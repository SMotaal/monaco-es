import { X as TPromise, a4 as LinkedList, c as isFalsyOrWhitespace, b as empty, d as pad, e as format, f as escape, g as escapeRegExpCharacters, h as trim, i as ltrim, j as rtrim, k as convertSimple2RegExpPattern, l as stripWildcards, m as startsWith, n as endsWith, o as createRegExp, p as regExpLeadsToEndlessLoop, q as regExpContainsBackreference, r as canNormalize, s as normalizeNFC, t as normalizeNFD, u as firstNonWhitespaceIndex, v as getLeadingWhitespace, w as lastNonWhitespaceIndex, x as compare, y as compareIgnoreCase, z as equalsIgnoreCase, A as startsWithIgnoreCase, B as commonPrefixLength, C as commonSuffixLength, D as overlap, E as isHighSurrogate, F as isLowSurrogate, G as containsRTL, H as containsEmoji, I as isBasicASCII, J as containsFullWidthCharacter, K as isFullWidthCharacter, L as lcut, M as removeAnsiEscapeCodes, N as UTF8_BOM_CHARACTER, O as startsWithUTF8BOM, P as stripUTF8BOM, Q as safeBtoa, R as repeat, S as fuzzyContains, T as containsUppercaseCharacter, U as strings, a5 as dispose, a6 as Event, V as Emitter, a7 as ResolvedKeybinding, a8 as ResolvedKeybindingPart, a9 as KeyCodeUtils, aa as isWindows, ab as isLinux, Z as URI, ac as isMacintosh, ad as TernarySearchTree, ae as ResourceMap, af as SimpleKeybinding, ag as Platform, ah as isNative, a1 as isWeb, a3 as globals, ai as setImmediate, aj as OS, ak as mapEvent, al as TimeoutTimer, am as onUnexpectedError, $ as Disposable, an as createKeybinding, ao as ImmortalReference, ap as combinedDisposable, aq as LRUCache, ar as ErrorHandler, as as errorHandler, at as onUnexpectedExternalError, _ as transformErrorForSerialization, au as isPromiseCanceledError, av as canceled, aw as illegalArgument, ax as illegalState, ay as RunOnceScheduler, az as IntervalTimer, aA as filterEvent, aB as EventBufferer, aC as chain, aD as anyEvent, aE as empty$1, aF as isDisposable, aG as toDisposable, aH as debounceEvent, a0 as ShallowCancelThenPromise, aI as wireCancellationToken, aJ as Promise$1, aK as PPromise, aL as once, aM as EventMultiplexer, aN as Relay, a2 as stringDiff, aO as Debug, aP as MyArray, a as LcsDiff, aQ as Delayer, aR as toPromiseLike } from './base.js';
import { c as Position, j as Token, k as TokenizationResult, l as TokenizationResult2, a as Range, m as DEFAULT_WORD_REGEXP, h as ensureValidWordDefinition, n as USUAL_WORD_SEPARATORS, o as CharacterClassifier, p as Selection, g as getWordAtText, q as SelectionDirection, r as PrefixSumComputerWithCache, s as PrefixSumComputer, t as toUint32Array, i as createMonacoBaseAPI } from './editor.js';
import { a as logOnceWebWorkerWarning, b as SimpleWorkerClient, c as EditorSimpleWorkerImpl } from './workers.js';

const css = "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n\n/* Default standalone editor font */\n.monaco-editor {\n\tfont-family: -apple-system, BlinkMacSystemFont, \"Segoe WPC\", \"Segoe UI\", \"HelveticaNeue-Light\", \"Ubuntu\", \"Droid Sans\", sans-serif;\n}\n\n.monaco-menu .monaco-action-bar.vertical .action-item .action-label:focus {\n\tcolor: #0059AC;\n\tstroke-width: 1.2px;\n\ttext-shadow: 0px 0px 0.15px #0059AC;\n}\n\n.monaco-editor.vs-dark .monaco-menu .monaco-action-bar.vertical .action-item .action-label:focus,\n.monaco-editor.hc-black .monaco-menu .monaco-action-bar.vertical .action-item .action-label:focus {\n\tcolor: #ACDDFF;\n\tstroke-width: 1.2px;\n\ttext-shadow: 0px 0px 0.15px #ACDDFF;\n}\n\n.monaco-editor-hover p {\n\tmargin: 0;\n}\n\n/* The hc-black theme is already high contrast optimized */\n.monaco-editor.hc-black {\n\t-ms-high-contrast-adjust: none;\n}\n/* In case the browser goes into high contrast mode and the editor is not configured with the hc-black theme */\n@media screen and (-ms-high-contrast:active) {\n\n\t/* current line highlight */\n\t.monaco-editor.vs .view-overlays .current-line,\n\t.monaco-editor.vs-dark .view-overlays .current-line {\n\t\tborder-color: windowtext !important;\n\t\tborder-left: 0;\n\t\tborder-right: 0;\n\t}\n\n\t/* view cursors */\n\t.monaco-editor.vs .cursor,\n\t.monaco-editor.vs-dark .cursor {\n\t\tbackground-color: windowtext !important;\n\t}\n\t/* dnd target */\n\t.monaco-editor.vs .dnd-target,\n\t.monaco-editor.vs-dark .dnd-target {\n\t\tborder-color: windowtext !important;\n\t}\n\n\t/* selected text background */\n\t.monaco-editor.vs .selected-text,\n\t.monaco-editor.vs-dark .selected-text {\n\t\tbackground-color: highlight !important;\n\t}\n\n\t/* allow the text to have a transparent background. */\n\t.monaco-editor.vs .view-line,\n\t.monaco-editor.vs-dark .view-line {\n\t\t-ms-high-contrast-adjust: none;\n\t}\n\n\t/* text color */\n\t.monaco-editor.vs .view-line span,\n\t.monaco-editor.vs-dark .view-line span {\n\t\tcolor: windowtext !important;\n\t}\n\t/* selected text color */\n\t.monaco-editor.vs .view-line span.inline-selected-text,\n\t.monaco-editor.vs-dark .view-line span.inline-selected-text {\n\t\tcolor: highlighttext !important;\n\t}\n\n\t/* allow decorations */\n\t.monaco-editor.vs .view-overlays,\n\t.monaco-editor.vs-dark .view-overlays {\n\t\t-ms-high-contrast-adjust: none;\n\t}\n\n\t/* various decorations */\n\t.monaco-editor.vs .selectionHighlight,\n\t.monaco-editor.vs-dark .selectionHighlight,\n\t.monaco-editor.vs .wordHighlight,\n\t.monaco-editor.vs-dark .wordHighlight,\n\t.monaco-editor.vs .wordHighlightStrong,\n\t.monaco-editor.vs-dark .wordHighlightStrong,\n\t.monaco-editor.vs .reference-decoration,\n\t.monaco-editor.vs-dark .reference-decoration {\n\t\tborder: 2px dotted highlight !important;\n\t\tbackground: transparent !important;\n\t\tbox-sizing: border-box;\n\t}\n\t.monaco-editor.vs .rangeHighlight,\n\t.monaco-editor.vs-dark .rangeHighlight {\n\t\tbackground: transparent !important;\n\t\tborder: 1px dotted activeborder !important;\n\t\tbox-sizing: border-box;\n\t}\n\t.monaco-editor.vs .bracket-match,\n\t.monaco-editor.vs-dark .bracket-match {\n\t\tborder-color: windowtext !important;\n\t\tbackground: transparent !important;\n\t}\n\n\t/* find widget */\n\t.monaco-editor.vs .findMatch,\n\t.monaco-editor.vs-dark .findMatch,\n\t.monaco-editor.vs .currentFindMatch,\n\t.monaco-editor.vs-dark .currentFindMatch {\n\t\tborder: 2px dotted activeborder !important;\n\t\tbackground: transparent !important;\n\t\tbox-sizing: border-box;\n\t}\n\t.monaco-editor.vs .find-widget,\n\t.monaco-editor.vs-dark .find-widget {\n\t\tborder: 1px solid windowtext;\n\t}\n\n\t/* list - used by suggest widget */\n\t.monaco-editor.vs .monaco-list .monaco-list-row,\n\t.monaco-editor.vs-dark .monaco-list .monaco-list-row {\n\t\t-ms-high-contrast-adjust: none;\n\t\tcolor: windowtext !important;\n\t}\n\t.monaco-editor.vs .monaco-list .monaco-list-row.focused,\n\t.monaco-editor.vs-dark .monaco-list .monaco-list-row.focused {\n\t\tcolor: highlighttext !important;\n\t\tbackground-color: highlight !important;\n\t}\n\t.monaco-editor.vs .monaco-list .monaco-list-row:hover,\n\t.monaco-editor.vs-dark .monaco-list .monaco-list-row:hover {\n\t\tbackground: transparent !important;\n\t\tborder: 1px solid highlight;\n\t\tbox-sizing: border-box;\n\t}\n\n\t/* tree */\n\t.monaco-editor.vs .monaco-tree .monaco-tree-row,\n\t.monaco-editor.vs-dark .monaco-tree .monaco-tree-row {\n\t\t-ms-high-contrast-adjust: none;\n\t\tcolor: windowtext !important;\n\t}\n\t.monaco-editor.vs .monaco-tree .monaco-tree-row.selected,\n\t.monaco-editor.vs-dark .monaco-tree .monaco-tree-row.selected,\n\t.monaco-editor.vs .monaco-tree .monaco-tree-row.focused,\n\t.monaco-editor.vs-dark .monaco-tree .monaco-tree-row.focused {\n\t\tcolor: highlighttext !important;\n\t\tbackground-color: highlight !important;\n\t}\n\t.monaco-editor.vs .monaco-tree .monaco-tree-row:hover,\n\t.monaco-editor.vs-dark .monaco-tree .monaco-tree-row:hover {\n\t\tbackground: transparent !important;\n\t\tborder: 1px solid highlight;\n\t\tbox-sizing: border-box;\n\t}\n\n\t/* scrollbars */\n\t.monaco-editor.vs .monaco-scrollable-element > .scrollbar,\n\t.monaco-editor.vs-dark .monaco-scrollable-element > .scrollbar {\n\t\t-ms-high-contrast-adjust: none;\n\t\tbackground: background !important;\n\t\tborder: 1px solid windowtext;\n\t\tbox-sizing: border-box;\n\t}\n\t.monaco-editor.vs .monaco-scrollable-element > .scrollbar > .slider,\n\t.monaco-editor.vs-dark .monaco-scrollable-element > .scrollbar > .slider {\n\t\tbackground: windowtext !important;\n\t}\n\t.monaco-editor.vs .monaco-scrollable-element > .scrollbar > .slider:hover,\n\t.monaco-editor.vs-dark .monaco-scrollable-element > .scrollbar > .slider:hover {\n\t\tbackground: highlight !important;\n\t}\n\t.monaco-editor.vs .monaco-scrollable-element > .scrollbar > .slider.active,\n\t.monaco-editor.vs-dark .monaco-scrollable-element > .scrollbar > .slider.active {\n\t\tbackground: highlight !important;\n\t}\n\n\t/* overview ruler */\n\t.monaco-editor.vs .decorationsOverviewRuler,\n\t.monaco-editor.vs-dark .decorationsOverviewRuler {\n\t\topacity: 0;\n\t}\n\n\t/* minimap */\n\t.monaco-editor.vs .minimap,\n\t.monaco-editor.vs-dark .minimap {\n\t\tdisplay: none;\n\t}\n\n\t/* squiggles */\n\t.monaco-editor.vs .squiggly-d-error,\n\t.monaco-editor.vs-dark .squiggly-d-error {\n\t\tbackground: transparent !important;\n\t\tborder-bottom: 4px double #E47777;\n\t}\n\t.monaco-editor.vs .squiggly-c-warning,\n\t.monaco-editor.vs-dark .squiggly-c-warning {\n\t\tborder-bottom: 4px double #71B771;\n\t}\n\t.monaco-editor.vs .squiggly-b-info,\n\t.monaco-editor.vs-dark .squiggly-b-info {\n\t\tborder-bottom: 4px double #71B771;\n\t}\n\t.monaco-editor.vs .squiggly-a-hint,\n\t.monaco-editor.vs-dark .squiggly-a-hint {\n\t\tborder-bottom: 4px double #6c6c6c;\n\t}\n\n\t/* contextmenu */\n\t.monaco-editor.vs .monaco-menu .monaco-action-bar.vertical .action-item .action-label:focus,\n\t.monaco-editor.vs-dark .monaco-menu .monaco-action-bar.vertical .action-item .action-label:focus {\n\t\t-ms-high-contrast-adjust: none;\n\t\tcolor: highlighttext !important;\n\t\tbackground-color: highlight !important;\n\t}\n\t.monaco-editor.vs .monaco-menu .monaco-action-bar.vertical .action-item .action-label:hover,\n\t.monaco-editor.vs-dark .monaco-menu .monaco-action-bar.vertical .action-item .action-label:hover {\n\t\t-ms-high-contrast-adjust: none;\n\t\tbackground: transparent !important;\n\t\tborder: 1px solid highlight;\n\t\tbox-sizing: border-box;\n\t}\n\n\t/* diff editor */\n\t.monaco-diff-editor.vs .diffOverviewRuler,\n\t.monaco-diff-editor.vs-dark .diffOverviewRuler {\n\t\tdisplay: none;\n\t}\n\t.monaco-editor.vs .line-insert,\n\t.monaco-editor.vs-dark .line-insert,\n\t.monaco-editor.vs .line-delete,\n\t.monaco-editor.vs-dark .line-delete {\n\t\tbackground: transparent !important;\n\t\tborder: 1px solid highlight !important;\n\t\tbox-sizing: border-box;\n\t}\n\t.monaco-editor.vs .char-insert,\n\t.monaco-editor.vs-dark .char-insert,\n\t.monaco-editor.vs .char-delete,\n\t.monaco-editor.vs-dark .char-delete {\n\t\tbackground: transparent !important;\n\t}\n}\n\n/*.monaco-editor.vs [tabindex=\"0\"]:focus {\n\toutline: 1px solid rgba(0, 122, 204, 0.4);\n\toutline-offset: -1px;\n\topacity: 1 !important;\n}\n\n.monaco-editor.vs-dark [tabindex=\"0\"]:focus {\n\toutline: 1px solid rgba(14, 99, 156, 0.6);\n\toutline-offset: -1px;\n\topacity: 1 !important;\n}*/\n";
  const element = ((css, src) => {
if (typeof document !== 'object')
console.info(`Skipped loading "${src}"`);
try {
const id = src
  .replace(/\.css.*$/, '')
  .replace(/[\\:]/g, '/')
  .replace(/[^\w\/]+/g, '');
return (
  document.querySelector(`style[id="${id}"]`) ||
  document.head.appendChild(
    Object.assign(document.createElement('style'), {
      id,
      textContent: `${css}\n\n /* sourceURL=${src} */`,
    }),
  )
);
} catch (exception) {
console.warn(`Failed load "${src}"`, exception);
}
})(css, "…monaco-editor/esm/vs/editor/standalone/browser/standalone-tokens.css");
  //@ sourceURL=/Users/daflair/Projects/packages/monaco-es/node_modules/monaco-editor/esm/vs/editor/standalone/browser/standalone-tokens.css

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
/**
 * @internal
 */
function isThemeColor(o) {
    return o && typeof o.id === 'string';
}
/**
 * The type of the `IEditor`.
 */
var EditorType = {
    ICodeEditor: 'vs.editor.ICodeEditor',
    IDiffEditor: 'vs.editor.IDiffEditor'
};
/**
 * Built-in commands.
 * @internal
 */
var Handler = {
    ExecuteCommand: 'executeCommand',
    ExecuteCommands: 'executeCommands',
    Type: 'type',
    ReplacePreviousChar: 'replacePreviousChar',
    CompositionStart: 'compositionStart',
    CompositionEnd: 'compositionEnd',
    Paste: 'paste',
    Cut: 'cut',
    Undo: 'undo',
    Redo: 'redo',
};

var editorCommon = /*#__PURE__*/Object.freeze({
	isThemeColor: isThemeColor,
	EditorType: EditorType,
	Handler: Handler
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
/**
 * A positioning preference for rendering content widgets.
 */
var ContentWidgetPositionPreference;
(function (ContentWidgetPositionPreference) {
    /**
     * Place the content widget exactly at a position
     */
    ContentWidgetPositionPreference[ContentWidgetPositionPreference["EXACT"] = 0] = "EXACT";
    /**
     * Place the content widget above a position
     */
    ContentWidgetPositionPreference[ContentWidgetPositionPreference["ABOVE"] = 1] = "ABOVE";
    /**
     * Place the content widget below a position
     */
    ContentWidgetPositionPreference[ContentWidgetPositionPreference["BELOW"] = 2] = "BELOW";
})(ContentWidgetPositionPreference || (ContentWidgetPositionPreference = {}));
/**
 * A positioning preference for rendering overlay widgets.
 */
var OverlayWidgetPositionPreference;
(function (OverlayWidgetPositionPreference) {
    /**
     * Position the overlay widget in the top right corner
     */
    OverlayWidgetPositionPreference[OverlayWidgetPositionPreference["TOP_RIGHT_CORNER"] = 0] = "TOP_RIGHT_CORNER";
    /**
     * Position the overlay widget in the bottom right corner
     */
    OverlayWidgetPositionPreference[OverlayWidgetPositionPreference["BOTTOM_RIGHT_CORNER"] = 1] = "BOTTOM_RIGHT_CORNER";
    /**
     * Position the overlay widget in the top center
     */
    OverlayWidgetPositionPreference[OverlayWidgetPositionPreference["TOP_CENTER"] = 2] = "TOP_CENTER";
})(OverlayWidgetPositionPreference || (OverlayWidgetPositionPreference = {}));
/**
 * Type of hit element with the mouse in the editor.
 */
var MouseTargetType;
(function (MouseTargetType) {
    /**
     * Mouse is on top of an unknown element.
     */
    MouseTargetType[MouseTargetType["UNKNOWN"] = 0] = "UNKNOWN";
    /**
     * Mouse is on top of the textarea used for input.
     */
    MouseTargetType[MouseTargetType["TEXTAREA"] = 1] = "TEXTAREA";
    /**
     * Mouse is on top of the glyph margin
     */
    MouseTargetType[MouseTargetType["GUTTER_GLYPH_MARGIN"] = 2] = "GUTTER_GLYPH_MARGIN";
    /**
     * Mouse is on top of the line numbers
     */
    MouseTargetType[MouseTargetType["GUTTER_LINE_NUMBERS"] = 3] = "GUTTER_LINE_NUMBERS";
    /**
     * Mouse is on top of the line decorations
     */
    MouseTargetType[MouseTargetType["GUTTER_LINE_DECORATIONS"] = 4] = "GUTTER_LINE_DECORATIONS";
    /**
     * Mouse is on top of the whitespace left in the gutter by a view zone.
     */
    MouseTargetType[MouseTargetType["GUTTER_VIEW_ZONE"] = 5] = "GUTTER_VIEW_ZONE";
    /**
     * Mouse is on top of text in the content.
     */
    MouseTargetType[MouseTargetType["CONTENT_TEXT"] = 6] = "CONTENT_TEXT";
    /**
     * Mouse is on top of empty space in the content (e.g. after line text or below last line)
     */
    MouseTargetType[MouseTargetType["CONTENT_EMPTY"] = 7] = "CONTENT_EMPTY";
    /**
     * Mouse is on top of a view zone in the content.
     */
    MouseTargetType[MouseTargetType["CONTENT_VIEW_ZONE"] = 8] = "CONTENT_VIEW_ZONE";
    /**
     * Mouse is on top of a content widget.
     */
    MouseTargetType[MouseTargetType["CONTENT_WIDGET"] = 9] = "CONTENT_WIDGET";
    /**
     * Mouse is on top of the decorations overview ruler.
     */
    MouseTargetType[MouseTargetType["OVERVIEW_RULER"] = 10] = "OVERVIEW_RULER";
    /**
     * Mouse is on top of a scrollbar.
     */
    MouseTargetType[MouseTargetType["SCROLLBAR"] = 11] = "SCROLLBAR";
    /**
     * Mouse is on top of an overlay widget.
     */
    MouseTargetType[MouseTargetType["OVERLAY_WIDGET"] = 12] = "OVERLAY_WIDGET";
    /**
     * Mouse is outside of the editor.
     */
    MouseTargetType[MouseTargetType["OUTSIDE_EDITOR"] = 13] = "OUTSIDE_EDITOR";
})(MouseTargetType || (MouseTargetType = {}));
/**
 *@internal
 */
function isCodeEditor(thing) {
    if (thing && typeof thing.getEditorType === 'function') {
        return thing.getEditorType() === EditorType.ICodeEditor;
    }
    else {
        return false;
    }
}
/**
 *@internal
 */
function isDiffEditor(thing) {
    if (thing && typeof thing.getEditorType === 'function') {
        return thing.getEditorType() === EditorType.IDiffEditor;
    }
    else {
        return false;
    }
}

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// ------ internal util
var _util;
(function (_util) {
    _util.serviceIds = new Map();
    _util.DI_TARGET = '$di$target';
    _util.DI_DEPENDENCIES = '$di$dependencies';
    function getServiceDependencies(ctor) {
        return ctor[_util.DI_DEPENDENCIES] || [];
    }
    _util.getServiceDependencies = getServiceDependencies;
})(_util || (_util = {}));
var IInstantiationService = createDecorator('instantiationService');
function storeServiceDependency(id, target, index, optional) {
    if (target[_util.DI_TARGET] === target) {
        target[_util.DI_DEPENDENCIES].push({ id: id, index: index, optional: optional });
    }
    else {
        target[_util.DI_DEPENDENCIES] = [{ id: id, index: index, optional: optional }];
        target[_util.DI_TARGET] = target;
    }
}
/**
 * A *only* valid way to create a {{ServiceIdentifier}}.
 */
function createDecorator(serviceId) {
    if (_util.serviceIds.has(serviceId)) {
        return _util.serviceIds.get(serviceId);
    }
    var id = function (target, key, index) {
        if (arguments.length !== 3) {
            throw new Error('@IServiceName-decorator can only be used to decorate a parameter');
        }
        storeServiceDependency(id, target, index, false);
    };
    id.toString = function () { return serviceId; };
    _util.serviceIds.set(serviceId, id);
    return id;
}
/**
 * Mark a service dependency as optional.
 */
function optional(serviceIdentifier) {
    return function (target, key, index) {
        if (arguments.length !== 3) {
            throw new Error('@optional-decorator can only be used to decorate a parameter');
        }
        storeServiceDependency(serviceIdentifier, target, index, true);
    };
}

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var IContextViewService = createDecorator('contextViewService');
var IContextMenuService = createDecorator('contextMenuService');

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var _typeof = {
    number: 'number',
    string: 'string',
    undefined: 'undefined',
    object: 'object',
    function: 'function'
};
/**
 * @returns whether the provided parameter is a JavaScript Array or not.
 */
function isArray(array) {
    if (Array.isArray) {
        return Array.isArray(array);
    }
    if (array && typeof (array.length) === _typeof.number && array.constructor === Array) {
        return true;
    }
    return false;
}
/**
 * @returns whether the provided parameter is a JavaScript String or not.
 */
function isString(str) {
    if (typeof (str) === _typeof.string || str instanceof String) {
        return true;
    }
    return false;
}
/**
 *
 * @returns whether the provided parameter is of type `object` but **not**
 *	`null`, an `array`, a `regexp`, nor a `date`.
 */
function isObject(obj) {
    // The method can't do a type cast since there are type (like strings) which
    // are subclasses of any put not positvely matched by the function. Hence type
    // narrowing results in wrong results.
    return typeof obj === _typeof.object
        && obj !== null
        && !Array.isArray(obj)
        && !(obj instanceof RegExp)
        && !(obj instanceof Date);
}
/**
 * In **contrast** to just checking `typeof` this will return `false` for `NaN`.
 * @returns whether the provided parameter is a JavaScript Number or not.
 */
function isNumber(obj) {
    if ((typeof (obj) === _typeof.number || obj instanceof Number) && !isNaN(obj)) {
        return true;
    }
    return false;
}
/**
 * @returns whether the provided parameter is a JavaScript Boolean or not.
 */
function isBoolean(obj) {
    return obj === true || obj === false;
}
/**
 * @returns whether the provided parameter is undefined.
 */
function isUndefined(obj) {
    return typeof (obj) === _typeof.undefined;
}
/**
 * @returns whether the provided parameter is undefined or null.
 */
function isUndefinedOrNull(obj) {
    return isUndefined(obj) || obj === null;
}
var hasOwnProperty = Object.prototype.hasOwnProperty;
/**
 * @returns whether the provided parameter is an empty JavaScript Object or not.
 */
function isEmptyObject(obj) {
    if (!isObject(obj)) {
        return false;
    }
    for (var key in obj) {
        if (hasOwnProperty.call(obj, key)) {
            return false;
        }
    }
    return true;
}
/**
 * @returns whether the provided parameter is a JavaScript Function or not.
 */
function isFunction(obj) {
    return typeof obj === _typeof.function;
}
function validateConstraints(args, constraints) {
    var len = Math.min(args.length, constraints.length);
    for (var i = 0; i < len; i++) {
        validateConstraint(args[i], constraints[i]);
    }
}
function validateConstraint(arg, constraint) {
    if (isString(constraint)) {
        if (typeof arg !== constraint) {
            throw new Error("argument does not match constraint: typeof " + constraint);
        }
    }
    else if (isFunction(constraint)) {
        if (arg instanceof constraint) {
            return;
        }
        if (!isUndefinedOrNull(arg) && arg.constructor === constraint) {
            return;
        }
        if (constraint.length === 1 && constraint.call(undefined, arg) === true) {
            return;
        }
        throw new Error("argument does not match one of these constraints: arg instanceof constraint, arg.constructor === constraint, nor constraint(arg) === true");
    }
}
/**
 * Creates a new object of the provided class and will call the constructor with
 * any additional argument supplied.
 */
function create(ctor) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
    }
    var obj = Object.create(ctor.prototype);
    ctor.apply(obj, args);
    return obj;
}

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var ICommandService = createDecorator('commandService');
var CommandsRegistry = new /** @class */ (function () {
    function class_1() {
        this._commands = new Map();
    }
    class_1.prototype.registerCommand = function (idOrCommand, handler) {
        var _this = this;
        if (!idOrCommand) {
            throw new Error("invalid command");
        }
        if (typeof idOrCommand === 'string') {
            if (!handler) {
                throw new Error("invalid command");
            }
            return this.registerCommand({ id: idOrCommand, handler: handler });
        }
        // add argument validation if rich command metadata is provided
        if (idOrCommand.description) {
            var constraints_1 = [];
            for (var _i = 0, _a = idOrCommand.description.args; _i < _a.length; _i++) {
                var arg = _a[_i];
                constraints_1.push(arg.constraint);
            }
            var actualHandler_1 = idOrCommand.handler;
            idOrCommand.handler = function (accessor) {
                var args = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    args[_i - 1] = arguments[_i];
                }
                validateConstraints(args, constraints_1);
                return actualHandler_1.apply(void 0, [accessor].concat(args));
            };
        }
        // find a place to store the command
        var id = idOrCommand.id;
        var commands = this._commands.get(id);
        if (!commands) {
            commands = new LinkedList();
            this._commands.set(id, commands);
        }
        var removeFn = commands.unshift(idOrCommand);
        return {
            dispose: function () {
                removeFn();
                if (_this._commands.get(id).isEmpty()) {
                    _this._commands.delete(id);
                }
            }
        };
    };
    class_1.prototype.getCommand = function (id) {
        var list = this._commands.get(id);
        if (!list || list.isEmpty()) {
            return undefined;
        }
        return list.iterator().next().value;
    };
    class_1.prototype.getCommands = function () {
        var _this = this;
        var result = Object.create(null);
        this._commands.forEach(function (value, key) {
            result[key] = _this.getCommand(key);
        });
        return result;
    };
    return class_1;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var KeybindingSource;
(function (KeybindingSource) {
    KeybindingSource[KeybindingSource["Default"] = 1] = "Default";
    KeybindingSource[KeybindingSource["User"] = 2] = "User";
})(KeybindingSource || (KeybindingSource = {}));
var IKeybindingService = createDecorator('keybindingService');

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var ContextKeyExprType;
(function (ContextKeyExprType) {
    ContextKeyExprType[ContextKeyExprType["Defined"] = 1] = "Defined";
    ContextKeyExprType[ContextKeyExprType["Not"] = 2] = "Not";
    ContextKeyExprType[ContextKeyExprType["Equals"] = 3] = "Equals";
    ContextKeyExprType[ContextKeyExprType["NotEquals"] = 4] = "NotEquals";
    ContextKeyExprType[ContextKeyExprType["And"] = 5] = "And";
    ContextKeyExprType[ContextKeyExprType["Regex"] = 6] = "Regex";
})(ContextKeyExprType || (ContextKeyExprType = {}));
var ContextKeyExpr = /** @class */ (function () {
    function ContextKeyExpr() {
    }
    ContextKeyExpr.has = function (key) {
        return new ContextKeyDefinedExpr(key);
    };
    ContextKeyExpr.equals = function (key, value) {
        return new ContextKeyEqualsExpr(key, value);
    };
    ContextKeyExpr.notEquals = function (key, value) {
        return new ContextKeyNotEqualsExpr(key, value);
    };
    ContextKeyExpr.regex = function (key, value) {
        return new ContextKeyRegexExpr(key, value);
    };
    ContextKeyExpr.not = function (key) {
        return new ContextKeyNotExpr(key);
    };
    ContextKeyExpr.and = function () {
        var expr = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            expr[_i] = arguments[_i];
        }
        return new ContextKeyAndExpr(expr);
    };
    ContextKeyExpr.deserialize = function (serialized) {
        var _this = this;
        if (!serialized) {
            return null;
        }
        var pieces = serialized.split('&&');
        var result = new ContextKeyAndExpr(pieces.map(function (p) { return _this._deserializeOne(p); }));
        return result.normalize();
    };
    ContextKeyExpr._deserializeOne = function (serializedOne) {
        serializedOne = serializedOne.trim();
        if (serializedOne.indexOf('!=') >= 0) {
            var pieces = serializedOne.split('!=');
            return new ContextKeyNotEqualsExpr(pieces[0].trim(), this._deserializeValue(pieces[1]));
        }
        if (serializedOne.indexOf('==') >= 0) {
            var pieces = serializedOne.split('==');
            return new ContextKeyEqualsExpr(pieces[0].trim(), this._deserializeValue(pieces[1]));
        }
        if (serializedOne.indexOf('=~') >= 0) {
            var pieces = serializedOne.split('=~');
            return new ContextKeyRegexExpr(pieces[0].trim(), this._deserializeRegexValue(pieces[1]));
        }
        if (/^\!\s*/.test(serializedOne)) {
            return new ContextKeyNotExpr(serializedOne.substr(1).trim());
        }
        return new ContextKeyDefinedExpr(serializedOne);
    };
    ContextKeyExpr._deserializeValue = function (serializedValue) {
        serializedValue = serializedValue.trim();
        if (serializedValue === 'true') {
            return true;
        }
        if (serializedValue === 'false') {
            return false;
        }
        var m = /^'([^']*)'$/.exec(serializedValue);
        if (m) {
            return m[1].trim();
        }
        return serializedValue;
    };
    ContextKeyExpr._deserializeRegexValue = function (serializedValue) {
        if (isFalsyOrWhitespace(serializedValue)) {
            console.warn('missing regexp-value for =~-expression');
            return null;
        }
        var start = serializedValue.indexOf('/');
        var end = serializedValue.lastIndexOf('/');
        if (start === end || start < 0 /* || to < 0 */) {
            console.warn("bad regexp-value '" + serializedValue + "', missing /-enclosure");
            return null;
        }
        var value = serializedValue.slice(start + 1, end);
        var caseIgnoreFlag = serializedValue[end + 1] === 'i' ? 'i' : '';
        try {
            return new RegExp(value, caseIgnoreFlag);
        }
        catch (e) {
            console.warn("bad regexp-value '" + serializedValue + "', parse error: " + e);
            return null;
        }
    };
    return ContextKeyExpr;
}());
function cmp(a, b) {
    var aType = a.getType();
    var bType = b.getType();
    if (aType !== bType) {
        return aType - bType;
    }
    switch (aType) {
        case ContextKeyExprType.Defined:
            return a.cmp(b);
        case ContextKeyExprType.Not:
            return a.cmp(b);
        case ContextKeyExprType.Equals:
            return a.cmp(b);
        case ContextKeyExprType.NotEquals:
            return a.cmp(b);
        case ContextKeyExprType.Regex:
            return a.cmp(b);
        default:
            throw new Error('Unknown ContextKeyExpr!');
    }
}
var ContextKeyDefinedExpr = /** @class */ (function () {
    function ContextKeyDefinedExpr(key) {
        this.key = key;
    }
    ContextKeyDefinedExpr.prototype.getType = function () {
        return ContextKeyExprType.Defined;
    };
    ContextKeyDefinedExpr.prototype.cmp = function (other) {
        if (this.key < other.key) {
            return -1;
        }
        if (this.key > other.key) {
            return 1;
        }
        return 0;
    };
    ContextKeyDefinedExpr.prototype.equals = function (other) {
        if (other instanceof ContextKeyDefinedExpr) {
            return (this.key === other.key);
        }
        return false;
    };
    ContextKeyDefinedExpr.prototype.evaluate = function (context) {
        return (!!context.getValue(this.key));
    };
    ContextKeyDefinedExpr.prototype.normalize = function () {
        return this;
    };
    ContextKeyDefinedExpr.prototype.serialize = function () {
        return this.key;
    };
    ContextKeyDefinedExpr.prototype.keys = function () {
        return [this.key];
    };
    return ContextKeyDefinedExpr;
}());
var ContextKeyEqualsExpr = /** @class */ (function () {
    function ContextKeyEqualsExpr(key, value) {
        this.key = key;
        this.value = value;
    }
    ContextKeyEqualsExpr.prototype.getType = function () {
        return ContextKeyExprType.Equals;
    };
    ContextKeyEqualsExpr.prototype.cmp = function (other) {
        if (this.key < other.key) {
            return -1;
        }
        if (this.key > other.key) {
            return 1;
        }
        if (this.value < other.value) {
            return -1;
        }
        if (this.value > other.value) {
            return 1;
        }
        return 0;
    };
    ContextKeyEqualsExpr.prototype.equals = function (other) {
        if (other instanceof ContextKeyEqualsExpr) {
            return (this.key === other.key && this.value === other.value);
        }
        return false;
    };
    ContextKeyEqualsExpr.prototype.evaluate = function (context) {
        /* tslint:disable:triple-equals */
        // Intentional ==
        return (context.getValue(this.key) == this.value);
        /* tslint:enable:triple-equals */
    };
    ContextKeyEqualsExpr.prototype.normalize = function () {
        if (typeof this.value === 'boolean') {
            if (this.value) {
                return new ContextKeyDefinedExpr(this.key);
            }
            return new ContextKeyNotExpr(this.key);
        }
        return this;
    };
    ContextKeyEqualsExpr.prototype.serialize = function () {
        if (typeof this.value === 'boolean') {
            return this.normalize().serialize();
        }
        return this.key + ' == \'' + this.value + '\'';
    };
    ContextKeyEqualsExpr.prototype.keys = function () {
        return [this.key];
    };
    return ContextKeyEqualsExpr;
}());
var ContextKeyNotEqualsExpr = /** @class */ (function () {
    function ContextKeyNotEqualsExpr(key, value) {
        this.key = key;
        this.value = value;
    }
    ContextKeyNotEqualsExpr.prototype.getType = function () {
        return ContextKeyExprType.NotEquals;
    };
    ContextKeyNotEqualsExpr.prototype.cmp = function (other) {
        if (this.key < other.key) {
            return -1;
        }
        if (this.key > other.key) {
            return 1;
        }
        if (this.value < other.value) {
            return -1;
        }
        if (this.value > other.value) {
            return 1;
        }
        return 0;
    };
    ContextKeyNotEqualsExpr.prototype.equals = function (other) {
        if (other instanceof ContextKeyNotEqualsExpr) {
            return (this.key === other.key && this.value === other.value);
        }
        return false;
    };
    ContextKeyNotEqualsExpr.prototype.evaluate = function (context) {
        /* tslint:disable:triple-equals */
        // Intentional !=
        return (context.getValue(this.key) != this.value);
        /* tslint:enable:triple-equals */
    };
    ContextKeyNotEqualsExpr.prototype.normalize = function () {
        if (typeof this.value === 'boolean') {
            if (this.value) {
                return new ContextKeyNotExpr(this.key);
            }
            return new ContextKeyDefinedExpr(this.key);
        }
        return this;
    };
    ContextKeyNotEqualsExpr.prototype.serialize = function () {
        if (typeof this.value === 'boolean') {
            return this.normalize().serialize();
        }
        return this.key + ' != \'' + this.value + '\'';
    };
    ContextKeyNotEqualsExpr.prototype.keys = function () {
        return [this.key];
    };
    return ContextKeyNotEqualsExpr;
}());
var ContextKeyNotExpr = /** @class */ (function () {
    function ContextKeyNotExpr(key) {
        this.key = key;
    }
    ContextKeyNotExpr.prototype.getType = function () {
        return ContextKeyExprType.Not;
    };
    ContextKeyNotExpr.prototype.cmp = function (other) {
        if (this.key < other.key) {
            return -1;
        }
        if (this.key > other.key) {
            return 1;
        }
        return 0;
    };
    ContextKeyNotExpr.prototype.equals = function (other) {
        if (other instanceof ContextKeyNotExpr) {
            return (this.key === other.key);
        }
        return false;
    };
    ContextKeyNotExpr.prototype.evaluate = function (context) {
        return (!context.getValue(this.key));
    };
    ContextKeyNotExpr.prototype.normalize = function () {
        return this;
    };
    ContextKeyNotExpr.prototype.serialize = function () {
        return '!' + this.key;
    };
    ContextKeyNotExpr.prototype.keys = function () {
        return [this.key];
    };
    return ContextKeyNotExpr;
}());
var ContextKeyRegexExpr = /** @class */ (function () {
    function ContextKeyRegexExpr(key, regexp) {
        this.key = key;
        this.regexp = regexp;
        //
    }
    ContextKeyRegexExpr.prototype.getType = function () {
        return ContextKeyExprType.Regex;
    };
    ContextKeyRegexExpr.prototype.cmp = function (other) {
        if (this.key < other.key) {
            return -1;
        }
        if (this.key > other.key) {
            return 1;
        }
        var source = this.regexp ? this.regexp.source : undefined;
        if (source < other.regexp.source) {
            return -1;
        }
        if (source > other.regexp.source) {
            return 1;
        }
        return 0;
    };
    ContextKeyRegexExpr.prototype.equals = function (other) {
        if (other instanceof ContextKeyRegexExpr) {
            var source = this.regexp ? this.regexp.source : undefined;
            return (this.key === other.key && source === other.regexp.source);
        }
        return false;
    };
    ContextKeyRegexExpr.prototype.evaluate = function (context) {
        return this.regexp ? this.regexp.test(context.getValue(this.key)) : false;
    };
    ContextKeyRegexExpr.prototype.normalize = function () {
        return this;
    };
    ContextKeyRegexExpr.prototype.serialize = function () {
        return this.key + " =~ /" + (this.regexp ? this.regexp.source : '<invalid>') + "/" + (this.regexp.ignoreCase ? 'i' : '');
    };
    ContextKeyRegexExpr.prototype.keys = function () {
        return [this.key];
    };
    return ContextKeyRegexExpr;
}());
var ContextKeyAndExpr = /** @class */ (function () {
    function ContextKeyAndExpr(expr) {
        this.expr = ContextKeyAndExpr._normalizeArr(expr);
    }
    ContextKeyAndExpr.prototype.getType = function () {
        return ContextKeyExprType.And;
    };
    ContextKeyAndExpr.prototype.equals = function (other) {
        if (other instanceof ContextKeyAndExpr) {
            if (this.expr.length !== other.expr.length) {
                return false;
            }
            for (var i = 0, len = this.expr.length; i < len; i++) {
                if (!this.expr[i].equals(other.expr[i])) {
                    return false;
                }
            }
            return true;
        }
        return false;
    };
    ContextKeyAndExpr.prototype.evaluate = function (context) {
        for (var i = 0, len = this.expr.length; i < len; i++) {
            if (!this.expr[i].evaluate(context)) {
                return false;
            }
        }
        return true;
    };
    ContextKeyAndExpr._normalizeArr = function (arr) {
        var expr = [];
        if (arr) {
            for (var i = 0, len = arr.length; i < len; i++) {
                var e = arr[i];
                if (!e) {
                    continue;
                }
                e = e.normalize();
                if (!e) {
                    continue;
                }
                if (e instanceof ContextKeyAndExpr) {
                    expr = expr.concat(e.expr);
                    continue;
                }
                expr.push(e);
            }
            expr.sort(cmp);
        }
        return expr;
    };
    ContextKeyAndExpr.prototype.normalize = function () {
        if (this.expr.length === 0) {
            return null;
        }
        if (this.expr.length === 1) {
            return this.expr[0];
        }
        return this;
    };
    ContextKeyAndExpr.prototype.serialize = function () {
        if (this.expr.length === 0) {
            return '';
        }
        if (this.expr.length === 1) {
            return this.normalize().serialize();
        }
        return this.expr.map(function (e) { return e.serialize(); }).join(' && ');
    };
    ContextKeyAndExpr.prototype.keys = function () {
        var result = [];
        for (var _i = 0, _a = this.expr; _i < _a.length; _i++) {
            var expr = _a[_i];
            result.push.apply(result, expr.keys());
        }
        return result;
    };
    return ContextKeyAndExpr;
}());
var RawContextKey = /** @class */ (function (_super) {
    __extends(RawContextKey, _super);
    function RawContextKey(key, defaultValue) {
        var _this = _super.call(this, key) || this;
        _this._defaultValue = defaultValue;
        return _this;
    }
    RawContextKey.prototype.bindTo = function (target) {
        return target.createKey(this.key, this._defaultValue);
    };
    RawContextKey.prototype.getValue = function (target) {
        return target.getContextKeyValue(this.key);
    };
    RawContextKey.prototype.toNegated = function () {
        return ContextKeyExpr.not(this.key);
    };
    RawContextKey.prototype.isEqualTo = function (value) {
        return ContextKeyExpr.equals(this.key, value);
    };
    RawContextKey.prototype.notEqualsTo = function (value) {
        return ContextKeyExpr.notEquals(this.key, value);
    };
    return RawContextKey;
}(ContextKeyDefinedExpr));
var IContextKeyService = createDecorator('contextKeyService');
var SET_CONTEXT_COMMAND_ID = 'setContext';

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var ICodeEditorService = createDecorator('codeEditorService');
/**
 * Uses `editor.getControl()` and returns either a `codeEditor` or a `diffEditor` or nothing.
 */
function getCodeOrDiffEditor(editor) {
    if (editor) {
        var control = editor.getControl();
        if (control) {
            if (isCodeEditor(control)) {
                return {
                    codeEditor: control,
                    diffEditor: null
                };
            }
            if (isDiffEditor(control)) {
                return {
                    codeEditor: null,
                    diffEditor: control
                };
            }
        }
    }
    return {
        codeEditor: null,
        diffEditor: null
    };
}
/**
 * Uses `editor.getControl()` and returns either the code editor, or the modified editor of a diff editor or nothing.
 */
function getCodeEditor(editor) {
    var r = getCodeOrDiffEditor(editor);
    return r.codeEditor || (r.diffEditor && r.diffEditor.getModifiedEditor()) || null;
}

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var ID_EDITOR_WORKER_SERVICE = 'editorWorkerService';
var IEditorWorkerService = createDecorator(ID_EDITOR_WORKER_SERVICE);

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var Schemas;
(function (Schemas) {
    /**
     * A schema that is used for models that exist in memory
     * only and that have no correspondence on a server or such.
     */
    Schemas.inMemory = 'inmemory';
    /**
     * A schema that is used for setting files
     */
    Schemas.vscode = 'vscode';
    /**
     * A schema that is used for internal private files
     */
    Schemas.internal = 'private';
    /**
     * A walk-through document.
     */
    Schemas.walkThrough = 'walkThrough';
    /**
     * An embedded code snippet.
     */
    Schemas.walkThroughSnippet = 'walkThroughSnippet';
    Schemas.http = 'http';
    Schemas.https = 'https';
    Schemas.file = 'file';
    Schemas.mailto = 'mailto';
    Schemas.untitled = 'untitled';
    Schemas.data = 'data';
})(Schemas || (Schemas = {}));

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
function _format(message, args) {
    var result;
    if (args.length === 0) {
        result = message;
    }
    else {
        result = message.replace(/\{(\d+)\}/g, function (match, rest) {
            var index = rest[0];
            return typeof args[index] !== 'undefined' ? args[index] : match;
        });
    }
    return result;
}
function localize(data, message) {
    var args = [];
    for (var _i = 2; _i < arguments.length; _i++) {
        args[_i - 2] = arguments[_i];
    }
    return _format(message, args);
}

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var Severity;
(function (Severity) {
    Severity[Severity["Ignore"] = 0] = "Ignore";
    Severity[Severity["Info"] = 1] = "Info";
    Severity[Severity["Warning"] = 2] = "Warning";
    Severity[Severity["Error"] = 3] = "Error";
})(Severity || (Severity = {}));
(function (Severity) {
    var _error = 'error';
    var _warning = 'warning';
    var _warn = 'warn';
    var _info = 'info';
    var _displayStrings = Object.create(null);
    _displayStrings[Severity.Error] = localize('sev.error', "Error");
    _displayStrings[Severity.Warning] = localize('sev.warning', "Warning");
    _displayStrings[Severity.Info] = localize('sev.info', "Info");
    /**
     * Parses 'error', 'warning', 'warn', 'info' in call casings
     * and falls back to ignore.
     */
    function fromValue(value) {
        if (!value) {
            return Severity.Ignore;
        }
        if (equalsIgnoreCase(_error, value)) {
            return Severity.Error;
        }
        if (equalsIgnoreCase(_warning, value) || equalsIgnoreCase(_warn, value)) {
            return Severity.Warning;
        }
        if (equalsIgnoreCase(_info, value)) {
            return Severity.Info;
        }
        return Severity.Ignore;
    }
    Severity.fromValue = fromValue;
})(Severity || (Severity = {}));
var Severity$1 = Severity;

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var AbstractKeybindingService = /** @class */ (function () {
    function AbstractKeybindingService(contextKeyService, commandService, telemetryService, notificationService, statusService) {
        this.toDispose = [];
        this._contextKeyService = contextKeyService;
        this._commandService = commandService;
        this._telemetryService = telemetryService;
        this._statusService = statusService;
        this._notificationService = notificationService;
        this._currentChord = null;
        this._currentChordStatusMessage = null;
        this._onDidUpdateKeybindings = new Emitter();
        this.toDispose.push(this._onDidUpdateKeybindings);
    }
    AbstractKeybindingService.prototype.dispose = function () {
        this.toDispose = dispose(this.toDispose);
    };
    Object.defineProperty(AbstractKeybindingService.prototype, "onDidUpdateKeybindings", {
        get: function () {
            return this._onDidUpdateKeybindings ? this._onDidUpdateKeybindings.event : Event.None; // Sinon stubbing walks properties on prototype
        },
        enumerable: true,
        configurable: true
    });
    AbstractKeybindingService.prototype.getDefaultKeybindingsContent = function () {
        return '';
    };
    AbstractKeybindingService.prototype.getDefaultKeybindings = function () {
        return this._getResolver().getDefaultKeybindings();
    };
    AbstractKeybindingService.prototype.getKeybindings = function () {
        return this._getResolver().getKeybindings();
    };
    AbstractKeybindingService.prototype.customKeybindingsCount = function () {
        return 0;
    };
    AbstractKeybindingService.prototype.lookupKeybindings = function (commandId) {
        return this._getResolver().lookupKeybindings(commandId).map(function (item) { return item.resolvedKeybinding; });
    };
    AbstractKeybindingService.prototype.lookupKeybinding = function (commandId) {
        var result = this._getResolver().lookupPrimaryKeybinding(commandId);
        if (!result) {
            return null;
        }
        return result.resolvedKeybinding;
    };
    AbstractKeybindingService.prototype.softDispatch = function (e, target) {
        var keybinding = this.resolveKeyboardEvent(e);
        if (keybinding.isChord()) {
            console.warn('Unexpected keyboard event mapped to a chord');
            return null;
        }
        var firstPart = keybinding.getDispatchParts()[0];
        if (firstPart === null) {
            // cannot be dispatched, probably only modifier keys
            return null;
        }
        var contextValue = this._contextKeyService.getContext(target);
        var currentChord = this._currentChord ? this._currentChord.keypress : null;
        return this._getResolver().resolve(contextValue, currentChord, firstPart);
    };
    AbstractKeybindingService.prototype._dispatch = function (e, target) {
        var _this = this;
        var shouldPreventDefault = false;
        var keybinding = this.resolveKeyboardEvent(e);
        if (keybinding.isChord()) {
            console.warn('Unexpected keyboard event mapped to a chord');
            return null;
        }
        var firstPart = keybinding.getDispatchParts()[0];
        if (firstPart === null) {
            // cannot be dispatched, probably only modifier keys
            return shouldPreventDefault;
        }
        var contextValue = this._contextKeyService.getContext(target);
        var currentChord = this._currentChord ? this._currentChord.keypress : null;
        var keypressLabel = keybinding.getLabel();
        var resolveResult = this._getResolver().resolve(contextValue, currentChord, firstPart);
        if (resolveResult && resolveResult.enterChord) {
            shouldPreventDefault = true;
            this._currentChord = {
                keypress: firstPart,
                label: keypressLabel
            };
            if (this._statusService) {
                this._currentChordStatusMessage = this._statusService.setStatusMessage(localize('first.chord', "({0}) was pressed. Waiting for second key of chord...", keypressLabel));
            }
            return shouldPreventDefault;
        }
        if (this._statusService && this._currentChord) {
            if (!resolveResult || !resolveResult.commandId) {
                this._statusService.setStatusMessage(localize('missing.chord', "The key combination ({0}, {1}) is not a command.", this._currentChord.label, keypressLabel), 10 * 1000 /* 10s */);
                shouldPreventDefault = true;
            }
        }
        if (this._currentChordStatusMessage) {
            this._currentChordStatusMessage.dispose();
            this._currentChordStatusMessage = null;
        }
        this._currentChord = null;
        if (resolveResult && resolveResult.commandId) {
            if (!resolveResult.bubble) {
                shouldPreventDefault = true;
            }
            this._commandService.executeCommand(resolveResult.commandId, resolveResult.commandArgs || {}).done(undefined, function (err) {
                _this._notificationService.warn(err);
            });
            /* __GDPR__
                "workbenchActionExecuted" : {
                    "id" : { "classification": "SystemMetaData", "purpose": "FeatureInsight" },
                    "from": { "classification": "SystemMetaData", "purpose": "FeatureInsight" }
                }
            */
            this._telemetryService.publicLog('workbenchActionExecuted', { id: resolveResult.commandId, from: 'keybinding' });
        }
        return shouldPreventDefault;
    };
    return AbstractKeybindingService;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var ModifierLabelProvider = /** @class */ (function () {
    function ModifierLabelProvider(mac, windows, linux) {
        if (linux === void 0) { linux = windows; }
        this.modifierLabels = [null];
        this.modifierLabels[2 /* Macintosh */] = mac;
        this.modifierLabels[1 /* Windows */] = windows;
        this.modifierLabels[3 /* Linux */] = linux;
    }
    ModifierLabelProvider.prototype.toLabel = function (firstPartMod, firstPartKey, chordPartMod, chordPartKey, OS$$1) {
        if (firstPartKey === null && chordPartKey === null) {
            return null;
        }
        return _asString(firstPartMod, firstPartKey, chordPartMod, chordPartKey, this.modifierLabels[OS$$1]);
    };
    return ModifierLabelProvider;
}());
/**
 * A label provider that prints modifiers in a suitable format for displaying in the UI.
 */
var UILabelProvider = new ModifierLabelProvider({
    ctrlKey: '⌃',
    shiftKey: '⇧',
    altKey: '⌥',
    metaKey: '⌘',
    separator: '',
}, {
    ctrlKey: localize({ key: 'ctrlKey', comment: ['This is the short form for the Control key on the keyboard'] }, "Ctrl"),
    shiftKey: localize({ key: 'shiftKey', comment: ['This is the short form for the Shift key on the keyboard'] }, "Shift"),
    altKey: localize({ key: 'altKey', comment: ['This is the short form for the Alt key on the keyboard'] }, "Alt"),
    metaKey: localize({ key: 'windowsKey', comment: ['This is the short form for the Windows key on the keyboard'] }, "Windows"),
    separator: '+',
});
/**
 * A label provider that prints modifiers in a suitable format for ARIA.
 */
var AriaLabelProvider = new ModifierLabelProvider({
    ctrlKey: localize({ key: 'ctrlKey.long', comment: ['This is the long form for the Control key on the keyboard'] }, "Control"),
    shiftKey: localize({ key: 'shiftKey.long', comment: ['This is the long form for the Shift key on the keyboard'] }, "Shift"),
    altKey: localize({ key: 'altKey.long', comment: ['This is the long form for the Alt key on the keyboard'] }, "Alt"),
    metaKey: localize({ key: 'cmdKey.long', comment: ['This is the long form for the Command key on the keyboard'] }, "Command"),
    separator: '+',
}, {
    ctrlKey: localize({ key: 'ctrlKey.long', comment: ['This is the long form for the Control key on the keyboard'] }, "Control"),
    shiftKey: localize({ key: 'shiftKey.long', comment: ['This is the long form for the Shift key on the keyboard'] }, "Shift"),
    altKey: localize({ key: 'altKey.long', comment: ['This is the long form for the Alt key on the keyboard'] }, "Alt"),
    metaKey: localize({ key: 'windowsKey.long', comment: ['This is the long form for the Windows key on the keyboard'] }, "Windows"),
    separator: '+',
});
/**
 * A label provider that prints modifiers in a suitable format for Electron Accelerators.
 * See https://github.com/electron/electron/blob/master/docs/api/accelerator.md
 */
var ElectronAcceleratorLabelProvider = new ModifierLabelProvider({
    ctrlKey: 'Ctrl',
    shiftKey: 'Shift',
    altKey: 'Alt',
    metaKey: 'Cmd',
    separator: '+',
}, {
    ctrlKey: 'Ctrl',
    shiftKey: 'Shift',
    altKey: 'Alt',
    metaKey: 'Super',
    separator: '+',
});
/**
 * A label provider that prints modifiers in a suitable format for user settings.
 */
var UserSettingsLabelProvider = new ModifierLabelProvider({
    ctrlKey: 'ctrl',
    shiftKey: 'shift',
    altKey: 'alt',
    metaKey: 'cmd',
    separator: '+',
}, {
    ctrlKey: 'ctrl',
    shiftKey: 'shift',
    altKey: 'alt',
    metaKey: 'win',
    separator: '+',
}, {
    ctrlKey: 'ctrl',
    shiftKey: 'shift',
    altKey: 'alt',
    metaKey: 'meta',
    separator: '+',
});
function _simpleAsString(modifiers, key, labels) {
    if (key === null) {
        return '';
    }
    var result = [];
    // translate modifier keys: Ctrl-Shift-Alt-Meta
    if (modifiers.ctrlKey) {
        result.push(labels.ctrlKey);
    }
    if (modifiers.shiftKey) {
        result.push(labels.shiftKey);
    }
    if (modifiers.altKey) {
        result.push(labels.altKey);
    }
    if (modifiers.metaKey) {
        result.push(labels.metaKey);
    }
    // the actual key
    result.push(key);
    return result.join(labels.separator);
}
function _asString(firstPartMod, firstPartKey, chordPartMod, chordPartKey, labels) {
    var result = _simpleAsString(firstPartMod, firstPartKey, labels);
    if (chordPartKey !== null) {
        result += ' ';
        result += _simpleAsString(chordPartMod, chordPartKey, labels);
    }
    return result;
}

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$1 = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * Do not instantiate. Use KeybindingService to get a ResolvedKeybinding seeded with information about the current kb layout.
 */
var USLayoutResolvedKeybinding = /** @class */ (function (_super) {
    __extends$1(USLayoutResolvedKeybinding, _super);
    function USLayoutResolvedKeybinding(actual, OS$$1) {
        var _this = _super.call(this) || this;
        _this._os = OS$$1;
        if (actual === null) {
            throw new Error("Invalid USLayoutResolvedKeybinding");
        }
        else if (actual.type === 2 /* Chord */) {
            _this._firstPart = actual.firstPart;
            _this._chordPart = actual.chordPart;
        }
        else {
            _this._firstPart = actual;
            _this._chordPart = null;
        }
        return _this;
    }
    USLayoutResolvedKeybinding.prototype._keyCodeToUILabel = function (keyCode) {
        if (this._os === 2 /* Macintosh */) {
            switch (keyCode) {
                case 15 /* LeftArrow */:
                    return '←';
                case 16 /* UpArrow */:
                    return '↑';
                case 17 /* RightArrow */:
                    return '→';
                case 18 /* DownArrow */:
                    return '↓';
            }
        }
        return KeyCodeUtils.toString(keyCode);
    };
    USLayoutResolvedKeybinding.prototype._getUILabelForKeybinding = function (keybinding) {
        if (!keybinding) {
            return null;
        }
        if (keybinding.isDuplicateModifierCase()) {
            return '';
        }
        return this._keyCodeToUILabel(keybinding.keyCode);
    };
    USLayoutResolvedKeybinding.prototype.getLabel = function () {
        var firstPart = this._getUILabelForKeybinding(this._firstPart);
        var chordPart = this._getUILabelForKeybinding(this._chordPart);
        return UILabelProvider.toLabel(this._firstPart, firstPart, this._chordPart, chordPart, this._os);
    };
    USLayoutResolvedKeybinding.prototype._getAriaLabelForKeybinding = function (keybinding) {
        if (!keybinding) {
            return null;
        }
        if (keybinding.isDuplicateModifierCase()) {
            return '';
        }
        return KeyCodeUtils.toString(keybinding.keyCode);
    };
    USLayoutResolvedKeybinding.prototype.getAriaLabel = function () {
        var firstPart = this._getAriaLabelForKeybinding(this._firstPart);
        var chordPart = this._getAriaLabelForKeybinding(this._chordPart);
        return AriaLabelProvider.toLabel(this._firstPart, firstPart, this._chordPart, chordPart, this._os);
    };
    USLayoutResolvedKeybinding.prototype._keyCodeToElectronAccelerator = function (keyCode) {
        if (keyCode >= 93 /* NUMPAD_0 */ && keyCode <= 108 /* NUMPAD_DIVIDE */) {
            // Electron cannot handle numpad keys
            return null;
        }
        switch (keyCode) {
            case 16 /* UpArrow */:
                return 'Up';
            case 18 /* DownArrow */:
                return 'Down';
            case 15 /* LeftArrow */:
                return 'Left';
            case 17 /* RightArrow */:
                return 'Right';
        }
        return KeyCodeUtils.toString(keyCode);
    };
    USLayoutResolvedKeybinding.prototype._getElectronAcceleratorLabelForKeybinding = function (keybinding) {
        if (!keybinding) {
            return null;
        }
        if (keybinding.isDuplicateModifierCase()) {
            return null;
        }
        return this._keyCodeToElectronAccelerator(keybinding.keyCode);
    };
    USLayoutResolvedKeybinding.prototype.getElectronAccelerator = function () {
        if (this._chordPart !== null) {
            // Electron cannot handle chords
            return null;
        }
        var firstPart = this._getElectronAcceleratorLabelForKeybinding(this._firstPart);
        return ElectronAcceleratorLabelProvider.toLabel(this._firstPart, firstPart, null, null, this._os);
    };
    USLayoutResolvedKeybinding.prototype._getUserSettingsLabelForKeybinding = function (keybinding) {
        if (!keybinding) {
            return null;
        }
        if (keybinding.isDuplicateModifierCase()) {
            return '';
        }
        return KeyCodeUtils.toUserSettingsUS(keybinding.keyCode);
    };
    USLayoutResolvedKeybinding.prototype.getUserSettingsLabel = function () {
        var firstPart = this._getUserSettingsLabelForKeybinding(this._firstPart);
        var chordPart = this._getUserSettingsLabelForKeybinding(this._chordPart);
        var result = UserSettingsLabelProvider.toLabel(this._firstPart, firstPart, this._chordPart, chordPart, this._os);
        return (result ? result.toLowerCase() : result);
    };
    USLayoutResolvedKeybinding.prototype.isWYSIWYG = function () {
        return true;
    };
    USLayoutResolvedKeybinding.prototype.isChord = function () {
        return (this._chordPart ? true : false);
    };
    USLayoutResolvedKeybinding.prototype.getParts = function () {
        return [
            this._toResolvedKeybindingPart(this._firstPart),
            this._toResolvedKeybindingPart(this._chordPart)
        ];
    };
    USLayoutResolvedKeybinding.prototype._toResolvedKeybindingPart = function (keybinding) {
        if (!keybinding) {
            return null;
        }
        return new ResolvedKeybindingPart(keybinding.ctrlKey, keybinding.shiftKey, keybinding.altKey, keybinding.metaKey, this._getUILabelForKeybinding(keybinding), this._getAriaLabelForKeybinding(keybinding));
    };
    USLayoutResolvedKeybinding.prototype.getDispatchParts = function () {
        var firstPart = this._firstPart ? USLayoutResolvedKeybinding.getDispatchStr(this._firstPart) : null;
        var chordPart = this._chordPart ? USLayoutResolvedKeybinding.getDispatchStr(this._chordPart) : null;
        return [firstPart, chordPart];
    };
    USLayoutResolvedKeybinding.getDispatchStr = function (keybinding) {
        if (keybinding.isModifierKey()) {
            return null;
        }
        var result = '';
        if (keybinding.ctrlKey) {
            result += 'ctrl+';
        }
        if (keybinding.shiftKey) {
            result += 'shift+';
        }
        if (keybinding.altKey) {
            result += 'alt+';
        }
        if (keybinding.metaKey) {
            result += 'meta+';
        }
        result += KeyCodeUtils.toString(keybinding.keyCode);
        return result;
    };
    return USLayoutResolvedKeybinding;
}(ResolvedKeybinding));

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
/**
 * Returns the last element of an array.
 * @param array The array.
 * @param n Which element from the end (default is zero).
 */
function tail(array, n) {
    if (n === void 0) { n = 0; }
    return array[array.length - (1 + n)];
}
function equals(one, other, itemEquals) {
    if (itemEquals === void 0) { itemEquals = function (a, b) { return a === b; }; }
    if (one.length !== other.length) {
        return false;
    }
    for (var i = 0, len = one.length; i < len; i++) {
        if (!itemEquals(one[i], other[i])) {
            return false;
        }
    }
    return true;
}
function binarySearch(array, key, comparator) {
    var low = 0, high = array.length - 1;
    while (low <= high) {
        var mid = ((low + high) / 2) | 0;
        var comp = comparator(array[mid], key);
        if (comp < 0) {
            low = mid + 1;
        }
        else if (comp > 0) {
            high = mid - 1;
        }
        else {
            return mid;
        }
    }
    return -(low + 1);
}
/**
 * Takes a sorted array and a function p. The array is sorted in such a way that all elements where p(x) is false
 * are located before all elements where p(x) is true.
 * @returns the least x for which p(x) is true or array.length if no element fullfills the given function.
 */
function findFirstInSorted(array, p) {
    var low = 0, high = array.length;
    if (high === 0) {
        return 0; // no children
    }
    while (low < high) {
        var mid = Math.floor((low + high) / 2);
        if (p(array[mid])) {
            high = mid;
        }
        else {
            low = mid + 1;
        }
    }
    return low;
}
/**
 * Like `Array#sort` but always stable. Usually runs a little slower `than Array#sort`
 * so only use this when actually needing stable sort.
 */
function mergeSort(data, compare$$1) {
    _divideAndMerge(data, compare$$1);
    return data;
}
function _divideAndMerge(data, compare$$1) {
    if (data.length <= 1) {
        // sorted
        return;
    }
    var p = (data.length / 2) | 0;
    var left = data.slice(0, p);
    var right = data.slice(p);
    _divideAndMerge(left, compare$$1);
    _divideAndMerge(right, compare$$1);
    var leftIdx = 0;
    var rightIdx = 0;
    var i = 0;
    while (leftIdx < left.length && rightIdx < right.length) {
        var ret = compare$$1(left[leftIdx], right[rightIdx]);
        if (ret <= 0) {
            // smaller_equal -> take left to preserve order
            data[i++] = left[leftIdx++];
        }
        else {
            // greater -> take right
            data[i++] = right[rightIdx++];
        }
    }
    while (leftIdx < left.length) {
        data[i++] = left[leftIdx++];
    }
    while (rightIdx < right.length) {
        data[i++] = right[rightIdx++];
    }
}
function groupBy(data, compare$$1) {
    var result = [];
    var currentGroup;
    for (var _i = 0, _a = mergeSort(data.slice(0), compare$$1); _i < _a.length; _i++) {
        var element = _a[_i];
        if (!currentGroup || compare$$1(currentGroup[0], element) !== 0) {
            currentGroup = [element];
            result.push(currentGroup);
        }
        else {
            currentGroup.push(element);
        }
    }
    return result;
}
/**
 * @returns a new array with all undefined or null values removed. The original array is not modified at all.
 */
function coalesce(array) {
    if (!array) {
        return array;
    }
    return array.filter(function (e) { return !!e; });
}
/**
 * @returns {{false}} if the provided object is an array
 * 	and not empty.
 */
function isFalsyOrEmpty(obj) {
    return !Array.isArray(obj) || obj.length === 0;
}
/**
 * Removes duplicates from the given array. The optional keyFn allows to specify
 * how elements are checked for equalness by returning a unique string for each.
 */
function distinct(array, keyFn) {
    if (!keyFn) {
        return array.filter(function (element, position) {
            return array.indexOf(element) === position;
        });
    }
    var seen = Object.create(null);
    return array.filter(function (elem) {
        var key = keyFn(elem);
        if (seen[key]) {
            return false;
        }
        seen[key] = true;
        return true;
    });
}
function firstIndex(array, fn) {
    for (var i = 0; i < array.length; i++) {
        var element = array[i];
        if (fn(element)) {
            return i;
        }
    }
    return -1;
}
function first(array, fn, notFoundValue) {
    if (notFoundValue === void 0) { notFoundValue = null; }
    var index = firstIndex(array, fn);
    return index < 0 ? notFoundValue : array[index];
}
function commonPrefixLength$1(one, other, equals) {
    if (equals === void 0) { equals = function (a, b) { return a === b; }; }
    var result = 0;
    for (var i = 0, len = Math.min(one.length, other.length); i < len && equals(one[i], other[i]); i++) {
        result++;
    }
    return result;
}
function flatten(arr) {
    return [].concat.apply([], arr);
}
function range(arg, to) {
    var from = typeof to === 'number' ? arg : 0;
    if (typeof to === 'number') {
        from = arg;
    }
    else {
        from = 0;
        to = arg;
    }
    var result = [];
    if (from <= to) {
        for (var i = from; i < to; i++) {
            result.push(i);
        }
    }
    else {
        for (var i = from; i > to; i--) {
            result.push(i);
        }
    }
    return result;
}
/**
 * Insert `insertArr` inside `target` at `insertIndex`.
 * Please don't touch unless you understand https://jsperf.com/inserting-an-array-within-an-array
 */
function arrayInsert(target, insertIndex, insertArr) {
    var before = target.slice(0, insertIndex);
    var after = target.slice(insertIndex);
    return before.concat(insertArr, after);
}

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var KeybindingResolver = /** @class */ (function () {
    function KeybindingResolver(defaultKeybindings, overrides) {
        this._defaultKeybindings = defaultKeybindings;
        this._defaultBoundCommands = new Map();
        for (var i = 0, len = defaultKeybindings.length; i < len; i++) {
            var command = defaultKeybindings[i].command;
            this._defaultBoundCommands.set(command, true);
        }
        this._map = new Map();
        this._lookupMap = new Map();
        this._keybindings = KeybindingResolver.combine(defaultKeybindings, overrides);
        for (var i = 0, len = this._keybindings.length; i < len; i++) {
            var k = this._keybindings[i];
            if (k.keypressFirstPart === null) {
                // unbound
                continue;
            }
            this._addKeyPress(k.keypressFirstPart, k);
        }
    }
    KeybindingResolver._isTargetedForRemoval = function (defaultKb, keypressFirstPart, keypressChordPart, command, when) {
        if (defaultKb.command !== command) {
            return false;
        }
        if (keypressFirstPart && defaultKb.keypressFirstPart !== keypressFirstPart) {
            return false;
        }
        if (keypressChordPart && defaultKb.keypressChordPart !== keypressChordPart) {
            return false;
        }
        if (when) {
            if (!defaultKb.when) {
                return false;
            }
            if (!when.equals(defaultKb.when)) {
                return false;
            }
        }
        return true;
    };
    /**
     * Looks for rules containing -command in `overrides` and removes them directly from `defaults`.
     */
    KeybindingResolver.combine = function (defaults, rawOverrides) {
        defaults = defaults.slice(0);
        var overrides = [];
        for (var i = 0, len = rawOverrides.length; i < len; i++) {
            var override = rawOverrides[i];
            if (!override.command || override.command.length === 0 || override.command.charAt(0) !== '-') {
                overrides.push(override);
                continue;
            }
            var command = override.command.substr(1);
            var keypressFirstPart = override.keypressFirstPart;
            var keypressChordPart = override.keypressChordPart;
            var when = override.when;
            for (var j = defaults.length - 1; j >= 0; j--) {
                if (this._isTargetedForRemoval(defaults[j], keypressFirstPart, keypressChordPart, command, when)) {
                    defaults.splice(j, 1);
                }
            }
        }
        return defaults.concat(overrides);
    };
    KeybindingResolver.prototype._addKeyPress = function (keypress, item) {
        var conflicts = this._map.get(keypress);
        if (typeof conflicts === 'undefined') {
            // There is no conflict so far
            this._map.set(keypress, [item]);
            this._addToLookupMap(item);
            return;
        }
        for (var i = conflicts.length - 1; i >= 0; i--) {
            var conflict = conflicts[i];
            if (conflict.command === item.command) {
                continue;
            }
            var conflictIsChord = (conflict.keypressChordPart !== null);
            var itemIsChord = (item.keypressChordPart !== null);
            if (conflictIsChord && itemIsChord && conflict.keypressChordPart !== item.keypressChordPart) {
                // The conflict only shares the chord start with this command
                continue;
            }
            if (KeybindingResolver.whenIsEntirelyIncluded(conflict.when, item.when)) {
                // `item` completely overwrites `conflict`
                // Remove conflict from the lookupMap
                this._removeFromLookupMap(conflict);
            }
        }
        conflicts.push(item);
        this._addToLookupMap(item);
    };
    KeybindingResolver.prototype._addToLookupMap = function (item) {
        if (!item.command) {
            return;
        }
        var arr = this._lookupMap.get(item.command);
        if (typeof arr === 'undefined') {
            arr = [item];
            this._lookupMap.set(item.command, arr);
        }
        else {
            arr.push(item);
        }
    };
    KeybindingResolver.prototype._removeFromLookupMap = function (item) {
        var arr = this._lookupMap.get(item.command);
        if (typeof arr === 'undefined') {
            return;
        }
        for (var i = 0, len = arr.length; i < len; i++) {
            if (arr[i] === item) {
                arr.splice(i, 1);
                return;
            }
        }
    };
    /**
     * Returns true if it is provable `a` implies `b`.
     * **Precondition**: Assumes `a` and `b` are normalized!
     */
    KeybindingResolver.whenIsEntirelyIncluded = function (a, b) {
        if (!b) {
            return true;
        }
        if (!a) {
            return false;
        }
        var aExpressions = ((a instanceof ContextKeyAndExpr) ? a.expr : [a]);
        var bExpressions = ((b instanceof ContextKeyAndExpr) ? b.expr : [b]);
        var aIndex = 0;
        for (var bIndex = 0; bIndex < bExpressions.length; bIndex++) {
            var bExpr = bExpressions[bIndex];
            var bExprMatched = false;
            while (!bExprMatched && aIndex < aExpressions.length) {
                var aExpr = aExpressions[aIndex];
                if (aExpr.equals(bExpr)) {
                    bExprMatched = true;
                }
                aIndex++;
            }
            if (!bExprMatched) {
                return false;
            }
        }
        return true;
    };
    KeybindingResolver.prototype.getDefaultBoundCommands = function () {
        return this._defaultBoundCommands;
    };
    KeybindingResolver.prototype.getDefaultKeybindings = function () {
        return this._defaultKeybindings;
    };
    KeybindingResolver.prototype.getKeybindings = function () {
        return this._keybindings;
    };
    KeybindingResolver.prototype.lookupKeybindings = function (commandId) {
        var items = this._lookupMap.get(commandId);
        if (typeof items === 'undefined' || items.length === 0) {
            return [];
        }
        // Reverse to get the most specific item first
        var result = [], resultLen = 0;
        for (var i = items.length - 1; i >= 0; i--) {
            result[resultLen++] = items[i];
        }
        return result;
    };
    KeybindingResolver.prototype.lookupPrimaryKeybinding = function (commandId) {
        var items = this._lookupMap.get(commandId);
        if (typeof items === 'undefined' || items.length === 0) {
            return null;
        }
        return items[items.length - 1];
    };
    KeybindingResolver.prototype.resolve = function (context, currentChord, keypress) {
        var lookupMap = null;
        if (currentChord !== null) {
            // Fetch all chord bindings for `currentChord`
            var candidates = this._map.get(currentChord);
            if (typeof candidates === 'undefined') {
                // No chords starting with `currentChord`
                return null;
            }
            lookupMap = [];
            for (var i = 0, len = candidates.length; i < len; i++) {
                var candidate = candidates[i];
                if (candidate.keypressChordPart === keypress) {
                    lookupMap.push(candidate);
                }
            }
        }
        else {
            var candidates = this._map.get(keypress);
            if (typeof candidates === 'undefined') {
                // No bindings with `keypress`
                return null;
            }
            lookupMap = candidates;
        }
        var result = this._findCommand(context, lookupMap);
        if (!result) {
            return null;
        }
        if (currentChord === null && result.keypressChordPart !== null) {
            return {
                enterChord: true,
                commandId: null,
                commandArgs: null,
                bubble: false
            };
        }
        return {
            enterChord: false,
            commandId: result.command,
            commandArgs: result.commandArgs,
            bubble: result.bubble
        };
    };
    KeybindingResolver.prototype._findCommand = function (context, matches) {
        for (var i = matches.length - 1; i >= 0; i--) {
            var k = matches[i];
            if (!KeybindingResolver.contextMatchesRules(context, k.when)) {
                continue;
            }
            return k;
        }
        return null;
    };
    KeybindingResolver.contextMatchesRules = function (context, rules) {
        if (!rules) {
            return true;
        }
        return rules.evaluate(context);
    };
    KeybindingResolver.getAllUnboundCommands = function (boundCommands) {
        var commands = CommandsRegistry.getCommands();
        var unboundCommands = [];
        for (var id in commands) {
            if (id[0] === '_' || id.indexOf('vscode.') === 0) { // private command
                continue;
            }
            if (typeof commands[id].description === 'object'
                && !isFalsyOrEmpty(commands[id].description.args)) { // command with args
                continue;
            }
            if (boundCommands.get(id) === true) {
                continue;
            }
            unboundCommands.push(id);
        }
        return unboundCommands;
    };
    return KeybindingResolver;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
/**
 * The forward slash path separator.
 */
var sep = '/';
/**
 * The native path separator depending on the OS.
 */
var nativeSep = isWindows ? '\\' : '/';
/**
 * @returns the directory name of a path.
 */
function dirname(path) {
    var idx = ~path.lastIndexOf('/') || ~path.lastIndexOf('\\');
    if (idx === 0) {
        return '.';
    }
    else if (~idx === 0) {
        return path[0];
    }
    else if (~idx === path.length - 1) {
        return dirname(path.substring(0, path.length - 1));
    }
    else {
        var res = path.substring(0, ~idx);
        if (isWindows && res[res.length - 1] === ':') {
            res += nativeSep; // make sure drive letters end with backslash
        }
        return res;
    }
}
/**
 * @returns the base name of a path.
 */
function basename(path) {
    var idx = ~path.lastIndexOf('/') || ~path.lastIndexOf('\\');
    if (idx === 0) {
        return path;
    }
    else if (~idx === path.length - 1) {
        return basename(path.substring(0, path.length - 1));
    }
    else {
        return path.substr(~idx + 1);
    }
}
/**
 * @returns {{.far}} from boo.far or the empty string.
 */
function extname(path) {
    path = basename(path);
    var idx = ~path.lastIndexOf('.');
    return idx ? path.substring(~idx) : '';
}
var _posixBadPath = /(\/\.\.?\/)|(\/\.\.?)$|^(\.\.?\/)|(\/\/+)|(\\)/;
var _winBadPath = /(\\\.\.?\\)|(\\\.\.?)$|^(\.\.?\\)|(\\\\+)|(\/)/;
function _isNormal(path, win) {
    return win
        ? !_winBadPath.test(path)
        : !_posixBadPath.test(path);
}
function normalize(path, toOSPath) {
    if (path === null || path === void 0) {
        return path;
    }
    var len = path.length;
    if (len === 0) {
        return '.';
    }
    var wantsBackslash = isWindows && toOSPath;
    if (_isNormal(path, wantsBackslash)) {
        return path;
    }
    var sep = wantsBackslash ? '\\' : '/';
    var root = getRoot(path, sep);
    // skip the root-portion of the path
    var start = root.length;
    var skip = false;
    var res = '';
    for (var end = root.length; end <= len; end++) {
        // either at the end or at a path-separator character
        if (end === len || path.charCodeAt(end) === 47 /* Slash */ || path.charCodeAt(end) === 92 /* Backslash */) {
            if (streql(path, start, end, '..')) {
                // skip current and remove parent (if there is already something)
                var prev_start = res.lastIndexOf(sep);
                var prev_part = res.slice(prev_start + 1);
                if ((root || prev_part.length > 0) && prev_part !== '..') {
                    res = prev_start === -1 ? '' : res.slice(0, prev_start);
                    skip = true;
                }
            }
            else if (streql(path, start, end, '.') && (root || res || end < len - 1)) {
                // skip current (if there is already something or if there is more to come)
                skip = true;
            }
            if (!skip) {
                var part = path.slice(start, end);
                if (res !== '' && res[res.length - 1] !== sep) {
                    res += sep;
                }
                res += part;
            }
            start = end + 1;
            skip = false;
        }
    }
    return root + res;
}
function streql(value, start, end, other) {
    return start + other.length === end && value.indexOf(other, start) === start;
}
/**
 * Computes the _root_ this path, like `getRoot('c:\files') === c:\`,
 * `getRoot('files:///files/path') === files:///`,
 * or `getRoot('\\server\shares\path') === \\server\shares\`
 */
function getRoot(path, sep) {
    if (sep === void 0) { sep = '/'; }
    if (!path) {
        return '';
    }
    var len = path.length;
    var code = path.charCodeAt(0);
    if (code === 47 /* Slash */ || code === 92 /* Backslash */) {
        code = path.charCodeAt(1);
        if (code === 47 /* Slash */ || code === 92 /* Backslash */) {
            // UNC candidate \\localhost\shares\ddd
            //               ^^^^^^^^^^^^^^^^^^^
            code = path.charCodeAt(2);
            if (code !== 47 /* Slash */ && code !== 92 /* Backslash */) {
                var pos_1 = 3;
                var start = pos_1;
                for (; pos_1 < len; pos_1++) {
                    code = path.charCodeAt(pos_1);
                    if (code === 47 /* Slash */ || code === 92 /* Backslash */) {
                        break;
                    }
                }
                code = path.charCodeAt(pos_1 + 1);
                if (start !== pos_1 && code !== 47 /* Slash */ && code !== 92 /* Backslash */) {
                    pos_1 += 1;
                    for (; pos_1 < len; pos_1++) {
                        code = path.charCodeAt(pos_1);
                        if (code === 47 /* Slash */ || code === 92 /* Backslash */) {
                            return path.slice(0, pos_1 + 1) // consume this separator
                                .replace(/[\\/]/g, sep);
                        }
                    }
                }
            }
        }
        // /user/far
        // ^
        return sep;
    }
    else if ((code >= 65 /* A */ && code <= 90 /* Z */) || (code >= 97 /* a */ && code <= 122 /* z */)) {
        // check for windows drive letter c:\ or c:
        if (path.charCodeAt(1) === 58 /* Colon */) {
            code = path.charCodeAt(2);
            if (code === 47 /* Slash */ || code === 92 /* Backslash */) {
                // C:\fff
                // ^^^
                return path.slice(0, 2) + sep;
            }
            else {
                // C:
                // ^^
                return path.slice(0, 2);
            }
        }
    }
    // check for URI
    // scheme://authority/path
    // ^^^^^^^^^^^^^^^^^^^
    var pos = path.indexOf('://');
    if (pos !== -1) {
        pos += 3; // 3 -> "://".length
        for (; pos < len; pos++) {
            code = path.charCodeAt(pos);
            if (code === 47 /* Slash */ || code === 92 /* Backslash */) {
                return path.slice(0, pos + 1); // consume this separator
            }
        }
    }
    return '';
}
var join = function () {
    // Not using a function with var-args because of how TS compiles
    // them to JS - it would result in 2*n runtime cost instead
    // of 1*n, where n is parts.length.
    var value = '';
    for (var i = 0; i < arguments.length; i++) {
        var part = arguments[i];
        if (i > 0) {
            // add the separater between two parts unless
            // there already is one
            var last = value.charCodeAt(value.length - 1);
            if (last !== 47 /* Slash */ && last !== 92 /* Backslash */) {
                var next = part.charCodeAt(0);
                if (next !== 47 /* Slash */ && next !== 92 /* Backslash */) {
                    value += sep;
                }
            }
        }
        value += part;
    }
    return normalize(value);
};
function isEqualOrParent(path, candidate, ignoreCase) {
    if (path === candidate) {
        return true;
    }
    if (!path || !candidate) {
        return false;
    }
    if (candidate.length > path.length) {
        return false;
    }
    if (ignoreCase) {
        var beginsWith = startsWithIgnoreCase(path, candidate);
        if (!beginsWith) {
            return false;
        }
        if (candidate.length === path.length) {
            return true; // same path, different casing
        }
        var sepOffset = candidate.length;
        if (candidate.charAt(candidate.length - 1) === nativeSep) {
            sepOffset--; // adjust the expected sep offset in case our candidate already ends in separator character
        }
        return path.charAt(sepOffset) === nativeSep;
    }
    if (candidate.charAt(candidate.length - 1) !== nativeSep) {
        candidate += nativeSep;
    }
    return path.indexOf(candidate) === 0;
}

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
function isEqualOrParent$1(resource, candidate, ignoreCase) {
    if (resource.scheme === candidate.scheme && resource.authority === candidate.authority) {
        if (resource.scheme === 'file') {
            return isEqualOrParent(resource.fsPath, candidate.fsPath, ignoreCase);
        }
        return isEqualOrParent(resource.path, candidate.path, ignoreCase);
    }
    return false;
}
function isEqual$1(first, second, ignoreCase) {
    var identityEquals = (first === second);
    if (identityEquals) {
        return true;
    }
    if (!first || !second) {
        return false;
    }
    if (ignoreCase) {
        return equalsIgnoreCase(first.toString(), second.toString());
    }
    return first.toString() === second.toString();
}

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$2 = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var IFileService = createDecorator('fileService');
var FileType;
(function (FileType) {
    FileType[FileType["Unknown"] = 0] = "Unknown";
    FileType[FileType["File"] = 1] = "File";
    FileType[FileType["Directory"] = 2] = "Directory";
    FileType[FileType["SymbolicLink"] = 64] = "SymbolicLink";
})(FileType || (FileType = {}));
var FileSystemProviderCapabilities;
(function (FileSystemProviderCapabilities) {
    FileSystemProviderCapabilities[FileSystemProviderCapabilities["FileReadWrite"] = 2] = "FileReadWrite";
    FileSystemProviderCapabilities[FileSystemProviderCapabilities["FileOpenReadWriteClose"] = 4] = "FileOpenReadWriteClose";
    FileSystemProviderCapabilities[FileSystemProviderCapabilities["FileFolderCopy"] = 8] = "FileFolderCopy";
    FileSystemProviderCapabilities[FileSystemProviderCapabilities["PathCaseSensitive"] = 1024] = "PathCaseSensitive";
})(FileSystemProviderCapabilities || (FileSystemProviderCapabilities = {}));
var FileOperation;
(function (FileOperation) {
    FileOperation[FileOperation["CREATE"] = 0] = "CREATE";
    FileOperation[FileOperation["DELETE"] = 1] = "DELETE";
    FileOperation[FileOperation["MOVE"] = 2] = "MOVE";
    FileOperation[FileOperation["COPY"] = 3] = "COPY";
})(FileOperation || (FileOperation = {}));
var FileOperationEvent = /** @class */ (function () {
    function FileOperationEvent(_resource, _operation, _target) {
        this._resource = _resource;
        this._operation = _operation;
        this._target = _target;
    }
    Object.defineProperty(FileOperationEvent.prototype, "resource", {
        get: function () {
            return this._resource;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FileOperationEvent.prototype, "target", {
        get: function () {
            return this._target;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FileOperationEvent.prototype, "operation", {
        get: function () {
            return this._operation;
        },
        enumerable: true,
        configurable: true
    });
    return FileOperationEvent;
}());
/**
 * Possible changes that can occur to a file.
 */
var FileChangeType;
(function (FileChangeType) {
    FileChangeType[FileChangeType["UPDATED"] = 0] = "UPDATED";
    FileChangeType[FileChangeType["ADDED"] = 1] = "ADDED";
    FileChangeType[FileChangeType["DELETED"] = 2] = "DELETED";
})(FileChangeType || (FileChangeType = {}));
var FileChangesEvent = /** @class */ (function () {
    function FileChangesEvent(changes) {
        this._changes = changes;
    }
    Object.defineProperty(FileChangesEvent.prototype, "changes", {
        get: function () {
            return this._changes;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns true if this change event contains the provided file with the given change type. In case of
     * type DELETED, this method will also return true if a folder got deleted that is the parent of the
     * provided file path.
     */
    FileChangesEvent.prototype.contains = function (resource, type) {
        if (!resource) {
            return false;
        }
        return this._changes.some(function (change) {
            if (change.type !== type) {
                return false;
            }
            // For deleted also return true when deleted folder is parent of target path
            if (type === FileChangeType.DELETED) {
                return isEqualOrParent$1(resource, change.resource, !isLinux /* ignorecase */);
            }
            return isEqual$1(resource, change.resource, !isLinux /* ignorecase */);
        });
    };
    /**
     * Returns the changes that describe added files.
     */
    FileChangesEvent.prototype.getAdded = function () {
        return this.getOfType(FileChangeType.ADDED);
    };
    /**
     * Returns if this event contains added files.
     */
    FileChangesEvent.prototype.gotAdded = function () {
        return this.hasType(FileChangeType.ADDED);
    };
    /**
     * Returns the changes that describe deleted files.
     */
    FileChangesEvent.prototype.getDeleted = function () {
        return this.getOfType(FileChangeType.DELETED);
    };
    /**
     * Returns if this event contains deleted files.
     */
    FileChangesEvent.prototype.gotDeleted = function () {
        return this.hasType(FileChangeType.DELETED);
    };
    /**
     * Returns the changes that describe updated files.
     */
    FileChangesEvent.prototype.getUpdated = function () {
        return this.getOfType(FileChangeType.UPDATED);
    };
    /**
     * Returns if this event contains updated files.
     */
    FileChangesEvent.prototype.gotUpdated = function () {
        return this.hasType(FileChangeType.UPDATED);
    };
    FileChangesEvent.prototype.getOfType = function (type) {
        return this._changes.filter(function (change) { return change.type === type; });
    };
    FileChangesEvent.prototype.hasType = function (type) {
        return this._changes.some(function (change) {
            return change.type === type;
        });
    };
    return FileChangesEvent;
}());
var FileOperationError = /** @class */ (function (_super) {
    __extends$2(FileOperationError, _super);
    function FileOperationError(message, fileOperationResult, options) {
        var _this = _super.call(this, message) || this;
        _this.fileOperationResult = fileOperationResult;
        _this.options = options;
        return _this;
    }
    FileOperationError.isFileOperationError = function (obj) {
        return obj instanceof Error && !isUndefinedOrNull(obj.fileOperationResult);
    };
    return FileOperationError;
}(Error));
var FileOperationResult;
(function (FileOperationResult) {
    FileOperationResult[FileOperationResult["FILE_IS_BINARY"] = 0] = "FILE_IS_BINARY";
    FileOperationResult[FileOperationResult["FILE_IS_DIRECTORY"] = 1] = "FILE_IS_DIRECTORY";
    FileOperationResult[FileOperationResult["FILE_NOT_FOUND"] = 2] = "FILE_NOT_FOUND";
    FileOperationResult[FileOperationResult["FILE_NOT_MODIFIED_SINCE"] = 3] = "FILE_NOT_MODIFIED_SINCE";
    FileOperationResult[FileOperationResult["FILE_MODIFIED_SINCE"] = 4] = "FILE_MODIFIED_SINCE";
    FileOperationResult[FileOperationResult["FILE_MOVE_CONFLICT"] = 5] = "FILE_MOVE_CONFLICT";
    FileOperationResult[FileOperationResult["FILE_READ_ONLY"] = 6] = "FILE_READ_ONLY";
    FileOperationResult[FileOperationResult["FILE_PERMISSION_DENIED"] = 7] = "FILE_PERMISSION_DENIED";
    FileOperationResult[FileOperationResult["FILE_TOO_LARGE"] = 8] = "FILE_TOO_LARGE";
    FileOperationResult[FileOperationResult["FILE_INVALID_PATH"] = 9] = "FILE_INVALID_PATH";
    FileOperationResult[FileOperationResult["FILE_EXCEED_MEMORY_LIMIT"] = 10] = "FILE_EXCEED_MEMORY_LIMIT";
})(FileOperationResult || (FileOperationResult = {}));
var FileKind;
(function (FileKind) {
    FileKind[FileKind["FILE"] = 0] = "FILE";
    FileKind[FileKind["FOLDER"] = 1] = "FOLDER";
    FileKind[FileKind["ROOT_FOLDER"] = 2] = "ROOT_FOLDER";
})(FileKind || (FileKind = {}));

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
function getPathLabel(resource, rootProvider, userHomeProvider) {
    if (!resource) {
        return null;
    }
    if (typeof resource === 'string') {
        resource = URI.file(resource);
    }
    // return early if the resource is neither file:// nor untitled://
    if (resource.scheme !== Schemas.file && resource.scheme !== Schemas.untitled) {
        return resource.with({ query: null, fragment: null }).toString(true);
    }
    // return early if we can resolve a relative path label from the root
    var baseResource = rootProvider ? rootProvider.getWorkspaceFolder(resource) : null;
    if (baseResource) {
        var hasMultipleRoots = rootProvider.getWorkspace().folders.length > 1;
        var pathLabel = void 0;
        if (isLinux ? baseResource.uri.fsPath === resource.fsPath : equalsIgnoreCase(baseResource.uri.fsPath, resource.fsPath)) {
            pathLabel = ''; // no label if pathes are identical
        }
        else {
            pathLabel = normalize(ltrim(resource.fsPath.substr(baseResource.uri.fsPath.length), nativeSep), true);
        }
        if (hasMultipleRoots) {
            var rootName = basename(baseResource.uri.fsPath);
            pathLabel = pathLabel ? join(rootName, pathLabel) : rootName; // always show root basename if there are multiple
        }
        return pathLabel;
    }
    // convert c:\something => C:\something
    if (hasDriveLetter(resource.fsPath)) {
        return normalize(normalizeDriveLetter(resource.fsPath), true);
    }
    // normalize and tildify (macOS, Linux only)
    var res = normalize(resource.fsPath, true);
    if (!isWindows && userHomeProvider) {
        res = tildify(res, userHomeProvider.userHome);
    }
    return res;
}
function getBaseLabel(resource) {
    if (!resource) {
        return null;
    }
    if (typeof resource === 'string') {
        resource = URI.file(resource);
    }
    var base = basename(resource.fsPath) || resource.fsPath /* can be empty string if '/' is passed in */;
    // convert c: => C:
    if (hasDriveLetter(base)) {
        return normalizeDriveLetter(base);
    }
    return base;
}
function hasDriveLetter(path) {
    return isWindows && path && path[1] === ':';
}
function normalizeDriveLetter(path) {
    if (hasDriveLetter(path)) {
        return path.charAt(0).toUpperCase() + path.slice(1);
    }
    return path;
}
var normalizedUserHomeCached = Object.create(null);
function tildify(path, userHome) {
    if (isWindows || !path || !userHome) {
        return path; // unsupported
    }
    // Keep a normalized user home path as cache to prevent accumulated string creation
    var normalizedUserHome = normalizedUserHomeCached.original === userHome ? normalizedUserHomeCached.normalized : void 0;
    if (!normalizedUserHome) {
        normalizedUserHome = "" + rtrim(userHome, sep) + sep;
        normalizedUserHomeCached = { original: userHome, normalized: normalizedUserHome };
    }
    // Linux: case sensitive, macOS: case insensitive
    if (isLinux ? startsWith(path, normalizedUserHome) : startsWithIgnoreCase(path, normalizedUserHome)) {
        path = "~/" + path.substr(normalizedUserHome.length);
    }
    return path;
}
var Type;
(function (Type) {
    Type[Type["TEXT"] = 0] = "TEXT";
    Type[Type["VARIABLE"] = 1] = "VARIABLE";
    Type[Type["SEPARATOR"] = 2] = "SEPARATOR";
})(Type || (Type = {}));

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var IWorkspacesMainService = createDecorator('workspacesMainService');
var IWorkspacesService = createDecorator('workspacesService');
var WORKSPACE_EXTENSION = 'code-workspace';
var WORKSPACE_FILTER = [{ name: localize('codeWorkspace', "Code Workspace"), extensions: [WORKSPACE_EXTENSION] }];

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var IWorkspaceContextService = createDecorator('contextService');
var WorkbenchState;
(function (WorkbenchState) {
    WorkbenchState[WorkbenchState["EMPTY"] = 1] = "EMPTY";
    WorkbenchState[WorkbenchState["FOLDER"] = 2] = "FOLDER";
    WorkbenchState[WorkbenchState["WORKSPACE"] = 3] = "WORKSPACE";
})(WorkbenchState || (WorkbenchState = {}));
var Workspace = /** @class */ (function () {
    function Workspace(_id, _name, folders, _configuration, _ctime) {
        if (_name === void 0) { _name = ''; }
        if (folders === void 0) { folders = []; }
        if (_configuration === void 0) { _configuration = null; }
        this._id = _id;
        this._name = _name;
        this._configuration = _configuration;
        this._ctime = _ctime;
        this._foldersMap = TernarySearchTree.forPaths();
        this.folders = folders;
    }
    Workspace.prototype.update = function (workspace) {
        this._id = workspace.id;
        this._name = workspace.name;
        this._configuration = workspace.configuration;
        this._ctime = workspace.ctime;
        this.folders = workspace.folders;
    };
    Object.defineProperty(Workspace.prototype, "folders", {
        get: function () {
            return this._folders;
        },
        set: function (folders) {
            this._folders = folders;
            this.updateFoldersMap();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Workspace.prototype, "id", {
        get: function () {
            return this._id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Workspace.prototype, "ctime", {
        get: function () {
            return this._ctime;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Workspace.prototype, "name", {
        get: function () {
            return this._name;
        },
        set: function (name) {
            this._name = name;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Workspace.prototype, "configuration", {
        get: function () {
            return this._configuration;
        },
        set: function (configuration) {
            this._configuration = configuration;
        },
        enumerable: true,
        configurable: true
    });
    Workspace.prototype.getFolder = function (resource) {
        if (!resource) {
            return null;
        }
        return this._foldersMap.findSubstr(resource.toString());
    };
    Workspace.prototype.updateFoldersMap = function () {
        this._foldersMap = TernarySearchTree.forPaths();
        for (var _i = 0, _a = this.folders; _i < _a.length; _i++) {
            var folder = _a[_i];
            this._foldersMap.set(folder.uri.toString(), folder);
        }
    };
    Workspace.prototype.toJSON = function () {
        return { id: this.id, folders: this.folders, name: this.name, configuration: this.configuration };
    };
    return Workspace;
}());
var WorkspaceFolder = /** @class */ (function () {
    function WorkspaceFolder(data, raw) {
        this.raw = raw;
        this.uri = data.uri;
        this.index = data.index;
        this.name = data.name;
    }
    WorkspaceFolder.prototype.toResource = function (relativePath) {
        return this.uri.with({ path: join(this.uri.path, relativePath) });
    };
    WorkspaceFolder.prototype.toJSON = function () {
        return { uri: this.uri, name: this.name, index: this.index };
    };
    return WorkspaceFolder;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var ScanError;
(function (ScanError) {
    ScanError[ScanError["None"] = 0] = "None";
    ScanError[ScanError["UnexpectedEndOfComment"] = 1] = "UnexpectedEndOfComment";
    ScanError[ScanError["UnexpectedEndOfString"] = 2] = "UnexpectedEndOfString";
    ScanError[ScanError["UnexpectedEndOfNumber"] = 3] = "UnexpectedEndOfNumber";
    ScanError[ScanError["InvalidUnicode"] = 4] = "InvalidUnicode";
    ScanError[ScanError["InvalidEscapeCharacter"] = 5] = "InvalidEscapeCharacter";
    ScanError[ScanError["InvalidCharacter"] = 6] = "InvalidCharacter";
})(ScanError || (ScanError = {}));
var SyntaxKind;
(function (SyntaxKind) {
    SyntaxKind[SyntaxKind["Unknown"] = 0] = "Unknown";
    SyntaxKind[SyntaxKind["OpenBraceToken"] = 1] = "OpenBraceToken";
    SyntaxKind[SyntaxKind["CloseBraceToken"] = 2] = "CloseBraceToken";
    SyntaxKind[SyntaxKind["OpenBracketToken"] = 3] = "OpenBracketToken";
    SyntaxKind[SyntaxKind["CloseBracketToken"] = 4] = "CloseBracketToken";
    SyntaxKind[SyntaxKind["CommaToken"] = 5] = "CommaToken";
    SyntaxKind[SyntaxKind["ColonToken"] = 6] = "ColonToken";
    SyntaxKind[SyntaxKind["NullKeyword"] = 7] = "NullKeyword";
    SyntaxKind[SyntaxKind["TrueKeyword"] = 8] = "TrueKeyword";
    SyntaxKind[SyntaxKind["FalseKeyword"] = 9] = "FalseKeyword";
    SyntaxKind[SyntaxKind["StringLiteral"] = 10] = "StringLiteral";
    SyntaxKind[SyntaxKind["NumericLiteral"] = 11] = "NumericLiteral";
    SyntaxKind[SyntaxKind["LineCommentTrivia"] = 12] = "LineCommentTrivia";
    SyntaxKind[SyntaxKind["BlockCommentTrivia"] = 13] = "BlockCommentTrivia";
    SyntaxKind[SyntaxKind["LineBreakTrivia"] = 14] = "LineBreakTrivia";
    SyntaxKind[SyntaxKind["Trivia"] = 15] = "Trivia";
    SyntaxKind[SyntaxKind["EOF"] = 16] = "EOF";
})(SyntaxKind || (SyntaxKind = {}));
/**
 * Creates a JSON scanner on the given text.
 * If ignoreTrivia is set, whitespaces or comments are ignored.
 */
function createScanner(text, ignoreTrivia) {
    if (ignoreTrivia === void 0) { ignoreTrivia = false; }
    var pos = 0, len = text.length, value = '', tokenOffset = 0, token = SyntaxKind.Unknown, scanError = ScanError.None;
    function scanHexDigits(count, exact) {
        var digits = 0;
        var value = 0;
        while (digits < count || !exact) {
            var ch = text.charCodeAt(pos);
            if (ch >= 48 /* _0 */ && ch <= 57 /* _9 */) {
                value = value * 16 + ch - 48 /* _0 */;
            }
            else if (ch >= 65 /* A */ && ch <= 70 /* F */) {
                value = value * 16 + ch - 65 /* A */ + 10;
            }
            else if (ch >= 97 /* a */ && ch <= 102 /* f */) {
                value = value * 16 + ch - 97 /* a */ + 10;
            }
            else {
                break;
            }
            pos++;
            digits++;
        }
        if (digits < count) {
            value = -1;
        }
        return value;
    }
    function setPosition(newPosition) {
        pos = newPosition;
        value = '';
        tokenOffset = 0;
        token = SyntaxKind.Unknown;
        scanError = ScanError.None;
    }
    function scanNumber() {
        var start = pos;
        if (text.charCodeAt(pos) === 48 /* _0 */) {
            pos++;
        }
        else {
            pos++;
            while (pos < text.length && isDigit(text.charCodeAt(pos))) {
                pos++;
            }
        }
        if (pos < text.length && text.charCodeAt(pos) === 46 /* dot */) {
            pos++;
            if (pos < text.length && isDigit(text.charCodeAt(pos))) {
                pos++;
                while (pos < text.length && isDigit(text.charCodeAt(pos))) {
                    pos++;
                }
            }
            else {
                scanError = ScanError.UnexpectedEndOfNumber;
                return text.substring(start, pos);
            }
        }
        var end = pos;
        if (pos < text.length && (text.charCodeAt(pos) === 69 /* E */ || text.charCodeAt(pos) === 101 /* e */)) {
            pos++;
            if (pos < text.length && text.charCodeAt(pos) === 43 /* plus */ || text.charCodeAt(pos) === 45 /* minus */) {
                pos++;
            }
            if (pos < text.length && isDigit(text.charCodeAt(pos))) {
                pos++;
                while (pos < text.length && isDigit(text.charCodeAt(pos))) {
                    pos++;
                }
                end = pos;
            }
            else {
                scanError = ScanError.UnexpectedEndOfNumber;
            }
        }
        return text.substring(start, end);
    }
    function scanString() {
        var result = '', start = pos;
        while (true) {
            if (pos >= len) {
                result += text.substring(start, pos);
                scanError = ScanError.UnexpectedEndOfString;
                break;
            }
            var ch = text.charCodeAt(pos);
            if (ch === 34 /* doubleQuote */) {
                result += text.substring(start, pos);
                pos++;
                break;
            }
            if (ch === 92 /* backslash */) {
                result += text.substring(start, pos);
                pos++;
                if (pos >= len) {
                    scanError = ScanError.UnexpectedEndOfString;
                    break;
                }
                ch = text.charCodeAt(pos++);
                switch (ch) {
                    case 34 /* doubleQuote */:
                        result += '\"';
                        break;
                    case 92 /* backslash */:
                        result += '\\';
                        break;
                    case 47 /* slash */:
                        result += '/';
                        break;
                    case 98 /* b */:
                        result += '\b';
                        break;
                    case 102 /* f */:
                        result += '\f';
                        break;
                    case 110 /* n */:
                        result += '\n';
                        break;
                    case 114 /* r */:
                        result += '\r';
                        break;
                    case 116 /* t */:
                        result += '\t';
                        break;
                    case 117 /* u */:
                        var ch_1 = scanHexDigits(4, true);
                        if (ch_1 >= 0) {
                            result += String.fromCharCode(ch_1);
                        }
                        else {
                            scanError = ScanError.InvalidUnicode;
                        }
                        break;
                    default:
                        scanError = ScanError.InvalidEscapeCharacter;
                }
                start = pos;
                continue;
            }
            if (ch >= 0 && ch <= 0x1f) {
                if (isLineBreak(ch)) {
                    result += text.substring(start, pos);
                    scanError = ScanError.UnexpectedEndOfString;
                    break;
                }
                else {
                    scanError = ScanError.InvalidCharacter;
                    // mark as error but continue with string
                }
            }
            pos++;
        }
        return result;
    }
    function scanNext() {
        value = '';
        scanError = ScanError.None;
        tokenOffset = pos;
        if (pos >= len) {
            // at the end
            tokenOffset = len;
            return token = SyntaxKind.EOF;
        }
        var code = text.charCodeAt(pos);
        // trivia: whitespace
        if (isWhiteSpace(code)) {
            do {
                pos++;
                value += String.fromCharCode(code);
                code = text.charCodeAt(pos);
            } while (isWhiteSpace(code));
            return token = SyntaxKind.Trivia;
        }
        // trivia: newlines
        if (isLineBreak(code)) {
            pos++;
            value += String.fromCharCode(code);
            if (code === 13 /* carriageReturn */ && text.charCodeAt(pos) === 10 /* lineFeed */) {
                pos++;
                value += '\n';
            }
            return token = SyntaxKind.LineBreakTrivia;
        }
        switch (code) {
            // tokens: []{}:,
            case 123 /* openBrace */:
                pos++;
                return token = SyntaxKind.OpenBraceToken;
            case 125 /* closeBrace */:
                pos++;
                return token = SyntaxKind.CloseBraceToken;
            case 91 /* openBracket */:
                pos++;
                return token = SyntaxKind.OpenBracketToken;
            case 93 /* closeBracket */:
                pos++;
                return token = SyntaxKind.CloseBracketToken;
            case 58 /* colon */:
                pos++;
                return token = SyntaxKind.ColonToken;
            case 44 /* comma */:
                pos++;
                return token = SyntaxKind.CommaToken;
            // strings
            case 34 /* doubleQuote */:
                pos++;
                value = scanString();
                return token = SyntaxKind.StringLiteral;
            // comments
            case 47 /* slash */:
                var start = pos - 1;
                // Single-line comment
                if (text.charCodeAt(pos + 1) === 47 /* slash */) {
                    pos += 2;
                    while (pos < len) {
                        if (isLineBreak(text.charCodeAt(pos))) {
                            break;
                        }
                        pos++;
                    }
                    value = text.substring(start, pos);
                    return token = SyntaxKind.LineCommentTrivia;
                }
                // Multi-line comment
                if (text.charCodeAt(pos + 1) === 42 /* asterisk */) {
                    pos += 2;
                    var safeLength = len - 1; // For lookahead.
                    var commentClosed = false;
                    while (pos < safeLength) {
                        var ch = text.charCodeAt(pos);
                        if (ch === 42 /* asterisk */ && text.charCodeAt(pos + 1) === 47 /* slash */) {
                            pos += 2;
                            commentClosed = true;
                            break;
                        }
                        pos++;
                    }
                    if (!commentClosed) {
                        pos++;
                        scanError = ScanError.UnexpectedEndOfComment;
                    }
                    value = text.substring(start, pos);
                    return token = SyntaxKind.BlockCommentTrivia;
                }
                // just a single slash
                value += String.fromCharCode(code);
                pos++;
                return token = SyntaxKind.Unknown;
            // numbers
            case 45 /* minus */:
                value += String.fromCharCode(code);
                pos++;
                if (pos === len || !isDigit(text.charCodeAt(pos))) {
                    return token = SyntaxKind.Unknown;
                }
            // found a minus, followed by a number so
            // we fall through to proceed with scanning
            // numbers
            case 48 /* _0 */:
            case 49 /* _1 */:
            case 50 /* _2 */:
            case 51 /* _3 */:
            case 52 /* _4 */:
            case 53 /* _5 */:
            case 54 /* _6 */:
            case 55 /* _7 */:
            case 56 /* _8 */:
            case 57 /* _9 */:
                value += scanNumber();
                return token = SyntaxKind.NumericLiteral;
            // literals and unknown symbols
            default:
                // is a literal? Read the full word.
                while (pos < len && isUnknownContentCharacter(code)) {
                    pos++;
                    code = text.charCodeAt(pos);
                }
                if (tokenOffset !== pos) {
                    value = text.substring(tokenOffset, pos);
                    // keywords: true, false, null
                    switch (value) {
                        case 'true': return token = SyntaxKind.TrueKeyword;
                        case 'false': return token = SyntaxKind.FalseKeyword;
                        case 'null': return token = SyntaxKind.NullKeyword;
                    }
                    return token = SyntaxKind.Unknown;
                }
                // some
                value += String.fromCharCode(code);
                pos++;
                return token = SyntaxKind.Unknown;
        }
    }
    function isUnknownContentCharacter(code) {
        if (isWhiteSpace(code) || isLineBreak(code)) {
            return false;
        }
        switch (code) {
            case 125 /* closeBrace */:
            case 93 /* closeBracket */:
            case 123 /* openBrace */:
            case 91 /* openBracket */:
            case 34 /* doubleQuote */:
            case 58 /* colon */:
            case 44 /* comma */:
                return false;
        }
        return true;
    }
    function scanNextNonTrivia() {
        var result;
        do {
            result = scanNext();
        } while (result >= SyntaxKind.LineCommentTrivia && result <= SyntaxKind.Trivia);
        return result;
    }
    return {
        setPosition: setPosition,
        getPosition: function () { return pos; },
        scan: ignoreTrivia ? scanNextNonTrivia : scanNext,
        getToken: function () { return token; },
        getTokenValue: function () { return value; },
        getTokenOffset: function () { return tokenOffset; },
        getTokenLength: function () { return pos - tokenOffset; },
        getTokenError: function () { return scanError; }
    };
}
function isWhiteSpace(ch) {
    return ch === 32 /* space */ || ch === 9 /* tab */ || ch === 11 /* verticalTab */ || ch === 12 /* formFeed */ ||
        ch === 160 /* nonBreakingSpace */ || ch === 5760 /* ogham */ || ch >= 8192 /* enQuad */ && ch <= 8203 /* zeroWidthSpace */ ||
        ch === 8239 /* narrowNoBreakSpace */ || ch === 8287 /* mathematicalSpace */ || ch === 12288 /* ideographicSpace */ || ch === 65279 /* byteOrderMark */;
}
function isLineBreak(ch) {
    return ch === 10 /* lineFeed */ || ch === 13 /* carriageReturn */ || ch === 8232 /* lineSeparator */ || ch === 8233 /* paragraphSeparator */;
}
function isDigit(ch) {
    return ch >= 48 /* _0 */ && ch <= 57 /* _9 */;
}
var ParseErrorCode;
(function (ParseErrorCode) {
    ParseErrorCode[ParseErrorCode["InvalidSymbol"] = 0] = "InvalidSymbol";
    ParseErrorCode[ParseErrorCode["InvalidNumberFormat"] = 1] = "InvalidNumberFormat";
    ParseErrorCode[ParseErrorCode["PropertyNameExpected"] = 2] = "PropertyNameExpected";
    ParseErrorCode[ParseErrorCode["ValueExpected"] = 3] = "ValueExpected";
    ParseErrorCode[ParseErrorCode["ColonExpected"] = 4] = "ColonExpected";
    ParseErrorCode[ParseErrorCode["CommaExpected"] = 5] = "CommaExpected";
    ParseErrorCode[ParseErrorCode["CloseBraceExpected"] = 6] = "CloseBraceExpected";
    ParseErrorCode[ParseErrorCode["CloseBracketExpected"] = 7] = "CloseBracketExpected";
    ParseErrorCode[ParseErrorCode["EndOfFileExpected"] = 8] = "EndOfFileExpected";
})(ParseErrorCode || (ParseErrorCode = {}));
/**
 * Parses the given text and invokes the visitor functions for each object, array and literal reached.
 */
function visit(text, visitor, options) {
    var _scanner = createScanner(text, false);
    function toNoArgVisit(visitFunction) {
        return visitFunction ? function () { return visitFunction(_scanner.getTokenOffset(), _scanner.getTokenLength()); } : function () { return true; };
    }
    function toOneArgVisit(visitFunction) {
        return visitFunction ? function (arg) { return visitFunction(arg, _scanner.getTokenOffset(), _scanner.getTokenLength()); } : function () { return true; };
    }
    var onObjectBegin = toNoArgVisit(visitor.onObjectBegin), onObjectProperty = toOneArgVisit(visitor.onObjectProperty), onObjectEnd = toNoArgVisit(visitor.onObjectEnd), onArrayBegin = toNoArgVisit(visitor.onArrayBegin), onArrayEnd = toNoArgVisit(visitor.onArrayEnd), onLiteralValue = toOneArgVisit(visitor.onLiteralValue), onSeparator = toOneArgVisit(visitor.onSeparator), onError = toOneArgVisit(visitor.onError);
    var disallowComments = options && options.disallowComments;
    var allowTrailingComma = options && options.allowTrailingComma;
    function scanNext() {
        while (true) {
            var token = _scanner.scan();
            switch (token) {
                case SyntaxKind.LineCommentTrivia:
                case SyntaxKind.BlockCommentTrivia:
                    if (disallowComments) {
                        handleError(ParseErrorCode.InvalidSymbol);
                    }
                    break;
                case SyntaxKind.Unknown:
                    handleError(ParseErrorCode.InvalidSymbol);
                    break;
                case SyntaxKind.Trivia:
                case SyntaxKind.LineBreakTrivia:
                    break;
                default:
                    return token;
            }
        }
    }
    function handleError(error, skipUntilAfter, skipUntil) {
        if (skipUntilAfter === void 0) { skipUntilAfter = []; }
        if (skipUntil === void 0) { skipUntil = []; }
        onError(error);
        if (skipUntilAfter.length + skipUntil.length > 0) {
            var token = _scanner.getToken();
            while (token !== SyntaxKind.EOF) {
                if (skipUntilAfter.indexOf(token) !== -1) {
                    scanNext();
                    break;
                }
                else if (skipUntil.indexOf(token) !== -1) {
                    break;
                }
                token = scanNext();
            }
        }
    }
    function parseString(isValue) {
        var value = _scanner.getTokenValue();
        if (isValue) {
            onLiteralValue(value);
        }
        else {
            onObjectProperty(value);
        }
        scanNext();
        return true;
    }
    function parseLiteral() {
        switch (_scanner.getToken()) {
            case SyntaxKind.NumericLiteral:
                var value = 0;
                try {
                    value = JSON.parse(_scanner.getTokenValue());
                    if (typeof value !== 'number') {
                        handleError(ParseErrorCode.InvalidNumberFormat);
                        value = 0;
                    }
                }
                catch (e) {
                    handleError(ParseErrorCode.InvalidNumberFormat);
                }
                onLiteralValue(value);
                break;
            case SyntaxKind.NullKeyword:
                onLiteralValue(null);
                break;
            case SyntaxKind.TrueKeyword:
                onLiteralValue(true);
                break;
            case SyntaxKind.FalseKeyword:
                onLiteralValue(false);
                break;
            default:
                return false;
        }
        scanNext();
        return true;
    }
    function parseProperty() {
        if (_scanner.getToken() !== SyntaxKind.StringLiteral) {
            handleError(ParseErrorCode.PropertyNameExpected, [], [SyntaxKind.CloseBraceToken, SyntaxKind.CommaToken]);
            return false;
        }
        parseString(false);
        if (_scanner.getToken() === SyntaxKind.ColonToken) {
            onSeparator(':');
            scanNext(); // consume colon
            if (!parseValue()) {
                handleError(ParseErrorCode.ValueExpected, [], [SyntaxKind.CloseBraceToken, SyntaxKind.CommaToken]);
            }
        }
        else {
            handleError(ParseErrorCode.ColonExpected, [], [SyntaxKind.CloseBraceToken, SyntaxKind.CommaToken]);
        }
        return true;
    }
    function parseObject() {
        onObjectBegin();
        scanNext(); // consume open brace
        var needsComma = false;
        while (_scanner.getToken() !== SyntaxKind.CloseBraceToken && _scanner.getToken() !== SyntaxKind.EOF) {
            if (_scanner.getToken() === SyntaxKind.CommaToken) {
                if (!needsComma) {
                    handleError(ParseErrorCode.ValueExpected, [], []);
                }
                onSeparator(',');
                scanNext(); // consume comma
                if (_scanner.getToken() === SyntaxKind.CloseBraceToken && allowTrailingComma) {
                    break;
                }
            }
            else if (needsComma) {
                handleError(ParseErrorCode.CommaExpected, [], []);
            }
            if (!parseProperty()) {
                handleError(ParseErrorCode.ValueExpected, [], [SyntaxKind.CloseBraceToken, SyntaxKind.CommaToken]);
            }
            needsComma = true;
        }
        onObjectEnd();
        if (_scanner.getToken() !== SyntaxKind.CloseBraceToken) {
            handleError(ParseErrorCode.CloseBraceExpected, [SyntaxKind.CloseBraceToken], []);
        }
        else {
            scanNext(); // consume close brace
        }
        return true;
    }
    function parseArray() {
        onArrayBegin();
        scanNext(); // consume open bracket
        var needsComma = false;
        while (_scanner.getToken() !== SyntaxKind.CloseBracketToken && _scanner.getToken() !== SyntaxKind.EOF) {
            if (_scanner.getToken() === SyntaxKind.CommaToken) {
                if (!needsComma) {
                    handleError(ParseErrorCode.ValueExpected, [], []);
                }
                onSeparator(',');
                scanNext(); // consume comma
                if (_scanner.getToken() === SyntaxKind.CloseBracketToken && allowTrailingComma) {
                    break;
                }
            }
            else if (needsComma) {
                handleError(ParseErrorCode.CommaExpected, [], []);
            }
            if (!parseValue()) {
                handleError(ParseErrorCode.ValueExpected, [], [SyntaxKind.CloseBracketToken, SyntaxKind.CommaToken]);
            }
            needsComma = true;
        }
        onArrayEnd();
        if (_scanner.getToken() !== SyntaxKind.CloseBracketToken) {
            handleError(ParseErrorCode.CloseBracketExpected, [SyntaxKind.CloseBracketToken], []);
        }
        else {
            scanNext(); // consume close bracket
        }
        return true;
    }
    function parseValue() {
        switch (_scanner.getToken()) {
            case SyntaxKind.OpenBracketToken:
                return parseArray();
            case SyntaxKind.OpenBraceToken:
                return parseObject();
            case SyntaxKind.StringLiteral:
                return parseString(true);
            default:
                return parseLiteral();
        }
    }
    scanNext();
    if (_scanner.getToken() === SyntaxKind.EOF) {
        return true;
    }
    if (!parseValue()) {
        handleError(ParseErrorCode.ValueExpected, [], []);
        return false;
    }
    if (_scanner.getToken() !== SyntaxKind.EOF) {
        handleError(ParseErrorCode.EndOfFileExpected, [], []);
    }
    return true;
}

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
function deepClone(obj) {
    if (!obj || typeof obj !== 'object') {
        return obj;
    }
    if (obj instanceof RegExp) {
        // See https://github.com/Microsoft/TypeScript/issues/10990
        return obj;
    }
    var result = Array.isArray(obj) ? [] : {};
    Object.keys(obj).forEach(function (key) {
        if (obj[key] && typeof obj[key] === 'object') {
            result[key] = deepClone(obj[key]);
        }
        else {
            result[key] = obj[key];
        }
    });
    return result;
}
function deepFreeze(obj) {
    if (!obj || typeof obj !== 'object') {
        return obj;
    }
    var stack = [obj];
    while (stack.length > 0) {
        var obj_1 = stack.shift();
        Object.freeze(obj_1);
        for (var key in obj_1) {
            if (_hasOwnProperty.call(obj_1, key)) {
                var prop = obj_1[key];
                if (typeof prop === 'object' && !Object.isFrozen(prop)) {
                    stack.push(prop);
                }
            }
        }
    }
    return obj;
}
var _hasOwnProperty = Object.prototype.hasOwnProperty;
/**
 * Copies all properties of source into destination. The optional parameter "overwrite" allows to control
 * if existing properties on the destination should be overwritten or not. Defaults to true (overwrite).
 */
function mixin(destination, source, overwrite) {
    if (overwrite === void 0) { overwrite = true; }
    if (!isObject(destination)) {
        return source;
    }
    if (isObject(source)) {
        Object.keys(source).forEach(function (key) {
            if (key in destination) {
                if (overwrite) {
                    if (isObject(destination[key]) && isObject(source[key])) {
                        mixin(destination[key], source[key], overwrite);
                    }
                    else {
                        destination[key] = source[key];
                    }
                }
            }
            else {
                destination[key] = source[key];
            }
        });
    }
    return destination;
}
function assign(destination) {
    var sources = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        sources[_i - 1] = arguments[_i];
    }
    sources.forEach(function (source) { return Object.keys(source).forEach(function (key) { return destination[key] = source[key]; }); });
    return destination;
}
function equals$1(one, other) {
    if (one === other) {
        return true;
    }
    if (one === null || one === undefined || other === null || other === undefined) {
        return false;
    }
    if (typeof one !== typeof other) {
        return false;
    }
    if (typeof one !== 'object') {
        return false;
    }
    if ((Array.isArray(one)) !== (Array.isArray(other))) {
        return false;
    }
    var i;
    var key;
    if (Array.isArray(one)) {
        if (one.length !== other.length) {
            return false;
        }
        for (i = 0; i < one.length; i++) {
            if (!equals$1(one[i], other[i])) {
                return false;
            }
        }
    }
    else {
        var oneKeys = [];
        for (key in one) {
            oneKeys.push(key);
        }
        oneKeys.sort();
        var otherKeys = [];
        for (key in other) {
            otherKeys.push(key);
        }
        otherKeys.sort();
        if (!equals$1(oneKeys, otherKeys)) {
            return false;
        }
        for (i = 0; i < oneKeys.length; i++) {
            if (!equals$1(one[oneKeys[i]], other[oneKeys[i]])) {
                return false;
            }
        }
    }
    return true;
}
function arrayToHash(array) {
    var result = {};
    for (var i = 0; i < array.length; ++i) {
        result[array[i]] = true;
    }
    return result;
}
/**
 * Given an array of strings, returns a function which, given a string
 * returns true or false whether the string is in that array.
 */
function createKeywordMatcher(arr, caseInsensitive) {
    if (caseInsensitive === void 0) { caseInsensitive = false; }
    if (caseInsensitive) {
        arr = arr.map(function (x) { return x.toLowerCase(); });
    }
    var hash = arrayToHash(arr);
    if (caseInsensitive) {
        return function (word) {
            return hash[word.toLowerCase()] !== undefined && hash.hasOwnProperty(word.toLowerCase());
        };
    }
    else {
        return function (word) {
            return hash[word] !== undefined && hash.hasOwnProperty(word);
        };
    }
}
function getOrDefault(obj, fn, defaultValue) {
    if (defaultValue === void 0) { defaultValue = null; }
    var result = fn(obj);
    return typeof result === 'undefined' ? defaultValue : result;
}

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
/**
 * Throws an error with the provided message if the provided value does not evaluate to a true Javascript value.
 */
function ok(value, message) {
    if (!value || value === null) {
        throw new Error(message ? 'Assertion failed (' + message + ')' : 'Assertion Failed');
    }
}

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var RegistryImpl = /** @class */ (function () {
    function RegistryImpl() {
        this.data = {};
    }
    RegistryImpl.prototype.add = function (id, data) {
        ok(isString(id));
        ok(isObject(data));
        ok(!this.data.hasOwnProperty(id), 'There is already an extension with this id');
        this.data[id] = data;
    };
    RegistryImpl.prototype.knows = function (id) {
        return this.data.hasOwnProperty(id);
    };
    RegistryImpl.prototype.as = function (id) {
        return this.data[id] || null;
    };
    return RegistryImpl;
}());
var Registry = new RegistryImpl();

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var Extensions = {
    JSONContribution: 'base.contributions.json'
};
function normalizeId(id) {
    if (id.length > 0 && id.charAt(id.length - 1) === '#') {
        return id.substring(0, id.length - 1);
    }
    return id;
}
var JSONContributionRegistry = /** @class */ (function () {
    function JSONContributionRegistry() {
        this._onDidChangeSchema = new Emitter();
        this.onDidChangeSchema = this._onDidChangeSchema.event;
        this.schemasById = {};
    }
    JSONContributionRegistry.prototype.registerSchema = function (uri, unresolvedSchemaContent) {
        this.schemasById[normalizeId(uri)] = unresolvedSchemaContent;
        this._onDidChangeSchema.fire(uri);
    };
    JSONContributionRegistry.prototype.notifySchemaChanged = function (uri) {
        this._onDidChangeSchema.fire(uri);
    };
    JSONContributionRegistry.prototype.getSchemaContributions = function () {
        return {
            schemas: this.schemasById,
        };
    };
    return JSONContributionRegistry;
}());
var jsonContributionRegistry = new JSONContributionRegistry();
Registry.add(Extensions.JSONContribution, jsonContributionRegistry);

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var Extensions$1 = {
    Configuration: 'base.contributions.configuration'
};
var ConfigurationScope;
(function (ConfigurationScope) {
    ConfigurationScope[ConfigurationScope["APPLICATION"] = 1] = "APPLICATION";
    ConfigurationScope[ConfigurationScope["WINDOW"] = 2] = "WINDOW";
    ConfigurationScope[ConfigurationScope["RESOURCE"] = 3] = "RESOURCE";
})(ConfigurationScope || (ConfigurationScope = {}));
var allSettings = { properties: {}, patternProperties: {} };
var applicationSettings = { properties: {}, patternProperties: {} };
var windowSettings = { properties: {}, patternProperties: {} };
var resourceSettings = { properties: {}, patternProperties: {} };
var editorConfigurationSchemaId = 'vscode://schemas/settings/editor';
var contributionRegistry = Registry.as(Extensions.JSONContribution);
var ConfigurationRegistry = /** @class */ (function () {
    function ConfigurationRegistry() {
        this.overrideIdentifiers = [];
        this._onDidRegisterConfiguration = new Emitter();
        this.onDidRegisterConfiguration = this._onDidRegisterConfiguration.event;
        this.configurationContributors = [];
        this.editorConfigurationSchema = { properties: {}, patternProperties: {}, additionalProperties: false, errorMessage: 'Unknown editor configuration setting' };
        this.configurationProperties = {};
        this.excludedConfigurationProperties = {};
        this.computeOverridePropertyPattern();
        contributionRegistry.registerSchema(editorConfigurationSchemaId, this.editorConfigurationSchema);
    }
    ConfigurationRegistry.prototype.registerConfiguration = function (configuration, validate) {
        if (validate === void 0) { validate = true; }
        this.registerConfigurations([configuration], [], validate);
    };
    ConfigurationRegistry.prototype.registerConfigurations = function (configurations, defaultConfigurations, validate) {
        var _this = this;
        if (validate === void 0) { validate = true; }
        var configurationNode = this.toConfiguration(defaultConfigurations);
        if (configurationNode) {
            configurations.push(configurationNode);
        }
        var properties = [];
        configurations.forEach(function (configuration) {
            properties.push.apply(properties, _this.validateAndRegisterProperties(configuration, validate)); // fills in defaults
            _this.configurationContributors.push(configuration);
            _this.registerJSONConfiguration(configuration);
            _this.updateSchemaForOverrideSettingsConfiguration(configuration);
        });
        this._onDidRegisterConfiguration.fire(properties);
    };
    ConfigurationRegistry.prototype.notifyConfigurationSchemaUpdated = function (configuration) {
        contributionRegistry.notifySchemaChanged(editorConfigurationSchemaId);
    };
    ConfigurationRegistry.prototype.registerOverrideIdentifiers = function (overrideIdentifiers) {
        (_a = this.overrideIdentifiers).push.apply(_a, overrideIdentifiers);
        this.updateOverridePropertyPatternKey();
        var _a;
    };
    ConfigurationRegistry.prototype.toConfiguration = function (defaultConfigurations) {
        var configurationNode = {
            id: 'defaultOverrides',
            title: localize('defaultConfigurations.title', "Default Configuration Overrides"),
            properties: {}
        };
        for (var _i = 0, defaultConfigurations_1 = defaultConfigurations; _i < defaultConfigurations_1.length; _i++) {
            var defaultConfiguration = defaultConfigurations_1[_i];
            for (var key in defaultConfiguration.defaults) {
                var defaultValue = defaultConfiguration.defaults[key];
                if (OVERRIDE_PROPERTY_PATTERN.test(key) && typeof defaultValue === 'object') {
                    configurationNode.properties[key] = {
                        type: 'object',
                        default: defaultValue,
                        description: localize('overrideSettings.description', "Configure editor settings to be overridden for {0} language.", key),
                        $ref: editorConfigurationSchemaId
                    };
                }
            }
        }
        return Object.keys(configurationNode.properties).length ? configurationNode : null;
    };
    ConfigurationRegistry.prototype.validateAndRegisterProperties = function (configuration, validate, scope, overridable) {
        if (validate === void 0) { validate = true; }
        if (scope === void 0) { scope = ConfigurationScope.WINDOW; }
        if (overridable === void 0) { overridable = false; }
        scope = configuration.scope !== void 0 && configuration.scope !== null ? configuration.scope : scope;
        overridable = configuration.overridable || overridable;
        var propertyKeys = [];
        var properties = configuration.properties;
        if (properties) {
            for (var key in properties) {
                var message = void 0;
                if (validate && (message = validateProperty(key))) {
                    console.warn(message);
                    delete properties[key];
                    continue;
                }
                // fill in default values
                var property = properties[key];
                var defaultValue = property.default;
                if (isUndefined(defaultValue)) {
                    property.default = getDefaultValue(property.type);
                }
                // Inherit overridable property from parent
                if (overridable) {
                    property.overridable = true;
                }
                if (property.scope === void 0) {
                    property.scope = scope;
                }
                // Add to properties maps
                // Property is included by default if 'included' is unspecified
                if (properties[key].hasOwnProperty('included') && !properties[key].included) {
                    this.excludedConfigurationProperties[key] = properties[key];
                    delete properties[key];
                    continue;
                }
                else {
                    this.configurationProperties[key] = properties[key];
                }
                propertyKeys.push(key);
            }
        }
        var subNodes = configuration.allOf;
        if (subNodes) {
            for (var _i = 0, subNodes_1 = subNodes; _i < subNodes_1.length; _i++) {
                var node = subNodes_1[_i];
                propertyKeys.push.apply(propertyKeys, this.validateAndRegisterProperties(node, validate, scope, overridable));
            }
        }
        return propertyKeys;
    };
    ConfigurationRegistry.prototype.getConfigurations = function () {
        return this.configurationContributors;
    };
    ConfigurationRegistry.prototype.getConfigurationProperties = function () {
        return this.configurationProperties;
    };
    ConfigurationRegistry.prototype.getExcludedConfigurationProperties = function () {
        return this.excludedConfigurationProperties;
    };
    ConfigurationRegistry.prototype.registerJSONConfiguration = function (configuration) {
        function register(configuration) {
            var properties = configuration.properties;
            if (properties) {
                for (var key in properties) {
                    allSettings.properties[key] = properties[key];
                    switch (properties[key].scope) {
                        case ConfigurationScope.APPLICATION:
                            applicationSettings.properties[key] = properties[key];
                            break;
                        case ConfigurationScope.WINDOW:
                            windowSettings.properties[key] = properties[key];
                            break;
                        case ConfigurationScope.RESOURCE:
                            resourceSettings.properties[key] = properties[key];
                            break;
                    }
                }
            }
            var subNodes = configuration.allOf;
            if (subNodes) {
                subNodes.forEach(register);
            }
        }
        register(configuration);
    };
    ConfigurationRegistry.prototype.updateSchemaForOverrideSettingsConfiguration = function (configuration) {
        if (configuration.id !== SETTINGS_OVERRRIDE_NODE_ID) {
            this.update(configuration);
            contributionRegistry.registerSchema(editorConfigurationSchemaId, this.editorConfigurationSchema);
        }
    };
    ConfigurationRegistry.prototype.updateOverridePropertyPatternKey = function () {
        var patternProperties = allSettings.patternProperties[this.overridePropertyPattern];
        if (!patternProperties) {
            patternProperties = {
                type: 'object',
                description: localize('overrideSettings.defaultDescription', "Configure editor settings to be overridden for a language."),
                errorMessage: 'Unknown Identifier. Use language identifiers',
                $ref: editorConfigurationSchemaId
            };
        }
        delete allSettings.patternProperties[this.overridePropertyPattern];
        delete applicationSettings.patternProperties[this.overridePropertyPattern];
        delete windowSettings.patternProperties[this.overridePropertyPattern];
        delete resourceSettings.patternProperties[this.overridePropertyPattern];
        this.computeOverridePropertyPattern();
        allSettings.patternProperties[this.overridePropertyPattern] = patternProperties;
        applicationSettings.patternProperties[this.overridePropertyPattern] = patternProperties;
        windowSettings.patternProperties[this.overridePropertyPattern] = patternProperties;
        resourceSettings.patternProperties[this.overridePropertyPattern] = patternProperties;
    };
    ConfigurationRegistry.prototype.update = function (configuration) {
        var _this = this;
        var properties = configuration.properties;
        if (properties) {
            for (var key in properties) {
                if (properties[key].overridable) {
                    this.editorConfigurationSchema.properties[key] = this.getConfigurationProperties()[key];
                }
            }
        }
        var subNodes = configuration.allOf;
        if (subNodes) {
            subNodes.forEach(function (subNode) { return _this.update(subNode); });
        }
    };
    ConfigurationRegistry.prototype.computeOverridePropertyPattern = function () {
        this.overridePropertyPattern = this.overrideIdentifiers.length ? OVERRIDE_PATTERN_WITH_SUBSTITUTION.replace('${0}', this.overrideIdentifiers.map(function (identifier) { return createRegExp(identifier, false).source; }).join('|')) : OVERRIDE_PROPERTY;
    };
    return ConfigurationRegistry;
}());
var SETTINGS_OVERRRIDE_NODE_ID = 'override';
var OVERRIDE_PROPERTY = '\\[.*\\]$';
var OVERRIDE_PATTERN_WITH_SUBSTITUTION = '\\[(${0})\\]$';
var OVERRIDE_PROPERTY_PATTERN = new RegExp(OVERRIDE_PROPERTY);
function getDefaultValue(type) {
    var t = Array.isArray(type) ? type[0] : type;
    switch (t) {
        case 'boolean':
            return false;
        case 'integer':
        case 'number':
            return 0;
        case 'string':
            return '';
        case 'array':
            return [];
        case 'object':
            return {};
        default:
            return null;
    }
}
var configurationRegistry = new ConfigurationRegistry();
Registry.add(Extensions$1.Configuration, configurationRegistry);
function validateProperty(property) {
    if (OVERRIDE_PROPERTY_PATTERN.test(property)) {
        return localize('config.property.languageDefault', "Cannot register '{0}'. This matches property pattern '\\\\[.*\\\\]$' for describing language specific editor settings. Use 'configurationDefaults' contribution.", property);
    }
    if (configurationRegistry.getConfigurationProperties()[property] !== void 0) {
        return localize('config.property.duplicate', "Cannot register '{0}'. This property is already registered.", property);
    }
    return null;
}

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var IConfigurationService = createDecorator('configurationService');
var ConfigurationTarget;
(function (ConfigurationTarget) {
    ConfigurationTarget[ConfigurationTarget["USER"] = 1] = "USER";
    ConfigurationTarget[ConfigurationTarget["WORKSPACE"] = 2] = "WORKSPACE";
    ConfigurationTarget[ConfigurationTarget["WORKSPACE_FOLDER"] = 3] = "WORKSPACE_FOLDER";
    ConfigurationTarget[ConfigurationTarget["DEFAULT"] = 4] = "DEFAULT";
    ConfigurationTarget[ConfigurationTarget["MEMORY"] = 5] = "MEMORY";
})(ConfigurationTarget || (ConfigurationTarget = {}));
function toOverrides(raw, conflictReporter) {
    var overrides = [];
    var configurationProperties = Registry.as(Extensions$1.Configuration).getConfigurationProperties();
    for (var _i = 0, _a = Object.keys(raw); _i < _a.length; _i++) {
        var key = _a[_i];
        if (OVERRIDE_PROPERTY_PATTERN.test(key)) {
            var overrideRaw = {};
            for (var keyInOverrideRaw in raw[key]) {
                if (configurationProperties[keyInOverrideRaw] && configurationProperties[keyInOverrideRaw].overridable) {
                    overrideRaw[keyInOverrideRaw] = raw[key][keyInOverrideRaw];
                }
            }
            overrides.push({
                identifiers: [overrideIdentifierFromKey(key).trim()],
                contents: toValuesTree(overrideRaw, conflictReporter)
            });
        }
    }
    return overrides;
}
function toValuesTree(properties, conflictReporter) {
    var root = Object.create(null);
    for (var key in properties) {
        addToValueTree(root, key, properties[key], conflictReporter);
    }
    return root;
}
function addToValueTree(settingsTreeRoot, key, value, conflictReporter) {
    var segments = key.split('.');
    var last = segments.pop();
    var curr = settingsTreeRoot;
    for (var i = 0; i < segments.length; i++) {
        var s = segments[i];
        var obj = curr[s];
        switch (typeof obj) {
            case 'undefined':
                obj = curr[s] = Object.create(null);
                break;
            case 'object':
                break;
            default:
                conflictReporter("Ignoring " + key + " as " + segments.slice(0, i + 1).join('.') + " is " + JSON.stringify(obj));
                return;
        }
        curr = obj;
    }
    if (typeof curr === 'object') {
        curr[last] = value; // workaround https://github.com/Microsoft/vscode/issues/13606
    }
    else {
        conflictReporter("Ignoring " + key + " as " + segments.join('.') + " is " + JSON.stringify(curr));
    }
}
function removeFromValueTree(valueTree, key) {
    var segments = key.split('.');
    doRemoveFromValueTree(valueTree, segments);
}
function doRemoveFromValueTree(valueTree, segments) {
    var first = segments.shift();
    if (segments.length === 0) {
        // Reached last segment
        delete valueTree[first];
        return;
    }
    if (Object.keys(valueTree).indexOf(first) !== -1) {
        var value = valueTree[first];
        if (typeof value === 'object' && !Array.isArray(value)) {
            doRemoveFromValueTree(value, segments);
            if (Object.keys(value).length === 0) {
                delete valueTree[first];
            }
        }
    }
}
/**
 * A helper function to get the configuration value with a specific settings path (e.g. config.some.setting)
 */
function getConfigurationValue(config, settingPath, defaultValue) {
    function accessSetting(config, path) {
        var current = config;
        for (var i = 0; i < path.length; i++) {
            if (typeof current !== 'object' || current === null) {
                return undefined;
            }
            current = current[path[i]];
        }
        return current;
    }
    var path = settingPath.split('.');
    var result = accessSetting(config, path);
    return typeof result === 'undefined' ? defaultValue : result;
}
function getConfigurationKeys() {
    var properties = Registry.as(Extensions$1.Configuration).getConfigurationProperties();
    return Object.keys(properties);
}
function getDefaultValues() {
    var valueTreeRoot = Object.create(null);
    var properties = Registry.as(Extensions$1.Configuration).getConfigurationProperties();
    for (var key in properties) {
        var value = properties[key].default;
        addToValueTree(valueTreeRoot, key, value, function (message) { return console.error("Conflict in default settings: " + message); });
    }
    return valueTreeRoot;
}
function overrideIdentifierFromKey(key) {
    return key.substring(1, key.length - 1);
}

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$3 = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var ConfigurationModel = /** @class */ (function () {
    function ConfigurationModel(_contents, _keys, _overrides) {
        if (_contents === void 0) { _contents = {}; }
        if (_keys === void 0) { _keys = []; }
        if (_overrides === void 0) { _overrides = []; }
        this._contents = _contents;
        this._keys = _keys;
        this._overrides = _overrides;
        this.isFrozen = false;
    }
    Object.defineProperty(ConfigurationModel.prototype, "contents", {
        get: function () {
            return this.checkAndFreeze(this._contents);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ConfigurationModel.prototype, "overrides", {
        get: function () {
            return this.checkAndFreeze(this._overrides);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ConfigurationModel.prototype, "keys", {
        get: function () {
            return this.checkAndFreeze(this._keys);
        },
        enumerable: true,
        configurable: true
    });
    ConfigurationModel.prototype.getValue = function (section) {
        return section ? getConfigurationValue(this.contents, section) : this.contents;
    };
    ConfigurationModel.prototype.override = function (identifier) {
        var overrideContents = this.getContentsForOverrideIdentifer(identifier);
        if (!overrideContents || typeof overrideContents !== 'object' || !Object.keys(overrideContents).length) {
            // If there are no valid overrides, return self
            return this;
        }
        var contents = {};
        for (var _i = 0, _a = distinct(Object.keys(this.contents).concat(Object.keys(overrideContents))); _i < _a.length; _i++) {
            var key = _a[_i];
            var contentsForKey = this.contents[key];
            var overrideContentsForKey = overrideContents[key];
            // If there are override contents for the key, clone and merge otherwise use base contents
            if (overrideContentsForKey) {
                // Clone and merge only if base contents and override contents are of type object otherwise just override
                if (typeof contentsForKey === 'object' && typeof overrideContentsForKey === 'object') {
                    contentsForKey = deepClone(contentsForKey);
                    this.mergeContents(contentsForKey, overrideContentsForKey);
                }
                else {
                    contentsForKey = overrideContentsForKey;
                }
            }
            contents[key] = contentsForKey;
        }
        return new ConfigurationModel(contents);
    };
    ConfigurationModel.prototype.merge = function () {
        var others = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            others[_i] = arguments[_i];
        }
        var contents = deepClone(this.contents);
        var overrides = deepClone(this.overrides);
        var keys = this.keys.slice();
        for (var _a = 0, others_1 = others; _a < others_1.length; _a++) {
            var other = others_1[_a];
            this.mergeContents(contents, other.contents);
            var _loop_1 = function (otherOverride) {
                var override = overrides.filter(function (o) { return equals(o.identifiers, otherOverride.identifiers); })[0];
                if (override) {
                    this_1.mergeContents(override.contents, otherOverride.contents);
                }
                else {
                    overrides.push(deepClone(otherOverride));
                }
            };
            var this_1 = this;
            for (var _b = 0, _c = other.overrides; _b < _c.length; _b++) {
                var otherOverride = _c[_b];
                _loop_1(otherOverride);
            }
            for (var _d = 0, _e = other.keys; _d < _e.length; _d++) {
                var key = _e[_d];
                if (keys.indexOf(key) === -1) {
                    keys.push(key);
                }
            }
        }
        return new ConfigurationModel(contents, keys, overrides);
    };
    ConfigurationModel.prototype.freeze = function () {
        this.isFrozen = true;
        return this;
    };
    ConfigurationModel.prototype.mergeContents = function (source, target) {
        for (var _i = 0, _a = Object.keys(target); _i < _a.length; _i++) {
            var key = _a[_i];
            if (key in source) {
                if (isObject(source[key]) && isObject(target[key])) {
                    this.mergeContents(source[key], target[key]);
                    continue;
                }
            }
            source[key] = deepClone(target[key]);
        }
    };
    ConfigurationModel.prototype.checkAndFreeze = function (data) {
        if (this.isFrozen && !Object.isFrozen(data)) {
            return deepFreeze(data);
        }
        return data;
    };
    ConfigurationModel.prototype.getContentsForOverrideIdentifer = function (identifier) {
        for (var _i = 0, _a = this.overrides; _i < _a.length; _i++) {
            var override = _a[_i];
            if (override.identifiers.indexOf(identifier) !== -1) {
                return override.contents;
            }
        }
        return null;
    };
    ConfigurationModel.prototype.toJSON = function () {
        return {
            contents: this.contents,
            overrides: this.overrides,
            keys: this.keys
        };
    };
    // Update methods
    ConfigurationModel.prototype.setValue = function (key, value) {
        this.addKey(key);
        addToValueTree(this.contents, key, value, function (e) { throw new Error(e); });
    };
    ConfigurationModel.prototype.removeValue = function (key) {
        if (this.removeKey(key)) {
            removeFromValueTree(this.contents, key);
        }
    };
    ConfigurationModel.prototype.addKey = function (key) {
        var index$$1 = this.keys.length;
        for (var i = 0; i < index$$1; i++) {
            if (key.indexOf(this.keys[i]) === 0) {
                index$$1 = i;
            }
        }
        this.keys.splice(index$$1, 1, key);
    };
    ConfigurationModel.prototype.removeKey = function (key) {
        var index$$1 = this.keys.indexOf(key);
        if (index$$1 !== -1) {
            this.keys.splice(index$$1, 1);
            return true;
        }
        return false;
    };
    return ConfigurationModel;
}());
var DefaultConfigurationModel = /** @class */ (function (_super) {
    __extends$3(DefaultConfigurationModel, _super);
    function DefaultConfigurationModel() {
        var _this = this;
        var contents = getDefaultValues();
        var keys = getConfigurationKeys();
        var overrides = [];
        for (var _i = 0, _a = Object.keys(contents); _i < _a.length; _i++) {
            var key = _a[_i];
            if (OVERRIDE_PROPERTY_PATTERN.test(key)) {
                overrides.push({
                    identifiers: [overrideIdentifierFromKey(key).trim()],
                    contents: toValuesTree(contents[key], function (message) { return console.error("Conflict in default settings file: " + message); })
                });
            }
        }
        _this = _super.call(this, contents, keys, overrides) || this;
        return _this;
    }
    return DefaultConfigurationModel;
}(ConfigurationModel));
var ConfigurationModelParser = /** @class */ (function () {
    function ConfigurationModelParser(_name) {
        this._name = _name;
        this._configurationModel = null;
        this._parseErrors = [];
    }
    Object.defineProperty(ConfigurationModelParser.prototype, "configurationModel", {
        get: function () {
            return this._configurationModel || new ConfigurationModel();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ConfigurationModelParser.prototype, "errors", {
        get: function () {
            return this._parseErrors;
        },
        enumerable: true,
        configurable: true
    });
    ConfigurationModelParser.prototype.parse = function (content) {
        var raw = this.parseContent(content);
        var configurationModel = this.parseRaw(raw);
        this._configurationModel = new ConfigurationModel(configurationModel.contents, configurationModel.keys, configurationModel.overrides);
    };
    ConfigurationModelParser.prototype.parseContent = function (content) {
        var raw = {};
        var currentProperty = null;
        var currentParent = [];
        var previousParents = [];
        function onValue(value) {
            if (Array.isArray(currentParent)) {
                currentParent.push(value);
            }
            else if (currentProperty) {
                currentParent[currentProperty] = value;
            }
        }
        var visitor = {
            onObjectBegin: function () {
                var object = {};
                onValue(object);
                previousParents.push(currentParent);
                currentParent = object;
                currentProperty = null;
            },
            onObjectProperty: function (name) {
                currentProperty = name;
            },
            onObjectEnd: function () {
                currentParent = previousParents.pop();
            },
            onArrayBegin: function () {
                var array = [];
                onValue(array);
                previousParents.push(currentParent);
                currentParent = array;
                currentProperty = null;
            },
            onArrayEnd: function () {
                currentParent = previousParents.pop();
            },
            onLiteralValue: onValue,
            onError: function (error) {
            }
        };
        if (content) {
            try {
                visit(content, visitor);
                raw = currentParent[0] || {};
            }
            catch (e) {
                console.error("Error while parsing settings file " + this._name + ": " + e);
                this._parseErrors = [e];
            }
        }
        return raw;
    };
    ConfigurationModelParser.prototype.parseRaw = function (raw) {
        var _this = this;
        var contents = toValuesTree(raw, function (message) { return console.error("Conflict in settings file " + _this._name + ": " + message); });
        var keys = Object.keys(raw);
        var overrides = toOverrides(raw, function (message) { return console.error("Conflict in settings file " + _this._name + ": " + message); });
        return { contents: contents, keys: keys, overrides: overrides };
    };
    return ConfigurationModelParser;
}());
var Configuration = /** @class */ (function () {
    function Configuration(_defaultConfiguration, _userConfiguration, _workspaceConfiguration, _folderConfigurations, _memoryConfiguration, _memoryConfigurationByResource, _freeze) {
        if (_workspaceConfiguration === void 0) { _workspaceConfiguration = new ConfigurationModel(); }
        if (_folderConfigurations === void 0) { _folderConfigurations = new ResourceMap(); }
        if (_memoryConfiguration === void 0) { _memoryConfiguration = new ConfigurationModel(); }
        if (_memoryConfigurationByResource === void 0) { _memoryConfigurationByResource = new ResourceMap(); }
        if (_freeze === void 0) { _freeze = true; }
        this._defaultConfiguration = _defaultConfiguration;
        this._userConfiguration = _userConfiguration;
        this._workspaceConfiguration = _workspaceConfiguration;
        this._folderConfigurations = _folderConfigurations;
        this._memoryConfiguration = _memoryConfiguration;
        this._memoryConfigurationByResource = _memoryConfigurationByResource;
        this._freeze = _freeze;
        this._workspaceConsolidatedConfiguration = null;
        this._foldersConsolidatedConfigurations = new ResourceMap();
    }
    Configuration.prototype.getValue = function (section, overrides, workspace) {
        var consolidateConfigurationModel = this.getConsolidateConfigurationModel(overrides, workspace);
        return consolidateConfigurationModel.getValue(section);
    };
    Configuration.prototype.updateValue = function (key, value, overrides) {
        if (overrides === void 0) { overrides = {}; }
        var memoryConfiguration;
        if (overrides.resource) {
            memoryConfiguration = this._memoryConfigurationByResource.get(overrides.resource);
            if (!memoryConfiguration) {
                memoryConfiguration = new ConfigurationModel();
                this._memoryConfigurationByResource.set(overrides.resource, memoryConfiguration);
            }
        }
        else {
            memoryConfiguration = this._memoryConfiguration;
        }
        if (value === void 0) {
            memoryConfiguration.removeValue(key);
        }
        else {
            memoryConfiguration.setValue(key, value);
        }
        if (!overrides.resource) {
            this._workspaceConsolidatedConfiguration = null;
        }
    };
    Configuration.prototype.inspect = function (key, overrides, workspace) {
        var consolidateConfigurationModel = this.getConsolidateConfigurationModel(overrides, workspace);
        var folderConfigurationModel = this.getFolderConfigurationModelForResource(overrides.resource, workspace);
        var memoryConfigurationModel = overrides.resource ? this._memoryConfigurationByResource.get(overrides.resource) || this._memoryConfiguration : this._memoryConfiguration;
        return {
            default: overrides.overrideIdentifier ? this._defaultConfiguration.freeze().override(overrides.overrideIdentifier).getValue(key) : this._defaultConfiguration.freeze().getValue(key),
            user: overrides.overrideIdentifier ? this._userConfiguration.freeze().override(overrides.overrideIdentifier).getValue(key) : this._userConfiguration.freeze().getValue(key),
            workspace: workspace ? overrides.overrideIdentifier ? this._workspaceConfiguration.freeze().override(overrides.overrideIdentifier).getValue(key) : this._workspaceConfiguration.freeze().getValue(key) : void 0,
            workspaceFolder: folderConfigurationModel ? overrides.overrideIdentifier ? folderConfigurationModel.freeze().override(overrides.overrideIdentifier).getValue(key) : folderConfigurationModel.freeze().getValue(key) : void 0,
            memory: overrides.overrideIdentifier ? memoryConfigurationModel.freeze().override(overrides.overrideIdentifier).getValue(key) : memoryConfigurationModel.freeze().getValue(key),
            value: consolidateConfigurationModel.getValue(key)
        };
    };
    Configuration.prototype.keys = function (workspace) {
        var folderConfigurationModel = this.getFolderConfigurationModelForResource(null, workspace);
        return {
            default: this._defaultConfiguration.freeze().keys,
            user: this._userConfiguration.freeze().keys,
            workspace: this._workspaceConfiguration.freeze().keys,
            workspaceFolder: folderConfigurationModel ? folderConfigurationModel.freeze().keys : []
        };
    };
    Configuration.prototype.updateDefaultConfiguration = function (defaultConfiguration) {
        this._defaultConfiguration = defaultConfiguration;
        this._workspaceConsolidatedConfiguration = null;
        this._foldersConsolidatedConfigurations.clear();
    };
    Configuration.prototype.updateUserConfiguration = function (userConfiguration) {
        this._userConfiguration = userConfiguration;
        this._workspaceConsolidatedConfiguration = null;
        this._foldersConsolidatedConfigurations.clear();
    };
    Configuration.prototype.updateWorkspaceConfiguration = function (workspaceConfiguration) {
        this._workspaceConfiguration = workspaceConfiguration;
        this._workspaceConsolidatedConfiguration = null;
        this._foldersConsolidatedConfigurations.clear();
    };
    Configuration.prototype.updateFolderConfiguration = function (resource, configuration) {
        this._folderConfigurations.set(resource, configuration);
        this._foldersConsolidatedConfigurations.delete(resource);
    };
    Configuration.prototype.deleteFolderConfiguration = function (resource) {
        this.folders.delete(resource);
        this._foldersConsolidatedConfigurations.delete(resource);
    };
    Object.defineProperty(Configuration.prototype, "defaults", {
        get: function () {
            return this._defaultConfiguration;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Configuration.prototype, "user", {
        get: function () {
            return this._userConfiguration;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Configuration.prototype, "workspace", {
        get: function () {
            return this._workspaceConfiguration;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Configuration.prototype, "folders", {
        get: function () {
            return this._folderConfigurations;
        },
        enumerable: true,
        configurable: true
    });
    Configuration.prototype.getConsolidateConfigurationModel = function (overrides, workspace) {
        var configurationModel = this.getConsolidatedConfigurationModelForResource(overrides, workspace);
        return overrides.overrideIdentifier ? configurationModel.override(overrides.overrideIdentifier) : configurationModel;
    };
    Configuration.prototype.getConsolidatedConfigurationModelForResource = function (_a, workspace) {
        var resource = _a.resource;
        var consolidateConfiguration = this.getWorkspaceConsolidatedConfiguration();
        if (workspace && resource) {
            var root = workspace.getFolder(resource);
            if (root) {
                consolidateConfiguration = this.getFolderConsolidatedConfiguration(root.uri) || consolidateConfiguration;
            }
            var memoryConfigurationForResource = this._memoryConfigurationByResource.get(resource);
            if (memoryConfigurationForResource) {
                consolidateConfiguration = consolidateConfiguration.merge(memoryConfigurationForResource);
            }
        }
        return consolidateConfiguration;
    };
    Configuration.prototype.getWorkspaceConsolidatedConfiguration = function () {
        if (!this._workspaceConsolidatedConfiguration) {
            this._workspaceConsolidatedConfiguration = this._defaultConfiguration.merge(this._userConfiguration, this._workspaceConfiguration, this._memoryConfiguration);
            if (this._freeze) {
                this._workspaceConfiguration = this._workspaceConfiguration.freeze();
            }
        }
        return this._workspaceConsolidatedConfiguration;
    };
    Configuration.prototype.getFolderConsolidatedConfiguration = function (folder) {
        var folderConsolidatedConfiguration = this._foldersConsolidatedConfigurations.get(folder);
        if (!folderConsolidatedConfiguration) {
            var workspaceConsolidateConfiguration = this.getWorkspaceConsolidatedConfiguration();
            var folderConfiguration = this._folderConfigurations.get(folder);
            if (folderConfiguration) {
                folderConsolidatedConfiguration = workspaceConsolidateConfiguration.merge(folderConfiguration);
                if (this._freeze) {
                    folderConsolidatedConfiguration = folderConsolidatedConfiguration.freeze();
                }
                this._foldersConsolidatedConfigurations.set(folder, folderConsolidatedConfiguration);
            }
            else {
                folderConsolidatedConfiguration = workspaceConsolidateConfiguration;
            }
        }
        return folderConsolidatedConfiguration;
    };
    Configuration.prototype.getFolderConfigurationModelForResource = function (resource, workspace) {
        if (workspace && resource) {
            var root = workspace.getFolder(resource);
            if (root) {
                return this._folderConfigurations.get(root.uri);
            }
        }
        return null;
    };
    Configuration.prototype.toData = function () {
        var _this = this;
        return {
            defaults: {
                contents: this._defaultConfiguration.contents,
                overrides: this._defaultConfiguration.overrides,
                keys: this._defaultConfiguration.keys
            },
            user: {
                contents: this._userConfiguration.contents,
                overrides: this._userConfiguration.overrides,
                keys: this._userConfiguration.keys
            },
            workspace: {
                contents: this._workspaceConfiguration.contents,
                overrides: this._workspaceConfiguration.overrides,
                keys: this._workspaceConfiguration.keys
            },
            folders: this._folderConfigurations.keys().reduce(function (result, folder) {
                var _a = _this._folderConfigurations.get(folder), contents = _a.contents, overrides = _a.overrides, keys = _a.keys;
                result[folder.toString()] = { contents: contents, overrides: overrides, keys: keys };
                return result;
            }, Object.create({})),
            isComplete: true
        };
    };
    Configuration.prototype.allKeys = function (workspace) {
        var keys = this.keys(workspace);
        var all = keys.default.slice();
        var addKeys = function (keys) {
            for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
                var key = keys_1[_i];
                if (all.indexOf(key) === -1) {
                    all.push(key);
                }
            }
        };
        addKeys(keys.user);
        addKeys(keys.workspace);
        for (var _i = 0, _a = this.folders.keys(); _i < _a.length; _i++) {
            var resource = _a[_i];
            addKeys(this.folders.get(resource).keys);
        }
        return all;
    };
    return Configuration;
}());
var AbstractConfigurationChangeEvent = /** @class */ (function () {
    function AbstractConfigurationChangeEvent() {
    }
    AbstractConfigurationChangeEvent.prototype.doesConfigurationContains = function (configuration, config) {
        var changedKeysTree = configuration.contents;
        var requestedTree = toValuesTree((_a = {}, _a[config] = true, _a), function () { });
        var key;
        while (typeof requestedTree === 'object' && (key = Object.keys(requestedTree)[0])) { // Only one key should present, since we added only one property
            changedKeysTree = changedKeysTree[key];
            if (!changedKeysTree) {
                return false; // Requested tree is not found
            }
            requestedTree = requestedTree[key];
        }
        return true;
        var _a;
    };
    AbstractConfigurationChangeEvent.prototype.updateKeys = function (configuration, keys, resource) {
        for (var _i = 0, keys_2 = keys; _i < keys_2.length; _i++) {
            var key = keys_2[_i];
            configuration.setValue(key, {});
        }
    };
    return AbstractConfigurationChangeEvent;
}());
var ConfigurationChangeEvent = /** @class */ (function (_super) {
    __extends$3(ConfigurationChangeEvent, _super);
    function ConfigurationChangeEvent(_changedConfiguration, _changedConfigurationByResource) {
        if (_changedConfiguration === void 0) { _changedConfiguration = new ConfigurationModel(); }
        if (_changedConfigurationByResource === void 0) { _changedConfigurationByResource = new ResourceMap(); }
        var _this = _super.call(this) || this;
        _this._changedConfiguration = _changedConfiguration;
        _this._changedConfigurationByResource = _changedConfigurationByResource;
        return _this;
    }
    Object.defineProperty(ConfigurationChangeEvent.prototype, "changedConfiguration", {
        get: function () {
            return this._changedConfiguration;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ConfigurationChangeEvent.prototype, "changedConfigurationByResource", {
        get: function () {
            return this._changedConfigurationByResource;
        },
        enumerable: true,
        configurable: true
    });
    ConfigurationChangeEvent.prototype.change = function (arg1, arg2) {
        if (arg1 instanceof ConfigurationChangeEvent) {
            this._changedConfiguration = this._changedConfiguration.merge(arg1._changedConfiguration);
            for (var _i = 0, _a = arg1._changedConfigurationByResource.keys(); _i < _a.length; _i++) {
                var resource = _a[_i];
                var changedConfigurationByResource = this.getOrSetChangedConfigurationForResource(resource);
                changedConfigurationByResource = changedConfigurationByResource.merge(arg1._changedConfigurationByResource.get(resource));
                this._changedConfigurationByResource.set(resource, changedConfigurationByResource);
            }
        }
        else {
            this.changeWithKeys(arg1, arg2);
        }
        return this;
    };
    ConfigurationChangeEvent.prototype.telemetryData = function (source, sourceConfig) {
        this._source = source;
        this._sourceConfig = sourceConfig;
        return this;
    };
    Object.defineProperty(ConfigurationChangeEvent.prototype, "affectedKeys", {
        get: function () {
            var keys = this._changedConfiguration.keys.slice();
            this._changedConfigurationByResource.forEach(function (model) { return keys.push.apply(keys, model.keys); });
            return distinct(keys);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ConfigurationChangeEvent.prototype, "source", {
        get: function () {
            return this._source;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ConfigurationChangeEvent.prototype, "sourceConfig", {
        get: function () {
            return this._sourceConfig;
        },
        enumerable: true,
        configurable: true
    });
    ConfigurationChangeEvent.prototype.affectsConfiguration = function (config, resource) {
        var configurationModelsToSearch = [this._changedConfiguration];
        if (resource) {
            var model = this._changedConfigurationByResource.get(resource);
            if (model) {
                configurationModelsToSearch.push(model);
            }
        }
        else {
            configurationModelsToSearch.push.apply(configurationModelsToSearch, this._changedConfigurationByResource.values());
        }
        for (var _i = 0, configurationModelsToSearch_1 = configurationModelsToSearch; _i < configurationModelsToSearch_1.length; _i++) {
            var configuration = configurationModelsToSearch_1[_i];
            if (this.doesConfigurationContains(configuration, config)) {
                return true;
            }
        }
        return false;
    };
    ConfigurationChangeEvent.prototype.changeWithKeys = function (keys, resource) {
        var changedConfiguration = resource ? this.getOrSetChangedConfigurationForResource(resource) : this._changedConfiguration;
        this.updateKeys(changedConfiguration, keys);
    };
    ConfigurationChangeEvent.prototype.getOrSetChangedConfigurationForResource = function (resource) {
        var changedConfigurationByResource = this._changedConfigurationByResource.get(resource);
        if (!changedConfigurationByResource) {
            changedConfigurationByResource = new ConfigurationModel();
            this._changedConfigurationByResource.set(resource, changedConfigurationByResource);
        }
        return changedConfigurationByResource;
    };
    return ConfigurationChangeEvent;
}(AbstractConfigurationChangeEvent));

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var WindowManager = /** @class */ (function () {
    function WindowManager() {
        // --- Zoom Level
        this._zoomLevel = 0;
        this._lastZoomLevelChangeTime = 0;
        this._onDidChangeZoomLevel = new Emitter();
        this.onDidChangeZoomLevel = this._onDidChangeZoomLevel.event;
        // --- Zoom Factor
        this._zoomFactor = 0;
        this._onDidChangeFullscreen = new Emitter();
        this.onDidChangeFullscreen = this._onDidChangeFullscreen.event;
        // --- Accessibility
        this._accessibilitySupport = 0 /* Unknown */;
        this._onDidChangeAccessibilitySupport = new Emitter();
        this.onDidChangeAccessibilitySupport = this._onDidChangeAccessibilitySupport.event;
    }
    WindowManager.prototype.getZoomLevel = function () {
        return this._zoomLevel;
    };
    WindowManager.prototype.getTimeSinceLastZoomLevelChanged = function () {
        return Date.now() - this._lastZoomLevelChangeTime;
    };
    WindowManager.prototype.setZoomLevel = function (zoomLevel, isTrusted) {
        if (this._zoomLevel === zoomLevel) {
            return;
        }
        this._zoomLevel = zoomLevel;
        // See https://github.com/Microsoft/vscode/issues/26151
        this._lastZoomLevelChangeTime = isTrusted ? 0 : Date.now();
        this._onDidChangeZoomLevel.fire(this._zoomLevel);
    };
    WindowManager.prototype.getZoomFactor = function () {
        return this._zoomFactor;
    };
    WindowManager.prototype.setZoomFactor = function (zoomFactor) {
        this._zoomFactor = zoomFactor;
    };
    // --- Pixel Ratio
    WindowManager.prototype.getPixelRatio = function () {
        var ctx = document.createElement('canvas').getContext('2d');
        var dpr = window.devicePixelRatio || 1;
        var bsr = ctx.webkitBackingStorePixelRatio ||
            ctx.mozBackingStorePixelRatio ||
            ctx.msBackingStorePixelRatio ||
            ctx.oBackingStorePixelRatio ||
            ctx.backingStorePixelRatio || 1;
        return dpr / bsr;
    };
    WindowManager.prototype.setFullscreen = function (fullscreen) {
        if (this._fullscreen === fullscreen) {
            return;
        }
        this._fullscreen = fullscreen;
        this._onDidChangeFullscreen.fire();
    };
    WindowManager.prototype.isFullscreen = function () {
        return this._fullscreen;
    };
    WindowManager.prototype.setAccessibilitySupport = function (accessibilitySupport) {
        if (this._accessibilitySupport === accessibilitySupport) {
            return;
        }
        this._accessibilitySupport = accessibilitySupport;
        this._onDidChangeAccessibilitySupport.fire();
    };
    WindowManager.prototype.getAccessibilitySupport = function () {
        return this._accessibilitySupport;
    };
    WindowManager.INSTANCE = new WindowManager();
    return WindowManager;
}());
function getZoomLevel() {
    return WindowManager.INSTANCE.getZoomLevel();
}
/** Returns the time (in ms) since the zoom level was changed */
function getTimeSinceLastZoomLevelChanged() {
    return WindowManager.INSTANCE.getTimeSinceLastZoomLevelChanged();
}
function onDidChangeZoomLevel(callback) {
    return WindowManager.INSTANCE.onDidChangeZoomLevel(callback);
}
function getPixelRatio() {
    return WindowManager.INSTANCE.getPixelRatio();
}
function getAccessibilitySupport() {
    return WindowManager.INSTANCE.getAccessibilitySupport();
}
function onDidChangeAccessibilitySupport(callback) {
    return WindowManager.INSTANCE.onDidChangeAccessibilitySupport(callback);
}
var userAgent = navigator.userAgent;
var isIE = (userAgent.indexOf('Trident') >= 0);
var isEdge = (userAgent.indexOf('Edge/') >= 0);
var isEdgeOrIE = isIE || isEdge;
var isOpera = (userAgent.indexOf('Opera') >= 0);
var isFirefox = (userAgent.indexOf('Firefox') >= 0);
var isWebKit = (userAgent.indexOf('AppleWebKit') >= 0);
var isChrome = (userAgent.indexOf('Chrome') >= 0);
var isSafari = (userAgent.indexOf('Chrome') === -1) && (userAgent.indexOf('Safari') >= 0);
var isIPad = (userAgent.indexOf('iPad') >= 0);
var isEdgeWebView = isEdge && (userAgent.indexOf('WebView/') >= 0);
var isChromev56 = (userAgent.indexOf('Chrome/56.') >= 0
    // Edge likes to impersonate Chrome sometimes
    && userAgent.indexOf('Edge/') === -1);
function hasClipboardSupport() {
    if (isIE) {
        return false;
    }
    if (isEdge) {
        var index = userAgent.indexOf('Edge/');
        var version = parseInt(userAgent.substring(index + 5, userAgent.indexOf('.', index)), 10);
        if (!version || (version >= 12 && version <= 16)) {
            return false;
        }
    }
    return true;
}

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var KEY_CODE_MAP = new Array(230);
var INVERSE_KEY_CODE_MAP = new Array(112 /* MAX_VALUE */);
(function () {
    for (var i = 0; i < INVERSE_KEY_CODE_MAP.length; i++) {
        INVERSE_KEY_CODE_MAP[i] = -1;
    }
    function define(code, keyCode) {
        KEY_CODE_MAP[code] = keyCode;
        INVERSE_KEY_CODE_MAP[keyCode] = code;
    }
    define(3, 7 /* PauseBreak */); // VK_CANCEL 0x03 Control-break processing
    define(8, 1 /* Backspace */);
    define(9, 2 /* Tab */);
    define(13, 3 /* Enter */);
    define(16, 4 /* Shift */);
    define(17, 5 /* Ctrl */);
    define(18, 6 /* Alt */);
    define(19, 7 /* PauseBreak */);
    define(20, 8 /* CapsLock */);
    define(27, 9 /* Escape */);
    define(32, 10 /* Space */);
    define(33, 11 /* PageUp */);
    define(34, 12 /* PageDown */);
    define(35, 13 /* End */);
    define(36, 14 /* Home */);
    define(37, 15 /* LeftArrow */);
    define(38, 16 /* UpArrow */);
    define(39, 17 /* RightArrow */);
    define(40, 18 /* DownArrow */);
    define(45, 19 /* Insert */);
    define(46, 20 /* Delete */);
    define(48, 21 /* KEY_0 */);
    define(49, 22 /* KEY_1 */);
    define(50, 23 /* KEY_2 */);
    define(51, 24 /* KEY_3 */);
    define(52, 25 /* KEY_4 */);
    define(53, 26 /* KEY_5 */);
    define(54, 27 /* KEY_6 */);
    define(55, 28 /* KEY_7 */);
    define(56, 29 /* KEY_8 */);
    define(57, 30 /* KEY_9 */);
    define(65, 31 /* KEY_A */);
    define(66, 32 /* KEY_B */);
    define(67, 33 /* KEY_C */);
    define(68, 34 /* KEY_D */);
    define(69, 35 /* KEY_E */);
    define(70, 36 /* KEY_F */);
    define(71, 37 /* KEY_G */);
    define(72, 38 /* KEY_H */);
    define(73, 39 /* KEY_I */);
    define(74, 40 /* KEY_J */);
    define(75, 41 /* KEY_K */);
    define(76, 42 /* KEY_L */);
    define(77, 43 /* KEY_M */);
    define(78, 44 /* KEY_N */);
    define(79, 45 /* KEY_O */);
    define(80, 46 /* KEY_P */);
    define(81, 47 /* KEY_Q */);
    define(82, 48 /* KEY_R */);
    define(83, 49 /* KEY_S */);
    define(84, 50 /* KEY_T */);
    define(85, 51 /* KEY_U */);
    define(86, 52 /* KEY_V */);
    define(87, 53 /* KEY_W */);
    define(88, 54 /* KEY_X */);
    define(89, 55 /* KEY_Y */);
    define(90, 56 /* KEY_Z */);
    define(93, 58 /* ContextMenu */);
    define(96, 93 /* NUMPAD_0 */);
    define(97, 94 /* NUMPAD_1 */);
    define(98, 95 /* NUMPAD_2 */);
    define(99, 96 /* NUMPAD_3 */);
    define(100, 97 /* NUMPAD_4 */);
    define(101, 98 /* NUMPAD_5 */);
    define(102, 99 /* NUMPAD_6 */);
    define(103, 100 /* NUMPAD_7 */);
    define(104, 101 /* NUMPAD_8 */);
    define(105, 102 /* NUMPAD_9 */);
    define(106, 103 /* NUMPAD_MULTIPLY */);
    define(107, 104 /* NUMPAD_ADD */);
    define(108, 105 /* NUMPAD_SEPARATOR */);
    define(109, 106 /* NUMPAD_SUBTRACT */);
    define(110, 107 /* NUMPAD_DECIMAL */);
    define(111, 108 /* NUMPAD_DIVIDE */);
    define(112, 59 /* F1 */);
    define(113, 60 /* F2 */);
    define(114, 61 /* F3 */);
    define(115, 62 /* F4 */);
    define(116, 63 /* F5 */);
    define(117, 64 /* F6 */);
    define(118, 65 /* F7 */);
    define(119, 66 /* F8 */);
    define(120, 67 /* F9 */);
    define(121, 68 /* F10 */);
    define(122, 69 /* F11 */);
    define(123, 70 /* F12 */);
    define(124, 71 /* F13 */);
    define(125, 72 /* F14 */);
    define(126, 73 /* F15 */);
    define(127, 74 /* F16 */);
    define(128, 75 /* F17 */);
    define(129, 76 /* F18 */);
    define(130, 77 /* F19 */);
    define(144, 78 /* NumLock */);
    define(145, 79 /* ScrollLock */);
    define(186, 80 /* US_SEMICOLON */);
    define(187, 81 /* US_EQUAL */);
    define(188, 82 /* US_COMMA */);
    define(189, 83 /* US_MINUS */);
    define(190, 84 /* US_DOT */);
    define(191, 85 /* US_SLASH */);
    define(192, 86 /* US_BACKTICK */);
    define(193, 110 /* ABNT_C1 */);
    define(194, 111 /* ABNT_C2 */);
    define(219, 87 /* US_OPEN_SQUARE_BRACKET */);
    define(220, 88 /* US_BACKSLASH */);
    define(221, 89 /* US_CLOSE_SQUARE_BRACKET */);
    define(222, 90 /* US_QUOTE */);
    define(223, 91 /* OEM_8 */);
    define(226, 92 /* OEM_102 */);
    /**
     * https://lists.w3.org/Archives/Public/www-dom/2010JulSep/att-0182/keyCode-spec.html
     * If an Input Method Editor is processing key input and the event is keydown, return 229.
     */
    define(229, 109 /* KEY_IN_COMPOSITION */);
    if (isIE) {
        define(91, 57 /* Meta */);
    }
    else if (isFirefox) {
        define(59, 80 /* US_SEMICOLON */);
        define(107, 81 /* US_EQUAL */);
        define(109, 83 /* US_MINUS */);
        if (isMacintosh) {
            define(224, 57 /* Meta */);
        }
    }
    else if (isWebKit) {
        define(91, 57 /* Meta */);
        if (isMacintosh) {
            // the two meta keys in the Mac have different key codes (91 and 93)
            define(93, 57 /* Meta */);
        }
        else {
            define(92, 57 /* Meta */);
        }
    }
})();
function extractKeyCode(e) {
    if (e.charCode) {
        // "keypress" events mostly
        var char = String.fromCharCode(e.charCode).toUpperCase();
        return KeyCodeUtils.fromString(char);
    }
    return KEY_CODE_MAP[e.keyCode] || 0 /* Unknown */;
}
var ctrlKeyMod = (isMacintosh ? 256 /* WinCtrl */ : 2048 /* CtrlCmd */);
var altKeyMod = 512 /* Alt */;
var shiftKeyMod = 1024 /* Shift */;
var metaKeyMod = (isMacintosh ? 2048 /* CtrlCmd */ : 256 /* WinCtrl */);
var StandardKeyboardEvent = /** @class */ (function () {
    function StandardKeyboardEvent(source) {
        var e = source;
        this.browserEvent = e;
        this.target = e.target;
        this.ctrlKey = e.ctrlKey;
        this.shiftKey = e.shiftKey;
        this.altKey = e.altKey;
        this.metaKey = e.metaKey;
        this.keyCode = extractKeyCode(e);
        this.code = e.code;
        // console.info(e.type + ": keyCode: " + e.keyCode + ", which: " + e.which + ", charCode: " + e.charCode + ", detail: " + e.detail + " ====> " + this.keyCode + ' -- ' + KeyCode[this.keyCode]);
        this.ctrlKey = this.ctrlKey || this.keyCode === 5 /* Ctrl */;
        this.altKey = this.altKey || this.keyCode === 6 /* Alt */;
        this.shiftKey = this.shiftKey || this.keyCode === 4 /* Shift */;
        this.metaKey = this.metaKey || this.keyCode === 57 /* Meta */;
        this._asKeybinding = this._computeKeybinding();
        this._asRuntimeKeybinding = this._computeRuntimeKeybinding();
        // console.log(`code: ${e.code}, keyCode: ${e.keyCode}, key: ${e.key}`);
    }
    StandardKeyboardEvent.prototype.preventDefault = function () {
        if (this.browserEvent && this.browserEvent.preventDefault) {
            this.browserEvent.preventDefault();
        }
    };
    StandardKeyboardEvent.prototype.stopPropagation = function () {
        if (this.browserEvent && this.browserEvent.stopPropagation) {
            this.browserEvent.stopPropagation();
        }
    };
    StandardKeyboardEvent.prototype.toKeybinding = function () {
        return this._asRuntimeKeybinding;
    };
    StandardKeyboardEvent.prototype.equals = function (other) {
        return this._asKeybinding === other;
    };
    StandardKeyboardEvent.prototype._computeKeybinding = function () {
        var key = 0 /* Unknown */;
        if (this.keyCode !== 5 /* Ctrl */ && this.keyCode !== 4 /* Shift */ && this.keyCode !== 6 /* Alt */ && this.keyCode !== 57 /* Meta */) {
            key = this.keyCode;
        }
        var result = 0;
        if (this.ctrlKey) {
            result |= ctrlKeyMod;
        }
        if (this.altKey) {
            result |= altKeyMod;
        }
        if (this.shiftKey) {
            result |= shiftKeyMod;
        }
        if (this.metaKey) {
            result |= metaKeyMod;
        }
        result |= key;
        return result;
    };
    StandardKeyboardEvent.prototype._computeRuntimeKeybinding = function () {
        var key = 0 /* Unknown */;
        if (this.keyCode !== 5 /* Ctrl */ && this.keyCode !== 4 /* Shift */ && this.keyCode !== 6 /* Alt */ && this.keyCode !== 57 /* Meta */) {
            key = this.keyCode;
        }
        return new SimpleKeybinding(this.ctrlKey, this.shiftKey, this.altKey, this.metaKey, key);
    };
    return StandardKeyboardEvent;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var hasDifferentOriginAncestorFlag = false;
var sameOriginWindowChainCache = null;
function getParentWindowIfSameOrigin(w) {
    if (!w.parent || w.parent === w) {
        return null;
    }
    // Cannot really tell if we have access to the parent window unless we try to access something in it
    try {
        var location_1 = w.location;
        var parentLocation = w.parent.location;
        if (location_1.protocol !== parentLocation.protocol || location_1.hostname !== parentLocation.hostname || location_1.port !== parentLocation.port) {
            hasDifferentOriginAncestorFlag = true;
            return null;
        }
    }
    catch (e) {
        hasDifferentOriginAncestorFlag = true;
        return null;
    }
    return w.parent;
}
function findIframeElementInParentWindow(parentWindow, childWindow) {
    var parentWindowIframes = parentWindow.document.getElementsByTagName('iframe');
    var iframe;
    for (var i = 0, len = parentWindowIframes.length; i < len; i++) {
        iframe = parentWindowIframes[i];
        if (iframe.contentWindow === childWindow) {
            return iframe;
        }
    }
    return null;
}
var IframeUtils = /** @class */ (function () {
    function IframeUtils() {
    }
    /**
     * Returns a chain of embedded windows with the same origin (which can be accessed programmatically).
     * Having a chain of length 1 might mean that the current execution environment is running outside of an iframe or inside an iframe embedded in a window with a different origin.
     * To distinguish if at one point the current execution environment is running inside a window with a different origin, see hasDifferentOriginAncestor()
     */
    IframeUtils.getSameOriginWindowChain = function () {
        if (!sameOriginWindowChainCache) {
            sameOriginWindowChainCache = [];
            var w = window, parent_1;
            do {
                parent_1 = getParentWindowIfSameOrigin(w);
                if (parent_1) {
                    sameOriginWindowChainCache.push({
                        window: w,
                        iframeElement: findIframeElementInParentWindow(parent_1, w)
                    });
                }
                else {
                    sameOriginWindowChainCache.push({
                        window: w,
                        iframeElement: null
                    });
                }
                w = parent_1;
            } while (w);
        }
        return sameOriginWindowChainCache.slice(0);
    };
    /**
     * Returns true if the current execution environment is chained in a list of iframes which at one point ends in a window with a different origin.
     * Returns false if the current execution environment is not running inside an iframe or if the entire chain of iframes have the same origin.
     */
    IframeUtils.hasDifferentOriginAncestor = function () {
        if (!sameOriginWindowChainCache) {
            this.getSameOriginWindowChain();
        }
        return hasDifferentOriginAncestorFlag;
    };
    /**
     * Returns the position of `childWindow` relative to `ancestorWindow`
     */
    IframeUtils.getPositionOfChildWindowRelativeToAncestorWindow = function (childWindow, ancestorWindow) {
        if (!ancestorWindow || childWindow === ancestorWindow) {
            return {
                top: 0,
                left: 0
            };
        }
        var top = 0, left = 0;
        var windowChain = this.getSameOriginWindowChain();
        for (var i = 0; i < windowChain.length; i++) {
            var windowChainEl = windowChain[i];
            if (windowChainEl.window === ancestorWindow) {
                break;
            }
            if (!windowChainEl.iframeElement) {
                break;
            }
            var boundingRect = windowChainEl.iframeElement.getBoundingClientRect();
            top += boundingRect.top;
            left += boundingRect.left;
        }
        return {
            top: top,
            left: left
        };
    };
    return IframeUtils;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$4 = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var StandardMouseEvent = /** @class */ (function () {
    function StandardMouseEvent(e) {
        this.timestamp = Date.now();
        this.browserEvent = e;
        this.leftButton = e.button === 0;
        this.middleButton = e.button === 1;
        this.rightButton = e.button === 2;
        this.target = e.target;
        this.detail = e.detail || 1;
        if (e.type === 'dblclick') {
            this.detail = 2;
        }
        this.ctrlKey = e.ctrlKey;
        this.shiftKey = e.shiftKey;
        this.altKey = e.altKey;
        this.metaKey = e.metaKey;
        if (typeof e.pageX === 'number') {
            this.posx = e.pageX;
            this.posy = e.pageY;
        }
        else {
            // Probably hit by MSGestureEvent
            this.posx = e.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;
            this.posy = e.clientY + document.body.scrollTop + document.documentElement.scrollTop;
        }
        // Find the position of the iframe this code is executing in relative to the iframe where the event was captured.
        var iframeOffsets = IframeUtils.getPositionOfChildWindowRelativeToAncestorWindow(self, e.view);
        this.posx -= iframeOffsets.left;
        this.posy -= iframeOffsets.top;
    }
    StandardMouseEvent.prototype.preventDefault = function () {
        if (this.browserEvent.preventDefault) {
            this.browserEvent.preventDefault();
        }
    };
    StandardMouseEvent.prototype.stopPropagation = function () {
        if (this.browserEvent.stopPropagation) {
            this.browserEvent.stopPropagation();
        }
    };
    return StandardMouseEvent;
}());
var DragMouseEvent = /** @class */ (function (_super) {
    __extends$4(DragMouseEvent, _super);
    function DragMouseEvent(e) {
        var _this = _super.call(this, e) || this;
        _this.dataTransfer = e.dataTransfer;
        return _this;
    }
    return DragMouseEvent;
}(StandardMouseEvent));
var StandardMouseWheelEvent = /** @class */ (function () {
    function StandardMouseWheelEvent(e, deltaX, deltaY) {
        if (deltaX === void 0) { deltaX = 0; }
        if (deltaY === void 0) { deltaY = 0; }
        this.browserEvent = e || null;
        this.target = e ? (e.target || e.targetNode || e.srcElement) : null;
        this.deltaY = deltaY;
        this.deltaX = deltaX;
        if (e) {
            var e1 = e;
            var e2 = e;
            // vertical delta scroll
            if (typeof e1.wheelDeltaY !== 'undefined') {
                this.deltaY = e1.wheelDeltaY / 120;
            }
            else if (typeof e2.VERTICAL_AXIS !== 'undefined' && e2.axis === e2.VERTICAL_AXIS) {
                this.deltaY = -e2.detail / 3;
            }
            // horizontal delta scroll
            if (typeof e1.wheelDeltaX !== 'undefined') {
                if (isSafari && isWindows) {
                    this.deltaX = -(e1.wheelDeltaX / 120);
                }
                else {
                    this.deltaX = e1.wheelDeltaX / 120;
                }
            }
            else if (typeof e2.HORIZONTAL_AXIS !== 'undefined' && e2.axis === e2.HORIZONTAL_AXIS) {
                this.deltaX = -e.detail / 3;
            }
            // Assume a vertical scroll if nothing else worked
            if (this.deltaY === 0 && this.deltaX === 0 && e.wheelDelta) {
                this.deltaY = e.wheelDelta / 120;
            }
        }
    }
    StandardMouseWheelEvent.prototype.preventDefault = function () {
        if (this.browserEvent) {
            if (this.browserEvent.preventDefault) {
                this.browserEvent.preventDefault();
            }
        }
    };
    StandardMouseWheelEvent.prototype.stopPropagation = function () {
        if (this.browserEvent) {
            if (this.browserEvent.stopPropagation) {
                this.browserEvent.stopPropagation();
            }
        }
    };
    return StandardMouseWheelEvent;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var domEvent = function (element, type, useCapture) {
    var fn = function (e) { return emitter.fire(e); };
    var emitter = new Emitter({
        onFirstListenerAdd: function () {
            element.addEventListener(type, fn, useCapture);
        },
        onLastListenerRemove: function () {
            element.removeEventListener(type, fn, useCapture);
        }
    });
    return emitter.event;
};
function stop(event) {
    return mapEvent(event, function (e) {
        e.preventDefault();
        e.stopPropagation();
        return e;
    });
}

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$5 = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
function clearNode(node) {
    while (node.firstChild) {
        node.removeChild(node.firstChild);
    }
}
function isInDOM(node) {
    while (node) {
        if (node === document.body) {
            return true;
        }
        node = node.parentNode;
    }
    return false;
}
var _manualClassList = new /** @class */ (function () {
    function class_1() {
    }
    class_1.prototype._findClassName = function (node, className) {
        var classes = node.className;
        if (!classes) {
            this._lastStart = -1;
            return;
        }
        className = className.trim();
        var classesLen = classes.length, classLen = className.length;
        if (classLen === 0) {
            this._lastStart = -1;
            return;
        }
        if (classesLen < classLen) {
            this._lastStart = -1;
            return;
        }
        if (classes === className) {
            this._lastStart = 0;
            this._lastEnd = classesLen;
            return;
        }
        var idx = -1, idxEnd;
        while ((idx = classes.indexOf(className, idx + 1)) >= 0) {
            idxEnd = idx + classLen;
            // a class that is followed by another class
            if ((idx === 0 || classes.charCodeAt(idx - 1) === 32 /* Space */) && classes.charCodeAt(idxEnd) === 32 /* Space */) {
                this._lastStart = idx;
                this._lastEnd = idxEnd + 1;
                return;
            }
            // last class
            if (idx > 0 && classes.charCodeAt(idx - 1) === 32 /* Space */ && idxEnd === classesLen) {
                this._lastStart = idx - 1;
                this._lastEnd = idxEnd;
                return;
            }
            // equal - duplicate of cmp above
            if (idx === 0 && idxEnd === classesLen) {
                this._lastStart = 0;
                this._lastEnd = idxEnd;
                return;
            }
        }
        this._lastStart = -1;
    };
    class_1.prototype.hasClass = function (node, className) {
        this._findClassName(node, className);
        return this._lastStart !== -1;
    };
    class_1.prototype.addClasses = function (node) {
        var _this = this;
        var classNames = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            classNames[_i - 1] = arguments[_i];
        }
        classNames.forEach(function (nameValue) { return nameValue.split(' ').forEach(function (name) { return _this.addClass(node, name); }); });
    };
    class_1.prototype.addClass = function (node, className) {
        if (!node.className) { // doesn't have it for sure
            node.className = className;
        }
        else {
            this._findClassName(node, className); // see if it's already there
            if (this._lastStart === -1) {
                node.className = node.className + ' ' + className;
            }
        }
    };
    class_1.prototype.removeClass = function (node, className) {
        this._findClassName(node, className);
        if (this._lastStart === -1) {
            return; // Prevent styles invalidation if not necessary
        }
        else {
            node.className = node.className.substring(0, this._lastStart) + node.className.substring(this._lastEnd);
        }
    };
    class_1.prototype.removeClasses = function (node) {
        var _this = this;
        var classNames = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            classNames[_i - 1] = arguments[_i];
        }
        classNames.forEach(function (nameValue) { return nameValue.split(' ').forEach(function (name) { return _this.removeClass(node, name); }); });
    };
    class_1.prototype.toggleClass = function (node, className, shouldHaveIt) {
        this._findClassName(node, className);
        if (this._lastStart !== -1 && (shouldHaveIt === void 0 || !shouldHaveIt)) {
            this.removeClass(node, className);
        }
        if (this._lastStart === -1 && (shouldHaveIt === void 0 || shouldHaveIt)) {
            this.addClass(node, className);
        }
    };
    return class_1;
}());
var _nativeClassList = new /** @class */ (function () {
    function class_2() {
    }
    class_2.prototype.hasClass = function (node, className) {
        return className && node.classList && node.classList.contains(className);
    };
    class_2.prototype.addClasses = function (node) {
        var _this = this;
        var classNames = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            classNames[_i - 1] = arguments[_i];
        }
        classNames.forEach(function (nameValue) { return nameValue.split(' ').forEach(function (name) { return _this.addClass(node, name); }); });
    };
    class_2.prototype.addClass = function (node, className) {
        if (className && node.classList) {
            node.classList.add(className);
        }
    };
    class_2.prototype.removeClass = function (node, className) {
        if (className && node.classList) {
            node.classList.remove(className);
        }
    };
    class_2.prototype.removeClasses = function (node) {
        var _this = this;
        var classNames = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            classNames[_i - 1] = arguments[_i];
        }
        classNames.forEach(function (nameValue) { return nameValue.split(' ').forEach(function (name) { return _this.removeClass(node, name); }); });
    };
    class_2.prototype.toggleClass = function (node, className, shouldHaveIt) {
        if (node.classList) {
            node.classList.toggle(className, shouldHaveIt);
        }
    };
    return class_2;
}());
// In IE11 there is only partial support for `classList` which makes us keep our
// custom implementation. Otherwise use the native implementation, see: http://caniuse.com/#search=classlist
var _classList = isIE ? _manualClassList : _nativeClassList;
var hasClass = _classList.hasClass.bind(_classList);
var addClass = _classList.addClass.bind(_classList);
var addClasses = _classList.addClasses.bind(_classList);
var removeClass = _classList.removeClass.bind(_classList);
var removeClasses = _classList.removeClasses.bind(_classList);
var toggleClass = _classList.toggleClass.bind(_classList);
var DomListener = /** @class */ (function () {
    function DomListener(node, type, handler, useCapture) {
        this._node = node;
        this._type = type;
        this._handler = handler;
        this._useCapture = (useCapture || false);
        this._node.addEventListener(this._type, this._handler, this._useCapture);
    }
    DomListener.prototype.dispose = function () {
        if (!this._handler) {
            // Already disposed
            return;
        }
        this._node.removeEventListener(this._type, this._handler, this._useCapture);
        // Prevent leakers from holding on to the dom or handler func
        this._node = null;
        this._handler = null;
    };
    return DomListener;
}());
function addDisposableListener(node, type, handler, useCapture) {
    return new DomListener(node, type, handler, useCapture);
}
function _wrapAsStandardMouseEvent(handler) {
    return function (e) {
        return handler(new StandardMouseEvent(e));
    };
}
function _wrapAsStandardKeyboardEvent(handler) {
    return function (e) {
        return handler(new StandardKeyboardEvent(e));
    };
}
var addStandardDisposableListener = function addStandardDisposableListener(node, type, handler, useCapture) {
    var wrapHandler = handler;
    if (type === 'click' || type === 'mousedown') {
        wrapHandler = _wrapAsStandardMouseEvent(handler);
    }
    else if (type === 'keydown' || type === 'keypress' || type === 'keyup') {
        wrapHandler = _wrapAsStandardKeyboardEvent(handler);
    }
    return addDisposableListener(node, type, wrapHandler, useCapture);
};
function addDisposableNonBubblingMouseOutListener(node, handler) {
    return addDisposableListener(node, 'mouseout', function (e) {
        // Mouse out bubbles, so this is an attempt to ignore faux mouse outs coming from children elements
        var toElement = (e.relatedTarget || e.toElement);
        while (toElement && toElement !== node) {
            toElement = toElement.parentNode;
        }
        if (toElement === node) {
            return;
        }
        handler(e);
    });
}
var _animationFrame = null;
function doRequestAnimationFrame(callback) {
    if (!_animationFrame) {
        var emulatedRequestAnimationFrame = function (callback) {
            return setTimeout(function () { return callback(new Date().getTime()); }, 0);
        };
        _animationFrame = (self.requestAnimationFrame
            || self.msRequestAnimationFrame
            || self.webkitRequestAnimationFrame
            || self.mozRequestAnimationFrame
            || self.oRequestAnimationFrame
            || emulatedRequestAnimationFrame);
    }
    return _animationFrame.call(self, callback);
}
/**
 * Schedule a callback to be run at the next animation frame.
 * This allows multiple parties to register callbacks that should run at the next animation frame.
 * If currently in an animation frame, `runner` will be executed immediately.
 * @return token that can be used to cancel the scheduled runner (only if `runner` was not executed immediately).
 */
var runAtThisOrScheduleAtNextAnimationFrame;
/**
 * Schedule a callback to be run at the next animation frame.
 * This allows multiple parties to register callbacks that should run at the next animation frame.
 * If currently in an animation frame, `runner` will be executed at the next animation frame.
 * @return token that can be used to cancel the scheduled runner.
 */
var scheduleAtNextAnimationFrame;
var AnimationFrameQueueItem = /** @class */ (function () {
    function AnimationFrameQueueItem(runner, priority) {
        this._runner = runner;
        this.priority = priority;
        this._canceled = false;
    }
    AnimationFrameQueueItem.prototype.dispose = function () {
        this._canceled = true;
    };
    AnimationFrameQueueItem.prototype.execute = function () {
        if (this._canceled) {
            return;
        }
        try {
            this._runner();
        }
        catch (e) {
            onUnexpectedError(e);
        }
    };
    // Sort by priority (largest to lowest)
    AnimationFrameQueueItem.sort = function (a, b) {
        return b.priority - a.priority;
    };
    return AnimationFrameQueueItem;
}());
(function () {
    /**
     * The runners scheduled at the next animation frame
     */
    var NEXT_QUEUE = [];
    /**
     * The runners scheduled at the current animation frame
     */
    var CURRENT_QUEUE = null;
    /**
     * A flag to keep track if the native requestAnimationFrame was already called
     */
    var animFrameRequested = false;
    /**
     * A flag to indicate if currently handling a native requestAnimationFrame callback
     */
    var inAnimationFrameRunner = false;
    var animationFrameRunner = function () {
        animFrameRequested = false;
        CURRENT_QUEUE = NEXT_QUEUE;
        NEXT_QUEUE = [];
        inAnimationFrameRunner = true;
        while (CURRENT_QUEUE.length > 0) {
            CURRENT_QUEUE.sort(AnimationFrameQueueItem.sort);
            var top_1 = CURRENT_QUEUE.shift();
            top_1.execute();
        }
        inAnimationFrameRunner = false;
    };
    scheduleAtNextAnimationFrame = function (runner, priority) {
        if (priority === void 0) { priority = 0; }
        var item = new AnimationFrameQueueItem(runner, priority);
        NEXT_QUEUE.push(item);
        if (!animFrameRequested) {
            animFrameRequested = true;
            doRequestAnimationFrame(animationFrameRunner);
        }
        return item;
    };
    runAtThisOrScheduleAtNextAnimationFrame = function (runner, priority) {
        if (inAnimationFrameRunner) {
            var item = new AnimationFrameQueueItem(runner, priority);
            CURRENT_QUEUE.push(item);
            return item;
        }
        else {
            return scheduleAtNextAnimationFrame(runner, priority);
        }
    };
})();
var MINIMUM_TIME_MS = 16;
var DEFAULT_EVENT_MERGER = function (lastEvent, currentEvent) {
    return currentEvent;
};
var TimeoutThrottledDomListener = /** @class */ (function (_super) {
    __extends$5(TimeoutThrottledDomListener, _super);
    function TimeoutThrottledDomListener(node, type, handler, eventMerger, minimumTimeMs) {
        if (eventMerger === void 0) { eventMerger = DEFAULT_EVENT_MERGER; }
        if (minimumTimeMs === void 0) { minimumTimeMs = MINIMUM_TIME_MS; }
        var _this = _super.call(this) || this;
        var lastEvent = null;
        var lastHandlerTime = 0;
        var timeout = _this._register(new TimeoutTimer());
        var invokeHandler = function () {
            lastHandlerTime = (new Date()).getTime();
            handler(lastEvent);
            lastEvent = null;
        };
        _this._register(addDisposableListener(node, type, function (e) {
            lastEvent = eventMerger(lastEvent, e);
            var elapsedTime = (new Date()).getTime() - lastHandlerTime;
            if (elapsedTime >= minimumTimeMs) {
                timeout.cancel();
                invokeHandler();
            }
            else {
                timeout.setIfNotSet(invokeHandler, minimumTimeMs - elapsedTime);
            }
        }));
        return _this;
    }
    return TimeoutThrottledDomListener;
}(Disposable));
function addDisposableThrottledListener(node, type, handler, eventMerger, minimumTimeMs) {
    return new TimeoutThrottledDomListener(node, type, handler, eventMerger, minimumTimeMs);
}
function getComputedStyle(el) {
    return document.defaultView.getComputedStyle(el, null);
}
// Adapted from WinJS
// Converts a CSS positioning string for the specified element to pixels.
var convertToPixels = (function () {
    return function (element, value) {
        return parseFloat(value) || 0;
    };
})();
function getDimension(element, cssPropertyName, jsPropertyName) {
    var computedStyle = getComputedStyle(element);
    var value = '0';
    if (computedStyle) {
        if (computedStyle.getPropertyValue) {
            value = computedStyle.getPropertyValue(cssPropertyName);
        }
        else {
            // IE8
            value = computedStyle.getAttribute(jsPropertyName);
        }
    }
    return convertToPixels(element, value);
}
function getClientArea(element) {
    // Try with DOM clientWidth / clientHeight
    if (element !== document.body) {
        return new Dimension(element.clientWidth, element.clientHeight);
    }
    // Try innerWidth / innerHeight
    if (window.innerWidth && window.innerHeight) {
        return new Dimension(window.innerWidth, window.innerHeight);
    }
    // Try with document.body.clientWidth / document.body.clientHeigh
    if (document.body && document.body.clientWidth && document.body.clientWidth) {
        return new Dimension(document.body.clientWidth, document.body.clientHeight);
    }
    // Try with document.documentElement.clientWidth / document.documentElement.clientHeight
    if (document.documentElement && document.documentElement.clientWidth && document.documentElement.clientHeight) {
        return new Dimension(document.documentElement.clientWidth, document.documentElement.clientHeight);
    }
    throw new Error('Unable to figure out browser width and height');
}
var sizeUtils = {
    getBorderLeftWidth: function (element) {
        return getDimension(element, 'border-left-width', 'borderLeftWidth');
    },
    getBorderRightWidth: function (element) {
        return getDimension(element, 'border-right-width', 'borderRightWidth');
    },
    getBorderTopWidth: function (element) {
        return getDimension(element, 'border-top-width', 'borderTopWidth');
    },
    getBorderBottomWidth: function (element) {
        return getDimension(element, 'border-bottom-width', 'borderBottomWidth');
    },
    getPaddingLeft: function (element) {
        return getDimension(element, 'padding-left', 'paddingLeft');
    },
    getPaddingRight: function (element) {
        return getDimension(element, 'padding-right', 'paddingRight');
    },
    getPaddingTop: function (element) {
        return getDimension(element, 'padding-top', 'paddingTop');
    },
    getPaddingBottom: function (element) {
        return getDimension(element, 'padding-bottom', 'paddingBottom');
    },
    getMarginLeft: function (element) {
        return getDimension(element, 'margin-left', 'marginLeft');
    },
    getMarginTop: function (element) {
        return getDimension(element, 'margin-top', 'marginTop');
    },
    getMarginRight: function (element) {
        return getDimension(element, 'margin-right', 'marginRight');
    },
    getMarginBottom: function (element) {
        return getDimension(element, 'margin-bottom', 'marginBottom');
    },
    __commaSentinel: false
};
// ----------------------------------------------------------------------------------------
// Position & Dimension
var Dimension = /** @class */ (function () {
    function Dimension(width, height) {
        this.width = width;
        this.height = height;
    }
    return Dimension;
}());
function getTopLeftOffset(element) {
    // Adapted from WinJS.Utilities.getPosition
    // and added borders to the mix
    var offsetParent = element.offsetParent, top = element.offsetTop, left = element.offsetLeft;
    while ((element = element.parentNode) !== null && element !== document.body && element !== document.documentElement) {
        top -= element.scrollTop;
        var c = getComputedStyle(element);
        if (c) {
            left -= c.direction !== 'rtl' ? element.scrollLeft : -element.scrollLeft;
        }
        if (element === offsetParent) {
            left += sizeUtils.getBorderLeftWidth(element);
            top += sizeUtils.getBorderTopWidth(element);
            top += element.offsetTop;
            left += element.offsetLeft;
            offsetParent = element.offsetParent;
        }
    }
    return {
        left: left,
        top: top
    };
}
/**
 * Returns the position of a dom node relative to the entire page.
 */
function getDomNodePagePosition(domNode) {
    var bb = domNode.getBoundingClientRect();
    return {
        left: bb.left + StandardWindow.scrollX,
        top: bb.top + StandardWindow.scrollY,
        width: bb.width,
        height: bb.height
    };
}
var StandardWindow = new /** @class */ (function () {
    function class_3() {
    }
    Object.defineProperty(class_3.prototype, "scrollX", {
        get: function () {
            if (typeof window.scrollX === 'number') {
                // modern browsers
                return window.scrollX;
            }
            else {
                return document.body.scrollLeft + document.documentElement.scrollLeft;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(class_3.prototype, "scrollY", {
        get: function () {
            if (typeof window.scrollY === 'number') {
                // modern browsers
                return window.scrollY;
            }
            else {
                return document.body.scrollTop + document.documentElement.scrollTop;
            }
        },
        enumerable: true,
        configurable: true
    });
    return class_3;
}());
// Adapted from WinJS
// Gets the width of the element, including margins.
function getTotalWidth(element) {
    var margin = sizeUtils.getMarginLeft(element) + sizeUtils.getMarginRight(element);
    return element.offsetWidth + margin;
}
function getContentWidth(element) {
    var border = sizeUtils.getBorderLeftWidth(element) + sizeUtils.getBorderRightWidth(element);
    var padding = sizeUtils.getPaddingLeft(element) + sizeUtils.getPaddingRight(element);
    return element.offsetWidth - border - padding;
}
// Adapted from WinJS
// Gets the height of the content of the specified element. The content height does not include borders or padding.
function getContentHeight(element) {
    var border = sizeUtils.getBorderTopWidth(element) + sizeUtils.getBorderBottomWidth(element);
    var padding = sizeUtils.getPaddingTop(element) + sizeUtils.getPaddingBottom(element);
    return element.offsetHeight - border - padding;
}
// Adapted from WinJS
// Gets the height of the element, including its margins.
function getTotalHeight(element) {
    var margin = sizeUtils.getMarginTop(element) + sizeUtils.getMarginBottom(element);
    return element.offsetHeight + margin;
}
// ----------------------------------------------------------------------------------------
function isAncestor(testChild, testAncestor) {
    while (testChild) {
        if (testChild === testAncestor) {
            return true;
        }
        testChild = testChild.parentNode;
    }
    return false;
}
function findParentWithClass(node, clazz, stopAtClazz) {
    while (node) {
        if (hasClass(node, clazz)) {
            return node;
        }
        if (stopAtClazz && hasClass(node, stopAtClazz)) {
            return null;
        }
        node = node.parentNode;
    }
    return null;
}
function createStyleSheet(container) {
    if (container === void 0) { container = document.getElementsByTagName('head')[0]; }
    var style = document.createElement('style');
    style.type = 'text/css';
    style.media = 'screen';
    container.appendChild(style);
    return style;
}
var _sharedStyleSheet = null;
function getSharedStyleSheet() {
    if (!_sharedStyleSheet) {
        _sharedStyleSheet = createStyleSheet();
    }
    return _sharedStyleSheet;
}
function getDynamicStyleSheetRules(style) {
    if (style && style.sheet && style.sheet.rules) {
        // Chrome, IE
        return style.sheet.rules;
    }
    if (style && style.sheet && style.sheet.cssRules) {
        // FF
        return style.sheet.cssRules;
    }
    return [];
}
function createCSSRule(selector, cssText, style) {
    if (style === void 0) { style = getSharedStyleSheet(); }
    if (!style || !cssText) {
        return;
    }
    style.sheet.insertRule(selector + '{' + cssText + '}', 0);
}
function removeCSSRulesContainingSelector(ruleName, style) {
    if (style === void 0) { style = getSharedStyleSheet(); }
    if (!style) {
        return;
    }
    var rules = getDynamicStyleSheetRules(style);
    var toDelete = [];
    for (var i = 0; i < rules.length; i++) {
        var rule = rules[i];
        if (rule.selectorText.indexOf(ruleName) !== -1) {
            toDelete.push(i);
        }
    }
    for (var i = toDelete.length - 1; i >= 0; i--) {
        style.sheet.deleteRule(toDelete[i]);
    }
}
function isHTMLElement(o) {
    if (typeof HTMLElement === 'object') {
        return o instanceof HTMLElement;
    }
    return o && typeof o === 'object' && o.nodeType === 1 && typeof o.nodeName === 'string';
}
var EventType = {
    // Mouse
    CLICK: 'click',
    AUXCLICK: 'auxclick',
    DBLCLICK: 'dblclick',
    MOUSE_UP: 'mouseup',
    MOUSE_DOWN: 'mousedown',
    MOUSE_OVER: 'mouseover',
    MOUSE_MOVE: 'mousemove',
    MOUSE_OUT: 'mouseout',
    CONTEXT_MENU: 'contextmenu',
    WHEEL: 'wheel',
    // Keyboard
    KEY_DOWN: 'keydown',
    KEY_PRESS: 'keypress',
    KEY_UP: 'keyup',
    // HTML Document
    LOAD: 'load',
    UNLOAD: 'unload',
    ABORT: 'abort',
    ERROR: 'error',
    RESIZE: 'resize',
    SCROLL: 'scroll',
    // Form
    SELECT: 'select',
    CHANGE: 'change',
    SUBMIT: 'submit',
    RESET: 'reset',
    FOCUS: 'focus',
    BLUR: 'blur',
    INPUT: 'input',
    // Local Storage
    STORAGE: 'storage',
    // Drag
    DRAG_START: 'dragstart',
    DRAG: 'drag',
    DRAG_ENTER: 'dragenter',
    DRAG_LEAVE: 'dragleave',
    DRAG_OVER: 'dragover',
    DROP: 'drop',
    DRAG_END: 'dragend',
    // Animation
    ANIMATION_START: isWebKit ? 'webkitAnimationStart' : 'animationstart',
    ANIMATION_END: isWebKit ? 'webkitAnimationEnd' : 'animationend',
    ANIMATION_ITERATION: isWebKit ? 'webkitAnimationIteration' : 'animationiteration'
};
var EventHelper = {
    stop: function (e, cancelBubble) {
        if (e.preventDefault) {
            e.preventDefault();
        }
        else {
            // IE8
            e.returnValue = false;
        }
        if (cancelBubble) {
            if (e.stopPropagation) {
                e.stopPropagation();
            }
            else {
                // IE8
                e.cancelBubble = true;
            }
        }
    }
};
function saveParentsScrollTop(node) {
    var r = [];
    for (var i = 0; node && node.nodeType === node.ELEMENT_NODE; i++) {
        r[i] = node.scrollTop;
        node = node.parentNode;
    }
    return r;
}
function restoreParentsScrollTop(node, state) {
    for (var i = 0; node && node.nodeType === node.ELEMENT_NODE; i++) {
        if (node.scrollTop !== state[i]) {
            node.scrollTop = state[i];
        }
        node = node.parentNode;
    }
}
var FocusTracker = /** @class */ (function () {
    function FocusTracker(element) {
        var _this = this;
        this._onDidFocus = new Emitter();
        this.onDidFocus = this._onDidFocus.event;
        this._onDidBlur = new Emitter();
        this.onDidBlur = this._onDidBlur.event;
        this.disposables = [];
        var hasFocus = false;
        var loosingFocus = false;
        var onFocus = function () {
            loosingFocus = false;
            if (!hasFocus) {
                hasFocus = true;
                _this._onDidFocus.fire();
            }
        };
        var onBlur = function () {
            if (hasFocus) {
                loosingFocus = true;
                window.setTimeout(function () {
                    if (loosingFocus) {
                        loosingFocus = false;
                        hasFocus = false;
                        _this._onDidBlur.fire();
                    }
                }, 0);
            }
        };
        domEvent(element, EventType.FOCUS, true)(onFocus, null, this.disposables);
        domEvent(element, EventType.BLUR, true)(onBlur, null, this.disposables);
    }
    FocusTracker.prototype.dispose = function () {
        this.disposables = dispose(this.disposables);
        this._onDidFocus.dispose();
        this._onDidBlur.dispose();
    };
    return FocusTracker;
}());
function trackFocus(element) {
    return new FocusTracker(element);
}
function append(parent) {
    var children = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        children[_i - 1] = arguments[_i];
    }
    children.forEach(function (child) { return parent.appendChild(child); });
    return children[children.length - 1];
}
function prepend(parent, child) {
    parent.insertBefore(child, parent.firstChild);
    return child;
}
var SELECTOR_REGEX = /([\w\-]+)?(#([\w\-]+))?((.([\w\-]+))*)/;
// Similar to builder, but much more lightweight
function $(description, attrs) {
    var children = [];
    for (var _i = 2; _i < arguments.length; _i++) {
        children[_i - 2] = arguments[_i];
    }
    var match = SELECTOR_REGEX.exec(description);
    if (!match) {
        throw new Error('Bad use of emmet');
    }
    var result = document.createElement(match[1] || 'div');
    if (match[3]) {
        result.id = match[3];
    }
    if (match[4]) {
        result.className = match[4].replace(/\./g, ' ').trim();
    }
    Object.keys(attrs || {}).forEach(function (name) {
        if (/^on\w+$/.test(name)) {
            result[name] = attrs[name];
        }
        else if (name === 'selected') {
            var value = attrs[name];
            if (value) {
                result.setAttribute(name, 'true');
            }
        }
        else {
            result.setAttribute(name, attrs[name]);
        }
    });
    children
        .filter(function (child) { return !!child; })
        .forEach(function (child) {
        if (child instanceof Node) {
            result.appendChild(child);
        }
        else {
            result.appendChild(document.createTextNode(child));
        }
    });
    return result;
}
function show() {
    var elements = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        elements[_i] = arguments[_i];
    }
    for (var _a = 0, elements_1 = elements; _a < elements_1.length; _a++) {
        var element = elements_1[_a];
        element.style.display = '';
        element.removeAttribute('aria-hidden');
    }
}
function hide() {
    var elements = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        elements[_i] = arguments[_i];
    }
    for (var _a = 0, elements_2 = elements; _a < elements_2.length; _a++) {
        var element = elements_2[_a];
        element.style.display = 'none';
        element.setAttribute('aria-hidden', 'true');
    }
}
function findParentWithAttribute(node, attribute) {
    while (node) {
        if (node instanceof HTMLElement && node.hasAttribute(attribute)) {
            return node;
        }
        node = node.parentNode;
    }
    return null;
}
function removeTabIndexAndUpdateFocus(node) {
    if (!node || !node.hasAttribute('tabIndex')) {
        return;
    }
    // If we are the currently focused element and tabIndex is removed,
    // standard DOM behavior is to move focus to the <body> element. We
    // typically never want that, rather put focus to the closest element
    // in the hierarchy of the parent DOM nodes.
    if (document.activeElement === node) {
        var parentFocusable = findParentWithAttribute(node.parentElement, 'tabIndex');
        if (parentFocusable) {
            parentFocusable.focus();
        }
    }
    node.removeAttribute('tabindex');
}
function getElementsByTagName(tag) {
    return Array.prototype.slice.call(document.getElementsByTagName(tag), 0);
}
/**
 * Find a value usable for a dom node size such that the likelihood that it would be
 * displayed with constant screen pixels size is as high as possible.
 *
 * e.g. We would desire for the cursors to be 2px (CSS px) wide. Under a devicePixelRatio
 * of 1.25, the cursor will be 2.5 screen pixels wide. Depending on how the dom node aligns/"snaps"
 * with the screen pixels, it will sometimes be rendered with 2 screen pixels, and sometimes with 3 screen pixels.
 */
function computeScreenAwareSize(cssPx) {
    var screenPx = window.devicePixelRatio * cssPx;
    return Math.max(1, Math.floor(screenPx)) / window.devicePixelRatio;
}
/**
 * See https://github.com/Microsoft/monaco-editor/issues/601
 * To protect against malicious code in the linked site, particularly phishing attempts,
 * the window.opener should be set to null to prevent the linked site from having access
 * to change the location of the current page.
 * See https://mathiasbynens.github.io/rel-noopener/
 */
function windowOpenNoOpener(url) {
    if (isNative || isEdgeWebView) {
        // In VSCode, window.open() always returns null...
        // The same is true for a WebView (see https://github.com/Microsoft/monaco-editor/issues/628)
        window.open(url);
    }
    else {
        var newTab = window.open();
        if (newTab) {
            newTab.opener = null;
            newTab.location.href = url;
        }
    }
}

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var KeybindingsRegistryImpl = /** @class */ (function () {
    function KeybindingsRegistryImpl() {
        this.WEIGHT = {
            editorCore: function (importance) {
                if (importance === void 0) { importance = 0; }
                return 0 + importance;
            },
            editorContrib: function (importance) {
                if (importance === void 0) { importance = 0; }
                return 100 + importance;
            },
            workbenchContrib: function (importance) {
                if (importance === void 0) { importance = 0; }
                return 200 + importance;
            },
            builtinExtension: function (importance) {
                if (importance === void 0) { importance = 0; }
                return 300 + importance;
            },
            externalExtension: function (importance) {
                if (importance === void 0) { importance = 0; }
                return 400 + importance;
            }
        };
        this._keybindings = [];
        this._keybindingsSorted = true;
    }
    /**
     * Take current platform into account and reduce to primary & secondary.
     */
    KeybindingsRegistryImpl.bindToCurrentPlatform = function (kb) {
        if (OS === 1 /* Windows */) {
            if (kb && kb.win) {
                return kb.win;
            }
        }
        else if (OS === 2 /* Macintosh */) {
            if (kb && kb.mac) {
                return kb.mac;
            }
        }
        else {
            if (kb && kb.linux) {
                return kb.linux;
            }
        }
        return kb;
    };
    /**
     * Take current platform into account and reduce to primary & secondary.
     */
    KeybindingsRegistryImpl.bindToCurrentPlatform2 = function (kb) {
        if (OS === 1 /* Windows */) {
            if (kb && kb.win) {
                return kb.win;
            }
        }
        else if (OS === 2 /* Macintosh */) {
            if (kb && kb.mac) {
                return kb.mac;
            }
        }
        else {
            if (kb && kb.linux) {
                return kb.linux;
            }
        }
        return kb;
    };
    KeybindingsRegistryImpl.prototype.registerKeybindingRule = function (rule, source) {
        if (source === void 0) { source = 0 /* Core */; }
        var actualKb = KeybindingsRegistryImpl.bindToCurrentPlatform(rule);
        if (actualKb && actualKb.primary) {
            this._registerDefaultKeybinding(createKeybinding(actualKb.primary, OS), rule.id, rule.weight, 0, rule.when, source);
        }
        if (actualKb && Array.isArray(actualKb.secondary)) {
            for (var i = 0, len = actualKb.secondary.length; i < len; i++) {
                var k = actualKb.secondary[i];
                this._registerDefaultKeybinding(createKeybinding(k, OS), rule.id, rule.weight, -i - 1, rule.when, source);
            }
        }
    };
    KeybindingsRegistryImpl.prototype.registerKeybindingRule2 = function (rule, source) {
        if (source === void 0) { source = 0 /* Core */; }
        var actualKb = KeybindingsRegistryImpl.bindToCurrentPlatform2(rule);
        if (actualKb && actualKb.primary) {
            this._registerDefaultKeybinding(actualKb.primary, rule.id, rule.weight, 0, rule.when, source);
        }
    };
    KeybindingsRegistryImpl.prototype.registerCommandAndKeybindingRule = function (desc, source) {
        if (source === void 0) { source = 0 /* Core */; }
        this.registerKeybindingRule(desc, source);
        CommandsRegistry.registerCommand(desc);
    };
    KeybindingsRegistryImpl._mightProduceChar = function (keyCode) {
        if (keyCode >= 21 /* KEY_0 */ && keyCode <= 30 /* KEY_9 */) {
            return true;
        }
        if (keyCode >= 31 /* KEY_A */ && keyCode <= 56 /* KEY_Z */) {
            return true;
        }
        return (keyCode === 80 /* US_SEMICOLON */
            || keyCode === 81 /* US_EQUAL */
            || keyCode === 82 /* US_COMMA */
            || keyCode === 83 /* US_MINUS */
            || keyCode === 84 /* US_DOT */
            || keyCode === 85 /* US_SLASH */
            || keyCode === 86 /* US_BACKTICK */
            || keyCode === 110 /* ABNT_C1 */
            || keyCode === 111 /* ABNT_C2 */
            || keyCode === 87 /* US_OPEN_SQUARE_BRACKET */
            || keyCode === 88 /* US_BACKSLASH */
            || keyCode === 89 /* US_CLOSE_SQUARE_BRACKET */
            || keyCode === 90 /* US_QUOTE */
            || keyCode === 91 /* OEM_8 */
            || keyCode === 92 /* OEM_102 */);
    };
    KeybindingsRegistryImpl.prototype._assertNoCtrlAlt = function (keybinding, commandId) {
        if (keybinding.ctrlKey && keybinding.altKey && !keybinding.metaKey) {
            if (KeybindingsRegistryImpl._mightProduceChar(keybinding.keyCode)) {
                console.warn('Ctrl+Alt+ keybindings should not be used by default under Windows. Offender: ', keybinding, ' for ', commandId);
            }
        }
    };
    KeybindingsRegistryImpl.prototype._registerDefaultKeybinding = function (keybinding, commandId, weight1, weight2, when, source) {
        if (source === 0 /* Core */ && OS === 1 /* Windows */) {
            if (keybinding.type === 2 /* Chord */) {
                this._assertNoCtrlAlt(keybinding.firstPart, commandId);
            }
            else {
                this._assertNoCtrlAlt(keybinding, commandId);
            }
        }
        this._keybindings.push({
            keybinding: keybinding,
            command: commandId,
            commandArgs: null,
            when: when,
            weight1: weight1,
            weight2: weight2
        });
        this._keybindingsSorted = false;
    };
    KeybindingsRegistryImpl.prototype.getDefaultKeybindings = function () {
        if (!this._keybindingsSorted) {
            this._keybindings.sort(sorter);
            this._keybindingsSorted = true;
        }
        return this._keybindings.slice(0);
    };
    return KeybindingsRegistryImpl;
}());
var KeybindingsRegistry = new KeybindingsRegistryImpl();
// Define extension point ids
var Extensions$2 = {
    EditorModes: 'platform.keybindingsRegistry'
};
Registry.add(Extensions$2.EditorModes, KeybindingsRegistry);
function sorter(a, b) {
    if (a.weight1 !== b.weight1) {
        return a.weight1 - b.weight1;
    }
    if (a.command < b.command) {
        return -1;
    }
    if (a.command > b.command) {
        return 1;
    }
    return a.weight2 - b.weight2;
}

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var Action = /** @class */ (function () {
    function Action(id, label, cssClass, enabled, actionCallback) {
        if (label === void 0) { label = ''; }
        if (cssClass === void 0) { cssClass = ''; }
        if (enabled === void 0) { enabled = true; }
        this._onDidChange = new Emitter();
        this._id = id;
        this._label = label;
        this._cssClass = cssClass;
        this._enabled = enabled;
        this._actionCallback = actionCallback;
    }
    Action.prototype.dispose = function () {
        this._onDidChange.dispose();
    };
    Object.defineProperty(Action.prototype, "onDidChange", {
        get: function () {
            return this._onDidChange.event;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Action.prototype, "id", {
        get: function () {
            return this._id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Action.prototype, "label", {
        get: function () {
            return this._label;
        },
        set: function (value) {
            this._setLabel(value);
        },
        enumerable: true,
        configurable: true
    });
    Action.prototype._setLabel = function (value) {
        if (this._label !== value) {
            this._label = value;
            this._onDidChange.fire({ label: value });
        }
    };
    Object.defineProperty(Action.prototype, "tooltip", {
        get: function () {
            return this._tooltip;
        },
        set: function (value) {
            this._setTooltip(value);
        },
        enumerable: true,
        configurable: true
    });
    Action.prototype._setTooltip = function (value) {
        if (this._tooltip !== value) {
            this._tooltip = value;
            this._onDidChange.fire({ tooltip: value });
        }
    };
    Object.defineProperty(Action.prototype, "class", {
        get: function () {
            return this._cssClass;
        },
        set: function (value) {
            this._setClass(value);
        },
        enumerable: true,
        configurable: true
    });
    Action.prototype._setClass = function (value) {
        if (this._cssClass !== value) {
            this._cssClass = value;
            this._onDidChange.fire({ class: value });
        }
    };
    Object.defineProperty(Action.prototype, "enabled", {
        get: function () {
            return this._enabled;
        },
        set: function (value) {
            this._setEnabled(value);
        },
        enumerable: true,
        configurable: true
    });
    Action.prototype._setEnabled = function (value) {
        if (this._enabled !== value) {
            this._enabled = value;
            this._onDidChange.fire({ enabled: value });
        }
    };
    Object.defineProperty(Action.prototype, "checked", {
        get: function () {
            return this._checked;
        },
        set: function (value) {
            this._setChecked(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Action.prototype, "radio", {
        get: function () {
            return this._radio;
        },
        set: function (value) {
            this._setRadio(value);
        },
        enumerable: true,
        configurable: true
    });
    Action.prototype._setChecked = function (value) {
        if (this._checked !== value) {
            this._checked = value;
            this._onDidChange.fire({ checked: value });
        }
    };
    Action.prototype._setRadio = function (value) {
        if (this._radio !== value) {
            this._radio = value;
            this._onDidChange.fire({ radio: value });
        }
    };
    Object.defineProperty(Action.prototype, "order", {
        get: function () {
            return this._order;
        },
        set: function (value) {
            this._order = value;
        },
        enumerable: true,
        configurable: true
    });
    Action.prototype.run = function (event, data) {
        if (this._actionCallback !== void 0) {
            return this._actionCallback(event);
        }
        return TPromise.as(true);
    };
    return Action;
}());
var ActionRunner = /** @class */ (function () {
    function ActionRunner() {
        this._onDidBeforeRun = new Emitter();
        this._onDidRun = new Emitter();
    }
    Object.defineProperty(ActionRunner.prototype, "onDidRun", {
        get: function () {
            return this._onDidRun.event;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ActionRunner.prototype, "onDidBeforeRun", {
        get: function () {
            return this._onDidBeforeRun.event;
        },
        enumerable: true,
        configurable: true
    });
    ActionRunner.prototype.run = function (action, context) {
        var _this = this;
        if (!action.enabled) {
            return TPromise.as(null);
        }
        this._onDidBeforeRun.fire({ action: action });
        return this.runAction(action, context).then(function (result) {
            _this._onDidRun.fire({ action: action, result: result });
        }, function (error) {
            _this._onDidRun.fire({ action: action, error: error });
        });
    };
    ActionRunner.prototype.runAction = function (action, context) {
        var res = context ? action.run(context) : action.run();
        if (TPromise.is(res)) {
            return res;
        }
        return TPromise.wrap(res);
    };
    ActionRunner.prototype.dispose = function () {
        this._onDidBeforeRun.dispose();
        this._onDidRun.dispose();
    };
    return ActionRunner;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var SyncDescriptor = /** @class */ (function () {
    function SyncDescriptor(ctor) {
        var _staticArguments = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            _staticArguments[_i - 1] = arguments[_i];
        }
        this.ctor = ctor;
        this.staticArguments = _staticArguments;
    }
    return SyncDescriptor;
}());
var createSyncDescriptor = function (ctor) {
    var staticArguments = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        staticArguments[_i - 1] = arguments[_i];
    }
    return new (SyncDescriptor.bind.apply(SyncDescriptor, [void 0, ctor].concat(staticArguments)))();
};

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$6 = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var MenuId = /** @class */ (function () {
    function MenuId() {
        this.id = String(MenuId.ID++);
    }
    MenuId.ID = 1;
    MenuId.EditorTitle = new MenuId();
    MenuId.EditorTitleContext = new MenuId();
    MenuId.EditorContext = new MenuId();
    MenuId.ExplorerContext = new MenuId();
    MenuId.OpenEditorsContext = new MenuId();
    MenuId.ProblemsPanelContext = new MenuId();
    MenuId.DebugVariablesContext = new MenuId();
    MenuId.DebugWatchContext = new MenuId();
    MenuId.DebugCallStackContext = new MenuId();
    MenuId.DebugBreakpointsContext = new MenuId();
    MenuId.DebugConsoleContext = new MenuId();
    MenuId.SCMTitle = new MenuId();
    MenuId.SCMSourceControl = new MenuId();
    MenuId.SCMResourceGroupContext = new MenuId();
    MenuId.SCMResourceContext = new MenuId();
    MenuId.SCMChangeContext = new MenuId();
    MenuId.CommandPalette = new MenuId();
    MenuId.ViewTitle = new MenuId();
    MenuId.ViewItemContext = new MenuId();
    MenuId.TouchBarContext = new MenuId();
    MenuId.SearchContext = new MenuId();
    return MenuId;
}());
var IMenuService = createDecorator('menuService');
var MenuRegistry = new /** @class */ (function () {
    function class_1() {
        this._commands = Object.create(null);
        this._menuItems = Object.create(null);
    }
    class_1.prototype.addCommand = function (command) {
        var old = this._commands[command.id];
        this._commands[command.id] = command;
        return old !== void 0;
    };
    class_1.prototype.getCommand = function (id) {
        return this._commands[id];
    };
    class_1.prototype.appendMenuItem = function (_a, item) {
        var id = _a.id;
        var array = this._menuItems[id];
        if (!array) {
            this._menuItems[id] = array = [item];
        }
        else {
            array.push(item);
        }
        return {
            dispose: function () {
                var idx = array.indexOf(item);
                if (idx >= 0) {
                    array.splice(idx, 1);
                }
            }
        };
    };
    class_1.prototype.getMenuItems = function (_a) {
        var id = _a.id;
        var result = this._menuItems[id] || [];
        if (id === MenuId.CommandPalette.id) {
            // CommandPalette is special because it shows
            // all commands by default
            this._appendImplicitItems(result);
        }
        return result;
    };
    class_1.prototype._appendImplicitItems = function (result) {
        var set = new Set();
        for (var _i = 0, result_1 = result; _i < result_1.length; _i++) {
            var _a = result_1[_i], command = _a.command, alt = _a.alt;
            set.add(command.id);
            if (alt) {
                set.add(alt.id);
            }
        }
        for (var id in this._commands) {
            if (!set.has(id)) {
                result.push({ command: this._commands[id] });
            }
        }
    };
    return class_1;
}());
var ExecuteCommandAction = /** @class */ (function (_super) {
    __extends$6(ExecuteCommandAction, _super);
    function ExecuteCommandAction(id, label, _commandService) {
        var _this = _super.call(this, id, label) || this;
        _this._commandService = _commandService;
        return _this;
    }
    ExecuteCommandAction.prototype.run = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return (_a = this._commandService).executeCommand.apply(_a, [this.id].concat(args));
        var _a;
    };
    ExecuteCommandAction = __decorate([
        __param(2, ICommandService)
    ], ExecuteCommandAction);
    return ExecuteCommandAction;
}(Action));
var MenuItemAction = /** @class */ (function (_super) {
    __extends$6(MenuItemAction, _super);
    function MenuItemAction(item, alt, options, contextKeyService, commandService) {
        var _this = this;
        typeof item.title === 'string' ? _this = _super.call(this, item.id, item.title, commandService) || this : _this = _super.call(this, item.id, item.title.value, commandService) || this;
        _this._cssClass = undefined;
        _this._enabled = !item.precondition || contextKeyService.contextMatchesRules(item.precondition);
        _this._options = options || {};
        _this.item = item;
        _this.alt = alt ? new MenuItemAction(alt, undefined, _this._options, contextKeyService, commandService) : undefined;
        return _this;
    }
    MenuItemAction.prototype.run = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var runArgs = [];
        if (this._options.arg) {
            runArgs = runArgs.concat([this._options.arg]);
        }
        if (this._options.shouldForwardArgs) {
            runArgs = runArgs.concat(args);
        }
        return _super.prototype.run.apply(this, runArgs);
    };
    MenuItemAction = __decorate([
        __param(3, IContextKeyService),
        __param(4, ICommandService)
    ], MenuItemAction);
    return MenuItemAction;
}(ExecuteCommandAction));
var SyncActionDescriptor = /** @class */ (function () {
    function SyncActionDescriptor(ctor, id, label, keybindings, keybindingContext, keybindingWeight) {
        this._id = id;
        this._label = label;
        this._keybindings = keybindings;
        this._keybindingContext = keybindingContext;
        this._keybindingWeight = keybindingWeight;
        this._descriptor = createSyncDescriptor(ctor, this._id, this._label);
    }
    Object.defineProperty(SyncActionDescriptor.prototype, "syncDescriptor", {
        get: function () {
            return this._descriptor;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SyncActionDescriptor.prototype, "id", {
        get: function () {
            return this._id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SyncActionDescriptor.prototype, "label", {
        get: function () {
            return this._label;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SyncActionDescriptor.prototype, "keybindings", {
        get: function () {
            return this._keybindings;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SyncActionDescriptor.prototype, "keybindingContext", {
        get: function () {
            return this._keybindingContext;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SyncActionDescriptor.prototype, "keybindingWeight", {
        get: function () {
            return this._keybindingWeight;
        },
        enumerable: true,
        configurable: true
    });
    return SyncActionDescriptor;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __decorate$1 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$1 = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var Menu = /** @class */ (function () {
    function Menu(id, startupSignal, _commandService, _contextKeyService) {
        var _this = this;
        this._commandService = _commandService;
        this._contextKeyService = _contextKeyService;
        this._menuGroups = [];
        this._disposables = [];
        this._onDidChange = new Emitter();
        startupSignal.then(function (_) {
            var menuItems = MenuRegistry.getMenuItems(id);
            var keysFilter = new Set();
            var group;
            menuItems.sort(Menu._compareMenuItems);
            for (var _i = 0, menuItems_1 = menuItems; _i < menuItems_1.length; _i++) {
                var item = menuItems_1[_i];
                // group by groupId
                var groupName = item.group;
                if (!group || group[0] !== groupName) {
                    group = [groupName, []];
                    _this._menuGroups.push(group);
                }
                group[1].push(item);
                // keep keys for eventing
                Menu._fillInKbExprKeys(item.when, keysFilter);
            }
            // subscribe to context changes
            _this._disposables.push(_this._contextKeyService.onDidChangeContext(function (event) {
                if (event.affectsSome(keysFilter)) {
                    _this._onDidChange.fire();
                }
            }));
            _this._onDidChange.fire(_this);
        });
    }
    Menu.prototype.dispose = function () {
        this._disposables = dispose(this._disposables);
        this._onDidChange.dispose();
    };
    Object.defineProperty(Menu.prototype, "onDidChange", {
        get: function () {
            return this._onDidChange.event;
        },
        enumerable: true,
        configurable: true
    });
    Menu.prototype.getActions = function (options) {
        var result = [];
        for (var _i = 0, _a = this._menuGroups; _i < _a.length; _i++) {
            var group = _a[_i];
            var id = group[0], items = group[1];
            var activeActions = [];
            for (var _b = 0, items_1 = items; _b < items_1.length; _b++) {
                var item = items_1[_b];
                if (this._contextKeyService.contextMatchesRules(item.when)) {
                    var action = new MenuItemAction(item.command, item.alt, options, this._contextKeyService, this._commandService);
                    action.order = item.order; //TODO@Ben order is menu item property, not an action property
                    activeActions.push(action);
                }
            }
            if (activeActions.length > 0) {
                result.push([id, activeActions]);
            }
        }
        return result;
    };
    Menu._fillInKbExprKeys = function (exp, set) {
        if (exp) {
            for (var _i = 0, _a = exp.keys(); _i < _a.length; _i++) {
                var key = _a[_i];
                set.add(key);
            }
        }
    };
    Menu._compareMenuItems = function (a, b) {
        var aGroup = a.group;
        var bGroup = b.group;
        if (aGroup !== bGroup) {
            // Falsy groups come last
            if (!aGroup) {
                return 1;
            }
            else if (!bGroup) {
                return -1;
            }
            // 'navigation' group comes first
            if (aGroup === 'navigation') {
                return -1;
            }
            else if (bGroup === 'navigation') {
                return 1;
            }
            // lexical sort for groups
            var value = aGroup.localeCompare(bGroup);
            if (value !== 0) {
                return value;
            }
        }
        // sort on priority - default is 0
        var aPrio = a.order || 0;
        var bPrio = b.order || 0;
        if (aPrio < bPrio) {
            return -1;
        }
        else if (aPrio > bPrio) {
            return 1;
        }
        // sort on titles
        var aTitle = typeof a.command.title === 'string' ? a.command.title : a.command.title.value;
        var bTitle = typeof b.command.title === 'string' ? b.command.title : b.command.title.value;
        return aTitle.localeCompare(bTitle);
    };
    Menu = __decorate$1([
        __param$1(2, ICommandService),
        __param$1(3, IContextKeyService)
    ], Menu);
    return Menu;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var ResolvedKeybindingItem = /** @class */ (function () {
    function ResolvedKeybindingItem(resolvedKeybinding, command, commandArgs, when, isDefault) {
        this.resolvedKeybinding = resolvedKeybinding;
        if (resolvedKeybinding) {
            var _a = resolvedKeybinding.getDispatchParts(), keypressFirstPart = _a[0], keypressChordPart = _a[1];
            this.keypressFirstPart = keypressFirstPart;
            this.keypressChordPart = keypressChordPart;
        }
        else {
            this.keypressFirstPart = null;
            this.keypressChordPart = null;
        }
        this.bubble = (command ? command.charCodeAt(0) === 94 /* Caret */ : false);
        this.command = this.bubble ? command.substr(1) : command;
        this.commandArgs = commandArgs;
        this.when = when;
        this.isDefault = isDefault;
    }
    return ResolvedKeybindingItem;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var INotificationService = createDecorator('notificationService');
var NoOpNotification = /** @class */ (function () {
    function NoOpNotification() {
        this.progress = new NoOpProgress();
        this._onDidClose = new Emitter();
    }
    Object.defineProperty(NoOpNotification.prototype, "onDidClose", {
        get: function () {
            return this._onDidClose.event;
        },
        enumerable: true,
        configurable: true
    });
    NoOpNotification.prototype.updateSeverity = function (severity) { };
    NoOpNotification.prototype.updateMessage = function (message) { };
    NoOpNotification.prototype.updateActions = function (actions) { };
    NoOpNotification.prototype.close = function () {
        this._onDidClose.dispose();
    };
    return NoOpNotification;
}());
var NoOpProgress = /** @class */ (function () {
    function NoOpProgress() {
    }
    NoOpProgress.prototype.infinite = function () { };
    NoOpProgress.prototype.done = function () { };
    NoOpProgress.prototype.total = function (value) { };
    NoOpProgress.prototype.worked = function (value) { };
    return NoOpProgress;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$7 = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var SimpleEditor = /** @class */ (function () {
    function SimpleEditor(editor) {
        this._widget = editor;
    }
    SimpleEditor.prototype.getId = function () { return 'editor'; };
    SimpleEditor.prototype.getControl = function () { return this._widget; };
    SimpleEditor.prototype.focus = function () { this._widget.focus(); };
    SimpleEditor.prototype.isVisible = function () { return true; };
    SimpleEditor.prototype.withTypedEditor = function (codeEditorCallback, diffEditorCallback) {
        if (isCodeEditor(this._widget)) {
            // Single Editor
            return codeEditorCallback(this._widget);
        }
        else {
            // Diff Editor
            return diffEditorCallback(this._widget);
        }
    };
    return SimpleEditor;
}());
var SimpleModel = /** @class */ (function () {
    function SimpleModel(model) {
        this.model = model;
        this._onDispose = new Emitter();
    }
    Object.defineProperty(SimpleModel.prototype, "onDispose", {
        get: function () {
            return this._onDispose.event;
        },
        enumerable: true,
        configurable: true
    });
    SimpleModel.prototype.load = function () {
        return TPromise.as(this);
    };
    Object.defineProperty(SimpleModel.prototype, "textEditorModel", {
        get: function () {
            return this.model;
        },
        enumerable: true,
        configurable: true
    });
    SimpleModel.prototype.dispose = function () {
        this._onDispose.fire();
    };
    return SimpleModel;
}());
var SimpleEditorService = /** @class */ (function () {
    function SimpleEditorService() {
        this.openEditorDelegate = null;
    }
    SimpleEditorService.prototype.setEditor = function (editor) {
        this.editor = new SimpleEditor(editor);
    };
    SimpleEditorService.prototype.setOpenEditorDelegate = function (openEditorDelegate) {
        this.openEditorDelegate = openEditorDelegate;
    };
    SimpleEditorService.prototype.openEditor = function (typedData, sideBySide) {
        var _this = this;
        return TPromise.as(this.editor.withTypedEditor(function (editor) { return _this.doOpenEditor(editor, typedData); }, function (diffEditor) { return (_this.doOpenEditor(diffEditor.getOriginalEditor(), typedData) ||
            _this.doOpenEditor(diffEditor.getModifiedEditor(), typedData)); }));
    };
    SimpleEditorService.prototype.doOpenEditor = function (editor, data) {
        var model = this.findModel(editor, data);
        if (!model) {
            if (data.resource) {
                if (this.openEditorDelegate) {
                    this.openEditorDelegate(data.resource.toString());
                    return null;
                }
                else {
                    var schema = data.resource.scheme;
                    if (schema === Schemas.http || schema === Schemas.https) {
                        // This is a fully qualified http or https URL
                        windowOpenNoOpener(data.resource.toString());
                        return this.editor;
                    }
                }
            }
            return null;
        }
        var selection = data.options.selection;
        if (selection) {
            if (typeof selection.endLineNumber === 'number' && typeof selection.endColumn === 'number') {
                editor.setSelection(selection);
                editor.revealRangeInCenter(selection, 1 /* Immediate */);
            }
            else {
                var pos = {
                    lineNumber: selection.startLineNumber,
                    column: selection.startColumn
                };
                editor.setPosition(pos);
                editor.revealPositionInCenter(pos, 1 /* Immediate */);
            }
        }
        return this.editor;
    };
    SimpleEditorService.prototype.findModel = function (editor, data) {
        var model = editor.getModel();
        if (model.uri.toString() !== data.resource.toString()) {
            return null;
        }
        return model;
    };
    return SimpleEditorService;
}());
var SimpleEditorModelResolverService = /** @class */ (function () {
    function SimpleEditorModelResolverService() {
    }
    SimpleEditorModelResolverService.prototype.setEditor = function (editor) {
        this.editor = new SimpleEditor(editor);
    };
    SimpleEditorModelResolverService.prototype.createModelReference = function (resource) {
        var _this = this;
        var model;
        model = this.editor.withTypedEditor(function (editor) { return _this.findModel(editor, resource); }, function (diffEditor) { return _this.findModel(diffEditor.getOriginalEditor(), resource) || _this.findModel(diffEditor.getModifiedEditor(), resource); });
        if (!model) {
            return TPromise.as(new ImmortalReference(null));
        }
        return TPromise.as(new ImmortalReference(new SimpleModel(model)));
    };
    SimpleEditorModelResolverService.prototype.registerTextModelContentProvider = function (scheme, provider) {
        return {
            dispose: function () { }
        };
    };
    SimpleEditorModelResolverService.prototype.findModel = function (editor, resource) {
        var model = editor.getModel();
        if (model.uri.toString() !== resource.toString()) {
            return null;
        }
        return model;
    };
    return SimpleEditorModelResolverService;
}());
var SimpleProgressService = /** @class */ (function () {
    function SimpleProgressService() {
    }
    SimpleProgressService.prototype.show = function () {
        return SimpleProgressService.NULL_PROGRESS_RUNNER;
    };
    SimpleProgressService.prototype.showWhile = function (promise, delay) {
        return null;
    };
    SimpleProgressService.NULL_PROGRESS_RUNNER = {
        done: function () { },
        total: function () { },
        worked: function () { }
    };
    return SimpleProgressService;
}());
var SimpleDialogService = /** @class */ (function () {
    function SimpleDialogService() {
    }
    SimpleDialogService.prototype.confirm = function (confirmation) {
        return this.doConfirm(confirmation).then(function (confirmed) {
            return {
                confirmed: confirmed,
                checkboxChecked: false // unsupported
            };
        });
    };
    SimpleDialogService.prototype.doConfirm = function (confirmation) {
        var messageText = confirmation.message;
        if (confirmation.detail) {
            messageText = messageText + '\n\n' + confirmation.detail;
        }
        return TPromise.wrap(window.confirm(messageText));
    };
    SimpleDialogService.prototype.show = function (severity, message, buttons, options) {
        return TPromise.as(0);
    };
    return SimpleDialogService;
}());
var SimpleNotificationService = /** @class */ (function () {
    function SimpleNotificationService() {
    }
    SimpleNotificationService.prototype.info = function (message) {
        return this.notify({ severity: Severity$1.Info, message: message });
    };
    SimpleNotificationService.prototype.warn = function (message) {
        return this.notify({ severity: Severity$1.Warning, message: message });
    };
    SimpleNotificationService.prototype.error = function (error) {
        return this.notify({ severity: Severity$1.Error, message: error });
    };
    SimpleNotificationService.prototype.notify = function (notification) {
        switch (notification.severity) {
            case Severity$1.Error:
                console.error(notification.message);
                break;
            case Severity$1.Warning:
                console.warn(notification.message);
                break;
            default:
                console.log(notification.message);
                break;
        }
        return SimpleNotificationService.NO_OP;
    };
    SimpleNotificationService.prototype.prompt = function (severity, message, choices, onCancel) {
        return SimpleNotificationService.NO_OP;
    };
    SimpleNotificationService.NO_OP = new NoOpNotification();
    return SimpleNotificationService;
}());
var StandaloneCommandService = /** @class */ (function () {
    function StandaloneCommandService(instantiationService) {
        this._onWillExecuteCommand = new Emitter();
        this.onWillExecuteCommand = this._onWillExecuteCommand.event;
        this._instantiationService = instantiationService;
        this._dynamicCommands = Object.create(null);
    }
    StandaloneCommandService.prototype.addCommand = function (command) {
        var _this = this;
        var id = command.id;
        this._dynamicCommands[id] = command;
        return {
            dispose: function () {
                delete _this._dynamicCommands[id];
            }
        };
    };
    StandaloneCommandService.prototype.executeCommand = function (id) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        var command = (CommandsRegistry.getCommand(id) || this._dynamicCommands[id]);
        if (!command) {
            return TPromise.wrapError(new Error("command '" + id + "' not found"));
        }
        try {
            this._onWillExecuteCommand.fire({ commandId: id });
            var result = this._instantiationService.invokeFunction.apply(this._instantiationService, [command.handler].concat(args));
            return TPromise.as(result);
        }
        catch (err) {
            return TPromise.wrapError(err);
        }
    };
    return StandaloneCommandService;
}());
var StandaloneKeybindingService = /** @class */ (function (_super) {
    __extends$7(StandaloneKeybindingService, _super);
    function StandaloneKeybindingService(contextKeyService, commandService, telemetryService, notificationService, domNode) {
        var _this = _super.call(this, contextKeyService, commandService, telemetryService, notificationService) || this;
        _this._cachedResolver = null;
        _this._dynamicKeybindings = [];
        _this.toDispose.push(addDisposableListener(domNode, EventType.KEY_DOWN, function (e) {
            var keyEvent = new StandardKeyboardEvent(e);
            var shouldPreventDefault = _this._dispatch(keyEvent, keyEvent.target);
            if (shouldPreventDefault) {
                keyEvent.preventDefault();
            }
        }));
        return _this;
    }
    StandaloneKeybindingService.prototype.addDynamicKeybinding = function (commandId, keybinding, handler, when) {
        var _this = this;
        var toDispose = [];
        this._dynamicKeybindings.push({
            keybinding: createKeybinding(keybinding, OS),
            command: commandId,
            when: when,
            weight1: 1000,
            weight2: 0
        });
        toDispose.push({
            dispose: function () {
                for (var i = 0; i < _this._dynamicKeybindings.length; i++) {
                    var kb = _this._dynamicKeybindings[i];
                    if (kb.command === commandId) {
                        _this._dynamicKeybindings.splice(i, 1);
                        _this.updateResolver({ source: KeybindingSource.Default });
                        return;
                    }
                }
            }
        });
        var commandService = this._commandService;
        if (commandService instanceof StandaloneCommandService) {
            toDispose.push(commandService.addCommand({
                id: commandId,
                handler: handler
            }));
        }
        else {
            throw new Error('Unknown command service!');
        }
        this.updateResolver({ source: KeybindingSource.Default });
        return combinedDisposable(toDispose);
    };
    StandaloneKeybindingService.prototype.updateResolver = function (event) {
        this._cachedResolver = null;
        this._onDidUpdateKeybindings.fire(event);
    };
    StandaloneKeybindingService.prototype._getResolver = function () {
        if (!this._cachedResolver) {
            var defaults = this._toNormalizedKeybindingItems(KeybindingsRegistry.getDefaultKeybindings(), true);
            var overrides = this._toNormalizedKeybindingItems(this._dynamicKeybindings, false);
            this._cachedResolver = new KeybindingResolver(defaults, overrides);
        }
        return this._cachedResolver;
    };
    StandaloneKeybindingService.prototype._toNormalizedKeybindingItems = function (items, isDefault) {
        var result = [], resultLen = 0;
        for (var i = 0, len = items.length; i < len; i++) {
            var item = items[i];
            var when = (item.when ? item.when.normalize() : null);
            var keybinding = item.keybinding;
            if (!keybinding) {
                // This might be a removal keybinding item in user settings => accept it
                result[resultLen++] = new ResolvedKeybindingItem(null, item.command, item.commandArgs, when, isDefault);
            }
            else {
                var resolvedKeybindings = this.resolveKeybinding(keybinding);
                for (var j = 0; j < resolvedKeybindings.length; j++) {
                    result[resultLen++] = new ResolvedKeybindingItem(resolvedKeybindings[j], item.command, item.commandArgs, when, isDefault);
                }
            }
        }
        return result;
    };
    StandaloneKeybindingService.prototype.resolveKeybinding = function (keybinding) {
        return [new USLayoutResolvedKeybinding(keybinding, OS)];
    };
    StandaloneKeybindingService.prototype.resolveKeyboardEvent = function (keyboardEvent) {
        var keybinding = new SimpleKeybinding(keyboardEvent.ctrlKey, keyboardEvent.shiftKey, keyboardEvent.altKey, keyboardEvent.metaKey, keyboardEvent.keyCode);
        return new USLayoutResolvedKeybinding(keybinding, OS);
    };
    StandaloneKeybindingService.prototype.resolveUserBinding = function (userBinding) {
        return [];
    };
    return StandaloneKeybindingService;
}(AbstractKeybindingService));
function isConfigurationOverrides$1(thing) {
    return thing
        && typeof thing === 'object'
        && (!thing.overrideIdentifier || typeof thing.overrideIdentifier === 'string')
        && (!thing.resource || thing.resource instanceof URI);
}
var SimpleConfigurationService = /** @class */ (function () {
    function SimpleConfigurationService() {
        this._onDidChangeConfiguration = new Emitter();
        this.onDidChangeConfiguration = this._onDidChangeConfiguration.event;
        this._configuration = new Configuration(new DefaultConfigurationModel(), new ConfigurationModel());
    }
    SimpleConfigurationService.prototype.configuration = function () {
        return this._configuration;
    };
    SimpleConfigurationService.prototype.getValue = function (arg1, arg2) {
        var section = typeof arg1 === 'string' ? arg1 : void 0;
        var overrides = isConfigurationOverrides$1(arg1) ? arg1 : isConfigurationOverrides$1(arg2) ? arg2 : {};
        return this.configuration().getValue(section, overrides, null);
    };
    SimpleConfigurationService.prototype.updateValue = function (key, value, arg3, arg4) {
        return TPromise.as(null);
    };
    SimpleConfigurationService.prototype.inspect = function (key, options) {
        if (options === void 0) { options = {}; }
        return this.configuration().inspect(key, options, null);
    };
    SimpleConfigurationService.prototype.keys = function () {
        return this.configuration().keys(null);
    };
    SimpleConfigurationService.prototype.reloadConfiguration = function () {
        return TPromise.as(null);
    };
    SimpleConfigurationService.prototype.getConfigurationData = function () {
        return null;
    };
    return SimpleConfigurationService;
}());
var SimpleResourceConfigurationService = /** @class */ (function () {
    function SimpleResourceConfigurationService(configurationService) {
        var _this = this;
        this.configurationService = configurationService;
        this._onDidChangeConfigurationEmitter = new Emitter();
        this.configurationService.onDidChangeConfiguration(function (e) {
            _this._onDidChangeConfigurationEmitter.fire(e);
        });
    }
    SimpleResourceConfigurationService.prototype.getValue = function (resource, arg2, arg3) {
        var position$$1 = Position.isIPosition(arg2) ? arg2 : null;
        var section = position$$1 ? (typeof arg3 === 'string' ? arg3 : void 0) : (typeof arg2 === 'string' ? arg2 : void 0);
        return this.configurationService.getValue(section);
    };
    return SimpleResourceConfigurationService;
}());
var SimpleMenuService = /** @class */ (function () {
    function SimpleMenuService(commandService) {
        this._commandService = commandService;
    }
    SimpleMenuService.prototype.createMenu = function (id, contextKeyService) {
        return new Menu(id, TPromise.as(true), this._commandService, contextKeyService);
    };
    return SimpleMenuService;
}());
var StandaloneTelemetryService = /** @class */ (function () {
    function StandaloneTelemetryService() {
        this.isOptedIn = false;
    }
    StandaloneTelemetryService.prototype.publicLog = function (eventName, data) {
        return TPromise.wrap(null);
    };
    StandaloneTelemetryService.prototype.getTelemetryInfo = function () {
        return null;
    };
    return StandaloneTelemetryService;
}());
var SimpleWorkspaceContextService = /** @class */ (function () {
    function SimpleWorkspaceContextService() {
        this._onDidChangeWorkspaceName = new Emitter();
        this.onDidChangeWorkspaceName = this._onDidChangeWorkspaceName.event;
        this._onDidChangeWorkspaceFolders = new Emitter();
        this.onDidChangeWorkspaceFolders = this._onDidChangeWorkspaceFolders.event;
        this._onDidChangeWorkbenchState = new Emitter();
        this.onDidChangeWorkbenchState = this._onDidChangeWorkbenchState.event;
        var resource = URI.from({ scheme: SimpleWorkspaceContextService.SCHEME, authority: 'model', path: '/' });
        this.workspace = { id: '4064f6ec-cb38-4ad0-af64-ee6467e63c82', folders: [new WorkspaceFolder({ uri: resource, name: '', index: 0 })], name: resource.fsPath };
    }
    SimpleWorkspaceContextService.prototype.getWorkspace = function () {
        return this.workspace;
    };
    SimpleWorkspaceContextService.prototype.getWorkbenchState = function () {
        if (this.workspace) {
            if (this.workspace.configuration) {
                return WorkbenchState.WORKSPACE;
            }
            return WorkbenchState.FOLDER;
        }
        return WorkbenchState.EMPTY;
    };
    SimpleWorkspaceContextService.prototype.getWorkspaceFolder = function (resource) {
        return resource && resource.scheme === SimpleWorkspaceContextService.SCHEME ? this.workspace.folders[0] : void 0;
    };
    SimpleWorkspaceContextService.prototype.isInsideWorkspace = function (resource) {
        return resource && resource.scheme === SimpleWorkspaceContextService.SCHEME;
    };
    SimpleWorkspaceContextService.prototype.isCurrentWorkspace = function (workspaceIdentifier) {
        return true;
    };
    return SimpleWorkspaceContextService;
}());

const css$1 = "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n/* -------------------- IE10 remove auto clear button -------------------- */\n\n::-ms-clear {\n\tdisplay: none;\n}\n\n/* All widgets */\n/* I am not a big fan of this rule */\n.monaco-editor .editor-widget input {\n\tcolor: inherit;\n}\n\n/* -------------------- Editor -------------------- */\n\n.monaco-editor {\n\tposition: relative;\n\toverflow: visible;\n\t-webkit-text-size-adjust: 100%;\n\t-webkit-font-feature-settings: \"liga\" off, \"calt\" off;\n\tfont-feature-settings: \"liga\" off, \"calt\" off;\n}\n.monaco-editor.enable-ligatures {\n\t-webkit-font-feature-settings: \"liga\" on, \"calt\" on;\n\tfont-feature-settings: \"liga\" on, \"calt\" on;\n}\n\n/* -------------------- Misc -------------------- */\n\n.monaco-editor .overflow-guard {\n\tposition: relative;\n\toverflow: hidden;\n}\n\n.monaco-editor .view-overlays {\n\tposition: absolute;\n\ttop: 0;\n}";
  const element$1 = ((css, src) => {
if (typeof document !== 'object')
console.info(`Skipped loading "${src}"`);
try {
const id = src
  .replace(/\.css.*$/, '')
  .replace(/[\\:]/g, '/')
  .replace(/[^\w\/]+/g, '');
return (
  document.querySelector(`style[id="${id}"]`) ||
  document.head.appendChild(
    Object.assign(document.createElement('style'), {
      id,
      textContent: `${css}\n\n /* sourceURL=${src} */`,
    }),
  )
);
} catch (exception) {
console.warn(`Failed load "${src}"`, exception);
}
})(css$1, "…monaco-editor/esm/vs/editor/browser/widget/media/editor.css");
  //@ sourceURL=/Users/daflair/Projects/packages/monaco-es/node_modules/monaco-editor/esm/vs/editor/browser/widget/media/editor.css

const css$2 = "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n.monaco-editor .vs-whitespace {\n\tdisplay:inline-block;\n}\n\n";
  const element$2 = ((css, src) => {
if (typeof document !== 'object')
console.info(`Skipped loading "${src}"`);
try {
const id = src
  .replace(/\.css.*$/, '')
  .replace(/[\\:]/g, '/')
  .replace(/[^\w\/]+/g, '');
return (
  document.querySelector(`style[id="${id}"]`) ||
  document.head.appendChild(
    Object.assign(document.createElement('style'), {
      id,
      textContent: `${css}\n\n /* sourceURL=${src} */`,
    }),
  )
);
} catch (exception) {
console.warn(`Failed load "${src}"`, exception);
}
})(css$2, "…monaco-editor/esm/vs/editor/browser/widget/media/tokens.css");
  //@ sourceURL=/Users/daflair/Projects/packages/monaco-es/node_modules/monaco-editor/esm/vs/editor/browser/widget/media/tokens.css

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var ServiceCollection = /** @class */ (function () {
    function ServiceCollection() {
        var entries = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            entries[_i] = arguments[_i];
        }
        this._entries = new Map();
        for (var _a = 0, entries_1 = entries; _a < entries_1.length; _a++) {
            var _b = entries_1[_a], id = _b[0], service = _b[1];
            this.set(id, service);
        }
    }
    ServiceCollection.prototype.set = function (id, instanceOrDescriptor) {
        var result = this._entries.get(id);
        this._entries.set(id, instanceOrDescriptor);
        return result;
    };
    ServiceCollection.prototype.forEach = function (callback) {
        this._entries.forEach(function (value, key) { return callback(key, value); });
    };
    ServiceCollection.prototype.has = function (id) {
        return this._entries.has(id);
    };
    ServiceCollection.prototype.get = function (id) {
        return this._entries.get(id);
    };
    return ServiceCollection;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
/**
 * Vertical Lane in the overview ruler of the editor.
 */
var OverviewRulerLane;
(function (OverviewRulerLane) {
    OverviewRulerLane[OverviewRulerLane["Left"] = 1] = "Left";
    OverviewRulerLane[OverviewRulerLane["Center"] = 2] = "Center";
    OverviewRulerLane[OverviewRulerLane["Right"] = 4] = "Right";
    OverviewRulerLane[OverviewRulerLane["Full"] = 7] = "Full";
})(OverviewRulerLane || (OverviewRulerLane = {}));
/**
 * End of line character preference.
 */
var EndOfLinePreference;
(function (EndOfLinePreference) {
    /**
     * Use the end of line character identified in the text buffer.
     */
    EndOfLinePreference[EndOfLinePreference["TextDefined"] = 0] = "TextDefined";
    /**
     * Use line feed (\n) as the end of line character.
     */
    EndOfLinePreference[EndOfLinePreference["LF"] = 1] = "LF";
    /**
     * Use carriage return and line feed (\r\n) as the end of line character.
     */
    EndOfLinePreference[EndOfLinePreference["CRLF"] = 2] = "CRLF";
})(EndOfLinePreference || (EndOfLinePreference = {}));
/**
 * The default end of line to use when instantiating models.
 */
var DefaultEndOfLine;
(function (DefaultEndOfLine) {
    /**
     * Use line feed (\n) as the end of line character.
     */
    DefaultEndOfLine[DefaultEndOfLine["LF"] = 1] = "LF";
    /**
     * Use carriage return and line feed (\r\n) as the end of line character.
     */
    DefaultEndOfLine[DefaultEndOfLine["CRLF"] = 2] = "CRLF";
})(DefaultEndOfLine || (DefaultEndOfLine = {}));
/**
 * End of line character preference.
 */
var EndOfLineSequence;
(function (EndOfLineSequence) {
    /**
     * Use line feed (\n) as the end of line character.
     */
    EndOfLineSequence[EndOfLineSequence["LF"] = 0] = "LF";
    /**
     * Use carriage return and line feed (\r\n) as the end of line character.
     */
    EndOfLineSequence[EndOfLineSequence["CRLF"] = 1] = "CRLF";
})(EndOfLineSequence || (EndOfLineSequence = {}));
var TextModelResolvedOptions = /** @class */ (function () {
    /**
     * @internal
     */
    function TextModelResolvedOptions(src) {
        this.tabSize = src.tabSize | 0;
        this.insertSpaces = Boolean(src.insertSpaces);
        this.defaultEOL = src.defaultEOL | 0;
        this.trimAutoWhitespace = Boolean(src.trimAutoWhitespace);
    }
    /**
     * @internal
     */
    TextModelResolvedOptions.prototype.equals = function (other) {
        return (this.tabSize === other.tabSize
            && this.insertSpaces === other.insertSpaces
            && this.defaultEOL === other.defaultEOL
            && this.trimAutoWhitespace === other.trimAutoWhitespace);
    };
    /**
     * @internal
     */
    TextModelResolvedOptions.prototype.createChangeEvent = function (newOpts) {
        return {
            tabSize: this.tabSize !== newOpts.tabSize,
            insertSpaces: this.insertSpaces !== newOpts.insertSpaces,
            trimAutoWhitespace: this.trimAutoWhitespace !== newOpts.trimAutoWhitespace,
        };
    };
    return TextModelResolvedOptions;
}());
var FindMatch = /** @class */ (function () {
    /**
     * @internal
     */
    function FindMatch(range, matches) {
        this.range = range;
        this.matches = matches;
    }
    return FindMatch;
}());
/**
 * Describes the behavior of decorations when typing/editing near their edges.
 * Note: Please do not edit the values, as they very carefully match `DecorationRangeBehavior`
 */
var TrackedRangeStickiness;
(function (TrackedRangeStickiness) {
    TrackedRangeStickiness[TrackedRangeStickiness["AlwaysGrowsWhenTypingAtEdges"] = 0] = "AlwaysGrowsWhenTypingAtEdges";
    TrackedRangeStickiness[TrackedRangeStickiness["NeverGrowsWhenTypingAtEdges"] = 1] = "NeverGrowsWhenTypingAtEdges";
    TrackedRangeStickiness[TrackedRangeStickiness["GrowsOnlyWhenTypingBefore"] = 2] = "GrowsOnlyWhenTypingBefore";
    TrackedRangeStickiness[TrackedRangeStickiness["GrowsOnlyWhenTypingAfter"] = 3] = "GrowsOnlyWhenTypingAfter";
})(TrackedRangeStickiness || (TrackedRangeStickiness = {}));
/**
 * @internal
 */
var ApplyEditsResult = /** @class */ (function () {
    function ApplyEditsResult(reverseEdits, changes, trimAutoWhitespaceLineNumbers) {
        this.reverseEdits = reverseEdits;
        this.changes = changes;
        this.trimAutoWhitespaceLineNumbers = trimAutoWhitespaceLineNumbers;
    }
    return ApplyEditsResult;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var GLOBSTAR = '**';
var GLOB_SPLIT = '/';
var PATH_REGEX = '[/\\\\]'; // any slash or backslash
var NO_PATH_REGEX = '[^/\\\\]'; // any non-slash and non-backslash
var ALL_FORWARD_SLASHES = /\//g;
function starsToRegExp(starCount) {
    switch (starCount) {
        case 0:
            return '';
        case 1:
            return NO_PATH_REGEX + "*?"; // 1 star matches any number of characters except path separator (/ and \) - non greedy (?)
        default:
            // Matches:  (Path Sep OR Path Val followed by Path Sep OR Path Sep followed by Path Val) 0-many times
            // Group is non capturing because we don't need to capture at all (?:...)
            // Overall we use non-greedy matching because it could be that we match too much
            return "(?:" + PATH_REGEX + "|" + NO_PATH_REGEX + "+" + PATH_REGEX + "|" + PATH_REGEX + NO_PATH_REGEX + "+)*?";
    }
}
function splitGlobAware(pattern, splitChar) {
    if (!pattern) {
        return [];
    }
    var segments = [];
    var inBraces = false;
    var inBrackets = false;
    var char;
    var curVal = '';
    for (var i = 0; i < pattern.length; i++) {
        char = pattern[i];
        switch (char) {
            case splitChar:
                if (!inBraces && !inBrackets) {
                    segments.push(curVal);
                    curVal = '';
                    continue;
                }
                break;
            case '{':
                inBraces = true;
                break;
            case '}':
                inBraces = false;
                break;
            case '[':
                inBrackets = true;
                break;
            case ']':
                inBrackets = false;
                break;
        }
        curVal += char;
    }
    // Tail
    if (curVal) {
        segments.push(curVal);
    }
    return segments;
}
function parseRegExp(pattern) {
    if (!pattern) {
        return '';
    }
    var regEx = '';
    // Split up into segments for each slash found
    var segments = splitGlobAware(pattern, GLOB_SPLIT);
    // Special case where we only have globstars
    if (segments.every(function (s) { return s === GLOBSTAR; })) {
        regEx = '.*';
    }
    // Build regex over segments
    else {
        var previousSegmentWasGlobStar_1 = false;
        segments.forEach(function (segment, index$$1) {
            // Globstar is special
            if (segment === GLOBSTAR) {
                // if we have more than one globstar after another, just ignore it
                if (!previousSegmentWasGlobStar_1) {
                    regEx += starsToRegExp(2);
                    previousSegmentWasGlobStar_1 = true;
                }
                return;
            }
            // States
            var inBraces = false;
            var braceVal = '';
            var inBrackets = false;
            var bracketVal = '';
            var char;
            for (var i = 0; i < segment.length; i++) {
                char = segment[i];
                // Support brace expansion
                if (char !== '}' && inBraces) {
                    braceVal += char;
                    continue;
                }
                // Support brackets
                if (inBrackets && (char !== ']' || !bracketVal) /* ] is literally only allowed as first character in brackets to match it */) {
                    var res = void 0;
                    // range operator
                    if (char === '-') {
                        res = char;
                    }
                    // negation operator (only valid on first index in bracket)
                    else if ((char === '^' || char === '!') && !bracketVal) {
                        res = '^';
                    }
                    // glob split matching is not allowed within character ranges
                    // see http://man7.org/linux/man-pages/man7/glob.7.html
                    else if (char === GLOB_SPLIT) {
                        res = '';
                    }
                    // anything else gets escaped
                    else {
                        res = escapeRegExpCharacters(char);
                    }
                    bracketVal += res;
                    continue;
                }
                switch (char) {
                    case '{':
                        inBraces = true;
                        continue;
                    case '[':
                        inBrackets = true;
                        continue;
                    case '}':
                        var choices = splitGlobAware(braceVal, ',');
                        // Converts {foo,bar} => [foo|bar]
                        var braceRegExp = "(?:" + choices.map(function (c) { return parseRegExp(c); }).join('|') + ")";
                        regEx += braceRegExp;
                        inBraces = false;
                        braceVal = '';
                        break;
                    case ']':
                        regEx += ('[' + bracketVal + ']');
                        inBrackets = false;
                        bracketVal = '';
                        break;
                    case '?':
                        regEx += NO_PATH_REGEX; // 1 ? matches any single character except path separator (/ and \)
                        continue;
                    case '*':
                        regEx += starsToRegExp(1);
                        continue;
                    default:
                        regEx += escapeRegExpCharacters(char);
                }
            }
            // Tail: Add the slash we had split on if there is more to come and the remaining pattern is not a globstar
            // For example if pattern: some/**/*.js we want the "/" after some to be included in the RegEx to prevent
            // a folder called "something" to match as well.
            // However, if pattern: some/**, we tolerate that we also match on "something" because our globstar behaviour
            // is to match 0-N segments.
            if (index$$1 < segments.length - 1 && (segments[index$$1 + 1] !== GLOBSTAR || index$$1 + 2 < segments.length)) {
                regEx += PATH_REGEX;
            }
            // reset state
            previousSegmentWasGlobStar_1 = false;
        });
    }
    return regEx;
}
// regexes to check for trival glob patterns that just check for String#endsWith
var T1 = /^\*\*\/\*\.[\w\.-]+$/; // **/*.something
var T2 = /^\*\*\/([\w\.-]+)\/?$/; // **/something
var T3 = /^{\*\*\/[\*\.]?[\w\.-]+\/?(,\*\*\/[\*\.]?[\w\.-]+\/?)*}$/; // {**/*.something,**/*.else} or {**/package.json,**/project.json}
var T3_2 = /^{\*\*\/[\*\.]?[\w\.-]+(\/(\*\*)?)?(,\*\*\/[\*\.]?[\w\.-]+(\/(\*\*)?)?)*}$/; // Like T3, with optional trailing /**
var T4 = /^\*\*((\/[\w\.-]+)+)\/?$/; // **/something/else
var T5 = /^([\w\.-]+(\/[\w\.-]+)*)\/?$/; // something/else
var CACHE = new LRUCache(10000); // bounded to 10000 elements
var FALSE = function () {
    return false;
};
var NULL = function () {
    return null;
};
function parsePattern(arg1, options) {
    if (!arg1) {
        return NULL;
    }
    // Handle IRelativePattern
    var pattern;
    if (typeof arg1 !== 'string') {
        pattern = arg1.pattern;
    }
    else {
        pattern = arg1;
    }
    // Whitespace trimming
    pattern = pattern.trim();
    // Check cache
    var patternKey = pattern + "_" + !!options.trimForExclusions;
    var parsedPattern = CACHE.get(patternKey);
    if (parsedPattern) {
        return wrapRelativePattern(parsedPattern, arg1);
    }
    // Check for Trivias
    var match;
    if (T1.test(pattern)) { // common pattern: **/*.txt just need endsWith check
        var base_1 = pattern.substr(4); // '**/*'.length === 4
        parsedPattern = function (path, basename$$1) {
            return path && endsWith(path, base_1) ? pattern : null;
        };
    }
    else if (match = T2.exec(trimForExclusions(pattern, options))) { // common pattern: **/some.txt just need basename check
        parsedPattern = trivia2(match[1], pattern);
    }
    else if ((options.trimForExclusions ? T3_2 : T3).test(pattern)) { // repetition of common patterns (see above) {**/*.txt,**/*.png}
        parsedPattern = trivia3(pattern, options);
    }
    else if (match = T4.exec(trimForExclusions(pattern, options))) { // common pattern: **/something/else just need endsWith check
        parsedPattern = trivia4and5(match[1].substr(1), pattern, true);
    }
    else if (match = T5.exec(trimForExclusions(pattern, options))) { // common pattern: something/else just need equals check
        parsedPattern = trivia4and5(match[1], pattern, false);
    }
    // Otherwise convert to pattern
    else {
        parsedPattern = toRegExp(pattern);
    }
    // Cache
    CACHE.set(patternKey, parsedPattern);
    return wrapRelativePattern(parsedPattern, arg1);
}
function wrapRelativePattern(parsedPattern, arg2) {
    if (typeof arg2 === 'string') {
        return parsedPattern;
    }
    return function (path, basename$$1) {
        if (!isEqualOrParent(path, arg2.base)) {
            return null;
        }
        return parsedPattern(normalize(arg2.pathToRelative(arg2.base, path)), basename$$1);
    };
}
function trimForExclusions(pattern, options) {
    return options.trimForExclusions && endsWith(pattern, '/**') ? pattern.substr(0, pattern.length - 2) : pattern; // dropping **, tailing / is dropped later
}
// common pattern: **/some.txt just need basename check
function trivia2(base, originalPattern) {
    var slashBase = "/" + base;
    var backslashBase = "\\" + base;
    var parsedPattern = function (path, basename$$1) {
        if (!path) {
            return null;
        }
        if (basename$$1) {
            return basename$$1 === base ? originalPattern : null;
        }
        return path === base || endsWith(path, slashBase) || endsWith(path, backslashBase) ? originalPattern : null;
    };
    var basenames = [base];
    parsedPattern.basenames = basenames;
    parsedPattern.patterns = [originalPattern];
    parsedPattern.allBasenames = basenames;
    return parsedPattern;
}
// repetition of common patterns (see above) {**/*.txt,**/*.png}
function trivia3(pattern, options) {
    var parsedPatterns = aggregateBasenameMatches(pattern.slice(1, -1).split(',')
        .map(function (pattern) { return parsePattern(pattern, options); })
        .filter(function (pattern) { return pattern !== NULL; }), pattern);
    var n = parsedPatterns.length;
    if (!n) {
        return NULL;
    }
    if (n === 1) {
        return parsedPatterns[0];
    }
    var parsedPattern = function (path, basename$$1) {
        for (var i = 0, n_1 = parsedPatterns.length; i < n_1; i++) {
            if (parsedPatterns[i](path, basename$$1)) {
                return pattern;
            }
        }
        return null;
    };
    var withBasenames = first(parsedPatterns, function (pattern) { return !!pattern.allBasenames; });
    if (withBasenames) {
        parsedPattern.allBasenames = withBasenames.allBasenames;
    }
    var allPaths = parsedPatterns.reduce(function (all, current) { return current.allPaths ? all.concat(current.allPaths) : all; }, []);
    if (allPaths.length) {
        parsedPattern.allPaths = allPaths;
    }
    return parsedPattern;
}
// common patterns: **/something/else just need endsWith check, something/else just needs and equals check
function trivia4and5(path, pattern, matchPathEnds) {
    var nativePath = nativeSep !== sep ? path.replace(ALL_FORWARD_SLASHES, nativeSep) : path;
    var nativePathEnd = nativeSep + nativePath;
    var parsedPattern = matchPathEnds ? function (path, basename$$1) {
        return path && (path === nativePath || endsWith(path, nativePathEnd)) ? pattern : null;
    } : function (path, basename$$1) {
        return path && path === nativePath ? pattern : null;
    };
    parsedPattern.allPaths = [(matchPathEnds ? '*/' : './') + path];
    return parsedPattern;
}
function toRegExp(pattern) {
    try {
        var regExp_1 = new RegExp("^" + parseRegExp(pattern) + "$");
        return function (path, basename$$1) {
            regExp_1.lastIndex = 0; // reset RegExp to its initial state to reuse it!
            return path && regExp_1.test(path) ? pattern : null;
        };
    }
    catch (error) {
        return NULL;
    }
}
function match(arg1, path, siblingsFn) {
    if (!arg1 || !path) {
        return false;
    }
    return parse$1(arg1)(path, undefined, siblingsFn);
}
function parse$1(arg1, options) {
    if (options === void 0) { options = {}; }
    if (!arg1) {
        return FALSE;
    }
    // Glob with String
    if (typeof arg1 === 'string' || isRelativePattern(arg1)) {
        var parsedPattern_1 = parsePattern(arg1, options);
        if (parsedPattern_1 === NULL) {
            return FALSE;
        }
        var resultPattern = function (path, basename$$1) {
            return !!parsedPattern_1(path, basename$$1);
        };
        if (parsedPattern_1.allBasenames) {
            resultPattern.allBasenames = parsedPattern_1.allBasenames;
        }
        if (parsedPattern_1.allPaths) {
            resultPattern.allPaths = parsedPattern_1.allPaths;
        }
        return resultPattern;
    }
    // Glob with Expression
    return parsedExpression(arg1, options);
}
function isRelativePattern(obj) {
    var rp = obj;
    return rp && typeof rp.base === 'string' && typeof rp.pattern === 'string' && typeof rp.pathToRelative === 'function';
}
function parsedExpression(expression, options) {
    var parsedPatterns = aggregateBasenameMatches(Object.getOwnPropertyNames(expression)
        .map(function (pattern) { return parseExpressionPattern(pattern, expression[pattern], options); })
        .filter(function (pattern) { return pattern !== NULL; }));
    var n = parsedPatterns.length;
    if (!n) {
        return NULL;
    }
    if (!parsedPatterns.some(function (parsedPattern) { return parsedPattern.requiresSiblings; })) {
        if (n === 1) {
            return parsedPatterns[0];
        }
        var resultExpression_1 = function (path, basename$$1, siblingsFn) {
            for (var i = 0, n_2 = parsedPatterns.length; i < n_2; i++) {
                // Pattern matches path
                var result = parsedPatterns[i](path, basename$$1);
                if (result) {
                    return result;
                }
            }
            return null;
        };
        var withBasenames_1 = first(parsedPatterns, function (pattern) { return !!pattern.allBasenames; });
        if (withBasenames_1) {
            resultExpression_1.allBasenames = withBasenames_1.allBasenames;
        }
        var allPaths_1 = parsedPatterns.reduce(function (all, current) { return current.allPaths ? all.concat(current.allPaths) : all; }, []);
        if (allPaths_1.length) {
            resultExpression_1.allPaths = allPaths_1;
        }
        return resultExpression_1;
    }
    var resultExpression = function (path, basename$$1, siblingsFn) {
        var siblingsPattern;
        var siblingsResolved = !siblingsFn;
        function siblingsToSiblingsPattern(siblings) {
            if (siblings && siblings.length) {
                if (!basename$$1) {
                    basename$$1 = basename(path);
                }
                var name_1 = basename$$1.substr(0, basename$$1.length - extname(path).length);
                return { siblings: siblings, name: name_1 };
            }
            return undefined;
        }
        function siblingsPatternFn() {
            // Resolve siblings only once
            if (!siblingsResolved) {
                siblingsResolved = true;
                var siblings = siblingsFn();
                siblingsPattern = TPromise.is(siblings) ?
                    siblings.then(siblingsToSiblingsPattern) :
                    siblingsToSiblingsPattern(siblings);
            }
            return siblingsPattern;
        }
        for (var i = 0, n_3 = parsedPatterns.length; i < n_3; i++) {
            // Pattern matches path
            var result = parsedPatterns[i](path, basename$$1, siblingsPatternFn);
            if (result) {
                return result;
            }
        }
        return null;
    };
    var withBasenames = first(parsedPatterns, function (pattern) { return !!pattern.allBasenames; });
    if (withBasenames) {
        resultExpression.allBasenames = withBasenames.allBasenames;
    }
    var allPaths = parsedPatterns.reduce(function (all, current) { return current.allPaths ? all.concat(current.allPaths) : all; }, []);
    if (allPaths.length) {
        resultExpression.allPaths = allPaths;
    }
    return resultExpression;
}
function parseExpressionPattern(pattern, value, options) {
    if (value === false) {
        return NULL; // pattern is disabled
    }
    var parsedPattern = parsePattern(pattern, options);
    if (parsedPattern === NULL) {
        return NULL;
    }
    // Expression Pattern is <boolean>
    if (typeof value === 'boolean') {
        return parsedPattern;
    }
    // Expression Pattern is <SiblingClause>
    if (value) {
        var when_1 = value.when;
        if (typeof when_1 === 'string') {
            var siblingsPatternToMatchingPattern_1 = function (siblingsPattern) {
                var clausePattern = when_1.replace('$(basename)', siblingsPattern.name);
                if (siblingsPattern.siblings.indexOf(clausePattern) !== -1) {
                    return pattern;
                }
                else {
                    return null; // pattern does not match in the end because the when clause is not satisfied
                }
            };
            var result = function (path, basename$$1, siblingsPatternFn) {
                if (!parsedPattern(path, basename$$1)) {
                    return null;
                }
                var siblingsPattern = siblingsPatternFn();
                if (!siblingsPattern) {
                    return null; // pattern is malformed or we don't have siblings
                }
                return TPromise.is(siblingsPattern) ?
                    siblingsPattern.then(siblingsPatternToMatchingPattern_1) :
                    siblingsPatternToMatchingPattern_1(siblingsPattern);
            };
            result.requiresSiblings = true;
            return result;
        }
    }
    // Expression is Anything
    return parsedPattern;
}
function aggregateBasenameMatches(parsedPatterns, result) {
    var basenamePatterns = parsedPatterns.filter(function (parsedPattern) { return !!parsedPattern.basenames; });
    if (basenamePatterns.length < 2) {
        return parsedPatterns;
    }
    var basenames = basenamePatterns.reduce(function (all, current) { return all.concat(current.basenames); }, []);
    var patterns;
    if (result) {
        patterns = [];
        for (var i = 0, n = basenames.length; i < n; i++) {
            patterns.push(result);
        }
    }
    else {
        patterns = basenamePatterns.reduce(function (all, current) { return all.concat(current.patterns); }, []);
    }
    var aggregate = function (path, basename$$1) {
        if (!path) {
            return null;
        }
        if (!basename$$1) {
            var i = void 0;
            for (i = path.length; i > 0; i--) {
                var ch = path.charCodeAt(i - 1);
                if (ch === 47 /* Slash */ || ch === 92 /* Backslash */) {
                    break;
                }
            }
            basename$$1 = path.substr(i);
        }
        var index$$1 = basenames.indexOf(basename$$1);
        return index$$1 !== -1 ? patterns[index$$1] : null;
    };
    aggregate.basenames = basenames;
    aggregate.patterns = patterns;
    aggregate.allBasenames = basenames;
    var aggregatedPatterns = parsedPatterns.filter(function (parsedPattern) { return !parsedPattern.basenames; });
    aggregatedPatterns.push(aggregate);
    return aggregatedPatterns;
}

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
function score(selector, candidateUri, candidateLanguage, candidateIsSynchronized) {
    if (Array.isArray(selector)) {
        // array -> take max individual value
        var ret = 0;
        for (var _i = 0, selector_1 = selector; _i < selector_1.length; _i++) {
            var filter = selector_1[_i];
            var value = score(filter, candidateUri, candidateLanguage, candidateIsSynchronized);
            if (value === 10) {
                return value; // already at the highest
            }
            if (value > ret) {
                ret = value;
            }
        }
        return ret;
    }
    else if (typeof selector === 'string') {
        if (!candidateIsSynchronized) {
            return 0;
        }
        // short-hand notion, desugars to
        // 'fooLang' -> [{ language: 'fooLang', scheme: 'file' }, { language: 'fooLang', scheme: 'untitled' }]
        // '*' -> { language: '*', scheme: '*' }
        if (selector === '*') {
            return 5;
        }
        else if (selector === candidateLanguage) {
            return 10;
        }
        else {
            return 0;
        }
    }
    else if (selector) {
        // filter -> select accordingly, use defaults for scheme
        var language = selector.language, pattern = selector.pattern, scheme = selector.scheme, hasAccessToAllModels = selector.hasAccessToAllModels;
        if (!candidateIsSynchronized && !hasAccessToAllModels) {
            return 0;
        }
        var ret = 0;
        if (scheme) {
            if (scheme === candidateUri.scheme) {
                ret = 10;
            }
            else if (scheme === '*') {
                ret = 5;
            }
            else {
                return 0;
            }
        }
        if (language) {
            if (language === candidateLanguage) {
                ret = 10;
            }
            else if (language === '*') {
                ret = Math.max(ret, 5);
            }
            else {
                return 0;
            }
        }
        if (pattern) {
            if (pattern === candidateUri.fsPath || match(pattern, candidateUri.fsPath)) {
                ret = 10;
            }
            else {
                return 0;
            }
        }
        return ret;
    }
    else {
        return 0;
    }
}

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var IModelService = createDecorator('modelService');
function shouldSynchronizeModel(model) {
    return (!model.isTooLargeForSyncing() && !model.isForSimpleWidget);
}

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var LanguageFeatureRegistry = /** @class */ (function () {
    function LanguageFeatureRegistry() {
        this._clock = 0;
        this._entries = [];
        this._onDidChange = new Emitter();
    }
    Object.defineProperty(LanguageFeatureRegistry.prototype, "onDidChange", {
        get: function () {
            return this._onDidChange.event;
        },
        enumerable: true,
        configurable: true
    });
    LanguageFeatureRegistry.prototype.register = function (selector, provider) {
        var _this = this;
        var entry = {
            selector: selector,
            provider: provider,
            _score: -1,
            _time: this._clock++
        };
        this._entries.push(entry);
        this._lastCandidate = undefined;
        this._onDidChange.fire(this._entries.length);
        return {
            dispose: function () {
                if (entry) {
                    var idx = _this._entries.indexOf(entry);
                    if (idx >= 0) {
                        _this._entries.splice(idx, 1);
                        _this._lastCandidate = undefined;
                        _this._onDidChange.fire(_this._entries.length);
                        entry = undefined;
                    }
                }
            }
        };
    };
    LanguageFeatureRegistry.prototype.has = function (model) {
        return this.all(model).length > 0;
    };
    LanguageFeatureRegistry.prototype.all = function (model) {
        if (!model) {
            return [];
        }
        this._updateScores(model);
        var result = [];
        // from registry
        for (var _i = 0, _a = this._entries; _i < _a.length; _i++) {
            var entry = _a[_i];
            if (entry._score > 0) {
                result.push(entry.provider);
            }
        }
        return result;
    };
    LanguageFeatureRegistry.prototype.ordered = function (model) {
        var result = [];
        this._orderedForEach(model, function (entry) { return result.push(entry.provider); });
        return result;
    };
    LanguageFeatureRegistry.prototype.orderedGroups = function (model) {
        var result = [];
        var lastBucket;
        var lastBucketScore;
        this._orderedForEach(model, function (entry) {
            if (lastBucket && lastBucketScore === entry._score) {
                lastBucket.push(entry.provider);
            }
            else {
                lastBucketScore = entry._score;
                lastBucket = [entry.provider];
                result.push(lastBucket);
            }
        });
        return result;
    };
    LanguageFeatureRegistry.prototype._orderedForEach = function (model, callback) {
        if (!model) {
            return;
        }
        this._updateScores(model);
        for (var from = 0; from < this._entries.length; from++) {
            var entry = this._entries[from];
            if (entry._score > 0) {
                callback(entry);
            }
        }
    };
    LanguageFeatureRegistry.prototype._updateScores = function (model) {
        var candidate = {
            uri: model.uri.toString(),
            language: model.getLanguageIdentifier().language
        };
        if (this._lastCandidate
            && this._lastCandidate.language === candidate.language
            && this._lastCandidate.uri === candidate.uri) {
            // nothing has changed
            return;
        }
        this._lastCandidate = candidate;
        for (var _i = 0, _a = this._entries; _i < _a.length; _i++) {
            var entry = _a[_i];
            entry._score = score(entry.selector, model.uri, model.getLanguageIdentifier().language, shouldSynchronizeModel(model));
        }
        // needs sorting
        this._entries.sort(LanguageFeatureRegistry._compareByScoreAndTime);
    };
    LanguageFeatureRegistry._compareByScoreAndTime = function (a, b) {
        if (a._score < b._score) {
            return 1;
        }
        else if (a._score > b._score) {
            return -1;
        }
        else if (a._time < b._time) {
            return 1;
        }
        else if (a._time > b._time) {
            return -1;
        }
        else {
            return 0;
        }
    };
    return LanguageFeatureRegistry;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var TokenizationRegistryImpl = /** @class */ (function () {
    function TokenizationRegistryImpl() {
        this._onDidChange = new Emitter();
        this.onDidChange = this._onDidChange.event;
        this._map = Object.create(null);
        this._colorMap = null;
    }
    TokenizationRegistryImpl.prototype.fire = function (languages) {
        this._onDidChange.fire({
            changedLanguages: languages,
            changedColorMap: false
        });
    };
    TokenizationRegistryImpl.prototype.register = function (language, support) {
        var _this = this;
        this._map[language] = support;
        this.fire([language]);
        return {
            dispose: function () {
                if (_this._map[language] !== support) {
                    return;
                }
                delete _this._map[language];
                _this.fire([language]);
            }
        };
    };
    TokenizationRegistryImpl.prototype.get = function (language) {
        return (this._map[language] || null);
    };
    TokenizationRegistryImpl.prototype.setColorMap = function (colorMap) {
        this._colorMap = colorMap;
        this._onDidChange.fire({
            changedLanguages: Object.keys(this._map),
            changedColorMap: true
        });
    };
    TokenizationRegistryImpl.prototype.getColorMap = function () {
        return this._colorMap;
    };
    TokenizationRegistryImpl.prototype.getDefaultBackground = function () {
        return this._colorMap[2 /* DefaultBackground */];
    };
    return TokenizationRegistryImpl;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
/**
 * @internal
 */
var LanguageIdentifier = /** @class */ (function () {
    function LanguageIdentifier(language, id) {
        this.language = language;
        this.id = id;
    }
    return LanguageIdentifier;
}());
/**
 * @internal
 */
var TokenMetadata = /** @class */ (function () {
    function TokenMetadata() {
    }
    TokenMetadata.getLanguageId = function (metadata) {
        return (metadata & 255 /* LANGUAGEID_MASK */) >>> 0 /* LANGUAGEID_OFFSET */;
    };
    TokenMetadata.getTokenType = function (metadata) {
        return (metadata & 1792 /* TOKEN_TYPE_MASK */) >>> 8 /* TOKEN_TYPE_OFFSET */;
    };
    TokenMetadata.getFontStyle = function (metadata) {
        return (metadata & 14336 /* FONT_STYLE_MASK */) >>> 11 /* FONT_STYLE_OFFSET */;
    };
    TokenMetadata.getForeground = function (metadata) {
        return (metadata & 8372224 /* FOREGROUND_MASK */) >>> 14 /* FOREGROUND_OFFSET */;
    };
    TokenMetadata.getBackground = function (metadata) {
        return (metadata & 4286578688 /* BACKGROUND_MASK */) >>> 23 /* BACKGROUND_OFFSET */;
    };
    TokenMetadata.getClassNameFromMetadata = function (metadata) {
        var foreground = this.getForeground(metadata);
        var className = 'mtk' + foreground;
        var fontStyle = this.getFontStyle(metadata);
        if (fontStyle & 1 /* Italic */) {
            className += ' mtki';
        }
        if (fontStyle & 2 /* Bold */) {
            className += ' mtkb';
        }
        if (fontStyle & 4 /* Underline */) {
            className += ' mtku';
        }
        return className;
    };
    TokenMetadata.getInlineStyleFromMetadata = function (metadata, colorMap) {
        var foreground = this.getForeground(metadata);
        var fontStyle = this.getFontStyle(metadata);
        var result = "color: " + colorMap[foreground] + ";";
        if (fontStyle & 1 /* Italic */) {
            result += 'font-style: italic;';
        }
        if (fontStyle & 2 /* Bold */) {
            result += 'font-weight: bold;';
        }
        if (fontStyle & 4 /* Underline */) {
            result += 'text-decoration: underline;';
        }
        return result;
    };
    return TokenMetadata;
}());
/**
 * How a suggest provider was triggered.
 */
var SuggestTriggerKind;
(function (SuggestTriggerKind) {
    SuggestTriggerKind[SuggestTriggerKind["Invoke"] = 0] = "Invoke";
    SuggestTriggerKind[SuggestTriggerKind["TriggerCharacter"] = 1] = "TriggerCharacter";
    SuggestTriggerKind[SuggestTriggerKind["TriggerForIncompleteCompletions"] = 2] = "TriggerForIncompleteCompletions";
})(SuggestTriggerKind || (SuggestTriggerKind = {}));
/**
 * A document highlight kind.
 */
var DocumentHighlightKind;
(function (DocumentHighlightKind) {
    /**
     * A textual occurrence.
     */
    DocumentHighlightKind[DocumentHighlightKind["Text"] = 0] = "Text";
    /**
     * Read-access of a symbol, like reading a variable.
     */
    DocumentHighlightKind[DocumentHighlightKind["Read"] = 1] = "Read";
    /**
     * Write-access of a symbol, like writing to a variable.
     */
    DocumentHighlightKind[DocumentHighlightKind["Write"] = 2] = "Write";
})(DocumentHighlightKind || (DocumentHighlightKind = {}));
/**
 * A symbol kind.
 */
var SymbolKind;
(function (SymbolKind) {
    SymbolKind[SymbolKind["File"] = 0] = "File";
    SymbolKind[SymbolKind["Module"] = 1] = "Module";
    SymbolKind[SymbolKind["Namespace"] = 2] = "Namespace";
    SymbolKind[SymbolKind["Package"] = 3] = "Package";
    SymbolKind[SymbolKind["Class"] = 4] = "Class";
    SymbolKind[SymbolKind["Method"] = 5] = "Method";
    SymbolKind[SymbolKind["Property"] = 6] = "Property";
    SymbolKind[SymbolKind["Field"] = 7] = "Field";
    SymbolKind[SymbolKind["Constructor"] = 8] = "Constructor";
    SymbolKind[SymbolKind["Enum"] = 9] = "Enum";
    SymbolKind[SymbolKind["Interface"] = 10] = "Interface";
    SymbolKind[SymbolKind["Function"] = 11] = "Function";
    SymbolKind[SymbolKind["Variable"] = 12] = "Variable";
    SymbolKind[SymbolKind["Constant"] = 13] = "Constant";
    SymbolKind[SymbolKind["String"] = 14] = "String";
    SymbolKind[SymbolKind["Number"] = 15] = "Number";
    SymbolKind[SymbolKind["Boolean"] = 16] = "Boolean";
    SymbolKind[SymbolKind["Array"] = 17] = "Array";
    SymbolKind[SymbolKind["Object"] = 18] = "Object";
    SymbolKind[SymbolKind["Key"] = 19] = "Key";
    SymbolKind[SymbolKind["Null"] = 20] = "Null";
    SymbolKind[SymbolKind["EnumMember"] = 21] = "EnumMember";
    SymbolKind[SymbolKind["Struct"] = 22] = "Struct";
    SymbolKind[SymbolKind["Event"] = 23] = "Event";
    SymbolKind[SymbolKind["Operator"] = 24] = "Operator";
    SymbolKind[SymbolKind["TypeParameter"] = 25] = "TypeParameter";
})(SymbolKind || (SymbolKind = {}));
/**
 * @internal
 */
var symbolKindToCssClass = (function () {
    var _fromMapping = Object.create(null);
    _fromMapping[SymbolKind.File] = 'file';
    _fromMapping[SymbolKind.Module] = 'module';
    _fromMapping[SymbolKind.Namespace] = 'namespace';
    _fromMapping[SymbolKind.Package] = 'package';
    _fromMapping[SymbolKind.Class] = 'class';
    _fromMapping[SymbolKind.Method] = 'method';
    _fromMapping[SymbolKind.Property] = 'property';
    _fromMapping[SymbolKind.Field] = 'field';
    _fromMapping[SymbolKind.Constructor] = 'constructor';
    _fromMapping[SymbolKind.Enum] = 'enum';
    _fromMapping[SymbolKind.Interface] = 'interface';
    _fromMapping[SymbolKind.Function] = 'function';
    _fromMapping[SymbolKind.Variable] = 'variable';
    _fromMapping[SymbolKind.Constant] = 'constant';
    _fromMapping[SymbolKind.String] = 'string';
    _fromMapping[SymbolKind.Number] = 'number';
    _fromMapping[SymbolKind.Boolean] = 'boolean';
    _fromMapping[SymbolKind.Array] = 'array';
    _fromMapping[SymbolKind.Object] = 'object';
    _fromMapping[SymbolKind.Key] = 'key';
    _fromMapping[SymbolKind.Null] = 'null';
    _fromMapping[SymbolKind.EnumMember] = 'enum-member';
    _fromMapping[SymbolKind.Struct] = 'struct';
    _fromMapping[SymbolKind.Event] = 'event';
    _fromMapping[SymbolKind.Operator] = 'operator';
    _fromMapping[SymbolKind.TypeParameter] = 'type-parameter';
    return function toCssClassName(kind) {
        return _fromMapping[kind] || 'property';
    };
})();
var FoldingRangeKind = /** @class */ (function () {
    /**
     * Creates a new [FoldingRangeKind](#FoldingRangeKind).
     *
     * @param value of the kind.
     */
    function FoldingRangeKind(value) {
        this.value = value;
    }
    /**
     * Kind for folding range representing a comment. The value of the kind is 'comment'.
     */
    FoldingRangeKind.Comment = new FoldingRangeKind('comment');
    /**
     * Kind for folding range representing a import. The value of the kind is 'imports'.
     */
    FoldingRangeKind.Imports = new FoldingRangeKind('imports');
    /**
     * Kind for folding range representing regions (for example marked by `#region`, `#endregion`).
     * The value of the kind is 'region'.
     */
    FoldingRangeKind.Region = new FoldingRangeKind('region');
    return FoldingRangeKind;
}());
/**
 * @internal
 */
function isResourceFileEdit(thing) {
    return isObject(thing) && (Boolean(thing.newUri) || Boolean(thing.oldUri));
}
/**
 * @internal
 */
function isResourceTextEdit(thing) {
    return isObject(thing) && thing.resource && Array.isArray(thing.edits);
}
// --- feature registries ------
/**
 * @internal
 */
var ReferenceProviderRegistry = new LanguageFeatureRegistry();
/**
 * @internal
 */
var RenameProviderRegistry = new LanguageFeatureRegistry();
/**
 * @internal
 */
var SuggestRegistry = new LanguageFeatureRegistry();
/**
 * @internal
 */
var SignatureHelpProviderRegistry = new LanguageFeatureRegistry();
/**
 * @internal
 */
var HoverProviderRegistry = new LanguageFeatureRegistry();
/**
 * @internal
 */
var DocumentSymbolProviderRegistry = new LanguageFeatureRegistry();
/**
 * @internal
 */
var DocumentHighlightProviderRegistry = new LanguageFeatureRegistry();
/**
 * @internal
 */
var DefinitionProviderRegistry = new LanguageFeatureRegistry();
/**
 * @internal
 */
var ImplementationProviderRegistry = new LanguageFeatureRegistry();
/**
 * @internal
 */
var TypeDefinitionProviderRegistry = new LanguageFeatureRegistry();
/**
 * @internal
 */
var CodeLensProviderRegistry = new LanguageFeatureRegistry();
/**
 * @internal
 */
var CodeActionProviderRegistry = new LanguageFeatureRegistry();
/**
 * @internal
 */
var DocumentFormattingEditProviderRegistry = new LanguageFeatureRegistry();
/**
 * @internal
 */
var DocumentRangeFormattingEditProviderRegistry = new LanguageFeatureRegistry();
/**
 * @internal
 */
var OnTypeFormattingEditProviderRegistry = new LanguageFeatureRegistry();
/**
 * @internal
 */
var LinkProviderRegistry = new LanguageFeatureRegistry();
/**
 * @internal
 */
var ColorProviderRegistry = new LanguageFeatureRegistry();
/**
 * @internal
 */
var FoldingRangeProviderRegistry = new LanguageFeatureRegistry();
/**
 * @internal
 */
var TokenizationRegistry = new TokenizationRegistryImpl();

var modes = /*#__PURE__*/Object.freeze({
	LanguageIdentifier: LanguageIdentifier,
	TokenMetadata: TokenMetadata,
	get SuggestTriggerKind () { return SuggestTriggerKind; },
	get DocumentHighlightKind () { return DocumentHighlightKind; },
	get SymbolKind () { return SymbolKind; },
	symbolKindToCssClass: symbolKindToCssClass,
	FoldingRangeKind: FoldingRangeKind,
	isResourceFileEdit: isResourceFileEdit,
	isResourceTextEdit: isResourceTextEdit,
	ReferenceProviderRegistry: ReferenceProviderRegistry,
	RenameProviderRegistry: RenameProviderRegistry,
	SuggestRegistry: SuggestRegistry,
	SignatureHelpProviderRegistry: SignatureHelpProviderRegistry,
	HoverProviderRegistry: HoverProviderRegistry,
	DocumentSymbolProviderRegistry: DocumentSymbolProviderRegistry,
	DocumentHighlightProviderRegistry: DocumentHighlightProviderRegistry,
	DefinitionProviderRegistry: DefinitionProviderRegistry,
	ImplementationProviderRegistry: ImplementationProviderRegistry,
	TypeDefinitionProviderRegistry: TypeDefinitionProviderRegistry,
	CodeLensProviderRegistry: CodeLensProviderRegistry,
	CodeActionProviderRegistry: CodeActionProviderRegistry,
	DocumentFormattingEditProviderRegistry: DocumentFormattingEditProviderRegistry,
	DocumentRangeFormattingEditProviderRegistry: DocumentRangeFormattingEditProviderRegistry,
	OnTypeFormattingEditProviderRegistry: OnTypeFormattingEditProviderRegistry,
	LinkProviderRegistry: LinkProviderRegistry,
	ColorProviderRegistry: ColorProviderRegistry,
	FoldingRangeProviderRegistry: FoldingRangeProviderRegistry,
	TokenizationRegistry: TokenizationRegistry
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var EditStack = /** @class */ (function () {
    function EditStack(model) {
        this.model = model;
        this.currentOpenStackElement = null;
        this.past = [];
        this.future = [];
    }
    EditStack.prototype.pushStackElement = function () {
        if (this.currentOpenStackElement !== null) {
            this.past.push(this.currentOpenStackElement);
            this.currentOpenStackElement = null;
        }
    };
    EditStack.prototype.clear = function () {
        this.currentOpenStackElement = null;
        this.past = [];
        this.future = [];
    };
    EditStack.prototype.pushEditOperation = function (beforeCursorState, editOperations, cursorStateComputer) {
        // No support for parallel universes :(
        this.future = [];
        if (!this.currentOpenStackElement) {
            this.currentOpenStackElement = {
                beforeVersionId: this.model.getAlternativeVersionId(),
                beforeCursorState: beforeCursorState,
                editOperations: [],
                afterCursorState: null,
                afterVersionId: -1
            };
        }
        var inverseEditOperation = {
            operations: this.model.applyEdits(editOperations)
        };
        this.currentOpenStackElement.editOperations.push(inverseEditOperation);
        try {
            this.currentOpenStackElement.afterCursorState = cursorStateComputer ? cursorStateComputer(inverseEditOperation.operations) : null;
        }
        catch (e) {
            onUnexpectedError(e);
            this.currentOpenStackElement.afterCursorState = null;
        }
        this.currentOpenStackElement.afterVersionId = this.model.getVersionId();
        return this.currentOpenStackElement.afterCursorState;
    };
    EditStack.prototype.undo = function () {
        this.pushStackElement();
        if (this.past.length > 0) {
            var pastStackElement = this.past.pop();
            try {
                // Apply all operations in reverse order
                for (var i = pastStackElement.editOperations.length - 1; i >= 0; i--) {
                    pastStackElement.editOperations[i] = {
                        operations: this.model.applyEdits(pastStackElement.editOperations[i].operations)
                    };
                }
            }
            catch (e) {
                this.clear();
                return null;
            }
            this.future.push(pastStackElement);
            return {
                selections: pastStackElement.beforeCursorState,
                recordedVersionId: pastStackElement.beforeVersionId
            };
        }
        return null;
    };
    EditStack.prototype.redo = function () {
        if (this.future.length > 0) {
            if (this.currentOpenStackElement) {
                throw new Error('How is this possible?');
            }
            var futureStackElement = this.future.pop();
            try {
                // Apply all operations
                for (var i = 0; i < futureStackElement.editOperations.length; i++) {
                    futureStackElement.editOperations[i] = {
                        operations: this.model.applyEdits(futureStackElement.editOperations[i].operations)
                    };
                }
            }
            catch (e) {
                this.clear();
                return null;
            }
            this.past.push(futureStackElement);
            return {
                selections: futureStackElement.afterCursorState,
                recordedVersionId: futureStackElement.afterVersionId
            };
        }
        return null;
    };
    return EditStack;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
/**
 * An event describing that a model has been reset to a new value.
 * @internal
 */
var ModelRawFlush = /** @class */ (function () {
    function ModelRawFlush() {
        this.changeType = 1 /* Flush */;
    }
    return ModelRawFlush;
}());
/**
 * An event describing that a line has changed in a model.
 * @internal
 */
var ModelRawLineChanged = /** @class */ (function () {
    function ModelRawLineChanged(lineNumber, detail) {
        this.changeType = 2 /* LineChanged */;
        this.lineNumber = lineNumber;
        this.detail = detail;
    }
    return ModelRawLineChanged;
}());
/**
 * An event describing that line(s) have been deleted in a model.
 * @internal
 */
var ModelRawLinesDeleted = /** @class */ (function () {
    function ModelRawLinesDeleted(fromLineNumber, toLineNumber) {
        this.changeType = 3 /* LinesDeleted */;
        this.fromLineNumber = fromLineNumber;
        this.toLineNumber = toLineNumber;
    }
    return ModelRawLinesDeleted;
}());
/**
 * An event describing that line(s) have been inserted in a model.
 * @internal
 */
var ModelRawLinesInserted = /** @class */ (function () {
    function ModelRawLinesInserted(fromLineNumber, toLineNumber, detail) {
        this.changeType = 4 /* LinesInserted */;
        this.fromLineNumber = fromLineNumber;
        this.toLineNumber = toLineNumber;
        this.detail = detail;
    }
    return ModelRawLinesInserted;
}());
/**
 * An event describing that a model has had its EOL changed.
 * @internal
 */
var ModelRawEOLChanged = /** @class */ (function () {
    function ModelRawEOLChanged() {
        this.changeType = 5 /* EOLChanged */;
    }
    return ModelRawEOLChanged;
}());
/**
 * An event describing a change in the text of a model.
 * @internal
 */
var ModelRawContentChangedEvent = /** @class */ (function () {
    function ModelRawContentChangedEvent(changes, versionId, isUndoing, isRedoing) {
        this.changes = changes;
        this.versionId = versionId;
        this.isUndoing = isUndoing;
        this.isRedoing = isRedoing;
    }
    ModelRawContentChangedEvent.prototype.containsEvent = function (type) {
        for (var i = 0, len = this.changes.length; i < len; i++) {
            var change = this.changes[i];
            if (change.changeType === type) {
                return true;
            }
        }
        return false;
    };
    ModelRawContentChangedEvent.merge = function (a, b) {
        var changes = [].concat(a.changes).concat(b.changes);
        var versionId = b.versionId;
        var isUndoing = (a.isUndoing || b.isUndoing);
        var isRedoing = (a.isRedoing || b.isRedoing);
        return new ModelRawContentChangedEvent(changes, versionId, isUndoing, isRedoing);
    };
    return ModelRawContentChangedEvent;
}());
/**
 * @internal
 */
var InternalModelContentChangeEvent = /** @class */ (function () {
    function InternalModelContentChangeEvent(rawContentChangedEvent, contentChangedEvent) {
        this.rawContentChangedEvent = rawContentChangedEvent;
        this.contentChangedEvent = contentChangedEvent;
    }
    InternalModelContentChangeEvent.prototype.merge = function (other) {
        var rawContentChangedEvent = ModelRawContentChangedEvent.merge(this.rawContentChangedEvent, other.rawContentChangedEvent);
        var contentChangedEvent = InternalModelContentChangeEvent._mergeChangeEvents(this.contentChangedEvent, other.contentChangedEvent);
        return new InternalModelContentChangeEvent(rawContentChangedEvent, contentChangedEvent);
    };
    InternalModelContentChangeEvent._mergeChangeEvents = function (a, b) {
        var changes = [].concat(a.changes).concat(b.changes);
        var eol = b.eol;
        var versionId = b.versionId;
        var isUndoing = (a.isUndoing || b.isUndoing);
        var isRedoing = (a.isRedoing || b.isRedoing);
        var isFlush = (a.isFlush || b.isFlush);
        return {
            changes: changes,
            eol: eol,
            versionId: versionId,
            isUndoing: isUndoing,
            isRedoing: isRedoing,
            isFlush: isFlush
        };
    };
    return InternalModelContentChangeEvent;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
//
// The red-black tree is based on the "Introduction to Algorithms" by Cormen, Leiserson and Rivest.
//
var ClassName = {
    EditorHintDecoration: 'squiggly-hint',
    EditorInfoDecoration: 'squiggly-info',
    EditorWarningDecoration: 'squiggly-warning',
    EditorErrorDecoration: 'squiggly-error'
};
function getNodeColor(node) {
    return ((node.metadata & 1 /* ColorMask */) >>> 0 /* ColorOffset */);
}
function setNodeColor(node, color) {
    node.metadata = ((node.metadata & 254 /* ColorMaskInverse */) | (color << 0 /* ColorOffset */));
}
function getNodeIsVisited(node) {
    return ((node.metadata & 2 /* IsVisitedMask */) >>> 1 /* IsVisitedOffset */) === 1;
}
function setNodeIsVisited(node, value) {
    node.metadata = ((node.metadata & 253 /* IsVisitedMaskInverse */) | ((value ? 1 : 0) << 1 /* IsVisitedOffset */));
}
function getNodeIsForValidation(node) {
    return ((node.metadata & 4 /* IsForValidationMask */) >>> 2 /* IsForValidationOffset */) === 1;
}
function setNodeIsForValidation(node, value) {
    node.metadata = ((node.metadata & 251 /* IsForValidationMaskInverse */) | ((value ? 1 : 0) << 2 /* IsForValidationOffset */));
}
function getNodeIsInOverviewRuler(node) {
    return ((node.metadata & 8 /* IsInOverviewRulerMask */) >>> 3 /* IsInOverviewRulerOffset */) === 1;
}
function setNodeIsInOverviewRuler(node, value) {
    node.metadata = ((node.metadata & 247 /* IsInOverviewRulerMaskInverse */) | ((value ? 1 : 0) << 3 /* IsInOverviewRulerOffset */));
}
function getNodeStickiness(node) {
    return ((node.metadata & 48 /* StickinessMask */) >>> 4 /* StickinessOffset */);
}
function setNodeStickiness(node, stickiness) {
    node.metadata = ((node.metadata & 207 /* StickinessMaskInverse */) | (stickiness << 4 /* StickinessOffset */));
}
var IntervalNode = /** @class */ (function () {
    function IntervalNode(id, start, end) {
        this.metadata = 0;
        this.parent = null;
        this.left = null;
        this.right = null;
        setNodeColor(this, 1 /* Red */);
        this.start = start;
        this.end = end;
        // FORCE_OVERFLOWING_TEST: this.delta = start;
        this.delta = 0;
        this.maxEnd = end;
        this.id = id;
        this.ownerId = 0;
        this.options = null;
        setNodeIsForValidation(this, false);
        setNodeStickiness(this, 1 /* NeverGrowsWhenTypingAtEdges */);
        setNodeIsInOverviewRuler(this, false);
        this.cachedVersionId = 0;
        this.cachedAbsoluteStart = start;
        this.cachedAbsoluteEnd = end;
        this.range = null;
        setNodeIsVisited(this, false);
    }
    IntervalNode.prototype.reset = function (versionId, start, end, range) {
        this.start = start;
        this.end = end;
        this.maxEnd = end;
        this.cachedVersionId = versionId;
        this.cachedAbsoluteStart = start;
        this.cachedAbsoluteEnd = end;
        this.range = range;
    };
    IntervalNode.prototype.setOptions = function (options) {
        this.options = options;
        var className = this.options.className;
        setNodeIsForValidation(this, (className === ClassName.EditorErrorDecoration
            || className === ClassName.EditorWarningDecoration
            || className === ClassName.EditorInfoDecoration));
        setNodeStickiness(this, this.options.stickiness);
        setNodeIsInOverviewRuler(this, this.options.overviewRuler.color ? true : false);
    };
    IntervalNode.prototype.setCachedOffsets = function (absoluteStart, absoluteEnd, cachedVersionId) {
        if (this.cachedVersionId !== cachedVersionId) {
            this.range = null;
        }
        this.cachedVersionId = cachedVersionId;
        this.cachedAbsoluteStart = absoluteStart;
        this.cachedAbsoluteEnd = absoluteEnd;
    };
    IntervalNode.prototype.detach = function () {
        this.parent = null;
        this.left = null;
        this.right = null;
    };
    return IntervalNode;
}());
var SENTINEL = new IntervalNode(null, 0, 0);
SENTINEL.parent = SENTINEL;
SENTINEL.left = SENTINEL;
SENTINEL.right = SENTINEL;
setNodeColor(SENTINEL, 0 /* Black */);
var IntervalTree = /** @class */ (function () {
    function IntervalTree() {
        this.root = SENTINEL;
        this.requestNormalizeDelta = false;
    }
    IntervalTree.prototype.intervalSearch = function (start, end, filterOwnerId, filterOutValidation, cachedVersionId) {
        if (this.root === SENTINEL) {
            return [];
        }
        return intervalSearch(this, start, end, filterOwnerId, filterOutValidation, cachedVersionId);
    };
    IntervalTree.prototype.search = function (filterOwnerId, filterOutValidation, cachedVersionId) {
        if (this.root === SENTINEL) {
            return [];
        }
        return search(this, filterOwnerId, filterOutValidation, cachedVersionId);
    };
    /**
     * Will not set `cachedAbsoluteStart` nor `cachedAbsoluteEnd` on the returned nodes!
     */
    IntervalTree.prototype.collectNodesFromOwner = function (ownerId) {
        return collectNodesFromOwner(this, ownerId);
    };
    /**
     * Will not set `cachedAbsoluteStart` nor `cachedAbsoluteEnd` on the returned nodes!
     */
    IntervalTree.prototype.collectNodesPostOrder = function () {
        return collectNodesPostOrder(this);
    };
    IntervalTree.prototype.insert = function (node) {
        rbTreeInsert(this, node);
        this._normalizeDeltaIfNecessary();
    };
    IntervalTree.prototype.delete = function (node) {
        rbTreeDelete(this, node);
        this._normalizeDeltaIfNecessary();
    };
    IntervalTree.prototype.resolveNode = function (node, cachedVersionId) {
        var initialNode = node;
        var delta = 0;
        while (node !== this.root) {
            if (node === node.parent.right) {
                delta += node.parent.delta;
            }
            node = node.parent;
        }
        var nodeStart = initialNode.start + delta;
        var nodeEnd = initialNode.end + delta;
        initialNode.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);
    };
    IntervalTree.prototype.acceptReplace = function (offset, length, textLength, forceMoveMarkers) {
        // Our strategy is to remove all directly impacted nodes, and then add them back to the tree.
        // (1) collect all nodes that are intersecting this edit as nodes of interest
        var nodesOfInterest = searchForEditing(this, offset, offset + length);
        // (2) remove all nodes that are intersecting this edit
        for (var i = 0, len = nodesOfInterest.length; i < len; i++) {
            var node = nodesOfInterest[i];
            rbTreeDelete(this, node);
        }
        this._normalizeDeltaIfNecessary();
        // (3) edit all tree nodes except the nodes of interest
        noOverlapReplace(this, offset, offset + length, textLength);
        this._normalizeDeltaIfNecessary();
        // (4) edit the nodes of interest and insert them back in the tree
        for (var i = 0, len = nodesOfInterest.length; i < len; i++) {
            var node = nodesOfInterest[i];
            node.start = node.cachedAbsoluteStart;
            node.end = node.cachedAbsoluteEnd;
            nodeAcceptEdit(node, offset, (offset + length), textLength, forceMoveMarkers);
            node.maxEnd = node.end;
            rbTreeInsert(this, node);
        }
        this._normalizeDeltaIfNecessary();
    };
    IntervalTree.prototype.getAllInOrder = function () {
        return search(this, 0, false, 0);
    };
    IntervalTree.prototype._normalizeDeltaIfNecessary = function () {
        if (!this.requestNormalizeDelta) {
            return;
        }
        this.requestNormalizeDelta = false;
        normalizeDelta(this);
    };
    return IntervalTree;
}());
//#region Delta Normalization
function normalizeDelta(T) {
    var node = T.root;
    var delta = 0;
    while (node !== SENTINEL) {
        if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {
            // go left
            node = node.left;
            continue;
        }
        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {
            // go right
            delta += node.delta;
            node = node.right;
            continue;
        }
        // handle current node
        node.start = delta + node.start;
        node.end = delta + node.end;
        node.delta = 0;
        recomputeMaxEnd(node);
        setNodeIsVisited(node, true);
        // going up from this node
        setNodeIsVisited(node.left, false);
        setNodeIsVisited(node.right, false);
        if (node === node.parent.right) {
            delta -= node.parent.delta;
        }
        node = node.parent;
    }
    setNodeIsVisited(T.root, false);
}
function adjustMarkerBeforeColumn(markerOffset, markerStickToPreviousCharacter, checkOffset, moveSemantics) {
    if (markerOffset < checkOffset) {
        return true;
    }
    if (markerOffset > checkOffset) {
        return false;
    }
    if (moveSemantics === 1 /* ForceMove */) {
        return false;
    }
    if (moveSemantics === 2 /* ForceStay */) {
        return true;
    }
    return markerStickToPreviousCharacter;
}
/**
 * This is a lot more complicated than strictly necessary to maintain the same behaviour
 * as when decorations were implemented using two markers.
 */
function nodeAcceptEdit(node, start, end, textLength, forceMoveMarkers) {
    var nodeStickiness = getNodeStickiness(node);
    var startStickToPreviousCharacter = (nodeStickiness === 0 /* AlwaysGrowsWhenTypingAtEdges */
        || nodeStickiness === 2 /* GrowsOnlyWhenTypingBefore */);
    var endStickToPreviousCharacter = (nodeStickiness === 1 /* NeverGrowsWhenTypingAtEdges */
        || nodeStickiness === 2 /* GrowsOnlyWhenTypingBefore */);
    var deletingCnt = (end - start);
    var insertingCnt = textLength;
    var commonLength = Math.min(deletingCnt, insertingCnt);
    var nodeStart = node.start;
    var startDone = false;
    var nodeEnd = node.end;
    var endDone = false;
    {
        var moveSemantics = forceMoveMarkers ? 1 /* ForceMove */ : (deletingCnt > 0 ? 2 /* ForceStay */ : 0 /* MarkerDefined */);
        if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, start, moveSemantics)) {
            startDone = true;
        }
        if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, start, moveSemantics)) {
            endDone = true;
        }
    }
    if (commonLength > 0 && !forceMoveMarkers) {
        var moveSemantics = (deletingCnt > insertingCnt ? 2 /* ForceStay */ : 0 /* MarkerDefined */);
        if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, start + commonLength, moveSemantics)) {
            startDone = true;
        }
        if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, start + commonLength, moveSemantics)) {
            endDone = true;
        }
    }
    {
        var moveSemantics = forceMoveMarkers ? 1 /* ForceMove */ : 0 /* MarkerDefined */;
        if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, end, moveSemantics)) {
            node.start = start + insertingCnt;
            startDone = true;
        }
        if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, end, moveSemantics)) {
            node.end = start + insertingCnt;
            endDone = true;
        }
    }
    // Finish
    var deltaColumn = (insertingCnt - deletingCnt);
    if (!startDone) {
        node.start = Math.max(0, nodeStart + deltaColumn);
        startDone = true;
    }
    if (!endDone) {
        node.end = Math.max(0, nodeEnd + deltaColumn);
        endDone = true;
    }
    if (node.start > node.end) {
        node.end = node.start;
    }
}
function searchForEditing(T, start, end) {
    // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree
    // Now, it is known that two intervals A and B overlap only when both
    // A.low <= B.high and A.high >= B.low. When searching the trees for
    // nodes overlapping with a given interval, you can immediately skip:
    //  a) all nodes to the right of nodes whose low value is past the end of the given interval.
    //  b) all nodes that have their maximum 'high' value below the start of the given interval.
    var node = T.root;
    var delta = 0;
    var nodeMaxEnd = 0;
    var nodeStart = 0;
    var nodeEnd = 0;
    var result = [];
    var resultLen = 0;
    while (node !== SENTINEL) {
        if (getNodeIsVisited(node)) {
            // going up from this node
            setNodeIsVisited(node.left, false);
            setNodeIsVisited(node.right, false);
            if (node === node.parent.right) {
                delta -= node.parent.delta;
            }
            node = node.parent;
            continue;
        }
        if (!getNodeIsVisited(node.left)) {
            // first time seeing this node
            nodeMaxEnd = delta + node.maxEnd;
            if (nodeMaxEnd < start) {
                // cover case b) from above
                // there is no need to search this node or its children
                setNodeIsVisited(node, true);
                continue;
            }
            if (node.left !== SENTINEL) {
                // go left
                node = node.left;
                continue;
            }
        }
        // handle current node
        nodeStart = delta + node.start;
        if (nodeStart > end) {
            // cover case a) from above
            // there is no need to search this node or its right subtree
            setNodeIsVisited(node, true);
            continue;
        }
        nodeEnd = delta + node.end;
        if (nodeEnd >= start) {
            node.setCachedOffsets(nodeStart, nodeEnd, 0);
            result[resultLen++] = node;
        }
        setNodeIsVisited(node, true);
        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {
            // go right
            delta += node.delta;
            node = node.right;
            continue;
        }
    }
    setNodeIsVisited(T.root, false);
    return result;
}
function noOverlapReplace(T, start, end, textLength) {
    // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree
    // Now, it is known that two intervals A and B overlap only when both
    // A.low <= B.high and A.high >= B.low. When searching the trees for
    // nodes overlapping with a given interval, you can immediately skip:
    //  a) all nodes to the right of nodes whose low value is past the end of the given interval.
    //  b) all nodes that have their maximum 'high' value below the start of the given interval.
    var node = T.root;
    var delta = 0;
    var nodeMaxEnd = 0;
    var nodeStart = 0;
    var editDelta = (textLength - (end - start));
    while (node !== SENTINEL) {
        if (getNodeIsVisited(node)) {
            // going up from this node
            setNodeIsVisited(node.left, false);
            setNodeIsVisited(node.right, false);
            if (node === node.parent.right) {
                delta -= node.parent.delta;
            }
            recomputeMaxEnd(node);
            node = node.parent;
            continue;
        }
        if (!getNodeIsVisited(node.left)) {
            // first time seeing this node
            nodeMaxEnd = delta + node.maxEnd;
            if (nodeMaxEnd < start) {
                // cover case b) from above
                // there is no need to search this node or its children
                setNodeIsVisited(node, true);
                continue;
            }
            if (node.left !== SENTINEL) {
                // go left
                node = node.left;
                continue;
            }
        }
        // handle current node
        nodeStart = delta + node.start;
        if (nodeStart > end) {
            node.start += editDelta;
            node.end += editDelta;
            node.delta += editDelta;
            if (node.delta < -1073741824 /* MIN_SAFE_DELTA */ || node.delta > 1073741824 /* MAX_SAFE_DELTA */) {
                T.requestNormalizeDelta = true;
            }
            // cover case a) from above
            // there is no need to search this node or its right subtree
            setNodeIsVisited(node, true);
            continue;
        }
        setNodeIsVisited(node, true);
        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {
            // go right
            delta += node.delta;
            node = node.right;
            continue;
        }
    }
    setNodeIsVisited(T.root, false);
}
//#endregion
//#region Searching
function collectNodesFromOwner(T, ownerId) {
    var node = T.root;
    var result = [];
    var resultLen = 0;
    while (node !== SENTINEL) {
        if (getNodeIsVisited(node)) {
            // going up from this node
            setNodeIsVisited(node.left, false);
            setNodeIsVisited(node.right, false);
            node = node.parent;
            continue;
        }
        if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {
            // go left
            node = node.left;
            continue;
        }
        // handle current node
        if (node.ownerId === ownerId) {
            result[resultLen++] = node;
        }
        setNodeIsVisited(node, true);
        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {
            // go right
            node = node.right;
            continue;
        }
    }
    setNodeIsVisited(T.root, false);
    return result;
}
function collectNodesPostOrder(T) {
    var node = T.root;
    var result = [];
    var resultLen = 0;
    while (node !== SENTINEL) {
        if (getNodeIsVisited(node)) {
            // going up from this node
            setNodeIsVisited(node.left, false);
            setNodeIsVisited(node.right, false);
            node = node.parent;
            continue;
        }
        if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {
            // go left
            node = node.left;
            continue;
        }
        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {
            // go right
            node = node.right;
            continue;
        }
        // handle current node
        result[resultLen++] = node;
        setNodeIsVisited(node, true);
    }
    setNodeIsVisited(T.root, false);
    return result;
}
function search(T, filterOwnerId, filterOutValidation, cachedVersionId) {
    var node = T.root;
    var delta = 0;
    var nodeStart = 0;
    var nodeEnd = 0;
    var result = [];
    var resultLen = 0;
    while (node !== SENTINEL) {
        if (getNodeIsVisited(node)) {
            // going up from this node
            setNodeIsVisited(node.left, false);
            setNodeIsVisited(node.right, false);
            if (node === node.parent.right) {
                delta -= node.parent.delta;
            }
            node = node.parent;
            continue;
        }
        if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {
            // go left
            node = node.left;
            continue;
        }
        // handle current node
        nodeStart = delta + node.start;
        nodeEnd = delta + node.end;
        node.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);
        var include = true;
        if (filterOwnerId && node.ownerId && node.ownerId !== filterOwnerId) {
            include = false;
        }
        if (filterOutValidation && getNodeIsForValidation(node)) {
            include = false;
        }
        if (include) {
            result[resultLen++] = node;
        }
        setNodeIsVisited(node, true);
        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {
            // go right
            delta += node.delta;
            node = node.right;
            continue;
        }
    }
    setNodeIsVisited(T.root, false);
    return result;
}
function intervalSearch(T, intervalStart, intervalEnd, filterOwnerId, filterOutValidation, cachedVersionId) {
    // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree
    // Now, it is known that two intervals A and B overlap only when both
    // A.low <= B.high and A.high >= B.low. When searching the trees for
    // nodes overlapping with a given interval, you can immediately skip:
    //  a) all nodes to the right of nodes whose low value is past the end of the given interval.
    //  b) all nodes that have their maximum 'high' value below the start of the given interval.
    var node = T.root;
    var delta = 0;
    var nodeMaxEnd = 0;
    var nodeStart = 0;
    var nodeEnd = 0;
    var result = [];
    var resultLen = 0;
    while (node !== SENTINEL) {
        if (getNodeIsVisited(node)) {
            // going up from this node
            setNodeIsVisited(node.left, false);
            setNodeIsVisited(node.right, false);
            if (node === node.parent.right) {
                delta -= node.parent.delta;
            }
            node = node.parent;
            continue;
        }
        if (!getNodeIsVisited(node.left)) {
            // first time seeing this node
            nodeMaxEnd = delta + node.maxEnd;
            if (nodeMaxEnd < intervalStart) {
                // cover case b) from above
                // there is no need to search this node or its children
                setNodeIsVisited(node, true);
                continue;
            }
            if (node.left !== SENTINEL) {
                // go left
                node = node.left;
                continue;
            }
        }
        // handle current node
        nodeStart = delta + node.start;
        if (nodeStart > intervalEnd) {
            // cover case a) from above
            // there is no need to search this node or its right subtree
            setNodeIsVisited(node, true);
            continue;
        }
        nodeEnd = delta + node.end;
        if (nodeEnd >= intervalStart) {
            // There is overlap
            node.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);
            var include = true;
            if (filterOwnerId && node.ownerId && node.ownerId !== filterOwnerId) {
                include = false;
            }
            if (filterOutValidation && getNodeIsForValidation(node)) {
                include = false;
            }
            if (include) {
                result[resultLen++] = node;
            }
        }
        setNodeIsVisited(node, true);
        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {
            // go right
            delta += node.delta;
            node = node.right;
            continue;
        }
    }
    setNodeIsVisited(T.root, false);
    return result;
}
//#endregion
//#region Insertion
function rbTreeInsert(T, newNode) {
    if (T.root === SENTINEL) {
        newNode.parent = SENTINEL;
        newNode.left = SENTINEL;
        newNode.right = SENTINEL;
        setNodeColor(newNode, 0 /* Black */);
        T.root = newNode;
        return T.root;
    }
    treeInsert(T, newNode);
    recomputeMaxEndWalkToRoot(newNode.parent);
    // repair tree
    var x = newNode;
    while (x !== T.root && getNodeColor(x.parent) === 1 /* Red */) {
        if (x.parent === x.parent.parent.left) {
            var y = x.parent.parent.right;
            if (getNodeColor(y) === 1 /* Red */) {
                setNodeColor(x.parent, 0 /* Black */);
                setNodeColor(y, 0 /* Black */);
                setNodeColor(x.parent.parent, 1 /* Red */);
                x = x.parent.parent;
            }
            else {
                if (x === x.parent.right) {
                    x = x.parent;
                    leftRotate(T, x);
                }
                setNodeColor(x.parent, 0 /* Black */);
                setNodeColor(x.parent.parent, 1 /* Red */);
                rightRotate(T, x.parent.parent);
            }
        }
        else {
            var y = x.parent.parent.left;
            if (getNodeColor(y) === 1 /* Red */) {
                setNodeColor(x.parent, 0 /* Black */);
                setNodeColor(y, 0 /* Black */);
                setNodeColor(x.parent.parent, 1 /* Red */);
                x = x.parent.parent;
            }
            else {
                if (x === x.parent.left) {
                    x = x.parent;
                    rightRotate(T, x);
                }
                setNodeColor(x.parent, 0 /* Black */);
                setNodeColor(x.parent.parent, 1 /* Red */);
                leftRotate(T, x.parent.parent);
            }
        }
    }
    setNodeColor(T.root, 0 /* Black */);
    return newNode;
}
function treeInsert(T, z) {
    var delta = 0;
    var x = T.root;
    var zAbsoluteStart = z.start;
    var zAbsoluteEnd = z.end;
    while (true) {
        var cmp = intervalCompare(zAbsoluteStart, zAbsoluteEnd, x.start + delta, x.end + delta);
        if (cmp < 0) {
            // this node should be inserted to the left
            // => it is not affected by the node's delta
            if (x.left === SENTINEL) {
                z.start -= delta;
                z.end -= delta;
                z.maxEnd -= delta;
                x.left = z;
                break;
            }
            else {
                x = x.left;
            }
        }
        else {
            // this node should be inserted to the right
            // => it is not affected by the node's delta
            if (x.right === SENTINEL) {
                z.start -= (delta + x.delta);
                z.end -= (delta + x.delta);
                z.maxEnd -= (delta + x.delta);
                x.right = z;
                break;
            }
            else {
                delta += x.delta;
                x = x.right;
            }
        }
    }
    z.parent = x;
    z.left = SENTINEL;
    z.right = SENTINEL;
    setNodeColor(z, 1 /* Red */);
}
//#endregion
//#region Deletion
function rbTreeDelete(T, z) {
    var x;
    var y;
    // RB-DELETE except we don't swap z and y in case c)
    // i.e. we always delete what's pointed at by z.
    if (z.left === SENTINEL) {
        x = z.right;
        y = z;
        // x's delta is no longer influenced by z's delta
        x.delta += z.delta;
        if (x.delta < -1073741824 /* MIN_SAFE_DELTA */ || x.delta > 1073741824 /* MAX_SAFE_DELTA */) {
            T.requestNormalizeDelta = true;
        }
        x.start += z.delta;
        x.end += z.delta;
    }
    else if (z.right === SENTINEL) {
        x = z.left;
        y = z;
    }
    else {
        y = leftest(z.right);
        x = y.right;
        // y's delta is no longer influenced by z's delta,
        // but we don't want to walk the entire right-hand-side subtree of x.
        // we therefore maintain z's delta in y, and adjust only x
        x.start += y.delta;
        x.end += y.delta;
        x.delta += y.delta;
        if (x.delta < -1073741824 /* MIN_SAFE_DELTA */ || x.delta > 1073741824 /* MAX_SAFE_DELTA */) {
            T.requestNormalizeDelta = true;
        }
        y.start += z.delta;
        y.end += z.delta;
        y.delta = z.delta;
        if (y.delta < -1073741824 /* MIN_SAFE_DELTA */ || y.delta > 1073741824 /* MAX_SAFE_DELTA */) {
            T.requestNormalizeDelta = true;
        }
    }
    if (y === T.root) {
        T.root = x;
        setNodeColor(x, 0 /* Black */);
        z.detach();
        resetSentinel();
        recomputeMaxEnd(x);
        T.root.parent = SENTINEL;
        return;
    }
    var yWasRed = (getNodeColor(y) === 1 /* Red */);
    if (y === y.parent.left) {
        y.parent.left = x;
    }
    else {
        y.parent.right = x;
    }
    if (y === z) {
        x.parent = y.parent;
    }
    else {
        if (y.parent === z) {
            x.parent = y;
        }
        else {
            x.parent = y.parent;
        }
        y.left = z.left;
        y.right = z.right;
        y.parent = z.parent;
        setNodeColor(y, getNodeColor(z));
        if (z === T.root) {
            T.root = y;
        }
        else {
            if (z === z.parent.left) {
                z.parent.left = y;
            }
            else {
                z.parent.right = y;
            }
        }
        if (y.left !== SENTINEL) {
            y.left.parent = y;
        }
        if (y.right !== SENTINEL) {
            y.right.parent = y;
        }
    }
    z.detach();
    if (yWasRed) {
        recomputeMaxEndWalkToRoot(x.parent);
        if (y !== z) {
            recomputeMaxEndWalkToRoot(y);
            recomputeMaxEndWalkToRoot(y.parent);
        }
        resetSentinel();
        return;
    }
    recomputeMaxEndWalkToRoot(x);
    recomputeMaxEndWalkToRoot(x.parent);
    if (y !== z) {
        recomputeMaxEndWalkToRoot(y);
        recomputeMaxEndWalkToRoot(y.parent);
    }
    // RB-DELETE-FIXUP
    var w;
    while (x !== T.root && getNodeColor(x) === 0 /* Black */) {
        if (x === x.parent.left) {
            w = x.parent.right;
            if (getNodeColor(w) === 1 /* Red */) {
                setNodeColor(w, 0 /* Black */);
                setNodeColor(x.parent, 1 /* Red */);
                leftRotate(T, x.parent);
                w = x.parent.right;
            }
            if (getNodeColor(w.left) === 0 /* Black */ && getNodeColor(w.right) === 0 /* Black */) {
                setNodeColor(w, 1 /* Red */);
                x = x.parent;
            }
            else {
                if (getNodeColor(w.right) === 0 /* Black */) {
                    setNodeColor(w.left, 0 /* Black */);
                    setNodeColor(w, 1 /* Red */);
                    rightRotate(T, w);
                    w = x.parent.right;
                }
                setNodeColor(w, getNodeColor(x.parent));
                setNodeColor(x.parent, 0 /* Black */);
                setNodeColor(w.right, 0 /* Black */);
                leftRotate(T, x.parent);
                x = T.root;
            }
        }
        else {
            w = x.parent.left;
            if (getNodeColor(w) === 1 /* Red */) {
                setNodeColor(w, 0 /* Black */);
                setNodeColor(x.parent, 1 /* Red */);
                rightRotate(T, x.parent);
                w = x.parent.left;
            }
            if (getNodeColor(w.left) === 0 /* Black */ && getNodeColor(w.right) === 0 /* Black */) {
                setNodeColor(w, 1 /* Red */);
                x = x.parent;
            }
            else {
                if (getNodeColor(w.left) === 0 /* Black */) {
                    setNodeColor(w.right, 0 /* Black */);
                    setNodeColor(w, 1 /* Red */);
                    leftRotate(T, w);
                    w = x.parent.left;
                }
                setNodeColor(w, getNodeColor(x.parent));
                setNodeColor(x.parent, 0 /* Black */);
                setNodeColor(w.left, 0 /* Black */);
                rightRotate(T, x.parent);
                x = T.root;
            }
        }
    }
    setNodeColor(x, 0 /* Black */);
    resetSentinel();
}
function leftest(node) {
    while (node.left !== SENTINEL) {
        node = node.left;
    }
    return node;
}
function resetSentinel() {
    SENTINEL.parent = SENTINEL;
    SENTINEL.delta = 0; // optional
    SENTINEL.start = 0; // optional
    SENTINEL.end = 0; // optional
}
//#endregion
//#region Rotations
function leftRotate(T, x) {
    var y = x.right; // set y.
    y.delta += x.delta; // y's delta is no longer influenced by x's delta
    if (y.delta < -1073741824 /* MIN_SAFE_DELTA */ || y.delta > 1073741824 /* MAX_SAFE_DELTA */) {
        T.requestNormalizeDelta = true;
    }
    y.start += x.delta;
    y.end += x.delta;
    x.right = y.left; // turn y's left subtree into x's right subtree.
    if (y.left !== SENTINEL) {
        y.left.parent = x;
    }
    y.parent = x.parent; // link x's parent to y.
    if (x.parent === SENTINEL) {
        T.root = y;
    }
    else if (x === x.parent.left) {
        x.parent.left = y;
    }
    else {
        x.parent.right = y;
    }
    y.left = x; // put x on y's left.
    x.parent = y;
    recomputeMaxEnd(x);
    recomputeMaxEnd(y);
}
function rightRotate(T, y) {
    var x = y.left;
    y.delta -= x.delta;
    if (y.delta < -1073741824 /* MIN_SAFE_DELTA */ || y.delta > 1073741824 /* MAX_SAFE_DELTA */) {
        T.requestNormalizeDelta = true;
    }
    y.start -= x.delta;
    y.end -= x.delta;
    y.left = x.right;
    if (x.right !== SENTINEL) {
        x.right.parent = y;
    }
    x.parent = y.parent;
    if (y.parent === SENTINEL) {
        T.root = x;
    }
    else if (y === y.parent.right) {
        y.parent.right = x;
    }
    else {
        y.parent.left = x;
    }
    x.right = y;
    y.parent = x;
    recomputeMaxEnd(y);
    recomputeMaxEnd(x);
}
//#endregion
//#region max end computation
function computeMaxEnd(node) {
    var maxEnd = node.end;
    if (node.left !== SENTINEL) {
        var leftMaxEnd = node.left.maxEnd;
        if (leftMaxEnd > maxEnd) {
            maxEnd = leftMaxEnd;
        }
    }
    if (node.right !== SENTINEL) {
        var rightMaxEnd = node.right.maxEnd + node.delta;
        if (rightMaxEnd > maxEnd) {
            maxEnd = rightMaxEnd;
        }
    }
    return maxEnd;
}
function recomputeMaxEnd(node) {
    node.maxEnd = computeMaxEnd(node);
}
function recomputeMaxEndWalkToRoot(node) {
    while (node !== SENTINEL) {
        var maxEnd = computeMaxEnd(node);
        if (node.maxEnd === maxEnd) {
            // no need to go further
            return;
        }
        node.maxEnd = maxEnd;
        node = node.parent;
    }
}
//#endregion
//#region utils
function intervalCompare(aStart, aEnd, bStart, bEnd) {
    if (aStart === bStart) {
        return aEnd - bEnd;
    }
    return aStart - bStart;
}

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var hasPerformanceNow = (globals.performance && typeof globals.performance.now === 'function');
var StopWatch = /** @class */ (function () {
    function StopWatch(highResolution) {
        this._highResolution = hasPerformanceNow && highResolution;
        this._startTime = this._now();
        this._stopTime = -1;
    }
    StopWatch.create = function (highResolution) {
        if (highResolution === void 0) { highResolution = true; }
        return new StopWatch(highResolution);
    };
    StopWatch.prototype.stop = function () {
        this._stopTime = this._now();
    };
    StopWatch.prototype.elapsed = function () {
        if (this._stopTime !== -1) {
            return this._stopTime - this._startTime;
        }
        return this._now() - this._startTime;
    };
    StopWatch.prototype._now = function () {
        return this._highResolution ? globals.performance.now() : new Date().getTime();
    };
    return StopWatch;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var NullStateImpl = /** @class */ (function () {
    function NullStateImpl() {
    }
    NullStateImpl.prototype.clone = function () {
        return this;
    };
    NullStateImpl.prototype.equals = function (other) {
        return (this === other);
    };
    return NullStateImpl;
}());
var NULL_STATE = new NullStateImpl();
var NULL_MODE_ID = 'vs.editor.nullMode';
var NULL_LANGUAGE_IDENTIFIER = new LanguageIdentifier(NULL_MODE_ID, 0 /* Null */);
function nullTokenize(modeId, buffer, state, deltaOffset) {
    return new TokenizationResult([new Token(deltaOffset, '', modeId)], state);
}
function nullTokenize2(languageId, buffer, state, deltaOffset) {
    var tokens = new Uint32Array(2);
    tokens[0] = deltaOffset;
    tokens[1] = ((languageId << 0 /* LANGUAGEID_OFFSET */)
        | (0 /* Other */ << 8 /* TOKEN_TYPE_OFFSET */)
        | (0 /* None */ << 11 /* FONT_STYLE_OFFSET */)
        | (1 /* DefaultForeground */ << 14 /* FOREGROUND_OFFSET */)
        | (2 /* DefaultBackground */ << 23 /* BACKGROUND_OFFSET */)) >>> 0;
    return new TokenizationResult2(tokens, state);
}

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
function createScopedLineTokens(context, offset) {
    var tokenCount = context.getCount();
    var tokenIndex = context.findTokenIndexAtOffset(offset);
    var desiredLanguageId = context.getLanguageId(tokenIndex);
    var lastTokenIndex = tokenIndex;
    while (lastTokenIndex + 1 < tokenCount && context.getLanguageId(lastTokenIndex + 1) === desiredLanguageId) {
        lastTokenIndex++;
    }
    var firstTokenIndex = tokenIndex;
    while (firstTokenIndex > 0 && context.getLanguageId(firstTokenIndex - 1) === desiredLanguageId) {
        firstTokenIndex--;
    }
    return new ScopedLineTokens(context, desiredLanguageId, firstTokenIndex, lastTokenIndex + 1, context.getStartOffset(firstTokenIndex), context.getEndOffset(lastTokenIndex));
}
var ScopedLineTokens = /** @class */ (function () {
    function ScopedLineTokens(actual, languageId, firstTokenIndex, lastTokenIndex, firstCharOffset, lastCharOffset) {
        this._actual = actual;
        this.languageId = languageId;
        this._firstTokenIndex = firstTokenIndex;
        this._lastTokenIndex = lastTokenIndex;
        this.firstCharOffset = firstCharOffset;
        this._lastCharOffset = lastCharOffset;
    }
    ScopedLineTokens.prototype.getLineContent = function () {
        var actualLineContent = this._actual.getLineContent();
        return actualLineContent.substring(this.firstCharOffset, this._lastCharOffset);
    };
    ScopedLineTokens.prototype.getTokenCount = function () {
        return this._lastTokenIndex - this._firstTokenIndex;
    };
    ScopedLineTokens.prototype.findTokenIndexAtOffset = function (offset) {
        return this._actual.findTokenIndexAtOffset(offset + this.firstCharOffset) - this._firstTokenIndex;
    };
    ScopedLineTokens.prototype.getStandardTokenType = function (tokenIndex) {
        return this._actual.getStandardTokenType(tokenIndex + this._firstTokenIndex);
    };
    return ScopedLineTokens;
}());
function ignoreBracketsInToken(standardTokenType) {
    return (standardTokenType & 7 /* value */) !== 0;
}

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var RichEditBracket = /** @class */ (function () {
    function RichEditBracket(languageIdentifier, open, close, forwardRegex, reversedRegex) {
        this.languageIdentifier = languageIdentifier;
        this.open = open;
        this.close = close;
        this.forwardRegex = forwardRegex;
        this.reversedRegex = reversedRegex;
    }
    return RichEditBracket;
}());
var RichEditBrackets = /** @class */ (function () {
    function RichEditBrackets(languageIdentifier, brackets) {
        var _this = this;
        this.brackets = brackets.map(function (b) {
            return new RichEditBracket(languageIdentifier, b[0], b[1], getRegexForBracketPair({ open: b[0], close: b[1] }), getReversedRegexForBracketPair({ open: b[0], close: b[1] }));
        });
        this.forwardRegex = getRegexForBrackets(this.brackets);
        this.reversedRegex = getReversedRegexForBrackets(this.brackets);
        this.textIsBracket = {};
        this.textIsOpenBracket = {};
        var maxBracketLength = 0;
        this.brackets.forEach(function (b) {
            _this.textIsBracket[b.open.toLowerCase()] = b;
            _this.textIsBracket[b.close.toLowerCase()] = b;
            _this.textIsOpenBracket[b.open.toLowerCase()] = true;
            _this.textIsOpenBracket[b.close.toLowerCase()] = false;
            maxBracketLength = Math.max(maxBracketLength, b.open.length);
            maxBracketLength = Math.max(maxBracketLength, b.close.length);
        });
        this.maxBracketLength = maxBracketLength;
    }
    return RichEditBrackets;
}());
function once$1(keyFn, computeFn) {
    var cache = {};
    return function (input) {
        var key = keyFn(input);
        if (!cache.hasOwnProperty(key)) {
            cache[key] = computeFn(input);
        }
        return cache[key];
    };
}
var getRegexForBracketPair = once$1(function (input) { return input.open + ";" + input.close; }, function (input) {
    return createBracketOrRegExp([input.open, input.close]);
});
var getReversedRegexForBracketPair = once$1(function (input) { return input.open + ";" + input.close; }, function (input) {
    return createBracketOrRegExp([toReversedString(input.open), toReversedString(input.close)]);
});
var getRegexForBrackets = once$1(function (input) { return input.map(function (b) { return b.open + ";" + b.close; }).join(';'); }, function (input) {
    var pieces = [];
    input.forEach(function (b) {
        pieces.push(b.open);
        pieces.push(b.close);
    });
    return createBracketOrRegExp(pieces);
});
var getReversedRegexForBrackets = once$1(function (input) { return input.map(function (b) { return b.open + ";" + b.close; }).join(';'); }, function (input) {
    var pieces = [];
    input.forEach(function (b) {
        pieces.push(toReversedString(b.open));
        pieces.push(toReversedString(b.close));
    });
    return createBracketOrRegExp(pieces);
});
function prepareBracketForRegExp(str) {
    // This bracket pair uses letters like e.g. "begin" - "end"
    var insertWordBoundaries = (/^[\w]+$/.test(str));
    str = escapeRegExpCharacters(str);
    return (insertWordBoundaries ? "\\b" + str + "\\b" : str);
}
function createBracketOrRegExp(pieces) {
    var regexStr = "(" + pieces.map(prepareBracketForRegExp).join(')|(') + ")";
    return createRegExp(regexStr, true);
}
var toReversedString = (function () {
    function reverse(str) {
        var reversedStr = '';
        for (var i = str.length - 1; i >= 0; i--) {
            reversedStr += str.charAt(i);
        }
        return reversedStr;
    }
    var lastInput = null;
    var lastOutput = null;
    return function toReversedString(str) {
        if (lastInput !== str) {
            lastInput = str;
            lastOutput = reverse(lastInput);
        }
        return lastOutput;
    };
})();
var BracketsUtils = /** @class */ (function () {
    function BracketsUtils() {
    }
    BracketsUtils._findPrevBracketInText = function (reversedBracketRegex, lineNumber, reversedText, offset) {
        var m = reversedText.match(reversedBracketRegex);
        if (!m) {
            return null;
        }
        var matchOffset = reversedText.length - m.index;
        var matchLength = m[0].length;
        var absoluteMatchOffset = offset + matchOffset;
        return new Range(lineNumber, absoluteMatchOffset - matchLength + 1, lineNumber, absoluteMatchOffset + 1);
    };
    BracketsUtils.findPrevBracketInToken = function (reversedBracketRegex, lineNumber, lineText, currentTokenStart, currentTokenEnd) {
        // Because JS does not support backwards regex search, we search forwards in a reversed string with a reversed regex ;)
        var reversedLineText = toReversedString(lineText);
        var reversedTokenText = reversedLineText.substring(lineText.length - currentTokenEnd, lineText.length - currentTokenStart);
        return this._findPrevBracketInText(reversedBracketRegex, lineNumber, reversedTokenText, currentTokenStart);
    };
    BracketsUtils.findNextBracketInText = function (bracketRegex, lineNumber, text, offset) {
        var m = text.match(bracketRegex);
        if (!m) {
            return null;
        }
        var matchOffset = m.index;
        var matchLength = m[0].length;
        if (matchLength === 0) {
            return null;
        }
        var absoluteMatchOffset = offset + matchOffset;
        return new Range(lineNumber, absoluteMatchOffset + 1, lineNumber, absoluteMatchOffset + 1 + matchLength);
    };
    BracketsUtils.findNextBracketInToken = function (bracketRegex, lineNumber, lineText, currentTokenStart, currentTokenEnd) {
        var currentTokenText = lineText.substring(currentTokenStart, currentTokenEnd);
        return this.findNextBracketInText(bracketRegex, lineNumber, currentTokenText, currentTokenStart);
    };
    return BracketsUtils;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
/**
 * Describes what to do with the indentation when pressing Enter.
 */
var IndentAction;
(function (IndentAction) {
    /**
     * Insert new line and copy the previous line's indentation.
     */
    IndentAction[IndentAction["None"] = 0] = "None";
    /**
     * Insert new line and indent once (relative to the previous line's indentation).
     */
    IndentAction[IndentAction["Indent"] = 1] = "Indent";
    /**
     * Insert two new lines:
     *  - the first one indented which will hold the cursor
     *  - the second one at the same indentation level
     */
    IndentAction[IndentAction["IndentOutdent"] = 2] = "IndentOutdent";
    /**
     * Insert new line and outdent once (relative to the previous line's indentation).
     */
    IndentAction[IndentAction["Outdent"] = 3] = "Outdent";
})(IndentAction || (IndentAction = {}));
/**
 * @internal
 */
var StandardAutoClosingPairConditional = /** @class */ (function () {
    function StandardAutoClosingPairConditional(source) {
        this.open = source.open;
        this.close = source.close;
        // initially allowed in all tokens
        this._standardTokenMask = 0;
        if (Array.isArray(source.notIn)) {
            for (var i = 0, len = source.notIn.length; i < len; i++) {
                var notIn = source.notIn[i];
                switch (notIn) {
                    case 'string':
                        this._standardTokenMask |= 2 /* String */;
                        break;
                    case 'comment':
                        this._standardTokenMask |= 1 /* Comment */;
                        break;
                    case 'regex':
                        this._standardTokenMask |= 4 /* RegEx */;
                        break;
                }
            }
        }
    }
    StandardAutoClosingPairConditional.prototype.isOK = function (standardToken) {
        return (this._standardTokenMask & standardToken) === 0;
    };
    return StandardAutoClosingPairConditional;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var CharacterPairSupport = /** @class */ (function () {
    function CharacterPairSupport(config) {
        if (config.autoClosingPairs) {
            this._autoClosingPairs = config.autoClosingPairs.map(function (el) { return new StandardAutoClosingPairConditional(el); });
        }
        else if (config.brackets) {
            this._autoClosingPairs = config.brackets.map(function (b) { return new StandardAutoClosingPairConditional({ open: b[0], close: b[1] }); });
        }
        else {
            this._autoClosingPairs = [];
        }
        this._surroundingPairs = config.surroundingPairs || this._autoClosingPairs;
    }
    CharacterPairSupport.prototype.getAutoClosingPairs = function () {
        return this._autoClosingPairs;
    };
    CharacterPairSupport.prototype.shouldAutoClosePair = function (character, context, column) {
        // Always complete on empty line
        if (context.getTokenCount() === 0) {
            return true;
        }
        var tokenIndex = context.findTokenIndexAtOffset(column - 2);
        var standardTokenType = context.getStandardTokenType(tokenIndex);
        for (var i = 0; i < this._autoClosingPairs.length; ++i) {
            var autoClosingPair = this._autoClosingPairs[i];
            if (autoClosingPair.open === character) {
                return autoClosingPair.isOK(standardTokenType);
            }
        }
        return false;
    };
    CharacterPairSupport.prototype.getSurroundingPairs = function () {
        return this._surroundingPairs;
    };
    return CharacterPairSupport;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var BracketElectricCharacterSupport = /** @class */ (function () {
    function BracketElectricCharacterSupport(richEditBrackets, autoClosePairs, contribution) {
        contribution = contribution || {};
        this._richEditBrackets = richEditBrackets;
        this._complexAutoClosePairs = autoClosePairs.filter(function (pair) { return pair.open.length > 1 && !!pair.close; }).map(function (el) { return new StandardAutoClosingPairConditional(el); });
        if (contribution.docComment) {
            // IDocComment is legacy, only partially supported
            this._complexAutoClosePairs.push(new StandardAutoClosingPairConditional({ open: contribution.docComment.open, close: contribution.docComment.close }));
        }
    }
    BracketElectricCharacterSupport.prototype.getElectricCharacters = function () {
        var result = [];
        if (this._richEditBrackets) {
            for (var i = 0, len = this._richEditBrackets.brackets.length; i < len; i++) {
                var bracketPair = this._richEditBrackets.brackets[i];
                var lastChar = bracketPair.close.charAt(bracketPair.close.length - 1);
                result.push(lastChar);
            }
        }
        // auto close
        for (var _i = 0, _a = this._complexAutoClosePairs; _i < _a.length; _i++) {
            var pair = _a[_i];
            result.push(pair.open.charAt(pair.open.length - 1));
        }
        // Filter duplicate entries
        result = result.filter(function (item, pos, array) {
            return array.indexOf(item) === pos;
        });
        return result;
    };
    BracketElectricCharacterSupport.prototype.onElectricCharacter = function (character, context, column) {
        return (this._onElectricAutoClose(character, context, column) ||
            this._onElectricAutoIndent(character, context, column));
    };
    BracketElectricCharacterSupport.prototype._onElectricAutoIndent = function (character, context, column) {
        if (!this._richEditBrackets || this._richEditBrackets.brackets.length === 0) {
            return null;
        }
        var tokenIndex = context.findTokenIndexAtOffset(column - 1);
        if (ignoreBracketsInToken(context.getStandardTokenType(tokenIndex))) {
            return null;
        }
        var reversedBracketRegex = this._richEditBrackets.reversedRegex;
        var text = context.getLineContent().substring(0, column - 1) + character;
        var r = BracketsUtils.findPrevBracketInToken(reversedBracketRegex, 1, text, 0, text.length);
        if (!r) {
            return null;
        }
        var bracketText = text.substring(r.startColumn - 1, r.endColumn - 1);
        bracketText = bracketText.toLowerCase();
        var isOpen = this._richEditBrackets.textIsOpenBracket[bracketText];
        if (isOpen) {
            return null;
        }
        var textBeforeBracket = text.substring(0, r.startColumn - 1);
        if (!/^\s*$/.test(textBeforeBracket)) {
            // There is other text on the line before the bracket
            return null;
        }
        return {
            matchOpenBracket: bracketText
        };
    };
    BracketElectricCharacterSupport.prototype._onElectricAutoClose = function (character, context, column) {
        if (!this._complexAutoClosePairs.length) {
            return null;
        }
        var line = context.getLineContent();
        for (var i = 0, len = this._complexAutoClosePairs.length; i < len; i++) {
            var pair = this._complexAutoClosePairs[i];
            // See if the right electric character was pressed
            if (character !== pair.open.charAt(pair.open.length - 1)) {
                continue;
            }
            // check if the full open bracket matches
            var actual = line.substring(line.length - pair.open.length + 1) + character;
            if (actual !== pair.open) {
                continue;
            }
            var lastTokenIndex = context.findTokenIndexAtOffset(column - 1);
            var lastTokenStandardType = context.getStandardTokenType(lastTokenIndex);
            // If we're in a scope listed in 'notIn', do nothing
            if (!pair.isOK(lastTokenStandardType)) {
                continue;
            }
            // If this line already contains the closing tag, do nothing.
            if (line.indexOf(pair.close, column - 1) >= 0) {
                continue;
            }
            return { appendText: pair.close };
        }
        return null;
    };
    return BracketElectricCharacterSupport;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var OnEnterSupport = /** @class */ (function () {
    function OnEnterSupport(opts) {
        opts = opts || {};
        opts.brackets = opts.brackets || [
            ['(', ')'],
            ['{', '}'],
            ['[', ']']
        ];
        this._brackets = opts.brackets.map(function (bracket) {
            return {
                open: bracket[0],
                openRegExp: OnEnterSupport._createOpenBracketRegExp(bracket[0]),
                close: bracket[1],
                closeRegExp: OnEnterSupport._createCloseBracketRegExp(bracket[1]),
            };
        });
        this._regExpRules = opts.regExpRules || [];
    }
    OnEnterSupport.prototype.onEnter = function (oneLineAboveText, beforeEnterText, afterEnterText) {
        // (1): `regExpRules`
        for (var i = 0, len = this._regExpRules.length; i < len; i++) {
            var rule = this._regExpRules[i];
            if (rule.beforeText.test(beforeEnterText)) {
                if (rule.afterText) {
                    if (rule.afterText.test(afterEnterText)) {
                        return rule.action;
                    }
                }
                else {
                    return rule.action;
                }
            }
        }
        // (2): Special indent-outdent
        if (beforeEnterText.length > 0 && afterEnterText.length > 0) {
            for (var i = 0, len = this._brackets.length; i < len; i++) {
                var bracket = this._brackets[i];
                if (bracket.openRegExp.test(beforeEnterText) && bracket.closeRegExp.test(afterEnterText)) {
                    return { indentAction: IndentAction.IndentOutdent };
                }
            }
        }
        // (4): Open bracket based logic
        if (beforeEnterText.length > 0) {
            for (var i = 0, len = this._brackets.length; i < len; i++) {
                var bracket = this._brackets[i];
                if (bracket.openRegExp.test(beforeEnterText)) {
                    return { indentAction: IndentAction.Indent };
                }
            }
        }
        return null;
    };
    OnEnterSupport._createOpenBracketRegExp = function (bracket) {
        var str = escapeRegExpCharacters(bracket);
        if (!/\B/.test(str.charAt(0))) {
            str = '\\b' + str;
        }
        str += '\\s*$';
        return OnEnterSupport._safeRegExp(str);
    };
    OnEnterSupport._createCloseBracketRegExp = function (bracket) {
        var str = escapeRegExpCharacters(bracket);
        if (!/\B/.test(str.charAt(str.length - 1))) {
            str = str + '\\b';
        }
        str = '^\\s*' + str;
        return OnEnterSupport._safeRegExp(str);
    };
    OnEnterSupport._safeRegExp = function (def) {
        try {
            return new RegExp(def);
        }
        catch (err) {
            onUnexpectedError(err);
            return null;
        }
    };
    return OnEnterSupport;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var IndentRulesSupport = /** @class */ (function () {
    function IndentRulesSupport(indentationRules) {
        this._indentationRules = indentationRules;
    }
    IndentRulesSupport.prototype.shouldIncrease = function (text) {
        if (this._indentationRules) {
            if (this._indentationRules.increaseIndentPattern && this._indentationRules.increaseIndentPattern.test(text)) {
                return true;
            }
            // if (this._indentationRules.indentNextLinePattern && this._indentationRules.indentNextLinePattern.test(text)) {
            // 	return true;
            // }
        }
        return false;
    };
    IndentRulesSupport.prototype.shouldDecrease = function (text) {
        if (this._indentationRules && this._indentationRules.decreaseIndentPattern && this._indentationRules.decreaseIndentPattern.test(text)) {
            return true;
        }
        return false;
    };
    IndentRulesSupport.prototype.shouldIndentNextLine = function (text) {
        if (this._indentationRules && this._indentationRules.indentNextLinePattern && this._indentationRules.indentNextLinePattern.test(text)) {
            return true;
        }
        return false;
    };
    IndentRulesSupport.prototype.shouldIgnore = function (text) {
        // the text matches `unIndentedLinePattern`
        if (this._indentationRules && this._indentationRules.unIndentedLinePattern && this._indentationRules.unIndentedLinePattern.test(text)) {
            return true;
        }
        return false;
    };
    IndentRulesSupport.prototype.getIndentMetadata = function (text) {
        var ret = 0;
        if (this.shouldIncrease(text)) {
            ret += 1 /* INCREASE_MASK */;
        }
        if (this.shouldDecrease(text)) {
            ret += 2 /* DECREASE_MASK */;
        }
        if (this.shouldIndentNextLine(text)) {
            ret += 4 /* INDENT_NEXTLINE_MASK */;
        }
        if (this.shouldIgnore(text)) {
            ret += 8 /* UNINDENT_MASK */;
        }
        return ret;
    };
    return IndentRulesSupport;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var RichEditSupport = /** @class */ (function () {
    function RichEditSupport(languageIdentifier, previous, rawConf) {
        this._languageIdentifier = languageIdentifier;
        this._brackets = null;
        this._electricCharacter = null;
        var prev = null;
        if (previous) {
            prev = previous._conf;
        }
        this._conf = RichEditSupport._mergeConf(prev, rawConf);
        this.onEnter = RichEditSupport._handleOnEnter(this._conf);
        this.comments = RichEditSupport._handleComments(this._conf);
        this.characterPair = new CharacterPairSupport(this._conf);
        this.wordDefinition = this._conf.wordPattern || DEFAULT_WORD_REGEXP;
        this.indentationRules = this._conf.indentationRules;
        if (this._conf.indentationRules) {
            this.indentRulesSupport = new IndentRulesSupport(this._conf.indentationRules);
        }
        this.foldingRules = this._conf.folding || {};
    }
    Object.defineProperty(RichEditSupport.prototype, "brackets", {
        get: function () {
            if (!this._brackets && this._conf.brackets) {
                this._brackets = new RichEditBrackets(this._languageIdentifier, this._conf.brackets);
            }
            return this._brackets;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RichEditSupport.prototype, "electricCharacter", {
        get: function () {
            if (!this._electricCharacter) {
                var autoClosingPairs = [];
                if (this._conf.autoClosingPairs) {
                    autoClosingPairs = this._conf.autoClosingPairs;
                }
                else if (this._conf.brackets) {
                    autoClosingPairs = this._conf.brackets.map(function (b) {
                        return { open: b[0], close: b[1] };
                    });
                }
                this._electricCharacter = new BracketElectricCharacterSupport(this.brackets, autoClosingPairs, this._conf.__electricCharacterSupport);
            }
            return this._electricCharacter;
        },
        enumerable: true,
        configurable: true
    });
    RichEditSupport._mergeConf = function (prev, current) {
        return {
            comments: (prev ? current.comments || prev.comments : current.comments),
            brackets: (prev ? current.brackets || prev.brackets : current.brackets),
            wordPattern: (prev ? current.wordPattern || prev.wordPattern : current.wordPattern),
            indentationRules: (prev ? current.indentationRules || prev.indentationRules : current.indentationRules),
            onEnterRules: (prev ? current.onEnterRules || prev.onEnterRules : current.onEnterRules),
            autoClosingPairs: (prev ? current.autoClosingPairs || prev.autoClosingPairs : current.autoClosingPairs),
            surroundingPairs: (prev ? current.surroundingPairs || prev.surroundingPairs : current.surroundingPairs),
            folding: (prev ? current.folding || prev.folding : current.folding),
            __electricCharacterSupport: (prev ? current.__electricCharacterSupport || prev.__electricCharacterSupport : current.__electricCharacterSupport),
        };
    };
    RichEditSupport._handleOnEnter = function (conf) {
        // on enter
        var onEnter = {};
        var empty$$1 = true;
        if (conf.brackets) {
            empty$$1 = false;
            onEnter.brackets = conf.brackets;
        }
        if (conf.indentationRules) {
            empty$$1 = false;
        }
        if (conf.onEnterRules) {
            empty$$1 = false;
            onEnter.regExpRules = conf.onEnterRules;
        }
        if (!empty$$1) {
            return new OnEnterSupport(onEnter);
        }
        return null;
    };
    RichEditSupport._handleComments = function (conf) {
        var commentRule = conf.comments;
        if (!commentRule) {
            return null;
        }
        // comment configuration
        var comments = {};
        if (commentRule.lineComment) {
            comments.lineCommentToken = commentRule.lineComment;
        }
        if (commentRule.blockComment) {
            var _a = commentRule.blockComment, blockStart = _a[0], blockEnd = _a[1];
            comments.blockCommentStartToken = blockStart;
            comments.blockCommentEndToken = blockEnd;
        }
        return comments;
    };
    return RichEditSupport;
}());
var LanguageConfigurationRegistryImpl = /** @class */ (function () {
    function LanguageConfigurationRegistryImpl() {
        this._onDidChange = new Emitter();
        this.onDidChange = this._onDidChange.event;
        this._entries = [];
    }
    LanguageConfigurationRegistryImpl.prototype.register = function (languageIdentifier, configuration) {
        var _this = this;
        var previous = this._getRichEditSupport(languageIdentifier.id);
        var current = new RichEditSupport(languageIdentifier, previous, configuration);
        this._entries[languageIdentifier.id] = current;
        this._onDidChange.fire({ languageIdentifier: languageIdentifier });
        return {
            dispose: function () {
                if (_this._entries[languageIdentifier.id] === current) {
                    _this._entries[languageIdentifier.id] = previous;
                    _this._onDidChange.fire({ languageIdentifier: languageIdentifier });
                }
            }
        };
    };
    LanguageConfigurationRegistryImpl.prototype._getRichEditSupport = function (languageId) {
        return this._entries[languageId] || null;
    };
    LanguageConfigurationRegistryImpl.prototype.getIndentationRules = function (languageId) {
        var value = this._entries[languageId];
        if (!value) {
            return null;
        }
        return value.indentationRules || null;
    };
    // begin electricCharacter
    LanguageConfigurationRegistryImpl.prototype._getElectricCharacterSupport = function (languageId) {
        var value = this._getRichEditSupport(languageId);
        if (!value) {
            return null;
        }
        return value.electricCharacter || null;
    };
    LanguageConfigurationRegistryImpl.prototype.getElectricCharacters = function (languageId) {
        var electricCharacterSupport = this._getElectricCharacterSupport(languageId);
        if (!electricCharacterSupport) {
            return [];
        }
        return electricCharacterSupport.getElectricCharacters();
    };
    /**
     * Should return opening bracket type to match indentation with
     */
    LanguageConfigurationRegistryImpl.prototype.onElectricCharacter = function (character, context, column) {
        var scopedLineTokens = createScopedLineTokens(context, column - 1);
        var electricCharacterSupport = this._getElectricCharacterSupport(scopedLineTokens.languageId);
        if (!electricCharacterSupport) {
            return null;
        }
        return electricCharacterSupport.onElectricCharacter(character, scopedLineTokens, column - scopedLineTokens.firstCharOffset);
    };
    // end electricCharacter
    LanguageConfigurationRegistryImpl.prototype.getComments = function (languageId) {
        var value = this._getRichEditSupport(languageId);
        if (!value) {
            return null;
        }
        return value.comments || null;
    };
    // begin characterPair
    LanguageConfigurationRegistryImpl.prototype._getCharacterPairSupport = function (languageId) {
        var value = this._getRichEditSupport(languageId);
        if (!value) {
            return null;
        }
        return value.characterPair || null;
    };
    LanguageConfigurationRegistryImpl.prototype.getAutoClosingPairs = function (languageId) {
        var characterPairSupport = this._getCharacterPairSupport(languageId);
        if (!characterPairSupport) {
            return [];
        }
        return characterPairSupport.getAutoClosingPairs();
    };
    LanguageConfigurationRegistryImpl.prototype.getSurroundingPairs = function (languageId) {
        var characterPairSupport = this._getCharacterPairSupport(languageId);
        if (!characterPairSupport) {
            return [];
        }
        return characterPairSupport.getSurroundingPairs();
    };
    LanguageConfigurationRegistryImpl.prototype.shouldAutoClosePair = function (character, context, column) {
        var scopedLineTokens = createScopedLineTokens(context, column - 1);
        var characterPairSupport = this._getCharacterPairSupport(scopedLineTokens.languageId);
        if (!characterPairSupport) {
            return false;
        }
        return characterPairSupport.shouldAutoClosePair(character, scopedLineTokens, column - scopedLineTokens.firstCharOffset);
    };
    // end characterPair
    LanguageConfigurationRegistryImpl.prototype.getWordDefinition = function (languageId) {
        var value = this._getRichEditSupport(languageId);
        if (!value) {
            return ensureValidWordDefinition(null);
        }
        return ensureValidWordDefinition(value.wordDefinition || null);
    };
    LanguageConfigurationRegistryImpl.prototype.getFoldingRules = function (languageId) {
        var value = this._getRichEditSupport(languageId);
        if (!value) {
            return {};
        }
        return value.foldingRules;
    };
    // begin Indent Rules
    LanguageConfigurationRegistryImpl.prototype.getIndentRulesSupport = function (languageId) {
        var value = this._getRichEditSupport(languageId);
        if (!value) {
            return null;
        }
        return value.indentRulesSupport || null;
    };
    /**
     * Get nearest preceiding line which doesn't match unIndentPattern or contains all whitespace.
     * Result:
     * -1: run into the boundary of embedded languages
     * 0: every line above are invalid
     * else: nearest preceding line of the same language
     */
    LanguageConfigurationRegistryImpl.prototype.getPrecedingValidLine = function (model, lineNumber, indentRulesSupport) {
        var languageID = model.getLanguageIdAtPosition(lineNumber, 0);
        if (lineNumber > 1) {
            var lastLineNumber = lineNumber - 1;
            var resultLineNumber = -1;
            for (lastLineNumber = lineNumber - 1; lastLineNumber >= 1; lastLineNumber--) {
                if (model.getLanguageIdAtPosition(lastLineNumber, 0) !== languageID) {
                    return resultLineNumber;
                }
                var text = model.getLineContent(lastLineNumber);
                if (indentRulesSupport.shouldIgnore(text) || /^\s+$/.test(text) || text === '') {
                    resultLineNumber = lastLineNumber;
                    continue;
                }
                return lastLineNumber;
            }
        }
        return -1;
    };
    /**
     * Get inherited indentation from above lines.
     * 1. Find the nearest preceding line which doesn't match unIndentedLinePattern.
     * 2. If this line matches indentNextLinePattern or increaseIndentPattern, it means that the indent level of `lineNumber` should be 1 greater than this line.
     * 3. If this line doesn't match any indent rules
     *   a. check whether the line above it matches indentNextLinePattern
     *   b. If not, the indent level of this line is the result
     *   c. If so, it means the indent of this line is *temporary*, go upward utill we find a line whose indent is not temporary (the same workflow a -> b -> c).
     * 4. Otherwise, we fail to get an inherited indent from aboves. Return null and we should not touch the indent of `lineNumber`
     *
     * This function only return the inherited indent based on above lines, it doesn't check whether current line should decrease or not.
     */
    LanguageConfigurationRegistryImpl.prototype.getInheritIndentForLine = function (model, lineNumber, honorIntentialIndent) {
        if (honorIntentialIndent === void 0) { honorIntentialIndent = true; }
        var indentRulesSupport = this.getIndentRulesSupport(model.getLanguageIdentifier().id);
        if (!indentRulesSupport) {
            return null;
        }
        if (lineNumber <= 1) {
            return {
                indentation: '',
                action: null
            };
        }
        var precedingUnIgnoredLine = this.getPrecedingValidLine(model, lineNumber, indentRulesSupport);
        if (precedingUnIgnoredLine < 0) {
            return null;
        }
        else if (precedingUnIgnoredLine < 1) {
            return {
                indentation: '',
                action: null
            };
        }
        var precedingUnIgnoredLineContent = model.getLineContent(precedingUnIgnoredLine);
        if (indentRulesSupport.shouldIncrease(precedingUnIgnoredLineContent) || indentRulesSupport.shouldIndentNextLine(precedingUnIgnoredLineContent)) {
            return {
                indentation: getLeadingWhitespace(precedingUnIgnoredLineContent),
                action: IndentAction.Indent,
                line: precedingUnIgnoredLine
            };
        }
        else if (indentRulesSupport.shouldDecrease(precedingUnIgnoredLineContent)) {
            return {
                indentation: getLeadingWhitespace(precedingUnIgnoredLineContent),
                action: null,
                line: precedingUnIgnoredLine
            };
        }
        else {
            // precedingUnIgnoredLine can not be ignored.
            // it doesn't increase indent of following lines
            // it doesn't increase just next line
            // so current line is not affect by precedingUnIgnoredLine
            // and then we should get a correct inheritted indentation from above lines
            if (precedingUnIgnoredLine === 1) {
                return {
                    indentation: getLeadingWhitespace(model.getLineContent(precedingUnIgnoredLine)),
                    action: null,
                    line: precedingUnIgnoredLine
                };
            }
            var previousLine = precedingUnIgnoredLine - 1;
            var previousLineIndentMetadata = indentRulesSupport.getIndentMetadata(model.getLineContent(previousLine));
            if (!(previousLineIndentMetadata & (1 /* INCREASE_MASK */ | 2 /* DECREASE_MASK */)) &&
                (previousLineIndentMetadata & 4 /* INDENT_NEXTLINE_MASK */)) {
                var stopLine = 0;
                for (var i = previousLine - 1; i > 0; i--) {
                    if (indentRulesSupport.shouldIndentNextLine(model.getLineContent(i))) {
                        continue;
                    }
                    stopLine = i;
                    break;
                }
                return {
                    indentation: getLeadingWhitespace(model.getLineContent(stopLine + 1)),
                    action: null,
                    line: stopLine + 1
                };
            }
            if (honorIntentialIndent) {
                return {
                    indentation: getLeadingWhitespace(model.getLineContent(precedingUnIgnoredLine)),
                    action: null,
                    line: precedingUnIgnoredLine
                };
            }
            else {
                // search from precedingUnIgnoredLine until we find one whose indent is not temporary
                for (var i = precedingUnIgnoredLine; i > 0; i--) {
                    var lineContent = model.getLineContent(i);
                    if (indentRulesSupport.shouldIncrease(lineContent)) {
                        return {
                            indentation: getLeadingWhitespace(lineContent),
                            action: IndentAction.Indent,
                            line: i
                        };
                    }
                    else if (indentRulesSupport.shouldIndentNextLine(lineContent)) {
                        var stopLine = 0;
                        for (var j = i - 1; j > 0; j--) {
                            if (indentRulesSupport.shouldIndentNextLine(model.getLineContent(i))) {
                                continue;
                            }
                            stopLine = j;
                            break;
                        }
                        return {
                            indentation: getLeadingWhitespace(model.getLineContent(stopLine + 1)),
                            action: null,
                            line: stopLine + 1
                        };
                    }
                    else if (indentRulesSupport.shouldDecrease(lineContent)) {
                        return {
                            indentation: getLeadingWhitespace(lineContent),
                            action: null,
                            line: i
                        };
                    }
                }
                return {
                    indentation: getLeadingWhitespace(model.getLineContent(1)),
                    action: null,
                    line: 1
                };
            }
        }
    };
    LanguageConfigurationRegistryImpl.prototype.getGoodIndentForLine = function (virtualModel, languageId, lineNumber, indentConverter) {
        var indentRulesSupport = this.getIndentRulesSupport(languageId);
        if (!indentRulesSupport) {
            return null;
        }
        var indent = this.getInheritIndentForLine(virtualModel, lineNumber);
        var lineContent = virtualModel.getLineContent(lineNumber);
        if (indent) {
            var inheritLine = indent.line;
            if (inheritLine !== undefined) {
                var onEnterSupport = this._getOnEnterSupport(languageId);
                var enterResult = null;
                try {
                    enterResult = onEnterSupport.onEnter('', virtualModel.getLineContent(inheritLine), '');
                }
                catch (e) {
                    onUnexpectedError(e);
                }
                if (enterResult) {
                    var indentation = getLeadingWhitespace(virtualModel.getLineContent(inheritLine));
                    if (enterResult.removeText) {
                        indentation = indentation.substring(0, indentation.length - enterResult.removeText);
                    }
                    if ((enterResult.indentAction === IndentAction.Indent) ||
                        (enterResult.indentAction === IndentAction.IndentOutdent)) {
                        indentation = indentConverter.shiftIndent(indentation);
                    }
                    else if (enterResult.indentAction === IndentAction.Outdent) {
                        indentation = indentConverter.unshiftIndent(indentation);
                    }
                    if (indentRulesSupport.shouldDecrease(lineContent)) {
                        indentation = indentConverter.unshiftIndent(indentation);
                    }
                    if (enterResult.appendText) {
                        indentation += enterResult.appendText;
                    }
                    return getLeadingWhitespace(indentation);
                }
            }
            if (indentRulesSupport.shouldDecrease(lineContent)) {
                if (indent.action === IndentAction.Indent) {
                    return indent.indentation;
                }
                else {
                    return indentConverter.unshiftIndent(indent.indentation);
                }
            }
            else {
                if (indent.action === IndentAction.Indent) {
                    return indentConverter.shiftIndent(indent.indentation);
                }
                else {
                    return indent.indentation;
                }
            }
        }
        return null;
    };
    LanguageConfigurationRegistryImpl.prototype.getIndentForEnter = function (model, range, indentConverter, autoIndent) {
        model.forceTokenization(range.startLineNumber);
        var lineTokens = model.getLineTokens(range.startLineNumber);
        var beforeEnterText;
        var afterEnterText;
        var scopedLineTokens = createScopedLineTokens(lineTokens, range.startColumn - 1);
        var scopedLineText = scopedLineTokens.getLineContent();
        var embeddedLanguage = false;
        if (scopedLineTokens.firstCharOffset > 0 && lineTokens.getLanguageId(0) !== scopedLineTokens.languageId) {
            // we are in the embeded language content
            embeddedLanguage = true; // if embeddedLanguage is true, then we don't touch the indentation of current line
            beforeEnterText = scopedLineText.substr(0, range.startColumn - 1 - scopedLineTokens.firstCharOffset);
        }
        else {
            beforeEnterText = lineTokens.getLineContent().substring(0, range.startColumn - 1);
        }
        if (range.isEmpty()) {
            afterEnterText = scopedLineText.substr(range.startColumn - 1 - scopedLineTokens.firstCharOffset);
        }
        else {
            var endScopedLineTokens = this.getScopedLineTokens(model, range.endLineNumber, range.endColumn);
            afterEnterText = endScopedLineTokens.getLineContent().substr(range.endColumn - 1 - scopedLineTokens.firstCharOffset);
        }
        var indentRulesSupport = this.getIndentRulesSupport(scopedLineTokens.languageId);
        if (!indentRulesSupport) {
            return null;
        }
        var beforeEnterResult = beforeEnterText;
        var beforeEnterIndent = getLeadingWhitespace(beforeEnterText);
        if (!autoIndent && !embeddedLanguage) {
            var beforeEnterIndentAction = this.getInheritIndentForLine(model, range.startLineNumber);
            if (indentRulesSupport.shouldDecrease(beforeEnterText)) {
                if (beforeEnterIndentAction) {
                    beforeEnterIndent = beforeEnterIndentAction.indentation;
                    if (beforeEnterIndentAction.action !== IndentAction.Indent) {
                        beforeEnterIndent = indentConverter.unshiftIndent(beforeEnterIndent);
                    }
                }
            }
            beforeEnterResult = beforeEnterIndent + ltrim(ltrim(beforeEnterText, ' '), '\t');
        }
        var virtualModel = {
            getLineTokens: function (lineNumber) {
                return model.getLineTokens(lineNumber);
            },
            getLanguageIdentifier: function () {
                return model.getLanguageIdentifier();
            },
            getLanguageIdAtPosition: function (lineNumber, column) {
                return model.getLanguageIdAtPosition(lineNumber, column);
            },
            getLineContent: function (lineNumber) {
                if (lineNumber === range.startLineNumber) {
                    return beforeEnterResult;
                }
                else {
                    return model.getLineContent(lineNumber);
                }
            }
        };
        var currentLineIndent = getLeadingWhitespace(lineTokens.getLineContent());
        var afterEnterAction = this.getInheritIndentForLine(virtualModel, range.startLineNumber + 1);
        if (!afterEnterAction) {
            var beforeEnter = embeddedLanguage ? currentLineIndent : beforeEnterIndent;
            return {
                beforeEnter: beforeEnter,
                afterEnter: beforeEnter
            };
        }
        var afterEnterIndent = embeddedLanguage ? currentLineIndent : afterEnterAction.indentation;
        if (afterEnterAction.action === IndentAction.Indent) {
            afterEnterIndent = indentConverter.shiftIndent(afterEnterIndent);
        }
        if (indentRulesSupport.shouldDecrease(afterEnterText)) {
            afterEnterIndent = indentConverter.unshiftIndent(afterEnterIndent);
        }
        return {
            beforeEnter: embeddedLanguage ? currentLineIndent : beforeEnterIndent,
            afterEnter: afterEnterIndent
        };
    };
    /**
     * We should always allow intentional indentation. It means, if users change the indentation of `lineNumber` and the content of
     * this line doesn't match decreaseIndentPattern, we should not adjust the indentation.
     */
    LanguageConfigurationRegistryImpl.prototype.getIndentActionForType = function (model, range, ch, indentConverter) {
        var scopedLineTokens = this.getScopedLineTokens(model, range.startLineNumber, range.startColumn);
        var indentRulesSupport = this.getIndentRulesSupport(scopedLineTokens.languageId);
        if (!indentRulesSupport) {
            return null;
        }
        var scopedLineText = scopedLineTokens.getLineContent();
        var beforeTypeText = scopedLineText.substr(0, range.startColumn - 1 - scopedLineTokens.firstCharOffset);
        var afterTypeText;
        // selection support
        if (range.isEmpty()) {
            afterTypeText = scopedLineText.substr(range.startColumn - 1 - scopedLineTokens.firstCharOffset);
        }
        else {
            var endScopedLineTokens = this.getScopedLineTokens(model, range.endLineNumber, range.endColumn);
            afterTypeText = endScopedLineTokens.getLineContent().substr(range.endColumn - 1 - scopedLineTokens.firstCharOffset);
        }
        // If previous content already matches decreaseIndentPattern, it means indentation of this line should already be adjusted
        // Users might change the indentation by purpose and we should honor that instead of readjusting.
        if (!indentRulesSupport.shouldDecrease(beforeTypeText + afterTypeText) && indentRulesSupport.shouldDecrease(beforeTypeText + ch + afterTypeText)) {
            // after typing `ch`, the content matches decreaseIndentPattern, we should adjust the indent to a good manner.
            // 1. Get inherited indent action
            var r = this.getInheritIndentForLine(model, range.startLineNumber, false);
            if (!r) {
                return null;
            }
            var indentation = r.indentation;
            if (r.action !== IndentAction.Indent) {
                indentation = indentConverter.unshiftIndent(indentation);
            }
            return indentation;
        }
        return null;
    };
    LanguageConfigurationRegistryImpl.prototype.getIndentMetadata = function (model, lineNumber) {
        var indentRulesSupport = this.getIndentRulesSupport(model.getLanguageIdentifier().id);
        if (!indentRulesSupport) {
            return null;
        }
        if (lineNumber < 1 || lineNumber > model.getLineCount()) {
            return null;
        }
        return indentRulesSupport.getIndentMetadata(model.getLineContent(lineNumber));
    };
    // end Indent Rules
    // begin onEnter
    LanguageConfigurationRegistryImpl.prototype._getOnEnterSupport = function (languageId) {
        var value = this._getRichEditSupport(languageId);
        if (!value) {
            return null;
        }
        return value.onEnter || null;
    };
    LanguageConfigurationRegistryImpl.prototype.getRawEnterActionAtPosition = function (model, lineNumber, column) {
        var r = this.getEnterAction(model, new Range(lineNumber, column, lineNumber, column));
        return r ? r.enterAction : null;
    };
    LanguageConfigurationRegistryImpl.prototype.getEnterAction = function (model, range) {
        var indentation = this.getIndentationAtPosition(model, range.startLineNumber, range.startColumn);
        var scopedLineTokens = this.getScopedLineTokens(model, range.startLineNumber, range.startColumn);
        var onEnterSupport = this._getOnEnterSupport(scopedLineTokens.languageId);
        if (!onEnterSupport) {
            return null;
        }
        var scopedLineText = scopedLineTokens.getLineContent();
        var beforeEnterText = scopedLineText.substr(0, range.startColumn - 1 - scopedLineTokens.firstCharOffset);
        var afterEnterText;
        // selection support
        if (range.isEmpty()) {
            afterEnterText = scopedLineText.substr(range.startColumn - 1 - scopedLineTokens.firstCharOffset);
        }
        else {
            var endScopedLineTokens = this.getScopedLineTokens(model, range.endLineNumber, range.endColumn);
            afterEnterText = endScopedLineTokens.getLineContent().substr(range.endColumn - 1 - scopedLineTokens.firstCharOffset);
        }
        var lineNumber = range.startLineNumber;
        var oneLineAboveText = '';
        if (lineNumber > 1 && scopedLineTokens.firstCharOffset === 0) {
            // This is not the first line and the entire line belongs to this mode
            var oneLineAboveScopedLineTokens = this.getScopedLineTokens(model, lineNumber - 1);
            if (oneLineAboveScopedLineTokens.languageId === scopedLineTokens.languageId) {
                // The line above ends with text belonging to the same mode
                oneLineAboveText = oneLineAboveScopedLineTokens.getLineContent();
            }
        }
        var enterResult = null;
        try {
            enterResult = onEnterSupport.onEnter(oneLineAboveText, beforeEnterText, afterEnterText);
        }
        catch (e) {
            onUnexpectedError(e);
        }
        if (!enterResult) {
            return null;
        }
        else {
            // Here we add `\t` to appendText first because enterAction is leveraging appendText and removeText to change indentation.
            if (!enterResult.appendText) {
                if ((enterResult.indentAction === IndentAction.Indent) ||
                    (enterResult.indentAction === IndentAction.IndentOutdent)) {
                    enterResult.appendText = '\t';
                }
                else {
                    enterResult.appendText = '';
                }
            }
        }
        if (enterResult.removeText) {
            indentation = indentation.substring(0, indentation.length - enterResult.removeText);
        }
        return {
            enterAction: enterResult,
            indentation: indentation,
        };
    };
    LanguageConfigurationRegistryImpl.prototype.getIndentationAtPosition = function (model, lineNumber, column) {
        var lineText = model.getLineContent(lineNumber);
        var indentation = getLeadingWhitespace(lineText);
        if (indentation.length > column - 1) {
            indentation = indentation.substring(0, column - 1);
        }
        return indentation;
    };
    LanguageConfigurationRegistryImpl.prototype.getScopedLineTokens = function (model, lineNumber, columnNumber) {
        model.forceTokenization(lineNumber);
        var lineTokens = model.getLineTokens(lineNumber);
        var column = isNaN(columnNumber) ? model.getLineMaxColumn(lineNumber) - 1 : columnNumber - 1;
        var scopedLineTokens = createScopedLineTokens(lineTokens, column);
        return scopedLineTokens;
    };
    // end onEnter
    LanguageConfigurationRegistryImpl.prototype.getBracketsSupport = function (languageId) {
        var value = this._getRichEditSupport(languageId);
        if (!value) {
            return null;
        }
        return value.brackets || null;
    };
    return LanguageConfigurationRegistryImpl;
}());
var LanguageConfigurationRegistry = new LanguageConfigurationRegistryImpl();

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var LineTokens = /** @class */ (function () {
    function LineTokens(tokens, text) {
        this._tokens = tokens;
        this._tokensCount = (this._tokens.length >>> 1);
        this._text = text;
    }
    LineTokens.prototype.equals = function (other) {
        if (other instanceof LineTokens) {
            return this.slicedEquals(other, 0, this._tokensCount);
        }
        return false;
    };
    LineTokens.prototype.slicedEquals = function (other, sliceFromTokenIndex, sliceTokenCount) {
        if (this._text !== other._text) {
            return false;
        }
        if (this._tokensCount !== other._tokensCount) {
            return false;
        }
        var from = (sliceFromTokenIndex << 1);
        var to = from + (sliceTokenCount << 1);
        for (var i = from; i < to; i++) {
            if (this._tokens[i] !== other._tokens[i]) {
                return false;
            }
        }
        return true;
    };
    LineTokens.prototype.getLineContent = function () {
        return this._text;
    };
    LineTokens.prototype.getCount = function () {
        return this._tokensCount;
    };
    LineTokens.prototype.getStartOffset = function (tokenIndex) {
        if (tokenIndex > 0) {
            return this._tokens[(tokenIndex - 1) << 1];
        }
        return 0;
    };
    LineTokens.prototype.getLanguageId = function (tokenIndex) {
        var metadata = this._tokens[(tokenIndex << 1) + 1];
        return TokenMetadata.getLanguageId(metadata);
    };
    LineTokens.prototype.getStandardTokenType = function (tokenIndex) {
        var metadata = this._tokens[(tokenIndex << 1) + 1];
        return TokenMetadata.getTokenType(metadata);
    };
    LineTokens.prototype.getForeground = function (tokenIndex) {
        var metadata = this._tokens[(tokenIndex << 1) + 1];
        return TokenMetadata.getForeground(metadata);
    };
    LineTokens.prototype.getClassName = function (tokenIndex) {
        var metadata = this._tokens[(tokenIndex << 1) + 1];
        return TokenMetadata.getClassNameFromMetadata(metadata);
    };
    LineTokens.prototype.getInlineStyle = function (tokenIndex, colorMap) {
        var metadata = this._tokens[(tokenIndex << 1) + 1];
        return TokenMetadata.getInlineStyleFromMetadata(metadata, colorMap);
    };
    LineTokens.prototype.getEndOffset = function (tokenIndex) {
        return this._tokens[tokenIndex << 1];
    };
    /**
     * Find the token containing offset `offset`.
     * @param offset The search offset
     * @return The index of the token containing the offset.
     */
    LineTokens.prototype.findTokenIndexAtOffset = function (offset) {
        return LineTokens.findIndexInTokensArray(this._tokens, offset);
    };
    LineTokens.prototype.inflate = function () {
        return this;
    };
    LineTokens.prototype.sliceAndInflate = function (startOffset, endOffset, deltaOffset) {
        return new SlicedLineTokens(this, startOffset, endOffset, deltaOffset);
    };
    LineTokens.convertToEndOffset = function (tokens, lineTextLength) {
        var tokenCount = (tokens.length >>> 1);
        var lastTokenIndex = tokenCount - 1;
        for (var tokenIndex = 0; tokenIndex < lastTokenIndex; tokenIndex++) {
            tokens[tokenIndex << 1] = tokens[(tokenIndex + 1) << 1];
        }
        tokens[lastTokenIndex << 1] = lineTextLength;
    };
    LineTokens.findIndexInTokensArray = function (tokens, desiredIndex) {
        if (tokens.length <= 2) {
            return 0;
        }
        var low = 0;
        var high = (tokens.length >>> 1) - 1;
        while (low < high) {
            var mid = low + Math.floor((high - low) / 2);
            var endOffset = tokens[(mid << 1)];
            if (endOffset === desiredIndex) {
                return mid + 1;
            }
            else if (endOffset < desiredIndex) {
                low = mid + 1;
            }
            else if (endOffset > desiredIndex) {
                high = mid;
            }
        }
        return low;
    };
    return LineTokens;
}());
var SlicedLineTokens = /** @class */ (function () {
    function SlicedLineTokens(source, startOffset, endOffset, deltaOffset) {
        this._source = source;
        this._startOffset = startOffset;
        this._endOffset = endOffset;
        this._deltaOffset = deltaOffset;
        this._firstTokenIndex = source.findTokenIndexAtOffset(startOffset);
        this._tokensCount = 0;
        for (var i = this._firstTokenIndex, len = source.getCount(); i < len; i++) {
            var tokenStartOffset = source.getStartOffset(i);
            if (tokenStartOffset >= endOffset) {
                break;
            }
            this._tokensCount++;
        }
    }
    SlicedLineTokens.prototype.equals = function (other) {
        if (other instanceof SlicedLineTokens) {
            return (this._startOffset === other._startOffset
                && this._endOffset === other._endOffset
                && this._deltaOffset === other._deltaOffset
                && this._source.slicedEquals(other._source, this._firstTokenIndex, this._tokensCount));
        }
        return false;
    };
    SlicedLineTokens.prototype.getCount = function () {
        return this._tokensCount;
    };
    SlicedLineTokens.prototype.getForeground = function (tokenIndex) {
        return this._source.getForeground(this._firstTokenIndex + tokenIndex);
    };
    SlicedLineTokens.prototype.getEndOffset = function (tokenIndex) {
        var tokenEndOffset = this._source.getEndOffset(this._firstTokenIndex + tokenIndex);
        return Math.min(this._endOffset, tokenEndOffset) - this._startOffset + this._deltaOffset;
    };
    SlicedLineTokens.prototype.getClassName = function (tokenIndex) {
        return this._source.getClassName(this._firstTokenIndex + tokenIndex);
    };
    SlicedLineTokens.prototype.getInlineStyle = function (tokenIndex, colorMap) {
        return this._source.getInlineStyle(this._firstTokenIndex + tokenIndex, colorMap);
    };
    SlicedLineTokens.prototype.findTokenIndexAtOffset = function (offset) {
        return this._source.findTokenIndexAtOffset(offset + this._startOffset - this._deltaOffset) - this._firstTokenIndex;
    };
    return SlicedLineTokens;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
function getDefaultMetadata(topLevelLanguageId) {
    return ((topLevelLanguageId << 0 /* LANGUAGEID_OFFSET */)
        | (0 /* Other */ << 8 /* TOKEN_TYPE_OFFSET */)
        | (0 /* None */ << 11 /* FONT_STYLE_OFFSET */)
        | (1 /* DefaultForeground */ << 14 /* FOREGROUND_OFFSET */)
        | (2 /* DefaultBackground */ << 23 /* BACKGROUND_OFFSET */)) >>> 0;
}
var EMPTY_LINE_TOKENS = (new Uint32Array(0)).buffer;
var ModelLineTokens = /** @class */ (function () {
    function ModelLineTokens(state) {
        this._state = state;
        this._lineTokens = null;
        this._invalid = true;
    }
    ModelLineTokens.prototype.deleteBeginning = function (toChIndex) {
        if (this._lineTokens === null || this._lineTokens === EMPTY_LINE_TOKENS) {
            return;
        }
        this.delete(0, toChIndex);
    };
    ModelLineTokens.prototype.deleteEnding = function (fromChIndex) {
        if (this._lineTokens === null || this._lineTokens === EMPTY_LINE_TOKENS) {
            return;
        }
        var tokens = new Uint32Array(this._lineTokens);
        var lineTextLength = tokens[tokens.length - 2];
        this.delete(fromChIndex, lineTextLength);
    };
    ModelLineTokens.prototype.delete = function (fromChIndex, toChIndex) {
        if (this._lineTokens === null || this._lineTokens === EMPTY_LINE_TOKENS || fromChIndex === toChIndex) {
            return;
        }
        var tokens = new Uint32Array(this._lineTokens);
        var tokensCount = (tokens.length >>> 1);
        // special case: deleting everything
        if (fromChIndex === 0 && tokens[tokens.length - 2] === toChIndex) {
            this._lineTokens = EMPTY_LINE_TOKENS;
            return;
        }
        var fromTokenIndex = LineTokens.findIndexInTokensArray(tokens, fromChIndex);
        var fromTokenStartOffset = (fromTokenIndex > 0 ? tokens[(fromTokenIndex - 1) << 1] : 0);
        var fromTokenEndOffset = tokens[fromTokenIndex << 1];
        if (toChIndex < fromTokenEndOffset) {
            // the delete range is inside a single token
            var delta_1 = (toChIndex - fromChIndex);
            for (var i = fromTokenIndex; i < tokensCount; i++) {
                tokens[i << 1] -= delta_1;
            }
            return;
        }
        var dest;
        var lastEnd;
        if (fromTokenStartOffset !== fromChIndex) {
            tokens[fromTokenIndex << 1] = fromChIndex;
            dest = ((fromTokenIndex + 1) << 1);
            lastEnd = fromChIndex;
        }
        else {
            dest = (fromTokenIndex << 1);
            lastEnd = fromTokenStartOffset;
        }
        var delta$$1 = (toChIndex - fromChIndex);
        for (var tokenIndex = fromTokenIndex + 1; tokenIndex < tokensCount; tokenIndex++) {
            var tokenEndOffset = tokens[tokenIndex << 1] - delta$$1;
            if (tokenEndOffset > lastEnd) {
                tokens[dest++] = tokenEndOffset;
                tokens[dest++] = tokens[(tokenIndex << 1) + 1];
                lastEnd = tokenEndOffset;
            }
        }
        if (dest === tokens.length) {
            // nothing to trim
            return;
        }
        var tmp = new Uint32Array(dest);
        tmp.set(tokens.subarray(0, dest), 0);
        this._lineTokens = tmp.buffer;
    };
    ModelLineTokens.prototype.append = function (_otherTokens) {
        if (_otherTokens === EMPTY_LINE_TOKENS) {
            return;
        }
        if (this._lineTokens === EMPTY_LINE_TOKENS) {
            this._lineTokens = _otherTokens;
            return;
        }
        if (this._lineTokens === null) {
            return;
        }
        if (_otherTokens === null) {
            // cannot determine combined line length...
            this._lineTokens = null;
            return;
        }
        var myTokens = new Uint32Array(this._lineTokens);
        var otherTokens = new Uint32Array(_otherTokens);
        var otherTokensCount = (otherTokens.length >>> 1);
        var result = new Uint32Array(myTokens.length + otherTokens.length);
        result.set(myTokens, 0);
        var dest = myTokens.length;
        var delta$$1 = myTokens[myTokens.length - 2];
        for (var i = 0; i < otherTokensCount; i++) {
            result[dest++] = otherTokens[(i << 1)] + delta$$1;
            result[dest++] = otherTokens[(i << 1) + 1];
        }
        this._lineTokens = result.buffer;
    };
    ModelLineTokens.prototype.insert = function (chIndex, textLength) {
        if (!this._lineTokens) {
            // nothing to do
            return;
        }
        var tokens = new Uint32Array(this._lineTokens);
        var tokensCount = (tokens.length >>> 1);
        var fromTokenIndex = LineTokens.findIndexInTokensArray(tokens, chIndex);
        if (fromTokenIndex > 0) {
            var fromTokenStartOffset = (fromTokenIndex > 0 ? tokens[(fromTokenIndex - 1) << 1] : 0);
            if (fromTokenStartOffset === chIndex) {
                fromTokenIndex--;
            }
        }
        for (var tokenIndex = fromTokenIndex; tokenIndex < tokensCount; tokenIndex++) {
            tokens[tokenIndex << 1] += textLength;
        }
    };
    return ModelLineTokens;
}());
var ModelLinesTokens = /** @class */ (function () {
    function ModelLinesTokens(languageIdentifier, tokenizationSupport) {
        this.languageIdentifier = languageIdentifier;
        this.tokenizationSupport = tokenizationSupport;
        this._tokens = [];
        if (this.tokenizationSupport) {
            var initialState = null;
            try {
                initialState = this.tokenizationSupport.getInitialState();
            }
            catch (e) {
                onUnexpectedError(e);
                this.tokenizationSupport = null;
            }
            if (initialState) {
                this._tokens[0] = new ModelLineTokens(initialState);
            }
        }
        this._invalidLineStartIndex = 0;
        this._lastState = null;
    }
    Object.defineProperty(ModelLinesTokens.prototype, "inValidLineStartIndex", {
        get: function () {
            return this._invalidLineStartIndex;
        },
        enumerable: true,
        configurable: true
    });
    ModelLinesTokens.prototype.getTokens = function (topLevelLanguageId, lineIndex, lineText) {
        var rawLineTokens = null;
        if (lineIndex < this._tokens.length && this._tokens[lineIndex]) {
            rawLineTokens = this._tokens[lineIndex]._lineTokens;
        }
        if (rawLineTokens !== null && rawLineTokens !== EMPTY_LINE_TOKENS) {
            return new LineTokens(new Uint32Array(rawLineTokens), lineText);
        }
        var lineTokens = new Uint32Array(2);
        lineTokens[0] = lineText.length;
        lineTokens[1] = getDefaultMetadata(topLevelLanguageId);
        return new LineTokens(lineTokens, lineText);
    };
    ModelLinesTokens.prototype.isCheapToTokenize = function (lineNumber) {
        var firstInvalidLineNumber = this._invalidLineStartIndex + 1;
        return (firstInvalidLineNumber >= lineNumber);
    };
    ModelLinesTokens.prototype.hasLinesToTokenize = function (buffer) {
        return (this._invalidLineStartIndex < buffer.getLineCount());
    };
    ModelLinesTokens.prototype.invalidateLine = function (lineIndex) {
        this._setIsInvalid(lineIndex, true);
        if (lineIndex < this._invalidLineStartIndex) {
            this._setIsInvalid(this._invalidLineStartIndex, true);
            this._invalidLineStartIndex = lineIndex;
        }
    };
    ModelLinesTokens.prototype._setIsInvalid = function (lineIndex, invalid) {
        if (lineIndex < this._tokens.length && this._tokens[lineIndex]) {
            this._tokens[lineIndex]._invalid = invalid;
        }
    };
    ModelLinesTokens.prototype._isInvalid = function (lineIndex) {
        if (lineIndex < this._tokens.length && this._tokens[lineIndex]) {
            return this._tokens[lineIndex]._invalid;
        }
        return true;
    };
    ModelLinesTokens.prototype._getState = function (lineIndex) {
        if (lineIndex < this._tokens.length && this._tokens[lineIndex]) {
            return this._tokens[lineIndex]._state;
        }
        return null;
    };
    ModelLinesTokens.prototype._setTokens = function (topLevelLanguageId, lineIndex, lineTextLength, tokens) {
        var target;
        if (lineIndex < this._tokens.length && this._tokens[lineIndex]) {
            target = this._tokens[lineIndex];
        }
        else {
            target = new ModelLineTokens(null);
            this._tokens[lineIndex] = target;
        }
        if (lineTextLength === 0) {
            target._lineTokens = EMPTY_LINE_TOKENS;
            return;
        }
        if (!tokens || tokens.length === 0) {
            tokens = new Uint32Array(2);
            tokens[0] = 0;
            tokens[1] = getDefaultMetadata(topLevelLanguageId);
        }
        LineTokens.convertToEndOffset(tokens, lineTextLength);
        target._lineTokens = tokens.buffer;
    };
    ModelLinesTokens.prototype._setState = function (lineIndex, state) {
        if (lineIndex < this._tokens.length && this._tokens[lineIndex]) {
            this._tokens[lineIndex]._state = state;
        }
        else {
            var tmp = new ModelLineTokens(state);
            this._tokens[lineIndex] = tmp;
        }
    };
    //#region Editing
    ModelLinesTokens.prototype.applyEdits = function (range$$1, eolCount, firstLineLength) {
        var deletingLinesCnt = range$$1.endLineNumber - range$$1.startLineNumber;
        var insertingLinesCnt = eolCount;
        var editingLinesCnt = Math.min(deletingLinesCnt, insertingLinesCnt);
        for (var j = editingLinesCnt; j >= 0; j--) {
            this.invalidateLine(range$$1.startLineNumber + j - 1);
        }
        this._acceptDeleteRange(range$$1);
        this._acceptInsertText(new Position(range$$1.startLineNumber, range$$1.startColumn), eolCount, firstLineLength);
    };
    ModelLinesTokens.prototype._acceptDeleteRange = function (range$$1) {
        var firstLineIndex = range$$1.startLineNumber - 1;
        if (firstLineIndex >= this._tokens.length) {
            return;
        }
        if (range$$1.startLineNumber === range$$1.endLineNumber) {
            if (range$$1.startColumn === range$$1.endColumn) {
                // Nothing to delete
                return;
            }
            this._tokens[firstLineIndex].delete(range$$1.startColumn - 1, range$$1.endColumn - 1);
            return;
        }
        var firstLine = this._tokens[firstLineIndex];
        firstLine.deleteEnding(range$$1.startColumn - 1);
        var lastLineIndex = range$$1.endLineNumber - 1;
        var lastLineTokens = null;
        if (lastLineIndex < this._tokens.length) {
            var lastLine = this._tokens[lastLineIndex];
            lastLine.deleteBeginning(range$$1.endColumn - 1);
            lastLineTokens = lastLine._lineTokens;
        }
        // Take remaining text on last line and append it to remaining text on first line
        firstLine.append(lastLineTokens);
        // Delete middle lines
        this._tokens.splice(range$$1.startLineNumber, range$$1.endLineNumber - range$$1.startLineNumber);
    };
    ModelLinesTokens.prototype._acceptInsertText = function (position, eolCount, firstLineLength) {
        if (eolCount === 0 && firstLineLength === 0) {
            // Nothing to insert
            return;
        }
        var lineIndex = position.lineNumber - 1;
        if (lineIndex >= this._tokens.length) {
            return;
        }
        if (eolCount === 0) {
            // Inserting text on one line
            this._tokens[lineIndex].insert(position.column - 1, firstLineLength);
            return;
        }
        var line = this._tokens[lineIndex];
        line.deleteEnding(position.column - 1);
        line.insert(position.column - 1, firstLineLength);
        var insert$$1 = new Array(eolCount);
        for (var i = eolCount - 1; i >= 0; i--) {
            insert$$1[i] = new ModelLineTokens(null);
        }
        this._tokens = arrayInsert(this._tokens, position.lineNumber, insert$$1);
    };
    //#endregion
    //#region Tokenization
    ModelLinesTokens.prototype._tokenizeOneLine = function (buffer, eventBuilder) {
        if (!this.hasLinesToTokenize(buffer)) {
            return buffer.getLineCount() + 1;
        }
        var lineNumber = this._invalidLineStartIndex + 1;
        this._updateTokensUntilLine(buffer, eventBuilder, lineNumber);
        return lineNumber;
    };
    ModelLinesTokens.prototype._tokenizeText = function (buffer, text, state) {
        var r = null;
        try {
            r = this.tokenizationSupport.tokenize2(text, state, 0);
        }
        catch (e) {
            onUnexpectedError(e);
        }
        if (!r) {
            r = nullTokenize2(this.languageIdentifier.id, text, state, 0);
        }
        return r;
    };
    ModelLinesTokens.prototype._updateTokensUntilLine = function (buffer, eventBuilder, lineNumber) {
        if (!this.tokenizationSupport) {
            this._invalidLineStartIndex = buffer.getLineCount();
            return;
        }
        var linesLength = buffer.getLineCount();
        var endLineIndex = lineNumber - 1;
        // Validate all states up to and including endLineIndex
        for (var lineIndex = this._invalidLineStartIndex; lineIndex <= endLineIndex; lineIndex++) {
            var endStateIndex = lineIndex + 1;
            var r = null;
            var text = buffer.getLineContent(lineIndex + 1);
            try {
                // Tokenize only the first X characters
                var freshState = this._getState(lineIndex).clone();
                r = this.tokenizationSupport.tokenize2(text, freshState, 0);
            }
            catch (e) {
                onUnexpectedError(e);
            }
            if (!r) {
                r = nullTokenize2(this.languageIdentifier.id, text, this._getState(lineIndex), 0);
            }
            this._setTokens(this.languageIdentifier.id, lineIndex, text.length, r.tokens);
            eventBuilder.registerChangedTokens(lineIndex + 1);
            this._setIsInvalid(lineIndex, false);
            if (endStateIndex < linesLength) {
                if (this._getState(endStateIndex) !== null && r.endState.equals(this._getState(endStateIndex))) {
                    // The end state of this line remains the same
                    var nextInvalidLineIndex = lineIndex + 1;
                    while (nextInvalidLineIndex < linesLength) {
                        if (this._isInvalid(nextInvalidLineIndex)) {
                            break;
                        }
                        if (nextInvalidLineIndex + 1 < linesLength) {
                            if (this._getState(nextInvalidLineIndex + 1) === null) {
                                break;
                            }
                        }
                        else {
                            if (this._lastState === null) {
                                break;
                            }
                        }
                        nextInvalidLineIndex++;
                    }
                    this._invalidLineStartIndex = Math.max(this._invalidLineStartIndex, nextInvalidLineIndex);
                    lineIndex = nextInvalidLineIndex - 1; // -1 because the outer loop increments it
                }
                else {
                    this._setState(endStateIndex, r.endState);
                }
            }
            else {
                this._lastState = r.endState;
            }
        }
        this._invalidLineStartIndex = Math.max(this._invalidLineStartIndex, endLineIndex + 1);
    };
    return ModelLinesTokens;
}());
var ModelTokensChangedEventBuilder = /** @class */ (function () {
    function ModelTokensChangedEventBuilder() {
        this._ranges = [];
    }
    ModelTokensChangedEventBuilder.prototype.registerChangedTokens = function (lineNumber) {
        var ranges = this._ranges;
        var rangesLength = ranges.length;
        var previousRange = rangesLength > 0 ? ranges[rangesLength - 1] : null;
        if (previousRange && previousRange.toLineNumber === lineNumber - 1) {
            // extend previous range
            previousRange.toLineNumber++;
        }
        else {
            // insert new range
            ranges[rangesLength] = {
                fromLineNumber: lineNumber,
                toLineNumber: lineNumber
            };
        }
    };
    ModelTokensChangedEventBuilder.prototype.build = function () {
        if (this._ranges.length === 0) {
            return null;
        }
        return {
            ranges: this._ranges
        };
    };
    return ModelTokensChangedEventBuilder;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
/**
 * Compute the diff in spaces between two line's indentation.
 */
function spacesDiff(a, aLength, b, bLength) {
    // This can go both ways (e.g.):
    //  - a: "\t"
    //  - b: "\t    "
    //  => This should count 1 tab and 4 spaces
    var i;
    for (i = 0; i < aLength && i < bLength; i++) {
        var aCharCode = a.charCodeAt(i);
        var bCharCode = b.charCodeAt(i);
        if (aCharCode !== bCharCode) {
            break;
        }
    }
    var aSpacesCnt = 0, aTabsCount = 0;
    for (var j = i; j < aLength; j++) {
        var aCharCode = a.charCodeAt(j);
        if (aCharCode === 32 /* Space */) {
            aSpacesCnt++;
        }
        else {
            aTabsCount++;
        }
    }
    var bSpacesCnt = 0, bTabsCount = 0;
    for (var j = i; j < bLength; j++) {
        var bCharCode = b.charCodeAt(j);
        if (bCharCode === 32 /* Space */) {
            bSpacesCnt++;
        }
        else {
            bTabsCount++;
        }
    }
    if (aSpacesCnt > 0 && aTabsCount > 0) {
        return 0;
    }
    if (bSpacesCnt > 0 && bTabsCount > 0) {
        return 0;
    }
    var tabsDiff = Math.abs(aTabsCount - bTabsCount);
    var spacesDiff = Math.abs(aSpacesCnt - bSpacesCnt);
    if (tabsDiff === 0) {
        return spacesDiff;
    }
    if (spacesDiff % tabsDiff === 0) {
        return spacesDiff / tabsDiff;
    }
    return 0;
}
function guessIndentation(source, defaultTabSize, defaultInsertSpaces) {
    // Look at most at the first 10k lines
    var linesCount = Math.min(source.getLineCount(), 10000);
    var linesIndentedWithTabsCount = 0; // number of lines that contain at least one tab in indentation
    var linesIndentedWithSpacesCount = 0; // number of lines that contain only spaces in indentation
    var previousLineText = ''; // content of latest line that contained non-whitespace chars
    var previousLineIndentation = 0; // index at which latest line contained the first non-whitespace char
    var ALLOWED_TAB_SIZE_GUESSES = [2, 4, 6, 8]; // limit guesses for `tabSize` to 2, 4, 6 or 8.
    var MAX_ALLOWED_TAB_SIZE_GUESS = 8; // max(2,4,6,8) = 8
    var spacesDiffCount = [0, 0, 0, 0, 0, 0, 0, 0, 0]; // `tabSize` scores
    var _loop_1 = function (lineNumber) {
        var currentLineLength = source.getLineLength(lineNumber);
        var currentLineText = source.getLineContent(lineNumber);
        var charCodeAt = void 0;
        if (currentLineLength > 65536) {
            // if the text buffer is chunk based, so long lines are cons-string, v8 will flattern the string when we check charCode.
            // checking charCode on chunks directly is cheaper.
            charCodeAt = function (offset) { return source.getLineCharCode(lineNumber, offset); };
        }
        else {
            charCodeAt = function (offset) { return currentLineText.charCodeAt(offset); };
        }
        var currentLineHasContent = false; // does `currentLineText` contain non-whitespace chars
        var currentLineIndentation = 0; // index at which `currentLineText` contains the first non-whitespace char
        var currentLineSpacesCount = 0; // count of spaces found in `currentLineText` indentation
        var currentLineTabsCount = 0; // count of tabs found in `currentLineText` indentation
        for (var j = 0, lenJ = currentLineLength; j < lenJ; j++) {
            var charCode = charCodeAt(j);
            if (charCode === 9 /* Tab */) {
                currentLineTabsCount++;
            }
            else if (charCode === 32 /* Space */) {
                currentLineSpacesCount++;
            }
            else {
                // Hit non whitespace character on this line
                currentLineHasContent = true;
                currentLineIndentation = j;
                break;
            }
        }
        // Ignore empty or only whitespace lines
        if (!currentLineHasContent) {
            return "continue";
        }
        if (currentLineTabsCount > 0) {
            linesIndentedWithTabsCount++;
        }
        else if (currentLineSpacesCount > 1) {
            linesIndentedWithSpacesCount++;
        }
        var currentSpacesDiff = spacesDiff(previousLineText, previousLineIndentation, currentLineText, currentLineIndentation);
        if (currentSpacesDiff <= MAX_ALLOWED_TAB_SIZE_GUESS) {
            spacesDiffCount[currentSpacesDiff]++;
        }
        previousLineText = currentLineText;
        previousLineIndentation = currentLineIndentation;
    };
    for (var lineNumber = 1; lineNumber <= linesCount; lineNumber++) {
        _loop_1(lineNumber);
    }
    // Take into account the last line as well
    var deltaSpacesCount = spacesDiff(previousLineText, previousLineIndentation, '', 0);
    if (deltaSpacesCount <= MAX_ALLOWED_TAB_SIZE_GUESS) {
        spacesDiffCount[deltaSpacesCount]++;
    }
    var insertSpaces = defaultInsertSpaces;
    if (linesIndentedWithTabsCount !== linesIndentedWithSpacesCount) {
        insertSpaces = (linesIndentedWithTabsCount < linesIndentedWithSpacesCount);
    }
    var tabSize = defaultTabSize;
    var tabSizeScore = (insertSpaces ? 0 : 0.1 * linesCount);
    // console.log("score threshold: " + tabSizeScore);
    ALLOWED_TAB_SIZE_GUESSES.forEach(function (possibleTabSize) {
        var possibleTabSizeScore = spacesDiffCount[possibleTabSize];
        if (possibleTabSizeScore > tabSizeScore) {
            tabSizeScore = possibleTabSizeScore;
            tabSize = possibleTabSize;
        }
    });
    // console.log('--------------------------');
    // console.log('linesIndentedWithTabsCount: ' + linesIndentedWithTabsCount + ', linesIndentedWithSpacesCount: ' + linesIndentedWithSpacesCount);
    // console.log('spacesDiffCount: ' + spacesDiffCount);
    // console.log('tabSize: ' + tabSize + ', tabSizeScore: ' + tabSizeScore);
    return {
        insertSpaces: insertSpaces,
        tabSize: tabSize
    };
}

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$8 = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var ScrollbarVisibility;
(function (ScrollbarVisibility) {
    ScrollbarVisibility[ScrollbarVisibility["Auto"] = 1] = "Auto";
    ScrollbarVisibility[ScrollbarVisibility["Hidden"] = 2] = "Hidden";
    ScrollbarVisibility[ScrollbarVisibility["Visible"] = 3] = "Visible";
})(ScrollbarVisibility || (ScrollbarVisibility = {}));
var ScrollState = /** @class */ (function () {
    function ScrollState(width, scrollWidth, scrollLeft, height, scrollHeight, scrollTop) {
        width = width | 0;
        scrollWidth = scrollWidth | 0;
        scrollLeft = scrollLeft | 0;
        height = height | 0;
        scrollHeight = scrollHeight | 0;
        scrollTop = scrollTop | 0;
        if (width < 0) {
            width = 0;
        }
        if (scrollLeft + width > scrollWidth) {
            scrollLeft = scrollWidth - width;
        }
        if (scrollLeft < 0) {
            scrollLeft = 0;
        }
        if (height < 0) {
            height = 0;
        }
        if (scrollTop + height > scrollHeight) {
            scrollTop = scrollHeight - height;
        }
        if (scrollTop < 0) {
            scrollTop = 0;
        }
        this.width = width;
        this.scrollWidth = scrollWidth;
        this.scrollLeft = scrollLeft;
        this.height = height;
        this.scrollHeight = scrollHeight;
        this.scrollTop = scrollTop;
    }
    ScrollState.prototype.equals = function (other) {
        return (this.width === other.width
            && this.scrollWidth === other.scrollWidth
            && this.scrollLeft === other.scrollLeft
            && this.height === other.height
            && this.scrollHeight === other.scrollHeight
            && this.scrollTop === other.scrollTop);
    };
    ScrollState.prototype.withScrollDimensions = function (update) {
        return new ScrollState((typeof update.width !== 'undefined' ? update.width : this.width), (typeof update.scrollWidth !== 'undefined' ? update.scrollWidth : this.scrollWidth), this.scrollLeft, (typeof update.height !== 'undefined' ? update.height : this.height), (typeof update.scrollHeight !== 'undefined' ? update.scrollHeight : this.scrollHeight), this.scrollTop);
    };
    ScrollState.prototype.withScrollPosition = function (update) {
        return new ScrollState(this.width, this.scrollWidth, (typeof update.scrollLeft !== 'undefined' ? update.scrollLeft : this.scrollLeft), this.height, this.scrollHeight, (typeof update.scrollTop !== 'undefined' ? update.scrollTop : this.scrollTop));
    };
    ScrollState.prototype.createScrollEvent = function (previous) {
        var widthChanged = (this.width !== previous.width);
        var scrollWidthChanged = (this.scrollWidth !== previous.scrollWidth);
        var scrollLeftChanged = (this.scrollLeft !== previous.scrollLeft);
        var heightChanged = (this.height !== previous.height);
        var scrollHeightChanged = (this.scrollHeight !== previous.scrollHeight);
        var scrollTopChanged = (this.scrollTop !== previous.scrollTop);
        return {
            width: this.width,
            scrollWidth: this.scrollWidth,
            scrollLeft: this.scrollLeft,
            height: this.height,
            scrollHeight: this.scrollHeight,
            scrollTop: this.scrollTop,
            widthChanged: widthChanged,
            scrollWidthChanged: scrollWidthChanged,
            scrollLeftChanged: scrollLeftChanged,
            heightChanged: heightChanged,
            scrollHeightChanged: scrollHeightChanged,
            scrollTopChanged: scrollTopChanged,
        };
    };
    return ScrollState;
}());
var Scrollable = /** @class */ (function (_super) {
    __extends$8(Scrollable, _super);
    function Scrollable(smoothScrollDuration, scheduleAtNextAnimationFrame) {
        var _this = _super.call(this) || this;
        _this._onScroll = _this._register(new Emitter());
        _this.onScroll = _this._onScroll.event;
        _this._smoothScrollDuration = smoothScrollDuration;
        _this._scheduleAtNextAnimationFrame = scheduleAtNextAnimationFrame;
        _this._state = new ScrollState(0, 0, 0, 0, 0, 0);
        _this._smoothScrolling = null;
        return _this;
    }
    Scrollable.prototype.dispose = function () {
        if (this._smoothScrolling) {
            this._smoothScrolling.dispose();
            this._smoothScrolling = null;
        }
        _super.prototype.dispose.call(this);
    };
    Scrollable.prototype.setSmoothScrollDuration = function (smoothScrollDuration) {
        this._smoothScrollDuration = smoothScrollDuration;
    };
    Scrollable.prototype.validateScrollPosition = function (scrollPosition) {
        return this._state.withScrollPosition(scrollPosition);
    };
    Scrollable.prototype.getScrollDimensions = function () {
        return this._state;
    };
    Scrollable.prototype.setScrollDimensions = function (dimensions) {
        var newState = this._state.withScrollDimensions(dimensions);
        this._setState(newState);
        // Validate outstanding animated scroll position target
        if (this._smoothScrolling) {
            this._smoothScrolling.acceptScrollDimensions(this._state);
        }
    };
    /**
     * Returns the final scroll position that the instance will have once the smooth scroll animation concludes.
     * If no scroll animation is occuring, it will return the current scroll position instead.
     */
    Scrollable.prototype.getFutureScrollPosition = function () {
        if (this._smoothScrolling) {
            return this._smoothScrolling.to;
        }
        return this._state;
    };
    /**
     * Returns the current scroll position.
     * Note: This result might be an intermediate scroll position, as there might be an ongoing smooth scroll animation.
     */
    Scrollable.prototype.getCurrentScrollPosition = function () {
        return this._state;
    };
    Scrollable.prototype.setScrollPositionNow = function (update) {
        // no smooth scrolling requested
        var newState = this._state.withScrollPosition(update);
        // Terminate any outstanding smooth scrolling
        if (this._smoothScrolling) {
            this._smoothScrolling.dispose();
            this._smoothScrolling = null;
        }
        this._setState(newState);
    };
    Scrollable.prototype.setScrollPositionSmooth = function (update) {
        var _this = this;
        if (this._smoothScrollDuration === 0) {
            // Smooth scrolling not supported.
            return this.setScrollPositionNow(update);
        }
        if (this._smoothScrolling) {
            // Combine our pending scrollLeft/scrollTop with incoming scrollLeft/scrollTop
            update = {
                scrollLeft: (typeof update.scrollLeft === 'undefined' ? this._smoothScrolling.to.scrollLeft : update.scrollLeft),
                scrollTop: (typeof update.scrollTop === 'undefined' ? this._smoothScrolling.to.scrollTop : update.scrollTop)
            };
            // Validate `update`
            var validTarget = this._state.withScrollPosition(update);
            if (this._smoothScrolling.to.scrollLeft === validTarget.scrollLeft && this._smoothScrolling.to.scrollTop === validTarget.scrollTop) {
                // No need to interrupt or extend the current animation since we're going to the same place
                return;
            }
            var newSmoothScrolling = this._smoothScrolling.combine(this._state, validTarget, this._smoothScrollDuration);
            this._smoothScrolling.dispose();
            this._smoothScrolling = newSmoothScrolling;
        }
        else {
            // Validate `update`
            var validTarget = this._state.withScrollPosition(update);
            this._smoothScrolling = SmoothScrollingOperation.start(this._state, validTarget, this._smoothScrollDuration);
        }
        // Begin smooth scrolling animation
        this._smoothScrolling.animationFrameDisposable = this._scheduleAtNextAnimationFrame(function () {
            if (!_this._smoothScrolling) {
                return;
            }
            _this._smoothScrolling.animationFrameDisposable = null;
            _this._performSmoothScrolling();
        });
    };
    Scrollable.prototype._performSmoothScrolling = function () {
        var _this = this;
        var update = this._smoothScrolling.tick();
        var newState = this._state.withScrollPosition(update);
        this._setState(newState);
        if (update.isDone) {
            this._smoothScrolling.dispose();
            this._smoothScrolling = null;
            return;
        }
        // Continue smooth scrolling animation
        this._smoothScrolling.animationFrameDisposable = this._scheduleAtNextAnimationFrame(function () {
            if (!_this._smoothScrolling) {
                return;
            }
            _this._smoothScrolling.animationFrameDisposable = null;
            _this._performSmoothScrolling();
        });
    };
    Scrollable.prototype._setState = function (newState) {
        var oldState = this._state;
        if (oldState.equals(newState)) {
            // no change
            return;
        }
        this._state = newState;
        this._onScroll.fire(this._state.createScrollEvent(oldState));
    };
    return Scrollable;
}(Disposable));
var SmoothScrollingUpdate = /** @class */ (function () {
    function SmoothScrollingUpdate(scrollLeft, scrollTop, isDone) {
        this.scrollLeft = scrollLeft;
        this.scrollTop = scrollTop;
        this.isDone = isDone;
    }
    return SmoothScrollingUpdate;
}());
function createEaseOutCubic(from, to) {
    var delta = to - from;
    return function (completion) {
        return from + delta * easeOutCubic(completion);
    };
}
function createComposed(a, b, cut) {
    return function (completion) {
        if (completion < cut) {
            return a(completion / cut);
        }
        return b((completion - cut) / (1 - cut));
    };
}
var SmoothScrollingOperation = /** @class */ (function () {
    function SmoothScrollingOperation(from, to, startTime, duration) {
        this.from = from;
        this.to = to;
        this.duration = duration;
        this._startTime = startTime;
        this.animationFrameDisposable = null;
        this._initAnimations();
    }
    SmoothScrollingOperation.prototype._initAnimations = function () {
        this.scrollLeft = this._initAnimation(this.from.scrollLeft, this.to.scrollLeft, this.to.width);
        this.scrollTop = this._initAnimation(this.from.scrollTop, this.to.scrollTop, this.to.height);
    };
    SmoothScrollingOperation.prototype._initAnimation = function (from, to, viewportSize) {
        var delta = Math.abs(from - to);
        if (delta > 2.5 * viewportSize) {
            var stop1 = void 0, stop2 = void 0;
            if (from < to) {
                // scroll to 75% of the viewportSize
                stop1 = from + 0.75 * viewportSize;
                stop2 = to - 0.75 * viewportSize;
            }
            else {
                stop1 = from - 0.75 * viewportSize;
                stop2 = to + 0.75 * viewportSize;
            }
            return createComposed(createEaseOutCubic(from, stop1), createEaseOutCubic(stop2, to), 0.33);
        }
        return createEaseOutCubic(from, to);
    };
    SmoothScrollingOperation.prototype.dispose = function () {
        if (this.animationFrameDisposable !== null) {
            this.animationFrameDisposable.dispose();
            this.animationFrameDisposable = null;
        }
    };
    SmoothScrollingOperation.prototype.acceptScrollDimensions = function (state) {
        this.to = state.withScrollPosition(this.to);
        this._initAnimations();
    };
    SmoothScrollingOperation.prototype.tick = function () {
        return this._tick(Date.now());
    };
    SmoothScrollingOperation.prototype._tick = function (now) {
        var completion = (now - this._startTime) / this.duration;
        if (completion < 1) {
            var newScrollLeft = this.scrollLeft(completion);
            var newScrollTop = this.scrollTop(completion);
            return new SmoothScrollingUpdate(newScrollLeft, newScrollTop, false);
        }
        return new SmoothScrollingUpdate(this.to.scrollLeft, this.to.scrollTop, true);
    };
    SmoothScrollingOperation.prototype.combine = function (from, to, duration) {
        return SmoothScrollingOperation.start(from, to, duration);
    };
    SmoothScrollingOperation.start = function (from, to, duration) {
        // +10 / -10 : pretend the animation already started for a quicker response to a scroll request
        duration = duration + 10;
        var startTime = Date.now() - 10;
        return new SmoothScrollingOperation(from, to, startTime, duration);
    };
    return SmoothScrollingOperation;
}());
function easeInCubic(t) {
    return Math.pow(t, 3);
}
function easeOutCubic(t) {
    return 1 - easeInCubic(1 - t);
}

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __assign = (undefined && undefined.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
var RenderMinimap;
(function (RenderMinimap) {
    RenderMinimap[RenderMinimap["None"] = 0] = "None";
    RenderMinimap[RenderMinimap["Small"] = 1] = "Small";
    RenderMinimap[RenderMinimap["Large"] = 2] = "Large";
    RenderMinimap[RenderMinimap["SmallBlocks"] = 3] = "SmallBlocks";
    RenderMinimap[RenderMinimap["LargeBlocks"] = 4] = "LargeBlocks";
})(RenderMinimap || (RenderMinimap = {}));
/**
 * Describes how to indent wrapped lines.
 */
var WrappingIndent;
(function (WrappingIndent) {
    /**
     * No indentation => wrapped lines begin at column 1.
     */
    WrappingIndent[WrappingIndent["None"] = 0] = "None";
    /**
     * Same => wrapped lines get the same indentation as the parent.
     */
    WrappingIndent[WrappingIndent["Same"] = 1] = "Same";
    /**
     * Indent => wrapped lines get +1 indentation as the parent.
     */
    WrappingIndent[WrappingIndent["Indent"] = 2] = "Indent";
})(WrappingIndent || (WrappingIndent = {}));
/**
 * The kind of animation in which the editor's cursor should be rendered.
 */
var TextEditorCursorBlinkingStyle;
(function (TextEditorCursorBlinkingStyle) {
    /**
     * Hidden
     */
    TextEditorCursorBlinkingStyle[TextEditorCursorBlinkingStyle["Hidden"] = 0] = "Hidden";
    /**
     * Blinking
     */
    TextEditorCursorBlinkingStyle[TextEditorCursorBlinkingStyle["Blink"] = 1] = "Blink";
    /**
     * Blinking with smooth fading
     */
    TextEditorCursorBlinkingStyle[TextEditorCursorBlinkingStyle["Smooth"] = 2] = "Smooth";
    /**
     * Blinking with prolonged filled state and smooth fading
     */
    TextEditorCursorBlinkingStyle[TextEditorCursorBlinkingStyle["Phase"] = 3] = "Phase";
    /**
     * Expand collapse animation on the y axis
     */
    TextEditorCursorBlinkingStyle[TextEditorCursorBlinkingStyle["Expand"] = 4] = "Expand";
    /**
     * No-Blinking
     */
    TextEditorCursorBlinkingStyle[TextEditorCursorBlinkingStyle["Solid"] = 5] = "Solid";
})(TextEditorCursorBlinkingStyle || (TextEditorCursorBlinkingStyle = {}));
/**
 * @internal
 */
function blinkingStyleToString(blinkingStyle) {
    if (blinkingStyle === TextEditorCursorBlinkingStyle.Blink) {
        return 'blink';
    }
    else if (blinkingStyle === TextEditorCursorBlinkingStyle.Expand) {
        return 'expand';
    }
    else if (blinkingStyle === TextEditorCursorBlinkingStyle.Phase) {
        return 'phase';
    }
    else if (blinkingStyle === TextEditorCursorBlinkingStyle.Smooth) {
        return 'smooth';
    }
    else if (blinkingStyle === TextEditorCursorBlinkingStyle.Solid) {
        return 'solid';
    }
    else {
        throw new Error('blinkingStyleToString: Unknown blinkingStyle');
    }
}
/**
 * The style in which the editor's cursor should be rendered.
 */
var TextEditorCursorStyle;
(function (TextEditorCursorStyle) {
    /**
     * As a vertical line (sitting between two characters).
     */
    TextEditorCursorStyle[TextEditorCursorStyle["Line"] = 1] = "Line";
    /**
     * As a block (sitting on top of a character).
     */
    TextEditorCursorStyle[TextEditorCursorStyle["Block"] = 2] = "Block";
    /**
     * As a horizontal line (sitting under a character).
     */
    TextEditorCursorStyle[TextEditorCursorStyle["Underline"] = 3] = "Underline";
    /**
     * As a thin vertical line (sitting between two characters).
     */
    TextEditorCursorStyle[TextEditorCursorStyle["LineThin"] = 4] = "LineThin";
    /**
     * As an outlined block (sitting on top of a character).
     */
    TextEditorCursorStyle[TextEditorCursorStyle["BlockOutline"] = 5] = "BlockOutline";
    /**
     * As a thin horizontal line (sitting under a character).
     */
    TextEditorCursorStyle[TextEditorCursorStyle["UnderlineThin"] = 6] = "UnderlineThin";
})(TextEditorCursorStyle || (TextEditorCursorStyle = {}));
/**
 * @internal
 */
function cursorStyleToString(cursorStyle) {
    if (cursorStyle === TextEditorCursorStyle.Line) {
        return 'line';
    }
    else if (cursorStyle === TextEditorCursorStyle.Block) {
        return 'block';
    }
    else if (cursorStyle === TextEditorCursorStyle.Underline) {
        return 'underline';
    }
    else if (cursorStyle === TextEditorCursorStyle.LineThin) {
        return 'line-thin';
    }
    else if (cursorStyle === TextEditorCursorStyle.BlockOutline) {
        return 'block-outline';
    }
    else if (cursorStyle === TextEditorCursorStyle.UnderlineThin) {
        return 'underline-thin';
    }
    else {
        throw new Error('cursorStyleToString: Unknown cursorStyle');
    }
}
function _cursorStyleFromString(cursorStyle, defaultValue) {
    if (typeof cursorStyle !== 'string') {
        return defaultValue;
    }
    if (cursorStyle === 'line') {
        return TextEditorCursorStyle.Line;
    }
    else if (cursorStyle === 'block') {
        return TextEditorCursorStyle.Block;
    }
    else if (cursorStyle === 'underline') {
        return TextEditorCursorStyle.Underline;
    }
    else if (cursorStyle === 'line-thin') {
        return TextEditorCursorStyle.LineThin;
    }
    else if (cursorStyle === 'block-outline') {
        return TextEditorCursorStyle.BlockOutline;
    }
    else if (cursorStyle === 'underline-thin') {
        return TextEditorCursorStyle.UnderlineThin;
    }
    return TextEditorCursorStyle.Line;
}
/**
 * Internal configuration options (transformed or computed) for the editor.
 */
var InternalEditorOptions = /** @class */ (function () {
    /**
     * @internal
     */
    function InternalEditorOptions(source) {
        this.canUseLayerHinting = source.canUseLayerHinting;
        this.pixelRatio = source.pixelRatio;
        this.editorClassName = source.editorClassName;
        this.lineHeight = source.lineHeight | 0;
        this.readOnly = source.readOnly;
        this.accessibilitySupport = source.accessibilitySupport;
        this.multiCursorModifier = source.multiCursorModifier;
        this.multiCursorMergeOverlapping = source.multiCursorMergeOverlapping;
        this.wordSeparators = source.wordSeparators;
        this.autoClosingBrackets = source.autoClosingBrackets;
        this.autoIndent = source.autoIndent;
        this.useTabStops = source.useTabStops;
        this.tabFocusMode = source.tabFocusMode;
        this.dragAndDrop = source.dragAndDrop;
        this.emptySelectionClipboard = source.emptySelectionClipboard;
        this.layoutInfo = source.layoutInfo;
        this.fontInfo = source.fontInfo;
        this.viewInfo = source.viewInfo;
        this.wrappingInfo = source.wrappingInfo;
        this.contribInfo = source.contribInfo;
    }
    /**
     * @internal
     */
    InternalEditorOptions.prototype.equals = function (other) {
        return (this.canUseLayerHinting === other.canUseLayerHinting
            && this.pixelRatio === other.pixelRatio
            && this.editorClassName === other.editorClassName
            && this.lineHeight === other.lineHeight
            && this.readOnly === other.readOnly
            && this.accessibilitySupport === other.accessibilitySupport
            && this.multiCursorModifier === other.multiCursorModifier
            && this.multiCursorMergeOverlapping === other.multiCursorMergeOverlapping
            && this.wordSeparators === other.wordSeparators
            && this.autoClosingBrackets === other.autoClosingBrackets
            && this.autoIndent === other.autoIndent
            && this.useTabStops === other.useTabStops
            && this.tabFocusMode === other.tabFocusMode
            && this.dragAndDrop === other.dragAndDrop
            && this.emptySelectionClipboard === other.emptySelectionClipboard
            && InternalEditorOptions._equalsLayoutInfo(this.layoutInfo, other.layoutInfo)
            && this.fontInfo.equals(other.fontInfo)
            && InternalEditorOptions._equalsViewOptions(this.viewInfo, other.viewInfo)
            && InternalEditorOptions._equalsWrappingInfo(this.wrappingInfo, other.wrappingInfo)
            && InternalEditorOptions._equalsContribOptions(this.contribInfo, other.contribInfo));
    };
    /**
     * @internal
     */
    InternalEditorOptions.prototype.createChangeEvent = function (newOpts) {
        return {
            canUseLayerHinting: (this.canUseLayerHinting !== newOpts.canUseLayerHinting),
            pixelRatio: (this.pixelRatio !== newOpts.pixelRatio),
            editorClassName: (this.editorClassName !== newOpts.editorClassName),
            lineHeight: (this.lineHeight !== newOpts.lineHeight),
            readOnly: (this.readOnly !== newOpts.readOnly),
            accessibilitySupport: (this.accessibilitySupport !== newOpts.accessibilitySupport),
            multiCursorModifier: (this.multiCursorModifier !== newOpts.multiCursorModifier),
            multiCursorMergeOverlapping: (this.multiCursorMergeOverlapping !== newOpts.multiCursorMergeOverlapping),
            wordSeparators: (this.wordSeparators !== newOpts.wordSeparators),
            autoClosingBrackets: (this.autoClosingBrackets !== newOpts.autoClosingBrackets),
            autoIndent: (this.autoIndent !== newOpts.autoIndent),
            useTabStops: (this.useTabStops !== newOpts.useTabStops),
            tabFocusMode: (this.tabFocusMode !== newOpts.tabFocusMode),
            dragAndDrop: (this.dragAndDrop !== newOpts.dragAndDrop),
            emptySelectionClipboard: (this.emptySelectionClipboard !== newOpts.emptySelectionClipboard),
            layoutInfo: (!InternalEditorOptions._equalsLayoutInfo(this.layoutInfo, newOpts.layoutInfo)),
            fontInfo: (!this.fontInfo.equals(newOpts.fontInfo)),
            viewInfo: (!InternalEditorOptions._equalsViewOptions(this.viewInfo, newOpts.viewInfo)),
            wrappingInfo: (!InternalEditorOptions._equalsWrappingInfo(this.wrappingInfo, newOpts.wrappingInfo)),
            contribInfo: (!InternalEditorOptions._equalsContribOptions(this.contribInfo, newOpts.contribInfo))
        };
    };
    /**
     * @internal
     */
    InternalEditorOptions._equalsLayoutInfo = function (a, b) {
        return (a.width === b.width
            && a.height === b.height
            && a.glyphMarginLeft === b.glyphMarginLeft
            && a.glyphMarginWidth === b.glyphMarginWidth
            && a.glyphMarginHeight === b.glyphMarginHeight
            && a.lineNumbersLeft === b.lineNumbersLeft
            && a.lineNumbersWidth === b.lineNumbersWidth
            && a.lineNumbersHeight === b.lineNumbersHeight
            && a.decorationsLeft === b.decorationsLeft
            && a.decorationsWidth === b.decorationsWidth
            && a.decorationsHeight === b.decorationsHeight
            && a.contentLeft === b.contentLeft
            && a.contentWidth === b.contentWidth
            && a.contentHeight === b.contentHeight
            && a.renderMinimap === b.renderMinimap
            && a.minimapLeft === b.minimapLeft
            && a.minimapWidth === b.minimapWidth
            && a.viewportColumn === b.viewportColumn
            && a.verticalScrollbarWidth === b.verticalScrollbarWidth
            && a.horizontalScrollbarHeight === b.horizontalScrollbarHeight
            && this._equalsOverviewRuler(a.overviewRuler, b.overviewRuler));
    };
    /**
     * @internal
     */
    InternalEditorOptions._equalsOverviewRuler = function (a, b) {
        return (a.width === b.width
            && a.height === b.height
            && a.top === b.top
            && a.right === b.right);
    };
    /**
     * @internal
     */
    InternalEditorOptions._equalsViewOptions = function (a, b) {
        return (a.extraEditorClassName === b.extraEditorClassName
            && a.disableMonospaceOptimizations === b.disableMonospaceOptimizations
            && equals(a.rulers, b.rulers)
            && a.ariaLabel === b.ariaLabel
            && a.renderLineNumbers === b.renderLineNumbers
            && a.renderCustomLineNumbers === b.renderCustomLineNumbers
            && a.selectOnLineNumbers === b.selectOnLineNumbers
            && a.glyphMargin === b.glyphMargin
            && a.revealHorizontalRightPadding === b.revealHorizontalRightPadding
            && a.roundedSelection === b.roundedSelection
            && a.overviewRulerLanes === b.overviewRulerLanes
            && a.overviewRulerBorder === b.overviewRulerBorder
            && a.cursorBlinking === b.cursorBlinking
            && a.mouseWheelZoom === b.mouseWheelZoom
            && a.cursorStyle === b.cursorStyle
            && a.cursorWidth === b.cursorWidth
            && a.hideCursorInOverviewRuler === b.hideCursorInOverviewRuler
            && a.scrollBeyondLastLine === b.scrollBeyondLastLine
            && a.smoothScrolling === b.smoothScrolling
            && a.stopRenderingLineAfter === b.stopRenderingLineAfter
            && a.renderWhitespace === b.renderWhitespace
            && a.renderControlCharacters === b.renderControlCharacters
            && a.fontLigatures === b.fontLigatures
            && a.renderIndentGuides === b.renderIndentGuides
            && a.renderLineHighlight === b.renderLineHighlight
            && this._equalsScrollbarOptions(a.scrollbar, b.scrollbar)
            && this._equalsMinimapOptions(a.minimap, b.minimap)
            && a.fixedOverflowWidgets === b.fixedOverflowWidgets);
    };
    /**
     * @internal
     */
    InternalEditorOptions._equalsScrollbarOptions = function (a, b) {
        return (a.arrowSize === b.arrowSize
            && a.vertical === b.vertical
            && a.horizontal === b.horizontal
            && a.useShadows === b.useShadows
            && a.verticalHasArrows === b.verticalHasArrows
            && a.horizontalHasArrows === b.horizontalHasArrows
            && a.handleMouseWheel === b.handleMouseWheel
            && a.horizontalScrollbarSize === b.horizontalScrollbarSize
            && a.horizontalSliderSize === b.horizontalSliderSize
            && a.verticalScrollbarSize === b.verticalScrollbarSize
            && a.verticalSliderSize === b.verticalSliderSize
            && a.mouseWheelScrollSensitivity === b.mouseWheelScrollSensitivity);
    };
    /**
     * @internal
     */
    InternalEditorOptions._equalsMinimapOptions = function (a, b) {
        return (a.enabled === b.enabled
            && a.side === b.side
            && a.showSlider === b.showSlider
            && a.renderCharacters === b.renderCharacters
            && a.maxColumn === b.maxColumn);
    };
    /**
     * @internal
     */
    InternalEditorOptions._equalFindOptions = function (a, b) {
        return (a.seedSearchStringFromSelection === b.seedSearchStringFromSelection
            && a.autoFindInSelection === b.autoFindInSelection
            && a.globalFindClipboard === b.globalFindClipboard);
    };
    /**
     * @internal
     */
    InternalEditorOptions._equalsWrappingInfo = function (a, b) {
        return (a.inDiffEditor === b.inDiffEditor
            && a.isDominatedByLongLines === b.isDominatedByLongLines
            && a.isWordWrapMinified === b.isWordWrapMinified
            && a.isViewportWrapping === b.isViewportWrapping
            && a.wrappingColumn === b.wrappingColumn
            && a.wrappingIndent === b.wrappingIndent
            && a.wordWrapBreakBeforeCharacters === b.wordWrapBreakBeforeCharacters
            && a.wordWrapBreakAfterCharacters === b.wordWrapBreakAfterCharacters
            && a.wordWrapBreakObtrusiveCharacters === b.wordWrapBreakObtrusiveCharacters);
    };
    /**
     * @internal
     */
    InternalEditorOptions._equalsContribOptions = function (a, b) {
        return (a.selectionClipboard === b.selectionClipboard
            && a.hover === b.hover
            && a.links === b.links
            && a.contextmenu === b.contextmenu
            && InternalEditorOptions._equalsQuickSuggestions(a.quickSuggestions, b.quickSuggestions)
            && a.quickSuggestionsDelay === b.quickSuggestionsDelay
            && a.parameterHints === b.parameterHints
            && a.iconsInSuggestions === b.iconsInSuggestions
            && a.formatOnType === b.formatOnType
            && a.formatOnPaste === b.formatOnPaste
            && a.suggestOnTriggerCharacters === b.suggestOnTriggerCharacters
            && a.acceptSuggestionOnEnter === b.acceptSuggestionOnEnter
            && a.acceptSuggestionOnCommitCharacter === b.acceptSuggestionOnCommitCharacter
            && a.snippetSuggestions === b.snippetSuggestions
            && a.wordBasedSuggestions === b.wordBasedSuggestions
            && a.suggestSelection === b.suggestSelection
            && a.suggestFontSize === b.suggestFontSize
            && a.suggestLineHeight === b.suggestLineHeight
            && a.selectionHighlight === b.selectionHighlight
            && a.occurrencesHighlight === b.occurrencesHighlight
            && a.codeLens === b.codeLens
            && a.folding === b.folding
            && a.foldingStrategy === b.foldingStrategy
            && a.showFoldingControls === b.showFoldingControls
            && a.matchBrackets === b.matchBrackets
            && this._equalFindOptions(a.find, b.find)
            && a.colorDecorators === b.colorDecorators
            && equals$1(a.codeActionsOnSave, b.codeActionsOnSave)
            && a.codeActionsOnSaveTimeout === b.codeActionsOnSaveTimeout
            && a.lightbulbEnabled === b.lightbulbEnabled);
    };
    InternalEditorOptions._equalsQuickSuggestions = function (a, b) {
        if (typeof a === 'boolean') {
            if (typeof b !== 'boolean') {
                return false;
            }
            return a === b;
        }
        if (typeof b === 'boolean') {
            return false;
        }
        return (a.comments === b.comments
            && a.other === b.other
            && a.strings === b.strings);
    };
    return InternalEditorOptions;
}());
function _boolean(value, defaultValue) {
    if (typeof value === 'undefined') {
        return defaultValue;
    }
    if (value === 'false') {
        // treat the string 'false' as false
        return false;
    }
    return Boolean(value);
}
function _booleanMap(value, defaultValue) {
    if (!value) {
        return defaultValue;
    }
    var out = Object.create(null);
    for (var _i = 0, _a = Object.keys(value); _i < _a.length; _i++) {
        var k = _a[_i];
        var v = value[k];
        if (typeof v === 'boolean') {
            out[k] = v;
        }
    }
    return out;
}
function _string(value, defaultValue) {
    if (typeof value !== 'string') {
        return defaultValue;
    }
    return value;
}
function _stringSet(value, defaultValue, allowedValues) {
    if (typeof value !== 'string') {
        return defaultValue;
    }
    if (allowedValues.indexOf(value) === -1) {
        return defaultValue;
    }
    return value;
}
function _clampedInt(value, defaultValue, minimum, maximum) {
    var r;
    if (typeof value === 'undefined') {
        r = defaultValue;
    }
    else {
        r = parseInt(value, 10);
        if (isNaN(r)) {
            r = defaultValue;
        }
    }
    r = Math.max(minimum, r);
    r = Math.min(maximum, r);
    return r | 0;
}
function _float(value, defaultValue) {
    var r = parseFloat(value);
    if (isNaN(r)) {
        r = defaultValue;
    }
    return r;
}
function _wrappingIndentFromString(wrappingIndent, defaultValue) {
    if (typeof wrappingIndent !== 'string') {
        return defaultValue;
    }
    if (wrappingIndent === 'indent') {
        return WrappingIndent.Indent;
    }
    else if (wrappingIndent === 'same') {
        return WrappingIndent.Same;
    }
    else {
        return WrappingIndent.None;
    }
}
function _cursorBlinkingStyleFromString(cursorBlinkingStyle, defaultValue) {
    if (typeof cursorBlinkingStyle !== 'string') {
        return defaultValue;
    }
    switch (cursorBlinkingStyle) {
        case 'blink':
            return TextEditorCursorBlinkingStyle.Blink;
        case 'smooth':
            return TextEditorCursorBlinkingStyle.Smooth;
        case 'phase':
            return TextEditorCursorBlinkingStyle.Phase;
        case 'expand':
            return TextEditorCursorBlinkingStyle.Expand;
        case 'visible': // maintain compatibility
        case 'solid':
            return TextEditorCursorBlinkingStyle.Solid;
    }
    return TextEditorCursorBlinkingStyle.Blink;
}
function _scrollbarVisibilityFromString(visibility, defaultValue) {
    if (typeof visibility !== 'string') {
        return defaultValue;
    }
    switch (visibility) {
        case 'hidden':
            return ScrollbarVisibility.Hidden;
        case 'visible':
            return ScrollbarVisibility.Visible;
        default:
            return ScrollbarVisibility.Auto;
    }
}
/**
 * @internal
 */
var EditorOptionsValidator = /** @class */ (function () {
    function EditorOptionsValidator() {
    }
    /**
     * Validate raw editor options.
     * i.e. since they can be defined by the user, they might be invalid.
     */
    EditorOptionsValidator.validate = function (opts, defaults) {
        var wordWrap = opts.wordWrap;
        {
            // Compatibility with old true or false values
            if (wordWrap === true) {
                wordWrap = 'on';
            }
            else if (wordWrap === false) {
                wordWrap = 'off';
            }
            wordWrap = _stringSet(wordWrap, defaults.wordWrap, ['off', 'on', 'wordWrapColumn', 'bounded']);
        }
        var viewInfo = this._sanitizeViewInfo(opts, defaults.viewInfo);
        var contribInfo = this._sanitizeContribInfo(opts, defaults.contribInfo);
        var configuredMulticursorModifier;
        if (typeof opts.multiCursorModifier === 'string') {
            if (opts.multiCursorModifier === 'ctrlCmd') {
                configuredMulticursorModifier = isMacintosh ? 'metaKey' : 'ctrlKey';
            }
            else {
                configuredMulticursorModifier = 'altKey';
            }
        }
        var multiCursorModifier = _stringSet(configuredMulticursorModifier, defaults.multiCursorModifier, ['altKey', 'metaKey', 'ctrlKey']);
        return {
            inDiffEditor: _boolean(opts.inDiffEditor, defaults.inDiffEditor),
            wordSeparators: _string(opts.wordSeparators, defaults.wordSeparators),
            lineNumbersMinChars: _clampedInt(opts.lineNumbersMinChars, defaults.lineNumbersMinChars, 1, 10),
            lineDecorationsWidth: (typeof opts.lineDecorationsWidth === 'undefined' ? defaults.lineDecorationsWidth : opts.lineDecorationsWidth),
            readOnly: _boolean(opts.readOnly, defaults.readOnly),
            mouseStyle: _stringSet(opts.mouseStyle, defaults.mouseStyle, ['text', 'default', 'copy']),
            disableLayerHinting: _boolean(opts.disableLayerHinting, defaults.disableLayerHinting),
            automaticLayout: _boolean(opts.automaticLayout, defaults.automaticLayout),
            wordWrap: wordWrap,
            wordWrapColumn: _clampedInt(opts.wordWrapColumn, defaults.wordWrapColumn, 1, 1073741824 /* MAX_SAFE_SMALL_INTEGER */),
            wordWrapMinified: _boolean(opts.wordWrapMinified, defaults.wordWrapMinified),
            wrappingIndent: _wrappingIndentFromString(opts.wrappingIndent, defaults.wrappingIndent),
            wordWrapBreakBeforeCharacters: _string(opts.wordWrapBreakBeforeCharacters, defaults.wordWrapBreakBeforeCharacters),
            wordWrapBreakAfterCharacters: _string(opts.wordWrapBreakAfterCharacters, defaults.wordWrapBreakAfterCharacters),
            wordWrapBreakObtrusiveCharacters: _string(opts.wordWrapBreakObtrusiveCharacters, defaults.wordWrapBreakObtrusiveCharacters),
            autoClosingBrackets: _boolean(opts.autoClosingBrackets, defaults.autoClosingBrackets),
            autoIndent: _boolean(opts.autoIndent, defaults.autoIndent),
            dragAndDrop: _boolean(opts.dragAndDrop, defaults.dragAndDrop),
            emptySelectionClipboard: _boolean(opts.emptySelectionClipboard, defaults.emptySelectionClipboard),
            useTabStops: _boolean(opts.useTabStops, defaults.useTabStops),
            multiCursorModifier: multiCursorModifier,
            multiCursorMergeOverlapping: _boolean(opts.multiCursorMergeOverlapping, defaults.multiCursorMergeOverlapping),
            accessibilitySupport: _stringSet(opts.accessibilitySupport, defaults.accessibilitySupport, ['auto', 'on', 'off']),
            viewInfo: viewInfo,
            contribInfo: contribInfo,
        };
    };
    EditorOptionsValidator._sanitizeScrollbarOpts = function (opts, defaults, mouseWheelScrollSensitivity) {
        if (typeof opts !== 'object') {
            return defaults;
        }
        var horizontalScrollbarSize = _clampedInt(opts.horizontalScrollbarSize, defaults.horizontalScrollbarSize, 0, 1000);
        var verticalScrollbarSize = _clampedInt(opts.verticalScrollbarSize, defaults.verticalScrollbarSize, 0, 1000);
        return {
            vertical: _scrollbarVisibilityFromString(opts.vertical, defaults.vertical),
            horizontal: _scrollbarVisibilityFromString(opts.horizontal, defaults.horizontal),
            arrowSize: _clampedInt(opts.arrowSize, defaults.arrowSize, 0, 1000),
            useShadows: _boolean(opts.useShadows, defaults.useShadows),
            verticalHasArrows: _boolean(opts.verticalHasArrows, defaults.verticalHasArrows),
            horizontalHasArrows: _boolean(opts.horizontalHasArrows, defaults.horizontalHasArrows),
            horizontalScrollbarSize: horizontalScrollbarSize,
            horizontalSliderSize: _clampedInt(opts.horizontalSliderSize, horizontalScrollbarSize, 0, 1000),
            verticalScrollbarSize: verticalScrollbarSize,
            verticalSliderSize: _clampedInt(opts.verticalSliderSize, verticalScrollbarSize, 0, 1000),
            handleMouseWheel: _boolean(opts.handleMouseWheel, defaults.handleMouseWheel),
            mouseWheelScrollSensitivity: mouseWheelScrollSensitivity
        };
    };
    EditorOptionsValidator._sanitizeMinimapOpts = function (opts, defaults) {
        if (typeof opts !== 'object') {
            return defaults;
        }
        return {
            enabled: _boolean(opts.enabled, defaults.enabled),
            side: _stringSet(opts.side, defaults.side, ['right', 'left']),
            showSlider: _stringSet(opts.showSlider, defaults.showSlider, ['always', 'mouseover']),
            renderCharacters: _boolean(opts.renderCharacters, defaults.renderCharacters),
            maxColumn: _clampedInt(opts.maxColumn, defaults.maxColumn, 1, 10000),
        };
    };
    EditorOptionsValidator._santizeFindOpts = function (opts, defaults) {
        if (typeof opts !== 'object') {
            return defaults;
        }
        return {
            seedSearchStringFromSelection: _boolean(opts.seedSearchStringFromSelection, defaults.seedSearchStringFromSelection),
            autoFindInSelection: _boolean(opts.autoFindInSelection, defaults.autoFindInSelection),
            globalFindClipboard: _boolean(opts.globalFindClipboard, defaults.globalFindClipboard)
        };
    };
    EditorOptionsValidator._sanitizeViewInfo = function (opts, defaults) {
        var rulers = [];
        if (Array.isArray(opts.rulers)) {
            for (var i = 0, len = opts.rulers.length; i < len; i++) {
                rulers.push(_clampedInt(opts.rulers[i], 0, 0, 10000));
            }
            rulers.sort();
        }
        var renderLineNumbers = defaults.renderLineNumbers;
        var renderCustomLineNumbers = defaults.renderCustomLineNumbers;
        if (typeof opts.lineNumbers !== 'undefined') {
            var lineNumbers = opts.lineNumbers;
            // Compatibility with old true or false values
            if (lineNumbers === true) {
                lineNumbers = 'on';
            }
            else if (lineNumbers === false) {
                lineNumbers = 'off';
            }
            if (typeof lineNumbers === 'function') {
                renderLineNumbers = 4 /* Custom */;
                renderCustomLineNumbers = lineNumbers;
            }
            else if (lineNumbers === 'interval') {
                renderLineNumbers = 3 /* Interval */;
            }
            else if (lineNumbers === 'relative') {
                renderLineNumbers = 2 /* Relative */;
            }
            else if (lineNumbers === 'on') {
                renderLineNumbers = 1 /* On */;
            }
            else {
                renderLineNumbers = 0 /* Off */;
            }
        }
        var fontLigatures = _boolean(opts.fontLigatures, defaults.fontLigatures);
        var disableMonospaceOptimizations = _boolean(opts.disableMonospaceOptimizations, defaults.disableMonospaceOptimizations) || fontLigatures;
        var renderWhitespace = opts.renderWhitespace;
        {
            // Compatibility with old true or false values
            if (renderWhitespace === true) {
                renderWhitespace = 'boundary';
            }
            else if (renderWhitespace === false) {
                renderWhitespace = 'none';
            }
            renderWhitespace = _stringSet(opts.renderWhitespace, defaults.renderWhitespace, ['none', 'boundary', 'all']);
        }
        var renderLineHighlight = opts.renderLineHighlight;
        {
            // Compatibility with old true or false values
            if (renderLineHighlight === true) {
                renderLineHighlight = 'line';
            }
            else if (renderLineHighlight === false) {
                renderLineHighlight = 'none';
            }
            renderLineHighlight = _stringSet(opts.renderLineHighlight, defaults.renderLineHighlight, ['none', 'gutter', 'line', 'all']);
        }
        var mouseWheelScrollSensitivity = _float(opts.mouseWheelScrollSensitivity, defaults.scrollbar.mouseWheelScrollSensitivity);
        if (mouseWheelScrollSensitivity === 0) {
            // Disallow 0, as it would prevent/block scrolling
            mouseWheelScrollSensitivity = 1;
        }
        var scrollbar = this._sanitizeScrollbarOpts(opts.scrollbar, defaults.scrollbar, mouseWheelScrollSensitivity);
        var minimap = this._sanitizeMinimapOpts(opts.minimap, defaults.minimap);
        return {
            extraEditorClassName: _string(opts.extraEditorClassName, defaults.extraEditorClassName),
            disableMonospaceOptimizations: disableMonospaceOptimizations,
            rulers: rulers,
            ariaLabel: _string(opts.ariaLabel, defaults.ariaLabel),
            renderLineNumbers: renderLineNumbers,
            renderCustomLineNumbers: renderCustomLineNumbers,
            selectOnLineNumbers: _boolean(opts.selectOnLineNumbers, defaults.selectOnLineNumbers),
            glyphMargin: _boolean(opts.glyphMargin, defaults.glyphMargin),
            revealHorizontalRightPadding: _clampedInt(opts.revealHorizontalRightPadding, defaults.revealHorizontalRightPadding, 0, 1000),
            roundedSelection: _boolean(opts.roundedSelection, defaults.roundedSelection),
            overviewRulerLanes: _clampedInt(opts.overviewRulerLanes, defaults.overviewRulerLanes, 0, 3),
            overviewRulerBorder: _boolean(opts.overviewRulerBorder, defaults.overviewRulerBorder),
            cursorBlinking: _cursorBlinkingStyleFromString(opts.cursorBlinking, defaults.cursorBlinking),
            mouseWheelZoom: _boolean(opts.mouseWheelZoom, defaults.mouseWheelZoom),
            cursorStyle: _cursorStyleFromString(opts.cursorStyle, defaults.cursorStyle),
            cursorWidth: _clampedInt(opts.cursorWidth, defaults.cursorWidth, 0, Number.MAX_VALUE),
            hideCursorInOverviewRuler: _boolean(opts.hideCursorInOverviewRuler, defaults.hideCursorInOverviewRuler),
            scrollBeyondLastLine: _boolean(opts.scrollBeyondLastLine, defaults.scrollBeyondLastLine),
            smoothScrolling: _boolean(opts.smoothScrolling, defaults.smoothScrolling),
            stopRenderingLineAfter: _clampedInt(opts.stopRenderingLineAfter, defaults.stopRenderingLineAfter, -1, 1073741824 /* MAX_SAFE_SMALL_INTEGER */),
            renderWhitespace: renderWhitespace,
            renderControlCharacters: _boolean(opts.renderControlCharacters, defaults.renderControlCharacters),
            fontLigatures: fontLigatures,
            renderIndentGuides: _boolean(opts.renderIndentGuides, defaults.renderIndentGuides),
            renderLineHighlight: renderLineHighlight,
            scrollbar: scrollbar,
            minimap: minimap,
            fixedOverflowWidgets: _boolean(opts.fixedOverflowWidgets, defaults.fixedOverflowWidgets),
        };
    };
    EditorOptionsValidator._sanitizeContribInfo = function (opts, defaults) {
        var quickSuggestions;
        if (typeof opts.quickSuggestions === 'object') {
            quickSuggestions = __assign({ other: true }, opts.quickSuggestions);
        }
        else {
            quickSuggestions = _boolean(opts.quickSuggestions, defaults.quickSuggestions);
        }
        // Compatibility support for acceptSuggestionOnEnter
        if (typeof opts.acceptSuggestionOnEnter === 'boolean') {
            opts.acceptSuggestionOnEnter = opts.acceptSuggestionOnEnter ? 'on' : 'off';
        }
        var find = this._santizeFindOpts(opts.find, defaults.find);
        return {
            selectionClipboard: _boolean(opts.selectionClipboard, defaults.selectionClipboard),
            hover: _boolean(opts.hover, defaults.hover),
            links: _boolean(opts.links, defaults.links),
            contextmenu: _boolean(opts.contextmenu, defaults.contextmenu),
            quickSuggestions: quickSuggestions,
            quickSuggestionsDelay: _clampedInt(opts.quickSuggestionsDelay, defaults.quickSuggestionsDelay, -1073741824 /* MIN_SAFE_SMALL_INTEGER */, 1073741824 /* MAX_SAFE_SMALL_INTEGER */),
            parameterHints: _boolean(opts.parameterHints, defaults.parameterHints),
            iconsInSuggestions: _boolean(opts.iconsInSuggestions, defaults.iconsInSuggestions),
            formatOnType: _boolean(opts.formatOnType, defaults.formatOnType),
            formatOnPaste: _boolean(opts.formatOnPaste, defaults.formatOnPaste),
            suggestOnTriggerCharacters: _boolean(opts.suggestOnTriggerCharacters, defaults.suggestOnTriggerCharacters),
            acceptSuggestionOnEnter: _stringSet(opts.acceptSuggestionOnEnter, defaults.acceptSuggestionOnEnter, ['on', 'smart', 'off']),
            acceptSuggestionOnCommitCharacter: _boolean(opts.acceptSuggestionOnCommitCharacter, defaults.acceptSuggestionOnCommitCharacter),
            snippetSuggestions: _stringSet(opts.snippetSuggestions, defaults.snippetSuggestions, ['top', 'bottom', 'inline', 'none']),
            wordBasedSuggestions: _boolean(opts.wordBasedSuggestions, defaults.wordBasedSuggestions),
            suggestSelection: _stringSet(opts.suggestSelection, defaults.suggestSelection, ['first', 'recentlyUsed', 'recentlyUsedByPrefix']),
            suggestFontSize: _clampedInt(opts.suggestFontSize, defaults.suggestFontSize, 0, 1000),
            suggestLineHeight: _clampedInt(opts.suggestLineHeight, defaults.suggestLineHeight, 0, 1000),
            selectionHighlight: _boolean(opts.selectionHighlight, defaults.selectionHighlight),
            occurrencesHighlight: _boolean(opts.occurrencesHighlight, defaults.occurrencesHighlight),
            codeLens: _boolean(opts.codeLens, defaults.codeLens),
            folding: _boolean(opts.folding, defaults.folding),
            foldingStrategy: _stringSet(opts.foldingStrategy, defaults.foldingStrategy, ['auto', 'indentation']),
            showFoldingControls: _stringSet(opts.showFoldingControls, defaults.showFoldingControls, ['always', 'mouseover']),
            matchBrackets: _boolean(opts.matchBrackets, defaults.matchBrackets),
            find: find,
            colorDecorators: _boolean(opts.colorDecorators, defaults.colorDecorators),
            lightbulbEnabled: _boolean(opts.lightbulb ? opts.lightbulb.enabled : false, defaults.lightbulbEnabled),
            codeActionsOnSave: _booleanMap(opts.codeActionsOnSave, {}),
            codeActionsOnSaveTimeout: _clampedInt(opts.codeActionsOnSaveTimeout, defaults.codeActionsOnSaveTimeout, 1, 10000)
        };
    };
    return EditorOptionsValidator;
}());
/**
 * @internal
 */
var InternalEditorOptionsFactory = /** @class */ (function () {
    function InternalEditorOptionsFactory() {
    }
    InternalEditorOptionsFactory._tweakValidatedOptions = function (opts, accessibilitySupport) {
        var accessibilityIsOn = (accessibilitySupport === 2 /* Enabled */);
        var accessibilityIsOff = (accessibilitySupport === 1 /* Disabled */);
        return {
            inDiffEditor: opts.inDiffEditor,
            wordSeparators: opts.wordSeparators,
            lineNumbersMinChars: opts.lineNumbersMinChars,
            lineDecorationsWidth: opts.lineDecorationsWidth,
            readOnly: opts.readOnly,
            mouseStyle: opts.mouseStyle,
            disableLayerHinting: opts.disableLayerHinting,
            automaticLayout: opts.automaticLayout,
            wordWrap: opts.wordWrap,
            wordWrapColumn: opts.wordWrapColumn,
            wordWrapMinified: opts.wordWrapMinified,
            wrappingIndent: opts.wrappingIndent,
            wordWrapBreakBeforeCharacters: opts.wordWrapBreakBeforeCharacters,
            wordWrapBreakAfterCharacters: opts.wordWrapBreakAfterCharacters,
            wordWrapBreakObtrusiveCharacters: opts.wordWrapBreakObtrusiveCharacters,
            autoClosingBrackets: opts.autoClosingBrackets,
            autoIndent: opts.autoIndent,
            dragAndDrop: opts.dragAndDrop,
            emptySelectionClipboard: opts.emptySelectionClipboard,
            useTabStops: opts.useTabStops,
            multiCursorModifier: opts.multiCursorModifier,
            multiCursorMergeOverlapping: opts.multiCursorMergeOverlapping,
            accessibilitySupport: opts.accessibilitySupport,
            viewInfo: {
                extraEditorClassName: opts.viewInfo.extraEditorClassName,
                disableMonospaceOptimizations: opts.viewInfo.disableMonospaceOptimizations,
                rulers: opts.viewInfo.rulers,
                ariaLabel: (accessibilityIsOff ? localize('accessibilityOffAriaLabel', "The editor is not accessible at this time. Press Alt+F1 for options.") : opts.viewInfo.ariaLabel),
                renderLineNumbers: opts.viewInfo.renderLineNumbers,
                renderCustomLineNumbers: opts.viewInfo.renderCustomLineNumbers,
                selectOnLineNumbers: opts.viewInfo.selectOnLineNumbers,
                glyphMargin: opts.viewInfo.glyphMargin,
                revealHorizontalRightPadding: opts.viewInfo.revealHorizontalRightPadding,
                roundedSelection: (accessibilityIsOn ? false : opts.viewInfo.roundedSelection),
                overviewRulerLanes: opts.viewInfo.overviewRulerLanes,
                overviewRulerBorder: opts.viewInfo.overviewRulerBorder,
                cursorBlinking: opts.viewInfo.cursorBlinking,
                mouseWheelZoom: opts.viewInfo.mouseWheelZoom,
                cursorStyle: opts.viewInfo.cursorStyle,
                cursorWidth: opts.viewInfo.cursorWidth,
                hideCursorInOverviewRuler: opts.viewInfo.hideCursorInOverviewRuler,
                scrollBeyondLastLine: opts.viewInfo.scrollBeyondLastLine,
                smoothScrolling: opts.viewInfo.smoothScrolling,
                stopRenderingLineAfter: opts.viewInfo.stopRenderingLineAfter,
                renderWhitespace: (accessibilityIsOn ? 'none' : opts.viewInfo.renderWhitespace),
                renderControlCharacters: (accessibilityIsOn ? false : opts.viewInfo.renderControlCharacters),
                fontLigatures: (accessibilityIsOn ? false : opts.viewInfo.fontLigatures),
                renderIndentGuides: (accessibilityIsOn ? false : opts.viewInfo.renderIndentGuides),
                renderLineHighlight: opts.viewInfo.renderLineHighlight,
                scrollbar: opts.viewInfo.scrollbar,
                minimap: {
                    enabled: (accessibilityIsOn ? false : opts.viewInfo.minimap.enabled),
                    side: opts.viewInfo.minimap.side,
                    renderCharacters: opts.viewInfo.minimap.renderCharacters,
                    showSlider: opts.viewInfo.minimap.showSlider,
                    maxColumn: opts.viewInfo.minimap.maxColumn
                },
                fixedOverflowWidgets: opts.viewInfo.fixedOverflowWidgets
            },
            contribInfo: {
                selectionClipboard: opts.contribInfo.selectionClipboard,
                hover: opts.contribInfo.hover,
                links: (accessibilityIsOn ? false : opts.contribInfo.links),
                contextmenu: opts.contribInfo.contextmenu,
                quickSuggestions: opts.contribInfo.quickSuggestions,
                quickSuggestionsDelay: opts.contribInfo.quickSuggestionsDelay,
                parameterHints: opts.contribInfo.parameterHints,
                iconsInSuggestions: opts.contribInfo.iconsInSuggestions,
                formatOnType: opts.contribInfo.formatOnType,
                formatOnPaste: opts.contribInfo.formatOnPaste,
                suggestOnTriggerCharacters: opts.contribInfo.suggestOnTriggerCharacters,
                acceptSuggestionOnEnter: opts.contribInfo.acceptSuggestionOnEnter,
                acceptSuggestionOnCommitCharacter: opts.contribInfo.acceptSuggestionOnCommitCharacter,
                snippetSuggestions: opts.contribInfo.snippetSuggestions,
                wordBasedSuggestions: opts.contribInfo.wordBasedSuggestions,
                suggestSelection: opts.contribInfo.suggestSelection,
                suggestFontSize: opts.contribInfo.suggestFontSize,
                suggestLineHeight: opts.contribInfo.suggestLineHeight,
                selectionHighlight: (accessibilityIsOn ? false : opts.contribInfo.selectionHighlight),
                occurrencesHighlight: (accessibilityIsOn ? false : opts.contribInfo.occurrencesHighlight),
                codeLens: (accessibilityIsOn ? false : opts.contribInfo.codeLens),
                folding: (accessibilityIsOn ? false : opts.contribInfo.folding),
                foldingStrategy: opts.contribInfo.foldingStrategy,
                showFoldingControls: opts.contribInfo.showFoldingControls,
                matchBrackets: (accessibilityIsOn ? false : opts.contribInfo.matchBrackets),
                find: opts.contribInfo.find,
                colorDecorators: opts.contribInfo.colorDecorators,
                lightbulbEnabled: opts.contribInfo.lightbulbEnabled,
                codeActionsOnSave: opts.contribInfo.codeActionsOnSave,
                codeActionsOnSaveTimeout: opts.contribInfo.codeActionsOnSaveTimeout
            }
        };
    };
    InternalEditorOptionsFactory.createInternalEditorOptions = function (env, _opts) {
        var accessibilitySupport;
        if (_opts.accessibilitySupport === 'auto') {
            // The editor reads the `accessibilitySupport` from the environment
            accessibilitySupport = env.accessibilitySupport;
        }
        else if (_opts.accessibilitySupport === 'on') {
            accessibilitySupport = 2 /* Enabled */;
        }
        else {
            accessibilitySupport = 1 /* Disabled */;
        }
        // Disable some non critical features to get as best performance as possible
        // See https://github.com/Microsoft/vscode/issues/26730
        var opts = this._tweakValidatedOptions(_opts, accessibilitySupport);
        var lineDecorationsWidth;
        if (typeof opts.lineDecorationsWidth === 'string' && /^\d+(\.\d+)?ch$/.test(opts.lineDecorationsWidth)) {
            var multiple = parseFloat(opts.lineDecorationsWidth.substr(0, opts.lineDecorationsWidth.length - 2));
            lineDecorationsWidth = multiple * env.fontInfo.typicalHalfwidthCharacterWidth;
        }
        else {
            lineDecorationsWidth = _clampedInt(opts.lineDecorationsWidth, 0, 0, 1000);
        }
        if (opts.contribInfo.folding) {
            lineDecorationsWidth += 16;
        }
        var layoutInfo = EditorLayoutProvider.compute({
            outerWidth: env.outerWidth,
            outerHeight: env.outerHeight,
            showGlyphMargin: opts.viewInfo.glyphMargin,
            lineHeight: env.fontInfo.lineHeight,
            showLineNumbers: (opts.viewInfo.renderLineNumbers !== 0 /* Off */),
            lineNumbersMinChars: opts.lineNumbersMinChars,
            lineNumbersDigitCount: env.lineNumbersDigitCount,
            lineDecorationsWidth: lineDecorationsWidth,
            typicalHalfwidthCharacterWidth: env.fontInfo.typicalHalfwidthCharacterWidth,
            maxDigitWidth: env.fontInfo.maxDigitWidth,
            verticalScrollbarWidth: opts.viewInfo.scrollbar.verticalScrollbarSize,
            horizontalScrollbarHeight: opts.viewInfo.scrollbar.horizontalScrollbarSize,
            scrollbarArrowSize: opts.viewInfo.scrollbar.arrowSize,
            verticalScrollbarHasArrows: opts.viewInfo.scrollbar.verticalHasArrows,
            minimap: opts.viewInfo.minimap.enabled,
            minimapSide: opts.viewInfo.minimap.side,
            minimapRenderCharacters: opts.viewInfo.minimap.renderCharacters,
            minimapMaxColumn: opts.viewInfo.minimap.maxColumn,
            pixelRatio: env.pixelRatio
        });
        var bareWrappingInfo = null;
        {
            var wordWrap = opts.wordWrap;
            var wordWrapColumn = opts.wordWrapColumn;
            var wordWrapMinified = opts.wordWrapMinified;
            if (accessibilitySupport === 2 /* Enabled */) {
                // See https://github.com/Microsoft/vscode/issues/27766
                // Never enable wrapping when a screen reader is attached
                // because arrow down etc. will not move the cursor in the way
                // a screen reader expects.
                bareWrappingInfo = {
                    isWordWrapMinified: false,
                    isViewportWrapping: false,
                    wrappingColumn: -1
                };
            }
            else if (wordWrapMinified && env.isDominatedByLongLines) {
                // Force viewport width wrapping if model is dominated by long lines
                bareWrappingInfo = {
                    isWordWrapMinified: true,
                    isViewportWrapping: true,
                    wrappingColumn: Math.max(1, layoutInfo.viewportColumn)
                };
            }
            else if (wordWrap === 'on') {
                bareWrappingInfo = {
                    isWordWrapMinified: false,
                    isViewportWrapping: true,
                    wrappingColumn: Math.max(1, layoutInfo.viewportColumn)
                };
            }
            else if (wordWrap === 'bounded') {
                bareWrappingInfo = {
                    isWordWrapMinified: false,
                    isViewportWrapping: true,
                    wrappingColumn: Math.min(Math.max(1, layoutInfo.viewportColumn), wordWrapColumn)
                };
            }
            else if (wordWrap === 'wordWrapColumn') {
                bareWrappingInfo = {
                    isWordWrapMinified: false,
                    isViewportWrapping: false,
                    wrappingColumn: wordWrapColumn
                };
            }
            else {
                bareWrappingInfo = {
                    isWordWrapMinified: false,
                    isViewportWrapping: false,
                    wrappingColumn: -1
                };
            }
        }
        var wrappingInfo = {
            inDiffEditor: opts.inDiffEditor,
            isDominatedByLongLines: env.isDominatedByLongLines,
            isWordWrapMinified: bareWrappingInfo.isWordWrapMinified,
            isViewportWrapping: bareWrappingInfo.isViewportWrapping,
            wrappingColumn: bareWrappingInfo.wrappingColumn,
            wrappingIndent: opts.wrappingIndent,
            wordWrapBreakBeforeCharacters: opts.wordWrapBreakBeforeCharacters,
            wordWrapBreakAfterCharacters: opts.wordWrapBreakAfterCharacters,
            wordWrapBreakObtrusiveCharacters: opts.wordWrapBreakObtrusiveCharacters,
        };
        var className = 'monaco-editor';
        if (opts.viewInfo.extraEditorClassName) {
            className += ' ' + opts.viewInfo.extraEditorClassName;
        }
        if (env.extraEditorClassName) {
            className += ' ' + env.extraEditorClassName;
        }
        if (opts.viewInfo.fontLigatures) {
            className += ' enable-ligatures';
        }
        if (opts.mouseStyle === 'default') {
            className += ' mouse-default';
        }
        else if (opts.mouseStyle === 'copy') {
            className += ' mouse-copy';
        }
        return new InternalEditorOptions({
            canUseLayerHinting: opts.disableLayerHinting ? false : true,
            pixelRatio: env.pixelRatio,
            editorClassName: className,
            lineHeight: env.fontInfo.lineHeight,
            readOnly: opts.readOnly,
            accessibilitySupport: accessibilitySupport,
            multiCursorModifier: opts.multiCursorModifier,
            multiCursorMergeOverlapping: opts.multiCursorMergeOverlapping,
            wordSeparators: opts.wordSeparators,
            autoClosingBrackets: opts.autoClosingBrackets,
            autoIndent: opts.autoIndent,
            useTabStops: opts.useTabStops,
            tabFocusMode: opts.readOnly ? true : env.tabFocusMode,
            dragAndDrop: opts.dragAndDrop,
            emptySelectionClipboard: opts.emptySelectionClipboard && env.emptySelectionClipboard,
            layoutInfo: layoutInfo,
            fontInfo: env.fontInfo,
            viewInfo: opts.viewInfo,
            wrappingInfo: wrappingInfo,
            contribInfo: opts.contribInfo
        });
    };
    return InternalEditorOptionsFactory;
}());
/**
 * @internal
 */
var EditorLayoutProvider = /** @class */ (function () {
    function EditorLayoutProvider() {
    }
    EditorLayoutProvider.compute = function (_opts) {
        var outerWidth = _opts.outerWidth | 0;
        var outerHeight = _opts.outerHeight | 0;
        var showGlyphMargin = _opts.showGlyphMargin;
        var lineHeight = _opts.lineHeight | 0;
        var showLineNumbers = _opts.showLineNumbers;
        var lineNumbersMinChars = _opts.lineNumbersMinChars | 0;
        var lineNumbersDigitCount = _opts.lineNumbersDigitCount | 0;
        var lineDecorationsWidth = _opts.lineDecorationsWidth | 0;
        var typicalHalfwidthCharacterWidth = _opts.typicalHalfwidthCharacterWidth;
        var maxDigitWidth = _opts.maxDigitWidth;
        var verticalScrollbarWidth = _opts.verticalScrollbarWidth | 0;
        var verticalScrollbarHasArrows = _opts.verticalScrollbarHasArrows;
        var scrollbarArrowSize = _opts.scrollbarArrowSize | 0;
        var horizontalScrollbarHeight = _opts.horizontalScrollbarHeight | 0;
        var minimap = _opts.minimap;
        var minimapSide = _opts.minimapSide;
        var minimapRenderCharacters = _opts.minimapRenderCharacters;
        var minimapMaxColumn = _opts.minimapMaxColumn | 0;
        var pixelRatio = _opts.pixelRatio;
        var lineNumbersWidth = 0;
        if (showLineNumbers) {
            var digitCount = Math.max(lineNumbersDigitCount, lineNumbersMinChars);
            lineNumbersWidth = Math.round(digitCount * maxDigitWidth);
        }
        var glyphMarginWidth = 0;
        if (showGlyphMargin) {
            glyphMarginWidth = lineHeight;
        }
        var glyphMarginLeft = 0;
        var lineNumbersLeft = glyphMarginLeft + glyphMarginWidth;
        var decorationsLeft = lineNumbersLeft + lineNumbersWidth;
        var contentLeft = decorationsLeft + lineDecorationsWidth;
        var remainingWidth = outerWidth - glyphMarginWidth - lineNumbersWidth - lineDecorationsWidth;
        var renderMinimap;
        var minimapLeft;
        var minimapWidth;
        var contentWidth;
        if (!minimap) {
            minimapLeft = 0;
            minimapWidth = 0;
            renderMinimap = RenderMinimap.None;
            contentWidth = remainingWidth;
        }
        else {
            var minimapCharWidth = void 0;
            if (pixelRatio >= 2) {
                renderMinimap = minimapRenderCharacters ? RenderMinimap.Large : RenderMinimap.LargeBlocks;
                minimapCharWidth = 2 / pixelRatio;
            }
            else {
                renderMinimap = minimapRenderCharacters ? RenderMinimap.Small : RenderMinimap.SmallBlocks;
                minimapCharWidth = 1 / pixelRatio;
            }
            // Given:
            // (leaving 2px for the cursor to have space after the last character)
            // viewportColumn = (contentWidth - verticalScrollbarWidth - 2) / typicalHalfwidthCharacterWidth
            // minimapWidth = viewportColumn * minimapCharWidth
            // contentWidth = remainingWidth - minimapWidth
            // What are good values for contentWidth and minimapWidth ?
            // minimapWidth = ((contentWidth - verticalScrollbarWidth - 2) / typicalHalfwidthCharacterWidth) * minimapCharWidth
            // typicalHalfwidthCharacterWidth * minimapWidth = (contentWidth - verticalScrollbarWidth - 2) * minimapCharWidth
            // typicalHalfwidthCharacterWidth * minimapWidth = (remainingWidth - minimapWidth - verticalScrollbarWidth - 2) * minimapCharWidth
            // (typicalHalfwidthCharacterWidth + minimapCharWidth) * minimapWidth = (remainingWidth - verticalScrollbarWidth - 2) * minimapCharWidth
            // minimapWidth = ((remainingWidth - verticalScrollbarWidth - 2) * minimapCharWidth) / (typicalHalfwidthCharacterWidth + minimapCharWidth)
            minimapWidth = Math.max(0, Math.floor(((remainingWidth - verticalScrollbarWidth - 2) * minimapCharWidth) / (typicalHalfwidthCharacterWidth + minimapCharWidth)));
            var minimapColumns = minimapWidth / minimapCharWidth;
            if (minimapColumns > minimapMaxColumn) {
                minimapWidth = Math.floor(minimapMaxColumn * minimapCharWidth);
            }
            contentWidth = remainingWidth - minimapWidth;
            if (minimapSide === 'left') {
                minimapLeft = 0;
                glyphMarginLeft += minimapWidth;
                lineNumbersLeft += minimapWidth;
                decorationsLeft += minimapWidth;
                contentLeft += minimapWidth;
            }
            else {
                minimapLeft = outerWidth - minimapWidth - verticalScrollbarWidth;
            }
        }
        // (leaving 2px for the cursor to have space after the last character)
        var viewportColumn = Math.max(1, Math.floor((contentWidth - verticalScrollbarWidth - 2) / typicalHalfwidthCharacterWidth));
        var verticalArrowSize = (verticalScrollbarHasArrows ? scrollbarArrowSize : 0);
        return {
            width: outerWidth,
            height: outerHeight,
            glyphMarginLeft: glyphMarginLeft,
            glyphMarginWidth: glyphMarginWidth,
            glyphMarginHeight: outerHeight,
            lineNumbersLeft: lineNumbersLeft,
            lineNumbersWidth: lineNumbersWidth,
            lineNumbersHeight: outerHeight,
            decorationsLeft: decorationsLeft,
            decorationsWidth: lineDecorationsWidth,
            decorationsHeight: outerHeight,
            contentLeft: contentLeft,
            contentWidth: contentWidth,
            contentHeight: outerHeight,
            renderMinimap: renderMinimap,
            minimapLeft: minimapLeft,
            minimapWidth: minimapWidth,
            viewportColumn: viewportColumn,
            verticalScrollbarWidth: verticalScrollbarWidth,
            horizontalScrollbarHeight: horizontalScrollbarHeight,
            overviewRuler: {
                top: verticalArrowSize,
                width: verticalScrollbarWidth,
                height: (outerHeight - 2 * verticalArrowSize),
                right: 0
            }
        };
    };
    return EditorLayoutProvider;
}());
var DEFAULT_WINDOWS_FONT_FAMILY = 'Consolas, \'Courier New\', monospace';
var DEFAULT_MAC_FONT_FAMILY = 'Menlo, Monaco, \'Courier New\', monospace';
var DEFAULT_LINUX_FONT_FAMILY = '\'Droid Sans Mono\', \'monospace\', monospace, \'Droid Sans Fallback\'';
/**
 * @internal
 */
var EDITOR_FONT_DEFAULTS = {
    fontFamily: (isMacintosh ? DEFAULT_MAC_FONT_FAMILY : (isLinux ? DEFAULT_LINUX_FONT_FAMILY : DEFAULT_WINDOWS_FONT_FAMILY)),
    fontWeight: 'normal',
    fontSize: (isMacintosh ? 12 : 14),
    lineHeight: 0,
    letterSpacing: 0,
};
/**
 * @internal
 */
var EDITOR_MODEL_DEFAULTS = {
    tabSize: 4,
    insertSpaces: true,
    detectIndentation: true,
    trimAutoWhitespace: true,
    largeFileOptimizations: true
};
/**
 * @internal
 */
var EDITOR_DEFAULTS = {
    inDiffEditor: false,
    wordSeparators: USUAL_WORD_SEPARATORS,
    lineNumbersMinChars: 5,
    lineDecorationsWidth: 10,
    readOnly: false,
    mouseStyle: 'text',
    disableLayerHinting: false,
    automaticLayout: false,
    wordWrap: 'off',
    wordWrapColumn: 80,
    wordWrapMinified: true,
    wrappingIndent: WrappingIndent.Same,
    wordWrapBreakBeforeCharacters: '([{‘“〈《「『【〔（［｛｢£¥＄￡￥+＋',
    wordWrapBreakAfterCharacters: ' \t})]?|&,;¢°′″‰℃、。｡､￠，．：；？！％・･ゝゞヽヾーァィゥェォッャュョヮヵヶぁぃぅぇぉっゃゅょゎゕゖㇰㇱㇲㇳㇴㇵㇶㇷㇸㇹㇺㇻㇼㇽㇾㇿ々〻ｧｨｩｪｫｬｭｮｯｰ”〉》」』】〕）］｝｣',
    wordWrapBreakObtrusiveCharacters: '.',
    autoClosingBrackets: true,
    autoIndent: true,
    dragAndDrop: true,
    emptySelectionClipboard: true,
    useTabStops: true,
    multiCursorModifier: 'altKey',
    multiCursorMergeOverlapping: true,
    accessibilitySupport: 'auto',
    viewInfo: {
        extraEditorClassName: '',
        disableMonospaceOptimizations: false,
        rulers: [],
        ariaLabel: localize('editorViewAccessibleLabel', "Editor content"),
        renderLineNumbers: 1 /* On */,
        renderCustomLineNumbers: null,
        selectOnLineNumbers: true,
        glyphMargin: true,
        revealHorizontalRightPadding: 30,
        roundedSelection: true,
        overviewRulerLanes: 2,
        overviewRulerBorder: true,
        cursorBlinking: TextEditorCursorBlinkingStyle.Blink,
        mouseWheelZoom: false,
        cursorStyle: TextEditorCursorStyle.Line,
        cursorWidth: 0,
        hideCursorInOverviewRuler: false,
        scrollBeyondLastLine: true,
        smoothScrolling: false,
        stopRenderingLineAfter: 10000,
        renderWhitespace: 'none',
        renderControlCharacters: false,
        fontLigatures: false,
        renderIndentGuides: true,
        renderLineHighlight: 'line',
        scrollbar: {
            vertical: ScrollbarVisibility.Auto,
            horizontal: ScrollbarVisibility.Auto,
            arrowSize: 11,
            useShadows: true,
            verticalHasArrows: false,
            horizontalHasArrows: false,
            horizontalScrollbarSize: 10,
            horizontalSliderSize: 10,
            verticalScrollbarSize: 14,
            verticalSliderSize: 14,
            handleMouseWheel: true,
            mouseWheelScrollSensitivity: 1,
        },
        minimap: {
            enabled: true,
            side: 'right',
            showSlider: 'mouseover',
            renderCharacters: true,
            maxColumn: 120
        },
        fixedOverflowWidgets: false,
    },
    contribInfo: {
        selectionClipboard: true,
        hover: true,
        links: true,
        contextmenu: true,
        quickSuggestions: { other: true, comments: false, strings: false },
        quickSuggestionsDelay: 10,
        parameterHints: true,
        iconsInSuggestions: true,
        formatOnType: false,
        formatOnPaste: false,
        suggestOnTriggerCharacters: true,
        acceptSuggestionOnEnter: 'on',
        acceptSuggestionOnCommitCharacter: true,
        snippetSuggestions: 'inline',
        wordBasedSuggestions: true,
        suggestSelection: 'recentlyUsed',
        suggestFontSize: 0,
        suggestLineHeight: 0,
        selectionHighlight: true,
        occurrencesHighlight: true,
        codeLens: true,
        folding: true,
        foldingStrategy: 'auto',
        showFoldingControls: 'mouseover',
        matchBrackets: true,
        find: {
            seedSearchStringFromSelection: true,
            autoFindInSelection: false,
            globalFindClipboard: false
        },
        colorDecorators: true,
        lightbulbEnabled: true,
        codeActionsOnSave: {},
        codeActionsOnSaveTimeout: 750
    },
};

var editorOptions = /*#__PURE__*/Object.freeze({
	get RenderMinimap () { return RenderMinimap; },
	get WrappingIndent () { return WrappingIndent; },
	get TextEditorCursorBlinkingStyle () { return TextEditorCursorBlinkingStyle; },
	blinkingStyleToString: blinkingStyleToString,
	get TextEditorCursorStyle () { return TextEditorCursorStyle; },
	cursorStyleToString: cursorStyleToString,
	InternalEditorOptions: InternalEditorOptions,
	EditorOptionsValidator: EditorOptionsValidator,
	InternalEditorOptionsFactory: InternalEditorOptionsFactory,
	EditorLayoutProvider: EditorLayoutProvider,
	EDITOR_FONT_DEFAULTS: EDITOR_FONT_DEFAULTS,
	EDITOR_MODEL_DEFAULTS: EDITOR_MODEL_DEFAULTS,
	EDITOR_DEFAULTS: EDITOR_DEFAULTS
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$9 = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var WordCharacterClassifier = /** @class */ (function (_super) {
    __extends$9(WordCharacterClassifier, _super);
    function WordCharacterClassifier(wordSeparators) {
        var _this = _super.call(this, 0 /* Regular */) || this;
        for (var i = 0, len = wordSeparators.length; i < len; i++) {
            _this.set(wordSeparators.charCodeAt(i), 2 /* WordSeparator */);
        }
        _this.set(32 /* Space */, 1 /* Whitespace */);
        _this.set(9 /* Tab */, 1 /* Whitespace */);
        return _this;
    }
    return WordCharacterClassifier;
}(CharacterClassifier));
function once$2(computeFn) {
    var cache = {}; // TODO@Alex unbounded cache
    return function (input) {
        if (!cache.hasOwnProperty(input)) {
            cache[input] = computeFn(input);
        }
        return cache[input];
    };
}
var getMapForWordSeparators = once$2(function (input) { return new WordCharacterClassifier(input); });

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var LIMIT_FIND_COUNT = 999;
var SearchParams = /** @class */ (function () {
    function SearchParams(searchString, isRegex, matchCase, wordSeparators) {
        this.searchString = searchString;
        this.isRegex = isRegex;
        this.matchCase = matchCase;
        this.wordSeparators = wordSeparators;
    }
    SearchParams._isMultilineRegexSource = function (searchString) {
        if (!searchString || searchString.length === 0) {
            return false;
        }
        for (var i = 0, len = searchString.length; i < len; i++) {
            var chCode = searchString.charCodeAt(i);
            if (chCode === 92 /* Backslash */) {
                // move to next char
                i++;
                if (i >= len) {
                    // string ends with a \
                    break;
                }
                var nextChCode = searchString.charCodeAt(i);
                if (nextChCode === 110 /* n */ || nextChCode === 114 /* r */) {
                    return true;
                }
            }
        }
        return false;
    };
    SearchParams.prototype.parseSearchRequest = function () {
        if (this.searchString === '') {
            return null;
        }
        // Try to create a RegExp out of the params
        var multiline;
        if (this.isRegex) {
            multiline = SearchParams._isMultilineRegexSource(this.searchString);
        }
        else {
            multiline = (this.searchString.indexOf('\n') >= 0);
        }
        var regex = null;
        try {
            regex = createRegExp(this.searchString, this.isRegex, {
                matchCase: this.matchCase,
                wholeWord: false,
                multiline: multiline,
                global: true
            });
        }
        catch (err) {
            return null;
        }
        if (!regex) {
            return null;
        }
        var canUseSimpleSearch = (!this.isRegex && !multiline);
        if (canUseSimpleSearch && this.searchString.toLowerCase() !== this.searchString.toUpperCase()) {
            // casing might make a difference
            canUseSimpleSearch = this.matchCase;
        }
        return new SearchData(regex, this.wordSeparators ? getMapForWordSeparators(this.wordSeparators) : null, canUseSimpleSearch ? this.searchString : null);
    };
    return SearchParams;
}());
var SearchData = /** @class */ (function () {
    function SearchData(regex, wordSeparators, simpleSearch) {
        this.regex = regex;
        this.wordSeparators = wordSeparators;
        this.simpleSearch = simpleSearch;
    }
    return SearchData;
}());
function createFindMatch(range, rawMatches, captureMatches) {
    if (!captureMatches) {
        return new FindMatch(range, null);
    }
    var matches = [];
    for (var i = 0, len = rawMatches.length; i < len; i++) {
        matches[i] = rawMatches[i];
    }
    return new FindMatch(range, matches);
}
var TextModelSearch = /** @class */ (function () {
    function TextModelSearch() {
    }
    TextModelSearch.findMatches = function (model, searchParams, searchRange, captureMatches, limitResultCount) {
        var searchData = searchParams.parseSearchRequest();
        if (!searchData) {
            return [];
        }
        if (searchData.regex.multiline) {
            if (searchData.regex.source === '\\n') {
                // Fast path for searching for EOL
                var result = [], resultLen = 0;
                for (var lineNumber = 1, lineCount = model.getLineCount(); lineNumber < lineCount; lineNumber++) {
                    var range = new Range(lineNumber, model.getLineMaxColumn(lineNumber), lineNumber + 1, 1);
                    if (captureMatches) {
                        result[resultLen++] = new FindMatch(range, null);
                    }
                    else {
                        result[resultLen++] = new FindMatch(range, ['\n']);
                    }
                    if (resultLen >= limitResultCount) {
                        break;
                    }
                }
                return result;
            }
            return this._doFindMatchesMultiline(model, searchRange, new Searcher(searchData.wordSeparators, searchData.regex), captureMatches, limitResultCount);
        }
        return this._doFindMatchesLineByLine(model, searchRange, searchData, captureMatches, limitResultCount);
    };
    /**
     * Multiline search always executes on the lines concatenated with \n.
     * We must therefore compensate for the count of \n in case the model is CRLF
     */
    TextModelSearch._getMultilineMatchRange = function (model, deltaOffset, text, matchIndex, match0) {
        var startOffset;
        if (model.getEOL() === '\r\n') {
            var lineFeedCountBeforeMatch = 0;
            for (var i = 0; i < matchIndex; i++) {
                var chCode = text.charCodeAt(i);
                if (chCode === 10 /* LineFeed */) {
                    lineFeedCountBeforeMatch++;
                }
            }
            startOffset = deltaOffset + matchIndex + lineFeedCountBeforeMatch /* add as many \r as there were \n */;
        }
        else {
            startOffset = deltaOffset + matchIndex;
        }
        var endOffset;
        if (model.getEOL() === '\r\n') {
            var lineFeedCountInMatch = 0;
            for (var i = 0, len = match0.length; i < len; i++) {
                var chCode = text.charCodeAt(i + matchIndex);
                if (chCode === 10 /* LineFeed */) {
                    lineFeedCountInMatch++;
                }
            }
            endOffset = startOffset + match0.length + lineFeedCountInMatch /* add as many \r as there were \n */;
        }
        else {
            endOffset = startOffset + match0.length;
        }
        var startPosition = model.getPositionAt(startOffset);
        var endPosition = model.getPositionAt(endOffset);
        return new Range(startPosition.lineNumber, startPosition.column, endPosition.lineNumber, endPosition.column);
    };
    TextModelSearch._doFindMatchesMultiline = function (model, searchRange, searcher, captureMatches, limitResultCount) {
        var deltaOffset = model.getOffsetAt(searchRange.getStartPosition());
        // We always execute multiline search over the lines joined with \n
        // This makes it that \n will match the EOL for both CRLF and LF models
        // We compensate for offset errors in `_getMultilineMatchRange`
        var text = model.getValueInRange(searchRange, EndOfLinePreference.LF);
        var result = [];
        var counter = 0;
        var m;
        searcher.reset(0);
        while ((m = searcher.next(text))) {
            result[counter++] = createFindMatch(this._getMultilineMatchRange(model, deltaOffset, text, m.index, m[0]), m, captureMatches);
            if (counter >= limitResultCount) {
                return result;
            }
        }
        return result;
    };
    TextModelSearch._doFindMatchesLineByLine = function (model, searchRange, searchData, captureMatches, limitResultCount) {
        var result = [];
        var resultLen = 0;
        // Early case for a search range that starts & stops on the same line number
        if (searchRange.startLineNumber === searchRange.endLineNumber) {
            var text_1 = model.getLineContent(searchRange.startLineNumber).substring(searchRange.startColumn - 1, searchRange.endColumn - 1);
            resultLen = this._findMatchesInLine(searchData, text_1, searchRange.startLineNumber, searchRange.startColumn - 1, resultLen, result, captureMatches, limitResultCount);
            return result;
        }
        // Collect results from first line
        var text = model.getLineContent(searchRange.startLineNumber).substring(searchRange.startColumn - 1);
        resultLen = this._findMatchesInLine(searchData, text, searchRange.startLineNumber, searchRange.startColumn - 1, resultLen, result, captureMatches, limitResultCount);
        // Collect results from middle lines
        for (var lineNumber = searchRange.startLineNumber + 1; lineNumber < searchRange.endLineNumber && resultLen < limitResultCount; lineNumber++) {
            resultLen = this._findMatchesInLine(searchData, model.getLineContent(lineNumber), lineNumber, 0, resultLen, result, captureMatches, limitResultCount);
        }
        // Collect results from last line
        if (resultLen < limitResultCount) {
            var text_2 = model.getLineContent(searchRange.endLineNumber).substring(0, searchRange.endColumn - 1);
            resultLen = this._findMatchesInLine(searchData, text_2, searchRange.endLineNumber, 0, resultLen, result, captureMatches, limitResultCount);
        }
        return result;
    };
    TextModelSearch._findMatchesInLine = function (searchData, text, lineNumber, deltaOffset, resultLen, result, captureMatches, limitResultCount) {
        var wordSeparators = searchData.wordSeparators;
        if (!captureMatches && searchData.simpleSearch) {
            var searchString = searchData.simpleSearch;
            var searchStringLen = searchString.length;
            var textLength = text.length;
            var lastMatchIndex = -searchStringLen;
            while ((lastMatchIndex = text.indexOf(searchString, lastMatchIndex + searchStringLen)) !== -1) {
                if (!wordSeparators || isValidMatch(wordSeparators, text, textLength, lastMatchIndex, searchStringLen)) {
                    result[resultLen++] = new FindMatch(new Range(lineNumber, lastMatchIndex + 1 + deltaOffset, lineNumber, lastMatchIndex + 1 + searchStringLen + deltaOffset), null);
                    if (resultLen >= limitResultCount) {
                        return resultLen;
                    }
                }
            }
            return resultLen;
        }
        var searcher = new Searcher(searchData.wordSeparators, searchData.regex);
        var m;
        // Reset regex to search from the beginning
        searcher.reset(0);
        do {
            m = searcher.next(text);
            if (m) {
                result[resultLen++] = createFindMatch(new Range(lineNumber, m.index + 1 + deltaOffset, lineNumber, m.index + 1 + m[0].length + deltaOffset), m, captureMatches);
                if (resultLen >= limitResultCount) {
                    return resultLen;
                }
            }
        } while (m);
        return resultLen;
    };
    TextModelSearch.findNextMatch = function (model, searchParams, searchStart, captureMatches) {
        var searchData = searchParams.parseSearchRequest();
        if (!searchData) {
            return null;
        }
        var searcher = new Searcher(searchData.wordSeparators, searchData.regex);
        if (searchData.regex.multiline) {
            return this._doFindNextMatchMultiline(model, searchStart, searcher, captureMatches);
        }
        return this._doFindNextMatchLineByLine(model, searchStart, searcher, captureMatches);
    };
    TextModelSearch._doFindNextMatchMultiline = function (model, searchStart, searcher, captureMatches) {
        var searchTextStart = new Position(searchStart.lineNumber, 1);
        var deltaOffset = model.getOffsetAt(searchTextStart);
        var lineCount = model.getLineCount();
        // We always execute multiline search over the lines joined with \n
        // This makes it that \n will match the EOL for both CRLF and LF models
        // We compensate for offset errors in `_getMultilineMatchRange`
        var text = model.getValueInRange(new Range(searchTextStart.lineNumber, searchTextStart.column, lineCount, model.getLineMaxColumn(lineCount)), EndOfLinePreference.LF);
        searcher.reset(searchStart.column - 1);
        var m = searcher.next(text);
        if (m) {
            return createFindMatch(this._getMultilineMatchRange(model, deltaOffset, text, m.index, m[0]), m, captureMatches);
        }
        if (searchStart.lineNumber !== 1 || searchStart.column !== 1) {
            // Try again from the top
            return this._doFindNextMatchMultiline(model, new Position(1, 1), searcher, captureMatches);
        }
        return null;
    };
    TextModelSearch._doFindNextMatchLineByLine = function (model, searchStart, searcher, captureMatches) {
        var lineCount = model.getLineCount();
        var startLineNumber = searchStart.lineNumber;
        // Look in first line
        var text = model.getLineContent(startLineNumber);
        var r = this._findFirstMatchInLine(searcher, text, startLineNumber, searchStart.column, captureMatches);
        if (r) {
            return r;
        }
        for (var i = 1; i <= lineCount; i++) {
            var lineIndex = (startLineNumber + i - 1) % lineCount;
            var text_3 = model.getLineContent(lineIndex + 1);
            var r_1 = this._findFirstMatchInLine(searcher, text_3, lineIndex + 1, 1, captureMatches);
            if (r_1) {
                return r_1;
            }
        }
        return null;
    };
    TextModelSearch._findFirstMatchInLine = function (searcher, text, lineNumber, fromColumn, captureMatches) {
        // Set regex to search from column
        searcher.reset(fromColumn - 1);
        var m = searcher.next(text);
        if (m) {
            return createFindMatch(new Range(lineNumber, m.index + 1, lineNumber, m.index + 1 + m[0].length), m, captureMatches);
        }
        return null;
    };
    TextModelSearch.findPreviousMatch = function (model, searchParams, searchStart, captureMatches) {
        var searchData = searchParams.parseSearchRequest();
        if (!searchData) {
            return null;
        }
        var searcher = new Searcher(searchData.wordSeparators, searchData.regex);
        if (searchData.regex.multiline) {
            return this._doFindPreviousMatchMultiline(model, searchStart, searcher, captureMatches);
        }
        return this._doFindPreviousMatchLineByLine(model, searchStart, searcher, captureMatches);
    };
    TextModelSearch._doFindPreviousMatchMultiline = function (model, searchStart, searcher, captureMatches) {
        var matches = this._doFindMatchesMultiline(model, new Range(1, 1, searchStart.lineNumber, searchStart.column), searcher, captureMatches, 10 * LIMIT_FIND_COUNT);
        if (matches.length > 0) {
            return matches[matches.length - 1];
        }
        var lineCount = model.getLineCount();
        if (searchStart.lineNumber !== lineCount || searchStart.column !== model.getLineMaxColumn(lineCount)) {
            // Try again with all content
            return this._doFindPreviousMatchMultiline(model, new Position(lineCount, model.getLineMaxColumn(lineCount)), searcher, captureMatches);
        }
        return null;
    };
    TextModelSearch._doFindPreviousMatchLineByLine = function (model, searchStart, searcher, captureMatches) {
        var lineCount = model.getLineCount();
        var startLineNumber = searchStart.lineNumber;
        // Look in first line
        var text = model.getLineContent(startLineNumber).substring(0, searchStart.column - 1);
        var r = this._findLastMatchInLine(searcher, text, startLineNumber, captureMatches);
        if (r) {
            return r;
        }
        for (var i = 1; i <= lineCount; i++) {
            var lineIndex = (lineCount + startLineNumber - i - 1) % lineCount;
            var text_4 = model.getLineContent(lineIndex + 1);
            var r_2 = this._findLastMatchInLine(searcher, text_4, lineIndex + 1, captureMatches);
            if (r_2) {
                return r_2;
            }
        }
        return null;
    };
    TextModelSearch._findLastMatchInLine = function (searcher, text, lineNumber, captureMatches) {
        var bestResult = null;
        var m;
        searcher.reset(0);
        while ((m = searcher.next(text))) {
            bestResult = createFindMatch(new Range(lineNumber, m.index + 1, lineNumber, m.index + 1 + m[0].length), m, captureMatches);
        }
        return bestResult;
    };
    return TextModelSearch;
}());
function leftIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength) {
    if (matchStartIndex === 0) {
        // Match starts at start of string
        return true;
    }
    var charBefore = text.charCodeAt(matchStartIndex - 1);
    if (wordSeparators.get(charBefore) !== 0 /* Regular */) {
        // The character before the match is a word separator
        return true;
    }
    if (charBefore === 13 /* CarriageReturn */ || charBefore === 10 /* LineFeed */) {
        // The character before the match is line break or carriage return.
        return true;
    }
    if (matchLength > 0) {
        var firstCharInMatch = text.charCodeAt(matchStartIndex);
        if (wordSeparators.get(firstCharInMatch) !== 0 /* Regular */) {
            // The first character inside the match is a word separator
            return true;
        }
    }
    return false;
}
function rightIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength) {
    if (matchStartIndex + matchLength === textLength) {
        // Match ends at end of string
        return true;
    }
    var charAfter = text.charCodeAt(matchStartIndex + matchLength);
    if (wordSeparators.get(charAfter) !== 0 /* Regular */) {
        // The character after the match is a word separator
        return true;
    }
    if (charAfter === 13 /* CarriageReturn */ || charAfter === 10 /* LineFeed */) {
        // The character after the match is line break or carriage return.
        return true;
    }
    if (matchLength > 0) {
        var lastCharInMatch = text.charCodeAt(matchStartIndex + matchLength - 1);
        if (wordSeparators.get(lastCharInMatch) !== 0 /* Regular */) {
            // The last character in the match is a word separator
            return true;
        }
    }
    return false;
}
function isValidMatch(wordSeparators, text, textLength, matchStartIndex, matchLength) {
    return (leftIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength)
        && rightIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength));
}
var Searcher = /** @class */ (function () {
    function Searcher(wordSeparators, searchRegex) {
        this._wordSeparators = wordSeparators;
        this._searchRegex = searchRegex;
        this._prevMatchStartIndex = -1;
        this._prevMatchLength = 0;
    }
    Searcher.prototype.reset = function (lastIndex) {
        this._searchRegex.lastIndex = lastIndex;
        this._prevMatchStartIndex = -1;
        this._prevMatchLength = 0;
    };
    Searcher.prototype.next = function (text) {
        var textLength = text.length;
        var m;
        do {
            if (this._prevMatchStartIndex + this._prevMatchLength === textLength) {
                // Reached the end of the line
                return null;
            }
            m = this._searchRegex.exec(text);
            if (!m) {
                return null;
            }
            var matchStartIndex = m.index;
            var matchLength = m[0].length;
            if (matchStartIndex === this._prevMatchStartIndex && matchLength === this._prevMatchLength) {
                // Exit early if the regex matches the same range twice
                return null;
            }
            this._prevMatchStartIndex = matchStartIndex;
            this._prevMatchLength = matchLength;
            if (!this._wordSeparators || isValidMatch(this._wordSeparators, text, textLength, matchStartIndex, matchLength)) {
                return m;
            }
        } while (m);
        return null;
    };
    return Searcher;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var TreeNode = /** @class */ (function () {
    function TreeNode(piece, color) {
        this.piece = piece;
        this.color = color;
        this.size_left = 0;
        this.lf_left = 0;
        this.parent = null;
        this.left = null;
        this.right = null;
    }
    TreeNode.prototype.next = function () {
        if (this.right !== SENTINEL$1) {
            return leftest$1(this.right);
        }
        var node = this;
        while (node.parent !== SENTINEL$1) {
            if (node.parent.left === node) {
                break;
            }
            node = node.parent;
        }
        if (node.parent === SENTINEL$1) {
            return SENTINEL$1;
        }
        else {
            return node.parent;
        }
    };
    TreeNode.prototype.prev = function () {
        if (this.left !== SENTINEL$1) {
            return righttest(this.left);
        }
        var node = this;
        while (node.parent !== SENTINEL$1) {
            if (node.parent.right === node) {
                break;
            }
            node = node.parent;
        }
        if (node.parent === SENTINEL$1) {
            return SENTINEL$1;
        }
        else {
            return node.parent;
        }
    };
    TreeNode.prototype.detach = function () {
        this.parent = null;
        this.left = null;
        this.right = null;
    };
    return TreeNode;
}());
var SENTINEL$1 = new TreeNode(null, 0 /* Black */);
SENTINEL$1.parent = SENTINEL$1;
SENTINEL$1.left = SENTINEL$1;
SENTINEL$1.right = SENTINEL$1;
SENTINEL$1.color = 0 /* Black */;
function leftest$1(node) {
    while (node.left !== SENTINEL$1) {
        node = node.left;
    }
    return node;
}
function righttest(node) {
    while (node.right !== SENTINEL$1) {
        node = node.right;
    }
    return node;
}
function calculateSize(node) {
    if (node === SENTINEL$1) {
        return 0;
    }
    return node.size_left + node.piece.length + calculateSize(node.right);
}
function calculateLF(node) {
    if (node === SENTINEL$1) {
        return 0;
    }
    return node.lf_left + node.piece.lineFeedCnt + calculateLF(node.right);
}
function resetSentinel$1() {
    SENTINEL$1.parent = SENTINEL$1;
}
function leftRotate$1(tree, x) {
    var y = x.right;
    // fix size_left
    y.size_left += x.size_left + (x.piece ? x.piece.length : 0);
    y.lf_left += x.lf_left + (x.piece ? x.piece.lineFeedCnt : 0);
    x.right = y.left;
    if (y.left !== SENTINEL$1) {
        y.left.parent = x;
    }
    y.parent = x.parent;
    if (x.parent === SENTINEL$1) {
        tree.root = y;
    }
    else if (x.parent.left === x) {
        x.parent.left = y;
    }
    else {
        x.parent.right = y;
    }
    y.left = x;
    x.parent = y;
}
function rightRotate$1(tree, y) {
    var x = y.left;
    y.left = x.right;
    if (x.right !== SENTINEL$1) {
        x.right.parent = y;
    }
    x.parent = y.parent;
    // fix size_left
    y.size_left -= x.size_left + (x.piece ? x.piece.length : 0);
    y.lf_left -= x.lf_left + (x.piece ? x.piece.lineFeedCnt : 0);
    if (y.parent === SENTINEL$1) {
        tree.root = x;
    }
    else if (y === y.parent.right) {
        y.parent.right = x;
    }
    else {
        y.parent.left = x;
    }
    x.right = y;
    y.parent = x;
}
function rbDelete(tree, z) {
    var x;
    var y;
    if (z.left === SENTINEL$1) {
        y = z;
        x = y.right;
    }
    else if (z.right === SENTINEL$1) {
        y = z;
        x = y.left;
    }
    else {
        y = leftest$1(z.right);
        x = y.right;
    }
    if (y === tree.root) {
        tree.root = x;
        // if x is null, we are removing the only node
        x.color = 0 /* Black */;
        z.detach();
        resetSentinel$1();
        tree.root.parent = SENTINEL$1;
        return;
    }
    var yWasRed = (y.color === 1 /* Red */);
    if (y === y.parent.left) {
        y.parent.left = x;
    }
    else {
        y.parent.right = x;
    }
    if (y === z) {
        x.parent = y.parent;
        recomputeTreeMetadata(tree, x);
    }
    else {
        if (y.parent === z) {
            x.parent = y;
        }
        else {
            x.parent = y.parent;
        }
        // as we make changes to x's hierarchy, update size_left of subtree first
        recomputeTreeMetadata(tree, x);
        y.left = z.left;
        y.right = z.right;
        y.parent = z.parent;
        y.color = z.color;
        if (z === tree.root) {
            tree.root = y;
        }
        else {
            if (z === z.parent.left) {
                z.parent.left = y;
            }
            else {
                z.parent.right = y;
            }
        }
        if (y.left !== SENTINEL$1) {
            y.left.parent = y;
        }
        if (y.right !== SENTINEL$1) {
            y.right.parent = y;
        }
        // update metadata
        // we replace z with y, so in this sub tree, the length change is z.item.length
        y.size_left = z.size_left;
        y.lf_left = z.lf_left;
        recomputeTreeMetadata(tree, y);
    }
    z.detach();
    if (x.parent.left === x) {
        var newSizeLeft = calculateSize(x);
        var newLFLeft = calculateLF(x);
        if (newSizeLeft !== x.parent.size_left || newLFLeft !== x.parent.lf_left) {
            var delta = newSizeLeft - x.parent.size_left;
            var lf_delta = newLFLeft - x.parent.lf_left;
            x.parent.size_left = newSizeLeft;
            x.parent.lf_left = newLFLeft;
            updateTreeMetadata(tree, x.parent, delta, lf_delta);
        }
    }
    recomputeTreeMetadata(tree, x.parent);
    if (yWasRed) {
        resetSentinel$1();
        return;
    }
    // RB-DELETE-FIXUP
    var w;
    while (x !== tree.root && x.color === 0 /* Black */) {
        if (x === x.parent.left) {
            w = x.parent.right;
            if (w.color === 1 /* Red */) {
                w.color = 0 /* Black */;
                x.parent.color = 1 /* Red */;
                leftRotate$1(tree, x.parent);
                w = x.parent.right;
            }
            if (w.left.color === 0 /* Black */ && w.right.color === 0 /* Black */) {
                w.color = 1 /* Red */;
                x = x.parent;
            }
            else {
                if (w.right.color === 0 /* Black */) {
                    w.left.color = 0 /* Black */;
                    w.color = 1 /* Red */;
                    rightRotate$1(tree, w);
                    w = x.parent.right;
                }
                w.color = x.parent.color;
                x.parent.color = 0 /* Black */;
                w.right.color = 0 /* Black */;
                leftRotate$1(tree, x.parent);
                x = tree.root;
            }
        }
        else {
            w = x.parent.left;
            if (w.color === 1 /* Red */) {
                w.color = 0 /* Black */;
                x.parent.color = 1 /* Red */;
                rightRotate$1(tree, x.parent);
                w = x.parent.left;
            }
            if (w.left.color === 0 /* Black */ && w.right.color === 0 /* Black */) {
                w.color = 1 /* Red */;
                x = x.parent;
            }
            else {
                if (w.left.color === 0 /* Black */) {
                    w.right.color = 0 /* Black */;
                    w.color = 1 /* Red */;
                    leftRotate$1(tree, w);
                    w = x.parent.left;
                }
                w.color = x.parent.color;
                x.parent.color = 0 /* Black */;
                w.left.color = 0 /* Black */;
                rightRotate$1(tree, x.parent);
                x = tree.root;
            }
        }
    }
    x.color = 0 /* Black */;
    resetSentinel$1();
}
function fixInsert(tree, x) {
    recomputeTreeMetadata(tree, x);
    while (x !== tree.root && x.parent.color === 1 /* Red */) {
        if (x.parent === x.parent.parent.left) {
            var y = x.parent.parent.right;
            if (y.color === 1 /* Red */) {
                x.parent.color = 0 /* Black */;
                y.color = 0 /* Black */;
                x.parent.parent.color = 1 /* Red */;
                x = x.parent.parent;
            }
            else {
                if (x === x.parent.right) {
                    x = x.parent;
                    leftRotate$1(tree, x);
                }
                x.parent.color = 0 /* Black */;
                x.parent.parent.color = 1 /* Red */;
                rightRotate$1(tree, x.parent.parent);
            }
        }
        else {
            var y = x.parent.parent.left;
            if (y.color === 1 /* Red */) {
                x.parent.color = 0 /* Black */;
                y.color = 0 /* Black */;
                x.parent.parent.color = 1 /* Red */;
                x = x.parent.parent;
            }
            else {
                if (x === x.parent.left) {
                    x = x.parent;
                    rightRotate$1(tree, x);
                }
                x.parent.color = 0 /* Black */;
                x.parent.parent.color = 1 /* Red */;
                leftRotate$1(tree, x.parent.parent);
            }
        }
    }
    tree.root.color = 0 /* Black */;
}
function updateTreeMetadata(tree, x, delta, lineFeedCntDelta) {
    // node length change or line feed count change
    while (x !== tree.root && x !== SENTINEL$1) {
        if (x.parent.left === x) {
            x.parent.size_left += delta;
            x.parent.lf_left += lineFeedCntDelta;
        }
        x = x.parent;
    }
}
function recomputeTreeMetadata(tree, x) {
    var delta = 0;
    var lf_delta = 0;
    if (x === tree.root) {
        return;
    }
    if (delta === 0) {
        // go upwards till the node whose left subtree is changed.
        while (x !== tree.root && x === x.parent.right) {
            x = x.parent;
        }
        if (x === tree.root) {
            // well, it means we add a node to the end (inorder)
            return;
        }
        // x is the node whose right subtree is changed.
        x = x.parent;
        delta = calculateSize(x.left) - x.size_left;
        lf_delta = calculateLF(x.left) - x.lf_left;
        x.size_left += delta;
        x.lf_left += lf_delta;
    }
    // go upwards till root. O(logN)
    while (x !== tree.root && (delta !== 0 || lf_delta !== 0)) {
        if (x.parent.left === x) {
            x.parent.size_left += delta;
            x.parent.lf_left += lf_delta;
        }
        x = x.parent;
    }
}

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// const lfRegex = new RegExp(/\r\n|\r|\n/g);
var AverageBufferSize = 65535;
function createUintArray(arr) {
    var r;
    if (arr[arr.length - 1] < 65536) {
        r = new Uint16Array(arr.length);
    }
    else {
        r = new Uint32Array(arr.length);
    }
    r.set(arr, 0);
    return r;
}
var LineStarts = /** @class */ (function () {
    function LineStarts(lineStarts, cr, lf, crlf, isBasicASCII$$1) {
        this.lineStarts = lineStarts;
        this.cr = cr;
        this.lf = lf;
        this.crlf = crlf;
        this.isBasicASCII = isBasicASCII$$1;
    }
    return LineStarts;
}());
function createLineStartsFast(str, readonly) {
    if (readonly === void 0) { readonly = true; }
    var r = [0], rLength = 1;
    for (var i = 0, len = str.length; i < len; i++) {
        var chr = str.charCodeAt(i);
        if (chr === 13 /* CarriageReturn */) {
            if (i + 1 < len && str.charCodeAt(i + 1) === 10 /* LineFeed */) {
                // \r\n... case
                r[rLength++] = i + 2;
                i++; // skip \n
            }
            else {
                // \r... case
                r[rLength++] = i + 1;
            }
        }
        else if (chr === 10 /* LineFeed */) {
            r[rLength++] = i + 1;
        }
    }
    if (readonly) {
        return createUintArray(r);
    }
    else {
        return r;
    }
}
function createLineStarts(r, str) {
    r.length = 0;
    r[0] = 0;
    var rLength = 1;
    var cr = 0, lf = 0, crlf = 0;
    var isBasicASCII$$1 = true;
    for (var i = 0, len = str.length; i < len; i++) {
        var chr = str.charCodeAt(i);
        if (chr === 13 /* CarriageReturn */) {
            if (i + 1 < len && str.charCodeAt(i + 1) === 10 /* LineFeed */) {
                // \r\n... case
                crlf++;
                r[rLength++] = i + 2;
                i++; // skip \n
            }
            else {
                cr++;
                // \r... case
                r[rLength++] = i + 1;
            }
        }
        else if (chr === 10 /* LineFeed */) {
            lf++;
            r[rLength++] = i + 1;
        }
        else {
            if (isBasicASCII$$1) {
                if (chr !== 9 /* Tab */ && (chr < 32 || chr > 126)) {
                    isBasicASCII$$1 = false;
                }
            }
        }
    }
    var result = new LineStarts(createUintArray(r), cr, lf, crlf, isBasicASCII$$1);
    r.length = 0;
    return result;
}
var Piece = /** @class */ (function () {
    function Piece(bufferIndex, start, end, lineFeedCnt, length) {
        this.bufferIndex = bufferIndex;
        this.start = start;
        this.end = end;
        this.lineFeedCnt = lineFeedCnt;
        this.length = length;
    }
    return Piece;
}());
var StringBuffer = /** @class */ (function () {
    function StringBuffer(buffer, lineStarts) {
        this.buffer = buffer;
        this.lineStarts = lineStarts;
    }
    return StringBuffer;
}());
/**
 * Readonly snapshot for piece tree.
 * In a real multiple thread environment, to make snapshot reading always work correctly, we need to
 * 1. Make TreeNode.piece immutable, then reading and writing can run in parallel.
 * 2. TreeNode/Buffers normalization should not happen during snapshot reading.
 */
var PieceTreeSnapshot = /** @class */ (function () {
    function PieceTreeSnapshot(tree, BOM) {
        var _this = this;
        this._pieces = [];
        this._tree = tree;
        this._BOM = BOM;
        this._index = 0;
        if (tree.root !== SENTINEL$1) {
            tree.iterate(tree.root, function (node) {
                if (node !== SENTINEL$1) {
                    _this._pieces.push(node.piece);
                }
                return true;
            });
        }
    }
    PieceTreeSnapshot.prototype.read = function () {
        if (this._pieces.length === 0) {
            if (this._index === 0) {
                this._index++;
                return this._BOM;
            }
            else {
                return null;
            }
        }
        if (this._index > this._pieces.length - 1) {
            return null;
        }
        if (this._index === 0) {
            return this._BOM + this._tree.getPieceContent(this._pieces[this._index++]);
        }
        return this._tree.getPieceContent(this._pieces[this._index++]);
    };
    return PieceTreeSnapshot;
}());
var PieceTreeSearchCache = /** @class */ (function () {
    function PieceTreeSearchCache(limit) {
        this._limit = limit;
        this._cache = [];
    }
    PieceTreeSearchCache.prototype.get = function (offset) {
        for (var i = this._cache.length - 1; i >= 0; i--) {
            var nodePos = this._cache[i];
            if (nodePos.nodeStartOffset <= offset && nodePos.nodeStartOffset + nodePos.node.piece.length >= offset) {
                return nodePos;
            }
        }
        return null;
    };
    PieceTreeSearchCache.prototype.get2 = function (lineNumber) {
        for (var i = this._cache.length - 1; i >= 0; i--) {
            var nodePos = this._cache[i];
            if (nodePos.nodeStartLineNumber && nodePos.nodeStartLineNumber < lineNumber && nodePos.nodeStartLineNumber + nodePos.node.piece.lineFeedCnt >= lineNumber) {
                return nodePos;
            }
        }
        return null;
    };
    PieceTreeSearchCache.prototype.set = function (nodePosition) {
        if (this._cache.length >= this._limit) {
            this._cache.shift();
        }
        this._cache.push(nodePosition);
    };
    PieceTreeSearchCache.prototype.valdiate = function (offset) {
        var hasInvalidVal = false;
        for (var i = 0; i < this._cache.length; i++) {
            var nodePos = this._cache[i];
            if (nodePos.node.parent === null || nodePos.nodeStartOffset >= offset) {
                this._cache[i] = null;
                hasInvalidVal = true;
                continue;
            }
        }
        if (hasInvalidVal) {
            var newArr = [];
            for (var i = 0; i < this._cache.length; i++) {
                if (this._cache[i] !== null) {
                    newArr.push(this._cache[i]);
                }
            }
            this._cache = newArr;
        }
    };
    return PieceTreeSearchCache;
}());
var PieceTreeBase = /** @class */ (function () {
    function PieceTreeBase(chunks, eol, eolNormalized) {
        this.create(chunks, eol, eolNormalized);
    }
    PieceTreeBase.prototype.create = function (chunks, eol, eolNormalized) {
        this._buffers = [
            new StringBuffer('', [0])
        ];
        this._lastChangeBufferPos = { line: 0, column: 0 };
        this.root = SENTINEL$1;
        this._lineCnt = 1;
        this._length = 0;
        this._EOL = eol;
        this._EOLLength = eol.length;
        this._EOLNormalized = eolNormalized;
        var lastNode = null;
        for (var i = 0, len = chunks.length; i < len; i++) {
            if (chunks[i].buffer.length > 0) {
                if (!chunks[i].lineStarts) {
                    chunks[i].lineStarts = createLineStartsFast(chunks[i].buffer);
                }
                var piece = new Piece(i + 1, { line: 0, column: 0 }, { line: chunks[i].lineStarts.length - 1, column: chunks[i].buffer.length - chunks[i].lineStarts[chunks[i].lineStarts.length - 1] }, chunks[i].lineStarts.length - 1, chunks[i].buffer.length);
                this._buffers.push(chunks[i]);
                lastNode = this.rbInsertRight(lastNode, piece);
            }
        }
        this._searchCache = new PieceTreeSearchCache(1);
        this._lastVisitedLine = { lineNumber: 0, value: null };
        this.computeBufferMetadata();
    };
    PieceTreeBase.prototype.normalizeEOL = function (eol) {
        var _this = this;
        var averageBufferSize = AverageBufferSize;
        var min = averageBufferSize - Math.floor(averageBufferSize / 3);
        var max = min * 2;
        var tempChunk = '';
        var tempChunkLen = 0;
        var chunks = [];
        this.iterate(this.root, function (node) {
            var str = _this.getNodeContent(node);
            var len = str.length;
            if (tempChunkLen <= min || tempChunkLen + len < max) {
                tempChunk += str;
                tempChunkLen += len;
                return true;
            }
            // flush anyways
            var text = tempChunk.replace(/\r\n|\r|\n/g, eol);
            chunks.push(new StringBuffer(text, createLineStartsFast(text)));
            tempChunk = str;
            tempChunkLen = len;
            return true;
        });
        if (tempChunkLen > 0) {
            var text = tempChunk.replace(/\r\n|\r|\n/g, eol);
            chunks.push(new StringBuffer(text, createLineStartsFast(text)));
        }
        this.create(chunks, eol, true);
    };
    // #region Buffer API
    PieceTreeBase.prototype.getEOL = function () {
        return this._EOL;
    };
    PieceTreeBase.prototype.setEOL = function (newEOL) {
        this._EOL = newEOL;
        this._EOLLength = this._EOL.length;
        this.normalizeEOL(newEOL);
    };
    PieceTreeBase.prototype.createSnapshot = function (BOM) {
        return new PieceTreeSnapshot(this, BOM);
    };
    PieceTreeBase.prototype.equal = function (other) {
        var _this = this;
        if (this.getLength() !== other.getLength()) {
            return false;
        }
        if (this.getLineCount() !== other.getLineCount()) {
            return false;
        }
        var offset = 0;
        var ret = this.iterate(this.root, function (node) {
            if (node === SENTINEL$1) {
                return true;
            }
            var str = _this.getNodeContent(node);
            var len = str.length;
            var startPosition = other.nodeAt(offset);
            var endPosition = other.nodeAt(offset + len);
            var val = other.getValueInRange2(startPosition, endPosition);
            return str === val;
        });
        return ret;
    };
    PieceTreeBase.prototype.getOffsetAt = function (lineNumber, column) {
        var leftLen = 0; // inorder
        var x = this.root;
        while (x !== SENTINEL$1) {
            if (x.left !== SENTINEL$1 && x.lf_left + 1 >= lineNumber) {
                x = x.left;
            }
            else if (x.lf_left + x.piece.lineFeedCnt + 1 >= lineNumber) {
                leftLen += x.size_left;
                // lineNumber >= 2
                var accumualtedValInCurrentIndex = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);
                return leftLen += accumualtedValInCurrentIndex + column - 1;
            }
            else {
                lineNumber -= x.lf_left + x.piece.lineFeedCnt;
                leftLen += x.size_left + x.piece.length;
                x = x.right;
            }
        }
        return leftLen;
    };
    PieceTreeBase.prototype.getPositionAt = function (offset) {
        offset = Math.floor(offset);
        offset = Math.max(0, offset);
        var x = this.root;
        var lfCnt = 0;
        var originalOffset = offset;
        while (x !== SENTINEL$1) {
            if (x.size_left !== 0 && x.size_left >= offset) {
                x = x.left;
            }
            else if (x.size_left + x.piece.length >= offset) {
                var out = this.getIndexOf(x, offset - x.size_left);
                lfCnt += x.lf_left + out.index;
                if (out.index === 0) {
                    var lineStartOffset = this.getOffsetAt(lfCnt + 1, 1);
                    var column = originalOffset - lineStartOffset;
                    return new Position(lfCnt + 1, column + 1);
                }
                return new Position(lfCnt + 1, out.remainder + 1);
            }
            else {
                offset -= x.size_left + x.piece.length;
                lfCnt += x.lf_left + x.piece.lineFeedCnt;
                if (x.right === SENTINEL$1) {
                    // last node
                    var lineStartOffset = this.getOffsetAt(lfCnt + 1, 1);
                    var column = originalOffset - offset - lineStartOffset;
                    return new Position(lfCnt + 1, column + 1);
                }
                else {
                    x = x.right;
                }
            }
        }
        return new Position(1, 1);
    };
    PieceTreeBase.prototype.getValueInRange = function (range, eol) {
        if (range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn) {
            return '';
        }
        var startPosition = this.nodeAt2(range.startLineNumber, range.startColumn);
        var endPosition = this.nodeAt2(range.endLineNumber, range.endColumn);
        var value = this.getValueInRange2(startPosition, endPosition);
        if (eol) {
            if (eol !== this._EOL || !this._EOLNormalized) {
                return value.replace(/\r\n|\r|\n/g, eol);
            }
            if (eol === this.getEOL() && this._EOLNormalized) {
                return value;
            }
            return value.replace(/\r\n|\r|\n/g, eol);
        }
        return value;
    };
    PieceTreeBase.prototype.getValueInRange2 = function (startPosition, endPosition) {
        if (startPosition.node === endPosition.node) {
            var node = startPosition.node;
            var buffer_1 = this._buffers[node.piece.bufferIndex].buffer;
            var startOffset_1 = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start);
            return buffer_1.substring(startOffset_1 + startPosition.remainder, startOffset_1 + endPosition.remainder);
        }
        var x = startPosition.node;
        var buffer = this._buffers[x.piece.bufferIndex].buffer;
        var startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);
        var ret = buffer.substring(startOffset + startPosition.remainder, startOffset + x.piece.length);
        x = x.next();
        while (x !== SENTINEL$1) {
            var buffer_2 = this._buffers[x.piece.bufferIndex].buffer;
            var startOffset_2 = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);
            if (x === endPosition.node) {
                ret += buffer_2.substring(startOffset_2, startOffset_2 + endPosition.remainder);
                break;
            }
            else {
                ret += buffer_2.substr(startOffset_2, x.piece.length);
            }
            x = x.next();
        }
        return ret;
    };
    PieceTreeBase.prototype.getLinesContent = function () {
        return this.getContentOfSubTree(this.root).split(/\r\n|\r|\n/);
    };
    PieceTreeBase.prototype.getLength = function () {
        return this._length;
    };
    PieceTreeBase.prototype.getLineCount = function () {
        return this._lineCnt;
    };
    PieceTreeBase.prototype.getLineContent = function (lineNumber) {
        if (this._lastVisitedLine.lineNumber === lineNumber) {
            return this._lastVisitedLine.value;
        }
        this._lastVisitedLine.lineNumber = lineNumber;
        if (lineNumber === this._lineCnt) {
            this._lastVisitedLine.value = this.getLineRawContent(lineNumber);
        }
        else if (this._EOLNormalized) {
            this._lastVisitedLine.value = this.getLineRawContent(lineNumber, this._EOLLength);
        }
        else {
            this._lastVisitedLine.value = this.getLineRawContent(lineNumber).replace(/(\r\n|\r|\n)$/, '');
        }
        return this._lastVisitedLine.value;
    };
    PieceTreeBase.prototype.getLineCharCode = function (lineNumber, index) {
        var nodePos = this.nodeAt2(lineNumber, index + 1);
        if (nodePos.remainder === nodePos.node.piece.length) {
            // the char we want to fetch is at the head of next node.
            var matchingNode = nodePos.node.next();
            if (!matchingNode) {
                return 0;
            }
            var buffer = this._buffers[matchingNode.piece.bufferIndex];
            var startOffset = this.offsetInBuffer(matchingNode.piece.bufferIndex, matchingNode.piece.start);
            return buffer.buffer.charCodeAt(startOffset);
        }
        else {
            var buffer = this._buffers[nodePos.node.piece.bufferIndex];
            var startOffset = this.offsetInBuffer(nodePos.node.piece.bufferIndex, nodePos.node.piece.start);
            var targetOffset = startOffset + nodePos.remainder;
            return buffer.buffer.charCodeAt(targetOffset);
        }
    };
    PieceTreeBase.prototype.getLineLength = function (lineNumber) {
        if (lineNumber === this.getLineCount()) {
            var startOffset = this.getOffsetAt(lineNumber, 1);
            return this.getLength() - startOffset;
        }
        return this.getOffsetAt(lineNumber + 1, 1) - this.getOffsetAt(lineNumber, 1) - this._EOLLength;
    };
    PieceTreeBase.prototype.findMatchesInNode = function (node, searcher, startLineNumber, startColumn, startCursor, endCursor, searchData, captureMatches, limitResultCount, resultLen, result) {
        var buffer = this._buffers[node.piece.bufferIndex];
        var startOffsetInBuffer = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start);
        var start = this.offsetInBuffer(node.piece.bufferIndex, startCursor);
        var end = this.offsetInBuffer(node.piece.bufferIndex, endCursor);
        var m;
        // Reset regex to search from the beginning
        searcher.reset(start);
        var ret = { line: 0, column: 0 };
        do {
            m = searcher.next(buffer.buffer);
            if (m) {
                if (m.index >= end) {
                    return resultLen;
                }
                this.positionInBuffer(node, m.index - startOffsetInBuffer, ret);
                var lineFeedCnt = this.getLineFeedCnt(node.piece.bufferIndex, startCursor, ret);
                var retStartColumn = ret.line === startCursor.line ? ret.column - startCursor.column + startColumn : ret.column + 1;
                var retEndColumn = retStartColumn + m[0].length;
                result[resultLen++] = createFindMatch(new Range(startLineNumber + lineFeedCnt, retStartColumn, startLineNumber + lineFeedCnt, retEndColumn), m, captureMatches);
                if (m.index + m[0].length >= end) {
                    return resultLen;
                }
                if (resultLen >= limitResultCount) {
                    return resultLen;
                }
            }
        } while (m);
        return resultLen;
    };
    PieceTreeBase.prototype.findMatchesLineByLine = function (searchRange, searchData, captureMatches, limitResultCount) {
        var result = [];
        var resultLen = 0;
        var searcher = new Searcher(searchData.wordSeparators, searchData.regex);
        var startPostion = this.nodeAt2(searchRange.startLineNumber, searchRange.startColumn);
        if (startPostion === null) {
            return [];
        }
        var endPosition = this.nodeAt2(searchRange.endLineNumber, searchRange.endColumn);
        if (endPosition === null) {
            return [];
        }
        var start = this.positionInBuffer(startPostion.node, startPostion.remainder);
        var end = this.positionInBuffer(endPosition.node, endPosition.remainder);
        if (startPostion.node === endPosition.node) {
            this.findMatchesInNode(startPostion.node, searcher, searchRange.startLineNumber, searchRange.startColumn, start, end, searchData, captureMatches, limitResultCount, resultLen, result);
            return result;
        }
        var startLineNumber = searchRange.startLineNumber;
        var currentNode = startPostion.node;
        while (currentNode !== endPosition.node) {
            var lineBreakCnt = this.getLineFeedCnt(currentNode.piece.bufferIndex, start, currentNode.piece.end);
            if (lineBreakCnt >= 1) {
                // last line break position
                var lineStarts = this._buffers[currentNode.piece.bufferIndex].lineStarts;
                var startOffsetInBuffer = this.offsetInBuffer(currentNode.piece.bufferIndex, currentNode.piece.start);
                var nextLineStartOffset = lineStarts[start.line + lineBreakCnt];
                var startColumn_1 = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn : 1;
                resultLen = this.findMatchesInNode(currentNode, searcher, startLineNumber, startColumn_1, start, this.positionInBuffer(currentNode, nextLineStartOffset - startOffsetInBuffer), searchData, captureMatches, limitResultCount, resultLen, result);
                if (resultLen >= limitResultCount) {
                    return result;
                }
                startLineNumber += lineBreakCnt;
            }
            var startColumn_2 = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn - 1 : 0;
            // search for the remaining content
            if (startLineNumber === searchRange.endLineNumber) {
                var text = this.getLineContent(startLineNumber).substring(startColumn_2, searchRange.endColumn - 1);
                resultLen = this._findMatchesInLine(searchData, searcher, text, searchRange.endLineNumber, startColumn_2, resultLen, result, captureMatches, limitResultCount);
                return result;
            }
            resultLen = this._findMatchesInLine(searchData, searcher, this.getLineContent(startLineNumber).substr(startColumn_2), startLineNumber, startColumn_2, resultLen, result, captureMatches, limitResultCount);
            if (resultLen >= limitResultCount) {
                return result;
            }
            startLineNumber++;
            startPostion = this.nodeAt2(startLineNumber, 1);
            currentNode = startPostion.node;
            start = this.positionInBuffer(startPostion.node, startPostion.remainder);
        }
        if (startLineNumber === searchRange.endLineNumber) {
            var startColumn_3 = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn - 1 : 0;
            var text = this.getLineContent(startLineNumber).substring(startColumn_3, searchRange.endColumn - 1);
            resultLen = this._findMatchesInLine(searchData, searcher, text, searchRange.endLineNumber, startColumn_3, resultLen, result, captureMatches, limitResultCount);
            return result;
        }
        var startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn : 1;
        resultLen = this.findMatchesInNode(endPosition.node, searcher, startLineNumber, startColumn, start, end, searchData, captureMatches, limitResultCount, resultLen, result);
        return result;
    };
    PieceTreeBase.prototype._findMatchesInLine = function (searchData, searcher, text, lineNumber, deltaOffset, resultLen, result, captureMatches, limitResultCount) {
        var wordSeparators = searchData.wordSeparators;
        if (!captureMatches && searchData.simpleSearch) {
            var searchString = searchData.simpleSearch;
            var searchStringLen = searchString.length;
            var textLength = text.length;
            var lastMatchIndex = -searchStringLen;
            while ((lastMatchIndex = text.indexOf(searchString, lastMatchIndex + searchStringLen)) !== -1) {
                if (!wordSeparators || isValidMatch(wordSeparators, text, textLength, lastMatchIndex, searchStringLen)) {
                    result[resultLen++] = new FindMatch(new Range(lineNumber, lastMatchIndex + 1 + deltaOffset, lineNumber, lastMatchIndex + 1 + searchStringLen + deltaOffset), null);
                    if (resultLen >= limitResultCount) {
                        return resultLen;
                    }
                }
            }
            return resultLen;
        }
        var m;
        // Reset regex to search from the beginning
        searcher.reset(0);
        do {
            m = searcher.next(text);
            if (m) {
                result[resultLen++] = createFindMatch(new Range(lineNumber, m.index + 1 + deltaOffset, lineNumber, m.index + 1 + m[0].length + deltaOffset), m, captureMatches);
                if (resultLen >= limitResultCount) {
                    return resultLen;
                }
            }
        } while (m);
        return resultLen;
    };
    // #endregion
    // #region Piece Table
    PieceTreeBase.prototype.insert = function (offset, value, eolNormalized) {
        if (eolNormalized === void 0) { eolNormalized = false; }
        this._EOLNormalized = this._EOLNormalized && eolNormalized;
        this._lastVisitedLine.lineNumber = 0;
        this._lastVisitedLine.value = null;
        if (this.root !== SENTINEL$1) {
            var _a = this.nodeAt(offset), node = _a.node, remainder = _a.remainder, nodeStartOffset = _a.nodeStartOffset;
            var piece = node.piece;
            var bufferIndex = piece.bufferIndex;
            var insertPosInBuffer = this.positionInBuffer(node, remainder);
            if (node.piece.bufferIndex === 0 &&
                piece.end.line === this._lastChangeBufferPos.line &&
                piece.end.column === this._lastChangeBufferPos.column &&
                (nodeStartOffset + piece.length === offset) &&
                value.length < AverageBufferSize) {
                // changed buffer
                this.appendToNode(node, value);
                this.computeBufferMetadata();
                return;
            }
            if (nodeStartOffset === offset) {
                this.insertContentToNodeLeft(value, node);
                this._searchCache.valdiate(offset);
            }
            else if (nodeStartOffset + node.piece.length > offset) {
                // we are inserting into the middle of a node.
                var nodesToDel = [];
                var newRightPiece = new Piece(piece.bufferIndex, insertPosInBuffer, piece.end, this.getLineFeedCnt(piece.bufferIndex, insertPosInBuffer, piece.end), this.offsetInBuffer(bufferIndex, piece.end) - this.offsetInBuffer(bufferIndex, insertPosInBuffer));
                if (this.shouldCheckCRLF() && this.endWithCR(value)) {
                    var headOfRight = this.nodeCharCodeAt(node, remainder);
                    if (headOfRight === 10 /** \n */) {
                        var newStart = { line: newRightPiece.start.line + 1, column: 0 };
                        newRightPiece = new Piece(newRightPiece.bufferIndex, newStart, newRightPiece.end, this.getLineFeedCnt(newRightPiece.bufferIndex, newStart, newRightPiece.end), newRightPiece.length - 1);
                        value += '\n';
                    }
                }
                // reuse node for content before insertion point.
                if (this.shouldCheckCRLF() && this.startWithLF(value)) {
                    var tailOfLeft = this.nodeCharCodeAt(node, remainder - 1);
                    if (tailOfLeft === 13 /** \r */) {
                        var previousPos = this.positionInBuffer(node, remainder - 1);
                        this.deleteNodeTail(node, previousPos);
                        value = '\r' + value;
                        if (node.piece.length === 0) {
                            nodesToDel.push(node);
                        }
                    }
                    else {
                        this.deleteNodeTail(node, insertPosInBuffer);
                    }
                }
                else {
                    this.deleteNodeTail(node, insertPosInBuffer);
                }
                var newPieces = this.createNewPieces(value);
                if (newRightPiece.length > 0) {
                    this.rbInsertRight(node, newRightPiece);
                }
                var tmpNode = node;
                for (var k = 0; k < newPieces.length; k++) {
                    tmpNode = this.rbInsertRight(tmpNode, newPieces[k]);
                }
                this.deleteNodes(nodesToDel);
            }
            else {
                this.insertContentToNodeRight(value, node);
            }
        }
        else {
            // insert new node
            var pieces = this.createNewPieces(value);
            var node = this.rbInsertLeft(null, pieces[0]);
            for (var k = 1; k < pieces.length; k++) {
                node = this.rbInsertRight(node, pieces[k]);
            }
        }
        // todo, this is too brutal. Total line feed count should be updated the same way as lf_left.
        this.computeBufferMetadata();
    };
    PieceTreeBase.prototype.delete = function (offset, cnt) {
        this._lastVisitedLine.lineNumber = 0;
        this._lastVisitedLine.value = null;
        if (cnt <= 0 || this.root === SENTINEL$1) {
            return;
        }
        var startPosition = this.nodeAt(offset);
        var endPosition = this.nodeAt(offset + cnt);
        var startNode = startPosition.node;
        var endNode = endPosition.node;
        if (startNode === endNode) {
            var startSplitPosInBuffer_1 = this.positionInBuffer(startNode, startPosition.remainder);
            var endSplitPosInBuffer_1 = this.positionInBuffer(startNode, endPosition.remainder);
            if (startPosition.nodeStartOffset === offset) {
                if (cnt === startNode.piece.length) { // delete node
                    var next = startNode.next();
                    rbDelete(this, startNode);
                    this.validateCRLFWithPrevNode(next);
                    this.computeBufferMetadata();
                    return;
                }
                this.deleteNodeHead(startNode, endSplitPosInBuffer_1);
                this._searchCache.valdiate(offset);
                this.validateCRLFWithPrevNode(startNode);
                this.computeBufferMetadata();
                return;
            }
            if (startPosition.nodeStartOffset + startNode.piece.length === offset + cnt) {
                this.deleteNodeTail(startNode, startSplitPosInBuffer_1);
                this.validateCRLFWithNextNode(startNode);
                this.computeBufferMetadata();
                return;
            }
            // delete content in the middle, this node will be splitted to nodes
            this.shrinkNode(startNode, startSplitPosInBuffer_1, endSplitPosInBuffer_1);
            this.computeBufferMetadata();
            return;
        }
        var nodesToDel = [];
        var startSplitPosInBuffer = this.positionInBuffer(startNode, startPosition.remainder);
        this.deleteNodeTail(startNode, startSplitPosInBuffer);
        this._searchCache.valdiate(offset);
        if (startNode.piece.length === 0) {
            nodesToDel.push(startNode);
        }
        // update last touched node
        var endSplitPosInBuffer = this.positionInBuffer(endNode, endPosition.remainder);
        this.deleteNodeHead(endNode, endSplitPosInBuffer);
        if (endNode.piece.length === 0) {
            nodesToDel.push(endNode);
        }
        // delete nodes in between
        var secondNode = startNode.next();
        for (var node = secondNode; node !== SENTINEL$1 && node !== endNode; node = node.next()) {
            nodesToDel.push(node);
        }
        var prev = startNode.piece.length === 0 ? startNode.prev() : startNode;
        this.deleteNodes(nodesToDel);
        this.validateCRLFWithNextNode(prev);
        this.computeBufferMetadata();
    };
    PieceTreeBase.prototype.insertContentToNodeLeft = function (value, node) {
        // we are inserting content to the beginning of node
        var nodesToDel = [];
        if (this.shouldCheckCRLF() && this.endWithCR(value) && this.startWithLF(node)) {
            // move `\n` to new node.
            var piece = node.piece;
            var newStart = { line: piece.start.line + 1, column: 0 };
            var nPiece = new Piece(piece.bufferIndex, newStart, piece.end, this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end), piece.length - 1);
            node.piece = nPiece;
            value += '\n';
            updateTreeMetadata(this, node, -1, -1);
            if (node.piece.length === 0) {
                nodesToDel.push(node);
            }
        }
        var newPieces = this.createNewPieces(value);
        var newNode = this.rbInsertLeft(node, newPieces[newPieces.length - 1]);
        for (var k = newPieces.length - 2; k >= 0; k--) {
            newNode = this.rbInsertLeft(newNode, newPieces[k]);
        }
        this.validateCRLFWithPrevNode(newNode);
        this.deleteNodes(nodesToDel);
    };
    PieceTreeBase.prototype.insertContentToNodeRight = function (value, node) {
        // we are inserting to the right of this node.
        if (this.adjustCarriageReturnFromNext(value, node)) {
            // move \n to the new node.
            value += '\n';
        }
        var newPieces = this.createNewPieces(value);
        var newNode = this.rbInsertRight(node, newPieces[0]);
        var tmpNode = newNode;
        for (var k = 1; k < newPieces.length; k++) {
            tmpNode = this.rbInsertRight(tmpNode, newPieces[k]);
        }
        this.validateCRLFWithPrevNode(newNode);
    };
    PieceTreeBase.prototype.positionInBuffer = function (node, remainder, ret) {
        var piece = node.piece;
        var bufferIndex = node.piece.bufferIndex;
        var lineStarts = this._buffers[bufferIndex].lineStarts;
        var startOffset = lineStarts[piece.start.line] + piece.start.column;
        var offset = startOffset + remainder;
        // binary search offset between startOffset and endOffset
        var low = piece.start.line;
        var high = piece.end.line;
        var mid;
        var midStop;
        var midStart;
        while (low <= high) {
            mid = low + ((high - low) / 2) | 0;
            midStart = lineStarts[mid];
            if (mid === high) {
                break;
            }
            midStop = lineStarts[mid + 1];
            if (offset < midStart) {
                high = mid - 1;
            }
            else if (offset >= midStop) {
                low = mid + 1;
            }
            else {
                break;
            }
        }
        if (ret) {
            ret.line = mid;
            ret.column = offset - midStart;
            return null;
        }
        return {
            line: mid,
            column: offset - midStart
        };
    };
    PieceTreeBase.prototype.getLineFeedCnt = function (bufferIndex, start, end) {
        // we don't need to worry about start: abc\r|\n, or abc|\r, or abc|\n, or abc|\r\n doesn't change the fact that, there is one line break after start.
        // now let's take care of end: abc\r|\n, if end is in between \r and \n, we need to add line feed count by 1
        if (end.column === 0) {
            return end.line - start.line;
        }
        var lineStarts = this._buffers[bufferIndex].lineStarts;
        if (end.line === lineStarts.length - 1) { // it means, there is no \n after end, otherwise, there will be one more lineStart.
            return end.line - start.line;
        }
        var nextLineStartOffset = lineStarts[end.line + 1];
        var endOffset = lineStarts[end.line] + end.column;
        if (nextLineStartOffset > endOffset + 1) { // there are more than 1 character after end, which means it can't be \n
            return end.line - start.line;
        }
        // endOffset + 1 === nextLineStartOffset
        // character at endOffset is \n, so we check the character before first
        // if character at endOffset is \r, end.column is 0 and we can't get here.
        var previousCharOffset = endOffset - 1; // end.column > 0 so it's okay.
        var buffer = this._buffers[bufferIndex].buffer;
        if (buffer.charCodeAt(previousCharOffset) === 13) {
            return end.line - start.line + 1;
        }
        else {
            return end.line - start.line;
        }
    };
    PieceTreeBase.prototype.offsetInBuffer = function (bufferIndex, cursor) {
        var lineStarts = this._buffers[bufferIndex].lineStarts;
        return lineStarts[cursor.line] + cursor.column;
    };
    PieceTreeBase.prototype.deleteNodes = function (nodes) {
        for (var i = 0; i < nodes.length; i++) {
            rbDelete(this, nodes[i]);
        }
    };
    PieceTreeBase.prototype.createNewPieces = function (text) {
        if (text.length > AverageBufferSize) {
            // the content is large, operations like substring, charCode becomes slow
            // so here we split it into smaller chunks, just like what we did for CR/LF normalization
            var newPieces = [];
            while (text.length > AverageBufferSize) {
                var lastChar = text.charCodeAt(AverageBufferSize - 1);
                var splitText = void 0;
                if (lastChar === 13 /* CarriageReturn */ || (lastChar >= 0xd800 && lastChar <= 0xdbff)) {
                    // last character is \r or a high surrogate => keep it back
                    splitText = text.substring(0, AverageBufferSize - 1);
                    text = text.substring(AverageBufferSize - 1);
                }
                else {
                    splitText = text.substring(0, AverageBufferSize);
                    text = text.substring(AverageBufferSize);
                }
                var lineStarts_1 = createLineStartsFast(splitText);
                newPieces.push(new Piece(this._buffers.length, /* buffer index */ { line: 0, column: 0 }, { line: lineStarts_1.length - 1, column: splitText.length - lineStarts_1[lineStarts_1.length - 1] }, lineStarts_1.length - 1, splitText.length));
                this._buffers.push(new StringBuffer(splitText, lineStarts_1));
            }
            var lineStarts_2 = createLineStartsFast(text);
            newPieces.push(new Piece(this._buffers.length, /* buffer index */ { line: 0, column: 0 }, { line: lineStarts_2.length - 1, column: text.length - lineStarts_2[lineStarts_2.length - 1] }, lineStarts_2.length - 1, text.length));
            this._buffers.push(new StringBuffer(text, lineStarts_2));
            return newPieces;
        }
        var startOffset = this._buffers[0].buffer.length;
        var lineStarts = createLineStartsFast(text, false);
        var start = this._lastChangeBufferPos;
        if (this._buffers[0].lineStarts[this._buffers[0].lineStarts.length - 1] === startOffset
            && startOffset !== 0
            && this.startWithLF(text)
            && this.endWithCR(this._buffers[0].buffer) // todo, we can check this._lastChangeBufferPos's column as it's the last one
        ) {
            this._lastChangeBufferPos = { line: this._lastChangeBufferPos.line, column: this._lastChangeBufferPos.column + 1 };
            start = this._lastChangeBufferPos;
            for (var i = 0; i < lineStarts.length; i++) {
                lineStarts[i] += startOffset + 1;
            }
            this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(lineStarts.slice(1));
            this._buffers[0].buffer += '_' + text;
            startOffset += 1;
        }
        else {
            if (startOffset !== 0) {
                for (var i = 0; i < lineStarts.length; i++) {
                    lineStarts[i] += startOffset;
                }
            }
            this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(lineStarts.slice(1));
            this._buffers[0].buffer += text;
        }
        var endOffset = this._buffers[0].buffer.length;
        var endIndex = this._buffers[0].lineStarts.length - 1;
        var endColumn = endOffset - this._buffers[0].lineStarts[endIndex];
        var endPos = { line: endIndex, column: endColumn };
        var newPiece = new Piece(0, /** todo */ start, endPos, this.getLineFeedCnt(0, start, endPos), endOffset - startOffset);
        this._lastChangeBufferPos = endPos;
        return [newPiece];
    };
    PieceTreeBase.prototype.getLinesRawContent = function () {
        return this.getContentOfSubTree(this.root);
    };
    PieceTreeBase.prototype.getLineRawContent = function (lineNumber, endOffset) {
        if (endOffset === void 0) { endOffset = 0; }
        var x = this.root;
        var ret = '';
        var cache = this._searchCache.get2(lineNumber);
        if (cache) {
            x = cache.node;
            var prevAccumualtedValue = this.getAccumulatedValue(x, lineNumber - cache.nodeStartLineNumber - 1);
            var buffer = this._buffers[x.piece.bufferIndex].buffer;
            var startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);
            if (cache.nodeStartLineNumber + x.piece.lineFeedCnt === lineNumber) {
                ret = buffer.substring(startOffset + prevAccumualtedValue, startOffset + x.piece.length);
            }
            else {
                var accumualtedValue = this.getAccumulatedValue(x, lineNumber - cache.nodeStartLineNumber);
                return buffer.substring(startOffset + prevAccumualtedValue, startOffset + accumualtedValue - endOffset);
            }
        }
        else {
            var nodeStartOffset = 0;
            var originalLineNumber = lineNumber;
            while (x !== SENTINEL$1) {
                if (x.left !== SENTINEL$1 && x.lf_left >= lineNumber - 1) {
                    x = x.left;
                }
                else if (x.lf_left + x.piece.lineFeedCnt > lineNumber - 1) {
                    var prevAccumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);
                    var accumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 1);
                    var buffer = this._buffers[x.piece.bufferIndex].buffer;
                    var startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);
                    nodeStartOffset += x.size_left;
                    this._searchCache.set({
                        node: x,
                        nodeStartOffset: nodeStartOffset,
                        nodeStartLineNumber: originalLineNumber - (lineNumber - 1 - x.lf_left)
                    });
                    return buffer.substring(startOffset + prevAccumualtedValue, startOffset + accumualtedValue - endOffset);
                }
                else if (x.lf_left + x.piece.lineFeedCnt === lineNumber - 1) {
                    var prevAccumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);
                    var buffer = this._buffers[x.piece.bufferIndex].buffer;
                    var startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);
                    ret = buffer.substring(startOffset + prevAccumualtedValue, startOffset + x.piece.length);
                    break;
                }
                else {
                    lineNumber -= x.lf_left + x.piece.lineFeedCnt;
                    nodeStartOffset += x.size_left + x.piece.length;
                    x = x.right;
                }
            }
        }
        // search in order, to find the node contains end column
        x = x.next();
        while (x !== SENTINEL$1) {
            var buffer = this._buffers[x.piece.bufferIndex].buffer;
            if (x.piece.lineFeedCnt > 0) {
                var accumualtedValue = this.getAccumulatedValue(x, 0);
                var startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);
                ret += buffer.substring(startOffset, startOffset + accumualtedValue - endOffset);
                return ret;
            }
            else {
                var startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);
                ret += buffer.substr(startOffset, x.piece.length);
            }
            x = x.next();
        }
        return ret;
    };
    PieceTreeBase.prototype.computeBufferMetadata = function () {
        var x = this.root;
        var lfCnt = 1;
        var len = 0;
        while (x !== SENTINEL$1) {
            lfCnt += x.lf_left + x.piece.lineFeedCnt;
            len += x.size_left + x.piece.length;
            x = x.right;
        }
        this._lineCnt = lfCnt;
        this._length = len;
        this._searchCache.valdiate(this._length);
    };
    // #region node operations
    PieceTreeBase.prototype.getIndexOf = function (node, accumulatedValue) {
        var piece = node.piece;
        var pos = this.positionInBuffer(node, accumulatedValue);
        var lineCnt = pos.line - piece.start.line;
        if (this.offsetInBuffer(piece.bufferIndex, piece.end) - this.offsetInBuffer(piece.bufferIndex, piece.start) === accumulatedValue) {
            // we are checking the end of this node, so a CRLF check is necessary.
            var realLineCnt = this.getLineFeedCnt(node.piece.bufferIndex, piece.start, pos);
            if (realLineCnt !== lineCnt) {
                // aha yes, CRLF
                return { index: realLineCnt, remainder: 0 };
            }
        }
        return { index: lineCnt, remainder: pos.column };
    };
    PieceTreeBase.prototype.getAccumulatedValue = function (node, index) {
        if (index < 0) {
            return 0;
        }
        var piece = node.piece;
        var lineStarts = this._buffers[piece.bufferIndex].lineStarts;
        var expectedLineStartIndex = piece.start.line + index + 1;
        if (expectedLineStartIndex > piece.end.line) {
            return lineStarts[piece.end.line] + piece.end.column - lineStarts[piece.start.line] - piece.start.column;
        }
        else {
            return lineStarts[expectedLineStartIndex] - lineStarts[piece.start.line] - piece.start.column;
        }
    };
    PieceTreeBase.prototype.deleteNodeTail = function (node, pos) {
        var piece = node.piece;
        var originalLFCnt = piece.lineFeedCnt;
        var originalEndOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);
        var newEnd = pos;
        var newEndOffset = this.offsetInBuffer(piece.bufferIndex, newEnd);
        var newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, piece.start, newEnd);
        var lf_delta = newLineFeedCnt - originalLFCnt;
        var size_delta = newEndOffset - originalEndOffset;
        var newLength = piece.length + size_delta;
        node.piece = new Piece(piece.bufferIndex, piece.start, newEnd, newLineFeedCnt, newLength);
        updateTreeMetadata(this, node, size_delta, lf_delta);
    };
    PieceTreeBase.prototype.deleteNodeHead = function (node, pos) {
        var piece = node.piece;
        var originalLFCnt = piece.lineFeedCnt;
        var originalStartOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);
        var newStart = pos;
        var newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end);
        var newStartOffset = this.offsetInBuffer(piece.bufferIndex, newStart);
        var lf_delta = newLineFeedCnt - originalLFCnt;
        var size_delta = originalStartOffset - newStartOffset;
        var newLength = piece.length + size_delta;
        node.piece = new Piece(piece.bufferIndex, newStart, piece.end, newLineFeedCnt, newLength);
        updateTreeMetadata(this, node, size_delta, lf_delta);
    };
    PieceTreeBase.prototype.shrinkNode = function (node, start, end) {
        var piece = node.piece;
        var originalStartPos = piece.start;
        var originalEndPos = piece.end;
        // old piece, originalStartPos, start
        var oldLength = piece.length;
        var oldLFCnt = piece.lineFeedCnt;
        var newEnd = start;
        var newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, piece.start, newEnd);
        var newLength = this.offsetInBuffer(piece.bufferIndex, start) - this.offsetInBuffer(piece.bufferIndex, originalStartPos);
        node.piece = new Piece(piece.bufferIndex, piece.start, newEnd, newLineFeedCnt, newLength);
        updateTreeMetadata(this, node, newLength - oldLength, newLineFeedCnt - oldLFCnt);
        // new right piece, end, originalEndPos
        var newPiece = new Piece(piece.bufferIndex, end, originalEndPos, this.getLineFeedCnt(piece.bufferIndex, end, originalEndPos), this.offsetInBuffer(piece.bufferIndex, originalEndPos) - this.offsetInBuffer(piece.bufferIndex, end));
        var newNode = this.rbInsertRight(node, newPiece);
        this.validateCRLFWithPrevNode(newNode);
    };
    PieceTreeBase.prototype.appendToNode = function (node, value) {
        if (this.adjustCarriageReturnFromNext(value, node)) {
            value += '\n';
        }
        var hitCRLF = this.shouldCheckCRLF() && this.startWithLF(value) && this.endWithCR(node);
        var startOffset = this._buffers[0].buffer.length;
        this._buffers[0].buffer += value;
        var lineStarts = createLineStartsFast(value, false);
        for (var i = 0; i < lineStarts.length; i++) {
            lineStarts[i] += startOffset;
        }
        if (hitCRLF) {
            var prevStartOffset = this._buffers[0].lineStarts[this._buffers[0].lineStarts.length - 2];
            this._buffers[0].lineStarts.pop();
            // _lastChangeBufferPos is already wrong
            this._lastChangeBufferPos = { line: this._lastChangeBufferPos.line - 1, column: startOffset - prevStartOffset };
        }
        this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(lineStarts.slice(1));
        var endIndex = this._buffers[0].lineStarts.length - 1;
        var endColumn = this._buffers[0].buffer.length - this._buffers[0].lineStarts[endIndex];
        var newEnd = { line: endIndex, column: endColumn };
        var newLength = node.piece.length + value.length;
        var oldLineFeedCnt = node.piece.lineFeedCnt;
        var newLineFeedCnt = this.getLineFeedCnt(0, node.piece.start, newEnd);
        var lf_delta = newLineFeedCnt - oldLineFeedCnt;
        node.piece = new Piece(node.piece.bufferIndex, node.piece.start, newEnd, newLineFeedCnt, newLength);
        this._lastChangeBufferPos = newEnd;
        updateTreeMetadata(this, node, value.length, lf_delta);
    };
    PieceTreeBase.prototype.nodeAt = function (offset) {
        var x = this.root;
        var cache = this._searchCache.get(offset);
        if (cache) {
            return {
                node: cache.node,
                nodeStartOffset: cache.nodeStartOffset,
                remainder: offset - cache.nodeStartOffset
            };
        }
        var nodeStartOffset = 0;
        while (x !== SENTINEL$1) {
            if (x.size_left > offset) {
                x = x.left;
            }
            else if (x.size_left + x.piece.length >= offset) {
                nodeStartOffset += x.size_left;
                var ret = {
                    node: x,
                    remainder: offset - x.size_left,
                    nodeStartOffset: nodeStartOffset
                };
                this._searchCache.set(ret);
                return ret;
            }
            else {
                offset -= x.size_left + x.piece.length;
                nodeStartOffset += x.size_left + x.piece.length;
                x = x.right;
            }
        }
        return null;
    };
    PieceTreeBase.prototype.nodeAt2 = function (lineNumber, column) {
        var x = this.root;
        var nodeStartOffset = 0;
        while (x !== SENTINEL$1) {
            if (x.left !== SENTINEL$1 && x.lf_left >= lineNumber - 1) {
                x = x.left;
            }
            else if (x.lf_left + x.piece.lineFeedCnt > lineNumber - 1) {
                var prevAccumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);
                var accumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 1);
                nodeStartOffset += x.size_left;
                return {
                    node: x,
                    remainder: Math.min(prevAccumualtedValue + column - 1, accumualtedValue),
                    nodeStartOffset: nodeStartOffset
                };
            }
            else if (x.lf_left + x.piece.lineFeedCnt === lineNumber - 1) {
                var prevAccumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);
                if (prevAccumualtedValue + column - 1 <= x.piece.length) {
                    return {
                        node: x,
                        remainder: prevAccumualtedValue + column - 1,
                        nodeStartOffset: nodeStartOffset
                    };
                }
                else {
                    column -= x.piece.length - prevAccumualtedValue;
                    break;
                }
            }
            else {
                lineNumber -= x.lf_left + x.piece.lineFeedCnt;
                nodeStartOffset += x.size_left + x.piece.length;
                x = x.right;
            }
        }
        // search in order, to find the node contains position.column
        x = x.next();
        while (x !== SENTINEL$1) {
            if (x.piece.lineFeedCnt > 0) {
                var accumualtedValue = this.getAccumulatedValue(x, 0);
                var nodeStartOffset_1 = this.offsetOfNode(x);
                return {
                    node: x,
                    remainder: Math.min(column - 1, accumualtedValue),
                    nodeStartOffset: nodeStartOffset_1
                };
            }
            else {
                if (x.piece.length >= column - 1) {
                    var nodeStartOffset_2 = this.offsetOfNode(x);
                    return {
                        node: x,
                        remainder: column - 1,
                        nodeStartOffset: nodeStartOffset_2
                    };
                }
                else {
                    column -= x.piece.length;
                }
            }
            x = x.next();
        }
        return null;
    };
    PieceTreeBase.prototype.nodeCharCodeAt = function (node, offset) {
        if (node.piece.lineFeedCnt < 1) {
            return -1;
        }
        var buffer = this._buffers[node.piece.bufferIndex];
        var newOffset = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start) + offset;
        return buffer.buffer.charCodeAt(newOffset);
    };
    PieceTreeBase.prototype.offsetOfNode = function (node) {
        if (!node) {
            return 0;
        }
        var pos = node.size_left;
        while (node !== this.root) {
            if (node.parent.right === node) {
                pos += node.parent.size_left + node.parent.piece.length;
            }
            node = node.parent;
        }
        return pos;
    };
    // #endregion
    // #region CRLF
    PieceTreeBase.prototype.shouldCheckCRLF = function () {
        return !(this._EOLNormalized && this._EOL === '\n');
    };
    PieceTreeBase.prototype.startWithLF = function (val) {
        if (typeof val === 'string') {
            return val.charCodeAt(0) === 10;
        }
        if (val === SENTINEL$1 || val.piece.lineFeedCnt === 0) {
            return false;
        }
        var piece = val.piece;
        var lineStarts = this._buffers[piece.bufferIndex].lineStarts;
        var line = piece.start.line;
        var startOffset = lineStarts[line] + piece.start.column;
        if (line === lineStarts.length - 1) {
            // last line, so there is no line feed at the end of this line
            return false;
        }
        var nextLineOffset = lineStarts[line + 1];
        if (nextLineOffset > startOffset + 1) {
            return false;
        }
        return this._buffers[piece.bufferIndex].buffer.charCodeAt(startOffset) === 10;
    };
    PieceTreeBase.prototype.endWithCR = function (val) {
        if (typeof val === 'string') {
            return val.charCodeAt(val.length - 1) === 13;
        }
        if (val === SENTINEL$1 || val.piece.lineFeedCnt === 0) {
            return false;
        }
        return this.nodeCharCodeAt(val, val.piece.length - 1) === 13;
    };
    PieceTreeBase.prototype.validateCRLFWithPrevNode = function (nextNode) {
        if (this.shouldCheckCRLF() && this.startWithLF(nextNode)) {
            var node = nextNode.prev();
            if (this.endWithCR(node)) {
                this.fixCRLF(node, nextNode);
            }
        }
    };
    PieceTreeBase.prototype.validateCRLFWithNextNode = function (node) {
        if (this.shouldCheckCRLF() && this.endWithCR(node)) {
            var nextNode = node.next();
            if (this.startWithLF(nextNode)) {
                this.fixCRLF(node, nextNode);
            }
        }
    };
    PieceTreeBase.prototype.fixCRLF = function (prev, next) {
        var nodesToDel = [];
        // update node
        var lineStarts = this._buffers[prev.piece.bufferIndex].lineStarts;
        var newEnd;
        if (prev.piece.end.column === 0) {
            // it means, last line ends with \r, not \r\n
            newEnd = { line: prev.piece.end.line - 1, column: lineStarts[prev.piece.end.line] - lineStarts[prev.piece.end.line - 1] - 1 };
        }
        else {
            // \r\n
            newEnd = { line: prev.piece.end.line, column: prev.piece.end.column - 1 };
        }
        var prevNewLength = prev.piece.length - 1;
        var prevNewLFCnt = prev.piece.lineFeedCnt - 1;
        prev.piece = new Piece(prev.piece.bufferIndex, prev.piece.start, newEnd, prevNewLFCnt, prevNewLength);
        updateTreeMetadata(this, prev, -1, -1);
        if (prev.piece.length === 0) {
            nodesToDel.push(prev);
        }
        // update nextNode
        var newStart = { line: next.piece.start.line + 1, column: 0 };
        var newLength = next.piece.length - 1;
        var newLineFeedCnt = this.getLineFeedCnt(next.piece.bufferIndex, newStart, next.piece.end);
        next.piece = new Piece(next.piece.bufferIndex, newStart, next.piece.end, newLineFeedCnt, newLength);
        updateTreeMetadata(this, next, -1, -1);
        if (next.piece.length === 0) {
            nodesToDel.push(next);
        }
        // create new piece which contains \r\n
        var pieces = this.createNewPieces('\r\n');
        this.rbInsertRight(prev, pieces[0]);
        // delete empty nodes
        for (var i = 0; i < nodesToDel.length; i++) {
            rbDelete(this, nodesToDel[i]);
        }
    };
    PieceTreeBase.prototype.adjustCarriageReturnFromNext = function (value, node) {
        if (this.shouldCheckCRLF() && this.endWithCR(value)) {
            var nextNode = node.next();
            if (this.startWithLF(nextNode)) {
                // move `\n` forward
                value += '\n';
                if (nextNode.piece.length === 1) {
                    rbDelete(this, nextNode);
                }
                else {
                    var piece = nextNode.piece;
                    var newStart = { line: piece.start.line + 1, column: 0 };
                    var newLength = piece.length - 1;
                    var newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end);
                    nextNode.piece = new Piece(piece.bufferIndex, newStart, piece.end, newLineFeedCnt, newLength);
                    updateTreeMetadata(this, nextNode, -1, -1);
                }
                return true;
            }
        }
        return false;
    };
    // #endregion
    // #endregion
    // #region Tree operations
    PieceTreeBase.prototype.iterate = function (node, callback) {
        if (node === SENTINEL$1) {
            return callback(SENTINEL$1);
        }
        var leftRet = this.iterate(node.left, callback);
        if (!leftRet) {
            return leftRet;
        }
        return callback(node) && this.iterate(node.right, callback);
    };
    PieceTreeBase.prototype.getNodeContent = function (node) {
        if (node === SENTINEL$1) {
            return '';
        }
        var buffer = this._buffers[node.piece.bufferIndex];
        var currentContent;
        var piece = node.piece;
        var startOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);
        var endOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);
        currentContent = buffer.buffer.substring(startOffset, endOffset);
        return currentContent;
    };
    PieceTreeBase.prototype.getPieceContent = function (piece) {
        var buffer = this._buffers[piece.bufferIndex];
        var startOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);
        var endOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);
        var currentContent = buffer.buffer.substring(startOffset, endOffset);
        return currentContent;
    };
    /**
     *      node              node
     *     /  \              /  \
     *    a   b    <----   a    b
     *                         /
     *                        z
     */
    PieceTreeBase.prototype.rbInsertRight = function (node, p) {
        var z = new TreeNode(p, 1 /* Red */);
        z.left = SENTINEL$1;
        z.right = SENTINEL$1;
        z.parent = SENTINEL$1;
        z.size_left = 0;
        z.lf_left = 0;
        var x = this.root;
        if (x === SENTINEL$1) {
            this.root = z;
            z.color = 0 /* Black */;
        }
        else if (node.right === SENTINEL$1) {
            node.right = z;
            z.parent = node;
        }
        else {
            var nextNode = leftest$1(node.right);
            nextNode.left = z;
            z.parent = nextNode;
        }
        fixInsert(this, z);
        return z;
    };
    /**
     *      node              node
     *     /  \              /  \
     *    a   b     ---->   a    b
     *                       \
     *                        z
     */
    PieceTreeBase.prototype.rbInsertLeft = function (node, p) {
        var z = new TreeNode(p, 1 /* Red */);
        z.left = SENTINEL$1;
        z.right = SENTINEL$1;
        z.parent = SENTINEL$1;
        z.size_left = 0;
        z.lf_left = 0;
        var x = this.root;
        if (x === SENTINEL$1) {
            this.root = z;
            z.color = 0 /* Black */;
        }
        else if (node.left === SENTINEL$1) {
            node.left = z;
            z.parent = node;
        }
        else {
            var prevNode = righttest(node.left); // a
            prevNode.right = z;
            z.parent = prevNode;
        }
        fixInsert(this, z);
        return z;
    };
    PieceTreeBase.prototype.getContentOfSubTree = function (node) {
        var _this = this;
        var str = '';
        this.iterate(node, function (node) {
            str += _this.getNodeContent(node);
            return true;
        });
        return str;
    };
    return PieceTreeBase;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var PieceTreeTextBuffer = /** @class */ (function () {
    function PieceTreeTextBuffer(chunks, BOM, eol, containsRTL$$1, isBasicASCII$$1, eolNormalized) {
        this._BOM = BOM;
        this._mightContainNonBasicASCII = !isBasicASCII$$1;
        this._mightContainRTL = containsRTL$$1;
        this._pieceTree = new PieceTreeBase(chunks, eol, eolNormalized);
    }
    // #region TextBuffer
    PieceTreeTextBuffer.prototype.equals = function (other) {
        if (!(other instanceof PieceTreeTextBuffer)) {
            return false;
        }
        if (this._BOM !== other._BOM) {
            return false;
        }
        if (this.getEOL() !== other.getEOL()) {
            return false;
        }
        return this._pieceTree.equal(other._pieceTree);
    };
    PieceTreeTextBuffer.prototype.mightContainRTL = function () {
        return this._mightContainRTL;
    };
    PieceTreeTextBuffer.prototype.mightContainNonBasicASCII = function () {
        return this._mightContainNonBasicASCII;
    };
    PieceTreeTextBuffer.prototype.getBOM = function () {
        return this._BOM;
    };
    PieceTreeTextBuffer.prototype.getEOL = function () {
        return this._pieceTree.getEOL();
    };
    PieceTreeTextBuffer.prototype.createSnapshot = function (preserveBOM) {
        return this._pieceTree.createSnapshot(preserveBOM ? this._BOM : '');
    };
    PieceTreeTextBuffer.prototype.getOffsetAt = function (lineNumber, column) {
        return this._pieceTree.getOffsetAt(lineNumber, column);
    };
    PieceTreeTextBuffer.prototype.getPositionAt = function (offset) {
        return this._pieceTree.getPositionAt(offset);
    };
    PieceTreeTextBuffer.prototype.getRangeAt = function (start, length) {
        var end = start + length;
        var startPosition = this.getPositionAt(start);
        var endPosition = this.getPositionAt(end);
        return new Range(startPosition.lineNumber, startPosition.column, endPosition.lineNumber, endPosition.column);
    };
    PieceTreeTextBuffer.prototype.getValueInRange = function (range, eol) {
        if (eol === void 0) { eol = EndOfLinePreference.TextDefined; }
        if (range.isEmpty()) {
            return '';
        }
        var lineEnding = this._getEndOfLine(eol);
        return this._pieceTree.getValueInRange(range, lineEnding);
    };
    PieceTreeTextBuffer.prototype.getValueLengthInRange = function (range, eol) {
        if (eol === void 0) { eol = EndOfLinePreference.TextDefined; }
        if (range.isEmpty()) {
            return 0;
        }
        if (range.startLineNumber === range.endLineNumber) {
            return (range.endColumn - range.startColumn);
        }
        var startOffset = this.getOffsetAt(range.startLineNumber, range.startColumn);
        var endOffset = this.getOffsetAt(range.endLineNumber, range.endColumn);
        return endOffset - startOffset;
    };
    PieceTreeTextBuffer.prototype.getLength = function () {
        return this._pieceTree.getLength();
    };
    PieceTreeTextBuffer.prototype.getLineCount = function () {
        return this._pieceTree.getLineCount();
    };
    PieceTreeTextBuffer.prototype.getLinesContent = function () {
        return this._pieceTree.getLinesContent();
    };
    PieceTreeTextBuffer.prototype.getLineContent = function (lineNumber) {
        return this._pieceTree.getLineContent(lineNumber);
    };
    PieceTreeTextBuffer.prototype.getLineCharCode = function (lineNumber, index) {
        return this._pieceTree.getLineCharCode(lineNumber, index);
    };
    PieceTreeTextBuffer.prototype.getLineLength = function (lineNumber) {
        return this._pieceTree.getLineLength(lineNumber);
    };
    PieceTreeTextBuffer.prototype.getLineMinColumn = function (lineNumber) {
        return 1;
    };
    PieceTreeTextBuffer.prototype.getLineMaxColumn = function (lineNumber) {
        return this.getLineLength(lineNumber) + 1;
    };
    PieceTreeTextBuffer.prototype.getLineFirstNonWhitespaceColumn = function (lineNumber) {
        var result = firstNonWhitespaceIndex(this.getLineContent(lineNumber));
        if (result === -1) {
            return 0;
        }
        return result + 1;
    };
    PieceTreeTextBuffer.prototype.getLineLastNonWhitespaceColumn = function (lineNumber) {
        var result = lastNonWhitespaceIndex(this.getLineContent(lineNumber));
        if (result === -1) {
            return 0;
        }
        return result + 2;
    };
    PieceTreeTextBuffer.prototype._getEndOfLine = function (eol) {
        switch (eol) {
            case EndOfLinePreference.LF:
                return '\n';
            case EndOfLinePreference.CRLF:
                return '\r\n';
            case EndOfLinePreference.TextDefined:
                return this.getEOL();
        }
        throw new Error('Unknown EOL preference');
    };
    PieceTreeTextBuffer.prototype.setEOL = function (newEOL) {
        this._pieceTree.setEOL(newEOL);
    };
    PieceTreeTextBuffer.prototype.applyEdits = function (rawOperations, recordTrimAutoWhitespace) {
        var mightContainRTL = this._mightContainRTL;
        var mightContainNonBasicASCII = this._mightContainNonBasicASCII;
        var canReduceOperations = true;
        var operations = [];
        for (var i = 0; i < rawOperations.length; i++) {
            var op = rawOperations[i];
            if (canReduceOperations && op._isTracked) {
                canReduceOperations = false;
            }
            var validatedRange = op.range;
            if (!mightContainRTL && op.text) {
                // check if the new inserted text contains RTL
                mightContainRTL = containsRTL(op.text);
            }
            if (!mightContainNonBasicASCII && op.text) {
                mightContainNonBasicASCII = !isBasicASCII(op.text);
            }
            operations[i] = {
                sortIndex: i,
                identifier: op.identifier,
                range: validatedRange,
                rangeOffset: this.getOffsetAt(validatedRange.startLineNumber, validatedRange.startColumn),
                rangeLength: this.getValueLengthInRange(validatedRange),
                lines: op.text ? op.text.split(/\r\n|\r|\n/) : null,
                forceMoveMarkers: op.forceMoveMarkers,
                isAutoWhitespaceEdit: op.isAutoWhitespaceEdit || false
            };
        }
        // Sort operations ascending
        operations.sort(PieceTreeTextBuffer._sortOpsAscending);
        var hasTouchingRanges = false;
        for (var i = 0, count = operations.length - 1; i < count; i++) {
            var rangeEnd = operations[i].range.getEndPosition();
            var nextRangeStart = operations[i + 1].range.getStartPosition();
            if (nextRangeStart.isBeforeOrEqual(rangeEnd)) {
                if (nextRangeStart.isBefore(rangeEnd)) {
                    // overlapping ranges
                    throw new Error('Overlapping ranges are not allowed!');
                }
                hasTouchingRanges = true;
            }
        }
        if (canReduceOperations) {
            operations = this._reduceOperations(operations);
        }
        // Delta encode operations
        var reverseRanges = PieceTreeTextBuffer._getInverseEditRanges(operations);
        var newTrimAutoWhitespaceCandidates = [];
        for (var i = 0; i < operations.length; i++) {
            var op = operations[i];
            var reverseRange = reverseRanges[i];
            if (recordTrimAutoWhitespace && op.isAutoWhitespaceEdit && op.range.isEmpty()) {
                // Record already the future line numbers that might be auto whitespace removal candidates on next edit
                for (var lineNumber = reverseRange.startLineNumber; lineNumber <= reverseRange.endLineNumber; lineNumber++) {
                    var currentLineContent = '';
                    if (lineNumber === reverseRange.startLineNumber) {
                        currentLineContent = this.getLineContent(op.range.startLineNumber);
                        if (firstNonWhitespaceIndex(currentLineContent) !== -1) {
                            continue;
                        }
                    }
                    newTrimAutoWhitespaceCandidates.push({ lineNumber: lineNumber, oldContent: currentLineContent });
                }
            }
        }
        var reverseOperations = [];
        for (var i = 0; i < operations.length; i++) {
            var op = operations[i];
            var reverseRange = reverseRanges[i];
            reverseOperations[i] = {
                sortIndex: op.sortIndex,
                identifier: op.identifier,
                range: reverseRange,
                text: this.getValueInRange(op.range),
                forceMoveMarkers: op.forceMoveMarkers
            };
        }
        // Can only sort reverse operations when the order is not significant
        if (!hasTouchingRanges) {
            reverseOperations.sort(function (a, b) { return a.sortIndex - b.sortIndex; });
        }
        this._mightContainRTL = mightContainRTL;
        this._mightContainNonBasicASCII = mightContainNonBasicASCII;
        var contentChanges = this._doApplyEdits(operations);
        var trimAutoWhitespaceLineNumbers = null;
        if (recordTrimAutoWhitespace && newTrimAutoWhitespaceCandidates.length > 0) {
            // sort line numbers auto whitespace removal candidates for next edit descending
            newTrimAutoWhitespaceCandidates.sort(function (a, b) { return b.lineNumber - a.lineNumber; });
            trimAutoWhitespaceLineNumbers = [];
            for (var i = 0, len = newTrimAutoWhitespaceCandidates.length; i < len; i++) {
                var lineNumber = newTrimAutoWhitespaceCandidates[i].lineNumber;
                if (i > 0 && newTrimAutoWhitespaceCandidates[i - 1].lineNumber === lineNumber) {
                    // Do not have the same line number twice
                    continue;
                }
                var prevContent = newTrimAutoWhitespaceCandidates[i].oldContent;
                var lineContent = this.getLineContent(lineNumber);
                if (lineContent.length === 0 || lineContent === prevContent || firstNonWhitespaceIndex(lineContent) !== -1) {
                    continue;
                }
                trimAutoWhitespaceLineNumbers.push(lineNumber);
            }
        }
        return new ApplyEditsResult(reverseOperations, contentChanges, trimAutoWhitespaceLineNumbers);
    };
    /**
     * Transform operations such that they represent the same logic edit,
     * but that they also do not cause OOM crashes.
     */
    PieceTreeTextBuffer.prototype._reduceOperations = function (operations) {
        if (operations.length < 1000) {
            // We know from empirical testing that a thousand edits work fine regardless of their shape.
            return operations;
        }
        // At one point, due to how events are emitted and how each operation is handled,
        // some operations can trigger a high ammount of temporary string allocations,
        // that will immediately get edited again.
        // e.g. a formatter inserting ridiculous ammounts of \n on a model with a single line
        // Therefore, the strategy is to collapse all the operations into a huge single edit operation
        return [this._toSingleEditOperation(operations)];
    };
    PieceTreeTextBuffer.prototype._toSingleEditOperation = function (operations) {
        var forceMoveMarkers = false, firstEditRange = operations[0].range, lastEditRange = operations[operations.length - 1].range, entireEditRange = new Range(firstEditRange.startLineNumber, firstEditRange.startColumn, lastEditRange.endLineNumber, lastEditRange.endColumn), lastEndLineNumber = firstEditRange.startLineNumber, lastEndColumn = firstEditRange.startColumn, result = [];
        for (var i = 0, len = operations.length; i < len; i++) {
            var operation = operations[i], range = operation.range;
            forceMoveMarkers = forceMoveMarkers || operation.forceMoveMarkers;
            // (1) -- Push old text
            for (var lineNumber = lastEndLineNumber; lineNumber < range.startLineNumber; lineNumber++) {
                if (lineNumber === lastEndLineNumber) {
                    result.push(this.getLineContent(lineNumber).substring(lastEndColumn - 1));
                }
                else {
                    result.push('\n');
                    result.push(this.getLineContent(lineNumber));
                }
            }
            if (range.startLineNumber === lastEndLineNumber) {
                result.push(this.getLineContent(range.startLineNumber).substring(lastEndColumn - 1, range.startColumn - 1));
            }
            else {
                result.push('\n');
                result.push(this.getLineContent(range.startLineNumber).substring(0, range.startColumn - 1));
            }
            // (2) -- Push new text
            if (operation.lines) {
                for (var j = 0, lenJ = operation.lines.length; j < lenJ; j++) {
                    if (j !== 0) {
                        result.push('\n');
                    }
                    result.push(operation.lines[j]);
                }
            }
            lastEndLineNumber = operation.range.endLineNumber;
            lastEndColumn = operation.range.endColumn;
        }
        return {
            sortIndex: 0,
            identifier: operations[0].identifier,
            range: entireEditRange,
            rangeOffset: this.getOffsetAt(entireEditRange.startLineNumber, entireEditRange.startColumn),
            rangeLength: this.getValueLengthInRange(entireEditRange, EndOfLinePreference.TextDefined),
            lines: result.join('').split('\n'),
            forceMoveMarkers: forceMoveMarkers,
            isAutoWhitespaceEdit: false
        };
    };
    PieceTreeTextBuffer.prototype._doApplyEdits = function (operations) {
        operations.sort(PieceTreeTextBuffer._sortOpsDescending);
        var contentChanges = [];
        // operations are from bottom to top
        for (var i = 0; i < operations.length; i++) {
            var op = operations[i];
            var startLineNumber = op.range.startLineNumber;
            var startColumn = op.range.startColumn;
            var endLineNumber = op.range.endLineNumber;
            var endColumn = op.range.endColumn;
            if (startLineNumber === endLineNumber && startColumn === endColumn && (!op.lines || op.lines.length === 0)) {
                // no-op
                continue;
            }
            var deletingLinesCnt = endLineNumber - startLineNumber;
            var insertingLinesCnt = (op.lines ? op.lines.length - 1 : 0);
            var editingLinesCnt = Math.min(deletingLinesCnt, insertingLinesCnt);
            var text = (op.lines ? op.lines.join(this.getEOL()) : '');
            if (text) {
                // replacement
                this._pieceTree.delete(op.rangeOffset, op.rangeLength);
                this._pieceTree.insert(op.rangeOffset, text, true);
            }
            else {
                // deletion
                this._pieceTree.delete(op.rangeOffset, op.rangeLength);
            }
            if (editingLinesCnt < insertingLinesCnt) {
                var newLinesContent = [];
                for (var j = editingLinesCnt + 1; j <= insertingLinesCnt; j++) {
                    newLinesContent.push(op.lines[j]);
                }
                newLinesContent[newLinesContent.length - 1] = this.getLineContent(startLineNumber + insertingLinesCnt - 1);
            }
            var contentChangeRange = new Range(startLineNumber, startColumn, endLineNumber, endColumn);
            contentChanges.push({
                range: contentChangeRange,
                rangeLength: op.rangeLength,
                text: text,
                rangeOffset: op.rangeOffset,
                forceMoveMarkers: op.forceMoveMarkers
            });
        }
        return contentChanges;
    };
    PieceTreeTextBuffer.prototype.findMatchesLineByLine = function (searchRange, searchData, captureMatches, limitResultCount) {
        return this._pieceTree.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);
    };
    // #endregion
    // #region helper
    // testing purpose.
    PieceTreeTextBuffer.prototype.getPieceTree = function () {
        return this._pieceTree;
    };
    /**
     * Assumes `operations` are validated and sorted ascending
     */
    PieceTreeTextBuffer._getInverseEditRanges = function (operations) {
        var result = [];
        var prevOpEndLineNumber;
        var prevOpEndColumn;
        var prevOp = null;
        for (var i = 0, len = operations.length; i < len; i++) {
            var op = operations[i];
            var startLineNumber = void 0;
            var startColumn = void 0;
            if (prevOp) {
                if (prevOp.range.endLineNumber === op.range.startLineNumber) {
                    startLineNumber = prevOpEndLineNumber;
                    startColumn = prevOpEndColumn + (op.range.startColumn - prevOp.range.endColumn);
                }
                else {
                    startLineNumber = prevOpEndLineNumber + (op.range.startLineNumber - prevOp.range.endLineNumber);
                    startColumn = op.range.startColumn;
                }
            }
            else {
                startLineNumber = op.range.startLineNumber;
                startColumn = op.range.startColumn;
            }
            var resultRange = void 0;
            if (op.lines && op.lines.length > 0) {
                // the operation inserts something
                var lineCount = op.lines.length;
                var firstLine = op.lines[0];
                var lastLine = op.lines[lineCount - 1];
                if (lineCount === 1) {
                    // single line insert
                    resultRange = new Range(startLineNumber, startColumn, startLineNumber, startColumn + firstLine.length);
                }
                else {
                    // multi line insert
                    resultRange = new Range(startLineNumber, startColumn, startLineNumber + lineCount - 1, lastLine.length + 1);
                }
            }
            else {
                // There is nothing to insert
                resultRange = new Range(startLineNumber, startColumn, startLineNumber, startColumn);
            }
            prevOpEndLineNumber = resultRange.endLineNumber;
            prevOpEndColumn = resultRange.endColumn;
            result.push(resultRange);
            prevOp = op;
        }
        return result;
    };
    PieceTreeTextBuffer._sortOpsAscending = function (a, b) {
        var r = Range.compareRangesUsingEnds(a.range, b.range);
        if (r === 0) {
            return a.sortIndex - b.sortIndex;
        }
        return r;
    };
    PieceTreeTextBuffer._sortOpsDescending = function (a, b) {
        var r = Range.compareRangesUsingEnds(a.range, b.range);
        if (r === 0) {
            return b.sortIndex - a.sortIndex;
        }
        return -r;
    };
    return PieceTreeTextBuffer;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var PieceTreeTextBufferFactory = /** @class */ (function () {
    function PieceTreeTextBufferFactory(_chunks, _bom, _cr, _lf, _crlf, _containsRTL, _isBasicASCII, _normalizeEOL) {
        this._chunks = _chunks;
        this._bom = _bom;
        this._cr = _cr;
        this._lf = _lf;
        this._crlf = _crlf;
        this._containsRTL = _containsRTL;
        this._isBasicASCII = _isBasicASCII;
        this._normalizeEOL = _normalizeEOL;
    }
    PieceTreeTextBufferFactory.prototype._getEOL = function (defaultEOL) {
        var totalEOLCount = this._cr + this._lf + this._crlf;
        var totalCRCount = this._cr + this._crlf;
        if (totalEOLCount === 0) {
            // This is an empty file or a file with precisely one line
            return (defaultEOL === DefaultEndOfLine.LF ? '\n' : '\r\n');
        }
        if (totalCRCount > totalEOLCount / 2) {
            // More than half of the file contains \r\n ending lines
            return '\r\n';
        }
        // At least one line more ends in \n
        return '\n';
    };
    PieceTreeTextBufferFactory.prototype.create = function (defaultEOL) {
        var eol = this._getEOL(defaultEOL);
        var chunks = this._chunks;
        if (this._normalizeEOL &&
            ((eol === '\r\n' && (this._cr > 0 || this._lf > 0))
                || (eol === '\n' && (this._cr > 0 || this._crlf > 0)))) {
            // Normalize pieces
            for (var i = 0, len = chunks.length; i < len; i++) {
                var str = chunks[i].buffer.replace(/\r\n|\r|\n/g, eol);
                var newLineStart = createLineStartsFast(str);
                chunks[i] = new StringBuffer(str, newLineStart);
            }
        }
        return new PieceTreeTextBuffer(chunks, this._bom, eol, this._containsRTL, this._isBasicASCII, this._normalizeEOL);
    };
    PieceTreeTextBufferFactory.prototype.getFirstLineText = function (lengthLimit) {
        return this._chunks[0].buffer.substr(0, 100).split(/\r\n|\r|\n/)[0];
    };
    return PieceTreeTextBufferFactory;
}());
var PieceTreeTextBufferBuilder = /** @class */ (function () {
    function PieceTreeTextBufferBuilder() {
        this.chunks = [];
        this.BOM = '';
        this._hasPreviousChar = false;
        this._previousChar = 0;
        this._tmpLineStarts = [];
        this.cr = 0;
        this.lf = 0;
        this.crlf = 0;
        this.containsRTL = false;
        this.isBasicASCII = true;
    }
    PieceTreeTextBufferBuilder.prototype.acceptChunk = function (chunk) {
        if (chunk.length === 0) {
            return;
        }
        if (this.chunks.length === 0) {
            if (startsWithUTF8BOM(chunk)) {
                this.BOM = UTF8_BOM_CHARACTER;
                chunk = chunk.substr(1);
            }
        }
        var lastChar = chunk.charCodeAt(chunk.length - 1);
        if (lastChar === 13 /* CarriageReturn */ || (lastChar >= 0xd800 && lastChar <= 0xdbff)) {
            // last character is \r or a high surrogate => keep it back
            this._acceptChunk1(chunk.substr(0, chunk.length - 1), false);
            this._hasPreviousChar = true;
            this._previousChar = lastChar;
        }
        else {
            this._acceptChunk1(chunk, false);
            this._hasPreviousChar = false;
            this._previousChar = lastChar;
        }
    };
    PieceTreeTextBufferBuilder.prototype._acceptChunk1 = function (chunk, allowEmptyStrings) {
        if (!allowEmptyStrings && chunk.length === 0) {
            // Nothing to do
            return;
        }
        if (this._hasPreviousChar) {
            this._acceptChunk2(String.fromCharCode(this._previousChar) + chunk);
        }
        else {
            this._acceptChunk2(chunk);
        }
    };
    PieceTreeTextBufferBuilder.prototype._acceptChunk2 = function (chunk) {
        var lineStarts = createLineStarts(this._tmpLineStarts, chunk);
        this.chunks.push(new StringBuffer(chunk, lineStarts.lineStarts));
        this.cr += lineStarts.cr;
        this.lf += lineStarts.lf;
        this.crlf += lineStarts.crlf;
        if (this.isBasicASCII) {
            this.isBasicASCII = lineStarts.isBasicASCII;
        }
        if (!this.isBasicASCII && !this.containsRTL) {
            // No need to check if is basic ASCII
            this.containsRTL = containsRTL(chunk);
        }
    };
    PieceTreeTextBufferBuilder.prototype.finish = function (normalizeEOL) {
        if (normalizeEOL === void 0) { normalizeEOL = true; }
        this._finish();
        return new PieceTreeTextBufferFactory(this.chunks, this.BOM, this.cr, this.lf, this.crlf, this.containsRTL, this.isBasicASCII, normalizeEOL);
    };
    PieceTreeTextBufferBuilder.prototype._finish = function () {
        if (this.chunks.length === 0) {
            this._acceptChunk1('', true);
        }
        if (this._hasPreviousChar) {
            this._hasPreviousChar = false;
            // recreate last chunk
            var lastChunk = this.chunks[this.chunks.length - 1];
            lastChunk.buffer += String.fromCharCode(this._previousChar);
            var newLineStarts = createLineStartsFast(lastChunk.buffer);
            lastChunk.lineStarts = newLineStarts;
            if (this._previousChar === 13 /* CarriageReturn */) {
                this.cr++;
            }
        }
    };
    return PieceTreeTextBufferBuilder;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$a = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
function createTextBufferBuilder() {
    return new PieceTreeTextBufferBuilder();
}
function createTextBufferFactory(text) {
    var builder = createTextBufferBuilder();
    builder.acceptChunk(text);
    return builder.finish();
}
function createTextBuffer(value, defaultEOL) {
    var factory = (typeof value === 'string' ? createTextBufferFactory(value) : value);
    return factory.create(defaultEOL);
}
var MODEL_ID = 0;
/**
 * Produces 'a'-'z', followed by 'A'-'Z'... followed by 'a'-'z', etc.
 */
function singleLetter(result) {
    var LETTERS_CNT = (90 /* Z */ - 65 /* A */ + 1);
    result = result % (2 * LETTERS_CNT);
    if (result < LETTERS_CNT) {
        return String.fromCharCode(97 /* a */ + result);
    }
    return String.fromCharCode(65 /* A */ + result - LETTERS_CNT);
}
var LIMIT_FIND_COUNT$1 = 999;
var LONG_LINE_BOUNDARY = 10000;
var TextModelSnapshot = /** @class */ (function () {
    function TextModelSnapshot(source) {
        this._source = source;
        this._eos = false;
    }
    TextModelSnapshot.prototype.read = function () {
        if (this._eos) {
            return null;
        }
        var result = [], resultCnt = 0, resultLength = 0;
        do {
            var tmp = this._source.read();
            if (tmp === null) {
                // end-of-stream
                this._eos = true;
                if (resultCnt === 0) {
                    return null;
                }
                else {
                    return result.join('');
                }
            }
            if (tmp.length > 0) {
                result[resultCnt++] = tmp;
                resultLength += tmp.length;
            }
            if (resultLength >= 64 * 1024) {
                return result.join('');
            }
        } while (true);
    };
    return TextModelSnapshot;
}());
var TextModel = /** @class */ (function (_super) {
    __extends$a(TextModel, _super);
    //#endregion
    function TextModel(source, creationOptions, languageIdentifier, associatedResource) {
        if (associatedResource === void 0) { associatedResource = null; }
        var _this = _super.call(this) || this;
        //#region Events
        _this._onWillDispose = _this._register(new Emitter());
        _this.onWillDispose = _this._onWillDispose.event;
        _this._onDidChangeDecorations = _this._register(new DidChangeDecorationsEmitter());
        _this.onDidChangeDecorations = _this._onDidChangeDecorations.event;
        _this._onDidChangeLanguage = _this._register(new Emitter());
        _this.onDidChangeLanguage = _this._onDidChangeLanguage.event;
        _this._onDidChangeLanguageConfiguration = _this._register(new Emitter());
        _this.onDidChangeLanguageConfiguration = _this._onDidChangeLanguageConfiguration.event;
        _this._onDidChangeTokens = _this._register(new Emitter());
        _this.onDidChangeTokens = _this._onDidChangeTokens.event;
        _this._onDidChangeOptions = _this._register(new Emitter());
        _this.onDidChangeOptions = _this._onDidChangeOptions.event;
        _this._eventEmitter = _this._register(new DidChangeContentEmitter());
        // Generate a new unique model id
        MODEL_ID++;
        _this.id = '$model' + MODEL_ID;
        _this.isForSimpleWidget = creationOptions.isForSimpleWidget;
        if (typeof associatedResource === 'undefined' || associatedResource === null) {
            _this._associatedResource = URI.parse('inmemory://model/' + MODEL_ID);
        }
        else {
            _this._associatedResource = associatedResource;
        }
        _this._attachedEditorCount = 0;
        _this._buffer = createTextBuffer(source, creationOptions.defaultEOL);
        _this._options = TextModel.resolveOptions(_this._buffer, creationOptions);
        var bufferLineCount = _this._buffer.getLineCount();
        var bufferTextLength = _this._buffer.getValueLengthInRange(new Range(1, 1, bufferLineCount, _this._buffer.getLineLength(bufferLineCount) + 1), EndOfLinePreference.TextDefined);
        // !!! Make a decision in the ctor and permanently respect this decision !!!
        // If a model is too large at construction time, it will never get tokenized,
        // under no circumstances.
        if (creationOptions.largeFileOptimizations) {
            _this._isTooLargeForTokenization = ((bufferTextLength > TextModel.LARGE_FILE_SIZE_THRESHOLD)
                || (bufferLineCount > TextModel.LARGE_FILE_LINE_COUNT_THRESHOLD));
        }
        else {
            _this._isTooLargeForTokenization = false;
        }
        _this._isTooLargeForSyncing = (bufferTextLength > TextModel.MODEL_SYNC_LIMIT);
        _this._setVersionId(1);
        _this._isDisposed = false;
        _this._isDisposing = false;
        _this._languageIdentifier = languageIdentifier || NULL_LANGUAGE_IDENTIFIER;
        _this._tokenizationListener = TokenizationRegistry.onDidChange(function (e) {
            if (e.changedLanguages.indexOf(_this._languageIdentifier.language) === -1) {
                return;
            }
            _this._resetTokenizationState();
            _this.emitModelTokensChangedEvent({
                ranges: [{
                        fromLineNumber: 1,
                        toLineNumber: _this.getLineCount()
                    }]
            });
            if (_this._shouldAutoTokenize()) {
                _this._warmUpTokens();
            }
        });
        _this._revalidateTokensTimeout = -1;
        _this._languageRegistryListener = LanguageConfigurationRegistry.onDidChange(function (e) {
            if (e.languageIdentifier.id === _this._languageIdentifier.id) {
                _this._onDidChangeLanguageConfiguration.fire({});
            }
        });
        _this._resetTokenizationState();
        _this._instanceId = singleLetter(MODEL_ID);
        _this._lastDecorationId = 0;
        _this._decorations = Object.create(null);
        _this._decorationsTree = new DecorationsTrees();
        _this._commandManager = new EditStack(_this);
        _this._isUndoing = false;
        _this._isRedoing = false;
        _this._trimAutoWhitespaceLines = null;
        return _this;
    }
    TextModel.createFromString = function (text, options, languageIdentifier, uri) {
        if (options === void 0) { options = TextModel.DEFAULT_CREATION_OPTIONS; }
        if (languageIdentifier === void 0) { languageIdentifier = null; }
        if (uri === void 0) { uri = null; }
        return new TextModel(text, options, languageIdentifier, uri);
    };
    TextModel.resolveOptions = function (textBuffer, options) {
        if (options.detectIndentation) {
            var guessedIndentation = guessIndentation(textBuffer, options.tabSize, options.insertSpaces);
            return new TextModelResolvedOptions({
                tabSize: guessedIndentation.tabSize,
                insertSpaces: guessedIndentation.insertSpaces,
                trimAutoWhitespace: options.trimAutoWhitespace,
                defaultEOL: options.defaultEOL
            });
        }
        return new TextModelResolvedOptions({
            tabSize: options.tabSize,
            insertSpaces: options.insertSpaces,
            trimAutoWhitespace: options.trimAutoWhitespace,
            defaultEOL: options.defaultEOL
        });
    };
    TextModel.prototype.onDidChangeRawContentFast = function (listener) {
        return this._eventEmitter.fastEvent(function (e) { return listener(e.rawContentChangedEvent); });
    };
    TextModel.prototype.onDidChangeRawContent = function (listener) {
        return this._eventEmitter.slowEvent(function (e) { return listener(e.rawContentChangedEvent); });
    };
    TextModel.prototype.onDidChangeContent = function (listener) {
        return this._eventEmitter.slowEvent(function (e) { return listener(e.contentChangedEvent); });
    };
    TextModel.prototype.dispose = function () {
        this._isDisposing = true;
        this._onWillDispose.fire();
        this._commandManager = null;
        this._decorations = null;
        this._decorationsTree = null;
        this._tokenizationListener.dispose();
        this._languageRegistryListener.dispose();
        this._clearTimers();
        this._tokens = null;
        this._isDisposed = true;
        // Null out members, such that any use of a disposed model will throw exceptions sooner rather than later
        this._buffer = null;
        _super.prototype.dispose.call(this);
        this._isDisposing = false;
    };
    TextModel.prototype._assertNotDisposed = function () {
        if (this._isDisposed) {
            throw new Error('Model is disposed!');
        }
    };
    TextModel.prototype.equalsTextBuffer = function (other) {
        this._assertNotDisposed();
        return this._buffer.equals(other);
    };
    TextModel.prototype._emitContentChangedEvent = function (rawChange, change) {
        if (this._isDisposing) {
            // Do not confuse listeners by emitting any event after disposing
            return;
        }
        this._eventEmitter.fire(new InternalModelContentChangeEvent(rawChange, change));
    };
    TextModel.prototype.setValue = function (value) {
        this._assertNotDisposed();
        if (value === null) {
            // There's nothing to do
            return;
        }
        var textBuffer = createTextBuffer(value, this._options.defaultEOL);
        this.setValueFromTextBuffer(textBuffer);
    };
    TextModel.prototype._createContentChanged2 = function (range, rangeOffset, rangeLength, text, isUndoing, isRedoing, isFlush) {
        return {
            changes: [{
                    range: range,
                    rangeOffset: rangeOffset,
                    rangeLength: rangeLength,
                    text: text,
                }],
            eol: this._buffer.getEOL(),
            versionId: this.getVersionId(),
            isUndoing: isUndoing,
            isRedoing: isRedoing,
            isFlush: isFlush
        };
    };
    TextModel.prototype.setValueFromTextBuffer = function (textBuffer) {
        this._assertNotDisposed();
        if (textBuffer === null) {
            // There's nothing to do
            return;
        }
        var oldFullModelRange = this.getFullModelRange();
        var oldModelValueLength = this.getValueLengthInRange(oldFullModelRange);
        var endLineNumber = this.getLineCount();
        var endColumn = this.getLineMaxColumn(endLineNumber);
        this._buffer = textBuffer;
        this._increaseVersionId();
        // Cancel tokenization, clear all tokens and begin tokenizing
        this._resetTokenizationState();
        // Destroy all my decorations
        this._decorations = Object.create(null);
        this._decorationsTree = new DecorationsTrees();
        // Destroy my edit history and settings
        this._commandManager = new EditStack(this);
        this._trimAutoWhitespaceLines = null;
        this._emitContentChangedEvent(new ModelRawContentChangedEvent([
            new ModelRawFlush()
        ], this._versionId, false, false), this._createContentChanged2(new Range(1, 1, endLineNumber, endColumn), 0, oldModelValueLength, this.getValue(), false, false, true));
    };
    TextModel.prototype.setEOL = function (eol) {
        this._assertNotDisposed();
        var newEOL = (eol === EndOfLineSequence.CRLF ? '\r\n' : '\n');
        if (this._buffer.getEOL() === newEOL) {
            // Nothing to do
            return;
        }
        var oldFullModelRange = this.getFullModelRange();
        var oldModelValueLength = this.getValueLengthInRange(oldFullModelRange);
        var endLineNumber = this.getLineCount();
        var endColumn = this.getLineMaxColumn(endLineNumber);
        this._onBeforeEOLChange();
        this._buffer.setEOL(newEOL);
        this._increaseVersionId();
        this._onAfterEOLChange();
        this._emitContentChangedEvent(new ModelRawContentChangedEvent([
            new ModelRawEOLChanged()
        ], this._versionId, false, false), this._createContentChanged2(new Range(1, 1, endLineNumber, endColumn), 0, oldModelValueLength, this.getValue(), false, false, false));
    };
    TextModel.prototype._onBeforeEOLChange = function () {
        // Ensure all decorations get their `range` set.
        var versionId = this.getVersionId();
        var allDecorations = this._decorationsTree.search(0, false, false, versionId);
        this._ensureNodesHaveRanges(allDecorations);
    };
    TextModel.prototype._onAfterEOLChange = function () {
        // Transform back `range` to offsets
        var versionId = this.getVersionId();
        var allDecorations = this._decorationsTree.collectNodesPostOrder();
        for (var i = 0, len = allDecorations.length; i < len; i++) {
            var node = allDecorations[i];
            var delta = node.cachedAbsoluteStart - node.start;
            var startOffset = this._buffer.getOffsetAt(node.range.startLineNumber, node.range.startColumn);
            var endOffset = this._buffer.getOffsetAt(node.range.endLineNumber, node.range.endColumn);
            node.cachedAbsoluteStart = startOffset;
            node.cachedAbsoluteEnd = endOffset;
            node.cachedVersionId = versionId;
            node.start = startOffset - delta;
            node.end = endOffset - delta;
            recomputeMaxEnd(node);
        }
    };
    TextModel.prototype._resetTokenizationState = function () {
        this._clearTimers();
        var tokenizationSupport = (this._isTooLargeForTokenization
            ? null
            : TokenizationRegistry.get(this._languageIdentifier.language));
        this._tokens = new ModelLinesTokens(this._languageIdentifier, tokenizationSupport);
        this._beginBackgroundTokenization();
    };
    TextModel.prototype._clearTimers = function () {
        if (this._revalidateTokensTimeout !== -1) {
            clearTimeout(this._revalidateTokensTimeout);
            this._revalidateTokensTimeout = -1;
        }
    };
    TextModel.prototype.onBeforeAttached = function () {
        this._attachedEditorCount++;
        // Warm up tokens for the editor
        this._warmUpTokens();
    };
    TextModel.prototype.onBeforeDetached = function () {
        this._attachedEditorCount--;
    };
    TextModel.prototype._shouldAutoTokenize = function () {
        return this.isAttachedToEditor();
    };
    TextModel.prototype.isAttachedToEditor = function () {
        return this._attachedEditorCount > 0;
    };
    TextModel.prototype.getAttachedEditorCount = function () {
        return this._attachedEditorCount;
    };
    TextModel.prototype.isTooLargeForSyncing = function () {
        return this._isTooLargeForSyncing;
    };
    TextModel.prototype.isTooLargeForTokenization = function () {
        return this._isTooLargeForTokenization;
    };
    TextModel.prototype.isDisposed = function () {
        return this._isDisposed;
    };
    TextModel.prototype.isDominatedByLongLines = function () {
        this._assertNotDisposed();
        if (this.isTooLargeForTokenization()) {
            // Cannot word wrap huge files anyways, so it doesn't really matter
            return false;
        }
        var smallLineCharCount = 0;
        var longLineCharCount = 0;
        var lineCount = this._buffer.getLineCount();
        for (var lineNumber = 1; lineNumber <= lineCount; lineNumber++) {
            var lineLength = this._buffer.getLineLength(lineNumber);
            if (lineLength >= LONG_LINE_BOUNDARY) {
                longLineCharCount += lineLength;
            }
            else {
                smallLineCharCount += lineLength;
            }
        }
        return (longLineCharCount > smallLineCharCount);
    };
    Object.defineProperty(TextModel.prototype, "uri", {
        get: function () {
            return this._associatedResource;
        },
        enumerable: true,
        configurable: true
    });
    //#region Options
    TextModel.prototype.getOptions = function () {
        this._assertNotDisposed();
        return this._options;
    };
    TextModel.prototype.updateOptions = function (_newOpts) {
        this._assertNotDisposed();
        var tabSize = (typeof _newOpts.tabSize !== 'undefined') ? _newOpts.tabSize : this._options.tabSize;
        var insertSpaces = (typeof _newOpts.insertSpaces !== 'undefined') ? _newOpts.insertSpaces : this._options.insertSpaces;
        var trimAutoWhitespace = (typeof _newOpts.trimAutoWhitespace !== 'undefined') ? _newOpts.trimAutoWhitespace : this._options.trimAutoWhitespace;
        var newOpts = new TextModelResolvedOptions({
            tabSize: tabSize,
            insertSpaces: insertSpaces,
            defaultEOL: this._options.defaultEOL,
            trimAutoWhitespace: trimAutoWhitespace
        });
        if (this._options.equals(newOpts)) {
            return;
        }
        var e = this._options.createChangeEvent(newOpts);
        this._options = newOpts;
        this._onDidChangeOptions.fire(e);
    };
    TextModel.prototype.detectIndentation = function (defaultInsertSpaces, defaultTabSize) {
        this._assertNotDisposed();
        var guessedIndentation = guessIndentation(this._buffer, defaultTabSize, defaultInsertSpaces);
        this.updateOptions({
            insertSpaces: guessedIndentation.insertSpaces,
            tabSize: guessedIndentation.tabSize
        });
    };
    TextModel._normalizeIndentationFromWhitespace = function (str, tabSize, insertSpaces) {
        var spacesCnt = 0;
        for (var i = 0; i < str.length; i++) {
            if (str.charAt(i) === '\t') {
                spacesCnt += tabSize;
            }
            else {
                spacesCnt++;
            }
        }
        var result = '';
        if (!insertSpaces) {
            var tabsCnt = Math.floor(spacesCnt / tabSize);
            spacesCnt = spacesCnt % tabSize;
            for (var i = 0; i < tabsCnt; i++) {
                result += '\t';
            }
        }
        for (var i = 0; i < spacesCnt; i++) {
            result += ' ';
        }
        return result;
    };
    TextModel.normalizeIndentation = function (str, tabSize, insertSpaces) {
        var firstNonWhitespaceIndex$$1 = firstNonWhitespaceIndex(str);
        if (firstNonWhitespaceIndex$$1 === -1) {
            firstNonWhitespaceIndex$$1 = str.length;
        }
        return TextModel._normalizeIndentationFromWhitespace(str.substring(0, firstNonWhitespaceIndex$$1), tabSize, insertSpaces) + str.substring(firstNonWhitespaceIndex$$1);
    };
    TextModel.prototype.normalizeIndentation = function (str) {
        this._assertNotDisposed();
        return TextModel.normalizeIndentation(str, this._options.tabSize, this._options.insertSpaces);
    };
    TextModel.prototype.getOneIndent = function () {
        this._assertNotDisposed();
        var tabSize = this._options.tabSize;
        var insertSpaces = this._options.insertSpaces;
        if (insertSpaces) {
            var result = '';
            for (var i = 0; i < tabSize; i++) {
                result += ' ';
            }
            return result;
        }
        else {
            return '\t';
        }
    };
    //#endregion
    //#region Reading
    TextModel.prototype.getVersionId = function () {
        this._assertNotDisposed();
        return this._versionId;
    };
    TextModel.prototype.mightContainRTL = function () {
        return this._buffer.mightContainRTL();
    };
    TextModel.prototype.mightContainNonBasicASCII = function () {
        return this._buffer.mightContainNonBasicASCII();
    };
    TextModel.prototype.getAlternativeVersionId = function () {
        this._assertNotDisposed();
        return this._alternativeVersionId;
    };
    TextModel.prototype.getOffsetAt = function (rawPosition) {
        this._assertNotDisposed();
        var position = this._validatePosition(rawPosition.lineNumber, rawPosition.column, false);
        return this._buffer.getOffsetAt(position.lineNumber, position.column);
    };
    TextModel.prototype.getPositionAt = function (rawOffset) {
        this._assertNotDisposed();
        var offset = (Math.min(this._buffer.getLength(), Math.max(0, rawOffset)));
        return this._buffer.getPositionAt(offset);
    };
    TextModel.prototype._increaseVersionId = function () {
        this._setVersionId(this._versionId + 1);
    };
    TextModel.prototype._setVersionId = function (newVersionId) {
        this._versionId = newVersionId;
        this._alternativeVersionId = this._versionId;
    };
    TextModel.prototype._overwriteAlternativeVersionId = function (newAlternativeVersionId) {
        this._alternativeVersionId = newAlternativeVersionId;
    };
    TextModel.prototype.getValue = function (eol, preserveBOM) {
        if (preserveBOM === void 0) { preserveBOM = false; }
        this._assertNotDisposed();
        var fullModelRange = this.getFullModelRange();
        var fullModelValue = this.getValueInRange(fullModelRange, eol);
        if (preserveBOM) {
            return this._buffer.getBOM() + fullModelValue;
        }
        return fullModelValue;
    };
    TextModel.prototype.createSnapshot = function (preserveBOM) {
        if (preserveBOM === void 0) { preserveBOM = false; }
        return new TextModelSnapshot(this._buffer.createSnapshot(preserveBOM));
    };
    TextModel.prototype.getValueLength = function (eol, preserveBOM) {
        if (preserveBOM === void 0) { preserveBOM = false; }
        this._assertNotDisposed();
        var fullModelRange = this.getFullModelRange();
        var fullModelValue = this.getValueLengthInRange(fullModelRange, eol);
        if (preserveBOM) {
            return this._buffer.getBOM().length + fullModelValue;
        }
        return fullModelValue;
    };
    TextModel.prototype.getValueInRange = function (rawRange, eol) {
        if (eol === void 0) { eol = EndOfLinePreference.TextDefined; }
        this._assertNotDisposed();
        return this._buffer.getValueInRange(this.validateRange(rawRange), eol);
    };
    TextModel.prototype.getValueLengthInRange = function (rawRange, eol) {
        if (eol === void 0) { eol = EndOfLinePreference.TextDefined; }
        this._assertNotDisposed();
        return this._buffer.getValueLengthInRange(this.validateRange(rawRange), eol);
    };
    TextModel.prototype.getLineCount = function () {
        this._assertNotDisposed();
        return this._buffer.getLineCount();
    };
    TextModel.prototype.getLineContent = function (lineNumber) {
        this._assertNotDisposed();
        if (lineNumber < 1 || lineNumber > this.getLineCount()) {
            throw new Error('Illegal value for lineNumber');
        }
        return this._buffer.getLineContent(lineNumber);
    };
    TextModel.prototype.getLineLength = function (lineNumber) {
        this._assertNotDisposed();
        if (lineNumber < 1 || lineNumber > this.getLineCount()) {
            throw new Error('Illegal value for lineNumber');
        }
        return this._buffer.getLineLength(lineNumber);
    };
    TextModel.prototype.getLinesContent = function () {
        this._assertNotDisposed();
        return this._buffer.getLinesContent();
    };
    TextModel.prototype.getEOL = function () {
        this._assertNotDisposed();
        return this._buffer.getEOL();
    };
    TextModel.prototype.getLineMinColumn = function (lineNumber) {
        this._assertNotDisposed();
        return 1;
    };
    TextModel.prototype.getLineMaxColumn = function (lineNumber) {
        this._assertNotDisposed();
        if (lineNumber < 1 || lineNumber > this.getLineCount()) {
            throw new Error('Illegal value for lineNumber');
        }
        return this._buffer.getLineLength(lineNumber) + 1;
    };
    TextModel.prototype.getLineFirstNonWhitespaceColumn = function (lineNumber) {
        this._assertNotDisposed();
        if (lineNumber < 1 || lineNumber > this.getLineCount()) {
            throw new Error('Illegal value for lineNumber');
        }
        return this._buffer.getLineFirstNonWhitespaceColumn(lineNumber);
    };
    TextModel.prototype.getLineLastNonWhitespaceColumn = function (lineNumber) {
        this._assertNotDisposed();
        if (lineNumber < 1 || lineNumber > this.getLineCount()) {
            throw new Error('Illegal value for lineNumber');
        }
        return this._buffer.getLineLastNonWhitespaceColumn(lineNumber);
    };
    /**
     * Validates `range` is within buffer bounds, but allows it to sit in between surrogate pairs, etc.
     * Will try to not allocate if possible.
     */
    TextModel.prototype._validateRangeRelaxedNoAllocations = function (range) {
        var linesCount = this._buffer.getLineCount();
        var initialStartLineNumber = range.startLineNumber;
        var initialStartColumn = range.startColumn;
        var startLineNumber;
        var startColumn;
        if (initialStartLineNumber < 1) {
            startLineNumber = 1;
            startColumn = 1;
        }
        else if (initialStartLineNumber > linesCount) {
            startLineNumber = linesCount;
            startColumn = this.getLineMaxColumn(startLineNumber);
        }
        else {
            startLineNumber = initialStartLineNumber | 0;
            if (initialStartColumn <= 1) {
                startColumn = 1;
            }
            else {
                var maxColumn = this.getLineMaxColumn(startLineNumber);
                if (initialStartColumn >= maxColumn) {
                    startColumn = maxColumn;
                }
                else {
                    startColumn = initialStartColumn | 0;
                }
            }
        }
        var initialEndLineNumber = range.endLineNumber;
        var initialEndColumn = range.endColumn;
        var endLineNumber;
        var endColumn;
        if (initialEndLineNumber < 1) {
            endLineNumber = 1;
            endColumn = 1;
        }
        else if (initialEndLineNumber > linesCount) {
            endLineNumber = linesCount;
            endColumn = this.getLineMaxColumn(endLineNumber);
        }
        else {
            endLineNumber = initialEndLineNumber | 0;
            if (initialEndColumn <= 1) {
                endColumn = 1;
            }
            else {
                var maxColumn = this.getLineMaxColumn(endLineNumber);
                if (initialEndColumn >= maxColumn) {
                    endColumn = maxColumn;
                }
                else {
                    endColumn = initialEndColumn | 0;
                }
            }
        }
        if (initialStartLineNumber === startLineNumber
            && initialStartColumn === startColumn
            && initialEndLineNumber === endLineNumber
            && initialEndColumn === endColumn
            && range instanceof Range
            && !(range instanceof Selection)) {
            return range;
        }
        return new Range(startLineNumber, startColumn, endLineNumber, endColumn);
    };
    /**
     * @param strict Do NOT allow a position inside a high-low surrogate pair
     */
    TextModel.prototype._isValidPosition = function (lineNumber, column, strict) {
        if (lineNumber < 1) {
            return false;
        }
        var lineCount = this._buffer.getLineCount();
        if (lineNumber > lineCount) {
            return false;
        }
        if (column < 1) {
            return false;
        }
        var maxColumn = this.getLineMaxColumn(lineNumber);
        if (column > maxColumn) {
            return false;
        }
        if (strict) {
            if (column > 1) {
                var charCodeBefore = this._buffer.getLineCharCode(lineNumber, column - 2);
                if (isHighSurrogate(charCodeBefore)) {
                    return false;
                }
            }
        }
        return true;
    };
    /**
     * @param strict Do NOT allow a position inside a high-low surrogate pair
     */
    TextModel.prototype._validatePosition = function (_lineNumber, _column, strict) {
        var lineNumber = Math.floor(typeof _lineNumber === 'number' ? _lineNumber : 1);
        var column = Math.floor(typeof _column === 'number' ? _column : 1);
        var lineCount = this._buffer.getLineCount();
        if (lineNumber < 1) {
            return new Position(1, 1);
        }
        if (lineNumber > lineCount) {
            return new Position(lineCount, this.getLineMaxColumn(lineCount));
        }
        if (column <= 1) {
            return new Position(lineNumber, 1);
        }
        var maxColumn = this.getLineMaxColumn(lineNumber);
        if (column >= maxColumn) {
            return new Position(lineNumber, maxColumn);
        }
        if (strict) {
            // If the position would end up in the middle of a high-low surrogate pair,
            // we move it to before the pair
            // !!At this point, column > 1
            var charCodeBefore = this._buffer.getLineCharCode(lineNumber, column - 2);
            if (isHighSurrogate(charCodeBefore)) {
                return new Position(lineNumber, column - 1);
            }
        }
        return new Position(lineNumber, column);
    };
    TextModel.prototype.validatePosition = function (position) {
        this._assertNotDisposed();
        // Avoid object allocation and cover most likely case
        if (position instanceof Position) {
            if (this._isValidPosition(position.lineNumber, position.column, true)) {
                return position;
            }
        }
        return this._validatePosition(position.lineNumber, position.column, true);
    };
    /**
     * @param strict Do NOT allow a range to have its boundaries inside a high-low surrogate pair
     */
    TextModel.prototype._isValidRange = function (range, strict) {
        var startLineNumber = range.startLineNumber;
        var startColumn = range.startColumn;
        var endLineNumber = range.endLineNumber;
        var endColumn = range.endColumn;
        if (!this._isValidPosition(startLineNumber, startColumn, false)) {
            return false;
        }
        if (!this._isValidPosition(endLineNumber, endColumn, false)) {
            return false;
        }
        if (strict) {
            var charCodeBeforeStart = (startColumn > 1 ? this._buffer.getLineCharCode(startLineNumber, startColumn - 2) : 0);
            var charCodeBeforeEnd = (endColumn > 1 && endColumn <= this._buffer.getLineLength(endLineNumber) ? this._buffer.getLineCharCode(endLineNumber, endColumn - 2) : 0);
            var startInsideSurrogatePair = isHighSurrogate(charCodeBeforeStart);
            var endInsideSurrogatePair = isHighSurrogate(charCodeBeforeEnd);
            if (!startInsideSurrogatePair && !endInsideSurrogatePair) {
                return true;
            }
            return false;
        }
        return true;
    };
    TextModel.prototype.validateRange = function (_range) {
        this._assertNotDisposed();
        // Avoid object allocation and cover most likely case
        if ((_range instanceof Range) && !(_range instanceof Selection)) {
            if (this._isValidRange(_range, true)) {
                return _range;
            }
        }
        var start = this._validatePosition(_range.startLineNumber, _range.startColumn, false);
        var end = this._validatePosition(_range.endLineNumber, _range.endColumn, false);
        var startLineNumber = start.lineNumber;
        var startColumn = start.column;
        var endLineNumber = end.lineNumber;
        var endColumn = end.column;
        var charCodeBeforeStart = (startColumn > 1 ? this._buffer.getLineCharCode(startLineNumber, startColumn - 2) : 0);
        var charCodeBeforeEnd = (endColumn > 1 && endColumn <= this._buffer.getLineLength(endLineNumber) ? this._buffer.getLineCharCode(endLineNumber, endColumn - 2) : 0);
        var startInsideSurrogatePair = isHighSurrogate(charCodeBeforeStart);
        var endInsideSurrogatePair = isHighSurrogate(charCodeBeforeEnd);
        if (!startInsideSurrogatePair && !endInsideSurrogatePair) {
            return new Range(startLineNumber, startColumn, endLineNumber, endColumn);
        }
        if (startLineNumber === endLineNumber && startColumn === endColumn) {
            // do not expand a collapsed range, simply move it to a valid location
            return new Range(startLineNumber, startColumn - 1, endLineNumber, endColumn - 1);
        }
        if (startInsideSurrogatePair && endInsideSurrogatePair) {
            // expand range at both ends
            return new Range(startLineNumber, startColumn - 1, endLineNumber, endColumn + 1);
        }
        if (startInsideSurrogatePair) {
            // only expand range at the start
            return new Range(startLineNumber, startColumn - 1, endLineNumber, endColumn);
        }
        // only expand range at the end
        return new Range(startLineNumber, startColumn, endLineNumber, endColumn + 1);
    };
    TextModel.prototype.modifyPosition = function (rawPosition, offset) {
        this._assertNotDisposed();
        var candidate = this.getOffsetAt(rawPosition) + offset;
        return this.getPositionAt(Math.min(this._buffer.getLength(), Math.max(0, candidate)));
    };
    TextModel.prototype.getFullModelRange = function () {
        this._assertNotDisposed();
        var lineCount = this.getLineCount();
        return new Range(1, 1, lineCount, this.getLineMaxColumn(lineCount));
    };
    TextModel.prototype.findMatchesLineByLine = function (searchRange, searchData, captureMatches, limitResultCount) {
        return this._buffer.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);
    };
    TextModel.prototype.findMatches = function (searchString, rawSearchScope, isRegex, matchCase, wordSeparators, captureMatches, limitResultCount) {
        if (limitResultCount === void 0) { limitResultCount = LIMIT_FIND_COUNT$1; }
        this._assertNotDisposed();
        var searchRange;
        if (Range.isIRange(rawSearchScope)) {
            searchRange = this.validateRange(rawSearchScope);
        }
        else {
            searchRange = this.getFullModelRange();
        }
        if (!isRegex && searchString.indexOf('\n') < 0) {
            // not regex, not multi line
            var searchParams = new SearchParams(searchString, isRegex, matchCase, wordSeparators);
            var searchData = searchParams.parseSearchRequest();
            if (!searchData) {
                return [];
            }
            return this.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);
        }
        return TextModelSearch.findMatches(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchRange, captureMatches, limitResultCount);
    };
    TextModel.prototype.findNextMatch = function (searchString, rawSearchStart, isRegex, matchCase, wordSeparators, captureMatches) {
        this._assertNotDisposed();
        var searchStart = this.validatePosition(rawSearchStart);
        if (!isRegex && searchString.indexOf('\n') < 0) {
            var searchParams = new SearchParams(searchString, isRegex, matchCase, wordSeparators);
            var searchData = searchParams.parseSearchRequest();
            var lineCount = this.getLineCount();
            var searchRange = new Range(searchStart.lineNumber, searchStart.column, lineCount, this.getLineMaxColumn(lineCount));
            var ret = this.findMatchesLineByLine(searchRange, searchData, captureMatches, 1);
            TextModelSearch.findNextMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);
            if (ret.length > 0) {
                return ret[0];
            }
            searchRange = new Range(1, 1, searchStart.lineNumber, this.getLineMaxColumn(searchStart.lineNumber));
            ret = this.findMatchesLineByLine(searchRange, searchData, captureMatches, 1);
            if (ret.length > 0) {
                return ret[0];
            }
            return null;
        }
        return TextModelSearch.findNextMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);
    };
    TextModel.prototype.findPreviousMatch = function (searchString, rawSearchStart, isRegex, matchCase, wordSeparators, captureMatches) {
        this._assertNotDisposed();
        var searchStart = this.validatePosition(rawSearchStart);
        return TextModelSearch.findPreviousMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);
    };
    //#endregion
    //#region Editing
    TextModel.prototype.pushStackElement = function () {
        this._commandManager.pushStackElement();
    };
    TextModel.prototype.pushEditOperations = function (beforeCursorState, editOperations, cursorStateComputer) {
        try {
            this._onDidChangeDecorations.beginDeferredEmit();
            this._eventEmitter.beginDeferredEmit();
            return this._pushEditOperations(beforeCursorState, editOperations, cursorStateComputer);
        }
        finally {
            this._eventEmitter.endDeferredEmit();
            this._onDidChangeDecorations.endDeferredEmit();
        }
    };
    TextModel.prototype._pushEditOperations = function (beforeCursorState, editOperations, cursorStateComputer) {
        var _this = this;
        if (this._options.trimAutoWhitespace && this._trimAutoWhitespaceLines) {
            // Go through each saved line number and insert a trim whitespace edit
            // if it is safe to do so (no conflicts with other edits).
            var incomingEdits = editOperations.map(function (op) {
                return {
                    range: _this.validateRange(op.range),
                    text: op.text
                };
            });
            // Sometimes, auto-formatters change ranges automatically which can cause undesired auto whitespace trimming near the cursor
            // We'll use the following heuristic: if the edits occur near the cursor, then it's ok to trim auto whitespace
            var editsAreNearCursors = true;
            for (var i = 0, len = beforeCursorState.length; i < len; i++) {
                var sel = beforeCursorState[i];
                var foundEditNearSel = false;
                for (var j = 0, lenJ = incomingEdits.length; j < lenJ; j++) {
                    var editRange = incomingEdits[j].range;
                    var selIsAbove = editRange.startLineNumber > sel.endLineNumber;
                    var selIsBelow = sel.startLineNumber > editRange.endLineNumber;
                    if (!selIsAbove && !selIsBelow) {
                        foundEditNearSel = true;
                        break;
                    }
                }
                if (!foundEditNearSel) {
                    editsAreNearCursors = false;
                    break;
                }
            }
            if (editsAreNearCursors) {
                for (var i = 0, len = this._trimAutoWhitespaceLines.length; i < len; i++) {
                    var trimLineNumber = this._trimAutoWhitespaceLines[i];
                    var maxLineColumn = this.getLineMaxColumn(trimLineNumber);
                    var allowTrimLine = true;
                    for (var j = 0, lenJ = incomingEdits.length; j < lenJ; j++) {
                        var editRange = incomingEdits[j].range;
                        var editText = incomingEdits[j].text;
                        if (trimLineNumber < editRange.startLineNumber || trimLineNumber > editRange.endLineNumber) {
                            // `trimLine` is completely outside this edit
                            continue;
                        }
                        // At this point:
                        //   editRange.startLineNumber <= trimLine <= editRange.endLineNumber
                        if (trimLineNumber === editRange.startLineNumber && editRange.startColumn === maxLineColumn
                            && editRange.isEmpty() && editText && editText.length > 0 && editText.charAt(0) === '\n') {
                            // This edit inserts a new line (and maybe other text) after `trimLine`
                            continue;
                        }
                        // Looks like we can't trim this line as it would interfere with an incoming edit
                        allowTrimLine = false;
                        break;
                    }
                    if (allowTrimLine) {
                        editOperations.push({
                            range: new Range(trimLineNumber, 1, trimLineNumber, maxLineColumn),
                            text: null
                        });
                    }
                }
            }
            this._trimAutoWhitespaceLines = null;
        }
        return this._commandManager.pushEditOperation(beforeCursorState, editOperations, cursorStateComputer);
    };
    TextModel.prototype.applyEdits = function (rawOperations) {
        try {
            this._onDidChangeDecorations.beginDeferredEmit();
            this._eventEmitter.beginDeferredEmit();
            return this._applyEdits(rawOperations);
        }
        finally {
            this._eventEmitter.endDeferredEmit();
            this._onDidChangeDecorations.endDeferredEmit();
        }
    };
    TextModel._eolCount = function (text) {
        var eolCount = 0;
        var firstLineLength = 0;
        for (var i = 0, len = text.length; i < len; i++) {
            var chr = text.charCodeAt(i);
            if (chr === 13 /* CarriageReturn */) {
                if (eolCount === 0) {
                    firstLineLength = i;
                }
                eolCount++;
                if (i + 1 < len && text.charCodeAt(i + 1) === 10 /* LineFeed */) {
                    // \r\n... case
                    i++; // skip \n
                }
            }
            else if (chr === 10 /* LineFeed */) {
                if (eolCount === 0) {
                    firstLineLength = i;
                }
                eolCount++;
            }
        }
        if (eolCount === 0) {
            firstLineLength = text.length;
        }
        return [eolCount, firstLineLength];
    };
    TextModel.prototype._applyEdits = function (rawOperations) {
        for (var i = 0, len = rawOperations.length; i < len; i++) {
            rawOperations[i].range = this.validateRange(rawOperations[i].range);
        }
        var oldLineCount = this._buffer.getLineCount();
        var result = this._buffer.applyEdits(rawOperations, this._options.trimAutoWhitespace);
        var newLineCount = this._buffer.getLineCount();
        var contentChanges = result.changes;
        this._trimAutoWhitespaceLines = result.trimAutoWhitespaceLineNumbers;
        if (contentChanges.length !== 0) {
            var rawContentChanges = [];
            var lineCount = oldLineCount;
            for (var i = 0, len = contentChanges.length; i < len; i++) {
                var change = contentChanges[i];
                var _a = TextModel._eolCount(change.text), eolCount = _a[0], firstLineLength = _a[1];
                this._tokens.applyEdits(change.range, eolCount, firstLineLength);
                this._onDidChangeDecorations.fire();
                this._decorationsTree.acceptReplace(change.rangeOffset, change.rangeLength, change.text.length, change.forceMoveMarkers);
                var startLineNumber = change.range.startLineNumber;
                var endLineNumber = change.range.endLineNumber;
                var deletingLinesCnt = endLineNumber - startLineNumber;
                var insertingLinesCnt = eolCount;
                var editingLinesCnt = Math.min(deletingLinesCnt, insertingLinesCnt);
                var changeLineCountDelta = (insertingLinesCnt - deletingLinesCnt);
                for (var j = editingLinesCnt; j >= 0; j--) {
                    var editLineNumber = startLineNumber + j;
                    var currentEditLineNumber = newLineCount - lineCount - changeLineCountDelta + editLineNumber;
                    rawContentChanges.push(new ModelRawLineChanged(editLineNumber, this.getLineContent(currentEditLineNumber)));
                }
                if (editingLinesCnt < deletingLinesCnt) {
                    // Must delete some lines
                    var spliceStartLineNumber = startLineNumber + editingLinesCnt;
                    rawContentChanges.push(new ModelRawLinesDeleted(spliceStartLineNumber + 1, endLineNumber));
                }
                if (editingLinesCnt < insertingLinesCnt) {
                    // Must insert some lines
                    var spliceLineNumber = startLineNumber + editingLinesCnt;
                    var cnt = insertingLinesCnt - editingLinesCnt;
                    var fromLineNumber = newLineCount - lineCount - cnt + spliceLineNumber + 1;
                    var newLines = [];
                    for (var i_1 = 0; i_1 < cnt; i_1++) {
                        var lineNumber = fromLineNumber + i_1;
                        newLines[lineNumber - fromLineNumber] = this.getLineContent(lineNumber);
                    }
                    rawContentChanges.push(new ModelRawLinesInserted(spliceLineNumber + 1, startLineNumber + insertingLinesCnt, newLines));
                }
                lineCount += changeLineCountDelta;
            }
            this._increaseVersionId();
            this._emitContentChangedEvent(new ModelRawContentChangedEvent(rawContentChanges, this.getVersionId(), this._isUndoing, this._isRedoing), {
                changes: contentChanges,
                eol: this._buffer.getEOL(),
                versionId: this.getVersionId(),
                isUndoing: this._isUndoing,
                isRedoing: this._isRedoing,
                isFlush: false
            });
        }
        if (this._tokens.hasLinesToTokenize(this._buffer)) {
            this._beginBackgroundTokenization();
        }
        return result.reverseEdits;
    };
    TextModel.prototype._undo = function () {
        this._isUndoing = true;
        var r = this._commandManager.undo();
        this._isUndoing = false;
        if (!r) {
            return null;
        }
        this._overwriteAlternativeVersionId(r.recordedVersionId);
        return r.selections;
    };
    TextModel.prototype.undo = function () {
        try {
            this._onDidChangeDecorations.beginDeferredEmit();
            this._eventEmitter.beginDeferredEmit();
            return this._undo();
        }
        finally {
            this._eventEmitter.endDeferredEmit();
            this._onDidChangeDecorations.endDeferredEmit();
        }
    };
    TextModel.prototype._redo = function () {
        this._isRedoing = true;
        var r = this._commandManager.redo();
        this._isRedoing = false;
        if (!r) {
            return null;
        }
        this._overwriteAlternativeVersionId(r.recordedVersionId);
        return r.selections;
    };
    TextModel.prototype.redo = function () {
        try {
            this._onDidChangeDecorations.beginDeferredEmit();
            this._eventEmitter.beginDeferredEmit();
            return this._redo();
        }
        finally {
            this._eventEmitter.endDeferredEmit();
            this._onDidChangeDecorations.endDeferredEmit();
        }
    };
    //#endregion
    //#region Decorations
    TextModel.prototype.changeDecorations = function (callback, ownerId) {
        if (ownerId === void 0) { ownerId = 0; }
        this._assertNotDisposed();
        try {
            this._onDidChangeDecorations.beginDeferredEmit();
            return this._changeDecorations(ownerId, callback);
        }
        finally {
            this._onDidChangeDecorations.endDeferredEmit();
        }
    };
    TextModel.prototype._changeDecorations = function (ownerId, callback) {
        var _this = this;
        var changeAccessor = {
            addDecoration: function (range, options) {
                _this._onDidChangeDecorations.fire();
                return _this._deltaDecorationsImpl(ownerId, [], [{ range: range, options: options }])[0];
            },
            changeDecoration: function (id, newRange) {
                _this._onDidChangeDecorations.fire();
                _this._changeDecorationImpl(id, newRange);
            },
            changeDecorationOptions: function (id, options) {
                _this._onDidChangeDecorations.fire();
                _this._changeDecorationOptionsImpl(id, _normalizeOptions(options));
            },
            removeDecoration: function (id) {
                _this._onDidChangeDecorations.fire();
                _this._deltaDecorationsImpl(ownerId, [id], []);
            },
            deltaDecorations: function (oldDecorations, newDecorations) {
                if (oldDecorations.length === 0 && newDecorations.length === 0) {
                    // nothing to do
                    return [];
                }
                _this._onDidChangeDecorations.fire();
                return _this._deltaDecorationsImpl(ownerId, oldDecorations, newDecorations);
            }
        };
        var result = null;
        try {
            result = callback(changeAccessor);
        }
        catch (e) {
            onUnexpectedError(e);
        }
        // Invalidate change accessor
        changeAccessor.addDecoration = null;
        changeAccessor.changeDecoration = null;
        changeAccessor.removeDecoration = null;
        changeAccessor.deltaDecorations = null;
        return result;
    };
    TextModel.prototype.deltaDecorations = function (oldDecorations, newDecorations, ownerId) {
        if (ownerId === void 0) { ownerId = 0; }
        this._assertNotDisposed();
        if (!oldDecorations) {
            oldDecorations = [];
        }
        if (oldDecorations.length === 0 && newDecorations.length === 0) {
            // nothing to do
            return [];
        }
        try {
            this._onDidChangeDecorations.beginDeferredEmit();
            this._onDidChangeDecorations.fire();
            return this._deltaDecorationsImpl(ownerId, oldDecorations, newDecorations);
        }
        finally {
            this._onDidChangeDecorations.endDeferredEmit();
        }
    };
    TextModel.prototype._getTrackedRange = function (id) {
        return this.getDecorationRange(id);
    };
    TextModel.prototype._setTrackedRange = function (id, newRange, newStickiness) {
        var node = (id ? this._decorations[id] : null);
        if (!node) {
            if (!newRange) {
                // node doesn't exist, the request is to delete => nothing to do
                return null;
            }
            // node doesn't exist, the request is to set => add the tracked range
            return this._deltaDecorationsImpl(0, [], [{ range: newRange, options: TRACKED_RANGE_OPTIONS[newStickiness] }])[0];
        }
        if (!newRange) {
            // node exists, the request is to delete => delete node
            this._decorationsTree.delete(node);
            delete this._decorations[node.id];
            return null;
        }
        // node exists, the request is to set => change the tracked range and its options
        var range = this._validateRangeRelaxedNoAllocations(newRange);
        var startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);
        var endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);
        this._decorationsTree.delete(node);
        node.reset(this.getVersionId(), startOffset, endOffset, range);
        node.setOptions(TRACKED_RANGE_OPTIONS[newStickiness]);
        this._decorationsTree.insert(node);
        return node.id;
    };
    TextModel.prototype.removeAllDecorationsWithOwnerId = function (ownerId) {
        if (this._isDisposed) {
            return;
        }
        var nodes = this._decorationsTree.collectNodesFromOwner(ownerId);
        for (var i = 0, len = nodes.length; i < len; i++) {
            var node = nodes[i];
            this._decorationsTree.delete(node);
            delete this._decorations[node.id];
        }
    };
    TextModel.prototype.getDecorationOptions = function (decorationId) {
        var node = this._decorations[decorationId];
        if (!node) {
            return null;
        }
        return node.options;
    };
    TextModel.prototype.getDecorationRange = function (decorationId) {
        var node = this._decorations[decorationId];
        if (!node) {
            return null;
        }
        var versionId = this.getVersionId();
        if (node.cachedVersionId !== versionId) {
            this._decorationsTree.resolveNode(node, versionId);
        }
        if (node.range === null) {
            node.range = this._getRangeAt(node.cachedAbsoluteStart, node.cachedAbsoluteEnd);
        }
        return node.range;
    };
    TextModel.prototype.getLineDecorations = function (lineNumber, ownerId, filterOutValidation) {
        if (ownerId === void 0) { ownerId = 0; }
        if (filterOutValidation === void 0) { filterOutValidation = false; }
        if (lineNumber < 1 || lineNumber > this.getLineCount()) {
            return [];
        }
        return this.getLinesDecorations(lineNumber, lineNumber, ownerId, filterOutValidation);
    };
    TextModel.prototype.getLinesDecorations = function (_startLineNumber, _endLineNumber, ownerId, filterOutValidation) {
        if (ownerId === void 0) { ownerId = 0; }
        if (filterOutValidation === void 0) { filterOutValidation = false; }
        var lineCount = this.getLineCount();
        var startLineNumber = Math.min(lineCount, Math.max(1, _startLineNumber));
        var endLineNumber = Math.min(lineCount, Math.max(1, _endLineNumber));
        var endColumn = this.getLineMaxColumn(endLineNumber);
        return this._getDecorationsInRange(new Range(startLineNumber, 1, endLineNumber, endColumn), ownerId, filterOutValidation);
    };
    TextModel.prototype.getDecorationsInRange = function (range, ownerId, filterOutValidation) {
        if (ownerId === void 0) { ownerId = 0; }
        if (filterOutValidation === void 0) { filterOutValidation = false; }
        var validatedRange = this.validateRange(range);
        return this._getDecorationsInRange(validatedRange, ownerId, filterOutValidation);
    };
    TextModel.prototype.getOverviewRulerDecorations = function (ownerId, filterOutValidation) {
        if (ownerId === void 0) { ownerId = 0; }
        if (filterOutValidation === void 0) { filterOutValidation = false; }
        var versionId = this.getVersionId();
        var result = this._decorationsTree.search(ownerId, filterOutValidation, true, versionId);
        return this._ensureNodesHaveRanges(result);
    };
    TextModel.prototype.getAllDecorations = function (ownerId, filterOutValidation) {
        if (ownerId === void 0) { ownerId = 0; }
        if (filterOutValidation === void 0) { filterOutValidation = false; }
        var versionId = this.getVersionId();
        var result = this._decorationsTree.search(ownerId, filterOutValidation, false, versionId);
        return this._ensureNodesHaveRanges(result);
    };
    TextModel.prototype._getDecorationsInRange = function (filterRange, filterOwnerId, filterOutValidation) {
        var startOffset = this._buffer.getOffsetAt(filterRange.startLineNumber, filterRange.startColumn);
        var endOffset = this._buffer.getOffsetAt(filterRange.endLineNumber, filterRange.endColumn);
        var versionId = this.getVersionId();
        var result = this._decorationsTree.intervalSearch(startOffset, endOffset, filterOwnerId, filterOutValidation, versionId);
        return this._ensureNodesHaveRanges(result);
    };
    TextModel.prototype._ensureNodesHaveRanges = function (nodes) {
        for (var i = 0, len = nodes.length; i < len; i++) {
            var node = nodes[i];
            if (node.range === null) {
                node.range = this._getRangeAt(node.cachedAbsoluteStart, node.cachedAbsoluteEnd);
            }
        }
        return nodes;
    };
    TextModel.prototype._getRangeAt = function (start, end) {
        return this._buffer.getRangeAt(start, end - start);
    };
    TextModel.prototype._changeDecorationImpl = function (decorationId, _range) {
        var node = this._decorations[decorationId];
        if (!node) {
            return;
        }
        var range = this._validateRangeRelaxedNoAllocations(_range);
        var startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);
        var endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);
        this._decorationsTree.delete(node);
        node.reset(this.getVersionId(), startOffset, endOffset, range);
        this._decorationsTree.insert(node);
    };
    TextModel.prototype._changeDecorationOptionsImpl = function (decorationId, options) {
        var node = this._decorations[decorationId];
        if (!node) {
            return;
        }
        var nodeWasInOverviewRuler = (node.options.overviewRuler.color ? true : false);
        var nodeIsInOverviewRuler = (options.overviewRuler.color ? true : false);
        if (nodeWasInOverviewRuler !== nodeIsInOverviewRuler) {
            // Delete + Insert due to an overview ruler status change
            this._decorationsTree.delete(node);
            node.setOptions(options);
            this._decorationsTree.insert(node);
        }
        else {
            node.setOptions(options);
        }
    };
    TextModel.prototype._deltaDecorationsImpl = function (ownerId, oldDecorationsIds, newDecorations) {
        var versionId = this.getVersionId();
        var oldDecorationsLen = oldDecorationsIds.length;
        var oldDecorationIndex = 0;
        var newDecorationsLen = newDecorations.length;
        var newDecorationIndex = 0;
        var result = new Array(newDecorationsLen);
        while (oldDecorationIndex < oldDecorationsLen || newDecorationIndex < newDecorationsLen) {
            var node = null;
            if (oldDecorationIndex < oldDecorationsLen) {
                // (1) get ourselves an old node
                do {
                    node = this._decorations[oldDecorationsIds[oldDecorationIndex++]];
                } while (!node && oldDecorationIndex < oldDecorationsLen);
                // (2) remove the node from the tree (if it exists)
                if (node) {
                    this._decorationsTree.delete(node);
                }
            }
            if (newDecorationIndex < newDecorationsLen) {
                // (3) create a new node if necessary
                if (!node) {
                    var internalDecorationId = (++this._lastDecorationId);
                    var decorationId = this._instanceId + ";" + internalDecorationId;
                    node = new IntervalNode(decorationId, 0, 0);
                    this._decorations[decorationId] = node;
                }
                // (4) initialize node
                var newDecoration = newDecorations[newDecorationIndex];
                var range = this._validateRangeRelaxedNoAllocations(newDecoration.range);
                var options = _normalizeOptions(newDecoration.options);
                var startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);
                var endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);
                node.ownerId = ownerId;
                node.reset(versionId, startOffset, endOffset, range);
                node.setOptions(options);
                this._decorationsTree.insert(node);
                result[newDecorationIndex] = node.id;
                newDecorationIndex++;
            }
            else {
                if (node) {
                    delete this._decorations[node.id];
                }
            }
        }
        return result;
    };
    //#endregion
    //#region Tokenization
    TextModel.prototype.tokenizeViewport = function (startLineNumber, endLineNumber) {
        if (!this._tokens.tokenizationSupport) {
            return;
        }
        // we tokenize `this._tokens.inValidLineStartIndex` lines in around 20ms so it's a good baseline.
        var contextBefore = Math.floor(this._tokens.inValidLineStartIndex * 0.3);
        startLineNumber = Math.max(1, startLineNumber - contextBefore);
        if (startLineNumber <= this._tokens.inValidLineStartIndex) {
            this.forceTokenization(endLineNumber);
            return;
        }
        var eventBuilder = new ModelTokensChangedEventBuilder();
        var nonWhitespaceColumn = this.getLineFirstNonWhitespaceColumn(startLineNumber);
        var fakeLines = [];
        var i = startLineNumber - 1;
        var initialState = null;
        if (nonWhitespaceColumn > 0) {
            while (nonWhitespaceColumn > 0 && i >= 1) {
                var newNonWhitespaceIndex = this.getLineFirstNonWhitespaceColumn(i);
                if (newNonWhitespaceIndex === 0) {
                    i--;
                    continue;
                }
                if (newNonWhitespaceIndex < nonWhitespaceColumn) {
                    initialState = this._tokens._getState(i - 1);
                    if (initialState) {
                        break;
                    }
                    fakeLines.push(this.getLineContent(i));
                    nonWhitespaceColumn = newNonWhitespaceIndex;
                }
                i--;
            }
        }
        if (!initialState) {
            initialState = this._tokens.tokenizationSupport.getInitialState();
        }
        var state = initialState.clone();
        for (var i_2 = fakeLines.length - 1; i_2 >= 0; i_2--) {
            var r = this._tokens._tokenizeText(this._buffer, fakeLines[i_2], state);
            if (r) {
                state = r.endState.clone();
            }
            else {
                state = initialState.clone();
            }
        }
        var contextAfter = Math.floor(this._tokens.inValidLineStartIndex * 0.4);
        endLineNumber = Math.min(this.getLineCount(), endLineNumber + contextAfter);
        for (var i_3 = startLineNumber; i_3 <= endLineNumber; i_3++) {
            var text = this.getLineContent(i_3);
            var r = this._tokens._tokenizeText(this._buffer, text, state);
            if (r) {
                this._tokens._setTokens(this._tokens.languageIdentifier.id, i_3 - 1, text.length, r.tokens);
                /*
                 * we think it's valid and give it a state but we don't update `_invalidLineStartIndex` then the top-to-bottom tokenization
                 * goes through the viewport, it can skip them if they already have correct tokens and state, and the lines after the viewport
                 * can still be tokenized.
                 */
                this._tokens._setIsInvalid(i_3 - 1, false);
                this._tokens._setState(i_3 - 1, state);
                state = r.endState.clone();
                eventBuilder.registerChangedTokens(i_3);
            }
            else {
                state = initialState.clone();
            }
        }
        var e = eventBuilder.build();
        if (e) {
            this._onDidChangeTokens.fire(e);
        }
    };
    TextModel.prototype.forceTokenization = function (lineNumber) {
        if (lineNumber < 1 || lineNumber > this.getLineCount()) {
            throw new Error('Illegal value for lineNumber');
        }
        var eventBuilder = new ModelTokensChangedEventBuilder();
        this._tokens._updateTokensUntilLine(this._buffer, eventBuilder, lineNumber);
        var e = eventBuilder.build();
        if (e) {
            this._onDidChangeTokens.fire(e);
        }
    };
    TextModel.prototype.isCheapToTokenize = function (lineNumber) {
        return this._tokens.isCheapToTokenize(lineNumber);
    };
    TextModel.prototype.tokenizeIfCheap = function (lineNumber) {
        if (this.isCheapToTokenize(lineNumber)) {
            this.forceTokenization(lineNumber);
        }
    };
    TextModel.prototype.getLineTokens = function (lineNumber) {
        if (lineNumber < 1 || lineNumber > this.getLineCount()) {
            throw new Error('Illegal value for lineNumber');
        }
        return this._getLineTokens(lineNumber);
    };
    TextModel.prototype._getLineTokens = function (lineNumber) {
        var lineText = this._buffer.getLineContent(lineNumber);
        return this._tokens.getTokens(this._languageIdentifier.id, lineNumber - 1, lineText);
    };
    TextModel.prototype.getLanguageIdentifier = function () {
        return this._languageIdentifier;
    };
    TextModel.prototype.getModeId = function () {
        return this._languageIdentifier.language;
    };
    TextModel.prototype.setMode = function (languageIdentifier) {
        if (this._languageIdentifier.id === languageIdentifier.id) {
            // There's nothing to do
            return;
        }
        var e = {
            oldLanguage: this._languageIdentifier.language,
            newLanguage: languageIdentifier.language
        };
        this._languageIdentifier = languageIdentifier;
        // Cancel tokenization, clear all tokens and begin tokenizing
        this._resetTokenizationState();
        this.emitModelTokensChangedEvent({
            ranges: [{
                    fromLineNumber: 1,
                    toLineNumber: this.getLineCount()
                }]
        });
        this._onDidChangeLanguage.fire(e);
        this._onDidChangeLanguageConfiguration.fire({});
    };
    TextModel.prototype.getLanguageIdAtPosition = function (_lineNumber, _column) {
        if (!this._tokens.tokenizationSupport) {
            return this._languageIdentifier.id;
        }
        var _a = this.validatePosition({ lineNumber: _lineNumber, column: _column }), lineNumber = _a.lineNumber, column = _a.column;
        var lineTokens = this._getLineTokens(lineNumber);
        return lineTokens.getLanguageId(lineTokens.findTokenIndexAtOffset(column - 1));
    };
    TextModel.prototype._beginBackgroundTokenization = function () {
        var _this = this;
        if (this._shouldAutoTokenize() && this._revalidateTokensTimeout === -1) {
            this._revalidateTokensTimeout = setTimeout(function () {
                _this._revalidateTokensTimeout = -1;
                _this._revalidateTokensNow();
            }, 0);
        }
    };
    TextModel.prototype._warmUpTokens = function () {
        // Warm up first 100 lines (if it takes less than 50ms)
        var maxLineNumber = Math.min(100, this.getLineCount());
        this._revalidateTokensNow(maxLineNumber);
        if (this._tokens.hasLinesToTokenize(this._buffer)) {
            this._beginBackgroundTokenization();
        }
    };
    TextModel.prototype._revalidateTokensNow = function (toLineNumber) {
        if (toLineNumber === void 0) { toLineNumber = this._buffer.getLineCount(); }
        var MAX_ALLOWED_TIME = 20;
        var eventBuilder = new ModelTokensChangedEventBuilder();
        var sw = StopWatch.create(false);
        while (this._tokens.hasLinesToTokenize(this._buffer)) {
            if (sw.elapsed() > MAX_ALLOWED_TIME) {
                // Stop if MAX_ALLOWED_TIME is reached
                break;
            }
            var tokenizedLineNumber = this._tokens._tokenizeOneLine(this._buffer, eventBuilder);
            if (tokenizedLineNumber >= toLineNumber) {
                break;
            }
        }
        if (this._tokens.hasLinesToTokenize(this._buffer)) {
            this._beginBackgroundTokenization();
        }
        var e = eventBuilder.build();
        if (e) {
            this._onDidChangeTokens.fire(e);
        }
    };
    TextModel.prototype.emitModelTokensChangedEvent = function (e) {
        if (!this._isDisposing) {
            this._onDidChangeTokens.fire(e);
        }
    };
    // Having tokens allows implementing additional helper methods
    TextModel.prototype.getWordAtPosition = function (_position) {
        this._assertNotDisposed();
        var position = this.validatePosition(_position);
        var lineContent = this.getLineContent(position.lineNumber);
        var lineTokens = this._getLineTokens(position.lineNumber);
        var tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);
        // (1). First try checking right biased word
        var _a = TextModel._findLanguageBoundaries(lineTokens, tokenIndex), rbStartOffset = _a[0], rbEndOffset = _a[1];
        var rightBiasedWord = getWordAtText(position.column, LanguageConfigurationRegistry.getWordDefinition(lineTokens.getLanguageId(tokenIndex)), lineContent.substring(rbStartOffset, rbEndOffset), rbStartOffset);
        if (rightBiasedWord) {
            return rightBiasedWord;
        }
        // (2). Else, if we were at a language boundary, check the left biased word
        if (tokenIndex > 0 && rbStartOffset === position.column - 1) {
            // edge case, where `position` sits between two tokens belonging to two different languages
            var _b = TextModel._findLanguageBoundaries(lineTokens, tokenIndex - 1), lbStartOffset = _b[0], lbEndOffset = _b[1];
            var leftBiasedWord = getWordAtText(position.column, LanguageConfigurationRegistry.getWordDefinition(lineTokens.getLanguageId(tokenIndex - 1)), lineContent.substring(lbStartOffset, lbEndOffset), lbStartOffset);
            if (leftBiasedWord) {
                return leftBiasedWord;
            }
        }
        return null;
    };
    TextModel._findLanguageBoundaries = function (lineTokens, tokenIndex) {
        var languageId = lineTokens.getLanguageId(tokenIndex);
        // go left until a different language is hit
        var startOffset;
        for (var i = tokenIndex; i >= 0 && lineTokens.getLanguageId(i) === languageId; i--) {
            startOffset = lineTokens.getStartOffset(i);
        }
        // go right until a different language is hit
        var endOffset;
        for (var i = tokenIndex, tokenCount = lineTokens.getCount(); i < tokenCount && lineTokens.getLanguageId(i) === languageId; i++) {
            endOffset = lineTokens.getEndOffset(i);
        }
        return [startOffset, endOffset];
    };
    TextModel.prototype.getWordUntilPosition = function (position) {
        var wordAtPosition = this.getWordAtPosition(position);
        if (!wordAtPosition) {
            return {
                word: '',
                startColumn: position.column,
                endColumn: position.column
            };
        }
        return {
            word: wordAtPosition.word.substr(0, position.column - wordAtPosition.startColumn),
            startColumn: wordAtPosition.startColumn,
            endColumn: position.column
        };
    };
    TextModel.prototype.findMatchingBracketUp = function (_bracket, _position) {
        var bracket = _bracket.toLowerCase();
        var position = this.validatePosition(_position);
        var lineTokens = this._getLineTokens(position.lineNumber);
        var languageId = lineTokens.getLanguageId(lineTokens.findTokenIndexAtOffset(position.column - 1));
        var bracketsSupport = LanguageConfigurationRegistry.getBracketsSupport(languageId);
        if (!bracketsSupport) {
            return null;
        }
        var data = bracketsSupport.textIsBracket[bracket];
        if (!data) {
            return null;
        }
        return this._findMatchingBracketUp(data, position);
    };
    TextModel.prototype.matchBracket = function (position) {
        return this._matchBracket(this.validatePosition(position));
    };
    TextModel.prototype._matchBracket = function (position) {
        var lineNumber = position.lineNumber;
        var lineTokens = this._getLineTokens(lineNumber);
        var lineText = this._buffer.getLineContent(lineNumber);
        var tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);
        if (tokenIndex < 0) {
            return null;
        }
        var currentModeBrackets = LanguageConfigurationRegistry.getBracketsSupport(lineTokens.getLanguageId(tokenIndex));
        // check that the token is not to be ignored
        if (currentModeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex))) {
            // limit search to not go before `maxBracketLength`
            var searchStartOffset = Math.max(lineTokens.getStartOffset(tokenIndex), position.column - 1 - currentModeBrackets.maxBracketLength);
            // limit search to not go after `maxBracketLength`
            var searchEndOffset = Math.min(lineTokens.getEndOffset(tokenIndex), position.column - 1 + currentModeBrackets.maxBracketLength);
            // it might be the case that [currentTokenStart -> currentTokenEnd] contains multiple brackets
            // `bestResult` will contain the most right-side result
            var bestResult = null;
            while (true) {
                var foundBracket = BracketsUtils.findNextBracketInToken(currentModeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);
                if (!foundBracket) {
                    // there are no more brackets in this text
                    break;
                }
                // check that we didn't hit a bracket too far away from position
                if (foundBracket.startColumn <= position.column && position.column <= foundBracket.endColumn) {
                    var foundBracketText = lineText.substring(foundBracket.startColumn - 1, foundBracket.endColumn - 1);
                    foundBracketText = foundBracketText.toLowerCase();
                    var r = this._matchFoundBracket(foundBracket, currentModeBrackets.textIsBracket[foundBracketText], currentModeBrackets.textIsOpenBracket[foundBracketText]);
                    // check that we can actually match this bracket
                    if (r) {
                        bestResult = r;
                    }
                }
                searchStartOffset = foundBracket.endColumn - 1;
            }
            if (bestResult) {
                return bestResult;
            }
        }
        // If position is in between two tokens, try also looking in the previous token
        if (tokenIndex > 0 && lineTokens.getStartOffset(tokenIndex) === position.column - 1) {
            var searchEndOffset = lineTokens.getStartOffset(tokenIndex);
            tokenIndex--;
            var prevModeBrackets = LanguageConfigurationRegistry.getBracketsSupport(lineTokens.getLanguageId(tokenIndex));
            // check that previous token is not to be ignored
            if (prevModeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex))) {
                // limit search in case previous token is very large, there's no need to go beyond `maxBracketLength`
                var searchStartOffset = Math.max(lineTokens.getStartOffset(tokenIndex), position.column - 1 - prevModeBrackets.maxBracketLength);
                var foundBracket = BracketsUtils.findPrevBracketInToken(prevModeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);
                // check that we didn't hit a bracket too far away from position
                if (foundBracket && foundBracket.startColumn <= position.column && position.column <= foundBracket.endColumn) {
                    var foundBracketText = lineText.substring(foundBracket.startColumn - 1, foundBracket.endColumn - 1);
                    foundBracketText = foundBracketText.toLowerCase();
                    var r = this._matchFoundBracket(foundBracket, prevModeBrackets.textIsBracket[foundBracketText], prevModeBrackets.textIsOpenBracket[foundBracketText]);
                    // check that we can actually match this bracket
                    if (r) {
                        return r;
                    }
                }
            }
        }
        return null;
    };
    TextModel.prototype._matchFoundBracket = function (foundBracket, data, isOpen) {
        if (!data) {
            return null;
        }
        if (isOpen) {
            var matched = this._findMatchingBracketDown(data, foundBracket.getEndPosition());
            if (matched) {
                return [foundBracket, matched];
            }
        }
        else {
            var matched = this._findMatchingBracketUp(data, foundBracket.getStartPosition());
            if (matched) {
                return [foundBracket, matched];
            }
        }
        return null;
    };
    TextModel.prototype._findMatchingBracketUp = function (bracket, position) {
        // console.log('_findMatchingBracketUp: ', 'bracket: ', JSON.stringify(bracket), 'startPosition: ', String(position));
        var languageId = bracket.languageIdentifier.id;
        var reversedBracketRegex = bracket.reversedRegex;
        var count = -1;
        for (var lineNumber = position.lineNumber; lineNumber >= 1; lineNumber--) {
            var lineTokens = this._getLineTokens(lineNumber);
            var tokenCount = lineTokens.getCount();
            var lineText = this._buffer.getLineContent(lineNumber);
            var tokenIndex = tokenCount - 1;
            var searchStopOffset = -1;
            if (lineNumber === position.lineNumber) {
                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);
                searchStopOffset = position.column - 1;
            }
            for (; tokenIndex >= 0; tokenIndex--) {
                var tokenLanguageId = lineTokens.getLanguageId(tokenIndex);
                var tokenType = lineTokens.getStandardTokenType(tokenIndex);
                var tokenStartOffset = lineTokens.getStartOffset(tokenIndex);
                var tokenEndOffset = lineTokens.getEndOffset(tokenIndex);
                if (searchStopOffset === -1) {
                    searchStopOffset = tokenEndOffset;
                }
                if (tokenLanguageId === languageId && !ignoreBracketsInToken(tokenType)) {
                    while (true) {
                        var r = BracketsUtils.findPrevBracketInToken(reversedBracketRegex, lineNumber, lineText, tokenStartOffset, searchStopOffset);
                        if (!r) {
                            break;
                        }
                        var hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1);
                        hitText = hitText.toLowerCase();
                        if (hitText === bracket.open) {
                            count++;
                        }
                        else if (hitText === bracket.close) {
                            count--;
                        }
                        if (count === 0) {
                            return r;
                        }
                        searchStopOffset = r.startColumn - 1;
                    }
                }
                searchStopOffset = -1;
            }
        }
        return null;
    };
    TextModel.prototype._findMatchingBracketDown = function (bracket, position) {
        // console.log('_findMatchingBracketDown: ', 'bracket: ', JSON.stringify(bracket), 'startPosition: ', String(position));
        var languageId = bracket.languageIdentifier.id;
        var bracketRegex = bracket.forwardRegex;
        var count = 1;
        for (var lineNumber = position.lineNumber, lineCount = this.getLineCount(); lineNumber <= lineCount; lineNumber++) {
            var lineTokens = this._getLineTokens(lineNumber);
            var tokenCount = lineTokens.getCount();
            var lineText = this._buffer.getLineContent(lineNumber);
            var tokenIndex = 0;
            var searchStartOffset = 0;
            if (lineNumber === position.lineNumber) {
                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);
                searchStartOffset = position.column - 1;
            }
            for (; tokenIndex < tokenCount; tokenIndex++) {
                var tokenLanguageId = lineTokens.getLanguageId(tokenIndex);
                var tokenType = lineTokens.getStandardTokenType(tokenIndex);
                var tokenStartOffset = lineTokens.getStartOffset(tokenIndex);
                var tokenEndOffset = lineTokens.getEndOffset(tokenIndex);
                if (searchStartOffset === 0) {
                    searchStartOffset = tokenStartOffset;
                }
                if (tokenLanguageId === languageId && !ignoreBracketsInToken(tokenType)) {
                    while (true) {
                        var r = BracketsUtils.findNextBracketInToken(bracketRegex, lineNumber, lineText, searchStartOffset, tokenEndOffset);
                        if (!r) {
                            break;
                        }
                        var hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1);
                        hitText = hitText.toLowerCase();
                        if (hitText === bracket.open) {
                            count++;
                        }
                        else if (hitText === bracket.close) {
                            count--;
                        }
                        if (count === 0) {
                            return r;
                        }
                        searchStartOffset = r.endColumn - 1;
                    }
                }
                searchStartOffset = 0;
            }
        }
        return null;
    };
    TextModel.prototype.findPrevBracket = function (_position) {
        var position = this.validatePosition(_position);
        var languageId = -1;
        var modeBrackets = null;
        for (var lineNumber = position.lineNumber; lineNumber >= 1; lineNumber--) {
            var lineTokens = this._getLineTokens(lineNumber);
            var tokenCount = lineTokens.getCount();
            var lineText = this._buffer.getLineContent(lineNumber);
            var tokenIndex = tokenCount - 1;
            var searchStopOffset = -1;
            if (lineNumber === position.lineNumber) {
                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);
                searchStopOffset = position.column - 1;
            }
            for (; tokenIndex >= 0; tokenIndex--) {
                var tokenLanguageId = lineTokens.getLanguageId(tokenIndex);
                var tokenType = lineTokens.getStandardTokenType(tokenIndex);
                var tokenStartOffset = lineTokens.getStartOffset(tokenIndex);
                var tokenEndOffset = lineTokens.getEndOffset(tokenIndex);
                if (searchStopOffset === -1) {
                    searchStopOffset = tokenEndOffset;
                }
                if (languageId !== tokenLanguageId) {
                    languageId = tokenLanguageId;
                    modeBrackets = LanguageConfigurationRegistry.getBracketsSupport(languageId);
                }
                if (modeBrackets && !ignoreBracketsInToken(tokenType)) {
                    var r = BracketsUtils.findPrevBracketInToken(modeBrackets.reversedRegex, lineNumber, lineText, tokenStartOffset, searchStopOffset);
                    if (r) {
                        return this._toFoundBracket(modeBrackets, r);
                    }
                }
                searchStopOffset = -1;
            }
        }
        return null;
    };
    TextModel.prototype.findNextBracket = function (_position) {
        var position = this.validatePosition(_position);
        var languageId = -1;
        var modeBrackets = null;
        for (var lineNumber = position.lineNumber, lineCount = this.getLineCount(); lineNumber <= lineCount; lineNumber++) {
            var lineTokens = this._getLineTokens(lineNumber);
            var tokenCount = lineTokens.getCount();
            var lineText = this._buffer.getLineContent(lineNumber);
            var tokenIndex = 0;
            var searchStartOffset = 0;
            if (lineNumber === position.lineNumber) {
                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);
                searchStartOffset = position.column - 1;
            }
            for (; tokenIndex < tokenCount; tokenIndex++) {
                var tokenLanguageId = lineTokens.getLanguageId(tokenIndex);
                var tokenType = lineTokens.getStandardTokenType(tokenIndex);
                var tokenStartOffset = lineTokens.getStartOffset(tokenIndex);
                var tokenEndOffset = lineTokens.getEndOffset(tokenIndex);
                if (searchStartOffset === 0) {
                    searchStartOffset = tokenStartOffset;
                }
                if (languageId !== tokenLanguageId) {
                    languageId = tokenLanguageId;
                    modeBrackets = LanguageConfigurationRegistry.getBracketsSupport(languageId);
                }
                if (modeBrackets && !ignoreBracketsInToken(tokenType)) {
                    var r = BracketsUtils.findNextBracketInToken(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, tokenEndOffset);
                    if (r) {
                        return this._toFoundBracket(modeBrackets, r);
                    }
                }
                searchStartOffset = 0;
            }
        }
        return null;
    };
    TextModel.prototype._toFoundBracket = function (modeBrackets, r) {
        if (!r) {
            return null;
        }
        var text = this.getValueInRange(r);
        text = text.toLowerCase();
        var data = modeBrackets.textIsBracket[text];
        if (!data) {
            return null;
        }
        return {
            range: r,
            open: data.open,
            close: data.close,
            isOpen: modeBrackets.textIsOpenBracket[text]
        };
    };
    /**
     * Returns:
     *  - -1 => the line consists of whitespace
     *  - otherwise => the indent level is returned value
     */
    TextModel.computeIndentLevel = function (line, tabSize) {
        var indent = 0;
        var i = 0;
        var len = line.length;
        while (i < len) {
            var chCode = line.charCodeAt(i);
            if (chCode === 32 /* Space */) {
                indent++;
            }
            else if (chCode === 9 /* Tab */) {
                indent = indent - indent % tabSize + tabSize;
            }
            else {
                break;
            }
            i++;
        }
        if (i === len) {
            return -1; // line only consists of whitespace
        }
        return indent;
    };
    TextModel.prototype._computeIndentLevel = function (lineIndex) {
        return TextModel.computeIndentLevel(this._buffer.getLineContent(lineIndex + 1), this._options.tabSize);
    };
    TextModel.prototype.getActiveIndentGuide = function (lineNumber, minLineNumber, maxLineNumber) {
        var _this = this;
        this._assertNotDisposed();
        var lineCount = this.getLineCount();
        if (lineNumber < 1 || lineNumber > lineCount) {
            throw new Error('Illegal value for lineNumber');
        }
        var foldingRules = LanguageConfigurationRegistry.getFoldingRules(this._languageIdentifier.id);
        var offSide = foldingRules && foldingRules.offSide;
        var up_aboveContentLineIndex = -2; /* -2 is a marker for not having computed it */
        var up_aboveContentLineIndent = -1;
        var up_belowContentLineIndex = -2; /* -2 is a marker for not having computed it */
        var up_belowContentLineIndent = -1;
        var up_resolveIndents = function (lineNumber) {
            if (up_aboveContentLineIndex !== -1 && (up_aboveContentLineIndex === -2 || up_aboveContentLineIndex > lineNumber - 1)) {
                up_aboveContentLineIndex = -1;
                up_aboveContentLineIndent = -1;
                // must find previous line with content
                for (var lineIndex = lineNumber - 2; lineIndex >= 0; lineIndex--) {
                    var indent_1 = _this._computeIndentLevel(lineIndex);
                    if (indent_1 >= 0) {
                        up_aboveContentLineIndex = lineIndex;
                        up_aboveContentLineIndent = indent_1;
                        break;
                    }
                }
            }
            if (up_belowContentLineIndex === -2) {
                up_belowContentLineIndex = -1;
                up_belowContentLineIndent = -1;
                // must find next line with content
                for (var lineIndex = lineNumber; lineIndex < lineCount; lineIndex++) {
                    var indent_2 = _this._computeIndentLevel(lineIndex);
                    if (indent_2 >= 0) {
                        up_belowContentLineIndex = lineIndex;
                        up_belowContentLineIndent = indent_2;
                        break;
                    }
                }
            }
        };
        var down_aboveContentLineIndex = -2; /* -2 is a marker for not having computed it */
        var down_aboveContentLineIndent = -1;
        var down_belowContentLineIndex = -2; /* -2 is a marker for not having computed it */
        var down_belowContentLineIndent = -1;
        var down_resolveIndents = function (lineNumber) {
            if (down_aboveContentLineIndex === -2) {
                down_aboveContentLineIndex = -1;
                down_aboveContentLineIndent = -1;
                // must find previous line with content
                for (var lineIndex = lineNumber - 2; lineIndex >= 0; lineIndex--) {
                    var indent_3 = _this._computeIndentLevel(lineIndex);
                    if (indent_3 >= 0) {
                        down_aboveContentLineIndex = lineIndex;
                        down_aboveContentLineIndent = indent_3;
                        break;
                    }
                }
            }
            if (down_belowContentLineIndex !== -1 && (down_belowContentLineIndex === -2 || down_belowContentLineIndex < lineNumber - 1)) {
                down_belowContentLineIndex = -1;
                down_belowContentLineIndent = -1;
                // must find next line with content
                for (var lineIndex = lineNumber; lineIndex < lineCount; lineIndex++) {
                    var indent_4 = _this._computeIndentLevel(lineIndex);
                    if (indent_4 >= 0) {
                        down_belowContentLineIndex = lineIndex;
                        down_belowContentLineIndent = indent_4;
                        break;
                    }
                }
            }
        };
        var startLineNumber = 0;
        var goUp = true;
        var endLineNumber = 0;
        var goDown = true;
        var indent = 0;
        for (var distance = 0; goUp || goDown; distance++) {
            var upLineNumber = lineNumber - distance;
            var downLineNumber = lineNumber + distance;
            if (upLineNumber < 1 || upLineNumber < minLineNumber) {
                goUp = false;
            }
            if (downLineNumber > lineCount || downLineNumber > maxLineNumber) {
                goDown = false;
            }
            if (distance > 50000) {
                // stop processing
                goUp = false;
                goDown = false;
            }
            if (goUp) {
                // compute indent level going up
                var upLineIndentLevel = void 0;
                var currentIndent = this._computeIndentLevel(upLineNumber - 1);
                if (currentIndent >= 0) {
                    // This line has content (besides whitespace)
                    // Use the line's indent
                    up_belowContentLineIndex = upLineNumber - 1;
                    up_belowContentLineIndent = currentIndent;
                    upLineIndentLevel = Math.ceil(currentIndent / this._options.tabSize);
                }
                else {
                    up_resolveIndents(upLineNumber);
                    upLineIndentLevel = this._getIndentLevelForWhitespaceLine(offSide, up_aboveContentLineIndent, up_belowContentLineIndent);
                }
                if (distance === 0) {
                    // This is the initial line number
                    startLineNumber = upLineNumber;
                    endLineNumber = downLineNumber;
                    indent = upLineIndentLevel;
                    if (indent === 0) {
                        // No need to continue
                        return { startLineNumber: startLineNumber, endLineNumber: endLineNumber, indent: indent };
                    }
                    continue;
                }
                if (upLineIndentLevel >= indent) {
                    startLineNumber = upLineNumber;
                }
                else {
                    goUp = false;
                }
            }
            if (goDown) {
                // compute indent level going down
                var downLineIndentLevel = void 0;
                var currentIndent = this._computeIndentLevel(downLineNumber - 1);
                if (currentIndent >= 0) {
                    // This line has content (besides whitespace)
                    // Use the line's indent
                    down_aboveContentLineIndex = downLineNumber - 1;
                    down_aboveContentLineIndent = currentIndent;
                    downLineIndentLevel = Math.ceil(currentIndent / this._options.tabSize);
                }
                else {
                    down_resolveIndents(downLineNumber);
                    downLineIndentLevel = this._getIndentLevelForWhitespaceLine(offSide, down_aboveContentLineIndent, down_belowContentLineIndent);
                }
                if (downLineIndentLevel >= indent) {
                    endLineNumber = downLineNumber;
                }
                else {
                    goDown = false;
                }
            }
        }
        return { startLineNumber: startLineNumber, endLineNumber: endLineNumber, indent: indent };
    };
    TextModel.prototype.getLinesIndentGuides = function (startLineNumber, endLineNumber) {
        this._assertNotDisposed();
        var lineCount = this.getLineCount();
        if (startLineNumber < 1 || startLineNumber > lineCount) {
            throw new Error('Illegal value for startLineNumber');
        }
        if (endLineNumber < 1 || endLineNumber > lineCount) {
            throw new Error('Illegal value for endLineNumber');
        }
        var foldingRules = LanguageConfigurationRegistry.getFoldingRules(this._languageIdentifier.id);
        var offSide = foldingRules && foldingRules.offSide;
        var result = new Array(endLineNumber - startLineNumber + 1);
        var aboveContentLineIndex = -2; /* -2 is a marker for not having computed it */
        var aboveContentLineIndent = -1;
        var belowContentLineIndex = -2; /* -2 is a marker for not having computed it */
        var belowContentLineIndent = -1;
        for (var lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {
            var resultIndex = lineNumber - startLineNumber;
            var currentIndent = this._computeIndentLevel(lineNumber - 1);
            if (currentIndent >= 0) {
                // This line has content (besides whitespace)
                // Use the line's indent
                aboveContentLineIndex = lineNumber - 1;
                aboveContentLineIndent = currentIndent;
                result[resultIndex] = Math.ceil(currentIndent / this._options.tabSize);
                continue;
            }
            if (aboveContentLineIndex === -2) {
                aboveContentLineIndex = -1;
                aboveContentLineIndent = -1;
                // must find previous line with content
                for (var lineIndex = lineNumber - 2; lineIndex >= 0; lineIndex--) {
                    var indent = this._computeIndentLevel(lineIndex);
                    if (indent >= 0) {
                        aboveContentLineIndex = lineIndex;
                        aboveContentLineIndent = indent;
                        break;
                    }
                }
            }
            if (belowContentLineIndex !== -1 && (belowContentLineIndex === -2 || belowContentLineIndex < lineNumber - 1)) {
                belowContentLineIndex = -1;
                belowContentLineIndent = -1;
                // must find next line with content
                for (var lineIndex = lineNumber; lineIndex < lineCount; lineIndex++) {
                    var indent = this._computeIndentLevel(lineIndex);
                    if (indent >= 0) {
                        belowContentLineIndex = lineIndex;
                        belowContentLineIndent = indent;
                        break;
                    }
                }
            }
            result[resultIndex] = this._getIndentLevelForWhitespaceLine(offSide, aboveContentLineIndent, belowContentLineIndent);
        }
        return result;
    };
    TextModel.prototype._getIndentLevelForWhitespaceLine = function (offSide, aboveContentLineIndent, belowContentLineIndent) {
        if (aboveContentLineIndent === -1 || belowContentLineIndent === -1) {
            // At the top or bottom of the file
            return 0;
        }
        else if (aboveContentLineIndent < belowContentLineIndent) {
            // we are inside the region above
            return (1 + Math.floor(aboveContentLineIndent / this._options.tabSize));
        }
        else if (aboveContentLineIndent === belowContentLineIndent) {
            // we are in between two regions
            return Math.ceil(belowContentLineIndent / this._options.tabSize);
        }
        else {
            if (offSide) {
                // same level as region below
                return Math.ceil(belowContentLineIndent / this._options.tabSize);
            }
            else {
                // we are inside the region that ends below
                return (1 + Math.floor(belowContentLineIndent / this._options.tabSize));
            }
        }
    };
    TextModel.MODEL_SYNC_LIMIT = 50 * 1024 * 1024; // 50 MB
    TextModel.LARGE_FILE_SIZE_THRESHOLD = 20 * 1024 * 1024; // 20 MB;
    TextModel.LARGE_FILE_LINE_COUNT_THRESHOLD = 300 * 1000; // 300K lines
    TextModel.DEFAULT_CREATION_OPTIONS = {
        isForSimpleWidget: false,
        tabSize: EDITOR_MODEL_DEFAULTS.tabSize,
        insertSpaces: EDITOR_MODEL_DEFAULTS.insertSpaces,
        detectIndentation: false,
        defaultEOL: DefaultEndOfLine.LF,
        trimAutoWhitespace: EDITOR_MODEL_DEFAULTS.trimAutoWhitespace,
        largeFileOptimizations: EDITOR_MODEL_DEFAULTS.largeFileOptimizations,
    };
    return TextModel;
}(Disposable));
//#region Decorations
var DecorationsTrees = /** @class */ (function () {
    function DecorationsTrees() {
        this._decorationsTree0 = new IntervalTree();
        this._decorationsTree1 = new IntervalTree();
    }
    DecorationsTrees.prototype.intervalSearch = function (start, end, filterOwnerId, filterOutValidation, cachedVersionId) {
        var r0 = this._decorationsTree0.intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId);
        var r1 = this._decorationsTree1.intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId);
        return r0.concat(r1);
    };
    DecorationsTrees.prototype.search = function (filterOwnerId, filterOutValidation, overviewRulerOnly, cachedVersionId) {
        if (overviewRulerOnly) {
            return this._decorationsTree1.search(filterOwnerId, filterOutValidation, cachedVersionId);
        }
        else {
            var r0 = this._decorationsTree0.search(filterOwnerId, filterOutValidation, cachedVersionId);
            var r1 = this._decorationsTree1.search(filterOwnerId, filterOutValidation, cachedVersionId);
            return r0.concat(r1);
        }
    };
    DecorationsTrees.prototype.collectNodesFromOwner = function (ownerId) {
        var r0 = this._decorationsTree0.collectNodesFromOwner(ownerId);
        var r1 = this._decorationsTree1.collectNodesFromOwner(ownerId);
        return r0.concat(r1);
    };
    DecorationsTrees.prototype.collectNodesPostOrder = function () {
        var r0 = this._decorationsTree0.collectNodesPostOrder();
        var r1 = this._decorationsTree1.collectNodesPostOrder();
        return r0.concat(r1);
    };
    DecorationsTrees.prototype.insert = function (node) {
        if (getNodeIsInOverviewRuler(node)) {
            this._decorationsTree1.insert(node);
        }
        else {
            this._decorationsTree0.insert(node);
        }
    };
    DecorationsTrees.prototype.delete = function (node) {
        if (getNodeIsInOverviewRuler(node)) {
            this._decorationsTree1.delete(node);
        }
        else {
            this._decorationsTree0.delete(node);
        }
    };
    DecorationsTrees.prototype.resolveNode = function (node, cachedVersionId) {
        if (getNodeIsInOverviewRuler(node)) {
            this._decorationsTree1.resolveNode(node, cachedVersionId);
        }
        else {
            this._decorationsTree0.resolveNode(node, cachedVersionId);
        }
    };
    DecorationsTrees.prototype.acceptReplace = function (offset, length, textLength, forceMoveMarkers) {
        this._decorationsTree0.acceptReplace(offset, length, textLength, forceMoveMarkers);
        this._decorationsTree1.acceptReplace(offset, length, textLength, forceMoveMarkers);
    };
    return DecorationsTrees;
}());
function cleanClassName(className) {
    return className.replace(/[^a-z0-9\-]/gi, ' ');
}
var ModelDecorationOverviewRulerOptions = /** @class */ (function () {
    function ModelDecorationOverviewRulerOptions(options) {
        this.color = empty;
        this.darkColor = empty;
        this.hcColor = empty;
        this.position = OverviewRulerLane.Center;
        this._resolvedColor = null;
        if (options && options.color) {
            this.color = options.color;
        }
        if (options && options.darkColor) {
            this.darkColor = options.darkColor;
            this.hcColor = options.darkColor;
        }
        if (options && options.hcColor) {
            this.hcColor = options.hcColor;
        }
        if (options && options.hasOwnProperty('position')) {
            this.position = options.position;
        }
    }
    return ModelDecorationOverviewRulerOptions;
}());
var ModelDecorationOptions = /** @class */ (function () {
    function ModelDecorationOptions(options) {
        this.stickiness = options.stickiness || TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges;
        this.zIndex = options.zIndex || 0;
        this.className = options.className ? cleanClassName(options.className) : empty;
        this.hoverMessage = options.hoverMessage || [];
        this.glyphMarginHoverMessage = options.glyphMarginHoverMessage || [];
        this.isWholeLine = options.isWholeLine || false;
        this.showIfCollapsed = options.showIfCollapsed || false;
        this.overviewRuler = new ModelDecorationOverviewRulerOptions(options.overviewRuler);
        this.glyphMarginClassName = options.glyphMarginClassName ? cleanClassName(options.glyphMarginClassName) : empty;
        this.linesDecorationsClassName = options.linesDecorationsClassName ? cleanClassName(options.linesDecorationsClassName) : empty;
        this.marginClassName = options.marginClassName ? cleanClassName(options.marginClassName) : empty;
        this.inlineClassName = options.inlineClassName ? cleanClassName(options.inlineClassName) : empty;
        this.inlineClassNameAffectsLetterSpacing = options.inlineClassNameAffectsLetterSpacing || false;
        this.beforeContentClassName = options.beforeContentClassName ? cleanClassName(options.beforeContentClassName) : empty;
        this.afterContentClassName = options.afterContentClassName ? cleanClassName(options.afterContentClassName) : empty;
    }
    ModelDecorationOptions.register = function (options) {
        return new ModelDecorationOptions(options);
    };
    ModelDecorationOptions.createDynamic = function (options) {
        return new ModelDecorationOptions(options);
    };
    return ModelDecorationOptions;
}());
ModelDecorationOptions.EMPTY = ModelDecorationOptions.register({});
/**
 * The order carefully matches the values of the enum.
 */
var TRACKED_RANGE_OPTIONS = [
    ModelDecorationOptions.register({ stickiness: TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges }),
    ModelDecorationOptions.register({ stickiness: TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges }),
    ModelDecorationOptions.register({ stickiness: TrackedRangeStickiness.GrowsOnlyWhenTypingBefore }),
    ModelDecorationOptions.register({ stickiness: TrackedRangeStickiness.GrowsOnlyWhenTypingAfter }),
];
function _normalizeOptions(options) {
    if (options instanceof ModelDecorationOptions) {
        return options;
    }
    return ModelDecorationOptions.createDynamic(options);
}
var DidChangeDecorationsEmitter = /** @class */ (function (_super) {
    __extends$a(DidChangeDecorationsEmitter, _super);
    function DidChangeDecorationsEmitter() {
        var _this = _super.call(this) || this;
        _this._actual = _this._register(new Emitter());
        _this.event = _this._actual.event;
        _this._deferredCnt = 0;
        _this._shouldFire = false;
        return _this;
    }
    DidChangeDecorationsEmitter.prototype.beginDeferredEmit = function () {
        this._deferredCnt++;
    };
    DidChangeDecorationsEmitter.prototype.endDeferredEmit = function () {
        this._deferredCnt--;
        if (this._deferredCnt === 0) {
            if (this._shouldFire) {
                this._shouldFire = false;
                this._actual.fire({});
            }
        }
    };
    DidChangeDecorationsEmitter.prototype.fire = function () {
        this._shouldFire = true;
    };
    return DidChangeDecorationsEmitter;
}(Disposable));
//#endregion
var DidChangeContentEmitter = /** @class */ (function (_super) {
    __extends$a(DidChangeContentEmitter, _super);
    function DidChangeContentEmitter() {
        var _this = _super.call(this) || this;
        /**
         * Both `fastEvent` and `slowEvent` work the same way and contain the same events, but first we invoke `fastEvent` and then `slowEvent`.
         */
        _this._fastEmitter = _this._register(new Emitter());
        _this.fastEvent = _this._fastEmitter.event;
        _this._slowEmitter = _this._register(new Emitter());
        _this.slowEvent = _this._slowEmitter.event;
        _this._deferredCnt = 0;
        _this._deferredEvent = null;
        return _this;
    }
    DidChangeContentEmitter.prototype.beginDeferredEmit = function () {
        this._deferredCnt++;
    };
    DidChangeContentEmitter.prototype.endDeferredEmit = function () {
        this._deferredCnt--;
        if (this._deferredCnt === 0) {
            if (this._deferredEvent !== null) {
                var e = this._deferredEvent;
                this._deferredEvent = null;
                this._fastEmitter.fire(e);
                this._slowEmitter.fire(e);
            }
        }
    };
    DidChangeContentEmitter.prototype.fire = function (e) {
        if (this._deferredCnt > 0) {
            if (this._deferredEvent) {
                this._deferredEvent = this._deferredEvent.merge(e);
            }
            else {
                this._deferredEvent = e;
            }
            return;
        }
        this._fastEmitter.fire(e);
        this._slowEmitter.fire(e);
    };
    return DidChangeContentEmitter;
}(Disposable));

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var CursorConfiguration = /** @class */ (function () {
    function CursorConfiguration(languageIdentifier, oneIndent, modelOptions, configuration) {
        this._languageIdentifier = languageIdentifier;
        var c = configuration.editor;
        this.readOnly = c.readOnly;
        this.tabSize = modelOptions.tabSize;
        this.insertSpaces = modelOptions.insertSpaces;
        this.oneIndent = oneIndent;
        this.pageSize = Math.floor(c.layoutInfo.height / c.fontInfo.lineHeight) - 2;
        this.lineHeight = c.lineHeight;
        this.useTabStops = c.useTabStops;
        this.wordSeparators = c.wordSeparators;
        this.emptySelectionClipboard = c.emptySelectionClipboard;
        this.multiCursorMergeOverlapping = c.multiCursorMergeOverlapping;
        this.autoClosingBrackets = c.autoClosingBrackets;
        this.autoIndent = c.autoIndent;
        this.autoClosingPairsOpen = {};
        this.autoClosingPairsClose = {};
        this.surroundingPairs = {};
        this._electricChars = null;
        var autoClosingPairs = CursorConfiguration._getAutoClosingPairs(languageIdentifier);
        if (autoClosingPairs) {
            for (var i = 0; i < autoClosingPairs.length; i++) {
                this.autoClosingPairsOpen[autoClosingPairs[i].open] = autoClosingPairs[i].close;
                this.autoClosingPairsClose[autoClosingPairs[i].close] = autoClosingPairs[i].open;
            }
        }
        var surroundingPairs = CursorConfiguration._getSurroundingPairs(languageIdentifier);
        if (surroundingPairs) {
            for (var i = 0; i < surroundingPairs.length; i++) {
                this.surroundingPairs[surroundingPairs[i].open] = surroundingPairs[i].close;
            }
        }
    }
    CursorConfiguration.shouldRecreate = function (e) {
        return (e.layoutInfo
            || e.wordSeparators
            || e.emptySelectionClipboard
            || e.multiCursorMergeOverlapping
            || e.autoClosingBrackets
            || e.useTabStops
            || e.lineHeight
            || e.readOnly);
    };
    Object.defineProperty(CursorConfiguration.prototype, "electricChars", {
        get: function () {
            if (!this._electricChars) {
                this._electricChars = {};
                var electricChars = CursorConfiguration._getElectricCharacters(this._languageIdentifier);
                if (electricChars) {
                    for (var i = 0; i < electricChars.length; i++) {
                        this._electricChars[electricChars[i]] = true;
                    }
                }
            }
            return this._electricChars;
        },
        enumerable: true,
        configurable: true
    });
    CursorConfiguration.prototype.normalizeIndentation = function (str) {
        return TextModel.normalizeIndentation(str, this.tabSize, this.insertSpaces);
    };
    CursorConfiguration._getElectricCharacters = function (languageIdentifier) {
        try {
            return LanguageConfigurationRegistry.getElectricCharacters(languageIdentifier.id);
        }
        catch (e) {
            onUnexpectedError(e);
            return null;
        }
    };
    CursorConfiguration._getAutoClosingPairs = function (languageIdentifier) {
        try {
            return LanguageConfigurationRegistry.getAutoClosingPairs(languageIdentifier.id);
        }
        catch (e) {
            onUnexpectedError(e);
            return null;
        }
    };
    CursorConfiguration._getSurroundingPairs = function (languageIdentifier) {
        try {
            return LanguageConfigurationRegistry.getSurroundingPairs(languageIdentifier.id);
        }
        catch (e) {
            onUnexpectedError(e);
            return null;
        }
    };
    return CursorConfiguration;
}());
/**
 * Represents the cursor state on either the model or on the view model.
 */
var SingleCursorState = /** @class */ (function () {
    function SingleCursorState(selectionStart, selectionStartLeftoverVisibleColumns, position, leftoverVisibleColumns) {
        this.selectionStart = selectionStart;
        this.selectionStartLeftoverVisibleColumns = selectionStartLeftoverVisibleColumns;
        this.position = position;
        this.leftoverVisibleColumns = leftoverVisibleColumns;
        this.selection = SingleCursorState._computeSelection(this.selectionStart, this.position);
    }
    SingleCursorState.prototype.equals = function (other) {
        return (this.selectionStartLeftoverVisibleColumns === other.selectionStartLeftoverVisibleColumns
            && this.leftoverVisibleColumns === other.leftoverVisibleColumns
            && this.position.equals(other.position)
            && this.selectionStart.equalsRange(other.selectionStart));
    };
    SingleCursorState.prototype.hasSelection = function () {
        return (!this.selection.isEmpty() || !this.selectionStart.isEmpty());
    };
    SingleCursorState.prototype.move = function (inSelectionMode, lineNumber, column, leftoverVisibleColumns) {
        if (inSelectionMode) {
            // move just position
            return new SingleCursorState(this.selectionStart, this.selectionStartLeftoverVisibleColumns, new Position(lineNumber, column), leftoverVisibleColumns);
        }
        else {
            // move everything
            return new SingleCursorState(new Range(lineNumber, column, lineNumber, column), leftoverVisibleColumns, new Position(lineNumber, column), leftoverVisibleColumns);
        }
    };
    SingleCursorState._computeSelection = function (selectionStart, position) {
        var startLineNumber, startColumn, endLineNumber, endColumn;
        if (selectionStart.isEmpty()) {
            startLineNumber = selectionStart.startLineNumber;
            startColumn = selectionStart.startColumn;
            endLineNumber = position.lineNumber;
            endColumn = position.column;
        }
        else {
            if (position.isBeforeOrEqual(selectionStart.getStartPosition())) {
                startLineNumber = selectionStart.endLineNumber;
                startColumn = selectionStart.endColumn;
                endLineNumber = position.lineNumber;
                endColumn = position.column;
            }
            else {
                startLineNumber = selectionStart.startLineNumber;
                startColumn = selectionStart.startColumn;
                endLineNumber = position.lineNumber;
                endColumn = position.column;
            }
        }
        return new Selection(startLineNumber, startColumn, endLineNumber, endColumn);
    };
    return SingleCursorState;
}());
var CursorContext = /** @class */ (function () {
    function CursorContext(configuration, model, viewModel) {
        this.model = model;
        this.viewModel = viewModel;
        this.config = new CursorConfiguration(this.model.getLanguageIdentifier(), this.model.getOneIndent(), this.model.getOptions(), configuration);
    }
    CursorContext.prototype.validateViewPosition = function (viewPosition, modelPosition) {
        return this.viewModel.coordinatesConverter.validateViewPosition(viewPosition, modelPosition);
    };
    CursorContext.prototype.validateViewRange = function (viewRange, expectedModelRange) {
        return this.viewModel.coordinatesConverter.validateViewRange(viewRange, expectedModelRange);
    };
    CursorContext.prototype.convertViewRangeToModelRange = function (viewRange) {
        return this.viewModel.coordinatesConverter.convertViewRangeToModelRange(viewRange);
    };
    CursorContext.prototype.convertViewPositionToModelPosition = function (lineNumber, column) {
        return this.viewModel.coordinatesConverter.convertViewPositionToModelPosition(new Position(lineNumber, column));
    };
    CursorContext.prototype.convertModelPositionToViewPosition = function (modelPosition) {
        return this.viewModel.coordinatesConverter.convertModelPositionToViewPosition(modelPosition);
    };
    CursorContext.prototype.convertModelRangeToViewRange = function (modelRange) {
        return this.viewModel.coordinatesConverter.convertModelRangeToViewRange(modelRange);
    };
    CursorContext.prototype.getCurrentScrollTop = function () {
        return this.viewModel.viewLayout.getCurrentScrollTop();
    };
    CursorContext.prototype.getCompletelyVisibleViewRange = function () {
        return this.viewModel.getCompletelyVisibleViewRange();
    };
    CursorContext.prototype.getCompletelyVisibleModelRange = function () {
        var viewRange = this.viewModel.getCompletelyVisibleViewRange();
        return this.viewModel.coordinatesConverter.convertViewRangeToModelRange(viewRange);
    };
    CursorContext.prototype.getCompletelyVisibleViewRangeAtScrollTop = function (scrollTop) {
        return this.viewModel.getCompletelyVisibleViewRangeAtScrollTop(scrollTop);
    };
    CursorContext.prototype.getVerticalOffsetForViewLine = function (viewLineNumber) {
        return this.viewModel.viewLayout.getVerticalOffsetForLineNumber(viewLineNumber);
    };
    return CursorContext;
}());
var CursorState = /** @class */ (function () {
    function CursorState(modelState, viewState) {
        this.modelState = modelState;
        this.viewState = viewState;
    }
    CursorState.fromModelState = function (modelState) {
        return new CursorState(modelState, null);
    };
    CursorState.fromViewState = function (viewState) {
        return new CursorState(null, viewState);
    };
    CursorState.fromModelSelection = function (modelSelection) {
        var selectionStartLineNumber = modelSelection.selectionStartLineNumber;
        var selectionStartColumn = modelSelection.selectionStartColumn;
        var positionLineNumber = modelSelection.positionLineNumber;
        var positionColumn = modelSelection.positionColumn;
        var modelState = new SingleCursorState(new Range(selectionStartLineNumber, selectionStartColumn, selectionStartLineNumber, selectionStartColumn), 0, new Position(positionLineNumber, positionColumn), 0);
        return CursorState.fromModelState(modelState);
    };
    CursorState.fromModelSelections = function (modelSelections) {
        var states = [];
        for (var i = 0, len = modelSelections.length; i < len; i++) {
            states[i] = this.fromModelSelection(modelSelections[i]);
        }
        return states;
    };
    CursorState.prototype.equals = function (other) {
        return (this.viewState.equals(other.viewState) && this.modelState.equals(other.modelState));
    };
    return CursorState;
}());
var EditOperationResult = /** @class */ (function () {
    function EditOperationResult(type, commands, opts) {
        this.type = type;
        this.commands = commands;
        this.shouldPushStackElementBefore = opts.shouldPushStackElementBefore;
        this.shouldPushStackElementAfter = opts.shouldPushStackElementAfter;
    }
    return EditOperationResult;
}());
/**
 * Common operations that work and make sense both on the model and on the view model.
 */
var CursorColumns = /** @class */ (function () {
    function CursorColumns() {
    }
    CursorColumns.isLowSurrogate = function (model, lineNumber, charOffset) {
        var lineContent = model.getLineContent(lineNumber);
        if (charOffset < 0 || charOffset >= lineContent.length) {
            return false;
        }
        return isLowSurrogate(lineContent.charCodeAt(charOffset));
    };
    CursorColumns.isHighSurrogate = function (model, lineNumber, charOffset) {
        var lineContent = model.getLineContent(lineNumber);
        if (charOffset < 0 || charOffset >= lineContent.length) {
            return false;
        }
        return isHighSurrogate(lineContent.charCodeAt(charOffset));
    };
    CursorColumns.isInsideSurrogatePair = function (model, lineNumber, column) {
        return this.isHighSurrogate(model, lineNumber, column - 2);
    };
    CursorColumns.visibleColumnFromColumn = function (lineContent, column, tabSize) {
        var endOffset = lineContent.length;
        if (endOffset > column - 1) {
            endOffset = column - 1;
        }
        var result = 0;
        for (var i = 0; i < endOffset; i++) {
            var charCode = lineContent.charCodeAt(i);
            if (charCode === 9 /* Tab */) {
                result = this.nextTabStop(result, tabSize);
            }
            else if (isFullWidthCharacter(charCode)) {
                result = result + 2;
            }
            else {
                result = result + 1;
            }
        }
        return result;
    };
    CursorColumns.visibleColumnFromColumn2 = function (config, model, position) {
        return this.visibleColumnFromColumn(model.getLineContent(position.lineNumber), position.column, config.tabSize);
    };
    CursorColumns.columnFromVisibleColumn = function (lineContent, visibleColumn, tabSize) {
        if (visibleColumn <= 0) {
            return 1;
        }
        var lineLength = lineContent.length;
        var beforeVisibleColumn = 0;
        for (var i = 0; i < lineLength; i++) {
            var charCode = lineContent.charCodeAt(i);
            var afterVisibleColumn = void 0;
            if (charCode === 9 /* Tab */) {
                afterVisibleColumn = this.nextTabStop(beforeVisibleColumn, tabSize);
            }
            else if (isFullWidthCharacter(charCode)) {
                afterVisibleColumn = beforeVisibleColumn + 2;
            }
            else {
                afterVisibleColumn = beforeVisibleColumn + 1;
            }
            if (afterVisibleColumn >= visibleColumn) {
                var prevDelta = visibleColumn - beforeVisibleColumn;
                var afterDelta = afterVisibleColumn - visibleColumn;
                if (afterDelta < prevDelta) {
                    return i + 2;
                }
                else {
                    return i + 1;
                }
            }
            beforeVisibleColumn = afterVisibleColumn;
        }
        // walked the entire string
        return lineLength + 1;
    };
    CursorColumns.columnFromVisibleColumn2 = function (config, model, lineNumber, visibleColumn) {
        var result = this.columnFromVisibleColumn(model.getLineContent(lineNumber), visibleColumn, config.tabSize);
        var minColumn = model.getLineMinColumn(lineNumber);
        if (result < minColumn) {
            return minColumn;
        }
        var maxColumn = model.getLineMaxColumn(lineNumber);
        if (result > maxColumn) {
            return maxColumn;
        }
        return result;
    };
    /**
     * ATTENTION: This works with 0-based columns (as oposed to the regular 1-based columns)
     */
    CursorColumns.nextTabStop = function (visibleColumn, tabSize) {
        return visibleColumn + tabSize - visibleColumn % tabSize;
    };
    /**
     * ATTENTION: This works with 0-based columns (as oposed to the regular 1-based columns)
     */
    CursorColumns.prevTabStop = function (column, tabSize) {
        return column - 1 - (column - 1) % tabSize;
    };
    return CursorColumns;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var OneCursor = /** @class */ (function () {
    function OneCursor(context) {
        this.modelState = null;
        this.viewState = null;
        this._selTrackedRange = null;
        this._trackSelection = true;
        this._setState(context, new SingleCursorState(new Range(1, 1, 1, 1), 0, new Position(1, 1), 0), new SingleCursorState(new Range(1, 1, 1, 1), 0, new Position(1, 1), 0));
    }
    OneCursor.prototype.dispose = function (context) {
        this._removeTrackedRange(context);
    };
    OneCursor.prototype.startTrackingSelection = function (context) {
        this._trackSelection = true;
        this._updateTrackedRange(context);
    };
    OneCursor.prototype.stopTrackingSelection = function (context) {
        this._trackSelection = false;
        this._removeTrackedRange(context);
    };
    OneCursor.prototype._updateTrackedRange = function (context) {
        if (!this._trackSelection) {
            // don't track the selection
            return;
        }
        this._selTrackedRange = context.model._setTrackedRange(this._selTrackedRange, this.modelState.selection, TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges);
    };
    OneCursor.prototype._removeTrackedRange = function (context) {
        this._selTrackedRange = context.model._setTrackedRange(this._selTrackedRange, null, TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges);
    };
    OneCursor.prototype.asCursorState = function () {
        return new CursorState(this.modelState, this.viewState);
    };
    OneCursor.prototype.readSelectionFromMarkers = function (context) {
        var range = context.model._getTrackedRange(this._selTrackedRange);
        if (this.modelState.selection.getDirection() === SelectionDirection.LTR) {
            return new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);
        }
        return new Selection(range.endLineNumber, range.endColumn, range.startLineNumber, range.startColumn);
    };
    OneCursor.prototype.ensureValidState = function (context) {
        this._setState(context, this.modelState, this.viewState);
    };
    OneCursor.prototype.setState = function (context, modelState, viewState) {
        this._setState(context, modelState, viewState);
    };
    OneCursor.prototype._setState = function (context, modelState, viewState) {
        if (!modelState) {
            // We only have the view state => compute the model state
            var selectionStart = context.model.validateRange(context.convertViewRangeToModelRange(viewState.selectionStart));
            var position = context.model.validatePosition(context.convertViewPositionToModelPosition(viewState.position.lineNumber, viewState.position.column));
            modelState = new SingleCursorState(selectionStart, viewState.selectionStartLeftoverVisibleColumns, position, viewState.leftoverVisibleColumns);
        }
        else {
            // Validate new model state
            var selectionStart = context.model.validateRange(modelState.selectionStart);
            var selectionStartLeftoverVisibleColumns = modelState.selectionStart.equalsRange(selectionStart) ? modelState.selectionStartLeftoverVisibleColumns : 0;
            var position = context.model.validatePosition(modelState.position);
            var leftoverVisibleColumns = modelState.position.equals(position) ? modelState.leftoverVisibleColumns : 0;
            modelState = new SingleCursorState(selectionStart, selectionStartLeftoverVisibleColumns, position, leftoverVisibleColumns);
        }
        if (!viewState) {
            // We only have the model state => compute the view state
            var viewSelectionStart1 = context.convertModelPositionToViewPosition(new Position(modelState.selectionStart.startLineNumber, modelState.selectionStart.startColumn));
            var viewSelectionStart2 = context.convertModelPositionToViewPosition(new Position(modelState.selectionStart.endLineNumber, modelState.selectionStart.endColumn));
            var viewSelectionStart = new Range(viewSelectionStart1.lineNumber, viewSelectionStart1.column, viewSelectionStart2.lineNumber, viewSelectionStart2.column);
            var viewPosition = context.convertModelPositionToViewPosition(modelState.position);
            viewState = new SingleCursorState(viewSelectionStart, modelState.selectionStartLeftoverVisibleColumns, viewPosition, modelState.leftoverVisibleColumns);
        }
        else {
            // Validate new view state
            var viewSelectionStart = context.validateViewRange(viewState.selectionStart, modelState.selectionStart);
            var viewPosition = context.validateViewPosition(viewState.position, modelState.position);
            viewState = new SingleCursorState(viewSelectionStart, modelState.selectionStartLeftoverVisibleColumns, viewPosition, modelState.leftoverVisibleColumns);
        }
        this.modelState = modelState;
        this.viewState = viewState;
        this._updateTrackedRange(context);
    };
    return OneCursor;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var CursorCollection = /** @class */ (function () {
    function CursorCollection(context) {
        this.context = context;
        this.primaryCursor = new OneCursor(context);
        this.secondaryCursors = [];
        this.lastAddedCursorIndex = 0;
    }
    CursorCollection.prototype.dispose = function () {
        this.primaryCursor.dispose(this.context);
        this.killSecondaryCursors();
    };
    CursorCollection.prototype.startTrackingSelections = function () {
        this.primaryCursor.startTrackingSelection(this.context);
        for (var i = 0, len = this.secondaryCursors.length; i < len; i++) {
            this.secondaryCursors[i].startTrackingSelection(this.context);
        }
    };
    CursorCollection.prototype.stopTrackingSelections = function () {
        this.primaryCursor.stopTrackingSelection(this.context);
        for (var i = 0, len = this.secondaryCursors.length; i < len; i++) {
            this.secondaryCursors[i].stopTrackingSelection(this.context);
        }
    };
    CursorCollection.prototype.updateContext = function (context) {
        this.context = context;
    };
    CursorCollection.prototype.ensureValidState = function () {
        this.primaryCursor.ensureValidState(this.context);
        for (var i = 0, len = this.secondaryCursors.length; i < len; i++) {
            this.secondaryCursors[i].ensureValidState(this.context);
        }
    };
    CursorCollection.prototype.readSelectionFromMarkers = function () {
        var result = [];
        result[0] = this.primaryCursor.readSelectionFromMarkers(this.context);
        for (var i = 0, len = this.secondaryCursors.length; i < len; i++) {
            result[i + 1] = this.secondaryCursors[i].readSelectionFromMarkers(this.context);
        }
        return result;
    };
    CursorCollection.prototype.getAll = function () {
        var result = [];
        result[0] = this.primaryCursor.asCursorState();
        for (var i = 0, len = this.secondaryCursors.length; i < len; i++) {
            result[i + 1] = this.secondaryCursors[i].asCursorState();
        }
        return result;
    };
    CursorCollection.prototype.getViewPositions = function () {
        var result = [];
        result[0] = this.primaryCursor.viewState.position;
        for (var i = 0, len = this.secondaryCursors.length; i < len; i++) {
            result[i + 1] = this.secondaryCursors[i].viewState.position;
        }
        return result;
    };
    CursorCollection.prototype.getSelections = function () {
        var result = [];
        result[0] = this.primaryCursor.modelState.selection;
        for (var i = 0, len = this.secondaryCursors.length; i < len; i++) {
            result[i + 1] = this.secondaryCursors[i].modelState.selection;
        }
        return result;
    };
    CursorCollection.prototype.getViewSelections = function () {
        var result = [];
        result[0] = this.primaryCursor.viewState.selection;
        for (var i = 0, len = this.secondaryCursors.length; i < len; i++) {
            result[i + 1] = this.secondaryCursors[i].viewState.selection;
        }
        return result;
    };
    CursorCollection.prototype.setSelections = function (selections) {
        this.setStates(CursorState.fromModelSelections(selections));
    };
    CursorCollection.prototype.getPrimaryCursor = function () {
        return this.primaryCursor.asCursorState();
    };
    CursorCollection.prototype.setStates = function (states) {
        if (states === null) {
            return;
        }
        this.primaryCursor.setState(this.context, states[0].modelState, states[0].viewState);
        this._setSecondaryStates(states.slice(1));
    };
    /**
     * Creates or disposes secondary cursors as necessary to match the number of `secondarySelections`.
     */
    CursorCollection.prototype._setSecondaryStates = function (secondaryStates) {
        var secondaryCursorsLength = this.secondaryCursors.length;
        var secondaryStatesLength = secondaryStates.length;
        if (secondaryCursorsLength < secondaryStatesLength) {
            var createCnt = secondaryStatesLength - secondaryCursorsLength;
            for (var i = 0; i < createCnt; i++) {
                this._addSecondaryCursor();
            }
        }
        else if (secondaryCursorsLength > secondaryStatesLength) {
            var removeCnt = secondaryCursorsLength - secondaryStatesLength;
            for (var i = 0; i < removeCnt; i++) {
                this._removeSecondaryCursor(this.secondaryCursors.length - 1);
            }
        }
        for (var i = 0; i < secondaryStatesLength; i++) {
            this.secondaryCursors[i].setState(this.context, secondaryStates[i].modelState, secondaryStates[i].viewState);
        }
    };
    CursorCollection.prototype.killSecondaryCursors = function () {
        this._setSecondaryStates([]);
    };
    CursorCollection.prototype._addSecondaryCursor = function () {
        this.secondaryCursors.push(new OneCursor(this.context));
        this.lastAddedCursorIndex = this.secondaryCursors.length;
    };
    CursorCollection.prototype.getLastAddedCursorIndex = function () {
        if (this.secondaryCursors.length === 0 || this.lastAddedCursorIndex === 0) {
            return 0;
        }
        return this.lastAddedCursorIndex;
    };
    CursorCollection.prototype._removeSecondaryCursor = function (removeIndex) {
        if (this.lastAddedCursorIndex >= removeIndex + 1) {
            this.lastAddedCursorIndex--;
        }
        this.secondaryCursors[removeIndex].dispose(this.context);
        this.secondaryCursors.splice(removeIndex, 1);
    };
    CursorCollection.prototype._getAll = function () {
        var result = [];
        result[0] = this.primaryCursor;
        for (var i = 0, len = this.secondaryCursors.length; i < len; i++) {
            result[i + 1] = this.secondaryCursors[i];
        }
        return result;
    };
    CursorCollection.prototype.normalize = function () {
        if (this.secondaryCursors.length === 0) {
            return;
        }
        var cursors = this._getAll();
        var sortedCursors = [];
        for (var i = 0, len = cursors.length; i < len; i++) {
            sortedCursors.push({
                index: i,
                selection: cursors[i].modelState.selection,
                viewSelection: cursors[i].viewState.selection
            });
        }
        sortedCursors.sort(function (a, b) {
            if (a.viewSelection.startLineNumber === b.viewSelection.startLineNumber) {
                return a.viewSelection.startColumn - b.viewSelection.startColumn;
            }
            return a.viewSelection.startLineNumber - b.viewSelection.startLineNumber;
        });
        for (var sortedCursorIndex = 0; sortedCursorIndex < sortedCursors.length - 1; sortedCursorIndex++) {
            var current = sortedCursors[sortedCursorIndex];
            var next = sortedCursors[sortedCursorIndex + 1];
            var currentViewSelection = current.viewSelection;
            var nextViewSelection = next.viewSelection;
            if (!this.context.config.multiCursorMergeOverlapping) {
                continue;
            }
            var shouldMergeCursors = void 0;
            if (nextViewSelection.isEmpty() || currentViewSelection.isEmpty()) {
                // Merge touching cursors if one of them is collapsed
                shouldMergeCursors = nextViewSelection.getStartPosition().isBeforeOrEqual(currentViewSelection.getEndPosition());
            }
            else {
                // Merge only overlapping cursors (i.e. allow touching ranges)
                shouldMergeCursors = nextViewSelection.getStartPosition().isBefore(currentViewSelection.getEndPosition());
            }
            if (shouldMergeCursors) {
                var winnerSortedCursorIndex = current.index < next.index ? sortedCursorIndex : sortedCursorIndex + 1;
                var looserSortedCursorIndex = current.index < next.index ? sortedCursorIndex + 1 : sortedCursorIndex;
                var looserIndex = sortedCursors[looserSortedCursorIndex].index;
                var winnerIndex = sortedCursors[winnerSortedCursorIndex].index;
                var looserSelection = sortedCursors[looserSortedCursorIndex].selection;
                var winnerSelection = sortedCursors[winnerSortedCursorIndex].selection;
                if (!looserSelection.equalsSelection(winnerSelection)) {
                    var resultingRange = looserSelection.plusRange(winnerSelection);
                    var looserSelectionIsLTR = (looserSelection.selectionStartLineNumber === looserSelection.startLineNumber && looserSelection.selectionStartColumn === looserSelection.startColumn);
                    var winnerSelectionIsLTR = (winnerSelection.selectionStartLineNumber === winnerSelection.startLineNumber && winnerSelection.selectionStartColumn === winnerSelection.startColumn);
                    // Give more importance to the last added cursor (think Ctrl-dragging + hitting another cursor)
                    var resultingSelectionIsLTR = void 0;
                    if (looserIndex === this.lastAddedCursorIndex) {
                        resultingSelectionIsLTR = looserSelectionIsLTR;
                        this.lastAddedCursorIndex = winnerIndex;
                    }
                    else {
                        // Winner takes it all
                        resultingSelectionIsLTR = winnerSelectionIsLTR;
                    }
                    var resultingSelection = void 0;
                    if (resultingSelectionIsLTR) {
                        resultingSelection = new Selection(resultingRange.startLineNumber, resultingRange.startColumn, resultingRange.endLineNumber, resultingRange.endColumn);
                    }
                    else {
                        resultingSelection = new Selection(resultingRange.endLineNumber, resultingRange.endColumn, resultingRange.startLineNumber, resultingRange.startColumn);
                    }
                    sortedCursors[winnerSortedCursorIndex].selection = resultingSelection;
                    var resultingState = CursorState.fromModelSelection(resultingSelection);
                    cursors[winnerIndex].setState(this.context, resultingState.modelState, resultingState.viewState);
                }
                for (var j = 0; j < sortedCursors.length; j++) {
                    if (sortedCursors[j].index > looserIndex) {
                        sortedCursors[j].index--;
                    }
                }
                cursors.splice(looserIndex, 1);
                sortedCursors.splice(looserSortedCursorIndex, 1);
                this._removeSecondaryCursor(looserIndex - 1);
                sortedCursorIndex--;
            }
        }
    };
    return CursorCollection;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var ReplaceCommand = /** @class */ (function () {
    function ReplaceCommand(range, text, insertsAutoWhitespace) {
        if (insertsAutoWhitespace === void 0) { insertsAutoWhitespace = false; }
        this._range = range;
        this._text = text;
        this.insertsAutoWhitespace = insertsAutoWhitespace;
    }
    ReplaceCommand.prototype.getEditOperations = function (model, builder) {
        builder.addTrackedEditOperation(this._range, this._text);
    };
    ReplaceCommand.prototype.computeCursorState = function (model, helper) {
        var inverseEditOperations = helper.getInverseEditOperations();
        var srcRange = inverseEditOperations[0].range;
        return new Selection(srcRange.endLineNumber, srcRange.endColumn, srcRange.endLineNumber, srcRange.endColumn);
    };
    return ReplaceCommand;
}());
var ReplaceCommandWithoutChangingPosition = /** @class */ (function () {
    function ReplaceCommandWithoutChangingPosition(range, text, insertsAutoWhitespace) {
        if (insertsAutoWhitespace === void 0) { insertsAutoWhitespace = false; }
        this._range = range;
        this._text = text;
        this.insertsAutoWhitespace = insertsAutoWhitespace;
    }
    ReplaceCommandWithoutChangingPosition.prototype.getEditOperations = function (model, builder) {
        builder.addTrackedEditOperation(this._range, this._text);
    };
    ReplaceCommandWithoutChangingPosition.prototype.computeCursorState = function (model, helper) {
        var inverseEditOperations = helper.getInverseEditOperations();
        var srcRange = inverseEditOperations[0].range;
        return new Selection(srcRange.startLineNumber, srcRange.startColumn, srcRange.startLineNumber, srcRange.startColumn);
    };
    return ReplaceCommandWithoutChangingPosition;
}());
var ReplaceCommandWithOffsetCursorState = /** @class */ (function () {
    function ReplaceCommandWithOffsetCursorState(range, text, lineNumberDeltaOffset, columnDeltaOffset, insertsAutoWhitespace) {
        if (insertsAutoWhitespace === void 0) { insertsAutoWhitespace = false; }
        this._range = range;
        this._text = text;
        this._columnDeltaOffset = columnDeltaOffset;
        this._lineNumberDeltaOffset = lineNumberDeltaOffset;
        this.insertsAutoWhitespace = insertsAutoWhitespace;
    }
    ReplaceCommandWithOffsetCursorState.prototype.getEditOperations = function (model, builder) {
        builder.addTrackedEditOperation(this._range, this._text);
    };
    ReplaceCommandWithOffsetCursorState.prototype.computeCursorState = function (model, helper) {
        var inverseEditOperations = helper.getInverseEditOperations();
        var srcRange = inverseEditOperations[0].range;
        return new Selection(srcRange.endLineNumber + this._lineNumberDeltaOffset, srcRange.endColumn + this._columnDeltaOffset, srcRange.endLineNumber + this._lineNumberDeltaOffset, srcRange.endColumn + this._columnDeltaOffset);
    };
    return ReplaceCommandWithOffsetCursorState;
}());
var ReplaceCommandThatPreservesSelection = /** @class */ (function () {
    function ReplaceCommandThatPreservesSelection(editRange, text, initialSelection) {
        this._range = editRange;
        this._text = text;
        this._initialSelection = initialSelection;
    }
    ReplaceCommandThatPreservesSelection.prototype.getEditOperations = function (model, builder) {
        builder.addEditOperation(this._range, this._text);
        this._selectionId = builder.trackSelection(this._initialSelection);
    };
    ReplaceCommandThatPreservesSelection.prototype.computeCursorState = function (model, helper) {
        return helper.getTrackedSelection(this._selectionId);
    };
    return ReplaceCommandThatPreservesSelection;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var CursorPosition = /** @class */ (function () {
    function CursorPosition(lineNumber, column, leftoverVisibleColumns) {
        this.lineNumber = lineNumber;
        this.column = column;
        this.leftoverVisibleColumns = leftoverVisibleColumns;
    }
    return CursorPosition;
}());
var MoveOperations = /** @class */ (function () {
    function MoveOperations() {
    }
    MoveOperations.left = function (config, model, lineNumber, column) {
        if (column > model.getLineMinColumn(lineNumber)) {
            if (CursorColumns.isLowSurrogate(model, lineNumber, column - 2)) {
                // character before column is a low surrogate
                column = column - 2;
            }
            else {
                column = column - 1;
            }
        }
        else if (lineNumber > 1) {
            lineNumber = lineNumber - 1;
            column = model.getLineMaxColumn(lineNumber);
        }
        return new CursorPosition(lineNumber, column, 0);
    };
    MoveOperations.moveLeft = function (config, model, cursor, inSelectionMode, noOfColumns) {
        var lineNumber, column;
        if (cursor.hasSelection() && !inSelectionMode) {
            // If we are in selection mode, move left without selection cancels selection and puts cursor at the beginning of the selection
            lineNumber = cursor.selection.startLineNumber;
            column = cursor.selection.startColumn;
        }
        else {
            var r = MoveOperations.left(config, model, cursor.position.lineNumber, cursor.position.column - (noOfColumns - 1));
            lineNumber = r.lineNumber;
            column = r.column;
        }
        return cursor.move(inSelectionMode, lineNumber, column, 0);
    };
    MoveOperations.right = function (config, model, lineNumber, column) {
        if (column < model.getLineMaxColumn(lineNumber)) {
            if (CursorColumns.isHighSurrogate(model, lineNumber, column - 1)) {
                // character after column is a high surrogate
                column = column + 2;
            }
            else {
                column = column + 1;
            }
        }
        else if (lineNumber < model.getLineCount()) {
            lineNumber = lineNumber + 1;
            column = model.getLineMinColumn(lineNumber);
        }
        return new CursorPosition(lineNumber, column, 0);
    };
    MoveOperations.moveRight = function (config, model, cursor, inSelectionMode, noOfColumns) {
        var lineNumber, column;
        if (cursor.hasSelection() && !inSelectionMode) {
            // If we are in selection mode, move right without selection cancels selection and puts cursor at the end of the selection
            lineNumber = cursor.selection.endLineNumber;
            column = cursor.selection.endColumn;
        }
        else {
            var r = MoveOperations.right(config, model, cursor.position.lineNumber, cursor.position.column + (noOfColumns - 1));
            lineNumber = r.lineNumber;
            column = r.column;
        }
        return cursor.move(inSelectionMode, lineNumber, column, 0);
    };
    MoveOperations.down = function (config, model, lineNumber, column, leftoverVisibleColumns, count, allowMoveOnLastLine) {
        var currentVisibleColumn = CursorColumns.visibleColumnFromColumn(model.getLineContent(lineNumber), column, config.tabSize) + leftoverVisibleColumns;
        lineNumber = lineNumber + count;
        var lineCount = model.getLineCount();
        if (lineNumber > lineCount) {
            lineNumber = lineCount;
            if (allowMoveOnLastLine) {
                column = model.getLineMaxColumn(lineNumber);
            }
            else {
                column = Math.min(model.getLineMaxColumn(lineNumber), column);
                if (CursorColumns.isInsideSurrogatePair(model, lineNumber, column)) {
                    column = column - 1;
                }
            }
        }
        else {
            column = CursorColumns.columnFromVisibleColumn2(config, model, lineNumber, currentVisibleColumn);
            if (CursorColumns.isInsideSurrogatePair(model, lineNumber, column)) {
                column = column - 1;
            }
        }
        leftoverVisibleColumns = currentVisibleColumn - CursorColumns.visibleColumnFromColumn(model.getLineContent(lineNumber), column, config.tabSize);
        return new CursorPosition(lineNumber, column, leftoverVisibleColumns);
    };
    MoveOperations.moveDown = function (config, model, cursor, inSelectionMode, linesCount) {
        var lineNumber, column;
        if (cursor.hasSelection() && !inSelectionMode) {
            // If we are in selection mode, move down acts relative to the end of selection
            lineNumber = cursor.selection.endLineNumber;
            column = cursor.selection.endColumn;
        }
        else {
            lineNumber = cursor.position.lineNumber;
            column = cursor.position.column;
        }
        var r = MoveOperations.down(config, model, lineNumber, column, cursor.leftoverVisibleColumns, linesCount, true);
        return cursor.move(inSelectionMode, r.lineNumber, r.column, r.leftoverVisibleColumns);
    };
    MoveOperations.translateDown = function (config, model, cursor) {
        var selection = cursor.selection;
        var selectionStart = MoveOperations.down(config, model, selection.selectionStartLineNumber, selection.selectionStartColumn, cursor.selectionStartLeftoverVisibleColumns, 1, false);
        var position = MoveOperations.down(config, model, selection.positionLineNumber, selection.positionColumn, cursor.leftoverVisibleColumns, 1, false);
        return new SingleCursorState(new Range(selectionStart.lineNumber, selectionStart.column, selectionStart.lineNumber, selectionStart.column), selectionStart.leftoverVisibleColumns, new Position(position.lineNumber, position.column), position.leftoverVisibleColumns);
    };
    MoveOperations.up = function (config, model, lineNumber, column, leftoverVisibleColumns, count, allowMoveOnFirstLine) {
        var currentVisibleColumn = CursorColumns.visibleColumnFromColumn(model.getLineContent(lineNumber), column, config.tabSize) + leftoverVisibleColumns;
        lineNumber = lineNumber - count;
        if (lineNumber < 1) {
            lineNumber = 1;
            if (allowMoveOnFirstLine) {
                column = model.getLineMinColumn(lineNumber);
            }
            else {
                column = Math.min(model.getLineMaxColumn(lineNumber), column);
                if (CursorColumns.isInsideSurrogatePair(model, lineNumber, column)) {
                    column = column - 1;
                }
            }
        }
        else {
            column = CursorColumns.columnFromVisibleColumn2(config, model, lineNumber, currentVisibleColumn);
            if (CursorColumns.isInsideSurrogatePair(model, lineNumber, column)) {
                column = column - 1;
            }
        }
        leftoverVisibleColumns = currentVisibleColumn - CursorColumns.visibleColumnFromColumn(model.getLineContent(lineNumber), column, config.tabSize);
        return new CursorPosition(lineNumber, column, leftoverVisibleColumns);
    };
    MoveOperations.moveUp = function (config, model, cursor, inSelectionMode, linesCount) {
        var lineNumber, column;
        if (cursor.hasSelection() && !inSelectionMode) {
            // If we are in selection mode, move up acts relative to the beginning of selection
            lineNumber = cursor.selection.startLineNumber;
            column = cursor.selection.startColumn;
        }
        else {
            lineNumber = cursor.position.lineNumber;
            column = cursor.position.column;
        }
        var r = MoveOperations.up(config, model, lineNumber, column, cursor.leftoverVisibleColumns, linesCount, true);
        return cursor.move(inSelectionMode, r.lineNumber, r.column, r.leftoverVisibleColumns);
    };
    MoveOperations.translateUp = function (config, model, cursor) {
        var selection = cursor.selection;
        var selectionStart = MoveOperations.up(config, model, selection.selectionStartLineNumber, selection.selectionStartColumn, cursor.selectionStartLeftoverVisibleColumns, 1, false);
        var position = MoveOperations.up(config, model, selection.positionLineNumber, selection.positionColumn, cursor.leftoverVisibleColumns, 1, false);
        return new SingleCursorState(new Range(selectionStart.lineNumber, selectionStart.column, selectionStart.lineNumber, selectionStart.column), selectionStart.leftoverVisibleColumns, new Position(position.lineNumber, position.column), position.leftoverVisibleColumns);
    };
    MoveOperations.moveToBeginningOfLine = function (config, model, cursor, inSelectionMode) {
        var lineNumber = cursor.position.lineNumber;
        var minColumn = model.getLineMinColumn(lineNumber);
        var firstNonBlankColumn = model.getLineFirstNonWhitespaceColumn(lineNumber) || minColumn;
        var column;
        var relevantColumnNumber = cursor.position.column;
        if (relevantColumnNumber === firstNonBlankColumn) {
            column = minColumn;
        }
        else {
            column = firstNonBlankColumn;
        }
        return cursor.move(inSelectionMode, lineNumber, column, 0);
    };
    MoveOperations.moveToEndOfLine = function (config, model, cursor, inSelectionMode) {
        var lineNumber = cursor.position.lineNumber;
        var maxColumn = model.getLineMaxColumn(lineNumber);
        return cursor.move(inSelectionMode, lineNumber, maxColumn, 0);
    };
    MoveOperations.moveToBeginningOfBuffer = function (config, model, cursor, inSelectionMode) {
        return cursor.move(inSelectionMode, 1, 1, 0);
    };
    MoveOperations.moveToEndOfBuffer = function (config, model, cursor, inSelectionMode) {
        var lastLineNumber = model.getLineCount();
        var lastColumn = model.getLineMaxColumn(lastLineNumber);
        return cursor.move(inSelectionMode, lastLineNumber, lastColumn, 0);
    };
    return MoveOperations;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var DeleteOperations = /** @class */ (function () {
    function DeleteOperations() {
    }
    DeleteOperations.deleteRight = function (prevEditOperationType, config, model, selections) {
        var commands = [];
        var shouldPushStackElementBefore = (prevEditOperationType !== 3 /* DeletingRight */);
        for (var i = 0, len = selections.length; i < len; i++) {
            var selection = selections[i];
            var deleteSelection = selection;
            if (deleteSelection.isEmpty()) {
                var position = selection.getPosition();
                var rightOfPosition = MoveOperations.right(config, model, position.lineNumber, position.column);
                deleteSelection = new Range(rightOfPosition.lineNumber, rightOfPosition.column, position.lineNumber, position.column);
            }
            if (deleteSelection.isEmpty()) {
                // Probably at end of file => ignore
                commands[i] = null;
                continue;
            }
            if (deleteSelection.startLineNumber !== deleteSelection.endLineNumber) {
                shouldPushStackElementBefore = true;
            }
            commands[i] = new ReplaceCommand(deleteSelection, '');
        }
        return [shouldPushStackElementBefore, commands];
    };
    DeleteOperations._isAutoClosingPairDelete = function (config, model, selections) {
        if (!config.autoClosingBrackets) {
            return false;
        }
        for (var i = 0, len = selections.length; i < len; i++) {
            var selection = selections[i];
            var position = selection.getPosition();
            if (!selection.isEmpty()) {
                return false;
            }
            var lineText = model.getLineContent(position.lineNumber);
            var character = lineText[position.column - 2];
            if (!config.autoClosingPairsOpen.hasOwnProperty(character)) {
                return false;
            }
            var afterCharacter = lineText[position.column - 1];
            var closeCharacter = config.autoClosingPairsOpen[character];
            if (afterCharacter !== closeCharacter) {
                return false;
            }
        }
        return true;
    };
    DeleteOperations._runAutoClosingPairDelete = function (config, model, selections) {
        var commands = [];
        for (var i = 0, len = selections.length; i < len; i++) {
            var position = selections[i].getPosition();
            var deleteSelection = new Range(position.lineNumber, position.column - 1, position.lineNumber, position.column + 1);
            commands[i] = new ReplaceCommand(deleteSelection, '');
        }
        return [true, commands];
    };
    DeleteOperations.deleteLeft = function (prevEditOperationType, config, model, selections) {
        if (this._isAutoClosingPairDelete(config, model, selections)) {
            return this._runAutoClosingPairDelete(config, model, selections);
        }
        var commands = [];
        var shouldPushStackElementBefore = (prevEditOperationType !== 2 /* DeletingLeft */);
        for (var i = 0, len = selections.length; i < len; i++) {
            var selection = selections[i];
            var deleteSelection = selection;
            if (deleteSelection.isEmpty()) {
                var position = selection.getPosition();
                if (config.useTabStops && position.column > 1) {
                    var lineContent = model.getLineContent(position.lineNumber);
                    var firstNonWhitespaceIndex$$1 = firstNonWhitespaceIndex(lineContent);
                    var lastIndentationColumn = (firstNonWhitespaceIndex$$1 === -1
                        ? /* entire string is whitespace */ lineContent.length + 1
                        : firstNonWhitespaceIndex$$1 + 1);
                    if (position.column <= lastIndentationColumn) {
                        var fromVisibleColumn = CursorColumns.visibleColumnFromColumn2(config, model, position);
                        var toVisibleColumn = CursorColumns.prevTabStop(fromVisibleColumn, config.tabSize);
                        var toColumn = CursorColumns.columnFromVisibleColumn2(config, model, position.lineNumber, toVisibleColumn);
                        deleteSelection = new Range(position.lineNumber, toColumn, position.lineNumber, position.column);
                    }
                    else {
                        deleteSelection = new Range(position.lineNumber, position.column - 1, position.lineNumber, position.column);
                    }
                }
                else {
                    var leftOfPosition = MoveOperations.left(config, model, position.lineNumber, position.column);
                    deleteSelection = new Range(leftOfPosition.lineNumber, leftOfPosition.column, position.lineNumber, position.column);
                }
            }
            if (deleteSelection.isEmpty()) {
                // Probably at beginning of file => ignore
                commands[i] = null;
                continue;
            }
            if (deleteSelection.startLineNumber !== deleteSelection.endLineNumber) {
                shouldPushStackElementBefore = true;
            }
            commands[i] = new ReplaceCommand(deleteSelection, '');
        }
        return [shouldPushStackElementBefore, commands];
    };
    DeleteOperations.cut = function (config, model, selections) {
        var commands = [];
        for (var i = 0, len = selections.length; i < len; i++) {
            var selection = selections[i];
            if (selection.isEmpty()) {
                if (config.emptySelectionClipboard) {
                    // This is a full line cut
                    var position = selection.getPosition();
                    var startLineNumber = void 0, startColumn = void 0, endLineNumber = void 0, endColumn = void 0;
                    if (position.lineNumber < model.getLineCount()) {
                        // Cutting a line in the middle of the model
                        startLineNumber = position.lineNumber;
                        startColumn = 1;
                        endLineNumber = position.lineNumber + 1;
                        endColumn = 1;
                    }
                    else if (position.lineNumber > 1) {
                        // Cutting the last line & there are more than 1 lines in the model
                        startLineNumber = position.lineNumber - 1;
                        startColumn = model.getLineMaxColumn(position.lineNumber - 1);
                        endLineNumber = position.lineNumber;
                        endColumn = model.getLineMaxColumn(position.lineNumber);
                    }
                    else {
                        // Cutting the single line that the model contains
                        startLineNumber = position.lineNumber;
                        startColumn = 1;
                        endLineNumber = position.lineNumber;
                        endColumn = model.getLineMaxColumn(position.lineNumber);
                    }
                    var deleteSelection = new Range(startLineNumber, startColumn, endLineNumber, endColumn);
                    if (!deleteSelection.isEmpty()) {
                        commands[i] = new ReplaceCommand(deleteSelection, '');
                    }
                    else {
                        commands[i] = null;
                    }
                }
                else {
                    // Cannot cut empty selection
                    commands[i] = null;
                }
            }
            else {
                commands[i] = new ReplaceCommand(selection, '');
            }
        }
        return new EditOperationResult(0 /* Other */, commands, {
            shouldPushStackElementBefore: true,
            shouldPushStackElementAfter: true
        });
    };
    return DeleteOperations;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var ShiftCommand = /** @class */ (function () {
    function ShiftCommand(range, opts) {
        this._opts = opts;
        this._selection = range;
        this._useLastEditRangeForCursorEndPosition = false;
        this._selectionStartColumnStaysPut = false;
    }
    ShiftCommand.unshiftIndentCount = function (line, column, tabSize) {
        // Determine the visible column where the content starts
        var contentStartVisibleColumn = CursorColumns.visibleColumnFromColumn(line, column, tabSize);
        var desiredTabStop = CursorColumns.prevTabStop(contentStartVisibleColumn, tabSize);
        // The `desiredTabStop` is a multiple of `tabSize` => determine the number of indents
        return desiredTabStop / tabSize;
    };
    ShiftCommand.shiftIndentCount = function (line, column, tabSize) {
        // Determine the visible column where the content starts
        var contentStartVisibleColumn = CursorColumns.visibleColumnFromColumn(line, column, tabSize);
        var desiredTabStop = CursorColumns.nextTabStop(contentStartVisibleColumn, tabSize);
        // The `desiredTabStop` is a multiple of `tabSize` => determine the number of indents
        return desiredTabStop / tabSize;
    };
    ShiftCommand.prototype._addEditOperation = function (builder, range, text) {
        if (this._useLastEditRangeForCursorEndPosition) {
            builder.addTrackedEditOperation(range, text);
        }
        else {
            builder.addEditOperation(range, text);
        }
    };
    ShiftCommand.prototype.getEditOperations = function (model, builder) {
        var startLine = this._selection.startLineNumber;
        var endLine = this._selection.endLineNumber;
        if (this._selection.endColumn === 1 && startLine !== endLine) {
            endLine = endLine - 1;
        }
        var tabSize = this._opts.tabSize;
        var oneIndent = this._opts.oneIndent;
        var shouldIndentEmptyLines = (startLine === endLine);
        // if indenting or outdenting on a whitespace only line
        if (this._selection.isEmpty()) {
            if (/^\s*$/.test(model.getLineContent(startLine))) {
                this._useLastEditRangeForCursorEndPosition = true;
            }
        }
        if (this._opts.useTabStops) {
            // indents[i] represents i * oneIndent
            var indents = ['', oneIndent];
            // keep track of previous line's "miss-alignment"
            var previousLineExtraSpaces = 0, extraSpaces = 0;
            for (var lineNumber = startLine; lineNumber <= endLine; lineNumber++, previousLineExtraSpaces = extraSpaces) {
                extraSpaces = 0;
                var lineText = model.getLineContent(lineNumber);
                var indentationEndIndex = firstNonWhitespaceIndex(lineText);
                if (this._opts.isUnshift && (lineText.length === 0 || indentationEndIndex === 0)) {
                    // empty line or line with no leading whitespace => nothing to do
                    continue;
                }
                if (!shouldIndentEmptyLines && !this._opts.isUnshift && lineText.length === 0) {
                    // do not indent empty lines => nothing to do
                    continue;
                }
                if (indentationEndIndex === -1) {
                    // the entire line is whitespace
                    indentationEndIndex = lineText.length;
                }
                if (lineNumber > 1) {
                    var contentStartVisibleColumn = CursorColumns.visibleColumnFromColumn(lineText, indentationEndIndex + 1, tabSize);
                    if (contentStartVisibleColumn % tabSize !== 0) {
                        // The current line is "miss-aligned", so let's see if this is expected...
                        // This can only happen when it has trailing commas in the indent
                        if (model.isCheapToTokenize(lineNumber - 1)) {
                            var enterAction = LanguageConfigurationRegistry.getRawEnterActionAtPosition(model, lineNumber - 1, model.getLineMaxColumn(lineNumber - 1));
                            if (enterAction) {
                                extraSpaces = previousLineExtraSpaces;
                                if (enterAction.appendText) {
                                    for (var j = 0, lenJ = enterAction.appendText.length; j < lenJ && extraSpaces < tabSize; j++) {
                                        if (enterAction.appendText.charCodeAt(j) === 32 /* Space */) {
                                            extraSpaces++;
                                        }
                                        else {
                                            break;
                                        }
                                    }
                                }
                                if (enterAction.removeText) {
                                    extraSpaces = Math.max(0, extraSpaces - enterAction.removeText);
                                }
                                // Act as if `prefixSpaces` is not part of the indentation
                                for (var j = 0; j < extraSpaces; j++) {
                                    if (indentationEndIndex === 0 || lineText.charCodeAt(indentationEndIndex - 1) !== 32 /* Space */) {
                                        break;
                                    }
                                    indentationEndIndex--;
                                }
                            }
                        }
                    }
                }
                if (this._opts.isUnshift && indentationEndIndex === 0) {
                    // line with no leading whitespace => nothing to do
                    continue;
                }
                var desiredIndentCount = void 0;
                if (this._opts.isUnshift) {
                    desiredIndentCount = ShiftCommand.unshiftIndentCount(lineText, indentationEndIndex + 1, tabSize);
                }
                else {
                    desiredIndentCount = ShiftCommand.shiftIndentCount(lineText, indentationEndIndex + 1, tabSize);
                }
                // Fill `indents`, as needed
                for (var j = indents.length; j <= desiredIndentCount; j++) {
                    indents[j] = indents[j - 1] + oneIndent;
                }
                this._addEditOperation(builder, new Range(lineNumber, 1, lineNumber, indentationEndIndex + 1), indents[desiredIndentCount]);
                if (lineNumber === startLine) {
                    // Force the startColumn to stay put because we're inserting after it
                    this._selectionStartColumnStaysPut = (this._selection.startColumn <= indentationEndIndex + 1);
                }
            }
        }
        else {
            for (var lineNumber = startLine; lineNumber <= endLine; lineNumber++) {
                var lineText = model.getLineContent(lineNumber);
                var indentationEndIndex = firstNonWhitespaceIndex(lineText);
                if (this._opts.isUnshift && (lineText.length === 0 || indentationEndIndex === 0)) {
                    // empty line or line with no leading whitespace => nothing to do
                    continue;
                }
                if (!shouldIndentEmptyLines && !this._opts.isUnshift && lineText.length === 0) {
                    // do not indent empty lines => nothing to do
                    continue;
                }
                if (indentationEndIndex === -1) {
                    // the entire line is whitespace
                    indentationEndIndex = lineText.length;
                }
                if (this._opts.isUnshift && indentationEndIndex === 0) {
                    // line with no leading whitespace => nothing to do
                    continue;
                }
                if (this._opts.isUnshift) {
                    indentationEndIndex = Math.min(indentationEndIndex, tabSize);
                    for (var i = 0; i < indentationEndIndex; i++) {
                        var chr = lineText.charCodeAt(i);
                        if (chr === 9 /* Tab */) {
                            indentationEndIndex = i + 1;
                            break;
                        }
                    }
                    this._addEditOperation(builder, new Range(lineNumber, 1, lineNumber, indentationEndIndex + 1), '');
                }
                else {
                    this._addEditOperation(builder, new Range(lineNumber, 1, lineNumber, 1), oneIndent);
                    if (lineNumber === startLine) {
                        // Force the startColumn to stay put because we're inserting after it
                        this._selectionStartColumnStaysPut = (this._selection.startColumn === 1);
                    }
                }
            }
        }
        this._selectionId = builder.trackSelection(this._selection);
    };
    ShiftCommand.prototype.computeCursorState = function (model, helper) {
        if (this._useLastEditRangeForCursorEndPosition) {
            var lastOp = helper.getInverseEditOperations()[0];
            return new Selection(lastOp.range.endLineNumber, lastOp.range.endColumn, lastOp.range.endLineNumber, lastOp.range.endColumn);
        }
        var result = helper.getTrackedSelection(this._selectionId);
        if (this._selectionStartColumnStaysPut) {
            // The selection start should not move
            var initialStartColumn = this._selection.startColumn;
            var resultStartColumn = result.startColumn;
            if (resultStartColumn <= initialStartColumn) {
                return result;
            }
            if (result.getDirection() === SelectionDirection.LTR) {
                return new Selection(result.startLineNumber, initialStartColumn, result.endLineNumber, result.endColumn);
            }
            return new Selection(result.endLineNumber, result.endColumn, result.startLineNumber, initialStartColumn);
        }
        return result;
    };
    return ShiftCommand;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var SurroundSelectionCommand = /** @class */ (function () {
    function SurroundSelectionCommand(range, charBeforeSelection, charAfterSelection) {
        this._range = range;
        this._charBeforeSelection = charBeforeSelection;
        this._charAfterSelection = charAfterSelection;
    }
    SurroundSelectionCommand.prototype.getEditOperations = function (model, builder) {
        builder.addTrackedEditOperation(new Range(this._range.startLineNumber, this._range.startColumn, this._range.startLineNumber, this._range.startColumn), this._charBeforeSelection);
        builder.addTrackedEditOperation(new Range(this._range.endLineNumber, this._range.endColumn, this._range.endLineNumber, this._range.endColumn), this._charAfterSelection);
    };
    SurroundSelectionCommand.prototype.computeCursorState = function (model, helper) {
        var inverseEditOperations = helper.getInverseEditOperations();
        var firstOperationRange = inverseEditOperations[0].range;
        var secondOperationRange = inverseEditOperations[1].range;
        return new Selection(firstOperationRange.endLineNumber, firstOperationRange.endColumn, secondOperationRange.endLineNumber, secondOperationRange.endColumn - this._charAfterSelection.length);
    };
    return SurroundSelectionCommand;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var TypeOperations = /** @class */ (function () {
    function TypeOperations() {
    }
    TypeOperations.indent = function (config, model, selections) {
        var commands = [];
        for (var i = 0, len = selections.length; i < len; i++) {
            commands[i] = new ShiftCommand(selections[i], {
                isUnshift: false,
                tabSize: config.tabSize,
                oneIndent: config.oneIndent,
                useTabStops: config.useTabStops
            });
        }
        return commands;
    };
    TypeOperations.outdent = function (config, model, selections) {
        var commands = [];
        for (var i = 0, len = selections.length; i < len; i++) {
            commands[i] = new ShiftCommand(selections[i], {
                isUnshift: true,
                tabSize: config.tabSize,
                oneIndent: config.oneIndent,
                useTabStops: config.useTabStops
            });
        }
        return commands;
    };
    TypeOperations.shiftIndent = function (config, indentation, count) {
        count = count || 1;
        var desiredIndentCount = ShiftCommand.shiftIndentCount(indentation, indentation.length + count, config.tabSize);
        var newIndentation = '';
        for (var i = 0; i < desiredIndentCount; i++) {
            newIndentation += '\t';
        }
        return newIndentation;
    };
    TypeOperations.unshiftIndent = function (config, indentation, count) {
        count = count || 1;
        var desiredIndentCount = ShiftCommand.unshiftIndentCount(indentation, indentation.length + count, config.tabSize);
        var newIndentation = '';
        for (var i = 0; i < desiredIndentCount; i++) {
            newIndentation += '\t';
        }
        return newIndentation;
    };
    TypeOperations._distributedPaste = function (config, model, selections, text) {
        var commands = [];
        for (var i = 0, len = selections.length; i < len; i++) {
            commands[i] = new ReplaceCommand(selections[i], text[i]);
        }
        return new EditOperationResult(0 /* Other */, commands, {
            shouldPushStackElementBefore: true,
            shouldPushStackElementAfter: true
        });
    };
    TypeOperations._simplePaste = function (config, model, selections, text, pasteOnNewLine) {
        var commands = [];
        for (var i = 0, len = selections.length; i < len; i++) {
            var selection = selections[i];
            var position = selection.getPosition();
            if (pasteOnNewLine && text.indexOf('\n') !== text.length - 1) {
                pasteOnNewLine = false;
            }
            if (pasteOnNewLine && selection.startLineNumber !== selection.endLineNumber) {
                pasteOnNewLine = false;
            }
            if (pasteOnNewLine && selection.startColumn === model.getLineMinColumn(selection.startLineNumber) && selection.endColumn === model.getLineMaxColumn(selection.startLineNumber)) {
                pasteOnNewLine = false;
            }
            if (pasteOnNewLine) {
                // Paste entire line at the beginning of line
                var typeSelection = new Range(position.lineNumber, 1, position.lineNumber, 1);
                commands[i] = new ReplaceCommand(typeSelection, text);
            }
            else {
                commands[i] = new ReplaceCommand(selection, text);
            }
        }
        return new EditOperationResult(0 /* Other */, commands, {
            shouldPushStackElementBefore: true,
            shouldPushStackElementAfter: true
        });
    };
    TypeOperations._distributePasteToCursors = function (selections, text, pasteOnNewLine, multicursorText) {
        if (pasteOnNewLine) {
            return null;
        }
        if (selections.length === 1) {
            return null;
        }
        if (multicursorText && multicursorText.length === selections.length) {
            return multicursorText;
        }
        // Remove trailing \n if present
        if (text.charCodeAt(text.length - 1) === 10 /* LineFeed */) {
            text = text.substr(0, text.length - 1);
        }
        var lines = text.split(/\r\n|\r|\n/);
        if (lines.length === selections.length) {
            return lines;
        }
        return null;
    };
    TypeOperations.paste = function (config, model, selections, text, pasteOnNewLine, multicursorText) {
        var distributedPaste = this._distributePasteToCursors(selections, text, pasteOnNewLine, multicursorText);
        if (distributedPaste) {
            selections = selections.sort(Range.compareRangesUsingStarts);
            return this._distributedPaste(config, model, selections, distributedPaste);
        }
        else {
            return this._simplePaste(config, model, selections, text, pasteOnNewLine);
        }
    };
    TypeOperations._goodIndentForLine = function (config, model, lineNumber) {
        var action;
        var indentation;
        var expectedIndentAction = config.autoIndent ? LanguageConfigurationRegistry.getInheritIndentForLine(model, lineNumber, false) : null;
        if (expectedIndentAction) {
            action = expectedIndentAction.action;
            indentation = expectedIndentAction.indentation;
        }
        else if (lineNumber > 1) {
            var lastLineNumber = lineNumber - 1;
            for (lastLineNumber = lineNumber - 1; lastLineNumber >= 1; lastLineNumber--) {
                var lineText = model.getLineContent(lastLineNumber);
                var nonWhitespaceIdx = lastNonWhitespaceIndex(lineText);
                if (nonWhitespaceIdx >= 0) {
                    break;
                }
            }
            if (lastLineNumber < 1) {
                // No previous line with content found
                return null;
            }
            var maxColumn = model.getLineMaxColumn(lastLineNumber);
            var expectedEnterAction = LanguageConfigurationRegistry.getEnterAction(model, new Range(lastLineNumber, maxColumn, lastLineNumber, maxColumn));
            if (expectedEnterAction) {
                indentation = expectedEnterAction.indentation;
                action = expectedEnterAction.enterAction;
                if (action) {
                    indentation += action.appendText;
                }
            }
        }
        if (action) {
            if (action === IndentAction.Indent) {
                indentation = TypeOperations.shiftIndent(config, indentation);
            }
            if (action === IndentAction.Outdent) {
                indentation = TypeOperations.unshiftIndent(config, indentation);
            }
            indentation = config.normalizeIndentation(indentation);
        }
        if (!indentation) {
            return null;
        }
        return indentation;
    };
    TypeOperations._replaceJumpToNextIndent = function (config, model, selection, insertsAutoWhitespace) {
        var typeText = '';
        var position = selection.getStartPosition();
        if (config.insertSpaces) {
            var visibleColumnFromColumn = CursorColumns.visibleColumnFromColumn2(config, model, position);
            var tabSize = config.tabSize;
            var spacesCnt = tabSize - (visibleColumnFromColumn % tabSize);
            for (var i = 0; i < spacesCnt; i++) {
                typeText += ' ';
            }
        }
        else {
            typeText = '\t';
        }
        return new ReplaceCommand(selection, typeText, insertsAutoWhitespace);
    };
    TypeOperations.tab = function (config, model, selections) {
        var commands = [];
        for (var i = 0, len = selections.length; i < len; i++) {
            var selection = selections[i];
            if (selection.isEmpty()) {
                var lineText = model.getLineContent(selection.startLineNumber);
                if (/^\s*$/.test(lineText) && model.isCheapToTokenize(selection.startLineNumber)) {
                    var goodIndent = this._goodIndentForLine(config, model, selection.startLineNumber);
                    goodIndent = goodIndent || '\t';
                    var possibleTypeText = config.normalizeIndentation(goodIndent);
                    if (!startsWith(lineText, possibleTypeText)) {
                        commands[i] = new ReplaceCommand(new Range(selection.startLineNumber, 1, selection.startLineNumber, lineText.length + 1), possibleTypeText, true);
                        continue;
                    }
                }
                commands[i] = this._replaceJumpToNextIndent(config, model, selection, true);
            }
            else {
                if (selection.startLineNumber === selection.endLineNumber) {
                    var lineMaxColumn = model.getLineMaxColumn(selection.startLineNumber);
                    if (selection.startColumn !== 1 || selection.endColumn !== lineMaxColumn) {
                        // This is a single line selection that is not the entire line
                        commands[i] = this._replaceJumpToNextIndent(config, model, selection, false);
                        continue;
                    }
                }
                commands[i] = new ShiftCommand(selection, {
                    isUnshift: false,
                    tabSize: config.tabSize,
                    oneIndent: config.oneIndent,
                    useTabStops: config.useTabStops
                });
            }
        }
        return commands;
    };
    TypeOperations.replacePreviousChar = function (prevEditOperationType, config, model, selections, txt, replaceCharCnt) {
        var commands = [];
        for (var i = 0, len = selections.length; i < len; i++) {
            var selection = selections[i];
            if (!selection.isEmpty()) {
                // looks like https://github.com/Microsoft/vscode/issues/2773
                // where a cursor operation occurred before a canceled composition
                // => ignore composition
                commands[i] = null;
                continue;
            }
            var pos = selection.getPosition();
            var startColumn = Math.max(1, pos.column - replaceCharCnt);
            var range = new Range(pos.lineNumber, startColumn, pos.lineNumber, pos.column);
            commands[i] = new ReplaceCommand(range, txt);
        }
        return new EditOperationResult(1 /* Typing */, commands, {
            shouldPushStackElementBefore: (prevEditOperationType !== 1 /* Typing */),
            shouldPushStackElementAfter: false
        });
    };
    TypeOperations._typeCommand = function (range, text, keepPosition) {
        if (keepPosition) {
            return new ReplaceCommandWithoutChangingPosition(range, text, true);
        }
        else {
            return new ReplaceCommand(range, text, true);
        }
    };
    TypeOperations._enter = function (config, model, keepPosition, range) {
        if (!model.isCheapToTokenize(range.getStartPosition().lineNumber)) {
            var lineText_1 = model.getLineContent(range.startLineNumber);
            var indentation_1 = getLeadingWhitespace(lineText_1).substring(0, range.startColumn - 1);
            return TypeOperations._typeCommand(range, '\n' + config.normalizeIndentation(indentation_1), keepPosition);
        }
        var r = LanguageConfigurationRegistry.getEnterAction(model, range);
        if (r) {
            var enterAction = r.enterAction;
            var indentation_2 = r.indentation;
            if (enterAction.indentAction === IndentAction.None) {
                // Nothing special
                return TypeOperations._typeCommand(range, '\n' + config.normalizeIndentation(indentation_2 + enterAction.appendText), keepPosition);
            }
            else if (enterAction.indentAction === IndentAction.Indent) {
                // Indent once
                return TypeOperations._typeCommand(range, '\n' + config.normalizeIndentation(indentation_2 + enterAction.appendText), keepPosition);
            }
            else if (enterAction.indentAction === IndentAction.IndentOutdent) {
                // Ultra special
                var normalIndent = config.normalizeIndentation(indentation_2);
                var increasedIndent = config.normalizeIndentation(indentation_2 + enterAction.appendText);
                var typeText = '\n' + increasedIndent + '\n' + normalIndent;
                if (keepPosition) {
                    return new ReplaceCommandWithoutChangingPosition(range, typeText, true);
                }
                else {
                    return new ReplaceCommandWithOffsetCursorState(range, typeText, -1, increasedIndent.length - normalIndent.length, true);
                }
            }
            else if (enterAction.indentAction === IndentAction.Outdent) {
                var actualIndentation = TypeOperations.unshiftIndent(config, indentation_2);
                return TypeOperations._typeCommand(range, '\n' + config.normalizeIndentation(actualIndentation + enterAction.appendText), keepPosition);
            }
        }
        // no enter rules applied, we should check indentation rules then.
        if (!config.autoIndent) {
            // Nothing special
            var lineText_2 = model.getLineContent(range.startLineNumber);
            var indentation_3 = getLeadingWhitespace(lineText_2).substring(0, range.startColumn - 1);
            return TypeOperations._typeCommand(range, '\n' + config.normalizeIndentation(indentation_3), keepPosition);
        }
        var ir = LanguageConfigurationRegistry.getIndentForEnter(model, range, {
            unshiftIndent: function (indent) {
                return TypeOperations.unshiftIndent(config, indent);
            },
            shiftIndent: function (indent) {
                return TypeOperations.shiftIndent(config, indent);
            },
            normalizeIndentation: function (indent) {
                return config.normalizeIndentation(indent);
            }
        }, config.autoIndent);
        var lineText = model.getLineContent(range.startLineNumber);
        var indentation = getLeadingWhitespace(lineText).substring(0, range.startColumn - 1);
        if (ir) {
            var oldEndViewColumn = CursorColumns.visibleColumnFromColumn2(config, model, range.getEndPosition());
            var oldEndColumn = range.endColumn;
            var beforeText = '\n';
            if (indentation !== config.normalizeIndentation(ir.beforeEnter)) {
                beforeText = config.normalizeIndentation(ir.beforeEnter) + lineText.substring(indentation.length, range.startColumn - 1) + '\n';
                range = new Range(range.startLineNumber, 1, range.endLineNumber, range.endColumn);
            }
            var newLineContent = model.getLineContent(range.endLineNumber);
            var firstNonWhitespace = firstNonWhitespaceIndex(newLineContent);
            if (firstNonWhitespace >= 0) {
                range = range.setEndPosition(range.endLineNumber, Math.max(range.endColumn, firstNonWhitespace + 1));
            }
            else {
                range = range.setEndPosition(range.endLineNumber, model.getLineMaxColumn(range.endLineNumber));
            }
            if (keepPosition) {
                return new ReplaceCommandWithoutChangingPosition(range, beforeText + config.normalizeIndentation(ir.afterEnter), true);
            }
            else {
                var offset = 0;
                if (oldEndColumn <= firstNonWhitespace + 1) {
                    if (!config.insertSpaces) {
                        oldEndViewColumn = Math.ceil(oldEndViewColumn / config.tabSize);
                    }
                    offset = Math.min(oldEndViewColumn + 1 - config.normalizeIndentation(ir.afterEnter).length - 1, 0);
                }
                return new ReplaceCommandWithOffsetCursorState(range, beforeText + config.normalizeIndentation(ir.afterEnter), 0, offset, true);
            }
        }
        else {
            return TypeOperations._typeCommand(range, '\n' + config.normalizeIndentation(indentation), keepPosition);
        }
    };
    TypeOperations._isAutoIndentType = function (config, model, selections) {
        if (!config.autoIndent) {
            return false;
        }
        for (var i = 0, len = selections.length; i < len; i++) {
            if (!model.isCheapToTokenize(selections[i].getEndPosition().lineNumber)) {
                return false;
            }
        }
        return true;
    };
    TypeOperations._runAutoIndentType = function (config, model, range, ch) {
        var currentIndentation = LanguageConfigurationRegistry.getIndentationAtPosition(model, range.startLineNumber, range.startColumn);
        var actualIndentation = LanguageConfigurationRegistry.getIndentActionForType(model, range, ch, {
            shiftIndent: function (indentation) {
                return TypeOperations.shiftIndent(config, indentation);
            },
            unshiftIndent: function (indentation) {
                return TypeOperations.unshiftIndent(config, indentation);
            },
        });
        if (actualIndentation === null) {
            return null;
        }
        if (actualIndentation !== config.normalizeIndentation(currentIndentation)) {
            var firstNonWhitespace = model.getLineFirstNonWhitespaceColumn(range.startLineNumber);
            if (firstNonWhitespace === 0) {
                return TypeOperations._typeCommand(new Range(range.startLineNumber, 0, range.endLineNumber, range.endColumn), config.normalizeIndentation(actualIndentation) + ch, false);
            }
            else {
                return TypeOperations._typeCommand(new Range(range.startLineNumber, 0, range.endLineNumber, range.endColumn), config.normalizeIndentation(actualIndentation) +
                    model.getLineContent(range.startLineNumber).substring(firstNonWhitespace - 1, range.startColumn - 1) + ch, false);
            }
        }
        return null;
    };
    TypeOperations._isAutoClosingCloseCharType = function (config, model, selections, ch) {
        if (!config.autoClosingBrackets || !config.autoClosingPairsClose.hasOwnProperty(ch)) {
            return false;
        }
        var isEqualPair = (ch === config.autoClosingPairsClose[ch]);
        for (var i = 0, len = selections.length; i < len; i++) {
            var selection = selections[i];
            if (!selection.isEmpty()) {
                return false;
            }
            var position = selection.getPosition();
            var lineText = model.getLineContent(position.lineNumber);
            var afterCharacter = lineText.charAt(position.column - 1);
            if (afterCharacter !== ch) {
                return false;
            }
            if (isEqualPair) {
                var lineTextBeforeCursor = lineText.substr(0, position.column - 1);
                var chCntBefore = this._countNeedlesInHaystack(lineTextBeforeCursor, ch);
                if (chCntBefore % 2 === 0) {
                    return false;
                }
            }
        }
        return true;
    };
    TypeOperations._countNeedlesInHaystack = function (haystack, needle) {
        var cnt = 0;
        var lastIndex = -1;
        while ((lastIndex = haystack.indexOf(needle, lastIndex + 1)) !== -1) {
            cnt++;
        }
        return cnt;
    };
    TypeOperations._runAutoClosingCloseCharType = function (prevEditOperationType, config, model, selections, ch) {
        var commands = [];
        for (var i = 0, len = selections.length; i < len; i++) {
            var selection = selections[i];
            var position = selection.getPosition();
            var typeSelection = new Range(position.lineNumber, position.column, position.lineNumber, position.column + 1);
            commands[i] = new ReplaceCommand(typeSelection, ch);
        }
        return new EditOperationResult(1 /* Typing */, commands, {
            shouldPushStackElementBefore: (prevEditOperationType !== 1 /* Typing */),
            shouldPushStackElementAfter: false
        });
    };
    TypeOperations._isAutoClosingOpenCharType = function (config, model, selections, ch) {
        if (!config.autoClosingBrackets || !config.autoClosingPairsOpen.hasOwnProperty(ch)) {
            return false;
        }
        for (var i = 0, len = selections.length; i < len; i++) {
            var selection = selections[i];
            if (!selection.isEmpty()) {
                return false;
            }
            var position = selection.getPosition();
            var lineText = model.getLineContent(position.lineNumber);
            // Do not auto-close ' or " after a word character
            if ((ch === '\'' || ch === '"') && position.column > 1) {
                var wordSeparators = getMapForWordSeparators(config.wordSeparators);
                var characterBeforeCode = lineText.charCodeAt(position.column - 2);
                var characterBeforeType = wordSeparators.get(characterBeforeCode);
                if (characterBeforeType === 0 /* Regular */) {
                    return false;
                }
            }
            // Only consider auto closing the pair if a space follows or if another autoclosed pair follows
            var characterAfter = lineText.charAt(position.column - 1);
            if (characterAfter) {
                var thisBraceIsSymmetric = (config.autoClosingPairsOpen[ch] === ch);
                var isBeforeCloseBrace = false;
                for (var otherCloseBrace in config.autoClosingPairsClose) {
                    var otherBraceIsSymmetric = (config.autoClosingPairsOpen[otherCloseBrace] === otherCloseBrace);
                    if (!thisBraceIsSymmetric && otherBraceIsSymmetric) {
                        continue;
                    }
                    if (characterAfter === otherCloseBrace) {
                        isBeforeCloseBrace = true;
                        break;
                    }
                }
                if (!isBeforeCloseBrace && !/\s/.test(characterAfter)) {
                    return false;
                }
            }
            if (!model.isCheapToTokenize(position.lineNumber)) {
                // Do not force tokenization
                return false;
            }
            model.forceTokenization(position.lineNumber);
            var lineTokens = model.getLineTokens(position.lineNumber);
            var shouldAutoClosePair = false;
            try {
                shouldAutoClosePair = LanguageConfigurationRegistry.shouldAutoClosePair(ch, lineTokens, position.column);
            }
            catch (e) {
                onUnexpectedError(e);
            }
            if (!shouldAutoClosePair) {
                return false;
            }
        }
        return true;
    };
    TypeOperations._runAutoClosingOpenCharType = function (prevEditOperationType, config, model, selections, ch) {
        var commands = [];
        for (var i = 0, len = selections.length; i < len; i++) {
            var selection = selections[i];
            var closeCharacter = config.autoClosingPairsOpen[ch];
            commands[i] = new ReplaceCommandWithOffsetCursorState(selection, ch + closeCharacter, 0, -closeCharacter.length);
        }
        return new EditOperationResult(1 /* Typing */, commands, {
            shouldPushStackElementBefore: true,
            shouldPushStackElementAfter: false
        });
    };
    TypeOperations._isSurroundSelectionType = function (config, model, selections, ch) {
        if (!config.autoClosingBrackets || !config.surroundingPairs.hasOwnProperty(ch)) {
            return false;
        }
        for (var i = 0, len = selections.length; i < len; i++) {
            var selection = selections[i];
            if (selection.isEmpty()) {
                return false;
            }
            var selectionContainsOnlyWhitespace = true;
            for (var lineNumber = selection.startLineNumber; lineNumber <= selection.endLineNumber; lineNumber++) {
                var lineText = model.getLineContent(lineNumber);
                var startIndex = (lineNumber === selection.startLineNumber ? selection.startColumn - 1 : 0);
                var endIndex = (lineNumber === selection.endLineNumber ? selection.endColumn - 1 : lineText.length);
                var selectedText = lineText.substring(startIndex, endIndex);
                if (/[^ \t]/.test(selectedText)) {
                    // this selected text contains something other than whitespace
                    selectionContainsOnlyWhitespace = false;
                    break;
                }
            }
            if (selectionContainsOnlyWhitespace) {
                return false;
            }
        }
        return true;
    };
    TypeOperations._runSurroundSelectionType = function (prevEditOperationType, config, model, selections, ch) {
        var commands = [];
        for (var i = 0, len = selections.length; i < len; i++) {
            var selection = selections[i];
            var closeCharacter = config.surroundingPairs[ch];
            commands[i] = new SurroundSelectionCommand(selection, ch, closeCharacter);
        }
        return new EditOperationResult(0 /* Other */, commands, {
            shouldPushStackElementBefore: true,
            shouldPushStackElementAfter: true
        });
    };
    TypeOperations._isTypeInterceptorElectricChar = function (config, model, selections) {
        if (selections.length === 1 && model.isCheapToTokenize(selections[0].getEndPosition().lineNumber)) {
            return true;
        }
        return false;
    };
    TypeOperations._typeInterceptorElectricChar = function (prevEditOperationType, config, model, selection, ch) {
        if (!config.electricChars.hasOwnProperty(ch) || !selection.isEmpty()) {
            return null;
        }
        var position = selection.getPosition();
        model.forceTokenization(position.lineNumber);
        var lineTokens = model.getLineTokens(position.lineNumber);
        var electricAction;
        try {
            electricAction = LanguageConfigurationRegistry.onElectricCharacter(ch, lineTokens, position.column);
        }
        catch (e) {
            onUnexpectedError(e);
        }
        if (!electricAction) {
            return null;
        }
        if (electricAction.appendText) {
            var command = new ReplaceCommandWithOffsetCursorState(selection, ch + electricAction.appendText, 0, -electricAction.appendText.length);
            return new EditOperationResult(1 /* Typing */, [command], {
                shouldPushStackElementBefore: false,
                shouldPushStackElementAfter: true
            });
        }
        if (electricAction.matchOpenBracket) {
            var endColumn = (lineTokens.getLineContent() + ch).lastIndexOf(electricAction.matchOpenBracket) + 1;
            var match = model.findMatchingBracketUp(electricAction.matchOpenBracket, {
                lineNumber: position.lineNumber,
                column: endColumn
            });
            if (match) {
                if (match.startLineNumber === position.lineNumber) {
                    // matched something on the same line => no change in indentation
                    return null;
                }
                var matchLine = model.getLineContent(match.startLineNumber);
                var matchLineIndentation = getLeadingWhitespace(matchLine);
                var newIndentation = config.normalizeIndentation(matchLineIndentation);
                var lineText = model.getLineContent(position.lineNumber);
                var lineFirstNonBlankColumn = model.getLineFirstNonWhitespaceColumn(position.lineNumber) || position.column;
                var prefix = lineText.substring(lineFirstNonBlankColumn - 1, position.column - 1);
                var typeText = newIndentation + prefix + ch;
                var typeSelection = new Range(position.lineNumber, 1, position.lineNumber, position.column);
                var command = new ReplaceCommand(typeSelection, typeText);
                return new EditOperationResult(1 /* Typing */, [command], {
                    shouldPushStackElementBefore: false,
                    shouldPushStackElementAfter: true
                });
            }
        }
        return null;
    };
    TypeOperations.typeWithInterceptors = function (prevEditOperationType, config, model, selections, ch) {
        if (ch === '\n') {
            var commands_1 = [];
            for (var i = 0, len = selections.length; i < len; i++) {
                commands_1[i] = TypeOperations._enter(config, model, false, selections[i]);
            }
            return new EditOperationResult(1 /* Typing */, commands_1, {
                shouldPushStackElementBefore: true,
                shouldPushStackElementAfter: false,
            });
        }
        if (this._isAutoIndentType(config, model, selections)) {
            var commands_2 = [];
            var autoIndentFails = false;
            for (var i = 0, len = selections.length; i < len; i++) {
                commands_2[i] = this._runAutoIndentType(config, model, selections[i], ch);
                if (!commands_2[i]) {
                    autoIndentFails = true;
                    break;
                }
            }
            if (!autoIndentFails) {
                return new EditOperationResult(1 /* Typing */, commands_2, {
                    shouldPushStackElementBefore: true,
                    shouldPushStackElementAfter: false,
                });
            }
        }
        if (this._isAutoClosingCloseCharType(config, model, selections, ch)) {
            return this._runAutoClosingCloseCharType(prevEditOperationType, config, model, selections, ch);
        }
        if (this._isAutoClosingOpenCharType(config, model, selections, ch)) {
            return this._runAutoClosingOpenCharType(prevEditOperationType, config, model, selections, ch);
        }
        if (this._isSurroundSelectionType(config, model, selections, ch)) {
            return this._runSurroundSelectionType(prevEditOperationType, config, model, selections, ch);
        }
        // Electric characters make sense only when dealing with a single cursor,
        // as multiple cursors typing brackets for example would interfer with bracket matching
        if (this._isTypeInterceptorElectricChar(config, model, selections)) {
            var r = this._typeInterceptorElectricChar(prevEditOperationType, config, model, selections[0], ch);
            if (r) {
                return r;
            }
        }
        // A simple character type
        var commands = [];
        for (var i = 0, len = selections.length; i < len; i++) {
            commands[i] = new ReplaceCommand(selections[i], ch);
        }
        var shouldPushStackElementBefore = (prevEditOperationType !== 1 /* Typing */);
        if (ch === ' ') {
            shouldPushStackElementBefore = true;
        }
        return new EditOperationResult(1 /* Typing */, commands, {
            shouldPushStackElementBefore: shouldPushStackElementBefore,
            shouldPushStackElementAfter: false
        });
    };
    TypeOperations.typeWithoutInterceptors = function (prevEditOperationType, config, model, selections, str) {
        var commands = [];
        for (var i = 0, len = selections.length; i < len; i++) {
            commands[i] = new ReplaceCommand(selections[i], str);
        }
        return new EditOperationResult(1 /* Typing */, commands, {
            shouldPushStackElementBefore: (prevEditOperationType !== 1 /* Typing */),
            shouldPushStackElementAfter: false
        });
    };
    TypeOperations.lineInsertBefore = function (config, model, selections) {
        var commands = [];
        for (var i = 0, len = selections.length; i < len; i++) {
            var lineNumber = selections[i].positionLineNumber;
            if (lineNumber === 1) {
                commands[i] = new ReplaceCommandWithoutChangingPosition(new Range(1, 1, 1, 1), '\n');
            }
            else {
                lineNumber--;
                var column = model.getLineMaxColumn(lineNumber);
                commands[i] = this._enter(config, model, false, new Range(lineNumber, column, lineNumber, column));
            }
        }
        return commands;
    };
    TypeOperations.lineInsertAfter = function (config, model, selections) {
        var commands = [];
        for (var i = 0, len = selections.length; i < len; i++) {
            var lineNumber = selections[i].positionLineNumber;
            var column = model.getLineMaxColumn(lineNumber);
            commands[i] = this._enter(config, model, false, new Range(lineNumber, column, lineNumber, column));
        }
        return commands;
    };
    TypeOperations.lineBreakInsert = function (config, model, selections) {
        var commands = [];
        for (var i = 0, len = selections.length; i < len; i++) {
            commands[i] = this._enter(config, model, true, selections[i]);
        }
        return commands;
    };
    return TypeOperations;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
/**
 * Describes the reason the cursor has changed its position.
 */
var CursorChangeReason;
(function (CursorChangeReason) {
    /**
     * Unknown or not set.
     */
    CursorChangeReason[CursorChangeReason["NotSet"] = 0] = "NotSet";
    /**
     * A `model.setValue()` was called.
     */
    CursorChangeReason[CursorChangeReason["ContentFlush"] = 1] = "ContentFlush";
    /**
     * The `model` has been changed outside of this cursor and the cursor recovers its position from associated markers.
     */
    CursorChangeReason[CursorChangeReason["RecoverFromMarkers"] = 2] = "RecoverFromMarkers";
    /**
     * There was an explicit user gesture.
     */
    CursorChangeReason[CursorChangeReason["Explicit"] = 3] = "Explicit";
    /**
     * There was a Paste.
     */
    CursorChangeReason[CursorChangeReason["Paste"] = 4] = "Paste";
    /**
     * There was an Undo.
     */
    CursorChangeReason[CursorChangeReason["Undo"] = 5] = "Undo";
    /**
     * There was a Redo.
     */
    CursorChangeReason[CursorChangeReason["Redo"] = 6] = "Redo";
})(CursorChangeReason || (CursorChangeReason = {}));

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$b = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var ViewConfigurationChangedEvent = /** @class */ (function () {
    function ViewConfigurationChangedEvent(source) {
        this.type = 1 /* ViewConfigurationChanged */;
        this.canUseLayerHinting = source.canUseLayerHinting;
        this.pixelRatio = source.pixelRatio;
        this.editorClassName = source.editorClassName;
        this.lineHeight = source.lineHeight;
        this.readOnly = source.readOnly;
        this.accessibilitySupport = source.accessibilitySupport;
        this.emptySelectionClipboard = source.emptySelectionClipboard;
        this.layoutInfo = source.layoutInfo;
        this.fontInfo = source.fontInfo;
        this.viewInfo = source.viewInfo;
        this.wrappingInfo = source.wrappingInfo;
    }
    return ViewConfigurationChangedEvent;
}());
var ViewCursorStateChangedEvent = /** @class */ (function () {
    function ViewCursorStateChangedEvent(selections) {
        this.type = 2 /* ViewCursorStateChanged */;
        this.selections = selections;
    }
    return ViewCursorStateChangedEvent;
}());
var ViewDecorationsChangedEvent = /** @class */ (function () {
    function ViewDecorationsChangedEvent() {
        this.type = 3 /* ViewDecorationsChanged */;
        // Nothing to do
    }
    return ViewDecorationsChangedEvent;
}());
var ViewFlushedEvent = /** @class */ (function () {
    function ViewFlushedEvent() {
        this.type = 4 /* ViewFlushed */;
        // Nothing to do
    }
    return ViewFlushedEvent;
}());
var ViewFocusChangedEvent = /** @class */ (function () {
    function ViewFocusChangedEvent(isFocused) {
        this.type = 5 /* ViewFocusChanged */;
        this.isFocused = isFocused;
    }
    return ViewFocusChangedEvent;
}());
var ViewLineMappingChangedEvent = /** @class */ (function () {
    function ViewLineMappingChangedEvent() {
        this.type = 6 /* ViewLineMappingChanged */;
        // Nothing to do
    }
    return ViewLineMappingChangedEvent;
}());
var ViewLinesChangedEvent = /** @class */ (function () {
    function ViewLinesChangedEvent(fromLineNumber, toLineNumber) {
        this.type = 7 /* ViewLinesChanged */;
        this.fromLineNumber = fromLineNumber;
        this.toLineNumber = toLineNumber;
    }
    return ViewLinesChangedEvent;
}());
var ViewLinesDeletedEvent = /** @class */ (function () {
    function ViewLinesDeletedEvent(fromLineNumber, toLineNumber) {
        this.type = 8 /* ViewLinesDeleted */;
        this.fromLineNumber = fromLineNumber;
        this.toLineNumber = toLineNumber;
    }
    return ViewLinesDeletedEvent;
}());
var ViewLinesInsertedEvent = /** @class */ (function () {
    function ViewLinesInsertedEvent(fromLineNumber, toLineNumber) {
        this.type = 9 /* ViewLinesInserted */;
        this.fromLineNumber = fromLineNumber;
        this.toLineNumber = toLineNumber;
    }
    return ViewLinesInsertedEvent;
}());
var ViewRevealRangeRequestEvent = /** @class */ (function () {
    function ViewRevealRangeRequestEvent(range, verticalType, revealHorizontal, scrollType) {
        this.type = 10 /* ViewRevealRangeRequest */;
        this.range = range;
        this.verticalType = verticalType;
        this.revealHorizontal = revealHorizontal;
        this.scrollType = scrollType;
    }
    return ViewRevealRangeRequestEvent;
}());
var ViewScrollChangedEvent = /** @class */ (function () {
    function ViewScrollChangedEvent(source) {
        this.type = 11 /* ViewScrollChanged */;
        this.scrollWidth = source.scrollWidth;
        this.scrollLeft = source.scrollLeft;
        this.scrollHeight = source.scrollHeight;
        this.scrollTop = source.scrollTop;
        this.scrollWidthChanged = source.scrollWidthChanged;
        this.scrollLeftChanged = source.scrollLeftChanged;
        this.scrollHeightChanged = source.scrollHeightChanged;
        this.scrollTopChanged = source.scrollTopChanged;
    }
    return ViewScrollChangedEvent;
}());
var ViewTokensChangedEvent = /** @class */ (function () {
    function ViewTokensChangedEvent(ranges) {
        this.type = 12 /* ViewTokensChanged */;
        this.ranges = ranges;
    }
    return ViewTokensChangedEvent;
}());
var ViewThemeChangedEvent = /** @class */ (function () {
    function ViewThemeChangedEvent() {
        this.type = 15 /* ViewThemeChanged */;
    }
    return ViewThemeChangedEvent;
}());
var ViewTokensColorsChangedEvent = /** @class */ (function () {
    function ViewTokensColorsChangedEvent() {
        this.type = 13 /* ViewTokensColorsChanged */;
        // Nothing to do
    }
    return ViewTokensColorsChangedEvent;
}());
var ViewZonesChangedEvent = /** @class */ (function () {
    function ViewZonesChangedEvent() {
        this.type = 14 /* ViewZonesChanged */;
        // Nothing to do
    }
    return ViewZonesChangedEvent;
}());
var ViewLanguageConfigurationEvent = /** @class */ (function () {
    function ViewLanguageConfigurationEvent() {
        this.type = 16 /* ViewLanguageConfigurationChanged */;
    }
    return ViewLanguageConfigurationEvent;
}());
var ViewEventEmitter = /** @class */ (function (_super) {
    __extends$b(ViewEventEmitter, _super);
    function ViewEventEmitter() {
        var _this = _super.call(this) || this;
        _this._listeners = [];
        _this._collector = null;
        _this._collectorCnt = 0;
        return _this;
    }
    ViewEventEmitter.prototype.dispose = function () {
        this._listeners = [];
        _super.prototype.dispose.call(this);
    };
    ViewEventEmitter.prototype._beginEmit = function () {
        this._collectorCnt++;
        if (this._collectorCnt === 1) {
            this._collector = new ViewEventsCollector();
        }
        return this._collector;
    };
    ViewEventEmitter.prototype._endEmit = function () {
        this._collectorCnt--;
        if (this._collectorCnt === 0) {
            var events = this._collector.finalize();
            this._collector = null;
            if (events.length > 0) {
                this._emit(events);
            }
        }
    };
    ViewEventEmitter.prototype._emit = function (events) {
        var listeners = this._listeners.slice(0);
        for (var i = 0, len = listeners.length; i < len; i++) {
            safeInvokeListener(listeners[i], events);
        }
    };
    ViewEventEmitter.prototype.addEventListener = function (listener) {
        var _this = this;
        this._listeners.push(listener);
        return {
            dispose: function () {
                var listeners = _this._listeners;
                for (var i = 0, len = listeners.length; i < len; i++) {
                    if (listeners[i] === listener) {
                        listeners.splice(i, 1);
                        break;
                    }
                }
            }
        };
    };
    return ViewEventEmitter;
}(Disposable));
var ViewEventsCollector = /** @class */ (function () {
    function ViewEventsCollector() {
        this._eventsLen = 0;
        this._events = [];
        this._eventsLen = 0;
    }
    ViewEventsCollector.prototype.emit = function (event) {
        this._events[this._eventsLen++] = event;
    };
    ViewEventsCollector.prototype.finalize = function () {
        var result = this._events;
        this._events = null;
        return result;
    };
    return ViewEventsCollector;
}());
function safeInvokeListener(listener, events) {
    try {
        listener(events);
    }
    catch (e) {
        onUnexpectedError(e);
    }
}

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$c = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
function containsLineMappingChanged(events) {
    for (var i = 0, len = events.length; i < len; i++) {
        if (events[i].type === 6 /* ViewLineMappingChanged */) {
            return true;
        }
    }
    return false;
}
var CursorStateChangedEvent = /** @class */ (function () {
    function CursorStateChangedEvent(selections, source, reason) {
        this.selections = selections;
        this.source = source;
        this.reason = reason;
    }
    return CursorStateChangedEvent;
}());
/**
 * A snapshot of the cursor and the model state
 */
var CursorModelState = /** @class */ (function () {
    function CursorModelState(model, cursor) {
        this.modelVersionId = model.getVersionId();
        this.cursorState = cursor.getAll();
    }
    CursorModelState.prototype.equals = function (other) {
        if (!other) {
            return false;
        }
        if (this.modelVersionId !== other.modelVersionId) {
            return false;
        }
        if (this.cursorState.length !== other.cursorState.length) {
            return false;
        }
        for (var i = 0, len = this.cursorState.length; i < len; i++) {
            if (!this.cursorState[i].equals(other.cursorState[i])) {
                return false;
            }
        }
        return true;
    };
    return CursorModelState;
}());
var Cursor = /** @class */ (function (_super) {
    __extends$c(Cursor, _super);
    function Cursor(configuration, model, viewModel) {
        var _this = _super.call(this) || this;
        _this._onDidReachMaxCursorCount = _this._register(new Emitter());
        _this.onDidReachMaxCursorCount = _this._onDidReachMaxCursorCount.event;
        _this._onDidAttemptReadOnlyEdit = _this._register(new Emitter());
        _this.onDidAttemptReadOnlyEdit = _this._onDidAttemptReadOnlyEdit.event;
        _this._onDidChange = _this._register(new Emitter());
        _this.onDidChange = _this._onDidChange.event;
        _this._configuration = configuration;
        _this._model = model;
        _this._knownModelVersionId = _this._model.getVersionId();
        _this._viewModel = viewModel;
        _this.context = new CursorContext(_this._configuration, _this._model, _this._viewModel);
        _this._cursors = new CursorCollection(_this.context);
        _this._isHandling = false;
        _this._isDoingComposition = false;
        _this._columnSelectData = null;
        _this._prevEditOperationType = 0 /* Other */;
        _this._register(_this._model.onDidChangeRawContent(function (e) {
            _this._knownModelVersionId = e.versionId;
            if (_this._isHandling) {
                return;
            }
            var hadFlushEvent = e.containsEvent(1 /* Flush */);
            _this._onModelContentChanged(hadFlushEvent);
        }));
        _this._register(viewModel.addEventListener(function (events) {
            if (!containsLineMappingChanged(events)) {
                return;
            }
            if (_this._knownModelVersionId !== _this._model.getVersionId()) {
                // There are model change events that I didn't yet receive.
                //
                // This can happen when editing the model, and the view model receives the change events first,
                // and the view model emits line mapping changed events, all before the cursor gets a chance to
                // recover from markers.
                //
                // The model change listener above will be called soon and we'll ensure a valid cursor state there.
                return;
            }
            // Ensure valid state
            _this.setStates('viewModel', CursorChangeReason.NotSet, _this.getAll());
        }));
        var updateCursorContext = function () {
            _this.context = new CursorContext(_this._configuration, _this._model, _this._viewModel);
            _this._cursors.updateContext(_this.context);
        };
        _this._register(_this._model.onDidChangeLanguage(function (e) {
            updateCursorContext();
        }));
        _this._register(_this._model.onDidChangeLanguageConfiguration(function () {
            updateCursorContext();
        }));
        _this._register(_this._model.onDidChangeOptions(function () {
            updateCursorContext();
        }));
        _this._register(_this._configuration.onDidChange(function (e) {
            if (CursorConfiguration.shouldRecreate(e)) {
                updateCursorContext();
            }
        }));
        return _this;
    }
    Cursor.prototype.dispose = function () {
        this._cursors.dispose();
        _super.prototype.dispose.call(this);
    };
    // ------ some getters/setters
    Cursor.prototype.getPrimaryCursor = function () {
        return this._cursors.getPrimaryCursor();
    };
    Cursor.prototype.getLastAddedCursorIndex = function () {
        return this._cursors.getLastAddedCursorIndex();
    };
    Cursor.prototype.getAll = function () {
        return this._cursors.getAll();
    };
    Cursor.prototype.setStates = function (source, reason, states) {
        if (states.length > Cursor.MAX_CURSOR_COUNT) {
            states = states.slice(0, Cursor.MAX_CURSOR_COUNT);
            this._onDidReachMaxCursorCount.fire(void 0);
        }
        var oldState = new CursorModelState(this._model, this);
        this._cursors.setStates(states);
        this._cursors.normalize();
        this._columnSelectData = null;
        this._emitStateChangedIfNecessary(source, reason, oldState);
    };
    Cursor.prototype.setColumnSelectData = function (columnSelectData) {
        this._columnSelectData = columnSelectData;
    };
    Cursor.prototype.reveal = function (horizontal, target, scrollType) {
        this._revealRange(target, 0 /* Simple */, horizontal, scrollType);
    };
    Cursor.prototype.revealRange = function (revealHorizontal, viewRange, verticalType, scrollType) {
        this.emitCursorRevealRange(viewRange, verticalType, revealHorizontal, scrollType);
    };
    Cursor.prototype.scrollTo = function (desiredScrollTop) {
        this._viewModel.viewLayout.setScrollPositionSmooth({
            scrollTop: desiredScrollTop
        });
    };
    Cursor.prototype.saveState = function () {
        var result = [];
        var selections = this._cursors.getSelections();
        for (var i = 0, len = selections.length; i < len; i++) {
            var selection = selections[i];
            result.push({
                inSelectionMode: !selection.isEmpty(),
                selectionStart: {
                    lineNumber: selection.selectionStartLineNumber,
                    column: selection.selectionStartColumn,
                },
                position: {
                    lineNumber: selection.positionLineNumber,
                    column: selection.positionColumn,
                }
            });
        }
        return result;
    };
    Cursor.prototype.restoreState = function (states) {
        var desiredSelections = [];
        for (var i = 0, len = states.length; i < len; i++) {
            var state = states[i];
            var positionLineNumber = 1;
            var positionColumn = 1;
            // Avoid missing properties on the literal
            if (state.position && state.position.lineNumber) {
                positionLineNumber = state.position.lineNumber;
            }
            if (state.position && state.position.column) {
                positionColumn = state.position.column;
            }
            var selectionStartLineNumber = positionLineNumber;
            var selectionStartColumn = positionColumn;
            // Avoid missing properties on the literal
            if (state.selectionStart && state.selectionStart.lineNumber) {
                selectionStartLineNumber = state.selectionStart.lineNumber;
            }
            if (state.selectionStart && state.selectionStart.column) {
                selectionStartColumn = state.selectionStart.column;
            }
            desiredSelections.push({
                selectionStartLineNumber: selectionStartLineNumber,
                selectionStartColumn: selectionStartColumn,
                positionLineNumber: positionLineNumber,
                positionColumn: positionColumn
            });
        }
        this.setStates('restoreState', CursorChangeReason.NotSet, CursorState.fromModelSelections(desiredSelections));
        this.reveal(true, 0 /* Primary */, 1 /* Immediate */);
    };
    Cursor.prototype._onModelContentChanged = function (hadFlushEvent) {
        this._prevEditOperationType = 0 /* Other */;
        if (hadFlushEvent) {
            // a model.setValue() was called
            this._cursors.dispose();
            this._cursors = new CursorCollection(this.context);
            this._emitStateChangedIfNecessary('model', CursorChangeReason.ContentFlush, null);
        }
        else {
            var selectionsFromMarkers = this._cursors.readSelectionFromMarkers();
            this.setStates('modelChange', CursorChangeReason.RecoverFromMarkers, CursorState.fromModelSelections(selectionsFromMarkers));
        }
    };
    Cursor.prototype.getSelection = function () {
        return this._cursors.getPrimaryCursor().modelState.selection;
    };
    Cursor.prototype.getColumnSelectData = function () {
        if (this._columnSelectData) {
            return this._columnSelectData;
        }
        var primaryCursor = this._cursors.getPrimaryCursor();
        var primaryPos = primaryCursor.viewState.position;
        return {
            toViewLineNumber: primaryPos.lineNumber,
            toViewVisualColumn: CursorColumns.visibleColumnFromColumn2(this.context.config, this.context.viewModel, primaryPos)
        };
    };
    Cursor.prototype.getSelections = function () {
        return this._cursors.getSelections();
    };
    Cursor.prototype.getViewSelections = function () {
        return this._cursors.getViewSelections();
    };
    Cursor.prototype.getPosition = function () {
        return this._cursors.getPrimaryCursor().modelState.position;
    };
    Cursor.prototype.setSelections = function (source, selections) {
        this.setStates(source, CursorChangeReason.NotSet, CursorState.fromModelSelections(selections));
    };
    Cursor.prototype.getPrevEditOperationType = function () {
        return this._prevEditOperationType;
    };
    Cursor.prototype.setPrevEditOperationType = function (type) {
        this._prevEditOperationType = type;
    };
    // ------ auxiliary handling logic
    Cursor.prototype._executeEditOperation = function (opResult) {
        if (!opResult) {
            // Nothing to execute
            return;
        }
        if (opResult.shouldPushStackElementBefore) {
            this._model.pushStackElement();
        }
        var result = CommandExecutor.executeCommands(this._model, this._cursors.getSelections(), opResult.commands);
        if (result) {
            // The commands were applied correctly
            this._interpretCommandResult(result);
            this._prevEditOperationType = opResult.type;
        }
        if (opResult.shouldPushStackElementAfter) {
            this._model.pushStackElement();
        }
    };
    Cursor.prototype._interpretCommandResult = function (cursorState) {
        if (!cursorState || cursorState.length === 0) {
            cursorState = this._cursors.readSelectionFromMarkers();
        }
        this._columnSelectData = null;
        this._cursors.setSelections(cursorState);
        this._cursors.normalize();
    };
    // -----------------------------------------------------------------------------------------------------------
    // ----- emitting events
    Cursor.prototype._emitStateChangedIfNecessary = function (source, reason, oldState) {
        var newState = new CursorModelState(this._model, this);
        if (newState.equals(oldState)) {
            return false;
        }
        var selections = this._cursors.getSelections();
        var viewSelections = this._cursors.getViewSelections();
        // Let the view get the event first.
        try {
            var eventsCollector = this._beginEmit();
            eventsCollector.emit(new ViewCursorStateChangedEvent(viewSelections));
        }
        finally {
            this._endEmit();
        }
        // Only after the view has been notified, let the rest of the world know...
        if (!oldState
            || oldState.cursorState.length !== newState.cursorState.length
            || newState.cursorState.some(function (newCursorState, i) { return !newCursorState.modelState.equals(oldState.cursorState[i].modelState); })) {
            this._onDidChange.fire(new CursorStateChangedEvent(selections, source || 'keyboard', reason));
        }
        return true;
    };
    Cursor.prototype._revealRange = function (revealTarget, verticalType, revealHorizontal, scrollType) {
        var viewPositions = this._cursors.getViewPositions();
        var viewPosition = viewPositions[0];
        if (revealTarget === 1 /* TopMost */) {
            for (var i = 1; i < viewPositions.length; i++) {
                if (viewPositions[i].isBefore(viewPosition)) {
                    viewPosition = viewPositions[i];
                }
            }
        }
        else if (revealTarget === 2 /* BottomMost */) {
            for (var i = 1; i < viewPositions.length; i++) {
                if (viewPosition.isBeforeOrEqual(viewPositions[i])) {
                    viewPosition = viewPositions[i];
                }
            }
        }
        else {
            if (viewPositions.length > 1) {
                // no revealing!
                return;
            }
        }
        var viewRange = new Range(viewPosition.lineNumber, viewPosition.column, viewPosition.lineNumber, viewPosition.column);
        this.emitCursorRevealRange(viewRange, verticalType, revealHorizontal, scrollType);
    };
    Cursor.prototype.emitCursorRevealRange = function (viewRange, verticalType, revealHorizontal, scrollType) {
        try {
            var eventsCollector = this._beginEmit();
            eventsCollector.emit(new ViewRevealRangeRequestEvent(viewRange, verticalType, revealHorizontal, scrollType));
        }
        finally {
            this._endEmit();
        }
    };
    // -----------------------------------------------------------------------------------------------------------
    // ----- handlers beyond this point
    Cursor.prototype.trigger = function (source, handlerId, payload) {
        var H = Handler;
        if (handlerId === H.CompositionStart) {
            this._isDoingComposition = true;
            return;
        }
        if (handlerId === H.CompositionEnd) {
            this._isDoingComposition = false;
            return;
        }
        if (this._configuration.editor.readOnly) {
            // All the remaining handlers will try to edit the model,
            // but we cannot edit when read only...
            this._onDidAttemptReadOnlyEdit.fire(void 0);
            return;
        }
        var oldState = new CursorModelState(this._model, this);
        var cursorChangeReason = CursorChangeReason.NotSet;
        if (handlerId !== H.Undo && handlerId !== H.Redo) {
            // TODO@Alex: if the undo/redo stack contains non-null selections
            // it would also be OK to stop tracking selections here
            this._cursors.stopTrackingSelections();
        }
        // ensure valid state on all cursors
        this._cursors.ensureValidState();
        this._isHandling = true;
        try {
            switch (handlerId) {
                case H.Type:
                    this._type(source, payload.text);
                    break;
                case H.ReplacePreviousChar:
                    this._replacePreviousChar(payload.text, payload.replaceCharCnt);
                    break;
                case H.Paste:
                    cursorChangeReason = CursorChangeReason.Paste;
                    this._paste(payload.text, payload.pasteOnNewLine, payload.multicursorText);
                    break;
                case H.Cut:
                    this._cut();
                    break;
                case H.Undo:
                    cursorChangeReason = CursorChangeReason.Undo;
                    this._interpretCommandResult(this._model.undo());
                    break;
                case H.Redo:
                    cursorChangeReason = CursorChangeReason.Redo;
                    this._interpretCommandResult(this._model.redo());
                    break;
                case H.ExecuteCommand:
                    this._externalExecuteCommand(payload);
                    break;
                case H.ExecuteCommands:
                    this._externalExecuteCommands(payload);
                    break;
            }
        }
        catch (err) {
            onUnexpectedError(err);
        }
        this._isHandling = false;
        if (handlerId !== H.Undo && handlerId !== H.Redo) {
            this._cursors.startTrackingSelections();
        }
        if (this._emitStateChangedIfNecessary(source, cursorChangeReason, oldState)) {
            this._revealRange(0 /* Primary */, 0 /* Simple */, true, 0 /* Smooth */);
        }
    };
    Cursor.prototype._type = function (source, text) {
        if (!this._isDoingComposition && source === 'keyboard') {
            // If this event is coming straight from the keyboard, look for electric characters and enter
            for (var i = 0, len = text.length; i < len; i++) {
                var charCode = text.charCodeAt(i);
                var chr = void 0;
                if (isHighSurrogate(charCode) && i + 1 < len) {
                    chr = text.charAt(i) + text.charAt(i + 1);
                    i++;
                }
                else {
                    chr = text.charAt(i);
                }
                // Here we must interpret each typed character individually, that's why we create a new context
                this._executeEditOperation(TypeOperations.typeWithInterceptors(this._prevEditOperationType, this.context.config, this.context.model, this.getSelections(), chr));
            }
        }
        else {
            this._executeEditOperation(TypeOperations.typeWithoutInterceptors(this._prevEditOperationType, this.context.config, this.context.model, this.getSelections(), text));
        }
    };
    Cursor.prototype._replacePreviousChar = function (text, replaceCharCnt) {
        this._executeEditOperation(TypeOperations.replacePreviousChar(this._prevEditOperationType, this.context.config, this.context.model, this.getSelections(), text, replaceCharCnt));
    };
    Cursor.prototype._paste = function (text, pasteOnNewLine, multicursorText) {
        this._executeEditOperation(TypeOperations.paste(this.context.config, this.context.model, this.getSelections(), text, pasteOnNewLine, multicursorText));
    };
    Cursor.prototype._cut = function () {
        this._executeEditOperation(DeleteOperations.cut(this.context.config, this.context.model, this.getSelections()));
    };
    Cursor.prototype._externalExecuteCommand = function (command) {
        this._cursors.killSecondaryCursors();
        this._executeEditOperation(new EditOperationResult(0 /* Other */, [command], {
            shouldPushStackElementBefore: false,
            shouldPushStackElementAfter: false
        }));
    };
    Cursor.prototype._externalExecuteCommands = function (commands) {
        this._executeEditOperation(new EditOperationResult(0 /* Other */, commands, {
            shouldPushStackElementBefore: false,
            shouldPushStackElementAfter: false
        }));
    };
    Cursor.MAX_CURSOR_COUNT = 10000;
    return Cursor;
}(ViewEventEmitter));
var CommandExecutor = /** @class */ (function () {
    function CommandExecutor() {
    }
    CommandExecutor.executeCommands = function (model, selectionsBefore, commands) {
        var ctx = {
            model: model,
            selectionsBefore: selectionsBefore,
            trackedRanges: [],
            trackedRangesDirection: []
        };
        var result = this._innerExecuteCommands(ctx, commands);
        for (var i = 0, len = ctx.trackedRanges.length; i < len; i++) {
            ctx.model._setTrackedRange(ctx.trackedRanges[i], null, TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges);
        }
        return result;
    };
    CommandExecutor._innerExecuteCommands = function (ctx, commands) {
        if (this._arrayIsEmpty(commands)) {
            return null;
        }
        var commandsData = this._getEditOperations(ctx, commands);
        if (commandsData.operations.length === 0) {
            return null;
        }
        var rawOperations = commandsData.operations;
        var loserCursorsMap = this._getLoserCursorMap(rawOperations);
        if (loserCursorsMap.hasOwnProperty('0')) {
            // These commands are very messed up
            console.warn('Ignoring commands');
            return null;
        }
        // Remove operations belonging to losing cursors
        var filteredOperations = [];
        for (var i = 0, len = rawOperations.length; i < len; i++) {
            if (!loserCursorsMap.hasOwnProperty(rawOperations[i].identifier.major.toString())) {
                filteredOperations.push(rawOperations[i]);
            }
        }
        // TODO@Alex: find a better way to do this.
        // give the hint that edit operations are tracked to the model
        if (commandsData.hadTrackedEditOperation && filteredOperations.length > 0) {
            filteredOperations[0]._isTracked = true;
        }
        var selectionsAfter = ctx.model.pushEditOperations(ctx.selectionsBefore, filteredOperations, function (inverseEditOperations) {
            var groupedInverseEditOperations = [];
            for (var i = 0; i < ctx.selectionsBefore.length; i++) {
                groupedInverseEditOperations[i] = [];
            }
            for (var i = 0; i < inverseEditOperations.length; i++) {
                var op = inverseEditOperations[i];
                if (!op.identifier) {
                    // perhaps auto whitespace trim edits
                    continue;
                }
                groupedInverseEditOperations[op.identifier.major].push(op);
            }
            var minorBasedSorter = function (a, b) {
                return a.identifier.minor - b.identifier.minor;
            };
            var cursorSelections = [];
            var _loop_1 = function (i) {
                if (groupedInverseEditOperations[i].length > 0) {
                    groupedInverseEditOperations[i].sort(minorBasedSorter);
                    cursorSelections[i] = commands[i].computeCursorState(ctx.model, {
                        getInverseEditOperations: function () {
                            return groupedInverseEditOperations[i];
                        },
                        getTrackedSelection: function (id) {
                            var idx = parseInt(id, 10);
                            var range = ctx.model._getTrackedRange(ctx.trackedRanges[idx]);
                            if (ctx.trackedRangesDirection[idx] === SelectionDirection.LTR) {
                                return new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);
                            }
                            return new Selection(range.endLineNumber, range.endColumn, range.startLineNumber, range.startColumn);
                        }
                    });
                }
                else {
                    cursorSelections[i] = ctx.selectionsBefore[i];
                }
            };
            for (var i = 0; i < ctx.selectionsBefore.length; i++) {
                _loop_1(i);
            }
            return cursorSelections;
        });
        // Extract losing cursors
        var losingCursors = [];
        for (var losingCursorIndex in loserCursorsMap) {
            if (loserCursorsMap.hasOwnProperty(losingCursorIndex)) {
                losingCursors.push(parseInt(losingCursorIndex, 10));
            }
        }
        // Sort losing cursors descending
        losingCursors.sort(function (a, b) {
            return b - a;
        });
        // Remove losing cursors
        for (var i = 0; i < losingCursors.length; i++) {
            selectionsAfter.splice(losingCursors[i], 1);
        }
        return selectionsAfter;
    };
    CommandExecutor._arrayIsEmpty = function (commands) {
        for (var i = 0, len = commands.length; i < len; i++) {
            if (commands[i]) {
                return false;
            }
        }
        return true;
    };
    CommandExecutor._getEditOperations = function (ctx, commands) {
        var operations = [];
        var hadTrackedEditOperation = false;
        for (var i = 0, len = commands.length; i < len; i++) {
            if (commands[i]) {
                var r = this._getEditOperationsFromCommand(ctx, i, commands[i]);
                operations = operations.concat(r.operations);
                hadTrackedEditOperation = hadTrackedEditOperation || r.hadTrackedEditOperation;
            }
        }
        return {
            operations: operations,
            hadTrackedEditOperation: hadTrackedEditOperation
        };
    };
    CommandExecutor._getEditOperationsFromCommand = function (ctx, majorIdentifier, command) {
        // This method acts as a transaction, if the command fails
        // everything it has done is ignored
        var operations = [];
        var operationMinor = 0;
        var addEditOperation = function (selection, text) {
            if (selection.isEmpty() && text === '') {
                // This command wants to add a no-op => no thank you
                return;
            }
            operations.push({
                identifier: {
                    major: majorIdentifier,
                    minor: operationMinor++
                },
                range: selection,
                text: text,
                forceMoveMarkers: false,
                isAutoWhitespaceEdit: command.insertsAutoWhitespace
            });
        };
        var hadTrackedEditOperation = false;
        var addTrackedEditOperation = function (selection, text) {
            hadTrackedEditOperation = true;
            addEditOperation(selection, text);
        };
        var trackSelection = function (selection, trackPreviousOnEmpty) {
            var stickiness;
            if (selection.isEmpty()) {
                if (typeof trackPreviousOnEmpty === 'boolean') {
                    if (trackPreviousOnEmpty) {
                        stickiness = TrackedRangeStickiness.GrowsOnlyWhenTypingBefore;
                    }
                    else {
                        stickiness = TrackedRangeStickiness.GrowsOnlyWhenTypingAfter;
                    }
                }
                else {
                    // Try to lock it with surrounding text
                    var maxLineColumn = ctx.model.getLineMaxColumn(selection.startLineNumber);
                    if (selection.startColumn === maxLineColumn) {
                        stickiness = TrackedRangeStickiness.GrowsOnlyWhenTypingBefore;
                    }
                    else {
                        stickiness = TrackedRangeStickiness.GrowsOnlyWhenTypingAfter;
                    }
                }
            }
            else {
                stickiness = TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges;
            }
            var l = ctx.trackedRanges.length;
            var id = ctx.model._setTrackedRange(null, selection, stickiness);
            ctx.trackedRanges[l] = id;
            ctx.trackedRangesDirection[l] = selection.getDirection();
            return l.toString();
        };
        var editOperationBuilder = {
            addEditOperation: addEditOperation,
            addTrackedEditOperation: addTrackedEditOperation,
            trackSelection: trackSelection
        };
        try {
            command.getEditOperations(ctx.model, editOperationBuilder);
        }
        catch (e) {
            e.friendlyMessage = localize('corrupt.commands', "Unexpected exception while executing command.");
            onUnexpectedError(e);
            return {
                operations: [],
                hadTrackedEditOperation: false
            };
        }
        return {
            operations: operations,
            hadTrackedEditOperation: hadTrackedEditOperation
        };
    };
    CommandExecutor._getLoserCursorMap = function (operations) {
        // This is destructive on the array
        operations = operations.slice(0);
        // Sort operations with last one first
        operations.sort(function (a, b) {
            // Note the minus!
            return -(Range.compareRangesUsingEnds(a.range, b.range));
        });
        // Operations can not overlap!
        var loserCursorsMap = {};
        for (var i = 1; i < operations.length; i++) {
            var previousOp = operations[i - 1];
            var currentOp = operations[i];
            if (previousOp.range.getStartPosition().isBefore(currentOp.range.getEndPosition())) {
                var loserMajor = void 0;
                if (previousOp.identifier.major > currentOp.identifier.major) {
                    // previousOp loses the battle
                    loserMajor = previousOp.identifier.major;
                }
                else {
                    loserMajor = currentOp.identifier.major;
                }
                loserCursorsMap[loserMajor.toString()] = true;
                for (var j = 0; j < operations.length; j++) {
                    if (operations[j].identifier.major === loserMajor) {
                        operations.splice(j, 1);
                        if (j < i) {
                            i--;
                        }
                        j--;
                    }
                }
                if (i > 0) {
                    i--;
                }
            }
        }
        return loserCursorsMap;
    };
    return CommandExecutor;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
function tokenizeToString(text, languageId) {
    return _tokenizeToString(text, _getSafeTokenizationSupport(languageId));
}
function tokenizeLineToHTML(text, viewLineTokens, colorMap, startOffset, endOffset, tabSize) {
    var result = "<div>";
    var charIndex = startOffset;
    var tabsCharDelta = 0;
    for (var tokenIndex = 0, tokenCount = viewLineTokens.getCount(); tokenIndex < tokenCount; tokenIndex++) {
        var tokenEndIndex = viewLineTokens.getEndOffset(tokenIndex);
        if (tokenEndIndex <= startOffset) {
            continue;
        }
        var partContent = '';
        for (; charIndex < tokenEndIndex && charIndex < endOffset; charIndex++) {
            var charCode = text.charCodeAt(charIndex);
            switch (charCode) {
                case 9 /* Tab */:
                    var insertSpacesCount = tabSize - (charIndex + tabsCharDelta) % tabSize;
                    tabsCharDelta += insertSpacesCount - 1;
                    while (insertSpacesCount > 0) {
                        partContent += '&nbsp;';
                        insertSpacesCount--;
                    }
                    break;
                case 60 /* LessThan */:
                    partContent += '&lt;';
                    break;
                case 62 /* GreaterThan */:
                    partContent += '&gt;';
                    break;
                case 38 /* Ampersand */:
                    partContent += '&amp;';
                    break;
                case 0 /* Null */:
                    partContent += '&#00;';
                    break;
                case 65279 /* UTF8_BOM */:
                case 8232 /* LINE_SEPARATOR_2028 */:
                    partContent += '\ufffd';
                    break;
                case 13 /* CarriageReturn */:
                    // zero width space, because carriage return would introduce a line break
                    partContent += '&#8203';
                    break;
                default:
                    partContent += String.fromCharCode(charCode);
            }
        }
        result += "<span style=\"" + viewLineTokens.getInlineStyle(tokenIndex, colorMap) + "\">" + partContent + "</span>";
        if (tokenEndIndex > endOffset || charIndex >= endOffset) {
            break;
        }
    }
    result += "</div>";
    return result;
}
function _getSafeTokenizationSupport(languageId) {
    var tokenizationSupport = TokenizationRegistry.get(languageId);
    if (tokenizationSupport) {
        return tokenizationSupport;
    }
    return {
        getInitialState: function () { return NULL_STATE; },
        tokenize: undefined,
        tokenize2: function (buffer, state, deltaOffset) { return nullTokenize2(0 /* Null */, buffer, state, deltaOffset); }
    };
}
function _tokenizeToString(text, tokenizationSupport) {
    var result = "<div class=\"monaco-tokenized-source\">";
    var lines = text.split(/\r\n|\r|\n/);
    var currentState = tokenizationSupport.getInitialState();
    for (var i = 0, len = lines.length; i < len; i++) {
        var line = lines[i];
        if (i > 0) {
            result += "<br/>";
        }
        var tokenizationResult = tokenizationSupport.tokenize2(line, currentState, 0);
        LineTokens.convertToEndOffset(tokenizationResult.tokens, line.length);
        var lineTokens = new LineTokens(tokenizationResult.tokens, line);
        var viewLineTokens = lineTokens.inflate();
        var startOffset = 0;
        for (var j = 0, lenJ = viewLineTokens.getCount(); j < lenJ; j++) {
            var type = viewLineTokens.getClassName(j);
            var endIndex = viewLineTokens.getEndOffset(j);
            result += "<span class=\"" + type + "\">" + escape(line.substring(startOffset, endIndex)) + "</span>";
            startOffset = endIndex;
        }
        currentState = tokenizationResult.endState;
    }
    result += "</div>";
    return result;
}

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var Viewport = /** @class */ (function () {
    function Viewport(top, left, width, height) {
        this.top = top | 0;
        this.left = left | 0;
        this.width = width | 0;
        this.height = height | 0;
    }
    return Viewport;
}());
var MinimapLinesRenderingData = /** @class */ (function () {
    function MinimapLinesRenderingData(tabSize, data) {
        this.tabSize = tabSize;
        this.data = data;
    }
    return MinimapLinesRenderingData;
}());
var ViewLineData = /** @class */ (function () {
    function ViewLineData(content, minColumn, maxColumn, tokens) {
        this.content = content;
        this.minColumn = minColumn;
        this.maxColumn = maxColumn;
        this.tokens = tokens;
    }
    return ViewLineData;
}());
var ViewLineRenderingData = /** @class */ (function () {
    function ViewLineRenderingData(minColumn, maxColumn, content, mightContainRTL, mightContainNonBasicASCII, tokens, inlineDecorations, tabSize) {
        this.minColumn = minColumn;
        this.maxColumn = maxColumn;
        this.content = content;
        this.isBasicASCII = ViewLineRenderingData.isBasicASCII(content, mightContainNonBasicASCII);
        this.containsRTL = ViewLineRenderingData.containsRTL(content, this.isBasicASCII, mightContainRTL);
        this.tokens = tokens;
        this.inlineDecorations = inlineDecorations;
        this.tabSize = tabSize;
    }
    ViewLineRenderingData.isBasicASCII = function (lineContent, mightContainNonBasicASCII) {
        if (mightContainNonBasicASCII) {
            return isBasicASCII(lineContent);
        }
        return true;
    };
    ViewLineRenderingData.containsRTL = function (lineContent, isBasicASCII$$1, mightContainRTL) {
        if (!isBasicASCII$$1 && mightContainRTL) {
            return containsRTL(lineContent);
        }
        return false;
    };
    return ViewLineRenderingData;
}());
var InlineDecoration = /** @class */ (function () {
    function InlineDecoration(range, inlineClassName, type) {
        this.range = range;
        this.inlineClassName = inlineClassName;
        this.type = type;
    }
    return InlineDecoration;
}());
var ViewModelDecoration = /** @class */ (function () {
    function ViewModelDecoration(range, options) {
        this.range = range;
        this.options = options;
    }
    return ViewModelDecoration;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var ViewModelDecorations = /** @class */ (function () {
    function ViewModelDecorations(editorId, model, configuration, linesCollection, coordinatesConverter) {
        this.editorId = editorId;
        this.model = model;
        this.configuration = configuration;
        this._linesCollection = linesCollection;
        this._coordinatesConverter = coordinatesConverter;
        this._decorationsCache = Object.create(null);
        this._clearCachedModelDecorationsResolver();
    }
    ViewModelDecorations.prototype._clearCachedModelDecorationsResolver = function () {
        this._cachedModelDecorationsResolver = null;
        this._cachedModelDecorationsResolverViewRange = null;
    };
    ViewModelDecorations.prototype.dispose = function () {
        this._decorationsCache = null;
        this._clearCachedModelDecorationsResolver();
    };
    ViewModelDecorations.prototype.reset = function () {
        this._decorationsCache = Object.create(null);
        this._clearCachedModelDecorationsResolver();
    };
    ViewModelDecorations.prototype.onModelDecorationsChanged = function () {
        this._decorationsCache = Object.create(null);
        this._clearCachedModelDecorationsResolver();
    };
    ViewModelDecorations.prototype.onLineMappingChanged = function () {
        this._decorationsCache = Object.create(null);
        this._clearCachedModelDecorationsResolver();
    };
    ViewModelDecorations.prototype._getOrCreateViewModelDecoration = function (modelDecoration) {
        var id = modelDecoration.id;
        var r = this._decorationsCache[id];
        if (!r) {
            var modelRange = modelDecoration.range;
            var options = modelDecoration.options;
            var viewRange = void 0;
            if (options.isWholeLine) {
                var start = this._coordinatesConverter.convertModelPositionToViewPosition(new Position(modelRange.startLineNumber, 1));
                var end = this._coordinatesConverter.convertModelPositionToViewPosition(new Position(modelRange.endLineNumber, this.model.getLineMaxColumn(modelRange.endLineNumber)));
                viewRange = new Range(start.lineNumber, start.column, end.lineNumber, end.column);
            }
            else {
                viewRange = this._coordinatesConverter.convertModelRangeToViewRange(modelRange);
            }
            r = new ViewModelDecoration(viewRange, options);
            this._decorationsCache[id] = r;
        }
        return r;
    };
    ViewModelDecorations.prototype.getDecorationsViewportData = function (viewRange) {
        var cacheIsValid = true;
        cacheIsValid = cacheIsValid && (this._cachedModelDecorationsResolver !== null);
        cacheIsValid = cacheIsValid && (viewRange.equalsRange(this._cachedModelDecorationsResolverViewRange));
        if (!cacheIsValid) {
            this._cachedModelDecorationsResolver = this._getDecorationsViewportData(viewRange);
            this._cachedModelDecorationsResolverViewRange = viewRange;
        }
        return this._cachedModelDecorationsResolver;
    };
    ViewModelDecorations.prototype._getDecorationsViewportData = function (viewportRange) {
        var modelDecorations = this._linesCollection.getDecorationsInRange(viewportRange, this.editorId, this.configuration.editor.readOnly);
        var startLineNumber = viewportRange.startLineNumber;
        var endLineNumber = viewportRange.endLineNumber;
        var decorationsInViewport = [], decorationsInViewportLen = 0;
        var inlineDecorations = [];
        for (var j = startLineNumber; j <= endLineNumber; j++) {
            inlineDecorations[j - startLineNumber] = [];
        }
        for (var i = 0, len = modelDecorations.length; i < len; i++) {
            var modelDecoration = modelDecorations[i];
            var decorationOptions = modelDecoration.options;
            var viewModelDecoration = this._getOrCreateViewModelDecoration(modelDecoration);
            var viewRange = viewModelDecoration.range;
            decorationsInViewport[decorationsInViewportLen++] = viewModelDecoration;
            if (decorationOptions.inlineClassName) {
                var inlineDecoration = new InlineDecoration(viewRange, decorationOptions.inlineClassName, decorationOptions.inlineClassNameAffectsLetterSpacing ? 3 /* RegularAffectingLetterSpacing */ : 0 /* Regular */);
                var intersectedStartLineNumber = Math.max(startLineNumber, viewRange.startLineNumber);
                var intersectedEndLineNumber = Math.min(endLineNumber, viewRange.endLineNumber);
                for (var j = intersectedStartLineNumber; j <= intersectedEndLineNumber; j++) {
                    inlineDecorations[j - startLineNumber].push(inlineDecoration);
                }
            }
            if (decorationOptions.beforeContentClassName) {
                if (startLineNumber <= viewRange.startLineNumber && viewRange.startLineNumber <= endLineNumber) {
                    var inlineDecoration = new InlineDecoration(new Range(viewRange.startLineNumber, viewRange.startColumn, viewRange.startLineNumber, viewRange.startColumn), decorationOptions.beforeContentClassName, 1 /* Before */);
                    inlineDecorations[viewRange.startLineNumber - startLineNumber].push(inlineDecoration);
                }
            }
            if (decorationOptions.afterContentClassName) {
                if (startLineNumber <= viewRange.endLineNumber && viewRange.endLineNumber <= endLineNumber) {
                    var inlineDecoration = new InlineDecoration(new Range(viewRange.endLineNumber, viewRange.endColumn, viewRange.endLineNumber, viewRange.endColumn), decorationOptions.afterContentClassName, 2 /* After */);
                    inlineDecorations[viewRange.endLineNumber - startLineNumber].push(inlineDecoration);
                }
            }
        }
        return {
            decorations: decorationsInViewport,
            inlineDecorations: inlineDecorations
        };
    };
    return ViewModelDecorations;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
function roundFloat(number, decimalPoints) {
    var decimal = Math.pow(10, decimalPoints);
    return Math.round(number * decimal) / decimal;
}
var RGBA = /** @class */ (function () {
    function RGBA(r, g, b, a) {
        if (a === void 0) { a = 1; }
        this.r = Math.min(255, Math.max(0, r)) | 0;
        this.g = Math.min(255, Math.max(0, g)) | 0;
        this.b = Math.min(255, Math.max(0, b)) | 0;
        this.a = roundFloat(Math.max(Math.min(1, a), 0), 3);
    }
    RGBA.equals = function (a, b) {
        return a.r === b.r && a.g === b.g && a.b === b.b && a.a === b.a;
    };
    return RGBA;
}());
var HSLA = /** @class */ (function () {
    function HSLA(h, s, l, a) {
        this.h = Math.max(Math.min(360, h), 0) | 0;
        this.s = roundFloat(Math.max(Math.min(1, s), 0), 3);
        this.l = roundFloat(Math.max(Math.min(1, l), 0), 3);
        this.a = roundFloat(Math.max(Math.min(1, a), 0), 3);
    }
    HSLA.equals = function (a, b) {
        return a.h === b.h && a.s === b.s && a.l === b.l && a.a === b.a;
    };
    /**
     * Converts an RGB color value to HSL. Conversion formula
     * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
     * Assumes r, g, and b are contained in the set [0, 255] and
     * returns h in the set [0, 360], s, and l in the set [0, 1].
     */
    HSLA.fromRGBA = function (rgba) {
        var r = rgba.r / 255;
        var g = rgba.g / 255;
        var b = rgba.b / 255;
        var a = rgba.a;
        var max = Math.max(r, g, b);
        var min = Math.min(r, g, b);
        var h = 0;
        var s = 0;
        var l = (min + max) / 2;
        var chroma = max - min;
        if (chroma > 0) {
            s = Math.min((l <= 0.5 ? chroma / (2 * l) : chroma / (2 - (2 * l))), 1);
            switch (max) {
                case r:
                    h = (g - b) / chroma + (g < b ? 6 : 0);
                    break;
                case g:
                    h = (b - r) / chroma + 2;
                    break;
                case b:
                    h = (r - g) / chroma + 4;
                    break;
            }
            h *= 60;
            h = Math.round(h);
        }
        return new HSLA(h, s, l, a);
    };
    HSLA._hue2rgb = function (p, q, t) {
        if (t < 0) {
            t += 1;
        }
        if (t > 1) {
            t -= 1;
        }
        if (t < 1 / 6) {
            return p + (q - p) * 6 * t;
        }
        if (t < 1 / 2) {
            return q;
        }
        if (t < 2 / 3) {
            return p + (q - p) * (2 / 3 - t) * 6;
        }
        return p;
    };
    /**
     * Converts an HSL color value to RGB. Conversion formula
     * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
     * Assumes h in the set [0, 360] s, and l are contained in the set [0, 1] and
     * returns r, g, and b in the set [0, 255].
     */
    HSLA.toRGBA = function (hsla) {
        var h = hsla.h / 360;
        var s = hsla.s, l = hsla.l, a = hsla.a;
        var r, g, b;
        if (s === 0) {
            r = g = b = l; // achromatic
        }
        else {
            var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
            var p = 2 * l - q;
            r = HSLA._hue2rgb(p, q, h + 1 / 3);
            g = HSLA._hue2rgb(p, q, h);
            b = HSLA._hue2rgb(p, q, h - 1 / 3);
        }
        return new RGBA(Math.round(r * 255), Math.round(g * 255), Math.round(b * 255), a);
    };
    return HSLA;
}());
var HSVA = /** @class */ (function () {
    function HSVA(h, s, v, a) {
        this.h = Math.max(Math.min(360, h), 0) | 0;
        this.s = roundFloat(Math.max(Math.min(1, s), 0), 3);
        this.v = roundFloat(Math.max(Math.min(1, v), 0), 3);
        this.a = roundFloat(Math.max(Math.min(1, a), 0), 3);
    }
    HSVA.equals = function (a, b) {
        return a.h === b.h && a.s === b.s && a.v === b.v && a.a === b.a;
    };
    // from http://www.rapidtables.com/convert/color/rgb-to-hsv.htm
    HSVA.fromRGBA = function (rgba) {
        var r = rgba.r / 255;
        var g = rgba.g / 255;
        var b = rgba.b / 255;
        var cmax = Math.max(r, g, b);
        var cmin = Math.min(r, g, b);
        var delta = cmax - cmin;
        var s = cmax === 0 ? 0 : (delta / cmax);
        var m;
        if (delta === 0) {
            m = 0;
        }
        else if (cmax === r) {
            m = ((((g - b) / delta) % 6) + 6) % 6;
        }
        else if (cmax === g) {
            m = ((b - r) / delta) + 2;
        }
        else {
            m = ((r - g) / delta) + 4;
        }
        return new HSVA(Math.round(m * 60), s, cmax, rgba.a);
    };
    // from http://www.rapidtables.com/convert/color/hsv-to-rgb.htm
    HSVA.toRGBA = function (hsva) {
        var h = hsva.h, s = hsva.s, v = hsva.v, a = hsva.a;
        var c = v * s;
        var x = c * (1 - Math.abs((h / 60) % 2 - 1));
        var m = v - c;
        var _a = [0, 0, 0], r = _a[0], g = _a[1], b = _a[2];
        if (h < 60) {
            r = c;
            g = x;
        }
        else if (h < 120) {
            r = x;
            g = c;
        }
        else if (h < 180) {
            g = c;
            b = x;
        }
        else if (h < 240) {
            g = x;
            b = c;
        }
        else if (h < 300) {
            r = x;
            b = c;
        }
        else if (h < 360) {
            r = c;
            b = x;
        }
        r = Math.round((r + m) * 255);
        g = Math.round((g + m) * 255);
        b = Math.round((b + m) * 255);
        return new RGBA(r, g, b, a);
    };
    return HSVA;
}());
var Color = /** @class */ (function () {
    function Color(arg) {
        if (!arg) {
            throw new Error('Color needs a value');
        }
        else if (arg instanceof RGBA) {
            this.rgba = arg;
        }
        else if (arg instanceof HSLA) {
            this._hsla = arg;
            this.rgba = HSLA.toRGBA(arg);
        }
        else if (arg instanceof HSVA) {
            this._hsva = arg;
            this.rgba = HSVA.toRGBA(arg);
        }
        else {
            throw new Error('Invalid color ctor argument');
        }
    }
    Color.fromHex = function (hex) {
        return Color.Format.CSS.parseHex(hex) || Color.red;
    };
    Object.defineProperty(Color.prototype, "hsla", {
        get: function () {
            if (this._hsla) {
                return this._hsla;
            }
            else {
                return HSLA.fromRGBA(this.rgba);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Color.prototype, "hsva", {
        get: function () {
            if (this._hsva) {
                return this._hsva;
            }
            return HSVA.fromRGBA(this.rgba);
        },
        enumerable: true,
        configurable: true
    });
    Color.prototype.equals = function (other) {
        return !!other && RGBA.equals(this.rgba, other.rgba) && HSLA.equals(this.hsla, other.hsla) && HSVA.equals(this.hsva, other.hsva);
    };
    /**
     * http://www.w3.org/TR/WCAG20/#relativeluminancedef
     * Returns the number in the set [0, 1]. O => Darkest Black. 1 => Lightest white.
     */
    Color.prototype.getRelativeLuminance = function () {
        var R = Color._relativeLuminanceForComponent(this.rgba.r);
        var G = Color._relativeLuminanceForComponent(this.rgba.g);
        var B = Color._relativeLuminanceForComponent(this.rgba.b);
        var luminance = 0.2126 * R + 0.7152 * G + 0.0722 * B;
        return roundFloat(luminance, 4);
    };
    Color._relativeLuminanceForComponent = function (color) {
        var c = color / 255;
        return (c <= 0.03928) ? c / 12.92 : Math.pow(((c + 0.055) / 1.055), 2.4);
    };
    /**
     * http://www.w3.org/TR/WCAG20/#contrast-ratiodef
     * Returns the contrast ration number in the set [1, 21].
     */
    Color.prototype.getContrastRatio = function (another) {
        var lum1 = this.getRelativeLuminance();
        var lum2 = another.getRelativeLuminance();
        return lum1 > lum2 ? (lum1 + 0.05) / (lum2 + 0.05) : (lum2 + 0.05) / (lum1 + 0.05);
    };
    /**
     *	http://24ways.org/2010/calculating-color-contrast
     *  Return 'true' if darker color otherwise 'false'
     */
    Color.prototype.isDarker = function () {
        var yiq = (this.rgba.r * 299 + this.rgba.g * 587 + this.rgba.b * 114) / 1000;
        return yiq < 128;
    };
    /**
     *	http://24ways.org/2010/calculating-color-contrast
     *  Return 'true' if lighter color otherwise 'false'
     */
    Color.prototype.isLighter = function () {
        var yiq = (this.rgba.r * 299 + this.rgba.g * 587 + this.rgba.b * 114) / 1000;
        return yiq >= 128;
    };
    Color.prototype.isLighterThan = function (another) {
        var lum1 = this.getRelativeLuminance();
        var lum2 = another.getRelativeLuminance();
        return lum1 > lum2;
    };
    Color.prototype.isDarkerThan = function (another) {
        var lum1 = this.getRelativeLuminance();
        var lum2 = another.getRelativeLuminance();
        return lum1 < lum2;
    };
    Color.prototype.lighten = function (factor) {
        return new Color(new HSLA(this.hsla.h, this.hsla.s, this.hsla.l + this.hsla.l * factor, this.hsla.a));
    };
    Color.prototype.darken = function (factor) {
        return new Color(new HSLA(this.hsla.h, this.hsla.s, this.hsla.l - this.hsla.l * factor, this.hsla.a));
    };
    Color.prototype.transparent = function (factor) {
        var _a = this.rgba, r = _a.r, g = _a.g, b = _a.b, a = _a.a;
        return new Color(new RGBA(r, g, b, a * factor));
    };
    Color.prototype.isTransparent = function () {
        return this.rgba.a === 0;
    };
    Color.prototype.isOpaque = function () {
        return this.rgba.a === 1;
    };
    Color.prototype.opposite = function () {
        return new Color(new RGBA(255 - this.rgba.r, 255 - this.rgba.g, 255 - this.rgba.b, this.rgba.a));
    };
    Color.prototype.blend = function (c) {
        var rgba = c.rgba;
        // Convert to 0..1 opacity
        var thisA = this.rgba.a;
        var colorA = rgba.a;
        var a = thisA + colorA * (1 - thisA);
        if (a < 1.0e-6) {
            return Color.transparent;
        }
        var r = this.rgba.r * thisA / a + rgba.r * colorA * (1 - thisA) / a;
        var g = this.rgba.g * thisA / a + rgba.g * colorA * (1 - thisA) / a;
        var b = this.rgba.b * thisA / a + rgba.b * colorA * (1 - thisA) / a;
        return new Color(new RGBA(r, g, b, a));
    };
    Color.prototype.flatten = function () {
        var backgrounds = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            backgrounds[_i] = arguments[_i];
        }
        var background = backgrounds.reduceRight(function (accumulator, color) {
            return Color._flatten(color, accumulator);
        });
        return Color._flatten(this, background);
    };
    Color._flatten = function (foreground, background) {
        var backgroundAlpha = 1 - foreground.rgba.a;
        return new Color(new RGBA(backgroundAlpha * background.rgba.r + foreground.rgba.a * foreground.rgba.r, backgroundAlpha * background.rgba.g + foreground.rgba.a * foreground.rgba.g, backgroundAlpha * background.rgba.b + foreground.rgba.a * foreground.rgba.b));
    };
    Color.prototype.toString = function () {
        return Color.Format.CSS.format(this);
    };
    Color.getLighterColor = function (of, relative, factor) {
        if (of.isLighterThan(relative)) {
            return of;
        }
        factor = factor ? factor : 0.5;
        var lum1 = of.getRelativeLuminance();
        var lum2 = relative.getRelativeLuminance();
        factor = factor * (lum2 - lum1) / lum2;
        return of.lighten(factor);
    };
    Color.getDarkerColor = function (of, relative, factor) {
        if (of.isDarkerThan(relative)) {
            return of;
        }
        factor = factor ? factor : 0.5;
        var lum1 = of.getRelativeLuminance();
        var lum2 = relative.getRelativeLuminance();
        factor = factor * (lum1 - lum2) / lum1;
        return of.darken(factor);
    };
    Color.white = new Color(new RGBA(255, 255, 255, 1));
    Color.black = new Color(new RGBA(0, 0, 0, 1));
    Color.red = new Color(new RGBA(255, 0, 0, 1));
    Color.blue = new Color(new RGBA(0, 0, 255, 1));
    Color.green = new Color(new RGBA(0, 255, 0, 1));
    Color.cyan = new Color(new RGBA(0, 255, 255, 1));
    Color.lightgrey = new Color(new RGBA(211, 211, 211, 1));
    Color.transparent = new Color(new RGBA(0, 0, 0, 0));
    return Color;
}());
(function (Color) {
    var Format;
    (function (Format) {
        var CSS;
        (function (CSS) {
            function formatRGB(color) {
                if (color.rgba.a === 1) {
                    return "rgb(" + color.rgba.r + ", " + color.rgba.g + ", " + color.rgba.b + ")";
                }
                return Color.Format.CSS.formatRGBA(color);
            }
            CSS.formatRGB = formatRGB;
            function formatRGBA(color) {
                return "rgba(" + color.rgba.r + ", " + color.rgba.g + ", " + color.rgba.b + ", " + +(color.rgba.a).toFixed(2) + ")";
            }
            CSS.formatRGBA = formatRGBA;
            function formatHSL(color) {
                if (color.hsla.a === 1) {
                    return "hsl(" + color.hsla.h + ", " + (color.hsla.s * 100).toFixed(2) + "%, " + (color.hsla.l * 100).toFixed(2) + "%)";
                }
                return Color.Format.CSS.formatHSLA(color);
            }
            CSS.formatHSL = formatHSL;
            function formatHSLA(color) {
                return "hsla(" + color.hsla.h + ", " + (color.hsla.s * 100).toFixed(2) + "%, " + (color.hsla.l * 100).toFixed(2) + "%, " + color.hsla.a.toFixed(2) + ")";
            }
            CSS.formatHSLA = formatHSLA;
            function _toTwoDigitHex(n) {
                var r = n.toString(16);
                return r.length !== 2 ? '0' + r : r;
            }
            /**
             * Formats the color as #RRGGBB
             */
            function formatHex(color) {
                return "#" + _toTwoDigitHex(color.rgba.r) + _toTwoDigitHex(color.rgba.g) + _toTwoDigitHex(color.rgba.b);
            }
            CSS.formatHex = formatHex;
            /**
             * Formats the color as #RRGGBBAA
             * If 'compact' is set, colors without transparancy will be printed as #RRGGBB
             */
            function formatHexA(color, compact) {
                if (compact === void 0) { compact = false; }
                if (compact && color.rgba.a === 1) {
                    return Color.Format.CSS.formatHex(color);
                }
                return "#" + _toTwoDigitHex(color.rgba.r) + _toTwoDigitHex(color.rgba.g) + _toTwoDigitHex(color.rgba.b) + _toTwoDigitHex(Math.round(color.rgba.a * 255));
            }
            CSS.formatHexA = formatHexA;
            /**
             * The default format will use HEX if opaque and RGBA otherwise.
             */
            function format$$1(color) {
                if (!color) {
                    return null;
                }
                if (color.isOpaque()) {
                    return Color.Format.CSS.formatHex(color);
                }
                return Color.Format.CSS.formatRGBA(color);
            }
            CSS.format = format$$1;
            /**
             * Converts an Hex color value to a Color.
             * returns r, g, and b are contained in the set [0, 255]
             * @param hex string (#RGB, #RGBA, #RRGGBB or #RRGGBBAA).
             */
            function parseHex(hex) {
                if (!hex) {
                    // Invalid color
                    return null;
                }
                var length = hex.length;
                if (length === 0) {
                    // Invalid color
                    return null;
                }
                if (hex.charCodeAt(0) !== 35 /* Hash */) {
                    // Does not begin with a #
                    return null;
                }
                if (length === 7) {
                    // #RRGGBB format
                    var r = 16 * _parseHexDigit(hex.charCodeAt(1)) + _parseHexDigit(hex.charCodeAt(2));
                    var g = 16 * _parseHexDigit(hex.charCodeAt(3)) + _parseHexDigit(hex.charCodeAt(4));
                    var b = 16 * _parseHexDigit(hex.charCodeAt(5)) + _parseHexDigit(hex.charCodeAt(6));
                    return new Color(new RGBA(r, g, b, 1));
                }
                if (length === 9) {
                    // #RRGGBBAA format
                    var r = 16 * _parseHexDigit(hex.charCodeAt(1)) + _parseHexDigit(hex.charCodeAt(2));
                    var g = 16 * _parseHexDigit(hex.charCodeAt(3)) + _parseHexDigit(hex.charCodeAt(4));
                    var b = 16 * _parseHexDigit(hex.charCodeAt(5)) + _parseHexDigit(hex.charCodeAt(6));
                    var a = 16 * _parseHexDigit(hex.charCodeAt(7)) + _parseHexDigit(hex.charCodeAt(8));
                    return new Color(new RGBA(r, g, b, a / 255));
                }
                if (length === 4) {
                    // #RGB format
                    var r = _parseHexDigit(hex.charCodeAt(1));
                    var g = _parseHexDigit(hex.charCodeAt(2));
                    var b = _parseHexDigit(hex.charCodeAt(3));
                    return new Color(new RGBA(16 * r + r, 16 * g + g, 16 * b + b));
                }
                if (length === 5) {
                    // #RGBA format
                    var r = _parseHexDigit(hex.charCodeAt(1));
                    var g = _parseHexDigit(hex.charCodeAt(2));
                    var b = _parseHexDigit(hex.charCodeAt(3));
                    var a = _parseHexDigit(hex.charCodeAt(4));
                    return new Color(new RGBA(16 * r + r, 16 * g + g, 16 * b + b, (16 * a + a) / 255));
                }
                // Invalid color
                return null;
            }
            CSS.parseHex = parseHex;
            function _parseHexDigit(charCode) {
                switch (charCode) {
                    case 48 /* Digit0 */: return 0;
                    case 49 /* Digit1 */: return 1;
                    case 50 /* Digit2 */: return 2;
                    case 51 /* Digit3 */: return 3;
                    case 52 /* Digit4 */: return 4;
                    case 53 /* Digit5 */: return 5;
                    case 54 /* Digit6 */: return 6;
                    case 55 /* Digit7 */: return 7;
                    case 56 /* Digit8 */: return 8;
                    case 57 /* Digit9 */: return 9;
                    case 97 /* a */: return 10;
                    case 65 /* A */: return 10;
                    case 98 /* b */: return 11;
                    case 66 /* B */: return 11;
                    case 99 /* c */: return 12;
                    case 67 /* C */: return 12;
                    case 100 /* d */: return 13;
                    case 68 /* D */: return 13;
                    case 101 /* e */: return 14;
                    case 69 /* E */: return 14;
                    case 102 /* f */: return 15;
                    case 70 /* F */: return 15;
                }
                return 0;
            }
        })(CSS = Format.CSS || (Format.CSS = {}));
    })(Format = Color.Format || (Color.Format = {}));
})(Color || (Color = {}));

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var OutputPosition = /** @class */ (function () {
    function OutputPosition(outputLineIndex, outputOffset) {
        this.outputLineIndex = outputLineIndex;
        this.outputOffset = outputOffset;
    }
    return OutputPosition;
}());
var CoordinatesConverter = /** @class */ (function () {
    function CoordinatesConverter(lines) {
        this._lines = lines;
    }
    // View -> Model conversion and related methods
    CoordinatesConverter.prototype.convertViewPositionToModelPosition = function (viewPosition) {
        return this._lines.convertViewPositionToModelPosition(viewPosition.lineNumber, viewPosition.column);
    };
    CoordinatesConverter.prototype.convertViewRangeToModelRange = function (viewRange) {
        var start = this._lines.convertViewPositionToModelPosition(viewRange.startLineNumber, viewRange.startColumn);
        var end = this._lines.convertViewPositionToModelPosition(viewRange.endLineNumber, viewRange.endColumn);
        return new Range(start.lineNumber, start.column, end.lineNumber, end.column);
    };
    CoordinatesConverter.prototype.validateViewPosition = function (viewPosition, expectedModelPosition) {
        return this._lines.validateViewPosition(viewPosition.lineNumber, viewPosition.column, expectedModelPosition);
    };
    CoordinatesConverter.prototype.validateViewRange = function (viewRange, expectedModelRange) {
        var validViewStart = this._lines.validateViewPosition(viewRange.startLineNumber, viewRange.startColumn, expectedModelRange.getStartPosition());
        var validViewEnd = this._lines.validateViewPosition(viewRange.endLineNumber, viewRange.endColumn, expectedModelRange.getEndPosition());
        return new Range(validViewStart.lineNumber, validViewStart.column, validViewEnd.lineNumber, validViewEnd.column);
    };
    // Model -> View conversion and related methods
    CoordinatesConverter.prototype.convertModelPositionToViewPosition = function (modelPosition) {
        return this._lines.convertModelPositionToViewPosition(modelPosition.lineNumber, modelPosition.column);
    };
    CoordinatesConverter.prototype.convertModelRangeToViewRange = function (modelRange) {
        var start = this._lines.convertModelPositionToViewPosition(modelRange.startLineNumber, modelRange.startColumn);
        var end = this._lines.convertModelPositionToViewPosition(modelRange.endLineNumber, modelRange.endColumn);
        return new Range(start.lineNumber, start.column, end.lineNumber, end.column);
    };
    CoordinatesConverter.prototype.modelPositionIsVisible = function (modelPosition) {
        return this._lines.modelPositionIsVisible(modelPosition.lineNumber, modelPosition.column);
    };
    return CoordinatesConverter;
}());
var SplitLinesCollection = /** @class */ (function () {
    function SplitLinesCollection(model, linePositionMapperFactory, tabSize, wrappingColumn, columnsForFullWidthChar, wrappingIndent) {
        this.model = model;
        this._validModelVersionId = -1;
        this.tabSize = tabSize;
        this.wrappingColumn = wrappingColumn;
        this.columnsForFullWidthChar = columnsForFullWidthChar;
        this.wrappingIndent = wrappingIndent;
        this.linePositionMapperFactory = linePositionMapperFactory;
        this._constructLines(true);
    }
    SplitLinesCollection.prototype.dispose = function () {
        this.hiddenAreasIds = this.model.deltaDecorations(this.hiddenAreasIds, []);
    };
    SplitLinesCollection.prototype.createCoordinatesConverter = function () {
        return new CoordinatesConverter(this);
    };
    SplitLinesCollection.prototype._ensureValidState = function () {
        var modelVersion = this.model.getVersionId();
        if (modelVersion !== this._validModelVersionId) {
            // This is pretty bad, it means we lost track of the model...
            throw new Error("ViewModel is out of sync with Model!");
        }
    };
    SplitLinesCollection.prototype._constructLines = function (resetHiddenAreas) {
        var _this = this;
        this.lines = [];
        if (resetHiddenAreas) {
            this.hiddenAreasIds = [];
        }
        var linesContent = this.model.getLinesContent();
        var lineCount = linesContent.length;
        var values = new Uint32Array(lineCount);
        var hiddenAreas = this.hiddenAreasIds.map(function (areaId) { return _this.model.getDecorationRange(areaId); }).sort(Range.compareRangesUsingStarts);
        var hiddenAreaStart = 1, hiddenAreaEnd = 0;
        var hiddenAreaIdx = -1;
        var nextLineNumberToUpdateHiddenArea = (hiddenAreaIdx + 1 < hiddenAreas.length) ? hiddenAreaEnd + 1 : lineCount + 2;
        for (var i = 0; i < lineCount; i++) {
            var lineNumber = i + 1;
            if (lineNumber === nextLineNumberToUpdateHiddenArea) {
                hiddenAreaIdx++;
                hiddenAreaStart = hiddenAreas[hiddenAreaIdx].startLineNumber;
                hiddenAreaEnd = hiddenAreas[hiddenAreaIdx].endLineNumber;
                nextLineNumberToUpdateHiddenArea = (hiddenAreaIdx + 1 < hiddenAreas.length) ? hiddenAreaEnd + 1 : lineCount + 2;
            }
            var isInHiddenArea = (lineNumber >= hiddenAreaStart && lineNumber <= hiddenAreaEnd);
            var line = createSplitLine(this.linePositionMapperFactory, linesContent[i], this.tabSize, this.wrappingColumn, this.columnsForFullWidthChar, this.wrappingIndent, !isInHiddenArea);
            values[i] = line.getViewLineCount();
            this.lines[i] = line;
        }
        this._validModelVersionId = this.model.getVersionId();
        this.prefixSumComputer = new PrefixSumComputerWithCache(values);
    };
    SplitLinesCollection.prototype.getHiddenAreas = function () {
        var _this = this;
        return this.hiddenAreasIds.map(function (decId) {
            return _this.model.getDecorationRange(decId);
        });
    };
    SplitLinesCollection.prototype._reduceRanges = function (_ranges) {
        var _this = this;
        if (_ranges.length === 0) {
            return [];
        }
        var ranges = _ranges.map(function (r) { return _this.model.validateRange(r); }).sort(Range.compareRangesUsingStarts);
        var result = [];
        var currentRangeStart = ranges[0].startLineNumber;
        var currentRangeEnd = ranges[0].endLineNumber;
        for (var i = 1, len = ranges.length; i < len; i++) {
            var range = ranges[i];
            if (range.startLineNumber > currentRangeEnd + 1) {
                result.push(new Range(currentRangeStart, 1, currentRangeEnd, 1));
                currentRangeStart = range.startLineNumber;
                currentRangeEnd = range.endLineNumber;
            }
            else if (range.endLineNumber > currentRangeEnd) {
                currentRangeEnd = range.endLineNumber;
            }
        }
        result.push(new Range(currentRangeStart, 1, currentRangeEnd, 1));
        return result;
    };
    SplitLinesCollection.prototype.setHiddenAreas = function (_ranges) {
        var _this = this;
        var newRanges = this._reduceRanges(_ranges);
        // BEGIN TODO@Martin: Please stop calling this method on each model change!
        var oldRanges = this.hiddenAreasIds.map(function (areaId) { return _this.model.getDecorationRange(areaId); }).sort(Range.compareRangesUsingStarts);
        if (newRanges.length === oldRanges.length) {
            var hasDifference = false;
            for (var i = 0; i < newRanges.length; i++) {
                if (!newRanges[i].equalsRange(oldRanges[i])) {
                    hasDifference = true;
                    break;
                }
            }
            if (!hasDifference) {
                return false;
            }
        }
        // END TODO@Martin: Please stop calling this method on each model change!
        var newDecorations = [];
        for (var i = 0; i < newRanges.length; i++) {
            newDecorations.push({
                range: newRanges[i],
                options: ModelDecorationOptions.EMPTY
            });
        }
        this.hiddenAreasIds = this.model.deltaDecorations(this.hiddenAreasIds, newDecorations);
        var hiddenAreas = newRanges;
        var hiddenAreaStart = 1, hiddenAreaEnd = 0;
        var hiddenAreaIdx = -1;
        var nextLineNumberToUpdateHiddenArea = (hiddenAreaIdx + 1 < hiddenAreas.length) ? hiddenAreaEnd + 1 : this.lines.length + 2;
        var hasVisibleLine = false;
        for (var i = 0; i < this.lines.length; i++) {
            var lineNumber = i + 1;
            if (lineNumber === nextLineNumberToUpdateHiddenArea) {
                hiddenAreaIdx++;
                hiddenAreaStart = hiddenAreas[hiddenAreaIdx].startLineNumber;
                hiddenAreaEnd = hiddenAreas[hiddenAreaIdx].endLineNumber;
                nextLineNumberToUpdateHiddenArea = (hiddenAreaIdx + 1 < hiddenAreas.length) ? hiddenAreaEnd + 1 : this.lines.length + 2;
            }
            var lineChanged = false;
            if (lineNumber >= hiddenAreaStart && lineNumber <= hiddenAreaEnd) {
                // Line should be hidden
                if (this.lines[i].isVisible()) {
                    this.lines[i] = this.lines[i].setVisible(false);
                    lineChanged = true;
                }
            }
            else {
                hasVisibleLine = true;
                // Line should be visible
                if (!this.lines[i].isVisible()) {
                    this.lines[i] = this.lines[i].setVisible(true);
                    lineChanged = true;
                }
            }
            if (lineChanged) {
                var newOutputLineCount = this.lines[i].getViewLineCount();
                this.prefixSumComputer.changeValue(i, newOutputLineCount);
            }
        }
        if (!hasVisibleLine) {
            // Cannot have everything be hidden => reveal everything!
            this.setHiddenAreas([]);
        }
        return true;
    };
    SplitLinesCollection.prototype.modelPositionIsVisible = function (modelLineNumber, modelColumn) {
        if (modelLineNumber < 1 || modelLineNumber > this.lines.length) {
            // invalid arguments
            return false;
        }
        return this.lines[modelLineNumber - 1].isVisible();
    };
    SplitLinesCollection.prototype.setTabSize = function (newTabSize) {
        if (this.tabSize === newTabSize) {
            return false;
        }
        this.tabSize = newTabSize;
        this._constructLines(false);
        return true;
    };
    SplitLinesCollection.prototype.setWrappingSettings = function (wrappingIndent, wrappingColumn, columnsForFullWidthChar) {
        if (this.wrappingIndent === wrappingIndent && this.wrappingColumn === wrappingColumn && this.columnsForFullWidthChar === columnsForFullWidthChar) {
            return false;
        }
        this.wrappingIndent = wrappingIndent;
        this.wrappingColumn = wrappingColumn;
        this.columnsForFullWidthChar = columnsForFullWidthChar;
        this._constructLines(false);
        return true;
    };
    SplitLinesCollection.prototype.onModelFlushed = function () {
        this._constructLines(true);
    };
    SplitLinesCollection.prototype.onModelLinesDeleted = function (versionId, fromLineNumber, toLineNumber) {
        if (versionId <= this._validModelVersionId) {
            // Here we check for versionId in case the lines were reconstructed in the meantime.
            // We don't want to apply stale change events on top of a newer read model state.
            return null;
        }
        var outputFromLineNumber = (fromLineNumber === 1 ? 1 : this.prefixSumComputer.getAccumulatedValue(fromLineNumber - 2) + 1);
        var outputToLineNumber = this.prefixSumComputer.getAccumulatedValue(toLineNumber - 1);
        this.lines.splice(fromLineNumber - 1, toLineNumber - fromLineNumber + 1);
        this.prefixSumComputer.removeValues(fromLineNumber - 1, toLineNumber - fromLineNumber + 1);
        return new ViewLinesDeletedEvent(outputFromLineNumber, outputToLineNumber);
    };
    SplitLinesCollection.prototype.onModelLinesInserted = function (versionId, fromLineNumber, toLineNumber, text) {
        if (versionId <= this._validModelVersionId) {
            // Here we check for versionId in case the lines were reconstructed in the meantime.
            // We don't want to apply stale change events on top of a newer read model state.
            return null;
        }
        var hiddenAreas = this.getHiddenAreas();
        var isInHiddenArea = false;
        var testPosition = new Position(fromLineNumber, 1);
        for (var i = 0; i < hiddenAreas.length; i++) {
            if (hiddenAreas[i].containsPosition(testPosition)) {
                isInHiddenArea = true;
                break;
            }
        }
        var outputFromLineNumber = (fromLineNumber === 1 ? 1 : this.prefixSumComputer.getAccumulatedValue(fromLineNumber - 2) + 1);
        var totalOutputLineCount = 0;
        var insertLines = [];
        var insertPrefixSumValues = new Uint32Array(text.length);
        for (var i = 0, len = text.length; i < len; i++) {
            var line = createSplitLine(this.linePositionMapperFactory, text[i], this.tabSize, this.wrappingColumn, this.columnsForFullWidthChar, this.wrappingIndent, !isInHiddenArea);
            insertLines.push(line);
            var outputLineCount = line.getViewLineCount();
            totalOutputLineCount += outputLineCount;
            insertPrefixSumValues[i] = outputLineCount;
        }
        // TODO@Alex: use arrays.arrayInsert
        this.lines = this.lines.slice(0, fromLineNumber - 1).concat(insertLines).concat(this.lines.slice(fromLineNumber - 1));
        this.prefixSumComputer.insertValues(fromLineNumber - 1, insertPrefixSumValues);
        return new ViewLinesInsertedEvent(outputFromLineNumber, outputFromLineNumber + totalOutputLineCount - 1);
    };
    SplitLinesCollection.prototype.onModelLineChanged = function (versionId, lineNumber, newText) {
        if (versionId <= this._validModelVersionId) {
            // Here we check for versionId in case the lines were reconstructed in the meantime.
            // We don't want to apply stale change events on top of a newer read model state.
            return [false, null, null, null];
        }
        var lineIndex = lineNumber - 1;
        var oldOutputLineCount = this.lines[lineIndex].getViewLineCount();
        var isVisible = this.lines[lineIndex].isVisible();
        var line = createSplitLine(this.linePositionMapperFactory, newText, this.tabSize, this.wrappingColumn, this.columnsForFullWidthChar, this.wrappingIndent, isVisible);
        this.lines[lineIndex] = line;
        var newOutputLineCount = this.lines[lineIndex].getViewLineCount();
        var lineMappingChanged = false;
        var changeFrom = 0;
        var changeTo = -1;
        var insertFrom = 0;
        var insertTo = -1;
        var deleteFrom = 0;
        var deleteTo = -1;
        if (oldOutputLineCount > newOutputLineCount) {
            changeFrom = (lineNumber === 1 ? 1 : this.prefixSumComputer.getAccumulatedValue(lineNumber - 2) + 1);
            changeTo = changeFrom + newOutputLineCount - 1;
            deleteFrom = changeTo + 1;
            deleteTo = deleteFrom + (oldOutputLineCount - newOutputLineCount) - 1;
            lineMappingChanged = true;
        }
        else if (oldOutputLineCount < newOutputLineCount) {
            changeFrom = (lineNumber === 1 ? 1 : this.prefixSumComputer.getAccumulatedValue(lineNumber - 2) + 1);
            changeTo = changeFrom + oldOutputLineCount - 1;
            insertFrom = changeTo + 1;
            insertTo = insertFrom + (newOutputLineCount - oldOutputLineCount) - 1;
            lineMappingChanged = true;
        }
        else {
            changeFrom = (lineNumber === 1 ? 1 : this.prefixSumComputer.getAccumulatedValue(lineNumber - 2) + 1);
            changeTo = changeFrom + newOutputLineCount - 1;
        }
        this.prefixSumComputer.changeValue(lineIndex, newOutputLineCount);
        var viewLinesChangedEvent = (changeFrom <= changeTo ? new ViewLinesChangedEvent(changeFrom, changeTo) : null);
        var viewLinesInsertedEvent = (insertFrom <= insertTo ? new ViewLinesInsertedEvent(insertFrom, insertTo) : null);
        var viewLinesDeletedEvent = (deleteFrom <= deleteTo ? new ViewLinesDeletedEvent(deleteFrom, deleteTo) : null);
        return [lineMappingChanged, viewLinesChangedEvent, viewLinesInsertedEvent, viewLinesDeletedEvent];
    };
    SplitLinesCollection.prototype.acceptVersionId = function (versionId) {
        this._validModelVersionId = versionId;
        if (this.lines.length === 1 && !this.lines[0].isVisible()) {
            // At least one line must be visible => reset hidden areas
            this.setHiddenAreas([]);
        }
    };
    SplitLinesCollection.prototype.getViewLineCount = function () {
        this._ensureValidState();
        return this.prefixSumComputer.getTotalValue();
    };
    SplitLinesCollection.prototype._toValidViewLineNumber = function (viewLineNumber) {
        if (viewLineNumber < 1) {
            return 1;
        }
        var viewLineCount = this.getViewLineCount();
        if (viewLineNumber > viewLineCount) {
            return viewLineCount;
        }
        return viewLineNumber;
    };
    /**
     * Gives a hint that a lot of requests are about to come in for these line numbers.
     */
    SplitLinesCollection.prototype.warmUpLookupCache = function (viewStartLineNumber, viewEndLineNumber) {
        this.prefixSumComputer.warmUpCache(viewStartLineNumber - 1, viewEndLineNumber - 1);
    };
    SplitLinesCollection.prototype.getActiveIndentGuide = function (viewLineNumber, minLineNumber, maxLineNumber) {
        this._ensureValidState();
        viewLineNumber = this._toValidViewLineNumber(viewLineNumber);
        minLineNumber = this._toValidViewLineNumber(minLineNumber);
        maxLineNumber = this._toValidViewLineNumber(maxLineNumber);
        var modelPosition = this.convertViewPositionToModelPosition(viewLineNumber, this.getViewLineMinColumn(viewLineNumber));
        var modelMinPosition = this.convertViewPositionToModelPosition(minLineNumber, this.getViewLineMinColumn(minLineNumber));
        var modelMaxPosition = this.convertViewPositionToModelPosition(maxLineNumber, this.getViewLineMinColumn(maxLineNumber));
        var result = this.model.getActiveIndentGuide(modelPosition.lineNumber, modelMinPosition.lineNumber, modelMaxPosition.lineNumber);
        var viewStartPosition = this.convertModelPositionToViewPosition(result.startLineNumber, 1);
        var viewEndPosition = this.convertModelPositionToViewPosition(result.endLineNumber, 1);
        return {
            startLineNumber: viewStartPosition.lineNumber,
            endLineNumber: viewEndPosition.lineNumber,
            indent: result.indent
        };
    };
    SplitLinesCollection.prototype.getViewLinesIndentGuides = function (viewStartLineNumber, viewEndLineNumber) {
        this._ensureValidState();
        viewStartLineNumber = this._toValidViewLineNumber(viewStartLineNumber);
        viewEndLineNumber = this._toValidViewLineNumber(viewEndLineNumber);
        var modelStart = this.convertViewPositionToModelPosition(viewStartLineNumber, this.getViewLineMinColumn(viewStartLineNumber));
        var modelEnd = this.convertViewPositionToModelPosition(viewEndLineNumber, this.getViewLineMaxColumn(viewEndLineNumber));
        var result = [];
        var resultRepeatCount = [];
        var modelStartLineIndex = modelStart.lineNumber - 1;
        var modelEndLineIndex = modelEnd.lineNumber - 1;
        var reqStart = null;
        for (var modelLineIndex = modelStartLineIndex; modelLineIndex <= modelEndLineIndex; modelLineIndex++) {
            var line = this.lines[modelLineIndex];
            if (line.isVisible()) {
                var count = 0;
                if (modelLineIndex === modelStartLineIndex) {
                    var viewLineStartIndex = line.getViewLineNumberOfModelPosition(0, modelStart.column);
                    var viewLineEndIndex = line.getViewLineNumberOfModelPosition(0, this.model.getLineMaxColumn(modelLineIndex + 1));
                    count = viewLineEndIndex - viewLineStartIndex + 1;
                }
                else {
                    var viewLineStartIndex = line.getViewLineNumberOfModelPosition(0, 1);
                    var viewLineEndIndex = line.getViewLineNumberOfModelPosition(0, this.model.getLineMaxColumn(modelLineIndex + 1));
                    count = viewLineEndIndex - viewLineStartIndex + 1;
                }
                resultRepeatCount.push(count);
                // merge into previous request
                if (reqStart === null) {
                    reqStart = new Position(modelLineIndex + 1, 0);
                }
            }
            else {
                // hit invisible line => flush request
                if (reqStart !== null) {
                    result = result.concat(this.model.getLinesIndentGuides(reqStart.lineNumber, modelLineIndex));
                    reqStart = null;
                }
            }
        }
        if (reqStart !== null) {
            result = result.concat(this.model.getLinesIndentGuides(reqStart.lineNumber, modelEnd.lineNumber));
            reqStart = null;
        }
        var viewLineCount = viewEndLineNumber - viewStartLineNumber + 1;
        var viewIndents = new Array(viewLineCount);
        var currIndex = 0;
        for (var i = 0, len = result.length; i < len; i++) {
            var value = result[i];
            var count = Math.min(viewLineCount - currIndex, resultRepeatCount[i]);
            for (var j = 0; j < count; j++) {
                viewIndents[currIndex++] = value;
            }
        }
        return viewIndents;
    };
    SplitLinesCollection.prototype.getViewLineContent = function (viewLineNumber) {
        this._ensureValidState();
        viewLineNumber = this._toValidViewLineNumber(viewLineNumber);
        var r = this.prefixSumComputer.getIndexOf(viewLineNumber - 1);
        var lineIndex = r.index;
        var remainder = r.remainder;
        return this.lines[lineIndex].getViewLineContent(this.model, lineIndex + 1, remainder);
    };
    SplitLinesCollection.prototype.getViewLineLength = function (viewLineNumber) {
        this._ensureValidState();
        viewLineNumber = this._toValidViewLineNumber(viewLineNumber);
        var r = this.prefixSumComputer.getIndexOf(viewLineNumber - 1);
        var lineIndex = r.index;
        var remainder = r.remainder;
        return this.lines[lineIndex].getViewLineLength(this.model, lineIndex + 1, remainder);
    };
    SplitLinesCollection.prototype.getViewLineMinColumn = function (viewLineNumber) {
        this._ensureValidState();
        viewLineNumber = this._toValidViewLineNumber(viewLineNumber);
        var r = this.prefixSumComputer.getIndexOf(viewLineNumber - 1);
        var lineIndex = r.index;
        var remainder = r.remainder;
        return this.lines[lineIndex].getViewLineMinColumn(this.model, lineIndex + 1, remainder);
    };
    SplitLinesCollection.prototype.getViewLineMaxColumn = function (viewLineNumber) {
        this._ensureValidState();
        viewLineNumber = this._toValidViewLineNumber(viewLineNumber);
        var r = this.prefixSumComputer.getIndexOf(viewLineNumber - 1);
        var lineIndex = r.index;
        var remainder = r.remainder;
        return this.lines[lineIndex].getViewLineMaxColumn(this.model, lineIndex + 1, remainder);
    };
    SplitLinesCollection.prototype.getViewLineData = function (viewLineNumber) {
        this._ensureValidState();
        viewLineNumber = this._toValidViewLineNumber(viewLineNumber);
        var r = this.prefixSumComputer.getIndexOf(viewLineNumber - 1);
        var lineIndex = r.index;
        var remainder = r.remainder;
        return this.lines[lineIndex].getViewLineData(this.model, lineIndex + 1, remainder);
    };
    SplitLinesCollection.prototype.getViewLinesData = function (viewStartLineNumber, viewEndLineNumber, needed) {
        this._ensureValidState();
        viewStartLineNumber = this._toValidViewLineNumber(viewStartLineNumber);
        viewEndLineNumber = this._toValidViewLineNumber(viewEndLineNumber);
        var start = this.prefixSumComputer.getIndexOf(viewStartLineNumber - 1);
        var viewLineNumber = viewStartLineNumber;
        var startModelLineIndex = start.index;
        var startRemainder = start.remainder;
        var result = [];
        for (var modelLineIndex = startModelLineIndex, len = this.model.getLineCount(); modelLineIndex < len; modelLineIndex++) {
            var line = this.lines[modelLineIndex];
            if (!line.isVisible()) {
                continue;
            }
            var fromViewLineIndex = (modelLineIndex === startModelLineIndex ? startRemainder : 0);
            var remainingViewLineCount = line.getViewLineCount() - fromViewLineIndex;
            var lastLine = false;
            if (viewLineNumber + remainingViewLineCount > viewEndLineNumber) {
                lastLine = true;
                remainingViewLineCount = viewEndLineNumber - viewLineNumber + 1;
            }
            var toViewLineIndex = fromViewLineIndex + remainingViewLineCount;
            line.getViewLinesData(this.model, modelLineIndex + 1, fromViewLineIndex, toViewLineIndex, viewLineNumber - viewStartLineNumber, needed, result);
            viewLineNumber += remainingViewLineCount;
            if (lastLine) {
                break;
            }
        }
        return result;
    };
    SplitLinesCollection.prototype.validateViewPosition = function (viewLineNumber, viewColumn, expectedModelPosition) {
        this._ensureValidState();
        viewLineNumber = this._toValidViewLineNumber(viewLineNumber);
        var r = this.prefixSumComputer.getIndexOf(viewLineNumber - 1);
        var lineIndex = r.index;
        var remainder = r.remainder;
        var line = this.lines[lineIndex];
        var minColumn = line.getViewLineMinColumn(this.model, lineIndex + 1, remainder);
        var maxColumn = line.getViewLineMaxColumn(this.model, lineIndex + 1, remainder);
        if (viewColumn < minColumn) {
            viewColumn = minColumn;
        }
        if (viewColumn > maxColumn) {
            viewColumn = maxColumn;
        }
        var computedModelColumn = line.getModelColumnOfViewPosition(remainder, viewColumn);
        var computedModelPosition = this.model.validatePosition(new Position(lineIndex + 1, computedModelColumn));
        if (computedModelPosition.equals(expectedModelPosition)) {
            return new Position(viewLineNumber, viewColumn);
        }
        return this.convertModelPositionToViewPosition(expectedModelPosition.lineNumber, expectedModelPosition.column);
    };
    SplitLinesCollection.prototype.convertViewPositionToModelPosition = function (viewLineNumber, viewColumn) {
        this._ensureValidState();
        viewLineNumber = this._toValidViewLineNumber(viewLineNumber);
        var r = this.prefixSumComputer.getIndexOf(viewLineNumber - 1);
        var lineIndex = r.index;
        var remainder = r.remainder;
        var inputColumn = this.lines[lineIndex].getModelColumnOfViewPosition(remainder, viewColumn);
        // console.log('out -> in ' + viewLineNumber + ',' + viewColumn + ' ===> ' + (lineIndex+1) + ',' + inputColumn);
        return this.model.validatePosition(new Position(lineIndex + 1, inputColumn));
    };
    SplitLinesCollection.prototype.convertModelPositionToViewPosition = function (_modelLineNumber, _modelColumn) {
        this._ensureValidState();
        var validPosition = this.model.validatePosition(new Position(_modelLineNumber, _modelColumn));
        var inputLineNumber = validPosition.lineNumber;
        var inputColumn = validPosition.column;
        var lineIndex = inputLineNumber - 1, lineIndexChanged = false;
        while (lineIndex > 0 && !this.lines[lineIndex].isVisible()) {
            lineIndex--;
            lineIndexChanged = true;
        }
        if (lineIndex === 0 && !this.lines[lineIndex].isVisible()) {
            // Could not reach a real line
            // console.log('in -> out ' + inputLineNumber + ',' + inputColumn + ' ===> ' + 1 + ',' + 1);
            return new Position(1, 1);
        }
        var deltaLineNumber = 1 + (lineIndex === 0 ? 0 : this.prefixSumComputer.getAccumulatedValue(lineIndex - 1));
        var r;
        if (lineIndexChanged) {
            r = this.lines[lineIndex].getViewPositionOfModelPosition(deltaLineNumber, this.model.getLineMaxColumn(lineIndex + 1));
        }
        else {
            r = this.lines[inputLineNumber - 1].getViewPositionOfModelPosition(deltaLineNumber, inputColumn);
        }
        // console.log('in -> out ' + inputLineNumber + ',' + inputColumn + ' ===> ' + r.lineNumber + ',' + r);
        return r;
    };
    SplitLinesCollection.prototype._getViewLineNumberForModelPosition = function (inputLineNumber, inputColumn) {
        var lineIndex = inputLineNumber - 1;
        if (this.lines[lineIndex].isVisible()) {
            // this model line is visible
            var deltaLineNumber_1 = 1 + (lineIndex === 0 ? 0 : this.prefixSumComputer.getAccumulatedValue(lineIndex - 1));
            return this.lines[lineIndex].getViewLineNumberOfModelPosition(deltaLineNumber_1, inputColumn);
        }
        // this model line is not visible
        while (lineIndex > 0 && !this.lines[lineIndex].isVisible()) {
            lineIndex--;
        }
        if (lineIndex === 0 && !this.lines[lineIndex].isVisible()) {
            // Could not reach a real line
            return 1;
        }
        var deltaLineNumber = 1 + (lineIndex === 0 ? 0 : this.prefixSumComputer.getAccumulatedValue(lineIndex - 1));
        return this.lines[lineIndex].getViewLineNumberOfModelPosition(deltaLineNumber, this.model.getLineMaxColumn(lineIndex + 1));
    };
    SplitLinesCollection.prototype.getAllOverviewRulerDecorations = function (ownerId, filterOutValidation, theme) {
        var decorations = this.model.getOverviewRulerDecorations(ownerId, filterOutValidation);
        var result = new OverviewRulerDecorations();
        for (var i = 0, len = decorations.length; i < len; i++) {
            var decoration = decorations[i];
            var opts = decoration.options.overviewRuler;
            var lane = opts.position;
            if (lane === 0) {
                continue;
            }
            var color = resolveColor(opts, theme);
            var viewStartLineNumber = this._getViewLineNumberForModelPosition(decoration.range.startLineNumber, decoration.range.startColumn);
            var viewEndLineNumber = this._getViewLineNumberForModelPosition(decoration.range.endLineNumber, decoration.range.endColumn);
            result.accept(color, viewStartLineNumber, viewEndLineNumber, lane);
        }
        return result.result;
    };
    SplitLinesCollection.prototype.getDecorationsInRange = function (range, ownerId, filterOutValidation) {
        var modelStart = this.convertViewPositionToModelPosition(range.startLineNumber, range.startColumn);
        var modelEnd = this.convertViewPositionToModelPosition(range.endLineNumber, range.endColumn);
        if (modelEnd.lineNumber - modelStart.lineNumber <= range.endLineNumber - range.startLineNumber) {
            // most likely there are no hidden lines => fast path
            return this.model.getDecorationsInRange(new Range(modelStart.lineNumber, modelStart.column, modelEnd.lineNumber, modelEnd.column), ownerId, filterOutValidation);
        }
        var result = [];
        var modelStartLineIndex = modelStart.lineNumber - 1;
        var modelEndLineIndex = modelEnd.lineNumber - 1;
        var reqStart = null;
        for (var modelLineIndex = modelStartLineIndex; modelLineIndex <= modelEndLineIndex; modelLineIndex++) {
            var line = this.lines[modelLineIndex];
            if (line.isVisible()) {
                // merge into previous request
                if (reqStart === null) {
                    reqStart = new Position(modelLineIndex + 1, modelLineIndex === modelStartLineIndex ? modelStart.column : 1);
                }
            }
            else {
                // hit invisible line => flush request
                if (reqStart !== null) {
                    var maxLineColumn = this.model.getLineMaxColumn(modelLineIndex);
                    result = result.concat(this.model.getDecorationsInRange(new Range(reqStart.lineNumber, reqStart.column, modelLineIndex, maxLineColumn), ownerId, filterOutValidation));
                    reqStart = null;
                }
            }
        }
        if (reqStart !== null) {
            result = result.concat(this.model.getDecorationsInRange(new Range(reqStart.lineNumber, reqStart.column, modelEnd.lineNumber, modelEnd.column), ownerId, filterOutValidation));
            reqStart = null;
        }
        return result;
    };
    return SplitLinesCollection;
}());
var VisibleIdentitySplitLine = /** @class */ (function () {
    function VisibleIdentitySplitLine() {
    }
    VisibleIdentitySplitLine.prototype.isVisible = function () {
        return true;
    };
    VisibleIdentitySplitLine.prototype.setVisible = function (isVisible) {
        if (isVisible) {
            return this;
        }
        return InvisibleIdentitySplitLine.INSTANCE;
    };
    VisibleIdentitySplitLine.prototype.getViewLineCount = function () {
        return 1;
    };
    VisibleIdentitySplitLine.prototype.getViewLineContent = function (model, modelLineNumber, outputLineIndex) {
        return model.getLineContent(modelLineNumber);
    };
    VisibleIdentitySplitLine.prototype.getViewLineLength = function (model, modelLineNumber, outputLineIndex) {
        return model.getLineLength(modelLineNumber);
    };
    VisibleIdentitySplitLine.prototype.getViewLineMinColumn = function (model, modelLineNumber, outputLineIndex) {
        return model.getLineMinColumn(modelLineNumber);
    };
    VisibleIdentitySplitLine.prototype.getViewLineMaxColumn = function (model, modelLineNumber, outputLineIndex) {
        return model.getLineMaxColumn(modelLineNumber);
    };
    VisibleIdentitySplitLine.prototype.getViewLineData = function (model, modelLineNumber, outputLineIndex) {
        var lineTokens = model.getLineTokens(modelLineNumber);
        var lineContent = lineTokens.getLineContent();
        return new ViewLineData(lineContent, 1, lineContent.length + 1, lineTokens.inflate());
    };
    VisibleIdentitySplitLine.prototype.getViewLinesData = function (model, modelLineNumber, fromOuputLineIndex, toOutputLineIndex, globalStartIndex, needed, result) {
        if (!needed[globalStartIndex]) {
            result[globalStartIndex] = null;
            return;
        }
        result[globalStartIndex] = this.getViewLineData(model, modelLineNumber, 0);
    };
    VisibleIdentitySplitLine.prototype.getModelColumnOfViewPosition = function (outputLineIndex, outputColumn) {
        return outputColumn;
    };
    VisibleIdentitySplitLine.prototype.getViewPositionOfModelPosition = function (deltaLineNumber, inputColumn) {
        return new Position(deltaLineNumber, inputColumn);
    };
    VisibleIdentitySplitLine.prototype.getViewLineNumberOfModelPosition = function (deltaLineNumber, inputColumn) {
        return deltaLineNumber;
    };
    VisibleIdentitySplitLine.INSTANCE = new VisibleIdentitySplitLine();
    return VisibleIdentitySplitLine;
}());
var InvisibleIdentitySplitLine = /** @class */ (function () {
    function InvisibleIdentitySplitLine() {
    }
    InvisibleIdentitySplitLine.prototype.isVisible = function () {
        return false;
    };
    InvisibleIdentitySplitLine.prototype.setVisible = function (isVisible) {
        if (!isVisible) {
            return this;
        }
        return VisibleIdentitySplitLine.INSTANCE;
    };
    InvisibleIdentitySplitLine.prototype.getViewLineCount = function () {
        return 0;
    };
    InvisibleIdentitySplitLine.prototype.getViewLineContent = function (model, modelLineNumber, outputLineIndex) {
        throw new Error('Not supported');
    };
    InvisibleIdentitySplitLine.prototype.getViewLineLength = function (model, modelLineNumber, outputLineIndex) {
        throw new Error('Not supported');
    };
    InvisibleIdentitySplitLine.prototype.getViewLineMinColumn = function (model, modelLineNumber, outputLineIndex) {
        throw new Error('Not supported');
    };
    InvisibleIdentitySplitLine.prototype.getViewLineMaxColumn = function (model, modelLineNumber, outputLineIndex) {
        throw new Error('Not supported');
    };
    InvisibleIdentitySplitLine.prototype.getViewLineData = function (model, modelLineNumber, outputLineIndex) {
        throw new Error('Not supported');
    };
    InvisibleIdentitySplitLine.prototype.getViewLinesData = function (model, modelLineNumber, fromOuputLineIndex, toOutputLineIndex, globalStartIndex, needed, result) {
        throw new Error('Not supported');
    };
    InvisibleIdentitySplitLine.prototype.getModelColumnOfViewPosition = function (outputLineIndex, outputColumn) {
        throw new Error('Not supported');
    };
    InvisibleIdentitySplitLine.prototype.getViewPositionOfModelPosition = function (deltaLineNumber, inputColumn) {
        throw new Error('Not supported');
    };
    InvisibleIdentitySplitLine.prototype.getViewLineNumberOfModelPosition = function (deltaLineNumber, inputColumn) {
        throw new Error('Not supported');
    };
    InvisibleIdentitySplitLine.INSTANCE = new InvisibleIdentitySplitLine();
    return InvisibleIdentitySplitLine;
}());
var SplitLine = /** @class */ (function () {
    function SplitLine(positionMapper, isVisible) {
        this.positionMapper = positionMapper;
        this.wrappedIndent = this.positionMapper.getWrappedLinesIndent();
        this.wrappedIndentLength = this.wrappedIndent.length;
        this.outputLineCount = this.positionMapper.getOutputLineCount();
        this._isVisible = isVisible;
    }
    SplitLine.prototype.isVisible = function () {
        return this._isVisible;
    };
    SplitLine.prototype.setVisible = function (isVisible) {
        this._isVisible = isVisible;
        return this;
    };
    SplitLine.prototype.getViewLineCount = function () {
        if (!this._isVisible) {
            return 0;
        }
        return this.outputLineCount;
    };
    SplitLine.prototype.getInputStartOffsetOfOutputLineIndex = function (outputLineIndex) {
        return this.positionMapper.getInputOffsetOfOutputPosition(outputLineIndex, 0);
    };
    SplitLine.prototype.getInputEndOffsetOfOutputLineIndex = function (model, modelLineNumber, outputLineIndex) {
        if (outputLineIndex + 1 === this.outputLineCount) {
            return model.getLineMaxColumn(modelLineNumber) - 1;
        }
        return this.positionMapper.getInputOffsetOfOutputPosition(outputLineIndex + 1, 0);
    };
    SplitLine.prototype.getViewLineContent = function (model, modelLineNumber, outputLineIndex) {
        if (!this._isVisible) {
            throw new Error('Not supported');
        }
        var startOffset = this.getInputStartOffsetOfOutputLineIndex(outputLineIndex);
        var endOffset = this.getInputEndOffsetOfOutputLineIndex(model, modelLineNumber, outputLineIndex);
        var r = model.getValueInRange({
            startLineNumber: modelLineNumber,
            startColumn: startOffset + 1,
            endLineNumber: modelLineNumber,
            endColumn: endOffset + 1
        });
        if (outputLineIndex > 0) {
            r = this.wrappedIndent + r;
        }
        return r;
    };
    SplitLine.prototype.getViewLineLength = function (model, modelLineNumber, outputLineIndex) {
        if (!this._isVisible) {
            throw new Error('Not supported');
        }
        var startOffset = this.getInputStartOffsetOfOutputLineIndex(outputLineIndex);
        var endOffset = this.getInputEndOffsetOfOutputLineIndex(model, modelLineNumber, outputLineIndex);
        var r = endOffset - startOffset;
        if (outputLineIndex > 0) {
            r = this.wrappedIndent.length + r;
        }
        return r;
    };
    SplitLine.prototype.getViewLineMinColumn = function (model, modelLineNumber, outputLineIndex) {
        if (!this._isVisible) {
            throw new Error('Not supported');
        }
        if (outputLineIndex > 0) {
            return this.wrappedIndentLength + 1;
        }
        return 1;
    };
    SplitLine.prototype.getViewLineMaxColumn = function (model, modelLineNumber, outputLineIndex) {
        if (!this._isVisible) {
            throw new Error('Not supported');
        }
        return this.getViewLineContent(model, modelLineNumber, outputLineIndex).length + 1;
    };
    SplitLine.prototype.getViewLineData = function (model, modelLineNumber, outputLineIndex) {
        if (!this._isVisible) {
            throw new Error('Not supported');
        }
        var startOffset = this.getInputStartOffsetOfOutputLineIndex(outputLineIndex);
        var endOffset = this.getInputEndOffsetOfOutputLineIndex(model, modelLineNumber, outputLineIndex);
        var lineContent = model.getValueInRange({
            startLineNumber: modelLineNumber,
            startColumn: startOffset + 1,
            endLineNumber: modelLineNumber,
            endColumn: endOffset + 1
        });
        if (outputLineIndex > 0) {
            lineContent = this.wrappedIndent + lineContent;
        }
        var minColumn = (outputLineIndex > 0 ? this.wrappedIndentLength + 1 : 1);
        var maxColumn = lineContent.length + 1;
        var deltaStartIndex = 0;
        if (outputLineIndex > 0) {
            deltaStartIndex = this.wrappedIndentLength;
        }
        var lineTokens = model.getLineTokens(modelLineNumber);
        return new ViewLineData(lineContent, minColumn, maxColumn, lineTokens.sliceAndInflate(startOffset, endOffset, deltaStartIndex));
    };
    SplitLine.prototype.getViewLinesData = function (model, modelLineNumber, fromOuputLineIndex, toOutputLineIndex, globalStartIndex, needed, result) {
        if (!this._isVisible) {
            throw new Error('Not supported');
        }
        for (var outputLineIndex = fromOuputLineIndex; outputLineIndex < toOutputLineIndex; outputLineIndex++) {
            var globalIndex = globalStartIndex + outputLineIndex - fromOuputLineIndex;
            if (!needed[globalIndex]) {
                result[globalIndex] = null;
                continue;
            }
            result[globalIndex] = this.getViewLineData(model, modelLineNumber, outputLineIndex);
        }
    };
    SplitLine.prototype.getModelColumnOfViewPosition = function (outputLineIndex, outputColumn) {
        if (!this._isVisible) {
            throw new Error('Not supported');
        }
        var adjustedColumn = outputColumn - 1;
        if (outputLineIndex > 0) {
            if (adjustedColumn < this.wrappedIndentLength) {
                adjustedColumn = 0;
            }
            else {
                adjustedColumn -= this.wrappedIndentLength;
            }
        }
        return this.positionMapper.getInputOffsetOfOutputPosition(outputLineIndex, adjustedColumn) + 1;
    };
    SplitLine.prototype.getViewPositionOfModelPosition = function (deltaLineNumber, inputColumn) {
        if (!this._isVisible) {
            throw new Error('Not supported');
        }
        var r = this.positionMapper.getOutputPositionOfInputOffset(inputColumn - 1);
        var outputLineIndex = r.outputLineIndex;
        var outputColumn = r.outputOffset + 1;
        if (outputLineIndex > 0) {
            outputColumn += this.wrappedIndentLength;
        }
        //		console.log('in -> out ' + deltaLineNumber + ',' + inputColumn + ' ===> ' + (deltaLineNumber+outputLineIndex) + ',' + outputColumn);
        return new Position(deltaLineNumber + outputLineIndex, outputColumn);
    };
    SplitLine.prototype.getViewLineNumberOfModelPosition = function (deltaLineNumber, inputColumn) {
        if (!this._isVisible) {
            throw new Error('Not supported');
        }
        var r = this.positionMapper.getOutputPositionOfInputOffset(inputColumn - 1);
        return (deltaLineNumber + r.outputLineIndex);
    };
    return SplitLine;
}());
function createSplitLine(linePositionMapperFactory, text, tabSize, wrappingColumn, columnsForFullWidthChar, wrappingIndent, isVisible) {
    var positionMapper = linePositionMapperFactory.createLineMapping(text, tabSize, wrappingColumn, columnsForFullWidthChar, wrappingIndent);
    if (positionMapper === null) {
        // No mapping needed
        if (isVisible) {
            return VisibleIdentitySplitLine.INSTANCE;
        }
        return InvisibleIdentitySplitLine.INSTANCE;
    }
    else {
        return new SplitLine(positionMapper, isVisible);
    }
}
var IdentityCoordinatesConverter = /** @class */ (function () {
    function IdentityCoordinatesConverter(lines) {
        this._lines = lines;
    }
    IdentityCoordinatesConverter.prototype._validPosition = function (pos) {
        return this._lines.model.validatePosition(pos);
    };
    IdentityCoordinatesConverter.prototype._validRange = function (range) {
        return this._lines.model.validateRange(range);
    };
    // View -> Model conversion and related methods
    IdentityCoordinatesConverter.prototype.convertViewPositionToModelPosition = function (viewPosition) {
        return this._validPosition(viewPosition);
    };
    IdentityCoordinatesConverter.prototype.convertViewRangeToModelRange = function (viewRange) {
        return this._validRange(viewRange);
    };
    IdentityCoordinatesConverter.prototype.validateViewPosition = function (viewPosition, expectedModelPosition) {
        return this._validPosition(expectedModelPosition);
    };
    IdentityCoordinatesConverter.prototype.validateViewRange = function (viewRange, expectedModelRange) {
        return this._validRange(expectedModelRange);
    };
    // Model -> View conversion and related methods
    IdentityCoordinatesConverter.prototype.convertModelPositionToViewPosition = function (modelPosition) {
        return this._validPosition(modelPosition);
    };
    IdentityCoordinatesConverter.prototype.convertModelRangeToViewRange = function (modelRange) {
        return this._validRange(modelRange);
    };
    IdentityCoordinatesConverter.prototype.modelPositionIsVisible = function (modelPosition) {
        var lineCount = this._lines.model.getLineCount();
        if (modelPosition.lineNumber < 1 || modelPosition.lineNumber > lineCount) {
            // invalid arguments
            return false;
        }
        return true;
    };
    return IdentityCoordinatesConverter;
}());
var IdentityLinesCollection = /** @class */ (function () {
    function IdentityLinesCollection(model) {
        this.model = model;
    }
    IdentityLinesCollection.prototype.dispose = function () {
    };
    IdentityLinesCollection.prototype.createCoordinatesConverter = function () {
        return new IdentityCoordinatesConverter(this);
    };
    IdentityLinesCollection.prototype.getHiddenAreas = function () {
        return [];
    };
    IdentityLinesCollection.prototype.setHiddenAreas = function (_ranges) {
        return false;
    };
    IdentityLinesCollection.prototype.setTabSize = function (newTabSize) {
        return false;
    };
    IdentityLinesCollection.prototype.setWrappingSettings = function (wrappingIndent, wrappingColumn, columnsForFullWidthChar) {
        return false;
    };
    IdentityLinesCollection.prototype.onModelFlushed = function () {
    };
    IdentityLinesCollection.prototype.onModelLinesDeleted = function (versionId, fromLineNumber, toLineNumber) {
        return new ViewLinesDeletedEvent(fromLineNumber, toLineNumber);
    };
    IdentityLinesCollection.prototype.onModelLinesInserted = function (versionId, fromLineNumber, toLineNumber, text) {
        return new ViewLinesInsertedEvent(fromLineNumber, toLineNumber);
    };
    IdentityLinesCollection.prototype.onModelLineChanged = function (versionId, lineNumber, newText) {
        return [false, new ViewLinesChangedEvent(lineNumber, lineNumber), null, null];
    };
    IdentityLinesCollection.prototype.acceptVersionId = function (versionId) {
    };
    IdentityLinesCollection.prototype.getViewLineCount = function () {
        return this.model.getLineCount();
    };
    IdentityLinesCollection.prototype.warmUpLookupCache = function (viewStartLineNumber, viewEndLineNumber) {
    };
    IdentityLinesCollection.prototype.getActiveIndentGuide = function (viewLineNumber, minLineNumber, maxLineNumber) {
        return {
            startLineNumber: viewLineNumber,
            endLineNumber: viewLineNumber,
            indent: 0
        };
    };
    IdentityLinesCollection.prototype.getViewLinesIndentGuides = function (viewStartLineNumber, viewEndLineNumber) {
        var viewLineCount = viewEndLineNumber - viewStartLineNumber + 1;
        var result = new Array(viewLineCount);
        for (var i = 0; i < viewLineCount; i++) {
            result[i] = 0;
        }
        return result;
    };
    IdentityLinesCollection.prototype.getViewLineContent = function (viewLineNumber) {
        return this.model.getLineContent(viewLineNumber);
    };
    IdentityLinesCollection.prototype.getViewLineLength = function (viewLineNumber) {
        return this.model.getLineLength(viewLineNumber);
    };
    IdentityLinesCollection.prototype.getViewLineMinColumn = function (viewLineNumber) {
        return this.model.getLineMinColumn(viewLineNumber);
    };
    IdentityLinesCollection.prototype.getViewLineMaxColumn = function (viewLineNumber) {
        return this.model.getLineMaxColumn(viewLineNumber);
    };
    IdentityLinesCollection.prototype.getViewLineData = function (viewLineNumber) {
        var lineTokens = this.model.getLineTokens(viewLineNumber);
        var lineContent = lineTokens.getLineContent();
        return new ViewLineData(lineContent, 1, lineContent.length + 1, lineTokens.inflate());
    };
    IdentityLinesCollection.prototype.getViewLinesData = function (viewStartLineNumber, viewEndLineNumber, needed) {
        var lineCount = this.model.getLineCount();
        viewStartLineNumber = Math.min(Math.max(1, viewStartLineNumber), lineCount);
        viewEndLineNumber = Math.min(Math.max(1, viewEndLineNumber), lineCount);
        var result = [];
        for (var lineNumber = viewStartLineNumber; lineNumber <= viewEndLineNumber; lineNumber++) {
            var idx = lineNumber - viewStartLineNumber;
            if (!needed[idx]) {
                result[idx] = null;
            }
            result[idx] = this.getViewLineData(lineNumber);
        }
        return result;
    };
    IdentityLinesCollection.prototype.getAllOverviewRulerDecorations = function (ownerId, filterOutValidation, theme) {
        var decorations = this.model.getOverviewRulerDecorations(ownerId, filterOutValidation);
        var result = new OverviewRulerDecorations();
        for (var i = 0, len = decorations.length; i < len; i++) {
            var decoration = decorations[i];
            var opts = decoration.options.overviewRuler;
            var lane = opts.position;
            if (lane === 0) {
                continue;
            }
            var color = resolveColor(opts, theme);
            var viewStartLineNumber = decoration.range.startLineNumber;
            var viewEndLineNumber = decoration.range.endLineNumber;
            result.accept(color, viewStartLineNumber, viewEndLineNumber, lane);
        }
        return result.result;
    };
    IdentityLinesCollection.prototype.getDecorationsInRange = function (range, ownerId, filterOutValidation) {
        return this.model.getDecorationsInRange(range, ownerId, filterOutValidation);
    };
    return IdentityLinesCollection;
}());
var OverviewRulerDecorations = /** @class */ (function () {
    function OverviewRulerDecorations() {
        this.result = Object.create(null);
    }
    OverviewRulerDecorations.prototype.accept = function (color, startLineNumber, endLineNumber, lane) {
        var prev = this.result[color];
        if (prev) {
            var prevLane = prev[prev.length - 3];
            var prevEndLineNumber = prev[prev.length - 1];
            if (prevLane === lane && prevEndLineNumber + 1 >= startLineNumber) {
                // merge into prev
                if (endLineNumber > prevEndLineNumber) {
                    prev[prev.length - 1] = endLineNumber;
                }
                return;
            }
            // push
            prev.push(lane, startLineNumber, endLineNumber);
        }
        else {
            this.result[color] = [lane, startLineNumber, endLineNumber];
        }
    };
    return OverviewRulerDecorations;
}());
function resolveColor(opts, theme) {
    if (!opts._resolvedColor) {
        var themeType = theme.type;
        var color = (themeType === 'dark' ? opts.darkColor : themeType === 'light' ? opts.color : opts.hcColor);
        opts._resolvedColor = resolveRulerColor(color, theme);
    }
    return opts._resolvedColor;
}
function resolveRulerColor(color, theme) {
    if (typeof color === 'string') {
        return color;
    }
    var c = color ? theme.getColor(color.id) : null;
    if (!c) {
        c = Color.transparent;
    }
    return c.toString();
}

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
/**
 * A very VM friendly rgba datastructure.
 * Please don't touch unless you take a look at the IR.
 */
var RGBA8 = /** @class */ (function () {
    function RGBA8(r, g, b, a) {
        this.r = RGBA8._clamp(r);
        this.g = RGBA8._clamp(g);
        this.b = RGBA8._clamp(b);
        this.a = RGBA8._clamp(a);
    }
    RGBA8._clamp = function (c) {
        if (c < 0) {
            return 0;
        }
        if (c > 255) {
            return 255;
        }
        return c | 0;
    };
    return RGBA8;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var MinimapTokensColorTracker = /** @class */ (function () {
    function MinimapTokensColorTracker() {
        var _this = this;
        this._onDidChange = new Emitter();
        this.onDidChange = this._onDidChange.event;
        this._updateColorMap();
        TokenizationRegistry.onDidChange(function (e) {
            if (e.changedColorMap) {
                _this._updateColorMap();
            }
        });
    }
    MinimapTokensColorTracker.getInstance = function () {
        if (!this._INSTANCE) {
            this._INSTANCE = new MinimapTokensColorTracker();
        }
        return this._INSTANCE;
    };
    MinimapTokensColorTracker.prototype._updateColorMap = function () {
        var colorMap = TokenizationRegistry.getColorMap();
        if (!colorMap) {
            this._colors = [null];
            this._backgroundIsLight = true;
            return;
        }
        this._colors = [null];
        for (var colorId = 1; colorId < colorMap.length; colorId++) {
            var source = colorMap[colorId].rgba;
            // Use a VM friendly data-type
            this._colors[colorId] = new RGBA8(source.r, source.g, source.b, Math.round(source.a * 255));
        }
        var backgroundLuminosity = colorMap[2 /* DefaultBackground */].getRelativeLuminance();
        this._backgroundIsLight = (backgroundLuminosity >= 0.5);
        this._onDidChange.fire(void 0);
    };
    MinimapTokensColorTracker.prototype.getColor = function (colorId) {
        if (colorId < 1 || colorId >= this._colors.length) {
            // background color (basically invisible)
            colorId = 2 /* DefaultBackground */;
        }
        return this._colors[colorId];
    };
    MinimapTokensColorTracker.prototype.backgroundIsLight = function () {
        return this._backgroundIsLight;
    };
    MinimapTokensColorTracker._INSTANCE = null;
    return MinimapTokensColorTracker;
}());
var MinimapCharRenderer = /** @class */ (function () {
    function MinimapCharRenderer(x2CharData, x1CharData) {
        var x2ExpectedLen = 4 /* x2_CHAR_HEIGHT */ * 2 /* x2_CHAR_WIDTH */ * 95 /* CHAR_COUNT */;
        if (x2CharData.length !== x2ExpectedLen) {
            throw new Error('Invalid x2CharData');
        }
        var x1ExpectedLen = 2 /* x1_CHAR_HEIGHT */ * 1 /* x1_CHAR_WIDTH */ * 95 /* CHAR_COUNT */;
        if (x1CharData.length !== x1ExpectedLen) {
            throw new Error('Invalid x1CharData');
        }
        this.x2charData = x2CharData;
        this.x1charData = x1CharData;
        this.x2charDataLight = MinimapCharRenderer.soften(x2CharData, 12 / 15);
        this.x1charDataLight = MinimapCharRenderer.soften(x1CharData, 50 / 60);
    }
    MinimapCharRenderer.soften = function (input, ratio) {
        var result = new Uint8ClampedArray(input.length);
        for (var i = 0, len = input.length; i < len; i++) {
            result[i] = input[i] * ratio;
        }
        return result;
    };
    MinimapCharRenderer._getChIndex = function (chCode) {
        chCode -= 32 /* START_CH_CODE */;
        if (chCode < 0) {
            chCode += 95 /* CHAR_COUNT */;
        }
        return (chCode % 95 /* CHAR_COUNT */);
    };
    MinimapCharRenderer.prototype.x2RenderChar = function (target, dx, dy, chCode, color, backgroundColor, useLighterFont) {
        if (dx + 2 /* x2_CHAR_WIDTH */ > target.width || dy + 4 /* x2_CHAR_HEIGHT */ > target.height) {
            console.warn('bad render request outside image data');
            return;
        }
        var x2CharData = useLighterFont ? this.x2charDataLight : this.x2charData;
        var chIndex = MinimapCharRenderer._getChIndex(chCode);
        var outWidth = target.width * 4 /* RGBA_CHANNELS_CNT */;
        var backgroundR = backgroundColor.r;
        var backgroundG = backgroundColor.g;
        var backgroundB = backgroundColor.b;
        var deltaR = color.r - backgroundR;
        var deltaG = color.g - backgroundG;
        var deltaB = color.b - backgroundB;
        var dest = target.data;
        var sourceOffset = chIndex * 4 /* x2_CHAR_HEIGHT */ * 2 /* x2_CHAR_WIDTH */;
        var destOffset = dy * outWidth + dx * 4 /* RGBA_CHANNELS_CNT */;
        {
            var c = x2CharData[sourceOffset] / 255;
            dest[destOffset + 0] = backgroundR + deltaR * c;
            dest[destOffset + 1] = backgroundG + deltaG * c;
            dest[destOffset + 2] = backgroundB + deltaB * c;
        }
        {
            var c = x2CharData[sourceOffset + 1] / 255;
            dest[destOffset + 4] = backgroundR + deltaR * c;
            dest[destOffset + 5] = backgroundG + deltaG * c;
            dest[destOffset + 6] = backgroundB + deltaB * c;
        }
        destOffset += outWidth;
        {
            var c = x2CharData[sourceOffset + 2] / 255;
            dest[destOffset + 0] = backgroundR + deltaR * c;
            dest[destOffset + 1] = backgroundG + deltaG * c;
            dest[destOffset + 2] = backgroundB + deltaB * c;
        }
        {
            var c = x2CharData[sourceOffset + 3] / 255;
            dest[destOffset + 4] = backgroundR + deltaR * c;
            dest[destOffset + 5] = backgroundG + deltaG * c;
            dest[destOffset + 6] = backgroundB + deltaB * c;
        }
        destOffset += outWidth;
        {
            var c = x2CharData[sourceOffset + 4] / 255;
            dest[destOffset + 0] = backgroundR + deltaR * c;
            dest[destOffset + 1] = backgroundG + deltaG * c;
            dest[destOffset + 2] = backgroundB + deltaB * c;
        }
        {
            var c = x2CharData[sourceOffset + 5] / 255;
            dest[destOffset + 4] = backgroundR + deltaR * c;
            dest[destOffset + 5] = backgroundG + deltaG * c;
            dest[destOffset + 6] = backgroundB + deltaB * c;
        }
        destOffset += outWidth;
        {
            var c = x2CharData[sourceOffset + 6] / 255;
            dest[destOffset + 0] = backgroundR + deltaR * c;
            dest[destOffset + 1] = backgroundG + deltaG * c;
            dest[destOffset + 2] = backgroundB + deltaB * c;
        }
        {
            var c = x2CharData[sourceOffset + 7] / 255;
            dest[destOffset + 4] = backgroundR + deltaR * c;
            dest[destOffset + 5] = backgroundG + deltaG * c;
            dest[destOffset + 6] = backgroundB + deltaB * c;
        }
    };
    MinimapCharRenderer.prototype.x1RenderChar = function (target, dx, dy, chCode, color, backgroundColor, useLighterFont) {
        if (dx + 1 /* x1_CHAR_WIDTH */ > target.width || dy + 2 /* x1_CHAR_HEIGHT */ > target.height) {
            console.warn('bad render request outside image data');
            return;
        }
        var x1CharData = useLighterFont ? this.x1charDataLight : this.x1charData;
        var chIndex = MinimapCharRenderer._getChIndex(chCode);
        var outWidth = target.width * 4 /* RGBA_CHANNELS_CNT */;
        var backgroundR = backgroundColor.r;
        var backgroundG = backgroundColor.g;
        var backgroundB = backgroundColor.b;
        var deltaR = color.r - backgroundR;
        var deltaG = color.g - backgroundG;
        var deltaB = color.b - backgroundB;
        var dest = target.data;
        var sourceOffset = chIndex * 2 /* x1_CHAR_HEIGHT */ * 1 /* x1_CHAR_WIDTH */;
        var destOffset = dy * outWidth + dx * 4 /* RGBA_CHANNELS_CNT */;
        {
            var c = x1CharData[sourceOffset] / 255;
            dest[destOffset + 0] = backgroundR + deltaR * c;
            dest[destOffset + 1] = backgroundG + deltaG * c;
            dest[destOffset + 2] = backgroundB + deltaB * c;
        }
        destOffset += outWidth;
        {
            var c = x1CharData[sourceOffset + 1] / 255;
            dest[destOffset + 0] = backgroundR + deltaR * c;
            dest[destOffset + 1] = backgroundG + deltaG * c;
            dest[destOffset + 2] = backgroundB + deltaB * c;
        }
    };
    MinimapCharRenderer.prototype.x2BlockRenderChar = function (target, dx, dy, color, backgroundColor, useLighterFont) {
        if (dx + 2 /* x2_CHAR_WIDTH */ > target.width || dy + 4 /* x2_CHAR_HEIGHT */ > target.height) {
            console.warn('bad render request outside image data');
            return;
        }
        var outWidth = target.width * 4 /* RGBA_CHANNELS_CNT */;
        var c = 0.5;
        var backgroundR = backgroundColor.r;
        var backgroundG = backgroundColor.g;
        var backgroundB = backgroundColor.b;
        var deltaR = color.r - backgroundR;
        var deltaG = color.g - backgroundG;
        var deltaB = color.b - backgroundB;
        var colorR = backgroundR + deltaR * c;
        var colorG = backgroundG + deltaG * c;
        var colorB = backgroundB + deltaB * c;
        var dest = target.data;
        var destOffset = dy * outWidth + dx * 4 /* RGBA_CHANNELS_CNT */;
        {
            dest[destOffset + 0] = colorR;
            dest[destOffset + 1] = colorG;
            dest[destOffset + 2] = colorB;
        }
        {
            dest[destOffset + 4] = colorR;
            dest[destOffset + 5] = colorG;
            dest[destOffset + 6] = colorB;
        }
        destOffset += outWidth;
        {
            dest[destOffset + 0] = colorR;
            dest[destOffset + 1] = colorG;
            dest[destOffset + 2] = colorB;
        }
        {
            dest[destOffset + 4] = colorR;
            dest[destOffset + 5] = colorG;
            dest[destOffset + 6] = colorB;
        }
        destOffset += outWidth;
        {
            dest[destOffset + 0] = colorR;
            dest[destOffset + 1] = colorG;
            dest[destOffset + 2] = colorB;
        }
        {
            dest[destOffset + 4] = colorR;
            dest[destOffset + 5] = colorG;
            dest[destOffset + 6] = colorB;
        }
        destOffset += outWidth;
        {
            dest[destOffset + 0] = colorR;
            dest[destOffset + 1] = colorG;
            dest[destOffset + 2] = colorB;
        }
        {
            dest[destOffset + 4] = colorR;
            dest[destOffset + 5] = colorG;
            dest[destOffset + 6] = colorB;
        }
    };
    MinimapCharRenderer.prototype.x1BlockRenderChar = function (target, dx, dy, color, backgroundColor, useLighterFont) {
        if (dx + 1 /* x1_CHAR_WIDTH */ > target.width || dy + 2 /* x1_CHAR_HEIGHT */ > target.height) {
            console.warn('bad render request outside image data');
            return;
        }
        var outWidth = target.width * 4 /* RGBA_CHANNELS_CNT */;
        var c = 0.5;
        var backgroundR = backgroundColor.r;
        var backgroundG = backgroundColor.g;
        var backgroundB = backgroundColor.b;
        var deltaR = color.r - backgroundR;
        var deltaG = color.g - backgroundG;
        var deltaB = color.b - backgroundB;
        var colorR = backgroundR + deltaR * c;
        var colorG = backgroundG + deltaG * c;
        var colorB = backgroundB + deltaB * c;
        var dest = target.data;
        var destOffset = dy * outWidth + dx * 4 /* RGBA_CHANNELS_CNT */;
        {
            dest[destOffset + 0] = colorR;
            dest[destOffset + 1] = colorG;
            dest[destOffset + 2] = colorB;
        }
        destOffset += outWidth;
        {
            dest[destOffset + 0] = colorR;
            dest[destOffset + 1] = colorG;
            dest[destOffset + 2] = colorB;
        }
    };
    return MinimapCharRenderer;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$d = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var WrappingCharacterClassifier = /** @class */ (function (_super) {
    __extends$d(WrappingCharacterClassifier, _super);
    function WrappingCharacterClassifier(BREAK_BEFORE, BREAK_AFTER, BREAK_OBTRUSIVE) {
        var _this = _super.call(this, 0 /* NONE */) || this;
        for (var i = 0; i < BREAK_BEFORE.length; i++) {
            _this.set(BREAK_BEFORE.charCodeAt(i), 1 /* BREAK_BEFORE */);
        }
        for (var i = 0; i < BREAK_AFTER.length; i++) {
            _this.set(BREAK_AFTER.charCodeAt(i), 2 /* BREAK_AFTER */);
        }
        for (var i = 0; i < BREAK_OBTRUSIVE.length; i++) {
            _this.set(BREAK_OBTRUSIVE.charCodeAt(i), 3 /* BREAK_OBTRUSIVE */);
        }
        return _this;
    }
    WrappingCharacterClassifier.prototype.get = function (charCode) {
        // Initialize CharacterClass.BREAK_IDEOGRAPHIC for these Unicode ranges:
        // 1. CJK Unified Ideographs (0x4E00 -- 0x9FFF)
        // 2. CJK Unified Ideographs Extension A (0x3400 -- 0x4DBF)
        // 3. Hiragana and Katakana (0x3040 -- 0x30FF)
        if ((charCode >= 0x3040 && charCode <= 0x30FF)
            || (charCode >= 0x3400 && charCode <= 0x4DBF)
            || (charCode >= 0x4E00 && charCode <= 0x9FFF)) {
            return 4 /* BREAK_IDEOGRAPHIC */;
        }
        return _super.prototype.get.call(this, charCode);
    };
    return WrappingCharacterClassifier;
}(CharacterClassifier));
var CharacterHardWrappingLineMapperFactory = /** @class */ (function () {
    function CharacterHardWrappingLineMapperFactory(breakBeforeChars, breakAfterChars, breakObtrusiveChars) {
        this.classifier = new WrappingCharacterClassifier(breakBeforeChars, breakAfterChars, breakObtrusiveChars);
    }
    // TODO@Alex -> duplicated in lineCommentCommand
    CharacterHardWrappingLineMapperFactory.nextVisibleColumn = function (currentVisibleColumn, tabSize, isTab, columnSize) {
        currentVisibleColumn = +currentVisibleColumn; //@perf
        tabSize = +tabSize; //@perf
        columnSize = +columnSize; //@perf
        if (isTab) {
            return currentVisibleColumn + (tabSize - (currentVisibleColumn % tabSize));
        }
        return currentVisibleColumn + columnSize;
    };
    CharacterHardWrappingLineMapperFactory.prototype.createLineMapping = function (lineText, tabSize, breakingColumn, columnsForFullWidthChar, hardWrappingIndent) {
        if (breakingColumn === -1) {
            return null;
        }
        tabSize = +tabSize; //@perf
        breakingColumn = +breakingColumn; //@perf
        columnsForFullWidthChar = +columnsForFullWidthChar; //@perf
        hardWrappingIndent = +hardWrappingIndent; //@perf
        var wrappedTextIndentVisibleColumn = 0;
        var wrappedTextIndent = '';
        var firstNonWhitespaceIndex$$1 = -1;
        if (hardWrappingIndent !== WrappingIndent.None) {
            firstNonWhitespaceIndex$$1 = firstNonWhitespaceIndex(lineText);
            if (firstNonWhitespaceIndex$$1 !== -1) {
                wrappedTextIndent = lineText.substring(0, firstNonWhitespaceIndex$$1);
                for (var i = 0; i < firstNonWhitespaceIndex$$1; i++) {
                    wrappedTextIndentVisibleColumn = CharacterHardWrappingLineMapperFactory.nextVisibleColumn(wrappedTextIndentVisibleColumn, tabSize, lineText.charCodeAt(i) === 9 /* Tab */, 1);
                }
                if (hardWrappingIndent === WrappingIndent.Indent) {
                    wrappedTextIndent += '\t';
                    wrappedTextIndentVisibleColumn = CharacterHardWrappingLineMapperFactory.nextVisibleColumn(wrappedTextIndentVisibleColumn, tabSize, true, 1);
                }
                // Force sticking to beginning of line if no character would fit except for the indentation
                if (wrappedTextIndentVisibleColumn + columnsForFullWidthChar > breakingColumn) {
                    wrappedTextIndent = '';
                    wrappedTextIndentVisibleColumn = 0;
                }
            }
        }
        var classifier = this.classifier;
        var lastBreakingOffset = 0; // Last 0-based offset in the lineText at which a break happened
        var breakingLengths = []; // The length of each broken-up line text
        var breakingLengthsIndex = 0; // The count of breaks already done
        var visibleColumn = 0; // Visible column since the beginning of the current line
        var niceBreakOffset = -1; // Last index of a character that indicates a break should happen before it (more desirable)
        var niceBreakVisibleColumn = 0; // visible column if a break were to be later introduced before `niceBreakOffset`
        var obtrusiveBreakOffset = -1; // Last index of a character that indicates a break should happen before it (less desirable)
        var obtrusiveBreakVisibleColumn = 0; // visible column if a break were to be later introduced before `obtrusiveBreakOffset`
        var len = lineText.length;
        for (var i = 0; i < len; i++) {
            // At this point, there is a certainty that the character before `i` fits on the current line,
            // but the character at `i` might not fit
            var charCode = lineText.charCodeAt(i);
            var charCodeIsTab = (charCode === 9 /* Tab */);
            var charCodeClass = classifier.get(charCode);
            if (charCodeClass === 1 /* BREAK_BEFORE */) {
                // This is a character that indicates that a break should happen before it
                // Since we are certain the character before `i` fits, there's no extra checking needed,
                // just mark it as a nice breaking opportunity
                niceBreakOffset = i;
                niceBreakVisibleColumn = wrappedTextIndentVisibleColumn;
            }
            // CJK breaking : before break
            if (charCodeClass === 4 /* BREAK_IDEOGRAPHIC */ && i > 0) {
                var prevCode = lineText.charCodeAt(i - 1);
                var prevClass = classifier.get(prevCode);
                if (prevClass !== 1 /* BREAK_BEFORE */) { // Kinsoku Shori: Don't break after a leading character, like an open bracket
                    niceBreakOffset = i;
                    niceBreakVisibleColumn = wrappedTextIndentVisibleColumn;
                }
            }
            var charColumnSize = 1;
            if (isFullWidthCharacter(charCode)) {
                charColumnSize = columnsForFullWidthChar;
            }
            // Advance visibleColumn with character at `i`
            visibleColumn = CharacterHardWrappingLineMapperFactory.nextVisibleColumn(visibleColumn, tabSize, charCodeIsTab, charColumnSize);
            if (visibleColumn > breakingColumn && i !== 0) {
                // We need to break at least before character at `i`:
                //  - break before niceBreakLastOffset if it exists (and re-establish a correct visibleColumn by using niceBreakVisibleColumn + charAt(i))
                //  - otherwise, break before obtrusiveBreakLastOffset if it exists (and re-establish a correct visibleColumn by using obtrusiveBreakVisibleColumn + charAt(i))
                //  - otherwise, break before i (and re-establish a correct visibleColumn by charAt(i))
                var breakBeforeOffset = void 0;
                var restoreVisibleColumnFrom = void 0;
                if (niceBreakOffset !== -1 && niceBreakVisibleColumn <= breakingColumn) {
                    // We will break before `niceBreakLastOffset`
                    breakBeforeOffset = niceBreakOffset;
                    restoreVisibleColumnFrom = niceBreakVisibleColumn;
                }
                else if (obtrusiveBreakOffset !== -1 && obtrusiveBreakVisibleColumn <= breakingColumn) {
                    // We will break before `obtrusiveBreakLastOffset`
                    breakBeforeOffset = obtrusiveBreakOffset;
                    restoreVisibleColumnFrom = obtrusiveBreakVisibleColumn;
                }
                else {
                    // We will break before `i`
                    breakBeforeOffset = i;
                    restoreVisibleColumnFrom = wrappedTextIndentVisibleColumn;
                }
                // Break before character at `breakBeforeOffset`
                breakingLengths[breakingLengthsIndex++] = breakBeforeOffset - lastBreakingOffset;
                lastBreakingOffset = breakBeforeOffset;
                // Re-establish visibleColumn by taking character at `i` into account
                visibleColumn = CharacterHardWrappingLineMapperFactory.nextVisibleColumn(restoreVisibleColumnFrom, tabSize, charCodeIsTab, charColumnSize);
                // Reset markers
                niceBreakOffset = -1;
                niceBreakVisibleColumn = 0;
                obtrusiveBreakOffset = -1;
                obtrusiveBreakVisibleColumn = 0;
            }
            // At this point, there is a certainty that the character at `i` fits on the current line
            if (niceBreakOffset !== -1) {
                // Advance niceBreakVisibleColumn
                niceBreakVisibleColumn = CharacterHardWrappingLineMapperFactory.nextVisibleColumn(niceBreakVisibleColumn, tabSize, charCodeIsTab, charColumnSize);
            }
            if (obtrusiveBreakOffset !== -1) {
                // Advance obtrusiveBreakVisibleColumn
                obtrusiveBreakVisibleColumn = CharacterHardWrappingLineMapperFactory.nextVisibleColumn(obtrusiveBreakVisibleColumn, tabSize, charCodeIsTab, charColumnSize);
            }
            if (charCodeClass === 2 /* BREAK_AFTER */ && (hardWrappingIndent === WrappingIndent.None || i >= firstNonWhitespaceIndex$$1)) {
                // This is a character that indicates that a break should happen after it
                niceBreakOffset = i + 1;
                niceBreakVisibleColumn = wrappedTextIndentVisibleColumn;
            }
            // CJK breaking : after break
            if (charCodeClass === 4 /* BREAK_IDEOGRAPHIC */ && i < len - 1) {
                var nextCode = lineText.charCodeAt(i + 1);
                var nextClass = classifier.get(nextCode);
                if (nextClass !== 2 /* BREAK_AFTER */) { // Kinsoku Shori: Don't break before a trailing character, like a period
                    niceBreakOffset = i + 1;
                    niceBreakVisibleColumn = wrappedTextIndentVisibleColumn;
                }
            }
            if (charCodeClass === 3 /* BREAK_OBTRUSIVE */) {
                // This is an obtrusive character that indicates that a break should happen after it
                obtrusiveBreakOffset = i + 1;
                obtrusiveBreakVisibleColumn = wrappedTextIndentVisibleColumn;
            }
        }
        if (breakingLengthsIndex === 0) {
            return null;
        }
        // Add last segment
        breakingLengths[breakingLengthsIndex++] = len - lastBreakingOffset;
        return new CharacterHardWrappingLineMapping(new PrefixSumComputer(toUint32Array(breakingLengths)), wrappedTextIndent);
    };
    return CharacterHardWrappingLineMapperFactory;
}());
var CharacterHardWrappingLineMapping = /** @class */ (function () {
    function CharacterHardWrappingLineMapping(prefixSums, wrappedLinesIndent) {
        this._prefixSums = prefixSums;
        this._wrappedLinesIndent = wrappedLinesIndent;
    }
    CharacterHardWrappingLineMapping.prototype.getOutputLineCount = function () {
        return this._prefixSums.getCount();
    };
    CharacterHardWrappingLineMapping.prototype.getWrappedLinesIndent = function () {
        return this._wrappedLinesIndent;
    };
    CharacterHardWrappingLineMapping.prototype.getInputOffsetOfOutputPosition = function (outputLineIndex, outputOffset) {
        if (outputLineIndex === 0) {
            return outputOffset;
        }
        else {
            return this._prefixSums.getAccumulatedValue(outputLineIndex - 1) + outputOffset;
        }
    };
    CharacterHardWrappingLineMapping.prototype.getOutputPositionOfInputOffset = function (inputOffset) {
        var r = this._prefixSums.getIndexOf(inputOffset);
        return new OutputPosition(r.index, r.remainder);
    };
    return CharacterHardWrappingLineMapping;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
/**
 * Represent whitespaces in between lines and provide fast CRUD management methods.
 * The whitespaces are sorted ascending by `afterLineNumber`.
 */
var WhitespaceComputer = /** @class */ (function () {
    function WhitespaceComputer() {
        this._heights = [];
        this._ids = [];
        this._afterLineNumbers = [];
        this._ordinals = [];
        this._prefixSum = [];
        this._prefixSumValidIndex = -1;
        this._whitespaceId2Index = {};
        this._lastWhitespaceId = 0;
    }
    /**
     * Find the insertion index for a new value inside a sorted array of values.
     * If the value is already present in the sorted array, the insertion index will be after the already existing value.
     */
    WhitespaceComputer.findInsertionIndex = function (sortedArray, value, ordinals, valueOrdinal) {
        var low = 0;
        var high = sortedArray.length;
        while (low < high) {
            var mid = ((low + high) >>> 1);
            if (value === sortedArray[mid]) {
                if (valueOrdinal < ordinals[mid]) {
                    high = mid;
                }
                else {
                    low = mid + 1;
                }
            }
            else if (value < sortedArray[mid]) {
                high = mid;
            }
            else {
                low = mid + 1;
            }
        }
        return low;
    };
    /**
     * Insert a new whitespace of a certain height after a line number.
     * The whitespace has a "sticky" characteristic.
     * Irrespective of edits above or below `afterLineNumber`, the whitespace will follow the initial line.
     *
     * @param afterLineNumber The conceptual position of this whitespace. The whitespace will follow this line as best as possible even when deleting/inserting lines above/below.
     * @param heightInPx The height of the whitespace, in pixels.
     * @return An id that can be used later to mutate or delete the whitespace
     */
    WhitespaceComputer.prototype.insertWhitespace = function (afterLineNumber, ordinal, heightInPx) {
        afterLineNumber = afterLineNumber | 0;
        ordinal = ordinal | 0;
        heightInPx = heightInPx | 0;
        var id = (++this._lastWhitespaceId);
        var insertionIndex = WhitespaceComputer.findInsertionIndex(this._afterLineNumbers, afterLineNumber, this._ordinals, ordinal);
        this._insertWhitespaceAtIndex(id, insertionIndex, afterLineNumber, ordinal, heightInPx);
        return id;
    };
    WhitespaceComputer.prototype._insertWhitespaceAtIndex = function (id, insertIndex, afterLineNumber, ordinal, heightInPx) {
        id = id | 0;
        insertIndex = insertIndex | 0;
        afterLineNumber = afterLineNumber | 0;
        ordinal = ordinal | 0;
        heightInPx = heightInPx | 0;
        this._heights.splice(insertIndex, 0, heightInPx);
        this._ids.splice(insertIndex, 0, id);
        this._afterLineNumbers.splice(insertIndex, 0, afterLineNumber);
        this._ordinals.splice(insertIndex, 0, ordinal);
        this._prefixSum.splice(insertIndex, 0, 0);
        var keys = Object.keys(this._whitespaceId2Index);
        for (var i = 0, len = keys.length; i < len; i++) {
            var sid = keys[i];
            var oldIndex = this._whitespaceId2Index[sid];
            if (oldIndex >= insertIndex) {
                this._whitespaceId2Index[sid] = oldIndex + 1;
            }
        }
        this._whitespaceId2Index[id.toString()] = insertIndex;
        this._prefixSumValidIndex = Math.min(this._prefixSumValidIndex, insertIndex - 1);
    };
    /**
     * Change properties associated with a certain whitespace.
     */
    WhitespaceComputer.prototype.changeWhitespace = function (id, newAfterLineNumber, newHeight) {
        id = id | 0;
        newAfterLineNumber = newAfterLineNumber | 0;
        newHeight = newHeight | 0;
        var hasChanges = false;
        hasChanges = this.changeWhitespaceHeight(id, newHeight) || hasChanges;
        hasChanges = this.changeWhitespaceAfterLineNumber(id, newAfterLineNumber) || hasChanges;
        return hasChanges;
    };
    /**
     * Change the height of an existing whitespace
     *
     * @param id The whitespace to change
     * @param newHeightInPx The new height of the whitespace, in pixels
     * @return Returns true if the whitespace is found and if the new height is different than the old height
     */
    WhitespaceComputer.prototype.changeWhitespaceHeight = function (id, newHeightInPx) {
        id = id | 0;
        newHeightInPx = newHeightInPx | 0;
        var sid = id.toString();
        if (this._whitespaceId2Index.hasOwnProperty(sid)) {
            var index = this._whitespaceId2Index[sid];
            if (this._heights[index] !== newHeightInPx) {
                this._heights[index] = newHeightInPx;
                this._prefixSumValidIndex = Math.min(this._prefixSumValidIndex, index - 1);
                return true;
            }
        }
        return false;
    };
    /**
     * Change the line number after which an existing whitespace flows.
     *
     * @param id The whitespace to change
     * @param newAfterLineNumber The new line number the whitespace will follow
     * @return Returns true if the whitespace is found and if the new line number is different than the old line number
     */
    WhitespaceComputer.prototype.changeWhitespaceAfterLineNumber = function (id, newAfterLineNumber) {
        id = id | 0;
        newAfterLineNumber = newAfterLineNumber | 0;
        var sid = id.toString();
        if (this._whitespaceId2Index.hasOwnProperty(sid)) {
            var index = this._whitespaceId2Index[sid];
            if (this._afterLineNumbers[index] !== newAfterLineNumber) {
                // `afterLineNumber` changed for this whitespace
                // Record old ordinal
                var ordinal = this._ordinals[index];
                // Record old height
                var heightInPx = this._heights[index];
                // Since changing `afterLineNumber` can trigger a reordering, we're gonna remove this whitespace
                this.removeWhitespace(id);
                // And add it again
                var insertionIndex = WhitespaceComputer.findInsertionIndex(this._afterLineNumbers, newAfterLineNumber, this._ordinals, ordinal);
                this._insertWhitespaceAtIndex(id, insertionIndex, newAfterLineNumber, ordinal, heightInPx);
                return true;
            }
        }
        return false;
    };
    /**
     * Remove an existing whitespace.
     *
     * @param id The whitespace to remove
     * @return Returns true if the whitespace is found and it is removed.
     */
    WhitespaceComputer.prototype.removeWhitespace = function (id) {
        id = id | 0;
        var sid = id.toString();
        if (this._whitespaceId2Index.hasOwnProperty(sid)) {
            var index = this._whitespaceId2Index[sid];
            delete this._whitespaceId2Index[sid];
            this._removeWhitespaceAtIndex(index);
            return true;
        }
        return false;
    };
    WhitespaceComputer.prototype._removeWhitespaceAtIndex = function (removeIndex) {
        removeIndex = removeIndex | 0;
        this._heights.splice(removeIndex, 1);
        this._ids.splice(removeIndex, 1);
        this._afterLineNumbers.splice(removeIndex, 1);
        this._ordinals.splice(removeIndex, 1);
        this._prefixSum.splice(removeIndex, 1);
        this._prefixSumValidIndex = Math.min(this._prefixSumValidIndex, removeIndex - 1);
        var keys = Object.keys(this._whitespaceId2Index);
        for (var i = 0, len = keys.length; i < len; i++) {
            var sid = keys[i];
            var oldIndex = this._whitespaceId2Index[sid];
            if (oldIndex >= removeIndex) {
                this._whitespaceId2Index[sid] = oldIndex - 1;
            }
        }
    };
    /**
     * Notify the computer that lines have been deleted (a continuous zone of lines).
     * This gives it a chance to update `afterLineNumber` for whitespaces, giving the "sticky" characteristic.
     *
     * @param fromLineNumber The line number at which the deletion started, inclusive
     * @param toLineNumber The line number at which the deletion ended, inclusive
     */
    WhitespaceComputer.prototype.onLinesDeleted = function (fromLineNumber, toLineNumber) {
        fromLineNumber = fromLineNumber | 0;
        toLineNumber = toLineNumber | 0;
        for (var i = 0, len = this._afterLineNumbers.length; i < len; i++) {
            var afterLineNumber = this._afterLineNumbers[i];
            if (fromLineNumber <= afterLineNumber && afterLineNumber <= toLineNumber) {
                // The line this whitespace was after has been deleted
                //  => move whitespace to before first deleted line
                this._afterLineNumbers[i] = fromLineNumber - 1;
            }
            else if (afterLineNumber > toLineNumber) {
                // The line this whitespace was after has been moved up
                //  => move whitespace up
                this._afterLineNumbers[i] -= (toLineNumber - fromLineNumber + 1);
            }
        }
    };
    /**
     * Notify the computer that lines have been inserted (a continuous zone of lines).
     * This gives it a chance to update `afterLineNumber` for whitespaces, giving the "sticky" characteristic.
     *
     * @param fromLineNumber The line number at which the insertion started, inclusive
     * @param toLineNumber The line number at which the insertion ended, inclusive.
     */
    WhitespaceComputer.prototype.onLinesInserted = function (fromLineNumber, toLineNumber) {
        fromLineNumber = fromLineNumber | 0;
        toLineNumber = toLineNumber | 0;
        for (var i = 0, len = this._afterLineNumbers.length; i < len; i++) {
            var afterLineNumber = this._afterLineNumbers[i];
            if (fromLineNumber <= afterLineNumber) {
                this._afterLineNumbers[i] += (toLineNumber - fromLineNumber + 1);
            }
        }
    };
    /**
     * Get the sum of all the whitespaces.
     */
    WhitespaceComputer.prototype.getTotalHeight = function () {
        if (this._heights.length === 0) {
            return 0;
        }
        return this.getAccumulatedHeight(this._heights.length - 1);
    };
    /**
     * Return the sum of the heights of the whitespaces at [0..index].
     * This includes the whitespace at `index`.
     *
     * @param index The index of the whitespace.
     * @return The sum of the heights of all whitespaces before the one at `index`, including the one at `index`.
     */
    WhitespaceComputer.prototype.getAccumulatedHeight = function (index) {
        index = index | 0;
        var startIndex = Math.max(0, this._prefixSumValidIndex + 1);
        if (startIndex === 0) {
            this._prefixSum[0] = this._heights[0];
            startIndex++;
        }
        for (var i = startIndex; i <= index; i++) {
            this._prefixSum[i] = this._prefixSum[i - 1] + this._heights[i];
        }
        this._prefixSumValidIndex = Math.max(this._prefixSumValidIndex, index);
        return this._prefixSum[index];
    };
    /**
     * Find all whitespaces with `afterLineNumber` < `lineNumber` and return the sum of their heights.
     *
     * @param lineNumber The line number whitespaces should be before.
     * @return The sum of the heights of the whitespaces before `lineNumber`.
     */
    WhitespaceComputer.prototype.getAccumulatedHeightBeforeLineNumber = function (lineNumber) {
        lineNumber = lineNumber | 0;
        var lastWhitespaceBeforeLineNumber = this._findLastWhitespaceBeforeLineNumber(lineNumber);
        if (lastWhitespaceBeforeLineNumber === -1) {
            return 0;
        }
        return this.getAccumulatedHeight(lastWhitespaceBeforeLineNumber);
    };
    WhitespaceComputer.prototype._findLastWhitespaceBeforeLineNumber = function (lineNumber) {
        lineNumber = lineNumber | 0;
        // Find the whitespace before line number
        var afterLineNumbers = this._afterLineNumbers;
        var low = 0;
        var high = afterLineNumbers.length - 1;
        while (low <= high) {
            var delta = (high - low) | 0;
            var halfDelta = (delta / 2) | 0;
            var mid = (low + halfDelta) | 0;
            if (afterLineNumbers[mid] < lineNumber) {
                if (mid + 1 >= afterLineNumbers.length || afterLineNumbers[mid + 1] >= lineNumber) {
                    return mid;
                }
                else {
                    low = (mid + 1) | 0;
                }
            }
            else {
                high = (mid - 1) | 0;
            }
        }
        return -1;
    };
    WhitespaceComputer.prototype._findFirstWhitespaceAfterLineNumber = function (lineNumber) {
        lineNumber = lineNumber | 0;
        var lastWhitespaceBeforeLineNumber = this._findLastWhitespaceBeforeLineNumber(lineNumber);
        var firstWhitespaceAfterLineNumber = lastWhitespaceBeforeLineNumber + 1;
        if (firstWhitespaceAfterLineNumber < this._heights.length) {
            return firstWhitespaceAfterLineNumber;
        }
        return -1;
    };
    /**
     * Find the index of the first whitespace which has `afterLineNumber` >= `lineNumber`.
     * @return The index of the first whitespace with `afterLineNumber` >= `lineNumber` or -1 if no whitespace is found.
     */
    WhitespaceComputer.prototype.getFirstWhitespaceIndexAfterLineNumber = function (lineNumber) {
        lineNumber = lineNumber | 0;
        return this._findFirstWhitespaceAfterLineNumber(lineNumber);
    };
    /**
     * The number of whitespaces.
     */
    WhitespaceComputer.prototype.getCount = function () {
        return this._heights.length;
    };
    /**
     * Get the `afterLineNumber` for whitespace at index `index`.
     *
     * @param index The index of the whitespace.
     * @return `afterLineNumber` of whitespace at `index`.
     */
    WhitespaceComputer.prototype.getAfterLineNumberForWhitespaceIndex = function (index) {
        index = index | 0;
        return this._afterLineNumbers[index];
    };
    /**
     * Get the `id` for whitespace at index `index`.
     *
     * @param index The index of the whitespace.
     * @return `id` of whitespace at `index`.
     */
    WhitespaceComputer.prototype.getIdForWhitespaceIndex = function (index) {
        index = index | 0;
        return this._ids[index];
    };
    /**
     * Get the `height` for whitespace at index `index`.
     *
     * @param index The index of the whitespace.
     * @return `height` of whitespace at `index`.
     */
    WhitespaceComputer.prototype.getHeightForWhitespaceIndex = function (index) {
        index = index | 0;
        return this._heights[index];
    };
    /**
     * Get all whitespaces.
     */
    WhitespaceComputer.prototype.getWhitespaces = function (deviceLineHeight) {
        deviceLineHeight = deviceLineHeight | 0;
        var result = [];
        for (var i = 0; i < this._heights.length; i++) {
            result.push({
                id: this._ids[i],
                afterLineNumber: this._afterLineNumbers[i],
                heightInLines: this._heights[i] / deviceLineHeight
            });
        }
        return result;
    };
    return WhitespaceComputer;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
/**
 * Layouting of objects that take vertical space (by having a height) and push down other objects.
 *
 * These objects are basically either text (lines) or spaces between those lines (whitespaces).
 * This provides commodity operations for working with lines that contain whitespace that pushes lines lower (vertically).
 * This is written with no knowledge of an editor in mind.
 */
var LinesLayout = /** @class */ (function () {
    function LinesLayout(lineCount, lineHeight) {
        this._lineCount = lineCount;
        this._lineHeight = lineHeight;
        this._whitespaces = new WhitespaceComputer();
    }
    /**
     * Change the height of a line in pixels.
     */
    LinesLayout.prototype.setLineHeight = function (lineHeight) {
        this._lineHeight = lineHeight;
    };
    /**
     * Set the number of lines.
     *
     * @param lineCount New number of lines.
     */
    LinesLayout.prototype.onFlushed = function (lineCount) {
        this._lineCount = lineCount;
    };
    /**
     * Insert a new whitespace of a certain height after a line number.
     * The whitespace has a "sticky" characteristic.
     * Irrespective of edits above or below `afterLineNumber`, the whitespace will follow the initial line.
     *
     * @param afterLineNumber The conceptual position of this whitespace. The whitespace will follow this line as best as possible even when deleting/inserting lines above/below.
     * @param heightInPx The height of the whitespace, in pixels.
     * @return An id that can be used later to mutate or delete the whitespace
     */
    LinesLayout.prototype.insertWhitespace = function (afterLineNumber, ordinal, heightInPx) {
        return this._whitespaces.insertWhitespace(afterLineNumber, ordinal, heightInPx);
    };
    /**
     * Change properties associated with a certain whitespace.
     */
    LinesLayout.prototype.changeWhitespace = function (id, newAfterLineNumber, newHeight) {
        return this._whitespaces.changeWhitespace(id, newAfterLineNumber, newHeight);
    };
    /**
     * Remove an existing whitespace.
     *
     * @param id The whitespace to remove
     * @return Returns true if the whitespace is found and it is removed.
     */
    LinesLayout.prototype.removeWhitespace = function (id) {
        return this._whitespaces.removeWhitespace(id);
    };
    /**
     * Notify the layouter that lines have been deleted (a continuous zone of lines).
     *
     * @param fromLineNumber The line number at which the deletion started, inclusive
     * @param toLineNumber The line number at which the deletion ended, inclusive
     */
    LinesLayout.prototype.onLinesDeleted = function (fromLineNumber, toLineNumber) {
        this._lineCount -= (toLineNumber - fromLineNumber + 1);
        this._whitespaces.onLinesDeleted(fromLineNumber, toLineNumber);
    };
    /**
     * Notify the layouter that lines have been inserted (a continuous zone of lines).
     *
     * @param fromLineNumber The line number at which the insertion started, inclusive
     * @param toLineNumber The line number at which the insertion ended, inclusive.
     */
    LinesLayout.prototype.onLinesInserted = function (fromLineNumber, toLineNumber) {
        this._lineCount += (toLineNumber - fromLineNumber + 1);
        this._whitespaces.onLinesInserted(fromLineNumber, toLineNumber);
    };
    /**
     * Get the sum of heights for all objects.
     *
     * @return The sum of heights for all objects.
     */
    LinesLayout.prototype.getLinesTotalHeight = function () {
        var linesHeight = this._lineHeight * this._lineCount;
        var whitespacesHeight = this._whitespaces.getTotalHeight();
        return linesHeight + whitespacesHeight;
    };
    /**
     * Get the vertical offset (the sum of heights for all objects above) a certain line number.
     *
     * @param lineNumber The line number
     * @return The sum of heights for all objects above `lineNumber`.
     */
    LinesLayout.prototype.getVerticalOffsetForLineNumber = function (lineNumber) {
        lineNumber = lineNumber | 0;
        var previousLinesHeight;
        if (lineNumber > 1) {
            previousLinesHeight = this._lineHeight * (lineNumber - 1);
        }
        else {
            previousLinesHeight = 0;
        }
        var previousWhitespacesHeight = this._whitespaces.getAccumulatedHeightBeforeLineNumber(lineNumber);
        return previousLinesHeight + previousWhitespacesHeight;
    };
    /**
     * Returns the accumulated height of whitespaces before the given line number.
     *
     * @param lineNumber The line number
     */
    LinesLayout.prototype.getWhitespaceAccumulatedHeightBeforeLineNumber = function (lineNumber) {
        return this._whitespaces.getAccumulatedHeightBeforeLineNumber(lineNumber);
    };
    /**
     * Returns if there is any whitespace in the document.
     */
    LinesLayout.prototype.hasWhitespace = function () {
        return this._whitespaces.getCount() > 0;
    };
    /**
     * Check if `verticalOffset` is below all lines.
     */
    LinesLayout.prototype.isAfterLines = function (verticalOffset) {
        var totalHeight = this.getLinesTotalHeight();
        return verticalOffset > totalHeight;
    };
    /**
     * Find the first line number that is at or after vertical offset `verticalOffset`.
     * i.e. if getVerticalOffsetForLine(line) is x and getVerticalOffsetForLine(line + 1) is y, then
     * getLineNumberAtOrAfterVerticalOffset(i) = line, x <= i < y.
     *
     * @param verticalOffset The vertical offset to search at.
     * @return The line number at or after vertical offset `verticalOffset`.
     */
    LinesLayout.prototype.getLineNumberAtOrAfterVerticalOffset = function (verticalOffset) {
        verticalOffset = verticalOffset | 0;
        if (verticalOffset < 0) {
            return 1;
        }
        var linesCount = this._lineCount | 0;
        var lineHeight = this._lineHeight;
        var minLineNumber = 1;
        var maxLineNumber = linesCount;
        while (minLineNumber < maxLineNumber) {
            var midLineNumber = ((minLineNumber + maxLineNumber) / 2) | 0;
            var midLineNumberVerticalOffset = this.getVerticalOffsetForLineNumber(midLineNumber) | 0;
            if (verticalOffset >= midLineNumberVerticalOffset + lineHeight) {
                // vertical offset is after mid line number
                minLineNumber = midLineNumber + 1;
            }
            else if (verticalOffset >= midLineNumberVerticalOffset) {
                // Hit
                return midLineNumber;
            }
            else {
                // vertical offset is before mid line number, but mid line number could still be what we're searching for
                maxLineNumber = midLineNumber;
            }
        }
        if (minLineNumber > linesCount) {
            return linesCount;
        }
        return minLineNumber;
    };
    /**
     * Get all the lines and their relative vertical offsets that are positioned between `verticalOffset1` and `verticalOffset2`.
     *
     * @param verticalOffset1 The beginning of the viewport.
     * @param verticalOffset2 The end of the viewport.
     * @return A structure describing the lines positioned between `verticalOffset1` and `verticalOffset2`.
     */
    LinesLayout.prototype.getLinesViewportData = function (verticalOffset1, verticalOffset2) {
        verticalOffset1 = verticalOffset1 | 0;
        verticalOffset2 = verticalOffset2 | 0;
        var lineHeight = this._lineHeight;
        // Find first line number
        // We don't live in a perfect world, so the line number might start before or after verticalOffset1
        var startLineNumber = this.getLineNumberAtOrAfterVerticalOffset(verticalOffset1) | 0;
        var startLineNumberVerticalOffset = this.getVerticalOffsetForLineNumber(startLineNumber) | 0;
        var endLineNumber = this._lineCount | 0;
        // Also keep track of what whitespace we've got
        var whitespaceIndex = this._whitespaces.getFirstWhitespaceIndexAfterLineNumber(startLineNumber) | 0;
        var whitespaceCount = this._whitespaces.getCount() | 0;
        var currentWhitespaceHeight;
        var currentWhitespaceAfterLineNumber;
        if (whitespaceIndex === -1) {
            whitespaceIndex = whitespaceCount;
            currentWhitespaceAfterLineNumber = endLineNumber + 1;
            currentWhitespaceHeight = 0;
        }
        else {
            currentWhitespaceAfterLineNumber = this._whitespaces.getAfterLineNumberForWhitespaceIndex(whitespaceIndex) | 0;
            currentWhitespaceHeight = this._whitespaces.getHeightForWhitespaceIndex(whitespaceIndex) | 0;
        }
        var currentVerticalOffset = startLineNumberVerticalOffset;
        var currentLineRelativeOffset = currentVerticalOffset;
        // IE (all versions) cannot handle units above about 1,533,908 px, so every 500k pixels bring numbers down
        var STEP_SIZE = 500000;
        var bigNumbersDelta = 0;
        if (startLineNumberVerticalOffset >= STEP_SIZE) {
            // Compute a delta that guarantees that lines are positioned at `lineHeight` increments
            bigNumbersDelta = Math.floor(startLineNumberVerticalOffset / STEP_SIZE) * STEP_SIZE;
            bigNumbersDelta = Math.floor(bigNumbersDelta / lineHeight) * lineHeight;
            currentLineRelativeOffset -= bigNumbersDelta;
        }
        var linesOffsets = [];
        var verticalCenter = verticalOffset1 + (verticalOffset2 - verticalOffset1) / 2;
        var centeredLineNumber = -1;
        // Figure out how far the lines go
        for (var lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {
            if (centeredLineNumber === -1) {
                var currentLineTop = currentVerticalOffset;
                var currentLineBottom = currentVerticalOffset + lineHeight;
                if ((currentLineTop <= verticalCenter && verticalCenter < currentLineBottom) || currentLineTop > verticalCenter) {
                    centeredLineNumber = lineNumber;
                }
            }
            // Count current line height in the vertical offsets
            currentVerticalOffset += lineHeight;
            linesOffsets[lineNumber - startLineNumber] = currentLineRelativeOffset;
            // Next line starts immediately after this one
            currentLineRelativeOffset += lineHeight;
            while (currentWhitespaceAfterLineNumber === lineNumber) {
                // Push down next line with the height of the current whitespace
                currentLineRelativeOffset += currentWhitespaceHeight;
                // Count current whitespace in the vertical offsets
                currentVerticalOffset += currentWhitespaceHeight;
                whitespaceIndex++;
                if (whitespaceIndex >= whitespaceCount) {
                    currentWhitespaceAfterLineNumber = endLineNumber + 1;
                }
                else {
                    currentWhitespaceAfterLineNumber = this._whitespaces.getAfterLineNumberForWhitespaceIndex(whitespaceIndex) | 0;
                    currentWhitespaceHeight = this._whitespaces.getHeightForWhitespaceIndex(whitespaceIndex) | 0;
                }
            }
            if (currentVerticalOffset >= verticalOffset2) {
                // We have covered the entire viewport area, time to stop
                endLineNumber = lineNumber;
                break;
            }
        }
        if (centeredLineNumber === -1) {
            centeredLineNumber = endLineNumber;
        }
        var endLineNumberVerticalOffset = this.getVerticalOffsetForLineNumber(endLineNumber) | 0;
        var completelyVisibleStartLineNumber = startLineNumber;
        var completelyVisibleEndLineNumber = endLineNumber;
        if (completelyVisibleStartLineNumber < completelyVisibleEndLineNumber) {
            if (startLineNumberVerticalOffset < verticalOffset1) {
                completelyVisibleStartLineNumber++;
            }
        }
        if (completelyVisibleStartLineNumber < completelyVisibleEndLineNumber) {
            if (endLineNumberVerticalOffset + lineHeight > verticalOffset2) {
                completelyVisibleEndLineNumber--;
            }
        }
        return {
            bigNumbersDelta: bigNumbersDelta,
            startLineNumber: startLineNumber,
            endLineNumber: endLineNumber,
            relativeVerticalOffset: linesOffsets,
            centeredLineNumber: centeredLineNumber,
            completelyVisibleStartLineNumber: completelyVisibleStartLineNumber,
            completelyVisibleEndLineNumber: completelyVisibleEndLineNumber
        };
    };
    LinesLayout.prototype.getVerticalOffsetForWhitespaceIndex = function (whitespaceIndex) {
        whitespaceIndex = whitespaceIndex | 0;
        var afterLineNumber = this._whitespaces.getAfterLineNumberForWhitespaceIndex(whitespaceIndex);
        var previousLinesHeight;
        if (afterLineNumber >= 1) {
            previousLinesHeight = this._lineHeight * afterLineNumber;
        }
        else {
            previousLinesHeight = 0;
        }
        var previousWhitespacesHeight;
        if (whitespaceIndex > 0) {
            previousWhitespacesHeight = this._whitespaces.getAccumulatedHeight(whitespaceIndex - 1);
        }
        else {
            previousWhitespacesHeight = 0;
        }
        return previousLinesHeight + previousWhitespacesHeight;
    };
    LinesLayout.prototype.getWhitespaceIndexAtOrAfterVerticallOffset = function (verticalOffset) {
        verticalOffset = verticalOffset | 0;
        var midWhitespaceIndex, minWhitespaceIndex = 0, maxWhitespaceIndex = this._whitespaces.getCount() - 1, midWhitespaceVerticalOffset, midWhitespaceHeight;
        if (maxWhitespaceIndex < 0) {
            return -1;
        }
        // Special case: nothing to be found
        var maxWhitespaceVerticalOffset = this.getVerticalOffsetForWhitespaceIndex(maxWhitespaceIndex);
        var maxWhitespaceHeight = this._whitespaces.getHeightForWhitespaceIndex(maxWhitespaceIndex);
        if (verticalOffset >= maxWhitespaceVerticalOffset + maxWhitespaceHeight) {
            return -1;
        }
        while (minWhitespaceIndex < maxWhitespaceIndex) {
            midWhitespaceIndex = Math.floor((minWhitespaceIndex + maxWhitespaceIndex) / 2);
            midWhitespaceVerticalOffset = this.getVerticalOffsetForWhitespaceIndex(midWhitespaceIndex);
            midWhitespaceHeight = this._whitespaces.getHeightForWhitespaceIndex(midWhitespaceIndex);
            if (verticalOffset >= midWhitespaceVerticalOffset + midWhitespaceHeight) {
                // vertical offset is after whitespace
                minWhitespaceIndex = midWhitespaceIndex + 1;
            }
            else if (verticalOffset >= midWhitespaceVerticalOffset) {
                // Hit
                return midWhitespaceIndex;
            }
            else {
                // vertical offset is before whitespace, but midWhitespaceIndex might still be what we're searching for
                maxWhitespaceIndex = midWhitespaceIndex;
            }
        }
        return minWhitespaceIndex;
    };
    /**
     * Get exactly the whitespace that is layouted at `verticalOffset`.
     *
     * @param verticalOffset The vertical offset.
     * @return Precisely the whitespace that is layouted at `verticaloffset` or null.
     */
    LinesLayout.prototype.getWhitespaceAtVerticalOffset = function (verticalOffset) {
        verticalOffset = verticalOffset | 0;
        var candidateIndex = this.getWhitespaceIndexAtOrAfterVerticallOffset(verticalOffset);
        if (candidateIndex < 0) {
            return null;
        }
        if (candidateIndex >= this._whitespaces.getCount()) {
            return null;
        }
        var candidateTop = this.getVerticalOffsetForWhitespaceIndex(candidateIndex);
        if (candidateTop > verticalOffset) {
            return null;
        }
        var candidateHeight = this._whitespaces.getHeightForWhitespaceIndex(candidateIndex);
        var candidateId = this._whitespaces.getIdForWhitespaceIndex(candidateIndex);
        var candidateAfterLineNumber = this._whitespaces.getAfterLineNumberForWhitespaceIndex(candidateIndex);
        return {
            id: candidateId,
            afterLineNumber: candidateAfterLineNumber,
            verticalOffset: candidateTop,
            height: candidateHeight
        };
    };
    /**
     * Get a list of whitespaces that are positioned between `verticalOffset1` and `verticalOffset2`.
     *
     * @param verticalOffset1 The beginning of the viewport.
     * @param verticalOffset2 The end of the viewport.
     * @return An array with all the whitespaces in the viewport. If no whitespace is in viewport, the array is empty.
     */
    LinesLayout.prototype.getWhitespaceViewportData = function (verticalOffset1, verticalOffset2) {
        verticalOffset1 = verticalOffset1 | 0;
        verticalOffset2 = verticalOffset2 | 0;
        var startIndex = this.getWhitespaceIndexAtOrAfterVerticallOffset(verticalOffset1);
        var endIndex = this._whitespaces.getCount() - 1;
        if (startIndex < 0) {
            return [];
        }
        var result = [];
        for (var i = startIndex; i <= endIndex; i++) {
            var top_1 = this.getVerticalOffsetForWhitespaceIndex(i);
            var height = this._whitespaces.getHeightForWhitespaceIndex(i);
            if (top_1 >= verticalOffset2) {
                break;
            }
            result.push({
                id: this._whitespaces.getIdForWhitespaceIndex(i),
                afterLineNumber: this._whitespaces.getAfterLineNumberForWhitespaceIndex(i),
                verticalOffset: top_1,
                height: height
            });
        }
        return result;
    };
    /**
     * Get all whitespaces.
     */
    LinesLayout.prototype.getWhitespaces = function () {
        return this._whitespaces.getWhitespaces(this._lineHeight);
    };
    return LinesLayout;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$e = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var SMOOTH_SCROLLING_TIME = 125;
var ViewLayout = /** @class */ (function (_super) {
    __extends$e(ViewLayout, _super);
    function ViewLayout(configuration, lineCount, scheduleAtNextAnimationFrame) {
        var _this = _super.call(this) || this;
        _this._configuration = configuration;
        _this._linesLayout = new LinesLayout(lineCount, _this._configuration.editor.lineHeight);
        _this.scrollable = _this._register(new Scrollable(0, scheduleAtNextAnimationFrame));
        _this._configureSmoothScrollDuration();
        _this.scrollable.setScrollDimensions({
            width: configuration.editor.layoutInfo.contentWidth,
            height: configuration.editor.layoutInfo.contentHeight
        });
        _this.onDidScroll = _this.scrollable.onScroll;
        _this._updateHeight();
        return _this;
    }
    ViewLayout.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
    };
    ViewLayout.prototype.onHeightMaybeChanged = function () {
        this._updateHeight();
    };
    ViewLayout.prototype._configureSmoothScrollDuration = function () {
        this.scrollable.setSmoothScrollDuration(this._configuration.editor.viewInfo.smoothScrolling ? SMOOTH_SCROLLING_TIME : 0);
    };
    // ---- begin view event handlers
    ViewLayout.prototype.onConfigurationChanged = function (e) {
        if (e.lineHeight) {
            this._linesLayout.setLineHeight(this._configuration.editor.lineHeight);
        }
        if (e.layoutInfo) {
            this.scrollable.setScrollDimensions({
                width: this._configuration.editor.layoutInfo.contentWidth,
                height: this._configuration.editor.layoutInfo.contentHeight
            });
        }
        if (e.viewInfo) {
            this._configureSmoothScrollDuration();
        }
        this._updateHeight();
    };
    ViewLayout.prototype.onFlushed = function (lineCount) {
        this._linesLayout.onFlushed(lineCount);
    };
    ViewLayout.prototype.onLinesDeleted = function (fromLineNumber, toLineNumber) {
        this._linesLayout.onLinesDeleted(fromLineNumber, toLineNumber);
    };
    ViewLayout.prototype.onLinesInserted = function (fromLineNumber, toLineNumber) {
        this._linesLayout.onLinesInserted(fromLineNumber, toLineNumber);
    };
    // ---- end view event handlers
    ViewLayout.prototype._getHorizontalScrollbarHeight = function (scrollDimensions) {
        if (this._configuration.editor.viewInfo.scrollbar.horizontal === ScrollbarVisibility.Hidden) {
            // horizontal scrollbar not visible
            return 0;
        }
        if (scrollDimensions.width >= scrollDimensions.scrollWidth) {
            // horizontal scrollbar not visible
            return 0;
        }
        return this._configuration.editor.viewInfo.scrollbar.horizontalScrollbarSize;
    };
    ViewLayout.prototype._getTotalHeight = function () {
        var scrollDimensions = this.scrollable.getScrollDimensions();
        var result = this._linesLayout.getLinesTotalHeight();
        if (this._configuration.editor.viewInfo.scrollBeyondLastLine) {
            result += scrollDimensions.height - this._configuration.editor.lineHeight;
        }
        else {
            result += this._getHorizontalScrollbarHeight(scrollDimensions);
        }
        return Math.max(scrollDimensions.height, result);
    };
    ViewLayout.prototype._updateHeight = function () {
        this.scrollable.setScrollDimensions({
            scrollHeight: this._getTotalHeight()
        });
    };
    // ---- Layouting logic
    ViewLayout.prototype.getCurrentViewport = function () {
        var scrollDimensions = this.scrollable.getScrollDimensions();
        var currentScrollPosition = this.scrollable.getCurrentScrollPosition();
        return new Viewport(currentScrollPosition.scrollTop, currentScrollPosition.scrollLeft, scrollDimensions.width, scrollDimensions.height);
    };
    ViewLayout.prototype.getFutureViewport = function () {
        var scrollDimensions = this.scrollable.getScrollDimensions();
        var currentScrollPosition = this.scrollable.getFutureScrollPosition();
        return new Viewport(currentScrollPosition.scrollTop, currentScrollPosition.scrollLeft, scrollDimensions.width, scrollDimensions.height);
    };
    ViewLayout.prototype._computeScrollWidth = function (maxLineWidth, viewportWidth) {
        var isViewportWrapping = this._configuration.editor.wrappingInfo.isViewportWrapping;
        if (!isViewportWrapping) {
            return Math.max(maxLineWidth + ViewLayout.LINES_HORIZONTAL_EXTRA_PX, viewportWidth);
        }
        return Math.max(maxLineWidth, viewportWidth);
    };
    ViewLayout.prototype.onMaxLineWidthChanged = function (maxLineWidth) {
        var newScrollWidth = this._computeScrollWidth(maxLineWidth, this.getCurrentViewport().width);
        this.scrollable.setScrollDimensions({
            scrollWidth: newScrollWidth
        });
        // The height might depend on the fact that there is a horizontal scrollbar or not
        this._updateHeight();
    };
    // ---- view state
    ViewLayout.prototype.saveState = function () {
        var currentScrollPosition = this.scrollable.getFutureScrollPosition();
        var scrollTop = currentScrollPosition.scrollTop;
        var firstLineNumberInViewport = this._linesLayout.getLineNumberAtOrAfterVerticalOffset(scrollTop);
        var whitespaceAboveFirstLine = this._linesLayout.getWhitespaceAccumulatedHeightBeforeLineNumber(firstLineNumberInViewport);
        return {
            scrollTop: scrollTop,
            scrollTopWithoutViewZones: scrollTop - whitespaceAboveFirstLine,
            scrollLeft: currentScrollPosition.scrollLeft
        };
    };
    // ---- IVerticalLayoutProvider
    ViewLayout.prototype.addWhitespace = function (afterLineNumber, ordinal, height) {
        return this._linesLayout.insertWhitespace(afterLineNumber, ordinal, height);
    };
    ViewLayout.prototype.changeWhitespace = function (id, newAfterLineNumber, newHeight) {
        return this._linesLayout.changeWhitespace(id, newAfterLineNumber, newHeight);
    };
    ViewLayout.prototype.removeWhitespace = function (id) {
        return this._linesLayout.removeWhitespace(id);
    };
    ViewLayout.prototype.getVerticalOffsetForLineNumber = function (lineNumber) {
        return this._linesLayout.getVerticalOffsetForLineNumber(lineNumber);
    };
    ViewLayout.prototype.isAfterLines = function (verticalOffset) {
        return this._linesLayout.isAfterLines(verticalOffset);
    };
    ViewLayout.prototype.getLineNumberAtVerticalOffset = function (verticalOffset) {
        return this._linesLayout.getLineNumberAtOrAfterVerticalOffset(verticalOffset);
    };
    ViewLayout.prototype.getWhitespaceAtVerticalOffset = function (verticalOffset) {
        return this._linesLayout.getWhitespaceAtVerticalOffset(verticalOffset);
    };
    ViewLayout.prototype.getLinesViewportData = function () {
        var visibleBox = this.getCurrentViewport();
        return this._linesLayout.getLinesViewportData(visibleBox.top, visibleBox.top + visibleBox.height);
    };
    ViewLayout.prototype.getLinesViewportDataAtScrollTop = function (scrollTop) {
        // do some minimal validations on scrollTop
        var scrollDimensions = this.scrollable.getScrollDimensions();
        if (scrollTop + scrollDimensions.height > scrollDimensions.scrollHeight) {
            scrollTop = scrollDimensions.scrollHeight - scrollDimensions.height;
        }
        if (scrollTop < 0) {
            scrollTop = 0;
        }
        return this._linesLayout.getLinesViewportData(scrollTop, scrollTop + scrollDimensions.height);
    };
    ViewLayout.prototype.getWhitespaceViewportData = function () {
        var visibleBox = this.getCurrentViewport();
        return this._linesLayout.getWhitespaceViewportData(visibleBox.top, visibleBox.top + visibleBox.height);
    };
    ViewLayout.prototype.getWhitespaces = function () {
        return this._linesLayout.getWhitespaces();
    };
    // ---- IScrollingProvider
    ViewLayout.prototype.getScrollWidth = function () {
        var scrollDimensions = this.scrollable.getScrollDimensions();
        return scrollDimensions.scrollWidth;
    };
    ViewLayout.prototype.getScrollHeight = function () {
        var scrollDimensions = this.scrollable.getScrollDimensions();
        return scrollDimensions.scrollHeight;
    };
    ViewLayout.prototype.getCurrentScrollLeft = function () {
        var currentScrollPosition = this.scrollable.getCurrentScrollPosition();
        return currentScrollPosition.scrollLeft;
    };
    ViewLayout.prototype.getCurrentScrollTop = function () {
        var currentScrollPosition = this.scrollable.getCurrentScrollPosition();
        return currentScrollPosition.scrollTop;
    };
    ViewLayout.prototype.validateScrollPosition = function (scrollPosition) {
        return this.scrollable.validateScrollPosition(scrollPosition);
    };
    ViewLayout.prototype.setScrollPositionNow = function (position) {
        this.scrollable.setScrollPositionNow(position);
    };
    ViewLayout.prototype.setScrollPositionSmooth = function (position) {
        this.scrollable.setScrollPositionSmooth(position);
    };
    ViewLayout.prototype.deltaScrollNow = function (deltaScrollLeft, deltaScrollTop) {
        var currentScrollPosition = this.scrollable.getCurrentScrollPosition();
        this.scrollable.setScrollPositionNow({
            scrollLeft: currentScrollPosition.scrollLeft + deltaScrollLeft,
            scrollTop: currentScrollPosition.scrollTop + deltaScrollTop
        });
    };
    ViewLayout.LINES_HORIZONTAL_EXTRA_PX = 30;
    return ViewLayout;
}(Disposable));

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$f = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var ViewModel = /** @class */ (function (_super) {
    __extends$f(ViewModel, _super);
    function ViewModel(editorId, configuration, model, scheduleAtNextAnimationFrame) {
        var _this = _super.call(this) || this;
        _this.editorId = editorId;
        _this.configuration = configuration;
        _this.model = model;
        _this.hasFocus = false;
        _this.viewportStartLine = -1;
        _this.viewportStartLineTrackedRange = null;
        _this.viewportStartLineTop = 0;
        if (_this.model.isTooLargeForTokenization()) {
            _this.lines = new IdentityLinesCollection(_this.model);
        }
        else {
            var conf = _this.configuration.editor;
            var hardWrappingLineMapperFactory = new CharacterHardWrappingLineMapperFactory(conf.wrappingInfo.wordWrapBreakBeforeCharacters, conf.wrappingInfo.wordWrapBreakAfterCharacters, conf.wrappingInfo.wordWrapBreakObtrusiveCharacters);
            _this.lines = new SplitLinesCollection(_this.model, hardWrappingLineMapperFactory, _this.model.getOptions().tabSize, conf.wrappingInfo.wrappingColumn, conf.fontInfo.typicalFullwidthCharacterWidth / conf.fontInfo.typicalHalfwidthCharacterWidth, conf.wrappingInfo.wrappingIndent);
        }
        _this.coordinatesConverter = _this.lines.createCoordinatesConverter();
        _this.viewLayout = _this._register(new ViewLayout(_this.configuration, _this.getLineCount(), scheduleAtNextAnimationFrame));
        _this._register(_this.viewLayout.onDidScroll(function (e) {
            try {
                var eventsCollector = _this._beginEmit();
                eventsCollector.emit(new ViewScrollChangedEvent(e));
            }
            finally {
                _this._endEmit();
            }
        }));
        _this.decorations = new ViewModelDecorations(_this.editorId, _this.model, _this.configuration, _this.lines, _this.coordinatesConverter);
        _this._registerModelEvents();
        _this._register(_this.configuration.onDidChange(function (e) {
            try {
                var eventsCollector = _this._beginEmit();
                _this._onConfigurationChanged(eventsCollector, e);
            }
            finally {
                _this._endEmit();
            }
        }));
        _this._register(MinimapTokensColorTracker.getInstance().onDidChange(function () {
            try {
                var eventsCollector = _this._beginEmit();
                eventsCollector.emit(new ViewTokensColorsChangedEvent());
            }
            finally {
                _this._endEmit();
            }
        }));
        return _this;
    }
    ViewModel.prototype.dispose = function () {
        // First remove listeners, as disposing the lines might end up sending
        // model decoration changed events ... and we no longer care about them ...
        _super.prototype.dispose.call(this);
        this.decorations.dispose();
        this.lines.dispose();
        this.viewportStartLineTrackedRange = this.model._setTrackedRange(this.viewportStartLineTrackedRange, null, TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges);
    };
    ViewModel.prototype.setHasFocus = function (hasFocus) {
        this.hasFocus = hasFocus;
    };
    ViewModel.prototype._onConfigurationChanged = function (eventsCollector, e) {
        // We might need to restore the current centered view range, so save it (if available)
        var previousViewportStartModelPosition = null;
        if (this.viewportStartLine !== -1) {
            var previousViewportStartViewPosition = new Position(this.viewportStartLine, this.getLineMinColumn(this.viewportStartLine));
            previousViewportStartModelPosition = this.coordinatesConverter.convertViewPositionToModelPosition(previousViewportStartViewPosition);
        }
        var restorePreviousViewportStart = false;
        var conf = this.configuration.editor;
        if (this.lines.setWrappingSettings(conf.wrappingInfo.wrappingIndent, conf.wrappingInfo.wrappingColumn, conf.fontInfo.typicalFullwidthCharacterWidth / conf.fontInfo.typicalHalfwidthCharacterWidth)) {
            eventsCollector.emit(new ViewFlushedEvent());
            eventsCollector.emit(new ViewLineMappingChangedEvent());
            eventsCollector.emit(new ViewDecorationsChangedEvent());
            this.decorations.onLineMappingChanged();
            this.viewLayout.onFlushed(this.getLineCount());
            if (this.viewLayout.getCurrentScrollTop() !== 0) {
                // Never change the scroll position from 0 to something else...
                restorePreviousViewportStart = true;
            }
        }
        if (e.readOnly) {
            // Must read again all decorations due to readOnly filtering
            this.decorations.reset();
            eventsCollector.emit(new ViewDecorationsChangedEvent());
        }
        eventsCollector.emit(new ViewConfigurationChangedEvent(e));
        this.viewLayout.onConfigurationChanged(e);
        if (restorePreviousViewportStart && previousViewportStartModelPosition) {
            var viewPosition = this.coordinatesConverter.convertModelPositionToViewPosition(previousViewportStartModelPosition);
            var viewPositionTop = this.viewLayout.getVerticalOffsetForLineNumber(viewPosition.lineNumber);
            this.viewLayout.deltaScrollNow(0, viewPositionTop - this.viewportStartLineTop);
        }
    };
    ViewModel.prototype._registerModelEvents = function () {
        var _this = this;
        this._register(this.model.onDidChangeRawContentFast(function (e) {
            try {
                var eventsCollector = _this._beginEmit();
                var hadOtherModelChange = false;
                var hadModelLineChangeThatChangedLineMapping = false;
                var changes = e.changes;
                var versionId = e.versionId;
                for (var j = 0, lenJ = changes.length; j < lenJ; j++) {
                    var change = changes[j];
                    switch (change.changeType) {
                        case 1 /* Flush */: {
                            _this.lines.onModelFlushed();
                            eventsCollector.emit(new ViewFlushedEvent());
                            _this.decorations.reset();
                            _this.viewLayout.onFlushed(_this.getLineCount());
                            hadOtherModelChange = true;
                            break;
                        }
                        case 3 /* LinesDeleted */: {
                            var linesDeletedEvent = _this.lines.onModelLinesDeleted(versionId, change.fromLineNumber, change.toLineNumber);
                            if (linesDeletedEvent !== null) {
                                eventsCollector.emit(linesDeletedEvent);
                                _this.viewLayout.onLinesDeleted(linesDeletedEvent.fromLineNumber, linesDeletedEvent.toLineNumber);
                            }
                            hadOtherModelChange = true;
                            break;
                        }
                        case 4 /* LinesInserted */: {
                            var linesInsertedEvent = _this.lines.onModelLinesInserted(versionId, change.fromLineNumber, change.toLineNumber, change.detail);
                            if (linesInsertedEvent !== null) {
                                eventsCollector.emit(linesInsertedEvent);
                                _this.viewLayout.onLinesInserted(linesInsertedEvent.fromLineNumber, linesInsertedEvent.toLineNumber);
                            }
                            hadOtherModelChange = true;
                            break;
                        }
                        case 2 /* LineChanged */: {
                            var _a = _this.lines.onModelLineChanged(versionId, change.lineNumber, change.detail), lineMappingChanged = _a[0], linesChangedEvent = _a[1], linesInsertedEvent = _a[2], linesDeletedEvent = _a[3];
                            hadModelLineChangeThatChangedLineMapping = lineMappingChanged;
                            if (linesChangedEvent) {
                                eventsCollector.emit(linesChangedEvent);
                            }
                            if (linesInsertedEvent) {
                                eventsCollector.emit(linesInsertedEvent);
                                _this.viewLayout.onLinesInserted(linesInsertedEvent.fromLineNumber, linesInsertedEvent.toLineNumber);
                            }
                            if (linesDeletedEvent) {
                                eventsCollector.emit(linesDeletedEvent);
                                _this.viewLayout.onLinesDeleted(linesDeletedEvent.fromLineNumber, linesDeletedEvent.toLineNumber);
                            }
                            break;
                        }
                        case 5 /* EOLChanged */: {
                            // Nothing to do. The new version will be accepted below
                            break;
                        }
                    }
                }
                _this.lines.acceptVersionId(versionId);
                _this.viewLayout.onHeightMaybeChanged();
                if (!hadOtherModelChange && hadModelLineChangeThatChangedLineMapping) {
                    eventsCollector.emit(new ViewLineMappingChangedEvent());
                    eventsCollector.emit(new ViewDecorationsChangedEvent());
                    _this.decorations.onLineMappingChanged();
                }
            }
            finally {
                _this._endEmit();
            }
            // Update the configuration and reset the centered view line
            _this.viewportStartLine = -1;
            _this.configuration.setMaxLineNumber(_this.model.getLineCount());
            // Recover viewport
            if (!_this.hasFocus && _this.model.getAttachedEditorCount() >= 2 && _this.viewportStartLineTrackedRange) {
                var modelRange = _this.model._getTrackedRange(_this.viewportStartLineTrackedRange);
                if (modelRange) {
                    var viewPosition = _this.coordinatesConverter.convertModelPositionToViewPosition(modelRange.getStartPosition());
                    var viewPositionTop = _this.viewLayout.getVerticalOffsetForLineNumber(viewPosition.lineNumber);
                    _this.viewLayout.deltaScrollNow(0, viewPositionTop - _this.viewportStartLineTop);
                }
            }
        }));
        this._register(this.model.onDidChangeTokens(function (e) {
            var viewRanges = [];
            for (var j = 0, lenJ = e.ranges.length; j < lenJ; j++) {
                var modelRange = e.ranges[j];
                var viewStartLineNumber = _this.coordinatesConverter.convertModelPositionToViewPosition(new Position(modelRange.fromLineNumber, 1)).lineNumber;
                var viewEndLineNumber = _this.coordinatesConverter.convertModelPositionToViewPosition(new Position(modelRange.toLineNumber, _this.model.getLineMaxColumn(modelRange.toLineNumber))).lineNumber;
                viewRanges[j] = {
                    fromLineNumber: viewStartLineNumber,
                    toLineNumber: viewEndLineNumber
                };
            }
            try {
                var eventsCollector = _this._beginEmit();
                eventsCollector.emit(new ViewTokensChangedEvent(viewRanges));
            }
            finally {
                _this._endEmit();
            }
        }));
        this._register(this.model.onDidChangeLanguageConfiguration(function (e) {
            try {
                var eventsCollector = _this._beginEmit();
                eventsCollector.emit(new ViewLanguageConfigurationEvent());
            }
            finally {
                _this._endEmit();
            }
        }));
        this._register(this.model.onDidChangeOptions(function (e) {
            // A tab size change causes a line mapping changed event => all view parts will repaint OK, no further event needed here
            if (_this.lines.setTabSize(_this.model.getOptions().tabSize)) {
                _this.decorations.onLineMappingChanged();
                _this.viewLayout.onFlushed(_this.getLineCount());
                try {
                    var eventsCollector = _this._beginEmit();
                    eventsCollector.emit(new ViewFlushedEvent());
                    eventsCollector.emit(new ViewLineMappingChangedEvent());
                    eventsCollector.emit(new ViewDecorationsChangedEvent());
                }
                finally {
                    _this._endEmit();
                }
            }
        }));
        this._register(this.model.onDidChangeDecorations(function (e) {
            _this.decorations.onModelDecorationsChanged();
            try {
                var eventsCollector = _this._beginEmit();
                eventsCollector.emit(new ViewDecorationsChangedEvent());
            }
            finally {
                _this._endEmit();
            }
        }));
    };
    ViewModel.prototype.setHiddenAreas = function (ranges) {
        try {
            var eventsCollector = this._beginEmit();
            var lineMappingChanged = this.lines.setHiddenAreas(ranges);
            if (lineMappingChanged) {
                eventsCollector.emit(new ViewFlushedEvent());
                eventsCollector.emit(new ViewLineMappingChangedEvent());
                eventsCollector.emit(new ViewDecorationsChangedEvent());
                this.decorations.onLineMappingChanged();
                this.viewLayout.onFlushed(this.getLineCount());
            }
        }
        finally {
            this._endEmit();
        }
    };
    ViewModel.prototype.getVisibleRanges = function () {
        var visibleViewRange = this.getCompletelyVisibleViewRange();
        var visibleRange = this.coordinatesConverter.convertViewRangeToModelRange(visibleViewRange);
        var hiddenAreas = this.lines.getHiddenAreas();
        if (hiddenAreas.length === 0) {
            return [visibleRange];
        }
        var result = [], resultLen = 0;
        var startLineNumber = visibleRange.startLineNumber;
        var startColumn = visibleRange.startColumn;
        var endLineNumber = visibleRange.endLineNumber;
        var endColumn = visibleRange.endColumn;
        for (var i = 0, len = hiddenAreas.length; i < len; i++) {
            var hiddenStartLineNumber = hiddenAreas[i].startLineNumber;
            var hiddenEndLineNumber = hiddenAreas[i].endLineNumber;
            if (hiddenEndLineNumber < startLineNumber) {
                continue;
            }
            if (hiddenStartLineNumber > endLineNumber) {
                continue;
            }
            if (startLineNumber < hiddenStartLineNumber) {
                result[resultLen++] = new Range(startLineNumber, startColumn, hiddenStartLineNumber - 1, this.model.getLineMaxColumn(hiddenStartLineNumber - 1));
            }
            startLineNumber = hiddenEndLineNumber + 1;
            startColumn = 1;
        }
        if (startLineNumber < endLineNumber || (startLineNumber === endLineNumber && startColumn < endColumn)) {
            result[resultLen++] = new Range(startLineNumber, startColumn, endLineNumber, endColumn);
        }
        return result;
    };
    ViewModel.prototype.getCompletelyVisibleViewRange = function () {
        var partialData = this.viewLayout.getLinesViewportData();
        var startViewLineNumber = partialData.completelyVisibleStartLineNumber;
        var endViewLineNumber = partialData.completelyVisibleEndLineNumber;
        return new Range(startViewLineNumber, this.getLineMinColumn(startViewLineNumber), endViewLineNumber, this.getLineMaxColumn(endViewLineNumber));
    };
    ViewModel.prototype.getCompletelyVisibleViewRangeAtScrollTop = function (scrollTop) {
        var partialData = this.viewLayout.getLinesViewportDataAtScrollTop(scrollTop);
        var startViewLineNumber = partialData.completelyVisibleStartLineNumber;
        var endViewLineNumber = partialData.completelyVisibleEndLineNumber;
        return new Range(startViewLineNumber, this.getLineMinColumn(startViewLineNumber), endViewLineNumber, this.getLineMaxColumn(endViewLineNumber));
    };
    ViewModel.prototype.saveState = function () {
        var compatViewState = this.viewLayout.saveState();
        var scrollTop = compatViewState.scrollTop;
        var firstViewLineNumber = this.viewLayout.getLineNumberAtVerticalOffset(scrollTop);
        var firstPosition = this.coordinatesConverter.convertViewPositionToModelPosition(new Position(firstViewLineNumber, this.getLineMinColumn(firstViewLineNumber)));
        var firstPositionDeltaTop = this.viewLayout.getVerticalOffsetForLineNumber(firstViewLineNumber) - scrollTop;
        return {
            scrollLeft: compatViewState.scrollLeft,
            firstPosition: firstPosition,
            firstPositionDeltaTop: firstPositionDeltaTop
        };
    };
    ViewModel.prototype.reduceRestoreState = function (state) {
        if (typeof state.firstPosition === 'undefined') {
            // This is a view state serialized by an older version
            return this._reduceRestoreStateCompatibility(state);
        }
        var modelPosition = this.model.validatePosition(state.firstPosition);
        var viewPosition = this.coordinatesConverter.convertModelPositionToViewPosition(modelPosition);
        var scrollTop = this.viewLayout.getVerticalOffsetForLineNumber(viewPosition.lineNumber) - state.firstPositionDeltaTop;
        return {
            scrollLeft: state.scrollLeft,
            scrollTop: scrollTop
        };
    };
    ViewModel.prototype._reduceRestoreStateCompatibility = function (state) {
        return {
            scrollLeft: state.scrollLeft,
            scrollTop: state.scrollTopWithoutViewZones
        };
    };
    ViewModel.prototype.getTabSize = function () {
        return this.model.getOptions().tabSize;
    };
    ViewModel.prototype.getLineCount = function () {
        return this.lines.getViewLineCount();
    };
    /**
     * Gives a hint that a lot of requests are about to come in for these line numbers.
     */
    ViewModel.prototype.setViewport = function (startLineNumber, endLineNumber, centeredLineNumber) {
        this.lines.warmUpLookupCache(startLineNumber, endLineNumber);
        this.viewportStartLine = startLineNumber;
        var position = this.coordinatesConverter.convertViewPositionToModelPosition(new Position(startLineNumber, this.getLineMinColumn(startLineNumber)));
        this.viewportStartLineTrackedRange = this.model._setTrackedRange(this.viewportStartLineTrackedRange, new Range(position.lineNumber, position.column, position.lineNumber, position.column), TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges);
        this.viewportStartLineTop = this.viewLayout.getVerticalOffsetForLineNumber(startLineNumber);
    };
    ViewModel.prototype.getActiveIndentGuide = function (lineNumber, minLineNumber, maxLineNumber) {
        return this.lines.getActiveIndentGuide(lineNumber, minLineNumber, maxLineNumber);
    };
    ViewModel.prototype.getLinesIndentGuides = function (startLineNumber, endLineNumber) {
        return this.lines.getViewLinesIndentGuides(startLineNumber, endLineNumber);
    };
    ViewModel.prototype.getLineContent = function (lineNumber) {
        return this.lines.getViewLineContent(lineNumber);
    };
    ViewModel.prototype.getLineLength = function (lineNumber) {
        return this.lines.getViewLineLength(lineNumber);
    };
    ViewModel.prototype.getLineMinColumn = function (lineNumber) {
        return this.lines.getViewLineMinColumn(lineNumber);
    };
    ViewModel.prototype.getLineMaxColumn = function (lineNumber) {
        return this.lines.getViewLineMaxColumn(lineNumber);
    };
    ViewModel.prototype.getLineFirstNonWhitespaceColumn = function (lineNumber) {
        var result = firstNonWhitespaceIndex(this.getLineContent(lineNumber));
        if (result === -1) {
            return 0;
        }
        return result + 1;
    };
    ViewModel.prototype.getLineLastNonWhitespaceColumn = function (lineNumber) {
        var result = lastNonWhitespaceIndex(this.getLineContent(lineNumber));
        if (result === -1) {
            return 0;
        }
        return result + 2;
    };
    ViewModel.prototype.getDecorationsInViewport = function (visibleRange) {
        return this.decorations.getDecorationsViewportData(visibleRange).decorations;
    };
    ViewModel.prototype.getViewLineRenderingData = function (visibleRange, lineNumber) {
        var mightContainRTL = this.model.mightContainRTL();
        var mightContainNonBasicASCII = this.model.mightContainNonBasicASCII();
        var tabSize = this.getTabSize();
        var lineData = this.lines.getViewLineData(lineNumber);
        var allInlineDecorations = this.decorations.getDecorationsViewportData(visibleRange).inlineDecorations;
        var inlineDecorations = allInlineDecorations[lineNumber - visibleRange.startLineNumber];
        return new ViewLineRenderingData(lineData.minColumn, lineData.maxColumn, lineData.content, mightContainRTL, mightContainNonBasicASCII, lineData.tokens, inlineDecorations, tabSize);
    };
    ViewModel.prototype.getViewLineData = function (lineNumber) {
        return this.lines.getViewLineData(lineNumber);
    };
    ViewModel.prototype.getMinimapLinesRenderingData = function (startLineNumber, endLineNumber, needed) {
        var result = this.lines.getViewLinesData(startLineNumber, endLineNumber, needed);
        return new MinimapLinesRenderingData(this.getTabSize(), result);
    };
    ViewModel.prototype.getAllOverviewRulerDecorations = function (theme) {
        return this.lines.getAllOverviewRulerDecorations(this.editorId, this.configuration.editor.readOnly, theme);
    };
    ViewModel.prototype.invalidateOverviewRulerColorCache = function () {
        var decorations = this.model.getOverviewRulerDecorations();
        for (var i = 0, len = decorations.length; i < len; i++) {
            var decoration = decorations[i];
            var opts = decoration.options.overviewRuler;
            opts._resolvedColor = null;
        }
    };
    ViewModel.prototype.getValueInRange = function (range, eol) {
        var modelRange = this.coordinatesConverter.convertViewRangeToModelRange(range);
        return this.model.getValueInRange(modelRange, eol);
    };
    ViewModel.prototype.getModelLineMaxColumn = function (modelLineNumber) {
        return this.model.getLineMaxColumn(modelLineNumber);
    };
    ViewModel.prototype.validateModelPosition = function (position) {
        return this.model.validatePosition(position);
    };
    ViewModel.prototype.deduceModelPositionRelativeToViewPosition = function (viewAnchorPosition, deltaOffset, lineFeedCnt) {
        var modelAnchor = this.coordinatesConverter.convertViewPositionToModelPosition(viewAnchorPosition);
        if (this.model.getEOL().length === 2) {
            // This model uses CRLF, so the delta must take that into account
            if (deltaOffset < 0) {
                deltaOffset -= lineFeedCnt;
            }
            else {
                deltaOffset += lineFeedCnt;
            }
        }
        var modelAnchorOffset = this.model.getOffsetAt(modelAnchor);
        var resultOffset = modelAnchorOffset + deltaOffset;
        return this.model.getPositionAt(resultOffset);
    };
    ViewModel.prototype.getEOL = function () {
        return this.model.getEOL();
    };
    ViewModel.prototype.getPlainTextToCopy = function (ranges, emptySelectionClipboard, forceCRLF) {
        var _this = this;
        var newLineCharacter = forceCRLF ? '\r\n' : this.model.getEOL();
        ranges = ranges.slice(0);
        ranges.sort(Range.compareRangesUsingStarts);
        var nonEmptyRanges = ranges.filter(function (r) { return !r.isEmpty(); });
        if (nonEmptyRanges.length === 0) {
            if (!emptySelectionClipboard) {
                return '';
            }
            var modelLineNumbers = ranges.map(function (r) {
                var viewLineStart = new Position(r.startLineNumber, 1);
                return _this.coordinatesConverter.convertViewPositionToModelPosition(viewLineStart).lineNumber;
            });
            var result_1 = '';
            for (var i = 0; i < modelLineNumbers.length; i++) {
                if (i > 0 && modelLineNumbers[i - 1] === modelLineNumbers[i]) {
                    continue;
                }
                result_1 += this.model.getLineContent(modelLineNumbers[i]) + newLineCharacter;
            }
            return result_1;
        }
        var result = [];
        for (var i = 0; i < nonEmptyRanges.length; i++) {
            result.push(this.getValueInRange(nonEmptyRanges[i], forceCRLF ? EndOfLinePreference.CRLF : EndOfLinePreference.TextDefined));
        }
        return result.length === 1 ? result[0] : result;
    };
    ViewModel.prototype.getHTMLToCopy = function (viewRanges, emptySelectionClipboard) {
        if (this.model.getLanguageIdentifier().id === 1 /* PlainText */) {
            return null;
        }
        if (viewRanges.length !== 1) {
            // no multiple selection support at this time
            return null;
        }
        var range = this.coordinatesConverter.convertViewRangeToModelRange(viewRanges[0]);
        if (range.isEmpty()) {
            if (!emptySelectionClipboard) {
                // nothing to copy
                return null;
            }
            var lineNumber = range.startLineNumber;
            range = new Range(lineNumber, this.model.getLineMinColumn(lineNumber), lineNumber, this.model.getLineMaxColumn(lineNumber));
        }
        var fontInfo = this.configuration.editor.fontInfo;
        var colorMap = this._getColorMap();
        return ("<div style=\""
            + ("color: " + colorMap[1 /* DefaultForeground */] + ";")
            + ("background-color: " + colorMap[2 /* DefaultBackground */] + ";")
            + ("font-family: " + fontInfo.fontFamily + ";")
            + ("font-weight: " + fontInfo.fontWeight + ";")
            + ("font-size: " + fontInfo.fontSize + "px;")
            + ("line-height: " + fontInfo.lineHeight + "px;")
            + "white-space: pre;"
            + "\">"
            + this._getHTMLToCopy(range, colorMap)
            + '</div>');
    };
    ViewModel.prototype._getHTMLToCopy = function (modelRange, colorMap) {
        var startLineNumber = modelRange.startLineNumber;
        var startColumn = modelRange.startColumn;
        var endLineNumber = modelRange.endLineNumber;
        var endColumn = modelRange.endColumn;
        var tabSize = this.getTabSize();
        var result = '';
        for (var lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {
            var lineTokens = this.model.getLineTokens(lineNumber);
            var lineContent = lineTokens.getLineContent();
            var startOffset = (lineNumber === startLineNumber ? startColumn - 1 : 0);
            var endOffset = (lineNumber === endLineNumber ? endColumn - 1 : lineContent.length);
            if (lineContent === '') {
                result += '<br>';
            }
            else {
                result += tokenizeLineToHTML(lineContent, lineTokens.inflate(), colorMap, startOffset, endOffset, tabSize);
            }
        }
        return result;
    };
    ViewModel.prototype._getColorMap = function () {
        var colorMap = TokenizationRegistry.getColorMap();
        var result = [null];
        for (var i = 1, len = colorMap.length; i < len; i++) {
            result[i] = Color.Format.CSS.formatHex(colorMap[i]);
        }
        return result;
    };
    return ViewModel;
}(ViewEventEmitter));

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
/**
 * Return a hash value for an object.
 */
function hash(obj, hashVal) {
    if (hashVal === void 0) { hashVal = 0; }
    switch (typeof obj) {
        case 'object':
            if (obj === null) {
                return numberHash(349, hashVal);
            }
            else if (Array.isArray(obj)) {
                return arrayHash(obj, hashVal);
            }
            return objectHash(obj, hashVal);
        case 'string':
            return stringHash(obj, hashVal);
        case 'boolean':
            return booleanHash(obj, hashVal);
        case 'number':
            return numberHash(obj, hashVal);
        case 'undefined':
            return numberHash(obj, 937);
        default:
            return numberHash(obj, 617);
    }
}
function numberHash(val, initialHashVal) {
    return (((initialHashVal << 5) - initialHashVal) + val) | 0; // hashVal * 31 + ch, keep as int32
}
function booleanHash(b, initialHashVal) {
    return numberHash(b ? 433 : 863, initialHashVal);
}
function stringHash(s, hashVal) {
    hashVal = numberHash(149417, hashVal);
    for (var i = 0, length_1 = s.length; i < length_1; i++) {
        hashVal = numberHash(s.charCodeAt(i), hashVal);
    }
    return hashVal;
}
function arrayHash(arr, initialHashVal) {
    initialHashVal = numberHash(104579, initialHashVal);
    return arr.reduce(function (hashVal, item) { return hash(item, hashVal); }, initialHashVal);
}
function objectHash(obj, initialHashVal) {
    initialHashVal = numberHash(181387, initialHashVal);
    return Object.keys(obj).sort().reduce(function (hashVal, key) {
        hashVal = stringHash(key, hashVal);
        return hash(obj[key], hashVal);
    }, initialHashVal);
}

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var EditorContextKeys;
(function (EditorContextKeys) {
    /**
     * A context key that is set when the editor's text has focus (cursor is blinking).
     */
    EditorContextKeys.editorTextFocus = new RawContextKey('editorTextFocus', false);
    /**
     * A context key that is set when the editor's text or an editor's widget has focus.
     */
    EditorContextKeys.focus = new RawContextKey('editorFocus', false);
    /**
     * A context key that is set when any editor input has focus (regular editor, repl input...).
     */
    EditorContextKeys.textInputFocus = new RawContextKey('textInputFocus', false);
    EditorContextKeys.readOnly = new RawContextKey('editorReadonly', false);
    EditorContextKeys.writable = EditorContextKeys.readOnly.toNegated();
    EditorContextKeys.hasNonEmptySelection = new RawContextKey('editorHasSelection', false);
    EditorContextKeys.hasOnlyEmptySelection = EditorContextKeys.hasNonEmptySelection.toNegated();
    EditorContextKeys.hasMultipleSelections = new RawContextKey('editorHasMultipleSelections', false);
    EditorContextKeys.hasSingleSelection = EditorContextKeys.hasMultipleSelections.toNegated();
    EditorContextKeys.tabMovesFocus = new RawContextKey('editorTabMovesFocus', false);
    EditorContextKeys.tabDoesNotMoveFocus = EditorContextKeys.tabMovesFocus.toNegated();
    EditorContextKeys.isInEmbeddedEditor = new RawContextKey('isInEmbeddedEditor', undefined);
    // -- mode context keys
    EditorContextKeys.languageId = new RawContextKey('editorLangId', undefined);
    EditorContextKeys.hasCompletionItemProvider = new RawContextKey('editorHasCompletionItemProvider', undefined);
    EditorContextKeys.hasCodeActionsProvider = new RawContextKey('editorHasCodeActionsProvider', undefined);
    EditorContextKeys.hasCodeLensProvider = new RawContextKey('editorHasCodeLensProvider', undefined);
    EditorContextKeys.hasDefinitionProvider = new RawContextKey('editorHasDefinitionProvider', undefined);
    EditorContextKeys.hasImplementationProvider = new RawContextKey('editorHasImplementationProvider', undefined);
    EditorContextKeys.hasTypeDefinitionProvider = new RawContextKey('editorHasTypeDefinitionProvider', undefined);
    EditorContextKeys.hasHoverProvider = new RawContextKey('editorHasHoverProvider', undefined);
    EditorContextKeys.hasDocumentHighlightProvider = new RawContextKey('editorHasDocumentHighlightProvider', undefined);
    EditorContextKeys.hasDocumentSymbolProvider = new RawContextKey('editorHasDocumentSymbolProvider', undefined);
    EditorContextKeys.hasReferenceProvider = new RawContextKey('editorHasReferenceProvider', undefined);
    EditorContextKeys.hasRenameProvider = new RawContextKey('editorHasRenameProvider', undefined);
    EditorContextKeys.hasDocumentFormattingProvider = new RawContextKey('editorHasDocumentFormattingProvider', undefined);
    EditorContextKeys.hasDocumentSelectionFormattingProvider = new RawContextKey('editorHasDocumentSelectionFormattingProvider', undefined);
    EditorContextKeys.hasSignatureHelpProvider = new RawContextKey('editorHasSignatureHelpProvider', undefined);
})(EditorContextKeys || (EditorContextKeys = {}));

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$g = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var EDITOR_ID = 0;
var CommonCodeEditor = /** @class */ (function (_super) {
    __extends$g(CommonCodeEditor, _super);
    function CommonCodeEditor(domElement, options, isSimpleWidget, instantiationService, contextKeyService, notificationService) {
        var _this = _super.call(this) || this;
        _this._onDidDispose = _this._register(new Emitter());
        _this.onDidDispose = _this._onDidDispose.event;
        _this._onDidChangeModelContent = _this._register(new Emitter());
        _this.onDidChangeModelContent = _this._onDidChangeModelContent.event;
        _this._onDidChangeModelLanguage = _this._register(new Emitter());
        _this.onDidChangeModelLanguage = _this._onDidChangeModelLanguage.event;
        _this._onDidChangeModelLanguageConfiguration = _this._register(new Emitter());
        _this.onDidChangeModelLanguageConfiguration = _this._onDidChangeModelLanguageConfiguration.event;
        _this._onDidChangeModelOptions = _this._register(new Emitter());
        _this.onDidChangeModelOptions = _this._onDidChangeModelOptions.event;
        _this._onDidChangeModelDecorations = _this._register(new Emitter());
        _this.onDidChangeModelDecorations = _this._onDidChangeModelDecorations.event;
        _this._onDidChangeConfiguration = _this._register(new Emitter());
        _this.onDidChangeConfiguration = _this._onDidChangeConfiguration.event;
        _this._onDidChangeModel = _this._register(new Emitter());
        _this.onDidChangeModel = _this._onDidChangeModel.event;
        _this._onDidChangeCursorPosition = _this._register(new Emitter());
        _this.onDidChangeCursorPosition = _this._onDidChangeCursorPosition.event;
        _this._onDidChangeCursorSelection = _this._register(new Emitter());
        _this.onDidChangeCursorSelection = _this._onDidChangeCursorSelection.event;
        _this._onDidAttemptReadOnlyEdit = _this._register(new Emitter());
        _this.onDidAttemptReadOnlyEdit = _this._onDidAttemptReadOnlyEdit.event;
        _this._onDidLayoutChange = _this._register(new Emitter());
        _this.onDidLayoutChange = _this._onDidLayoutChange.event;
        _this._editorTextFocus = _this._register(new BooleanEventEmitter());
        _this.onDidFocusEditorText = _this._editorTextFocus.onDidChangeToTrue;
        _this.onDidBlurEditorText = _this._editorTextFocus.onDidChangeToFalse;
        _this._editorFocus = _this._register(new BooleanEventEmitter());
        _this.onDidFocusEditor = _this._editorFocus.onDidChangeToTrue;
        _this.onDidBlurEditor = _this._editorFocus.onDidChangeToFalse;
        _this._onWillType = _this._register(new Emitter());
        _this.onWillType = _this._onWillType.event;
        _this._onDidType = _this._register(new Emitter());
        _this.onDidType = _this._onDidType.event;
        _this._onDidPaste = _this._register(new Emitter());
        _this.onDidPaste = _this._onDidPaste.event;
        _this.domElement = domElement;
        _this.id = (++EDITOR_ID);
        _this._decorationTypeKeysToIds = {};
        _this._decorationTypeSubtypes = {};
        _this.isSimpleWidget = isSimpleWidget;
        options = options || {};
        _this._configuration = _this._register(_this._createConfiguration(options));
        _this._register(_this._configuration.onDidChange(function (e) {
            _this._onDidChangeConfiguration.fire(e);
            if (e.layoutInfo) {
                _this._onDidLayoutChange.fire(_this._configuration.editor.layoutInfo);
            }
        }));
        _this._contextKeyService = _this._register(contextKeyService.createScoped(_this.domElement));
        _this._notificationService = notificationService;
        _this._register(new EditorContextKeysManager(_this, _this._contextKeyService));
        _this._register(new EditorModeContext(_this, _this._contextKeyService));
        _this._instantiationService = instantiationService.createChild(new ServiceCollection([IContextKeyService, _this._contextKeyService]));
        _this._attachModel(null);
        _this._contributions = {};
        _this._actions = {};
        return _this;
    }
    CommonCodeEditor.prototype.getId = function () {
        return this.getEditorType() + ':' + this.id;
    };
    CommonCodeEditor.prototype.getEditorType = function () {
        return EditorType.ICodeEditor;
    };
    CommonCodeEditor.prototype.dispose = function () {
        var keys = Object.keys(this._contributions);
        for (var i = 0, len = keys.length; i < len; i++) {
            var contributionId = keys[i];
            this._contributions[contributionId].dispose();
        }
        this._contributions = {};
        // editor actions don't need to be disposed
        this._actions = {};
        this._removeDecorationTypes();
        this._postDetachModelCleanup(this._detachModel());
        this._onDidDispose.fire();
        _super.prototype.dispose.call(this);
    };
    CommonCodeEditor.prototype.invokeWithinContext = function (fn) {
        return this._instantiationService.invokeFunction(fn);
    };
    CommonCodeEditor.prototype.updateOptions = function (newOptions) {
        this._configuration.updateOptions(newOptions);
    };
    CommonCodeEditor.prototype.getConfiguration = function () {
        return this._configuration.editor;
    };
    CommonCodeEditor.prototype.getRawConfiguration = function () {
        return this._configuration.getRawOptions();
    };
    CommonCodeEditor.prototype.getValue = function (options) {
        if (options === void 0) { options = null; }
        if (this.model) {
            var preserveBOM = (options && options.preserveBOM) ? true : false;
            var eolPreference = EndOfLinePreference.TextDefined;
            if (options && options.lineEnding && options.lineEnding === '\n') {
                eolPreference = EndOfLinePreference.LF;
            }
            else if (options && options.lineEnding && options.lineEnding === '\r\n') {
                eolPreference = EndOfLinePreference.CRLF;
            }
            return this.model.getValue(eolPreference, preserveBOM);
        }
        return '';
    };
    CommonCodeEditor.prototype.setValue = function (newValue) {
        if (this.model) {
            this.model.setValue(newValue);
        }
    };
    CommonCodeEditor.prototype.getModel = function () {
        return this.model;
    };
    CommonCodeEditor.prototype.setModel = function (model) {
        if (model === void 0) { model = null; }
        if (this.model === model) {
            // Current model is the new model
            return;
        }
        var detachedModel = this._detachModel();
        this._attachModel(model);
        var e = {
            oldModelUrl: detachedModel ? detachedModel.uri : null,
            newModelUrl: model ? model.uri : null
        };
        this._removeDecorationTypes();
        this._onDidChangeModel.fire(e);
        this._postDetachModelCleanup(detachedModel);
    };
    CommonCodeEditor.prototype._removeDecorationTypes = function () {
        this._decorationTypeKeysToIds = {};
        if (this._decorationTypeSubtypes) {
            for (var decorationType in this._decorationTypeSubtypes) {
                var subTypes = this._decorationTypeSubtypes[decorationType];
                for (var subType in subTypes) {
                    this._removeDecorationType(decorationType + '-' + subType);
                }
            }
            this._decorationTypeSubtypes = {};
        }
    };
    CommonCodeEditor.prototype.getVisibleRanges = function () {
        if (!this.hasView) {
            return [];
        }
        return this.viewModel.getVisibleRanges();
    };
    CommonCodeEditor.prototype.getWhitespaces = function () {
        if (!this.hasView) {
            return [];
        }
        return this.viewModel.viewLayout.getWhitespaces();
    };
    CommonCodeEditor.prototype._getVerticalOffsetForPosition = function (modelLineNumber, modelColumn) {
        var modelPosition = this.model.validatePosition({
            lineNumber: modelLineNumber,
            column: modelColumn
        });
        var viewPosition = this.viewModel.coordinatesConverter.convertModelPositionToViewPosition(modelPosition);
        return this.viewModel.viewLayout.getVerticalOffsetForLineNumber(viewPosition.lineNumber);
    };
    CommonCodeEditor.prototype.getTopForLineNumber = function (lineNumber) {
        if (!this.hasView) {
            return -1;
        }
        return this._getVerticalOffsetForPosition(lineNumber, 1);
    };
    CommonCodeEditor.prototype.getTopForPosition = function (lineNumber, column) {
        if (!this.hasView) {
            return -1;
        }
        return this._getVerticalOffsetForPosition(lineNumber, column);
    };
    CommonCodeEditor.prototype.setHiddenAreas = function (ranges) {
        if (this.viewModel) {
            this.viewModel.setHiddenAreas(ranges.map(function (r) { return Range.lift(r); }));
        }
    };
    CommonCodeEditor.prototype.getVisibleColumnFromPosition = function (rawPosition) {
        if (!this.model) {
            return rawPosition.column;
        }
        var position = this.model.validatePosition(rawPosition);
        var tabSize = this.model.getOptions().tabSize;
        return CursorColumns.visibleColumnFromColumn(this.model.getLineContent(position.lineNumber), position.column, tabSize) + 1;
    };
    CommonCodeEditor.prototype.getPosition = function () {
        if (!this.cursor) {
            return null;
        }
        return this.cursor.getPosition().clone();
    };
    CommonCodeEditor.prototype.setPosition = function (position) {
        if (!this.cursor) {
            return;
        }
        if (!Position.isIPosition(position)) {
            throw new Error('Invalid arguments');
        }
        this.cursor.setSelections('api', [{
                selectionStartLineNumber: position.lineNumber,
                selectionStartColumn: position.column,
                positionLineNumber: position.lineNumber,
                positionColumn: position.column
            }]);
    };
    CommonCodeEditor.prototype._sendRevealRange = function (modelRange, verticalType, revealHorizontal, scrollType) {
        if (!this.model || !this.cursor) {
            return;
        }
        if (!Range.isIRange(modelRange)) {
            throw new Error('Invalid arguments');
        }
        var validatedModelRange = this.model.validateRange(modelRange);
        var viewRange = this.viewModel.coordinatesConverter.convertModelRangeToViewRange(validatedModelRange);
        this.cursor.emitCursorRevealRange(viewRange, verticalType, revealHorizontal, scrollType);
    };
    CommonCodeEditor.prototype.revealLine = function (lineNumber, scrollType) {
        if (scrollType === void 0) { scrollType = 0 /* Smooth */; }
        this._revealLine(lineNumber, 0 /* Simple */, scrollType);
    };
    CommonCodeEditor.prototype.revealLineInCenter = function (lineNumber, scrollType) {
        if (scrollType === void 0) { scrollType = 0 /* Smooth */; }
        this._revealLine(lineNumber, 1 /* Center */, scrollType);
    };
    CommonCodeEditor.prototype.revealLineInCenterIfOutsideViewport = function (lineNumber, scrollType) {
        if (scrollType === void 0) { scrollType = 0 /* Smooth */; }
        this._revealLine(lineNumber, 2 /* CenterIfOutsideViewport */, scrollType);
    };
    CommonCodeEditor.prototype._revealLine = function (lineNumber, revealType, scrollType) {
        if (typeof lineNumber !== 'number') {
            throw new Error('Invalid arguments');
        }
        this._sendRevealRange(new Range(lineNumber, 1, lineNumber, 1), revealType, false, scrollType);
    };
    CommonCodeEditor.prototype.revealPosition = function (position, scrollType) {
        if (scrollType === void 0) { scrollType = 0 /* Smooth */; }
        this._revealPosition(position, 0 /* Simple */, true, scrollType);
    };
    CommonCodeEditor.prototype.revealPositionInCenter = function (position, scrollType) {
        if (scrollType === void 0) { scrollType = 0 /* Smooth */; }
        this._revealPosition(position, 1 /* Center */, true, scrollType);
    };
    CommonCodeEditor.prototype.revealPositionInCenterIfOutsideViewport = function (position, scrollType) {
        if (scrollType === void 0) { scrollType = 0 /* Smooth */; }
        this._revealPosition(position, 2 /* CenterIfOutsideViewport */, true, scrollType);
    };
    CommonCodeEditor.prototype._revealPosition = function (position, verticalType, revealHorizontal, scrollType) {
        if (!Position.isIPosition(position)) {
            throw new Error('Invalid arguments');
        }
        this._sendRevealRange(new Range(position.lineNumber, position.column, position.lineNumber, position.column), verticalType, revealHorizontal, scrollType);
    };
    CommonCodeEditor.prototype.getSelection = function () {
        if (!this.cursor) {
            return null;
        }
        return this.cursor.getSelection().clone();
    };
    CommonCodeEditor.prototype.getSelections = function () {
        if (!this.cursor) {
            return null;
        }
        var selections = this.cursor.getSelections();
        var result = [];
        for (var i = 0, len = selections.length; i < len; i++) {
            result[i] = selections[i].clone();
        }
        return result;
    };
    CommonCodeEditor.prototype.setSelection = function (something) {
        var isSelection = Selection.isISelection(something);
        var isRange = Range.isIRange(something);
        if (!isSelection && !isRange) {
            throw new Error('Invalid arguments');
        }
        if (isSelection) {
            this._setSelectionImpl(something);
        }
        else if (isRange) {
            // act as if it was an IRange
            var selection = {
                selectionStartLineNumber: something.startLineNumber,
                selectionStartColumn: something.startColumn,
                positionLineNumber: something.endLineNumber,
                positionColumn: something.endColumn
            };
            this._setSelectionImpl(selection);
        }
    };
    CommonCodeEditor.prototype._setSelectionImpl = function (sel) {
        if (!this.cursor) {
            return;
        }
        var selection = new Selection(sel.selectionStartLineNumber, sel.selectionStartColumn, sel.positionLineNumber, sel.positionColumn);
        this.cursor.setSelections('api', [selection]);
    };
    CommonCodeEditor.prototype.revealLines = function (startLineNumber, endLineNumber, scrollType) {
        if (scrollType === void 0) { scrollType = 0 /* Smooth */; }
        this._revealLines(startLineNumber, endLineNumber, 0 /* Simple */, scrollType);
    };
    CommonCodeEditor.prototype.revealLinesInCenter = function (startLineNumber, endLineNumber, scrollType) {
        if (scrollType === void 0) { scrollType = 0 /* Smooth */; }
        this._revealLines(startLineNumber, endLineNumber, 1 /* Center */, scrollType);
    };
    CommonCodeEditor.prototype.revealLinesInCenterIfOutsideViewport = function (startLineNumber, endLineNumber, scrollType) {
        if (scrollType === void 0) { scrollType = 0 /* Smooth */; }
        this._revealLines(startLineNumber, endLineNumber, 2 /* CenterIfOutsideViewport */, scrollType);
    };
    CommonCodeEditor.prototype._revealLines = function (startLineNumber, endLineNumber, verticalType, scrollType) {
        if (typeof startLineNumber !== 'number' || typeof endLineNumber !== 'number') {
            throw new Error('Invalid arguments');
        }
        this._sendRevealRange(new Range(startLineNumber, 1, endLineNumber, 1), verticalType, false, scrollType);
    };
    CommonCodeEditor.prototype.revealRange = function (range, scrollType, revealVerticalInCenter, revealHorizontal) {
        if (scrollType === void 0) { scrollType = 0 /* Smooth */; }
        if (revealVerticalInCenter === void 0) { revealVerticalInCenter = false; }
        if (revealHorizontal === void 0) { revealHorizontal = true; }
        this._revealRange(range, revealVerticalInCenter ? 1 /* Center */ : 0 /* Simple */, revealHorizontal, scrollType);
    };
    CommonCodeEditor.prototype.revealRangeInCenter = function (range, scrollType) {
        if (scrollType === void 0) { scrollType = 0 /* Smooth */; }
        this._revealRange(range, 1 /* Center */, true, scrollType);
    };
    CommonCodeEditor.prototype.revealRangeInCenterIfOutsideViewport = function (range, scrollType) {
        if (scrollType === void 0) { scrollType = 0 /* Smooth */; }
        this._revealRange(range, 2 /* CenterIfOutsideViewport */, true, scrollType);
    };
    CommonCodeEditor.prototype.revealRangeAtTop = function (range, scrollType) {
        if (scrollType === void 0) { scrollType = 0 /* Smooth */; }
        this._revealRange(range, 3 /* Top */, true, scrollType);
    };
    CommonCodeEditor.prototype._revealRange = function (range, verticalType, revealHorizontal, scrollType) {
        if (!Range.isIRange(range)) {
            throw new Error('Invalid arguments');
        }
        this._sendRevealRange(Range.lift(range), verticalType, revealHorizontal, scrollType);
    };
    CommonCodeEditor.prototype.setSelections = function (ranges) {
        if (!this.cursor) {
            return;
        }
        if (!ranges || ranges.length === 0) {
            throw new Error('Invalid arguments');
        }
        for (var i = 0, len = ranges.length; i < len; i++) {
            if (!Selection.isISelection(ranges[i])) {
                throw new Error('Invalid arguments');
            }
        }
        this.cursor.setSelections('api', ranges);
    };
    CommonCodeEditor.prototype.getScrollWidth = function () {
        if (!this.hasView) {
            return -1;
        }
        return this.viewModel.viewLayout.getScrollWidth();
    };
    CommonCodeEditor.prototype.getScrollLeft = function () {
        if (!this.hasView) {
            return -1;
        }
        return this.viewModel.viewLayout.getCurrentScrollLeft();
    };
    CommonCodeEditor.prototype.getScrollHeight = function () {
        if (!this.hasView) {
            return -1;
        }
        return this.viewModel.viewLayout.getScrollHeight();
    };
    CommonCodeEditor.prototype.getScrollTop = function () {
        if (!this.hasView) {
            return -1;
        }
        return this.viewModel.viewLayout.getCurrentScrollTop();
    };
    CommonCodeEditor.prototype.setScrollLeft = function (newScrollLeft) {
        if (!this.hasView) {
            return;
        }
        if (typeof newScrollLeft !== 'number') {
            throw new Error('Invalid arguments');
        }
        this.viewModel.viewLayout.setScrollPositionNow({
            scrollLeft: newScrollLeft
        });
    };
    CommonCodeEditor.prototype.setScrollTop = function (newScrollTop) {
        if (!this.hasView) {
            return;
        }
        if (typeof newScrollTop !== 'number') {
            throw new Error('Invalid arguments');
        }
        this.viewModel.viewLayout.setScrollPositionNow({
            scrollTop: newScrollTop
        });
    };
    CommonCodeEditor.prototype.setScrollPosition = function (position) {
        if (!this.hasView) {
            return;
        }
        this.viewModel.viewLayout.setScrollPositionNow(position);
    };
    CommonCodeEditor.prototype.saveViewState = function () {
        if (!this.cursor || !this.hasView) {
            return null;
        }
        var contributionsState = {};
        var keys = Object.keys(this._contributions);
        for (var i = 0, len = keys.length; i < len; i++) {
            var id = keys[i];
            var contribution = this._contributions[id];
            if (typeof contribution.saveViewState === 'function') {
                contributionsState[id] = contribution.saveViewState();
            }
        }
        var cursorState = this.cursor.saveState();
        var viewState = this.viewModel.saveState();
        return {
            cursorState: cursorState,
            viewState: viewState,
            contributionsState: contributionsState
        };
    };
    CommonCodeEditor.prototype.restoreViewState = function (s) {
        if (!this.cursor || !this.hasView) {
            return;
        }
        if (s && s.cursorState && s.viewState) {
            var codeEditorState = s;
            var cursorState = codeEditorState.cursorState;
            if (Array.isArray(cursorState)) {
                this.cursor.restoreState(cursorState);
            }
            else {
                // Backwards compatibility
                this.cursor.restoreState([cursorState]);
            }
            var contributionsState = s.contributionsState || {};
            var keys = Object.keys(this._contributions);
            for (var i = 0, len = keys.length; i < len; i++) {
                var id = keys[i];
                var contribution = this._contributions[id];
                if (typeof contribution.restoreViewState === 'function') {
                    contribution.restoreViewState(contributionsState[id]);
                }
            }
        }
    };
    CommonCodeEditor.prototype.onVisible = function () {
    };
    CommonCodeEditor.prototype.onHide = function () {
    };
    CommonCodeEditor.prototype.getContribution = function (id) {
        return (this._contributions[id] || null);
    };
    CommonCodeEditor.prototype.getActions = function () {
        var result = [];
        var keys = Object.keys(this._actions);
        for (var i = 0, len = keys.length; i < len; i++) {
            var id = keys[i];
            result.push(this._actions[id]);
        }
        return result;
    };
    CommonCodeEditor.prototype.getSupportedActions = function () {
        var result = this.getActions();
        result = result.filter(function (action) { return action.isSupported(); });
        return result;
    };
    CommonCodeEditor.prototype.getAction = function (id) {
        return this._actions[id] || null;
    };
    CommonCodeEditor.prototype.trigger = function (source, handlerId, payload) {
        payload = payload || {};
        // Special case for typing
        if (handlerId === Handler.Type) {
            if (!this.cursor || typeof payload.text !== 'string' || payload.text.length === 0) {
                // nothing to do
                return;
            }
            if (source === 'keyboard') {
                this._onWillType.fire(payload.text);
            }
            this.cursor.trigger(source, handlerId, payload);
            if (source === 'keyboard') {
                this._onDidType.fire(payload.text);
            }
            return;
        }
        // Special case for pasting
        if (handlerId === Handler.Paste) {
            if (!this.cursor || typeof payload.text !== 'string' || payload.text.length === 0) {
                // nothing to do
                return;
            }
            var startPosition = this.cursor.getSelection().getStartPosition();
            this.cursor.trigger(source, handlerId, payload);
            var endPosition = this.cursor.getSelection().getStartPosition();
            if (source === 'keyboard') {
                this._onDidPaste.fire(new Range(startPosition.lineNumber, startPosition.column, endPosition.lineNumber, endPosition.column));
            }
            return;
        }
        var action = this.getAction(handlerId);
        if (action) {
            TPromise.as(action.run()).then(null, onUnexpectedError);
            return;
        }
        if (!this.cursor) {
            return;
        }
        if (this._triggerEditorCommand(source, handlerId, payload)) {
            return;
        }
        this.cursor.trigger(source, handlerId, payload);
    };
    CommonCodeEditor.prototype._getCursors = function () {
        return this.cursor;
    };
    CommonCodeEditor.prototype._getCursorConfiguration = function () {
        return this.cursor.context.config;
    };
    CommonCodeEditor.prototype.pushUndoStop = function () {
        if (!this.model) {
            return false;
        }
        if (this._configuration.editor.readOnly) {
            // read only editor => sorry!
            return false;
        }
        this.model.pushStackElement();
        return true;
    };
    CommonCodeEditor.prototype.executeEdits = function (source, edits, endCursorState) {
        if (!this.cursor) {
            // no view, no cursor
            return false;
        }
        if (this._configuration.editor.readOnly) {
            // read only editor => sorry!
            return false;
        }
        this.model.pushEditOperations(this.cursor.getSelections(), edits, function () {
            return endCursorState ? endCursorState : null;
        });
        if (endCursorState) {
            this.cursor.setSelections(source, endCursorState);
        }
        return true;
    };
    CommonCodeEditor.prototype.executeCommand = function (source, command) {
        if (!this.cursor) {
            return;
        }
        this.cursor.trigger(source, Handler.ExecuteCommand, command);
    };
    CommonCodeEditor.prototype.executeCommands = function (source, commands) {
        if (!this.cursor) {
            return;
        }
        this.cursor.trigger(source, Handler.ExecuteCommands, commands);
    };
    CommonCodeEditor.prototype.changeDecorations = function (callback) {
        if (!this.model) {
            //			console.warn('Cannot change decorations on editor that is not attached to a model');
            // callback will not be called
            return null;
        }
        return this.model.changeDecorations(callback, this.id);
    };
    CommonCodeEditor.prototype.getLineDecorations = function (lineNumber) {
        if (!this.model) {
            return null;
        }
        return this.model.getLineDecorations(lineNumber, this.id, this._configuration.editor.readOnly);
    };
    CommonCodeEditor.prototype.deltaDecorations = function (oldDecorations, newDecorations) {
        if (!this.model) {
            return [];
        }
        if (oldDecorations.length === 0 && newDecorations.length === 0) {
            return oldDecorations;
        }
        return this.model.deltaDecorations(oldDecorations, newDecorations, this.id);
    };
    CommonCodeEditor.prototype.setDecorations = function (decorationTypeKey, decorationOptions) {
        var newDecorationsSubTypes = {};
        var oldDecorationsSubTypes = this._decorationTypeSubtypes[decorationTypeKey] || {};
        this._decorationTypeSubtypes[decorationTypeKey] = newDecorationsSubTypes;
        var newModelDecorations = [];
        for (var _i = 0, decorationOptions_1 = decorationOptions; _i < decorationOptions_1.length; _i++) {
            var decorationOption = decorationOptions_1[_i];
            var typeKey = decorationTypeKey;
            if (decorationOption.renderOptions) {
                // identify custom reder options by a hash code over all keys and values
                // For custom render options register a decoration type if necessary
                var subType = hash(decorationOption.renderOptions).toString(16);
                // The fact that `decorationTypeKey` appears in the typeKey has no influence
                // it is just a mechanism to get predictable and unique keys (repeatable for the same options and unique across clients)
                typeKey = decorationTypeKey + '-' + subType;
                if (!oldDecorationsSubTypes[subType] && !newDecorationsSubTypes[subType]) {
                    // decoration type did not exist before, register new one
                    this._registerDecorationType(typeKey, decorationOption.renderOptions, decorationTypeKey);
                }
                newDecorationsSubTypes[subType] = true;
            }
            var opts = this._resolveDecorationOptions(typeKey, !!decorationOption.hoverMessage);
            if (decorationOption.hoverMessage) {
                opts.hoverMessage = decorationOption.hoverMessage;
            }
            newModelDecorations.push({ range: decorationOption.range, options: opts });
        }
        // remove decoration sub types that are no longer used, deregister decoration type if necessary
        for (var subType in oldDecorationsSubTypes) {
            if (!newDecorationsSubTypes[subType]) {
                this._removeDecorationType(decorationTypeKey + '-' + subType);
            }
        }
        // update all decorations
        var oldDecorationsIds = this._decorationTypeKeysToIds[decorationTypeKey] || [];
        this._decorationTypeKeysToIds[decorationTypeKey] = this.deltaDecorations(oldDecorationsIds, newModelDecorations);
    };
    CommonCodeEditor.prototype.setDecorationsFast = function (decorationTypeKey, ranges) {
        // remove decoration sub types that are no longer used, deregister decoration type if necessary
        var oldDecorationsSubTypes = this._decorationTypeSubtypes[decorationTypeKey] || {};
        for (var subType in oldDecorationsSubTypes) {
            this._removeDecorationType(decorationTypeKey + '-' + subType);
        }
        this._decorationTypeSubtypes[decorationTypeKey] = {};
        var opts = ModelDecorationOptions.createDynamic(this._resolveDecorationOptions(decorationTypeKey, false));
        var newModelDecorations = new Array(ranges.length);
        for (var i = 0, len = ranges.length; i < len; i++) {
            newModelDecorations[i] = { range: ranges[i], options: opts };
        }
        // update all decorations
        var oldDecorationsIds = this._decorationTypeKeysToIds[decorationTypeKey] || [];
        this._decorationTypeKeysToIds[decorationTypeKey] = this.deltaDecorations(oldDecorationsIds, newModelDecorations);
    };
    CommonCodeEditor.prototype.removeDecorations = function (decorationTypeKey) {
        // remove decorations for type and sub type
        var oldDecorationsIds = this._decorationTypeKeysToIds[decorationTypeKey];
        if (oldDecorationsIds) {
            this.deltaDecorations(oldDecorationsIds, []);
        }
        if (this._decorationTypeKeysToIds.hasOwnProperty(decorationTypeKey)) {
            delete this._decorationTypeKeysToIds[decorationTypeKey];
        }
        if (this._decorationTypeSubtypes.hasOwnProperty(decorationTypeKey)) {
            delete this._decorationTypeSubtypes[decorationTypeKey];
        }
    };
    CommonCodeEditor.prototype.getLayoutInfo = function () {
        return this._configuration.editor.layoutInfo;
    };
    CommonCodeEditor.prototype._attachModel = function (model) {
        var _this = this;
        this.model = model ? model : null;
        this.listenersToRemove = [];
        this.viewModel = null;
        this.cursor = null;
        if (this.model) {
            this.domElement.setAttribute('data-mode-id', this.model.getLanguageIdentifier().language);
            this._configuration.setIsDominatedByLongLines(this.model.isDominatedByLongLines());
            this._configuration.setMaxLineNumber(this.model.getLineCount());
            this.model.onBeforeAttached();
            this.viewModel = new ViewModel(this.id, this._configuration, this.model, function (callback) { return _this._scheduleAtNextAnimationFrame(callback); });
            this.listenersToRemove.push(this.model.onDidChangeDecorations(function (e) { return _this._onDidChangeModelDecorations.fire(e); }));
            this.listenersToRemove.push(this.model.onDidChangeLanguage(function (e) {
                if (!_this.model) {
                    return;
                }
                _this.domElement.setAttribute('data-mode-id', _this.model.getLanguageIdentifier().language);
                _this._onDidChangeModelLanguage.fire(e);
            }));
            this.listenersToRemove.push(this.model.onDidChangeLanguageConfiguration(function (e) { return _this._onDidChangeModelLanguageConfiguration.fire(e); }));
            this.listenersToRemove.push(this.model.onDidChangeContent(function (e) { return _this._onDidChangeModelContent.fire(e); }));
            this.listenersToRemove.push(this.model.onDidChangeOptions(function (e) { return _this._onDidChangeModelOptions.fire(e); }));
            // Someone might destroy the model from under the editor, so prevent any exceptions by setting a null model
            this.listenersToRemove.push(this.model.onWillDispose(function () { return _this.setModel(null); }));
            this.cursor = new Cursor(this._configuration, this.model, this.viewModel);
            this._createView();
            this.listenersToRemove.push(this.cursor.onDidReachMaxCursorCount(function () {
                _this._notificationService.warn(localize('cursors.maximum', "The number of cursors has been limited to {0}.", Cursor.MAX_CURSOR_COUNT));
            }));
            this.listenersToRemove.push(this.cursor.onDidAttemptReadOnlyEdit(function () {
                _this._onDidAttemptReadOnlyEdit.fire(void 0);
            }));
            this.listenersToRemove.push(this.cursor.onDidChange(function (e) {
                var positions = [];
                for (var i = 0, len = e.selections.length; i < len; i++) {
                    positions[i] = e.selections[i].getPosition();
                }
                var e1 = {
                    position: positions[0],
                    secondaryPositions: positions.slice(1),
                    reason: e.reason,
                    source: e.source
                };
                _this._onDidChangeCursorPosition.fire(e1);
                var e2 = {
                    selection: e.selections[0],
                    secondarySelections: e.selections.slice(1),
                    source: e.source,
                    reason: e.reason
                };
                _this._onDidChangeCursorSelection.fire(e2);
            }));
        }
        else {
            this.hasView = false;
        }
    };
    CommonCodeEditor.prototype._postDetachModelCleanup = function (detachedModel) {
        if (detachedModel) {
            detachedModel.removeAllDecorationsWithOwnerId(this.id);
        }
    };
    CommonCodeEditor.prototype._detachModel = function () {
        if (this.model) {
            this.model.onBeforeDetached();
        }
        this.hasView = false;
        this.listenersToRemove = dispose(this.listenersToRemove);
        if (this.cursor) {
            this.cursor.dispose();
            this.cursor = null;
        }
        if (this.viewModel) {
            this.viewModel.dispose();
            this.viewModel = null;
        }
        var result = this.model;
        this.model = null;
        this.domElement.removeAttribute('data-mode-id');
        return result;
    };
    /* __GDPR__FRAGMENT__
        "EditorTelemetryData" : {}
    */
    CommonCodeEditor.prototype.getTelemetryData = function () {
        return null;
    };
    return CommonCodeEditor;
}(Disposable));
var BooleanEventEmitter = /** @class */ (function (_super) {
    __extends$g(BooleanEventEmitter, _super);
    function BooleanEventEmitter() {
        var _this = _super.call(this) || this;
        _this._onDidChangeToTrue = _this._register(new Emitter());
        _this.onDidChangeToTrue = _this._onDidChangeToTrue.event;
        _this._onDidChangeToFalse = _this._register(new Emitter());
        _this.onDidChangeToFalse = _this._onDidChangeToFalse.event;
        _this._value = 0 /* NotSet */;
        return _this;
    }
    BooleanEventEmitter.prototype.setValue = function (_value) {
        var value = (_value ? 2 /* True */ : 1 /* False */);
        if (this._value === value) {
            return;
        }
        this._value = value;
        if (this._value === 2 /* True */) {
            this._onDidChangeToTrue.fire();
        }
        else if (this._value === 1 /* False */) {
            this._onDidChangeToFalse.fire();
        }
    };
    return BooleanEventEmitter;
}(Disposable));
var EditorContextKeysManager = /** @class */ (function (_super) {
    __extends$g(EditorContextKeysManager, _super);
    function EditorContextKeysManager(editor, contextKeyService) {
        var _this = _super.call(this) || this;
        _this._editor = editor;
        contextKeyService.createKey('editorId', editor.getId());
        _this._editorFocus = EditorContextKeys.focus.bindTo(contextKeyService);
        _this._textInputFocus = EditorContextKeys.textInputFocus.bindTo(contextKeyService);
        _this._editorTextFocus = EditorContextKeys.editorTextFocus.bindTo(contextKeyService);
        _this._editorTabMovesFocus = EditorContextKeys.tabMovesFocus.bindTo(contextKeyService);
        _this._editorReadonly = EditorContextKeys.readOnly.bindTo(contextKeyService);
        _this._hasMultipleSelections = EditorContextKeys.hasMultipleSelections.bindTo(contextKeyService);
        _this._hasNonEmptySelection = EditorContextKeys.hasNonEmptySelection.bindTo(contextKeyService);
        _this._register(_this._editor.onDidChangeConfiguration(function () { return _this._updateFromConfig(); }));
        _this._register(_this._editor.onDidChangeCursorSelection(function () { return _this._updateFromSelection(); }));
        _this._register(_this._editor.onDidFocusEditor(function () { return _this._updateFromFocus(); }));
        _this._register(_this._editor.onDidBlurEditor(function () { return _this._updateFromFocus(); }));
        _this._register(_this._editor.onDidFocusEditorText(function () { return _this._updateFromFocus(); }));
        _this._register(_this._editor.onDidBlurEditorText(function () { return _this._updateFromFocus(); }));
        _this._updateFromConfig();
        _this._updateFromSelection();
        _this._updateFromFocus();
        return _this;
    }
    EditorContextKeysManager.prototype._updateFromConfig = function () {
        var config = this._editor.getConfiguration();
        this._editorTabMovesFocus.set(config.tabFocusMode);
        this._editorReadonly.set(config.readOnly);
    };
    EditorContextKeysManager.prototype._updateFromSelection = function () {
        var selections = this._editor.getSelections();
        if (!selections) {
            this._hasMultipleSelections.reset();
            this._hasNonEmptySelection.reset();
        }
        else {
            this._hasMultipleSelections.set(selections.length > 1);
            this._hasNonEmptySelection.set(selections.some(function (s) { return !s.isEmpty(); }));
        }
    };
    EditorContextKeysManager.prototype._updateFromFocus = function () {
        this._editorFocus.set(this._editor.hasWidgetFocus() && !this._editor.isSimpleWidget);
        this._editorTextFocus.set(this._editor.isFocused() && !this._editor.isSimpleWidget);
        this._textInputFocus.set(this._editor.isFocused());
    };
    return EditorContextKeysManager;
}(Disposable));
var EditorModeContext = /** @class */ (function (_super) {
    __extends$g(EditorModeContext, _super);
    function EditorModeContext(editor, contextKeyService) {
        var _this = _super.call(this) || this;
        _this._editor = editor;
        _this._langId = EditorContextKeys.languageId.bindTo(contextKeyService);
        _this._hasCompletionItemProvider = EditorContextKeys.hasCompletionItemProvider.bindTo(contextKeyService);
        _this._hasCodeActionsProvider = EditorContextKeys.hasCodeActionsProvider.bindTo(contextKeyService);
        _this._hasCodeLensProvider = EditorContextKeys.hasCodeLensProvider.bindTo(contextKeyService);
        _this._hasDefinitionProvider = EditorContextKeys.hasDefinitionProvider.bindTo(contextKeyService);
        _this._hasImplementationProvider = EditorContextKeys.hasImplementationProvider.bindTo(contextKeyService);
        _this._hasTypeDefinitionProvider = EditorContextKeys.hasTypeDefinitionProvider.bindTo(contextKeyService);
        _this._hasHoverProvider = EditorContextKeys.hasHoverProvider.bindTo(contextKeyService);
        _this._hasDocumentHighlightProvider = EditorContextKeys.hasDocumentHighlightProvider.bindTo(contextKeyService);
        _this._hasDocumentSymbolProvider = EditorContextKeys.hasDocumentSymbolProvider.bindTo(contextKeyService);
        _this._hasReferenceProvider = EditorContextKeys.hasReferenceProvider.bindTo(contextKeyService);
        _this._hasRenameProvider = EditorContextKeys.hasRenameProvider.bindTo(contextKeyService);
        _this._hasDocumentFormattingProvider = EditorContextKeys.hasDocumentFormattingProvider.bindTo(contextKeyService);
        _this._hasDocumentSelectionFormattingProvider = EditorContextKeys.hasDocumentSelectionFormattingProvider.bindTo(contextKeyService);
        _this._hasSignatureHelpProvider = EditorContextKeys.hasSignatureHelpProvider.bindTo(contextKeyService);
        _this._isInWalkThrough = EditorContextKeys.isInEmbeddedEditor.bindTo(contextKeyService);
        var update = function () { return _this._update(); };
        // update when model/mode changes
        _this._register(editor.onDidChangeModel(update));
        _this._register(editor.onDidChangeModelLanguage(update));
        // update when registries change
        _this._register(SuggestRegistry.onDidChange(update));
        _this._register(CodeActionProviderRegistry.onDidChange(update));
        _this._register(CodeLensProviderRegistry.onDidChange(update));
        _this._register(DefinitionProviderRegistry.onDidChange(update));
        _this._register(ImplementationProviderRegistry.onDidChange(update));
        _this._register(TypeDefinitionProviderRegistry.onDidChange(update));
        _this._register(HoverProviderRegistry.onDidChange(update));
        _this._register(DocumentHighlightProviderRegistry.onDidChange(update));
        _this._register(DocumentSymbolProviderRegistry.onDidChange(update));
        _this._register(ReferenceProviderRegistry.onDidChange(update));
        _this._register(RenameProviderRegistry.onDidChange(update));
        _this._register(DocumentFormattingEditProviderRegistry.onDidChange(update));
        _this._register(DocumentRangeFormattingEditProviderRegistry.onDidChange(update));
        _this._register(SignatureHelpProviderRegistry.onDidChange(update));
        update();
        return _this;
    }
    EditorModeContext.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
    };
    EditorModeContext.prototype.reset = function () {
        this._langId.reset();
        this._hasCompletionItemProvider.reset();
        this._hasCodeActionsProvider.reset();
        this._hasCodeLensProvider.reset();
        this._hasDefinitionProvider.reset();
        this._hasImplementationProvider.reset();
        this._hasTypeDefinitionProvider.reset();
        this._hasHoverProvider.reset();
        this._hasDocumentHighlightProvider.reset();
        this._hasDocumentSymbolProvider.reset();
        this._hasReferenceProvider.reset();
        this._hasRenameProvider.reset();
        this._hasDocumentFormattingProvider.reset();
        this._hasDocumentSelectionFormattingProvider.reset();
        this._hasSignatureHelpProvider.reset();
        this._isInWalkThrough.reset();
    };
    EditorModeContext.prototype._update = function () {
        var model = this._editor.getModel();
        if (!model) {
            this.reset();
            return;
        }
        this._langId.set(model.getLanguageIdentifier().language);
        this._hasCompletionItemProvider.set(SuggestRegistry.has(model));
        this._hasCodeActionsProvider.set(CodeActionProviderRegistry.has(model));
        this._hasCodeLensProvider.set(CodeLensProviderRegistry.has(model));
        this._hasDefinitionProvider.set(DefinitionProviderRegistry.has(model));
        this._hasImplementationProvider.set(ImplementationProviderRegistry.has(model));
        this._hasTypeDefinitionProvider.set(TypeDefinitionProviderRegistry.has(model));
        this._hasHoverProvider.set(HoverProviderRegistry.has(model));
        this._hasDocumentHighlightProvider.set(DocumentHighlightProviderRegistry.has(model));
        this._hasDocumentSymbolProvider.set(DocumentSymbolProviderRegistry.has(model));
        this._hasReferenceProvider.set(ReferenceProviderRegistry.has(model));
        this._hasRenameProvider.set(RenameProviderRegistry.has(model));
        this._hasSignatureHelpProvider.set(SignatureHelpProviderRegistry.has(model));
        this._hasDocumentFormattingProvider.set(DocumentFormattingEditProviderRegistry.has(model) || DocumentRangeFormattingEditProviderRegistry.has(model));
        this._hasDocumentSelectionFormattingProvider.set(DocumentRangeFormattingEditProviderRegistry.has(model));
        this._isInWalkThrough.set(model.uri.scheme === Schemas.walkThroughSnippet);
    };
    return EditorModeContext;
}(Disposable));

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var ITelemetryService = createDecorator('telemetryService');

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var IEditorService = createDecorator('editorService');
/**
 * Possible locations for opening an editor.
 */
var Position$1;
(function (Position$$1) {
    /** Opens the editor in the first position replacing the input currently showing */
    Position$$1[Position$$1["ONE"] = 0] = "ONE";
    /** Opens the editor in the second position replacing the input currently showing */
    Position$$1[Position$$1["TWO"] = 1] = "TWO";
    /** Opens the editor in the third most position replacing the input currently showing */
    Position$$1[Position$$1["THREE"] = 2] = "THREE";
})(Position$1 || (Position$1 = {}));
var POSITIONS = [Position$1.ONE, Position$1.TWO, Position$1.THREE];
var Direction;
(function (Direction) {
    Direction[Direction["LEFT"] = 0] = "LEFT";
    Direction[Direction["RIGHT"] = 1] = "RIGHT";
})(Direction || (Direction = {}));
var Verbosity;
(function (Verbosity) {
    Verbosity[Verbosity["SHORT"] = 0] = "SHORT";
    Verbosity[Verbosity["MEDIUM"] = 1] = "MEDIUM";
    Verbosity[Verbosity["LONG"] = 2] = "LONG";
})(Verbosity || (Verbosity = {}));

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$h = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign$1 = (undefined && undefined.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
var Command = /** @class */ (function () {
    function Command(opts) {
        this.id = opts.id;
        this.precondition = opts.precondition;
        this._kbOpts = opts.kbOpts;
        this._description = opts.description;
    }
    Command.prototype.toCommandAndKeybindingRule = function (defaultWeight) {
        var _this = this;
        var kbOpts = this._kbOpts || { primary: 0 };
        var kbWhen = kbOpts.kbExpr;
        if (this.precondition) {
            if (kbWhen) {
                kbWhen = ContextKeyExpr.and(kbWhen, this.precondition);
            }
            else {
                kbWhen = this.precondition;
            }
        }
        var weight = (typeof kbOpts.weight === 'number' ? kbOpts.weight : defaultWeight);
        return {
            id: this.id,
            handler: function (accessor, args) { return _this.runCommand(accessor, args); },
            weight: weight,
            when: kbWhen,
            primary: kbOpts.primary,
            secondary: kbOpts.secondary,
            win: kbOpts.win,
            linux: kbOpts.linux,
            mac: kbOpts.mac,
            description: this._description
        };
    };
    return Command;
}());
//#endregion Command
//#region EditorCommand
function getWorkbenchActiveEditor(accessor) {
    var editorService = accessor.get(IEditorService);
    var activeEditor = editorService.getActiveEditor && editorService.getActiveEditor();
    return getCodeEditor(activeEditor);
}
var EditorCommand = /** @class */ (function (_super) {
    __extends$h(EditorCommand, _super);
    function EditorCommand() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Create a command class that is bound to a certain editor contribution.
     */
    EditorCommand.bindToContribution = function (controllerGetter) {
        return /** @class */ (function (_super) {
            __extends$h(EditorControllerCommandImpl, _super);
            function EditorControllerCommandImpl(opts) {
                var _this = _super.call(this, opts) || this;
                _this._callback = opts.handler;
                return _this;
            }
            EditorControllerCommandImpl.prototype.runEditorCommand = function (accessor, editor, args) {
                var controller = controllerGetter(editor);
                if (controller) {
                    this._callback(controllerGetter(editor));
                }
            };
            return EditorControllerCommandImpl;
        }(EditorCommand));
    };
    EditorCommand.prototype.runCommand = function (accessor, args) {
        var _this = this;
        var codeEditorService = accessor.get(ICodeEditorService);
        // Find the editor with text focus
        var editor = codeEditorService.getFocusedCodeEditor();
        if (!editor) {
            // Fallback to use what the workbench considers the active editor
            editor = getWorkbenchActiveEditor(accessor);
        }
        if (!editor) {
            // well, at least we tried...
            return;
        }
        return editor.invokeWithinContext(function (editorAccessor) {
            var kbService = editorAccessor.get(IContextKeyService);
            if (!kbService.contextMatchesRules(_this.precondition)) {
                // precondition does not hold
                return;
            }
            return _this.runEditorCommand(editorAccessor, editor, args);
        });
    };
    return EditorCommand;
}(Command));
var EditorAction = /** @class */ (function (_super) {
    __extends$h(EditorAction, _super);
    function EditorAction(opts) {
        var _this = _super.call(this, opts) || this;
        _this.label = opts.label;
        _this.alias = opts.alias;
        _this.menuOpts = opts.menuOpts;
        return _this;
    }
    EditorAction.prototype.toMenuItem = function () {
        if (!this.menuOpts) {
            return null;
        }
        return {
            command: {
                id: this.id,
                title: this.label
            },
            when: ContextKeyExpr.and(this.precondition, this.menuOpts.when),
            group: this.menuOpts.group,
            order: this.menuOpts.order
        };
    };
    EditorAction.prototype.runEditorCommand = function (accessor, editor, args) {
        this.reportTelemetry(accessor, editor);
        return this.run(accessor, editor, args || {});
    };
    EditorAction.prototype.reportTelemetry = function (accessor, editor) {
        /* __GDPR__
            "editorActionInvoked" : {
                "name" : { "classification": "SystemMetaData", "purpose": "FeatureInsight" },
                "id": { "classification": "SystemMetaData", "purpose": "FeatureInsight" },
                "${include}": [
                    "${EditorTelemetryData}"
                ]
            }
        */
        accessor.get(ITelemetryService).publicLog('editorActionInvoked', __assign$1({ name: this.label, id: this.id }, editor.getTelemetryData()));
    };
    return EditorAction;
}(EditorCommand));
//#endregion EditorAction
// --- Registration of commands and actions
function registerLanguageCommand(id, handler) {
    CommandsRegistry.registerCommand(id, function (accessor, args) { return handler(accessor, args || {}); });
}
function registerDefaultLanguageCommand(id, handler) {
    registerLanguageCommand(id, function (accessor, args) {
        var resource = args.resource, position = args.position;
        if (!(resource instanceof URI)) {
            throw illegalArgument('resource');
        }
        if (!Position.isIPosition(position)) {
            throw illegalArgument('position');
        }
        var model = accessor.get(IModelService).getModel(resource);
        if (!model) {
            throw illegalArgument('Can not find open model for ' + resource);
        }
        var editorPosition = Position.lift(position);
        return handler(model, editorPosition, args);
    });
}
function registerEditorCommand(editorCommand) {
    EditorContributionRegistry.INSTANCE.registerEditorCommand(editorCommand);
    return editorCommand;
}
function registerEditorAction(ctor) {
    EditorContributionRegistry.INSTANCE.registerEditorAction(new ctor());
}
function registerInstantiatedEditorAction(editorAction) {
    EditorContributionRegistry.INSTANCE.registerEditorAction(editorAction);
}
function registerEditorContribution(ctor) {
    EditorContributionRegistry.INSTANCE.registerEditorContribution(ctor);
}
var EditorExtensionsRegistry;
(function (EditorExtensionsRegistry) {
    function getEditorCommand(commandId) {
        return EditorContributionRegistry.INSTANCE.getEditorCommand(commandId);
    }
    EditorExtensionsRegistry.getEditorCommand = getEditorCommand;
    function getEditorActions() {
        return EditorContributionRegistry.INSTANCE.getEditorActions();
    }
    EditorExtensionsRegistry.getEditorActions = getEditorActions;
    function getEditorContributions() {
        return EditorContributionRegistry.INSTANCE.getEditorContributions();
    }
    EditorExtensionsRegistry.getEditorContributions = getEditorContributions;
})(EditorExtensionsRegistry || (EditorExtensionsRegistry = {}));
// Editor extension points
var Extensions$3 = {
    EditorCommonContributions: 'editor.contributions'
};
var EditorContributionRegistry = /** @class */ (function () {
    function EditorContributionRegistry() {
        this.editorContributions = [];
        this.editorActions = [];
        this.editorCommands = Object.create(null);
    }
    EditorContributionRegistry.prototype.registerEditorContribution = function (ctor) {
        this.editorContributions.push(ctor);
    };
    EditorContributionRegistry.prototype.registerEditorAction = function (action) {
        var menuItem = action.toMenuItem();
        if (menuItem) {
            MenuRegistry.appendMenuItem(MenuId.EditorContext, menuItem);
        }
        KeybindingsRegistry.registerCommandAndKeybindingRule(action.toCommandAndKeybindingRule(KeybindingsRegistry.WEIGHT.editorContrib()));
        this.editorActions.push(action);
    };
    EditorContributionRegistry.prototype.getEditorContributions = function () {
        return this.editorContributions.slice(0);
    };
    EditorContributionRegistry.prototype.getEditorActions = function () {
        return this.editorActions.slice(0);
    };
    EditorContributionRegistry.prototype.registerEditorCommand = function (editorCommand) {
        KeybindingsRegistry.registerCommandAndKeybindingRule(editorCommand.toCommandAndKeybindingRule(KeybindingsRegistry.WEIGHT.editorContrib()));
        this.editorCommands[editorCommand.id] = editorCommand;
    };
    EditorContributionRegistry.prototype.getEditorCommand = function (commandId) {
        return (this.editorCommands[commandId] || null);
    };
    EditorContributionRegistry.INSTANCE = new EditorContributionRegistry();
    return EditorContributionRegistry;
}());
Registry.add(Extensions$3.EditorCommonContributions, EditorContributionRegistry.INSTANCE);

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var EditorZoom = new /** @class */ (function () {
    function class_1() {
        this._zoomLevel = 0;
        this._onDidChangeZoomLevel = new Emitter();
        this.onDidChangeZoomLevel = this._onDidChangeZoomLevel.event;
    }
    class_1.prototype.getZoomLevel = function () {
        return this._zoomLevel;
    };
    class_1.prototype.setZoomLevel = function (zoomLevel) {
        zoomLevel = Math.min(Math.max(-9, zoomLevel), 9);
        if (this._zoomLevel === zoomLevel) {
            return;
        }
        this._zoomLevel = zoomLevel;
        this._onDidChangeZoomLevel.fire(this._zoomLevel);
    };
    return class_1;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$i = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * Determined from empirical observations.
 * @internal
 */
var GOLDEN_LINE_HEIGHT_RATIO = isMacintosh ? 1.5 : 1.35;
/**
 * Font settings maximum and minimum limits
 */
var MINIMUM_FONT_SIZE = 8;
var MAXIMUM_FONT_SIZE = 100;
var MINIMUM_LINE_HEIGHT = 8;
var MAXIMUM_LINE_HEIGHT = 150;
var MINIMUM_LETTER_SPACING = -5;
var MAXIMUM_LETTER_SPACING = 20;
function safeParseFloat(n, defaultValue) {
    if (typeof n === 'number') {
        return n;
    }
    var r = parseFloat(n);
    if (isNaN(r)) {
        return defaultValue;
    }
    return r;
}
function safeParseInt(n, defaultValue) {
    if (typeof n === 'number') {
        return Math.round(n);
    }
    var r = parseInt(n);
    if (isNaN(r)) {
        return defaultValue;
    }
    return r;
}
function clamp(n, min, max) {
    if (n < min) {
        return min;
    }
    if (n > max) {
        return max;
    }
    return n;
}
function _string$1(value, defaultValue) {
    if (typeof value !== 'string') {
        return defaultValue;
    }
    return value;
}
var BareFontInfo = /** @class */ (function () {
    /**
     * @internal
     */
    function BareFontInfo(opts) {
        this.zoomLevel = opts.zoomLevel;
        this.fontFamily = String(opts.fontFamily);
        this.fontWeight = String(opts.fontWeight);
        this.fontSize = opts.fontSize;
        this.lineHeight = opts.lineHeight | 0;
        this.letterSpacing = opts.letterSpacing;
    }
    /**
     * @internal
     */
    BareFontInfo.createFromRawSettings = function (opts, zoomLevel) {
        var fontFamily = _string$1(opts.fontFamily, EDITOR_FONT_DEFAULTS.fontFamily);
        var fontWeight = _string$1(opts.fontWeight, EDITOR_FONT_DEFAULTS.fontWeight);
        var fontSize = safeParseFloat(opts.fontSize, EDITOR_FONT_DEFAULTS.fontSize);
        fontSize = clamp(fontSize, 0, MAXIMUM_FONT_SIZE);
        if (fontSize === 0) {
            fontSize = EDITOR_FONT_DEFAULTS.fontSize;
        }
        else if (fontSize < MINIMUM_FONT_SIZE) {
            fontSize = MINIMUM_FONT_SIZE;
        }
        var lineHeight = safeParseInt(opts.lineHeight, 0);
        lineHeight = clamp(lineHeight, 0, MAXIMUM_LINE_HEIGHT);
        if (lineHeight === 0) {
            lineHeight = Math.round(GOLDEN_LINE_HEIGHT_RATIO * fontSize);
        }
        else if (lineHeight < MINIMUM_LINE_HEIGHT) {
            lineHeight = MINIMUM_LINE_HEIGHT;
        }
        var letterSpacing = safeParseFloat(opts.letterSpacing, 0);
        letterSpacing = clamp(letterSpacing, MINIMUM_LETTER_SPACING, MAXIMUM_LETTER_SPACING);
        var editorZoomLevelMultiplier = 1 + (EditorZoom.getZoomLevel() * 0.1);
        fontSize *= editorZoomLevelMultiplier;
        lineHeight *= editorZoomLevelMultiplier;
        return new BareFontInfo({
            zoomLevel: zoomLevel,
            fontFamily: fontFamily,
            fontWeight: fontWeight,
            fontSize: fontSize,
            lineHeight: lineHeight,
            letterSpacing: letterSpacing
        });
    };
    /**
     * @internal
     */
    BareFontInfo.prototype.getId = function () {
        return this.zoomLevel + '-' + this.fontFamily + '-' + this.fontWeight + '-' + this.fontSize + '-' + this.lineHeight + '-' + this.letterSpacing;
    };
    return BareFontInfo;
}());
var FontInfo = /** @class */ (function (_super) {
    __extends$i(FontInfo, _super);
    /**
     * @internal
     */
    function FontInfo(opts, isTrusted) {
        var _this = _super.call(this, opts) || this;
        _this.isTrusted = isTrusted;
        _this.isMonospace = opts.isMonospace;
        _this.typicalHalfwidthCharacterWidth = opts.typicalHalfwidthCharacterWidth;
        _this.typicalFullwidthCharacterWidth = opts.typicalFullwidthCharacterWidth;
        _this.spaceWidth = opts.spaceWidth;
        _this.maxDigitWidth = opts.maxDigitWidth;
        return _this;
    }
    /**
     * @internal
     */
    FontInfo.prototype.equals = function (other) {
        return (this.fontFamily === other.fontFamily
            && this.fontWeight === other.fontWeight
            && this.fontSize === other.fontSize
            && this.lineHeight === other.lineHeight
            && this.letterSpacing === other.letterSpacing
            && this.typicalHalfwidthCharacterWidth === other.typicalHalfwidthCharacterWidth
            && this.typicalFullwidthCharacterWidth === other.typicalFullwidthCharacterWidth
            && this.spaceWidth === other.spaceWidth
            && this.maxDigitWidth === other.maxDigitWidth);
    };
    return FontInfo;
}(BareFontInfo));

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$j = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var EDITOR_DEFAULTS$1 = EDITOR_DEFAULTS;
var EDITOR_FONT_DEFAULTS$1 = EDITOR_FONT_DEFAULTS;
var EDITOR_MODEL_DEFAULTS$1 = EDITOR_MODEL_DEFAULTS;
var TabFocus = new /** @class */ (function () {
    function class_1() {
        this._tabFocus = false;
        this._onDidChangeTabFocus = new Emitter();
        this.onDidChangeTabFocus = this._onDidChangeTabFocus.event;
    }
    class_1.prototype.getTabFocusMode = function () {
        return this._tabFocus;
    };
    class_1.prototype.setTabFocusMode = function (tabFocusMode) {
        if (this._tabFocus === tabFocusMode) {
            return;
        }
        this._tabFocus = tabFocusMode;
        this._onDidChangeTabFocus.fire(this._tabFocus);
    };
    return class_1;
}());
var CommonEditorConfiguration = /** @class */ (function (_super) {
    __extends$j(CommonEditorConfiguration, _super);
    function CommonEditorConfiguration(options) {
        var _this = _super.call(this) || this;
        _this._onDidChange = _this._register(new Emitter());
        _this.onDidChange = _this._onDidChange.event;
        // Do a "deep clone of sorts" on the incoming options
        _this._rawOptions = mixin({}, options || {});
        _this._rawOptions.scrollbar = mixin({}, _this._rawOptions.scrollbar || {});
        _this._rawOptions.minimap = mixin({}, _this._rawOptions.minimap || {});
        _this._rawOptions.find = mixin({}, _this._rawOptions.find || {});
        _this._validatedOptions = EditorOptionsValidator.validate(_this._rawOptions, EDITOR_DEFAULTS$1);
        _this.editor = null;
        _this._isDominatedByLongLines = false;
        _this._lineNumbersDigitCount = 1;
        _this._register(EditorZoom.onDidChangeZoomLevel(function (_) { return _this._recomputeOptions(); }));
        _this._register(TabFocus.onDidChangeTabFocus(function (_) { return _this._recomputeOptions(); }));
        return _this;
    }
    CommonEditorConfiguration.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
    };
    CommonEditorConfiguration.prototype._recomputeOptions = function () {
        var oldOptions = this.editor;
        var newOptions = this._computeInternalOptions();
        if (oldOptions && oldOptions.equals(newOptions)) {
            return;
        }
        this.editor = newOptions;
        if (oldOptions) {
            this._onDidChange.fire(oldOptions.createChangeEvent(newOptions));
        }
    };
    CommonEditorConfiguration.prototype.getRawOptions = function () {
        return this._rawOptions;
    };
    CommonEditorConfiguration.prototype._computeInternalOptions = function () {
        var opts = this._validatedOptions;
        var partialEnv = this._getEnvConfiguration();
        var bareFontInfo = BareFontInfo.createFromRawSettings(this._rawOptions, partialEnv.zoomLevel);
        var env = {
            outerWidth: partialEnv.outerWidth,
            outerHeight: partialEnv.outerHeight,
            fontInfo: this.readConfiguration(bareFontInfo),
            extraEditorClassName: partialEnv.extraEditorClassName,
            isDominatedByLongLines: this._isDominatedByLongLines,
            lineNumbersDigitCount: this._lineNumbersDigitCount,
            emptySelectionClipboard: partialEnv.emptySelectionClipboard,
            pixelRatio: partialEnv.pixelRatio,
            tabFocusMode: TabFocus.getTabFocusMode(),
            accessibilitySupport: partialEnv.accessibilitySupport
        };
        return InternalEditorOptionsFactory.createInternalEditorOptions(env, opts);
    };
    CommonEditorConfiguration.prototype.updateOptions = function (newOptions) {
        this._rawOptions = mixin(this._rawOptions, newOptions || {});
        this._validatedOptions = EditorOptionsValidator.validate(this._rawOptions, EDITOR_DEFAULTS$1);
        this._recomputeOptions();
    };
    CommonEditorConfiguration.prototype.setIsDominatedByLongLines = function (isDominatedByLongLines) {
        this._isDominatedByLongLines = isDominatedByLongLines;
        this._recomputeOptions();
    };
    CommonEditorConfiguration.prototype.setMaxLineNumber = function (maxLineNumber) {
        var digitCount = CommonEditorConfiguration._digitCount(maxLineNumber);
        if (this._lineNumbersDigitCount === digitCount) {
            return;
        }
        this._lineNumbersDigitCount = digitCount;
        this._recomputeOptions();
    };
    CommonEditorConfiguration._digitCount = function (n) {
        var r = 0;
        while (n) {
            n = Math.floor(n / 10);
            r++;
        }
        return r ? r : 1;
    };
    return CommonEditorConfiguration;
}(Disposable));
var configurationRegistry$1 = Registry.as(Extensions$1.Configuration);
var editorConfiguration = {
    'id': 'editor',
    'order': 5,
    'type': 'object',
    'title': localize('editorConfigurationTitle', "Editor"),
    'overridable': true,
    'scope': ConfigurationScope.RESOURCE,
    'properties': {
        'editor.fontFamily': {
            'type': 'string',
            'default': EDITOR_FONT_DEFAULTS$1.fontFamily,
            'description': localize('fontFamily', "Controls the font family.")
        },
        'editor.fontWeight': {
            'type': 'string',
            'enum': ['normal', 'bold', '100', '200', '300', '400', '500', '600', '700', '800', '900'],
            'default': EDITOR_FONT_DEFAULTS$1.fontWeight,
            'description': localize('fontWeight', "Controls the font weight.")
        },
        'editor.fontSize': {
            'type': 'number',
            'default': EDITOR_FONT_DEFAULTS$1.fontSize,
            'description': localize('fontSize', "Controls the font size in pixels.")
        },
        'editor.lineHeight': {
            'type': 'number',
            'default': EDITOR_FONT_DEFAULTS$1.lineHeight,
            'description': localize('lineHeight', "Controls the line height. Use 0 to compute the lineHeight from the fontSize.")
        },
        'editor.letterSpacing': {
            'type': 'number',
            'default': EDITOR_FONT_DEFAULTS$1.letterSpacing,
            'description': localize('letterSpacing', "Controls the letter spacing in pixels.")
        },
        'editor.lineNumbers': {
            'type': 'string',
            'enum': ['off', 'on', 'relative', 'interval'],
            'enumDescriptions': [
                localize('lineNumbers.off', "Line numbers are not rendered."),
                localize('lineNumbers.on', "Line numbers are rendered as absolute number."),
                localize('lineNumbers.relative', "Line numbers are rendered as distance in lines to cursor position."),
                localize('lineNumbers.interval', "Line numbers are rendered every 10 lines.")
            ],
            'default': 'on',
            'description': localize('lineNumbers', "Controls the display of line numbers.")
        },
        'editor.rulers': {
            'type': 'array',
            'items': {
                'type': 'number'
            },
            'default': EDITOR_DEFAULTS$1.viewInfo.rulers,
            'description': localize('rulers', "Render vertical rulers after a certain number of monospace characters. Use multiple values for multiple rulers. No rulers are drawn if array is empty")
        },
        'editor.wordSeparators': {
            'type': 'string',
            'default': EDITOR_DEFAULTS$1.wordSeparators,
            'description': localize('wordSeparators', "Characters that will be used as word separators when doing word related navigations or operations")
        },
        'editor.tabSize': {
            'type': 'number',
            'default': EDITOR_MODEL_DEFAULTS$1.tabSize,
            'minimum': 1,
            'description': localize('tabSize', "The number of spaces a tab is equal to. This setting is overridden based on the file contents when `editor.detectIndentation` is on."),
            'errorMessage': localize('tabSize.errorMessage', "Expected 'number'. Note that the value \"auto\" has been replaced by the `editor.detectIndentation` setting.")
        },
        'editor.insertSpaces': {
            'type': 'boolean',
            'default': EDITOR_MODEL_DEFAULTS$1.insertSpaces,
            'description': localize('insertSpaces', "Insert spaces when pressing Tab. This setting is overridden based on the file contents when `editor.detectIndentation` is on."),
            'errorMessage': localize('insertSpaces.errorMessage', "Expected 'boolean'. Note that the value \"auto\" has been replaced by the `editor.detectIndentation` setting.")
        },
        'editor.detectIndentation': {
            'type': 'boolean',
            'default': EDITOR_MODEL_DEFAULTS$1.detectIndentation,
            'description': localize('detectIndentation', "When opening a file, `editor.tabSize` and `editor.insertSpaces` will be detected based on the file contents.")
        },
        'editor.roundedSelection': {
            'type': 'boolean',
            'default': EDITOR_DEFAULTS$1.viewInfo.roundedSelection,
            'description': localize('roundedSelection', "Controls if selections have rounded corners")
        },
        'editor.scrollBeyondLastLine': {
            'type': 'boolean',
            'default': EDITOR_DEFAULTS$1.viewInfo.scrollBeyondLastLine,
            'description': localize('scrollBeyondLastLine', "Controls if the editor will scroll beyond the last line")
        },
        'editor.smoothScrolling': {
            'type': 'boolean',
            'default': EDITOR_DEFAULTS$1.viewInfo.smoothScrolling,
            'description': localize('smoothScrolling', "Controls if the editor will scroll using an animation")
        },
        'editor.minimap.enabled': {
            'type': 'boolean',
            'default': EDITOR_DEFAULTS$1.viewInfo.minimap.enabled,
            'description': localize('minimap.enabled', "Controls if the minimap is shown")
        },
        'editor.minimap.side': {
            'type': 'string',
            'enum': ['left', 'right'],
            'default': EDITOR_DEFAULTS$1.viewInfo.minimap.side,
            'description': localize('minimap.side', "Controls the side where to render the minimap.")
        },
        'editor.minimap.showSlider': {
            'type': 'string',
            'enum': ['always', 'mouseover'],
            'default': EDITOR_DEFAULTS$1.viewInfo.minimap.showSlider,
            'description': localize('minimap.showSlider', "Controls whether the minimap slider is automatically hidden.")
        },
        'editor.minimap.renderCharacters': {
            'type': 'boolean',
            'default': EDITOR_DEFAULTS$1.viewInfo.minimap.renderCharacters,
            'description': localize('minimap.renderCharacters', "Render the actual characters on a line (as opposed to color blocks)")
        },
        'editor.minimap.maxColumn': {
            'type': 'number',
            'default': EDITOR_DEFAULTS$1.viewInfo.minimap.maxColumn,
            'description': localize('minimap.maxColumn', "Limit the width of the minimap to render at most a certain number of columns")
        },
        'editor.find.seedSearchStringFromSelection': {
            'type': 'boolean',
            'default': EDITOR_DEFAULTS$1.contribInfo.find.seedSearchStringFromSelection,
            'description': localize('find.seedSearchStringFromSelection', "Controls if we seed the search string in Find Widget from editor selection")
        },
        'editor.find.autoFindInSelection': {
            'type': 'boolean',
            'default': EDITOR_DEFAULTS$1.contribInfo.find.autoFindInSelection,
            'description': localize('find.autoFindInSelection', "Controls if Find in Selection flag is turned on when multiple characters or lines of text are selected in the editor")
        },
        'editor.find.globalFindClipboard': {
            'type': 'boolean',
            'default': EDITOR_DEFAULTS$1.contribInfo.find.globalFindClipboard,
            'description': localize('find.globalFindClipboard', "Controls if the Find Widget should read or modify the shared find clipboard on macOS"),
            'included': isMacintosh
        },
        'editor.wordWrap': {
            'type': 'string',
            'enum': ['off', 'on', 'wordWrapColumn', 'bounded'],
            'enumDescriptions': [
                localize('wordWrap.off', "Lines will never wrap."),
                localize('wordWrap.on', "Lines will wrap at the viewport width."),
                localize({
                    key: 'wordWrap.wordWrapColumn',
                    comment: [
                        '- `editor.wordWrapColumn` refers to a different setting and should not be localized.'
                    ]
                }, "Lines will wrap at `editor.wordWrapColumn`."),
                localize({
                    key: 'wordWrap.bounded',
                    comment: [
                        '- viewport means the edge of the visible window size.',
                        '- `editor.wordWrapColumn` refers to a different setting and should not be localized.'
                    ]
                }, "Lines will wrap at the minimum of viewport and `editor.wordWrapColumn`."),
            ],
            'default': EDITOR_DEFAULTS$1.wordWrap,
            'description': localize({
                key: 'wordWrap',
                comment: [
                    '- \'off\', \'on\', \'wordWrapColumn\' and \'bounded\' refer to values the setting can take and should not be localized.',
                    '- `editor.wordWrapColumn` refers to a different setting and should not be localized.'
                ]
            }, "Controls how lines should wrap. Can be:\n - 'off' (disable wrapping),\n - 'on' (viewport wrapping),\n - 'wordWrapColumn' (wrap at `editor.wordWrapColumn`) or\n - 'bounded' (wrap at minimum of viewport and `editor.wordWrapColumn`).")
        },
        'editor.wordWrapColumn': {
            'type': 'integer',
            'default': EDITOR_DEFAULTS$1.wordWrapColumn,
            'minimum': 1,
            'description': localize({
                key: 'wordWrapColumn',
                comment: [
                    '- `editor.wordWrap` refers to a different setting and should not be localized.',
                    '- \'wordWrapColumn\' and \'bounded\' refer to values the different setting can take and should not be localized.'
                ]
            }, "Controls the wrapping column of the editor when `editor.wordWrap` is 'wordWrapColumn' or 'bounded'.")
        },
        'editor.wrappingIndent': {
            'type': 'string',
            'enum': ['none', 'same', 'indent'],
            'default': 'same',
            'description': localize('wrappingIndent', "Controls the indentation of wrapped lines. Can be one of 'none', 'same' or 'indent'.")
        },
        'editor.mouseWheelScrollSensitivity': {
            'type': 'number',
            'default': EDITOR_DEFAULTS$1.viewInfo.scrollbar.mouseWheelScrollSensitivity,
            'description': localize('mouseWheelScrollSensitivity', "A multiplier to be used on the `deltaX` and `deltaY` of mouse wheel scroll events")
        },
        'editor.multiCursorModifier': {
            'type': 'string',
            'enum': ['ctrlCmd', 'alt'],
            'enumDescriptions': [
                localize('multiCursorModifier.ctrlCmd', "Maps to `Control` on Windows and Linux and to `Command` on macOS."),
                localize('multiCursorModifier.alt', "Maps to `Alt` on Windows and Linux and to `Option` on macOS.")
            ],
            'default': 'alt',
            'description': localize({
                key: 'multiCursorModifier',
                comment: [
                    '- `ctrlCmd` refers to a value the setting can take and should not be localized.',
                    '- `Control` and `Command` refer to the modifier keys Ctrl or Cmd on the keyboard and can be localized.'
                ]
            }, "The modifier to be used to add multiple cursors with the mouse. `ctrlCmd` maps to `Control` on Windows and Linux and to `Command` on macOS. The Go To Definition and Open Link mouse gestures will adapt such that they do not conflict with the multicursor modifier.")
        },
        'editor.multiCursorMergeOverlapping': {
            'type': 'boolean',
            'default': EDITOR_DEFAULTS$1.multiCursorMergeOverlapping,
            'description': localize('multiCursorMergeOverlapping', "Merge multiple cursors when they are overlapping.")
        },
        'editor.quickSuggestions': {
            'anyOf': [
                {
                    type: 'boolean',
                },
                {
                    type: 'object',
                    properties: {
                        strings: {
                            type: 'boolean',
                            default: false,
                            description: localize('quickSuggestions.strings', "Enable quick suggestions inside strings.")
                        },
                        comments: {
                            type: 'boolean',
                            default: false,
                            description: localize('quickSuggestions.comments', "Enable quick suggestions inside comments.")
                        },
                        other: {
                            type: 'boolean',
                            default: true,
                            description: localize('quickSuggestions.other', "Enable quick suggestions outside of strings and comments.")
                        },
                    }
                }
            ],
            'default': EDITOR_DEFAULTS$1.contribInfo.quickSuggestions,
            'description': localize('quickSuggestions', "Controls if suggestions should automatically show up while typing")
        },
        'editor.quickSuggestionsDelay': {
            'type': 'integer',
            'default': EDITOR_DEFAULTS$1.contribInfo.quickSuggestionsDelay,
            'minimum': 0,
            'description': localize('quickSuggestionsDelay', "Controls the delay in ms after which quick suggestions will show up")
        },
        'editor.parameterHints': {
            'type': 'boolean',
            'default': EDITOR_DEFAULTS$1.contribInfo.parameterHints,
            'description': localize('parameterHints', "Enables pop-up that shows parameter documentation and type information as you type")
        },
        'editor.autoClosingBrackets': {
            'type': 'boolean',
            'default': EDITOR_DEFAULTS$1.autoClosingBrackets,
            'description': localize('autoClosingBrackets', "Controls if the editor should automatically close brackets after opening them")
        },
        'editor.formatOnType': {
            'type': 'boolean',
            'default': EDITOR_DEFAULTS$1.contribInfo.formatOnType,
            'description': localize('formatOnType', "Controls if the editor should automatically format the line after typing")
        },
        'editor.formatOnPaste': {
            'type': 'boolean',
            'default': EDITOR_DEFAULTS$1.contribInfo.formatOnPaste,
            'description': localize('formatOnPaste', "Controls if the editor should automatically format the pasted content. A formatter must be available and the formatter should be able to format a range in a document.")
        },
        'editor.autoIndent': {
            'type': 'boolean',
            'default': EDITOR_DEFAULTS$1.autoIndent,
            'description': localize('autoIndent', "Controls if the editor should automatically adjust the indentation when users type, paste or move lines. Indentation rules of the language must be available.")
        },
        'editor.suggestOnTriggerCharacters': {
            'type': 'boolean',
            'default': EDITOR_DEFAULTS$1.contribInfo.suggestOnTriggerCharacters,
            'description': localize('suggestOnTriggerCharacters', "Controls if suggestions should automatically show up when typing trigger characters")
        },
        'editor.acceptSuggestionOnEnter': {
            'type': 'string',
            'enum': ['on', 'smart', 'off'],
            'default': EDITOR_DEFAULTS$1.contribInfo.acceptSuggestionOnEnter,
            'description': localize('acceptSuggestionOnEnter', "Controls if suggestions should be accepted on 'Enter' - in addition to 'Tab'. Helps to avoid ambiguity between inserting new lines or accepting suggestions. The value 'smart' means only accept a suggestion with Enter when it makes a textual change")
        },
        'editor.acceptSuggestionOnCommitCharacter': {
            'type': 'boolean',
            'default': EDITOR_DEFAULTS$1.contribInfo.acceptSuggestionOnCommitCharacter,
            'description': localize('acceptSuggestionOnCommitCharacter', "Controls if suggestions should be accepted on commit characters. For instance in JavaScript the semi-colon (';') can be a commit character that accepts a suggestion and types that character.")
        },
        'editor.snippetSuggestions': {
            'type': 'string',
            'enum': ['top', 'bottom', 'inline', 'none'],
            'enumDescriptions': [
                localize('snippetSuggestions.top', "Show snippet suggestions on top of other suggestions."),
                localize('snippetSuggestions.bottom', "Show snippet suggestions below other suggestions."),
                localize('snippetSuggestions.inline', "Show snippets suggestions with other suggestions."),
                localize('snippetSuggestions.none', "Do not show snippet suggestions."),
            ],
            'default': EDITOR_DEFAULTS$1.contribInfo.snippetSuggestions,
            'description': localize('snippetSuggestions', "Controls whether snippets are shown with other suggestions and how they are sorted.")
        },
        'editor.emptySelectionClipboard': {
            'type': 'boolean',
            'default': EDITOR_DEFAULTS$1.emptySelectionClipboard,
            'description': localize('emptySelectionClipboard', "Controls whether copying without a selection copies the current line.")
        },
        'editor.wordBasedSuggestions': {
            'type': 'boolean',
            'default': EDITOR_DEFAULTS$1.contribInfo.wordBasedSuggestions,
            'description': localize('wordBasedSuggestions', "Controls whether completions should be computed based on words in the document.")
        },
        'editor.suggestSelection': {
            'type': 'string',
            'enum': ['first', 'recentlyUsed', 'recentlyUsedByPrefix'],
            'enumDescriptions': [
                localize('suggestSelection.first', "Always select the first suggestion."),
                localize('suggestSelection.recentlyUsed', "Select recent suggestions unless further typing selects one, e.g. `console.| -> console.log` because `log` has been completed recently."),
                localize('suggestSelection.recentlyUsedByPrefix', "Select suggestions based on previous prefixes that have completed those suggestions, e.g. `co -> console` and `con -> const`."),
            ],
            'default': 'recentlyUsed',
            'description': localize('suggestSelection', "Controls how suggestions are pre-selected when showing the suggest list.")
        },
        'editor.suggestFontSize': {
            'type': 'integer',
            'default': 0,
            'minimum': 0,
            'description': localize('suggestFontSize', "Font size for the suggest widget")
        },
        'editor.suggestLineHeight': {
            'type': 'integer',
            'default': 0,
            'minimum': 0,
            'description': localize('suggestLineHeight', "Line height for the suggest widget")
        },
        'editor.selectionHighlight': {
            'type': 'boolean',
            'default': EDITOR_DEFAULTS$1.contribInfo.selectionHighlight,
            'description': localize('selectionHighlight', "Controls whether the editor should highlight similar matches to the selection")
        },
        'editor.occurrencesHighlight': {
            'type': 'boolean',
            'default': EDITOR_DEFAULTS$1.contribInfo.occurrencesHighlight,
            'description': localize('occurrencesHighlight', "Controls whether the editor should highlight semantic symbol occurrences")
        },
        'editor.overviewRulerLanes': {
            'type': 'integer',
            'default': 3,
            'description': localize('overviewRulerLanes', "Controls the number of decorations that can show up at the same position in the overview ruler")
        },
        'editor.overviewRulerBorder': {
            'type': 'boolean',
            'default': EDITOR_DEFAULTS$1.viewInfo.overviewRulerBorder,
            'description': localize('overviewRulerBorder', "Controls if a border should be drawn around the overview ruler.")
        },
        'editor.cursorBlinking': {
            'type': 'string',
            'enum': ['blink', 'smooth', 'phase', 'expand', 'solid'],
            'default': blinkingStyleToString(EDITOR_DEFAULTS$1.viewInfo.cursorBlinking),
            'description': localize('cursorBlinking', "Control the cursor animation style.")
        },
        'editor.mouseWheelZoom': {
            'type': 'boolean',
            'default': EDITOR_DEFAULTS$1.viewInfo.mouseWheelZoom,
            'description': localize('mouseWheelZoom', "Zoom the font of the editor when using mouse wheel and holding Ctrl")
        },
        'editor.cursorStyle': {
            'type': 'string',
            'enum': ['block', 'block-outline', 'line', 'line-thin', 'underline', 'underline-thin'],
            'default': cursorStyleToString(EDITOR_DEFAULTS$1.viewInfo.cursorStyle),
            'description': localize('cursorStyle', "Controls the cursor style, accepted values are 'block', 'block-outline', 'line', 'line-thin', 'underline' and 'underline-thin'")
        },
        'editor.cursorWidth': {
            'type': 'integer',
            'default': EDITOR_DEFAULTS$1.viewInfo.cursorWidth,
            'description': localize('cursorWidth', "Controls the width of the cursor when editor.cursorStyle is set to 'line'")
        },
        'editor.fontLigatures': {
            'type': 'boolean',
            'default': EDITOR_DEFAULTS$1.viewInfo.fontLigatures,
            'description': localize('fontLigatures', "Enables font ligatures")
        },
        'editor.hideCursorInOverviewRuler': {
            'type': 'boolean',
            'default': EDITOR_DEFAULTS$1.viewInfo.hideCursorInOverviewRuler,
            'description': localize('hideCursorInOverviewRuler', "Controls if the cursor should be hidden in the overview ruler.")
        },
        'editor.renderWhitespace': {
            'type': 'string',
            'enum': ['none', 'boundary', 'all'],
            default: EDITOR_DEFAULTS$1.viewInfo.renderWhitespace,
            description: localize('renderWhitespace', "Controls how the editor should render whitespace characters, possibilities are 'none', 'boundary', and 'all'. The 'boundary' option does not render single spaces between words.")
        },
        'editor.renderControlCharacters': {
            'type': 'boolean',
            default: EDITOR_DEFAULTS$1.viewInfo.renderControlCharacters,
            description: localize('renderControlCharacters', "Controls whether the editor should render control characters")
        },
        'editor.renderIndentGuides': {
            'type': 'boolean',
            default: EDITOR_DEFAULTS$1.viewInfo.renderIndentGuides,
            description: localize('renderIndentGuides', "Controls whether the editor should render indent guides")
        },
        'editor.renderLineHighlight': {
            'type': 'string',
            'enum': ['none', 'gutter', 'line', 'all'],
            default: EDITOR_DEFAULTS$1.viewInfo.renderLineHighlight,
            description: localize('renderLineHighlight', "Controls how the editor should render the current line highlight, possibilities are 'none', 'gutter', 'line', and 'all'.")
        },
        'editor.codeLens': {
            'type': 'boolean',
            'default': EDITOR_DEFAULTS$1.contribInfo.codeLens,
            'description': localize('codeLens', "Controls if the editor shows CodeLens")
        },
        'editor.folding': {
            'type': 'boolean',
            'default': EDITOR_DEFAULTS$1.contribInfo.folding,
            'description': localize('folding', "Controls whether the editor has code folding enabled")
        },
        'editor.foldingStrategy': {
            'type': 'string',
            'enum': ['auto', 'indentation'],
            'enumDescriptions': [
                localize('foldingStrategyAuto', 'If available, use a language specific folding strategy, otherwise falls back to the indentation based strategy.'),
                localize('foldingStrategyIndentation', 'Always use the indentation based folding strategy')
            ],
            'default': EDITOR_DEFAULTS$1.contribInfo.foldingStrategy,
            'description': localize('foldingStrategy', "Controls the way folding ranges are computed. 'auto' picks uses a language specific folding strategy, if available. 'indentation' forces that the indentation based folding strategy is used.")
        },
        'editor.showFoldingControls': {
            'type': 'string',
            'enum': ['always', 'mouseover'],
            'default': EDITOR_DEFAULTS$1.contribInfo.showFoldingControls,
            'description': localize('showFoldingControls', "Controls whether the fold controls on the gutter are automatically hidden.")
        },
        'editor.matchBrackets': {
            'type': 'boolean',
            'default': EDITOR_DEFAULTS$1.contribInfo.matchBrackets,
            'description': localize('matchBrackets', "Highlight matching brackets when one of them is selected.")
        },
        'editor.glyphMargin': {
            'type': 'boolean',
            'default': EDITOR_DEFAULTS$1.viewInfo.glyphMargin,
            'description': localize('glyphMargin', "Controls whether the editor should render the vertical glyph margin. Glyph margin is mostly used for debugging.")
        },
        'editor.useTabStops': {
            'type': 'boolean',
            'default': EDITOR_DEFAULTS$1.useTabStops,
            'description': localize('useTabStops', "Inserting and deleting whitespace follows tab stops")
        },
        'editor.trimAutoWhitespace': {
            'type': 'boolean',
            'default': EDITOR_MODEL_DEFAULTS$1.trimAutoWhitespace,
            'description': localize('trimAutoWhitespace', "Remove trailing auto inserted whitespace")
        },
        'editor.stablePeek': {
            'type': 'boolean',
            'default': false,
            'description': localize('stablePeek', "Keep peek editors open even when double clicking their content or when hitting Escape.")
        },
        'editor.dragAndDrop': {
            'type': 'boolean',
            'default': EDITOR_DEFAULTS$1.dragAndDrop,
            'description': localize('dragAndDrop', "Controls if the editor should allow to move selections via drag and drop.")
        },
        'editor.accessibilitySupport': {
            'type': 'string',
            'enum': ['auto', 'on', 'off'],
            'enumDescriptions': [
                localize('accessibilitySupport.auto', "The editor will use platform APIs to detect when a Screen Reader is attached."),
                localize('accessibilitySupport.on', "The editor will be permanently optimized for usage with a Screen Reader."),
                localize('accessibilitySupport.off', "The editor will never be optimized for usage with a Screen Reader."),
            ],
            'default': EDITOR_DEFAULTS$1.accessibilitySupport,
            'description': localize('accessibilitySupport', "Controls whether the editor should run in a mode where it is optimized for screen readers.")
        },
        'editor.links': {
            'type': 'boolean',
            'default': EDITOR_DEFAULTS$1.contribInfo.links,
            'description': localize('links', "Controls whether the editor should detect links and make them clickable")
        },
        'editor.colorDecorators': {
            'type': 'boolean',
            'default': EDITOR_DEFAULTS$1.contribInfo.colorDecorators,
            'description': localize('colorDecorators', "Controls whether the editor should render the inline color decorators and color picker.")
        },
        'editor.lightbulb.enabled': {
            'type': 'boolean',
            'default': EDITOR_DEFAULTS$1.contribInfo.lightbulbEnabled,
            'description': localize('codeActions', "Enables the code action lightbulb")
        },
        'editor.codeActionsOnSave': {
            'type': 'object',
            'properties': {
                'source.organizeImports': {
                    'type': 'boolean',
                    'description': localize('codeActionsOnSave.organizeImports', "Run organize imports on save?")
                }
            },
            'additionalProperties': {
                'type': 'boolean'
            },
            'default': EDITOR_DEFAULTS$1.contribInfo.codeActionsOnSave,
            'description': localize('codeActionsOnSave', "Code action kinds to be run on save.")
        },
        'editor.codeActionsOnSaveTimeout': {
            'type': 'number',
            'default': EDITOR_DEFAULTS$1.contribInfo.codeActionsOnSaveTimeout,
            'description': localize('codeActionsOnSaveTimeout', "Timeout for code actions run on save.")
        },
        'editor.selectionClipboard': {
            'type': 'boolean',
            'default': EDITOR_DEFAULTS$1.contribInfo.selectionClipboard,
            'description': localize('selectionClipboard', "Controls if the Linux primary clipboard should be supported."),
            'included': isLinux
        },
        'diffEditor.renderSideBySide': {
            'type': 'boolean',
            'default': true,
            'description': localize('sideBySide', "Controls if the diff editor shows the diff side by side or inline")
        },
        'diffEditor.ignoreTrimWhitespace': {
            'type': 'boolean',
            'default': true,
            'description': localize('ignoreTrimWhitespace', "Controls if the diff editor shows changes in leading or trailing whitespace as diffs")
        },
        'editor.largeFileOptimizations': {
            'type': 'boolean',
            'default': EDITOR_MODEL_DEFAULTS$1.largeFileOptimizations,
            'description': localize('largeFileOptimizations', "Special handling for large files to disable certain memory intensive features.")
        },
        'diffEditor.renderIndicators': {
            'type': 'boolean',
            'default': true,
            'description': localize('renderIndicators', "Controls if the diff editor shows +/- indicators for added/removed changes")
        }
    }
};
configurationRegistry$1.registerConfiguration(editorConfiguration);

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$k = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var ElementSizeObserver = /** @class */ (function (_super) {
    __extends$k(ElementSizeObserver, _super);
    function ElementSizeObserver(referenceDomElement, changeCallback) {
        var _this = _super.call(this) || this;
        _this.referenceDomElement = referenceDomElement;
        _this.changeCallback = changeCallback;
        _this.measureReferenceDomElementToken = -1;
        _this.width = -1;
        _this.height = -1;
        _this.measureReferenceDomElement(false);
        return _this;
    }
    ElementSizeObserver.prototype.dispose = function () {
        this.stopObserving();
        _super.prototype.dispose.call(this);
    };
    ElementSizeObserver.prototype.getWidth = function () {
        return this.width;
    };
    ElementSizeObserver.prototype.getHeight = function () {
        return this.height;
    };
    ElementSizeObserver.prototype.startObserving = function () {
        var _this = this;
        if (this.measureReferenceDomElementToken === -1) {
            this.measureReferenceDomElementToken = setInterval(function () { return _this.measureReferenceDomElement(true); }, 100);
        }
    };
    ElementSizeObserver.prototype.stopObserving = function () {
        if (this.measureReferenceDomElementToken !== -1) {
            clearInterval(this.measureReferenceDomElementToken);
            this.measureReferenceDomElementToken = -1;
        }
    };
    ElementSizeObserver.prototype.observe = function (dimension) {
        this.measureReferenceDomElement(true, dimension);
    };
    ElementSizeObserver.prototype.measureReferenceDomElement = function (callChangeCallback, dimension) {
        var observedWidth = 0;
        var observedHeight = 0;
        if (dimension) {
            observedWidth = dimension.width;
            observedHeight = dimension.height;
        }
        else if (this.referenceDomElement) {
            observedWidth = this.referenceDomElement.clientWidth;
            observedHeight = this.referenceDomElement.clientHeight;
        }
        observedWidth = Math.max(5, observedWidth);
        observedHeight = Math.max(5, observedHeight);
        if (this.width !== observedWidth || this.height !== observedHeight) {
            this.width = observedWidth;
            this.height = observedHeight;
            if (callChangeCallback) {
                this.changeCallback();
            }
        }
    };
    return ElementSizeObserver;
}(Disposable));

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var CharWidthRequest = /** @class */ (function () {
    function CharWidthRequest(chr, type) {
        this.chr = chr;
        this.type = type;
        this.width = 0;
    }
    CharWidthRequest.prototype.fulfill = function (width) {
        this.width = width;
    };
    return CharWidthRequest;
}());
var DomCharWidthReader = /** @class */ (function () {
    function DomCharWidthReader(bareFontInfo, requests) {
        this._bareFontInfo = bareFontInfo;
        this._requests = requests;
        this._container = null;
        this._testElements = null;
    }
    DomCharWidthReader.prototype.read = function () {
        // Create a test container with all these test elements
        this._createDomElements();
        // Add the container to the DOM
        document.body.appendChild(this._container);
        // Read character widths
        this._readFromDomElements();
        // Remove the container from the DOM
        document.body.removeChild(this._container);
        this._container = null;
        this._testElements = null;
    };
    DomCharWidthReader.prototype._createDomElements = function () {
        var container = document.createElement('div');
        container.style.position = 'absolute';
        container.style.top = '-50000px';
        container.style.width = '50000px';
        var regularDomNode = document.createElement('div');
        regularDomNode.style.fontFamily = this._bareFontInfo.fontFamily;
        regularDomNode.style.fontWeight = this._bareFontInfo.fontWeight;
        regularDomNode.style.fontSize = this._bareFontInfo.fontSize + 'px';
        regularDomNode.style.lineHeight = this._bareFontInfo.lineHeight + 'px';
        regularDomNode.style.letterSpacing = this._bareFontInfo.letterSpacing + 'px';
        container.appendChild(regularDomNode);
        var boldDomNode = document.createElement('div');
        boldDomNode.style.fontFamily = this._bareFontInfo.fontFamily;
        boldDomNode.style.fontWeight = 'bold';
        boldDomNode.style.fontSize = this._bareFontInfo.fontSize + 'px';
        boldDomNode.style.lineHeight = this._bareFontInfo.lineHeight + 'px';
        boldDomNode.style.letterSpacing = this._bareFontInfo.letterSpacing + 'px';
        container.appendChild(boldDomNode);
        var italicDomNode = document.createElement('div');
        italicDomNode.style.fontFamily = this._bareFontInfo.fontFamily;
        italicDomNode.style.fontWeight = this._bareFontInfo.fontWeight;
        italicDomNode.style.fontSize = this._bareFontInfo.fontSize + 'px';
        italicDomNode.style.lineHeight = this._bareFontInfo.lineHeight + 'px';
        italicDomNode.style.letterSpacing = this._bareFontInfo.letterSpacing + 'px';
        italicDomNode.style.fontStyle = 'italic';
        container.appendChild(italicDomNode);
        var testElements = [];
        for (var i = 0, len = this._requests.length; i < len; i++) {
            var request = this._requests[i];
            var parent_1 = void 0;
            if (request.type === 0 /* Regular */) {
                parent_1 = regularDomNode;
            }
            if (request.type === 2 /* Bold */) {
                parent_1 = boldDomNode;
            }
            if (request.type === 1 /* Italic */) {
                parent_1 = italicDomNode;
            }
            parent_1.appendChild(document.createElement('br'));
            var testElement = document.createElement('span');
            DomCharWidthReader._render(testElement, request);
            parent_1.appendChild(testElement);
            testElements[i] = testElement;
        }
        this._container = container;
        this._testElements = testElements;
    };
    DomCharWidthReader._render = function (testElement, request) {
        if (request.chr === ' ') {
            var htmlString = '&nbsp;';
            // Repeat character 256 (2^8) times
            for (var i = 0; i < 8; i++) {
                htmlString += htmlString;
            }
            testElement.innerHTML = htmlString;
        }
        else {
            var testString = request.chr;
            // Repeat character 256 (2^8) times
            for (var i = 0; i < 8; i++) {
                testString += testString;
            }
            testElement.textContent = testString;
        }
    };
    DomCharWidthReader.prototype._readFromDomElements = function () {
        for (var i = 0, len = this._requests.length; i < len; i++) {
            var request = this._requests[i];
            var testElement = this._testElements[i];
            request.fulfill(testElement.offsetWidth / 256);
        }
    };
    return DomCharWidthReader;
}());
function readCharWidths(bareFontInfo, requests) {
    var reader = new DomCharWidthReader(bareFontInfo, requests);
    reader.read();
}

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var ID = 'storageService';
var IStorageService = createDecorator(ID);
var StorageScope;
(function (StorageScope) {
    /**
     * The stored data will be scoped to all workspaces of this domain.
     */
    StorageScope[StorageScope["GLOBAL"] = 0] = "GLOBAL";
    /**
     * The stored data will be scoped to the current workspace.
     */
    StorageScope[StorageScope["WORKSPACE"] = 1] = "WORKSPACE";
})(StorageScope || (StorageScope = {}));
var NullStorageService = {
    _serviceBrand: undefined,
    store: function () { return undefined; },
    remove: function () { return undefined; },
    get: function (a, b, defaultValue) { return defaultValue; },
    getInteger: function (a, b, defaultValue) { return defaultValue; },
    getBoolean: function (a, b, defaultValue) { return defaultValue; }
};

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$l = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var CSSBasedConfigurationCache = /** @class */ (function () {
    function CSSBasedConfigurationCache() {
        this._keys = Object.create(null);
        this._values = Object.create(null);
    }
    CSSBasedConfigurationCache.prototype.has = function (item) {
        var itemId = item.getId();
        return !!this._values[itemId];
    };
    CSSBasedConfigurationCache.prototype.get = function (item) {
        var itemId = item.getId();
        return this._values[itemId];
    };
    CSSBasedConfigurationCache.prototype.put = function (item, value) {
        var itemId = item.getId();
        this._keys[itemId] = item;
        this._values[itemId] = value;
    };
    CSSBasedConfigurationCache.prototype.remove = function (item) {
        var itemId = item.getId();
        delete this._keys[itemId];
        delete this._values[itemId];
    };
    CSSBasedConfigurationCache.prototype.getValues = function () {
        var _this = this;
        return Object.keys(this._keys).map(function (id) { return _this._values[id]; });
    };
    return CSSBasedConfigurationCache;
}());
var CSSBasedConfiguration = /** @class */ (function (_super) {
    __extends$l(CSSBasedConfiguration, _super);
    function CSSBasedConfiguration() {
        var _this = _super.call(this) || this;
        _this._onDidChange = _this._register(new Emitter());
        _this.onDidChange = _this._onDidChange.event;
        _this._cache = new CSSBasedConfigurationCache();
        _this._evictUntrustedReadingsTimeout = -1;
        return _this;
    }
    CSSBasedConfiguration.prototype.dispose = function () {
        if (this._evictUntrustedReadingsTimeout !== -1) {
            clearTimeout(this._evictUntrustedReadingsTimeout);
            this._evictUntrustedReadingsTimeout = -1;
        }
        _super.prototype.dispose.call(this);
    };
    CSSBasedConfiguration.prototype._writeToCache = function (item, value) {
        var _this = this;
        this._cache.put(item, value);
        if (!value.isTrusted && this._evictUntrustedReadingsTimeout === -1) {
            // Try reading again after some time
            this._evictUntrustedReadingsTimeout = setTimeout(function () {
                _this._evictUntrustedReadingsTimeout = -1;
                _this._evictUntrustedReadings();
            }, 5000);
        }
    };
    CSSBasedConfiguration.prototype._evictUntrustedReadings = function () {
        var values = this._cache.getValues();
        var somethingRemoved = false;
        for (var i = 0, len = values.length; i < len; i++) {
            var item = values[i];
            if (!item.isTrusted) {
                somethingRemoved = true;
                this._cache.remove(item);
            }
        }
        if (somethingRemoved) {
            this._onDidChange.fire();
        }
    };
    CSSBasedConfiguration.prototype.saveFontInfo = function () {
        // Only save trusted font info (that has been measured in this running instance)
        return this._cache.getValues().filter(function (item) { return item.isTrusted; });
    };
    CSSBasedConfiguration.prototype.restoreFontInfo = function (savedFontInfo) {
        // Take all the saved font info and insert them in the cache without the trusted flag.
        // The reason for this is that a font might have been installed on the OS in the meantime.
        for (var i = 0, len = savedFontInfo.length; i < len; i++) {
            var fontInfo = new FontInfo(savedFontInfo[i], false);
            this._writeToCache(fontInfo, fontInfo);
        }
    };
    CSSBasedConfiguration.prototype.readConfiguration = function (bareFontInfo) {
        if (!this._cache.has(bareFontInfo)) {
            var readConfig = CSSBasedConfiguration._actualReadConfiguration(bareFontInfo);
            if (readConfig.typicalHalfwidthCharacterWidth <= 2 || readConfig.typicalFullwidthCharacterWidth <= 2 || readConfig.spaceWidth <= 2 || readConfig.maxDigitWidth <= 2) {
                // Hey, it's Bug 14341 ... we couldn't read
                readConfig = new FontInfo({
                    zoomLevel: getZoomLevel(),
                    fontFamily: readConfig.fontFamily,
                    fontWeight: readConfig.fontWeight,
                    fontSize: readConfig.fontSize,
                    lineHeight: readConfig.lineHeight,
                    letterSpacing: readConfig.letterSpacing,
                    isMonospace: readConfig.isMonospace,
                    typicalHalfwidthCharacterWidth: Math.max(readConfig.typicalHalfwidthCharacterWidth, 5),
                    typicalFullwidthCharacterWidth: Math.max(readConfig.typicalFullwidthCharacterWidth, 5),
                    spaceWidth: Math.max(readConfig.spaceWidth, 5),
                    maxDigitWidth: Math.max(readConfig.maxDigitWidth, 5),
                }, false);
            }
            this._writeToCache(bareFontInfo, readConfig);
        }
        return this._cache.get(bareFontInfo);
    };
    CSSBasedConfiguration.createRequest = function (chr, type, all, monospace) {
        var result = new CharWidthRequest(chr, type);
        all.push(result);
        if (monospace) {
            monospace.push(result);
        }
        return result;
    };
    CSSBasedConfiguration._actualReadConfiguration = function (bareFontInfo) {
        var all = [];
        var monospace = [];
        var typicalHalfwidthCharacter = this.createRequest('n', 0 /* Regular */, all, monospace);
        var typicalFullwidthCharacter = this.createRequest('\uff4d', 0 /* Regular */, all, null);
        var space = this.createRequest(' ', 0 /* Regular */, all, monospace);
        var digit0 = this.createRequest('0', 0 /* Regular */, all, monospace);
        var digit1 = this.createRequest('1', 0 /* Regular */, all, monospace);
        var digit2 = this.createRequest('2', 0 /* Regular */, all, monospace);
        var digit3 = this.createRequest('3', 0 /* Regular */, all, monospace);
        var digit4 = this.createRequest('4', 0 /* Regular */, all, monospace);
        var digit5 = this.createRequest('5', 0 /* Regular */, all, monospace);
        var digit6 = this.createRequest('6', 0 /* Regular */, all, monospace);
        var digit7 = this.createRequest('7', 0 /* Regular */, all, monospace);
        var digit8 = this.createRequest('8', 0 /* Regular */, all, monospace);
        var digit9 = this.createRequest('9', 0 /* Regular */, all, monospace);
        // monospace test: used for whitespace rendering
        this.createRequest('→', 0 /* Regular */, all, monospace);
        this.createRequest('·', 0 /* Regular */, all, monospace);
        // monospace test: some characters
        this.createRequest('|', 0 /* Regular */, all, monospace);
        this.createRequest('/', 0 /* Regular */, all, monospace);
        this.createRequest('-', 0 /* Regular */, all, monospace);
        this.createRequest('_', 0 /* Regular */, all, monospace);
        this.createRequest('i', 0 /* Regular */, all, monospace);
        this.createRequest('l', 0 /* Regular */, all, monospace);
        this.createRequest('m', 0 /* Regular */, all, monospace);
        // monospace italic test
        this.createRequest('|', 1 /* Italic */, all, monospace);
        this.createRequest('_', 1 /* Italic */, all, monospace);
        this.createRequest('i', 1 /* Italic */, all, monospace);
        this.createRequest('l', 1 /* Italic */, all, monospace);
        this.createRequest('m', 1 /* Italic */, all, monospace);
        this.createRequest('n', 1 /* Italic */, all, monospace);
        // monospace bold test
        this.createRequest('|', 2 /* Bold */, all, monospace);
        this.createRequest('_', 2 /* Bold */, all, monospace);
        this.createRequest('i', 2 /* Bold */, all, monospace);
        this.createRequest('l', 2 /* Bold */, all, monospace);
        this.createRequest('m', 2 /* Bold */, all, monospace);
        this.createRequest('n', 2 /* Bold */, all, monospace);
        readCharWidths(bareFontInfo, all);
        var maxDigitWidth = Math.max(digit0.width, digit1.width, digit2.width, digit3.width, digit4.width, digit5.width, digit6.width, digit7.width, digit8.width, digit9.width);
        var isMonospace = true;
        var referenceWidth = monospace[0].width;
        for (var i = 1, len = monospace.length; i < len; i++) {
            var diff = referenceWidth - monospace[i].width;
            if (diff < -0.001 || diff > 0.001) {
                isMonospace = false;
                break;
            }
        }
        // let's trust the zoom level only 2s after it was changed.
        var canTrustBrowserZoomLevel = (getTimeSinceLastZoomLevelChanged() > 2000);
        return new FontInfo({
            zoomLevel: getZoomLevel(),
            fontFamily: bareFontInfo.fontFamily,
            fontWeight: bareFontInfo.fontWeight,
            fontSize: bareFontInfo.fontSize,
            lineHeight: bareFontInfo.lineHeight,
            letterSpacing: bareFontInfo.letterSpacing,
            isMonospace: isMonospace,
            typicalHalfwidthCharacterWidth: typicalHalfwidthCharacter.width,
            typicalFullwidthCharacterWidth: typicalFullwidthCharacter.width,
            spaceWidth: space.width,
            maxDigitWidth: maxDigitWidth
        }, canTrustBrowserZoomLevel);
    };
    CSSBasedConfiguration.INSTANCE = new CSSBasedConfiguration();
    return CSSBasedConfiguration;
}(Disposable));
var Configuration$1 = /** @class */ (function (_super) {
    __extends$l(Configuration, _super);
    function Configuration(options, referenceDomElement) {
        if (referenceDomElement === void 0) { referenceDomElement = null; }
        var _this = _super.call(this, options) || this;
        _this._elementSizeObserver = _this._register(new ElementSizeObserver(referenceDomElement, function () { return _this._onReferenceDomElementSizeChanged(); }));
        _this._register(CSSBasedConfiguration.INSTANCE.onDidChange(function () { return _this._onCSSBasedConfigurationChanged(); }));
        if (_this._validatedOptions.automaticLayout) {
            _this._elementSizeObserver.startObserving();
        }
        _this._register(onDidChangeZoomLevel(function (_) { return _this._recomputeOptions(); }));
        _this._register(onDidChangeAccessibilitySupport(function () { return _this._recomputeOptions(); }));
        _this._recomputeOptions();
        return _this;
    }
    Configuration._massageFontFamily = function (fontFamily) {
        if (/[,"']/.test(fontFamily)) {
            // Looks like the font family might be already escaped
            return fontFamily;
        }
        if (/[+ ]/.test(fontFamily)) {
            // Wrap a font family using + or <space> with quotes
            return "\"" + fontFamily + "\"";
        }
        return fontFamily;
    };
    Configuration.applyFontInfoSlow = function (domNode, fontInfo) {
        domNode.style.fontFamily = Configuration._massageFontFamily(fontInfo.fontFamily);
        domNode.style.fontWeight = fontInfo.fontWeight;
        domNode.style.fontSize = fontInfo.fontSize + 'px';
        domNode.style.lineHeight = fontInfo.lineHeight + 'px';
        domNode.style.letterSpacing = fontInfo.letterSpacing + 'px';
    };
    Configuration.applyFontInfo = function (domNode, fontInfo) {
        domNode.setFontFamily(Configuration._massageFontFamily(fontInfo.fontFamily));
        domNode.setFontWeight(fontInfo.fontWeight);
        domNode.setFontSize(fontInfo.fontSize);
        domNode.setLineHeight(fontInfo.lineHeight);
        domNode.setLetterSpacing(fontInfo.letterSpacing);
    };
    Configuration.prototype._onReferenceDomElementSizeChanged = function () {
        this._recomputeOptions();
    };
    Configuration.prototype._onCSSBasedConfigurationChanged = function () {
        this._recomputeOptions();
    };
    Configuration.prototype.observeReferenceElement = function (dimension) {
        this._elementSizeObserver.observe(dimension);
    };
    Configuration.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
    };
    Configuration.prototype._getExtraEditorClassName = function () {
        var extra = '';
        if (isIE) {
            extra += 'ie ';
        }
        else if (isFirefox) {
            extra += 'ff ';
        }
        else if (isEdge) {
            extra += 'edge ';
        }
        else if (isSafari) {
            extra += 'safari ';
        }
        if (isMacintosh) {
            extra += 'mac ';
        }
        return extra;
    };
    Configuration.prototype._getEnvConfiguration = function () {
        return {
            extraEditorClassName: this._getExtraEditorClassName(),
            outerWidth: this._elementSizeObserver.getWidth(),
            outerHeight: this._elementSizeObserver.getHeight(),
            emptySelectionClipboard: isWebKit || isFirefox,
            pixelRatio: getPixelRatio(),
            zoomLevel: getZoomLevel(),
            accessibilitySupport: getAccessibilitySupport()
        };
    };
    Configuration.prototype.readConfiguration = function (bareFontInfo) {
        return CSSBasedConfiguration.INSTANCE.readConfiguration(bareFontInfo);
    };
    return Configuration;
}(CommonEditorConfiguration));

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var FastDomNode = /** @class */ (function () {
    function FastDomNode(domNode) {
        this.domNode = domNode;
        this._maxWidth = -1;
        this._width = -1;
        this._height = -1;
        this._top = -1;
        this._left = -1;
        this._bottom = -1;
        this._right = -1;
        this._fontFamily = '';
        this._fontWeight = '';
        this._fontSize = -1;
        this._lineHeight = -1;
        this._letterSpacing = -100;
        this._className = '';
        this._display = '';
        this._position = '';
        this._visibility = '';
        this._layerHint = false;
    }
    FastDomNode.prototype.setMaxWidth = function (maxWidth) {
        if (this._maxWidth === maxWidth) {
            return;
        }
        this._maxWidth = maxWidth;
        this.domNode.style.maxWidth = this._maxWidth + 'px';
    };
    FastDomNode.prototype.setWidth = function (width) {
        if (this._width === width) {
            return;
        }
        this._width = width;
        this.domNode.style.width = this._width + 'px';
    };
    FastDomNode.prototype.setHeight = function (height) {
        if (this._height === height) {
            return;
        }
        this._height = height;
        this.domNode.style.height = this._height + 'px';
    };
    FastDomNode.prototype.setTop = function (top) {
        if (this._top === top) {
            return;
        }
        this._top = top;
        this.domNode.style.top = this._top + 'px';
    };
    FastDomNode.prototype.unsetTop = function () {
        if (this._top === -1) {
            return;
        }
        this._top = -1;
        this.domNode.style.top = '';
    };
    FastDomNode.prototype.setLeft = function (left) {
        if (this._left === left) {
            return;
        }
        this._left = left;
        this.domNode.style.left = this._left + 'px';
    };
    FastDomNode.prototype.setBottom = function (bottom) {
        if (this._bottom === bottom) {
            return;
        }
        this._bottom = bottom;
        this.domNode.style.bottom = this._bottom + 'px';
    };
    FastDomNode.prototype.setRight = function (right) {
        if (this._right === right) {
            return;
        }
        this._right = right;
        this.domNode.style.right = this._right + 'px';
    };
    FastDomNode.prototype.setFontFamily = function (fontFamily) {
        if (this._fontFamily === fontFamily) {
            return;
        }
        this._fontFamily = fontFamily;
        this.domNode.style.fontFamily = this._fontFamily;
    };
    FastDomNode.prototype.setFontWeight = function (fontWeight) {
        if (this._fontWeight === fontWeight) {
            return;
        }
        this._fontWeight = fontWeight;
        this.domNode.style.fontWeight = this._fontWeight;
    };
    FastDomNode.prototype.setFontSize = function (fontSize) {
        if (this._fontSize === fontSize) {
            return;
        }
        this._fontSize = fontSize;
        this.domNode.style.fontSize = this._fontSize + 'px';
    };
    FastDomNode.prototype.setLineHeight = function (lineHeight) {
        if (this._lineHeight === lineHeight) {
            return;
        }
        this._lineHeight = lineHeight;
        this.domNode.style.lineHeight = this._lineHeight + 'px';
    };
    FastDomNode.prototype.setLetterSpacing = function (letterSpacing) {
        if (this._letterSpacing === letterSpacing) {
            return;
        }
        this._letterSpacing = letterSpacing;
        this.domNode.style.letterSpacing = this._letterSpacing + 'px';
    };
    FastDomNode.prototype.setClassName = function (className) {
        if (this._className === className) {
            return;
        }
        this._className = className;
        this.domNode.className = this._className;
    };
    FastDomNode.prototype.toggleClassName = function (className, shouldHaveIt) {
        toggleClass(this.domNode, className, shouldHaveIt);
        this._className = this.domNode.className;
    };
    FastDomNode.prototype.setDisplay = function (display) {
        if (this._display === display) {
            return;
        }
        this._display = display;
        this.domNode.style.display = this._display;
    };
    FastDomNode.prototype.setPosition = function (position$$1) {
        if (this._position === position$$1) {
            return;
        }
        this._position = position$$1;
        this.domNode.style.position = this._position;
    };
    FastDomNode.prototype.setVisibility = function (visibility) {
        if (this._visibility === visibility) {
            return;
        }
        this._visibility = visibility;
        this.domNode.style.visibility = this._visibility;
    };
    FastDomNode.prototype.setLayerHinting = function (layerHint) {
        if (this._layerHint === layerHint) {
            return;
        }
        this._layerHint = layerHint;
        this.domNode.style.willChange = this._layerHint ? 'transform' : 'auto';
    };
    FastDomNode.prototype.setAttribute = function (name, value) {
        this.domNode.setAttribute(name, value);
    };
    FastDomNode.prototype.removeAttribute = function (name) {
        this.domNode.removeAttribute(name);
    };
    FastDomNode.prototype.appendChild = function (child) {
        this.domNode.appendChild(child.domNode);
    };
    FastDomNode.prototype.removeChild = function (child) {
        this.domNode.removeChild(child.domNode);
    };
    return FastDomNode;
}());
function createFastDomNode(domNode) {
    return new FastDomNode(domNode);
}

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$m = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var ViewEventHandler = /** @class */ (function (_super) {
    __extends$m(ViewEventHandler, _super);
    function ViewEventHandler() {
        var _this = _super.call(this) || this;
        _this._shouldRender = true;
        return _this;
    }
    ViewEventHandler.prototype.shouldRender = function () {
        return this._shouldRender;
    };
    ViewEventHandler.prototype.forceShouldRender = function () {
        this._shouldRender = true;
    };
    ViewEventHandler.prototype.setShouldRender = function () {
        this._shouldRender = true;
    };
    ViewEventHandler.prototype.onDidRender = function () {
        this._shouldRender = false;
    };
    // --- begin event handlers
    ViewEventHandler.prototype.onConfigurationChanged = function (e) {
        return false;
    };
    ViewEventHandler.prototype.onCursorStateChanged = function (e) {
        return false;
    };
    ViewEventHandler.prototype.onDecorationsChanged = function (e) {
        return false;
    };
    ViewEventHandler.prototype.onFlushed = function (e) {
        return false;
    };
    ViewEventHandler.prototype.onFocusChanged = function (e) {
        return false;
    };
    ViewEventHandler.prototype.onLanguageConfigurationChanged = function (e) {
        return false;
    };
    ViewEventHandler.prototype.onLineMappingChanged = function (e) {
        return false;
    };
    ViewEventHandler.prototype.onLinesChanged = function (e) {
        return false;
    };
    ViewEventHandler.prototype.onLinesDeleted = function (e) {
        return false;
    };
    ViewEventHandler.prototype.onLinesInserted = function (e) {
        return false;
    };
    ViewEventHandler.prototype.onRevealRangeRequest = function (e) {
        return false;
    };
    ViewEventHandler.prototype.onScrollChanged = function (e) {
        return false;
    };
    ViewEventHandler.prototype.onTokensChanged = function (e) {
        return false;
    };
    ViewEventHandler.prototype.onTokensColorsChanged = function (e) {
        return false;
    };
    ViewEventHandler.prototype.onZonesChanged = function (e) {
        return false;
    };
    ViewEventHandler.prototype.onThemeChanged = function (e) {
        return false;
    };
    // --- end event handlers
    ViewEventHandler.prototype.handleEvents = function (events) {
        var shouldRender = false;
        for (var i = 0, len = events.length; i < len; i++) {
            var e = events[i];
            switch (e.type) {
                case 1 /* ViewConfigurationChanged */:
                    if (this.onConfigurationChanged(e)) {
                        shouldRender = true;
                    }
                    break;
                case 2 /* ViewCursorStateChanged */:
                    if (this.onCursorStateChanged(e)) {
                        shouldRender = true;
                    }
                    break;
                case 3 /* ViewDecorationsChanged */:
                    if (this.onDecorationsChanged(e)) {
                        shouldRender = true;
                    }
                    break;
                case 4 /* ViewFlushed */:
                    if (this.onFlushed(e)) {
                        shouldRender = true;
                    }
                    break;
                case 5 /* ViewFocusChanged */:
                    if (this.onFocusChanged(e)) {
                        shouldRender = true;
                    }
                    break;
                case 16 /* ViewLanguageConfigurationChanged */:
                    if (this.onLanguageConfigurationChanged(e)) {
                        shouldRender = true;
                    }
                    break;
                case 6 /* ViewLineMappingChanged */:
                    if (this.onLineMappingChanged(e)) {
                        shouldRender = true;
                    }
                    break;
                case 7 /* ViewLinesChanged */:
                    if (this.onLinesChanged(e)) {
                        shouldRender = true;
                    }
                    break;
                case 8 /* ViewLinesDeleted */:
                    if (this.onLinesDeleted(e)) {
                        shouldRender = true;
                    }
                    break;
                case 9 /* ViewLinesInserted */:
                    if (this.onLinesInserted(e)) {
                        shouldRender = true;
                    }
                    break;
                case 10 /* ViewRevealRangeRequest */:
                    if (this.onRevealRangeRequest(e)) {
                        shouldRender = true;
                    }
                    break;
                case 11 /* ViewScrollChanged */:
                    if (this.onScrollChanged(e)) {
                        shouldRender = true;
                    }
                    break;
                case 12 /* ViewTokensChanged */:
                    if (this.onTokensChanged(e)) {
                        shouldRender = true;
                    }
                    break;
                case 13 /* ViewTokensColorsChanged */:
                    if (this.onTokensColorsChanged(e)) {
                        shouldRender = true;
                    }
                    break;
                case 14 /* ViewZonesChanged */:
                    if (this.onZonesChanged(e)) {
                        shouldRender = true;
                    }
                    break;
                case 15 /* ViewThemeChanged */:
                    if (this.onThemeChanged(e)) {
                        shouldRender = true;
                    }
                    break;
                default:
                    console.info('View received unknown event: ');
                    console.info(e);
            }
        }
        if (shouldRender) {
            this._shouldRender = true;
        }
    };
    return ViewEventHandler;
}(Disposable));

const css$3 = "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n.monaco-editor .inputarea {\n\tmin-width: 0;\n\tmin-height: 0;\n\tmargin: 0;\n\tpadding: 0;\n\tposition: absolute;\n\toutline: none !important;\n\tresize: none;\n\tborder: none;\n\toverflow: hidden;\n\tcolor: transparent;\n\tbackground-color: transparent;\n}\n/*.monaco-editor .inputarea {\n\tposition: fixed !important;\n\twidth: 800px !important;\n\theight: 500px !important;\n\ttop: initial !important;\n\tleft: initial !important;\n\tbottom: 0 !important;\n\tright: 0 !important;\n\tcolor: black !important;\n\tbackground: white !important;\n\tline-height: 15px !important;\n\tfont-size: 14px !important;\n}*/\n.monaco-editor .inputarea.ime-input {\n\tz-index: 10;\n}\n";
  const element$3 = ((css, src) => {
if (typeof document !== 'object')
console.info(`Skipped loading "${src}"`);
try {
const id = src
  .replace(/\.css.*$/, '')
  .replace(/[\\:]/g, '/')
  .replace(/[^\w\/]+/g, '');
return (
  document.querySelector(`style[id="${id}"]`) ||
  document.head.appendChild(
    Object.assign(document.createElement('style'), {
      id,
      textContent: `${css}\n\n /* sourceURL=${src} */`,
    }),
  )
);
} catch (exception) {
console.warn(`Failed load "${src}"`, exception);
}
})(css$3, "…monaco-editor/esm/vs/editor/browser/controller/textAreaHandler.css");
  //@ sourceURL=/Users/daflair/Projects/packages/monaco-es/node_modules/monaco-editor/esm/vs/editor/browser/controller/textAreaHandler.css

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var TextAreaState = /** @class */ (function () {
    function TextAreaState(value, selectionStart, selectionEnd, selectionStartPosition, selectionEndPosition) {
        this.value = value;
        this.selectionStart = selectionStart;
        this.selectionEnd = selectionEnd;
        this.selectionStartPosition = selectionStartPosition;
        this.selectionEndPosition = selectionEndPosition;
    }
    TextAreaState.prototype.toString = function () {
        return '[ <' + this.value + '>, selectionStart: ' + this.selectionStart + ', selectionEnd: ' + this.selectionEnd + ']';
    };
    TextAreaState.readFromTextArea = function (textArea) {
        return new TextAreaState(textArea.getValue(), textArea.getSelectionStart(), textArea.getSelectionEnd(), null, null);
    };
    TextAreaState.prototype.collapseSelection = function () {
        return new TextAreaState(this.value, this.value.length, this.value.length, null, null);
    };
    TextAreaState.prototype.writeToTextArea = function (reason, textArea, select) {
        // console.log(Date.now() + ': writeToTextArea ' + reason + ': ' + this.toString());
        textArea.setValue(reason, this.value);
        if (select) {
            textArea.setSelectionRange(reason, this.selectionStart, this.selectionEnd);
        }
    };
    TextAreaState.prototype.deduceEditorPosition = function (offset) {
        if (offset <= this.selectionStart) {
            var str = this.value.substring(offset, this.selectionStart);
            return this._finishDeduceEditorPosition(this.selectionStartPosition, str, -1);
        }
        if (offset >= this.selectionEnd) {
            var str = this.value.substring(this.selectionEnd, offset);
            return this._finishDeduceEditorPosition(this.selectionEndPosition, str, 1);
        }
        var str1 = this.value.substring(this.selectionStart, offset);
        if (str1.indexOf(String.fromCharCode(8230)) === -1) {
            return this._finishDeduceEditorPosition(this.selectionStartPosition, str1, 1);
        }
        var str2 = this.value.substring(offset, this.selectionEnd);
        return this._finishDeduceEditorPosition(this.selectionEndPosition, str2, -1);
    };
    TextAreaState.prototype._finishDeduceEditorPosition = function (anchor, deltaText, signum) {
        var lineFeedCnt = 0;
        var lastLineFeedIndex = -1;
        while ((lastLineFeedIndex = deltaText.indexOf('\n', lastLineFeedIndex + 1)) !== -1) {
            lineFeedCnt++;
        }
        return [anchor, signum * deltaText.length, lineFeedCnt];
    };
    TextAreaState.selectedText = function (text) {
        return new TextAreaState(text, 0, text.length, null, null);
    };
    TextAreaState.deduceInput = function (previousState, currentState, couldBeEmojiInput, couldBeTypingAtOffset0) {
        if (!previousState) {
            // This is the EMPTY state
            return {
                text: '',
                replaceCharCnt: 0
            };
        }
        // console.log('------------------------deduceInput');
        // console.log('PREVIOUS STATE: ' + previousState.toString());
        // console.log('CURRENT STATE: ' + currentState.toString());
        var previousValue = previousState.value;
        var previousSelectionStart = previousState.selectionStart;
        var previousSelectionEnd = previousState.selectionEnd;
        var currentValue = currentState.value;
        var currentSelectionStart = currentState.selectionStart;
        var currentSelectionEnd = currentState.selectionEnd;
        if (couldBeTypingAtOffset0 && previousValue.length > 0 && previousSelectionStart === previousSelectionEnd && currentSelectionStart === currentSelectionEnd) {
            // See https://github.com/Microsoft/vscode/issues/42251
            // where typing always happens at offset 0 in the textarea
            // when using a custom title area in OSX and moving the window
            if (endsWith(currentValue, previousValue)) {
                // Looks like something was typed at offset 0
                // ==> pretend we placed the cursor at offset 0 to begin with...
                previousSelectionStart = 0;
                previousSelectionEnd = 0;
            }
        }
        // Strip the previous suffix from the value (without interfering with the current selection)
        var previousSuffix = previousValue.substring(previousSelectionEnd);
        var currentSuffix = currentValue.substring(currentSelectionEnd);
        var suffixLength = commonSuffixLength(previousSuffix, currentSuffix);
        currentValue = currentValue.substring(0, currentValue.length - suffixLength);
        previousValue = previousValue.substring(0, previousValue.length - suffixLength);
        var previousPrefix = previousValue.substring(0, previousSelectionStart);
        var currentPrefix = currentValue.substring(0, currentSelectionStart);
        var prefixLength = commonPrefixLength(previousPrefix, currentPrefix);
        currentValue = currentValue.substring(prefixLength);
        previousValue = previousValue.substring(prefixLength);
        currentSelectionStart -= prefixLength;
        previousSelectionStart -= prefixLength;
        currentSelectionEnd -= prefixLength;
        previousSelectionEnd -= prefixLength;
        // console.log('AFTER DIFFING PREVIOUS STATE: <' + previousValue + '>, selectionStart: ' + previousSelectionStart + ', selectionEnd: ' + previousSelectionEnd);
        // console.log('AFTER DIFFING CURRENT STATE: <' + currentValue + '>, selectionStart: ' + currentSelectionStart + ', selectionEnd: ' + currentSelectionEnd);
        if (couldBeEmojiInput && currentSelectionStart === currentSelectionEnd && previousValue.length > 0) {
            // on OSX, emojis from the emoji picker are inserted at random locations
            // the only hints we can use is that the selection is immediately after the inserted emoji
            // and that none of the old text has been deleted
            var potentialEmojiInput = null;
            if (currentSelectionStart === currentValue.length) {
                // emoji potentially inserted "somewhere" after the previous selection => it should appear at the end of `currentValue`
                if (startsWith(currentValue, previousValue)) {
                    // only if all of the old text is accounted for
                    potentialEmojiInput = currentValue.substring(previousValue.length);
                }
            }
            else {
                // emoji potentially inserted "somewhere" before the previous selection => it should appear at the start of `currentValue`
                if (endsWith(currentValue, previousValue)) {
                    // only if all of the old text is accounted for
                    potentialEmojiInput = currentValue.substring(0, currentValue.length - previousValue.length);
                }
            }
            if (potentialEmojiInput !== null && potentialEmojiInput.length > 0) {
                // now we check that this is indeed an emoji
                // emojis can grow quite long, so a length check is of no help
                // e.g. 1F3F4 E0067 E0062 E0065 E006E E0067 E007F  ; fully-qualified     # 🏴󠁧󠁢󠁥󠁮󠁧󠁿 England
                // Oftentimes, emojis use Variation Selector-16 (U+FE0F), so that is a good hint
                // http://emojipedia.org/variation-selector-16/
                // > An invisible codepoint which specifies that the preceding character
                // > should be displayed with emoji presentation. Only required if the
                // > preceding character defaults to text presentation.
                if (/\uFE0F/.test(potentialEmojiInput) || containsEmoji(potentialEmojiInput)) {
                    return {
                        text: potentialEmojiInput,
                        replaceCharCnt: 0
                    };
                }
            }
        }
        if (currentSelectionStart === currentSelectionEnd) {
            // composition accept case (noticed in FF + Japanese)
            // [blahblah] => blahblah|
            if (previousValue === currentValue
                && previousSelectionStart === 0
                && previousSelectionEnd === previousValue.length
                && currentSelectionStart === currentValue.length
                && currentValue.indexOf('\n') === -1) {
                if (containsFullWidthCharacter(currentValue)) {
                    return {
                        text: '',
                        replaceCharCnt: 0
                    };
                }
            }
            // no current selection
            var replacePreviousCharacters_1 = (previousPrefix.length - prefixLength);
            // console.log('REMOVE PREVIOUS: ' + (previousPrefix.length - prefixLength) + ' chars');
            return {
                text: currentValue,
                replaceCharCnt: replacePreviousCharacters_1
            };
        }
        // there is a current selection => composition case
        var replacePreviousCharacters = previousSelectionEnd - previousSelectionStart;
        return {
            text: currentValue,
            replaceCharCnt: replacePreviousCharacters
        };
    };
    TextAreaState.EMPTY = new TextAreaState('', 0, 0, null, null);
    return TextAreaState;
}());
var PagedScreenReaderStrategy = /** @class */ (function () {
    function PagedScreenReaderStrategy() {
    }
    PagedScreenReaderStrategy._getPageOfLine = function (lineNumber) {
        return Math.floor((lineNumber - 1) / PagedScreenReaderStrategy._LINES_PER_PAGE);
    };
    PagedScreenReaderStrategy._getRangeForPage = function (page) {
        var offset = page * PagedScreenReaderStrategy._LINES_PER_PAGE;
        var startLineNumber = offset + 1;
        var endLineNumber = offset + PagedScreenReaderStrategy._LINES_PER_PAGE;
        return new Range(startLineNumber, 1, endLineNumber + 1, 1);
    };
    PagedScreenReaderStrategy.fromEditorSelection = function (previousState, model, selection, trimLongText) {
        var selectionStartPage = PagedScreenReaderStrategy._getPageOfLine(selection.startLineNumber);
        var selectionStartPageRange = PagedScreenReaderStrategy._getRangeForPage(selectionStartPage);
        var selectionEndPage = PagedScreenReaderStrategy._getPageOfLine(selection.endLineNumber);
        var selectionEndPageRange = PagedScreenReaderStrategy._getRangeForPage(selectionEndPage);
        var pretextRange = selectionStartPageRange.intersectRanges(new Range(1, 1, selection.startLineNumber, selection.startColumn));
        var pretext = model.getValueInRange(pretextRange, EndOfLinePreference.LF);
        var lastLine = model.getLineCount();
        var lastLineMaxColumn = model.getLineMaxColumn(lastLine);
        var posttextRange = selectionEndPageRange.intersectRanges(new Range(selection.endLineNumber, selection.endColumn, lastLine, lastLineMaxColumn));
        var posttext = model.getValueInRange(posttextRange, EndOfLinePreference.LF);
        var text = null;
        if (selectionStartPage === selectionEndPage || selectionStartPage + 1 === selectionEndPage) {
            // take full selection
            text = model.getValueInRange(selection, EndOfLinePreference.LF);
        }
        else {
            var selectionRange1 = selectionStartPageRange.intersectRanges(selection);
            var selectionRange2 = selectionEndPageRange.intersectRanges(selection);
            text = (model.getValueInRange(selectionRange1, EndOfLinePreference.LF)
                + String.fromCharCode(8230)
                + model.getValueInRange(selectionRange2, EndOfLinePreference.LF));
        }
        // Chromium handles very poorly text even of a few thousand chars
        // Cut text to avoid stalling the entire UI
        if (trimLongText) {
            var LIMIT_CHARS = 500;
            if (pretext.length > LIMIT_CHARS) {
                pretext = pretext.substring(pretext.length - LIMIT_CHARS, pretext.length);
            }
            if (posttext.length > LIMIT_CHARS) {
                posttext = posttext.substring(0, LIMIT_CHARS);
            }
            if (text.length > 2 * LIMIT_CHARS) {
                text = text.substring(0, LIMIT_CHARS) + String.fromCharCode(8230) + text.substring(text.length - LIMIT_CHARS, text.length);
            }
        }
        return new TextAreaState(pretext + text + posttext, pretext.length, pretext.length + text.length, new Position(selection.startLineNumber, selection.startColumn), new Position(selection.endLineNumber, selection.endColumn));
    };
    PagedScreenReaderStrategy._LINES_PER_PAGE = 10;
    return PagedScreenReaderStrategy;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$n = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var CopyOptions = {
    forceCopyWithSyntaxHighlighting: false
};
/**
 * Writes screen reader content to the textarea and is able to analyze its input events to generate:
 *  - onCut
 *  - onPaste
 *  - onType
 *
 * Composition events are generated for presentation purposes (composition input is reflected in onType).
 */
var TextAreaInput = /** @class */ (function (_super) {
    __extends$n(TextAreaInput, _super);
    function TextAreaInput(host, textArea) {
        var _this = _super.call(this) || this;
        _this._onFocus = _this._register(new Emitter());
        _this.onFocus = _this._onFocus.event;
        _this._onBlur = _this._register(new Emitter());
        _this.onBlur = _this._onBlur.event;
        _this._onKeyDown = _this._register(new Emitter());
        _this.onKeyDown = _this._onKeyDown.event;
        _this._onKeyUp = _this._register(new Emitter());
        _this.onKeyUp = _this._onKeyUp.event;
        _this._onCut = _this._register(new Emitter());
        _this.onCut = _this._onCut.event;
        _this._onPaste = _this._register(new Emitter());
        _this.onPaste = _this._onPaste.event;
        _this._onType = _this._register(new Emitter());
        _this.onType = _this._onType.event;
        _this._onCompositionStart = _this._register(new Emitter());
        _this.onCompositionStart = _this._onCompositionStart.event;
        _this._onCompositionUpdate = _this._register(new Emitter());
        _this.onCompositionUpdate = _this._onCompositionUpdate.event;
        _this._onCompositionEnd = _this._register(new Emitter());
        _this.onCompositionEnd = _this._onCompositionEnd.event;
        _this._onSelectionChangeRequest = _this._register(new Emitter());
        _this.onSelectionChangeRequest = _this._onSelectionChangeRequest.event;
        _this._host = host;
        _this._textArea = _this._register(new TextAreaWrapper(textArea));
        _this._lastTextAreaEvent = 0 /* none */;
        _this._asyncTriggerCut = _this._register(new RunOnceScheduler(function () { return _this._onCut.fire(); }, 0));
        _this._textAreaState = TextAreaState.EMPTY;
        _this.writeScreenReaderContent('ctor');
        _this._hasFocus = false;
        _this._isDoingComposition = false;
        _this._nextCommand = 0 /* Type */;
        _this._register(addStandardDisposableListener(textArea.domNode, 'keydown', function (e) {
            if (_this._isDoingComposition &&
                (e.keyCode === 109 /* KEY_IN_COMPOSITION */ || e.keyCode === 1 /* Backspace */)) {
                // Stop propagation for keyDown events if the IME is processing key input
                e.stopPropagation();
            }
            if (e.equals(9 /* Escape */)) {
                // Prevent default always for `Esc`, otherwise it will generate a keypress
                // See https://msdn.microsoft.com/en-us/library/ie/ms536939(v=vs.85).aspx
                e.preventDefault();
            }
            _this._onKeyDown.fire(e);
        }));
        _this._register(addStandardDisposableListener(textArea.domNode, 'keyup', function (e) {
            _this._onKeyUp.fire(e);
        }));
        _this._register(addDisposableListener(textArea.domNode, 'compositionstart', function (e) {
            _this._lastTextAreaEvent = 1 /* compositionstart */;
            if (_this._isDoingComposition) {
                return;
            }
            _this._isDoingComposition = true;
            // In IE we cannot set .value when handling 'compositionstart' because the entire composition will get canceled.
            if (!isEdgeOrIE) {
                _this._setAndWriteTextAreaState('compositionstart', TextAreaState.EMPTY);
            }
            _this._onCompositionStart.fire();
        }));
        /**
         * Deduce the typed input from a text area's value and the last observed state.
         */
        var deduceInputFromTextAreaValue = function (couldBeEmojiInput, couldBeTypingAtOffset0) {
            var oldState = _this._textAreaState;
            var newState = TextAreaState.readFromTextArea(_this._textArea);
            return [newState, TextAreaState.deduceInput(oldState, newState, couldBeEmojiInput, couldBeTypingAtOffset0)];
        };
        /**
         * Deduce the composition input from a string.
         */
        var deduceComposition = function (text) {
            var oldState = _this._textAreaState;
            var newState = TextAreaState.selectedText(text);
            var typeInput = {
                text: newState.value,
                replaceCharCnt: oldState.selectionEnd - oldState.selectionStart
            };
            return [newState, typeInput];
        };
        var compositionDataInValid = function (locale) {
            // https://github.com/Microsoft/monaco-editor/issues/339
            // Multi-part Japanese compositions reset cursor in Edge/IE, Chinese and Korean IME don't have this issue.
            // The reason that we can't use this path for all CJK IME is IE and Edge behave differently when handling Korean IME,
            // which breaks this path of code.
            if (isEdgeOrIE && locale === 'ja') {
                return true;
            }
            // https://github.com/Microsoft/monaco-editor/issues/545
            // On IE11, we can't trust composition data when typing Chinese as IE11 doesn't emit correct
            // events when users type numbers in IME.
            // Chinese: zh-Hans-CN, zh-Hans-SG, zh-Hant-TW, zh-Hant-HK
            if (isIE && locale.indexOf('zh-Han') === 0) {
                return true;
            }
            return false;
        };
        _this._register(addDisposableListener(textArea.domNode, 'compositionupdate', function (e) {
            _this._lastTextAreaEvent = 2 /* compositionupdate */;
            if (isChromev56) {
                // See https://github.com/Microsoft/monaco-editor/issues/320
                // where compositionupdate .data is broken in Chrome v55 and v56
                // See https://bugs.chromium.org/p/chromium/issues/detail?id=677050#c9
                // The textArea doesn't get the composition update yet, the value of textarea is still obsolete
                // so we can't correct e at this moment.
                return;
            }
            if (compositionDataInValid(e.locale)) {
                var _a = deduceInputFromTextAreaValue(/*couldBeEmojiInput*/ false, /*couldBeTypingAtOffset0*/ false), newState_1 = _a[0], typeInput_1 = _a[1];
                _this._textAreaState = newState_1;
                _this._onType.fire(typeInput_1);
                _this._onCompositionUpdate.fire(e);
                return;
            }
            var _b = deduceComposition(e.data), newState = _b[0], typeInput = _b[1];
            _this._textAreaState = newState;
            _this._onType.fire(typeInput);
            _this._onCompositionUpdate.fire(e);
        }));
        _this._register(addDisposableListener(textArea.domNode, 'compositionend', function (e) {
            _this._lastTextAreaEvent = 3 /* compositionend */;
            if (compositionDataInValid(e.locale)) {
                // https://github.com/Microsoft/monaco-editor/issues/339
                var _a = deduceInputFromTextAreaValue(/*couldBeEmojiInput*/ false, /*couldBeTypingAtOffset0*/ false), newState = _a[0], typeInput = _a[1];
                _this._textAreaState = newState;
                _this._onType.fire(typeInput);
            }
            else {
                var _b = deduceComposition(e.data), newState = _b[0], typeInput = _b[1];
                _this._textAreaState = newState;
                _this._onType.fire(typeInput);
            }
            // Due to isEdgeOrIE (where the textarea was not cleared initially) and isChrome (the textarea is not updated correctly when composition ends)
            // we cannot assume the text at the end consists only of the composited text
            if (isEdgeOrIE || isChrome) {
                _this._textAreaState = TextAreaState.readFromTextArea(_this._textArea);
            }
            if (!_this._isDoingComposition) {
                return;
            }
            _this._isDoingComposition = false;
            _this._onCompositionEnd.fire();
        }));
        _this._register(addDisposableListener(textArea.domNode, 'input', function () {
            // We want to find out if this is the first `input` after a `focus`.
            var previousEventWasFocus = (_this._lastTextAreaEvent === 8 /* focus */);
            _this._lastTextAreaEvent = 4 /* input */;
            // Pretend here we touched the text area, as the `input` event will most likely
            // result in a `selectionchange` event which we want to ignore
            _this._textArea.setIgnoreSelectionChangeTime('received input event');
            if (_this._isDoingComposition) {
                // See https://github.com/Microsoft/monaco-editor/issues/320
                if (isChromev56) {
                    var _a = deduceComposition(_this._textArea.getValue()), newState_2 = _a[0], typeInput_2 = _a[1];
                    _this._textAreaState = newState_2;
                    _this._onType.fire(typeInput_2);
                    var e = {
                        data: typeInput_2.text
                    };
                    _this._onCompositionUpdate.fire(e);
                }
                return;
            }
            var _b = deduceInputFromTextAreaValue(/*couldBeEmojiInput*/ isMacintosh, /*couldBeTypingAtOffset0*/ previousEventWasFocus && isMacintosh), newState = _b[0], typeInput = _b[1];
            if (typeInput.replaceCharCnt === 0 && typeInput.text.length === 1 && isHighSurrogate(typeInput.text.charCodeAt(0))) {
                // Ignore invalid input but keep it around for next time
                return;
            }
            _this._textAreaState = newState;
            // console.log('==> DEDUCED INPUT: ' + JSON.stringify(typeInput));
            if (_this._nextCommand === 0 /* Type */) {
                if (typeInput.text !== '') {
                    _this._onType.fire(typeInput);
                }
            }
            else {
                if (typeInput.text !== '') {
                    _this._onPaste.fire({
                        text: typeInput.text
                    });
                }
                _this._nextCommand = 0 /* Type */;
            }
        }));
        // --- Clipboard operations
        _this._register(addDisposableListener(textArea.domNode, 'cut', function (e) {
            _this._lastTextAreaEvent = 5 /* cut */;
            // Pretend here we touched the text area, as the `cut` event will most likely
            // result in a `selectionchange` event which we want to ignore
            _this._textArea.setIgnoreSelectionChangeTime('received cut event');
            _this._ensureClipboardGetsEditorSelection(e);
            _this._asyncTriggerCut.schedule();
        }));
        _this._register(addDisposableListener(textArea.domNode, 'copy', function (e) {
            _this._lastTextAreaEvent = 6 /* copy */;
            _this._ensureClipboardGetsEditorSelection(e);
        }));
        _this._register(addDisposableListener(textArea.domNode, 'paste', function (e) {
            _this._lastTextAreaEvent = 7 /* paste */;
            // Pretend here we touched the text area, as the `paste` event will most likely
            // result in a `selectionchange` event which we want to ignore
            _this._textArea.setIgnoreSelectionChangeTime('received paste event');
            if (ClipboardEventUtils.canUseTextData(e)) {
                var pastePlainText = ClipboardEventUtils.getTextData(e);
                if (pastePlainText !== '') {
                    _this._onPaste.fire({
                        text: pastePlainText
                    });
                }
            }
            else {
                if (_this._textArea.getSelectionStart() !== _this._textArea.getSelectionEnd()) {
                    // Clean up the textarea, to get a clean paste
                    _this._setAndWriteTextAreaState('paste', TextAreaState.EMPTY);
                }
                _this._nextCommand = 1 /* Paste */;
            }
        }));
        _this._register(addDisposableListener(textArea.domNode, 'focus', function () {
            _this._lastTextAreaEvent = 8 /* focus */;
            _this._setHasFocus(true);
        }));
        _this._register(addDisposableListener(textArea.domNode, 'blur', function () {
            _this._lastTextAreaEvent = 9 /* blur */;
            _this._setHasFocus(false);
        }));
        // See https://github.com/Microsoft/vscode/issues/27216
        // When using a Braille display, it is possible for users to reposition the
        // system caret. This is reflected in Chrome as a `selectionchange` event.
        //
        // The `selectionchange` event appears to be emitted under numerous other circumstances,
        // so it is quite a challenge to distinguish a `selectionchange` coming in from a user
        // using a Braille display from all the other cases.
        //
        // The problems with the `selectionchange` event are:
        //  * the event is emitted when the textarea is focused programmatically -- textarea.focus()
        //  * the event is emitted when the selection is changed in the textarea programatically -- textarea.setSelectionRange(...)
        //  * the event is emitted when the value of the textarea is changed programmatically -- textarea.value = '...'
        //  * the event is emitted when tabbing into the textarea
        //  * the event is emitted asynchronously (sometimes with a delay as high as a few tens of ms)
        //  * the event sometimes comes in bursts for a single logical textarea operation
        // `selectionchange` events often come multiple times for a single logical change
        // so throttle multiple `selectionchange` events that burst in a short period of time.
        var previousSelectionChangeEventTime = 0;
        _this._register(addDisposableListener(document, 'selectionchange', function (e) {
            if (!_this._hasFocus) {
                return;
            }
            if (_this._isDoingComposition) {
                return;
            }
            if (!isChrome || !isWindows) {
                // Support only for Chrome on Windows until testing happens on other browsers + OS configurations
                return;
            }
            var now = Date.now();
            var delta1 = now - previousSelectionChangeEventTime;
            previousSelectionChangeEventTime = now;
            if (delta1 < 5) {
                // received another `selectionchange` event within 5ms of the previous `selectionchange` event
                // => ignore it
                return;
            }
            var delta2 = now - _this._textArea.getIgnoreSelectionChangeTime();
            _this._textArea.resetSelectionChangeTime();
            if (delta2 < 100) {
                // received a `selectionchange` event within 100ms since we touched the textarea
                // => ignore it, since we caused it
                return;
            }
            if (!_this._textAreaState.selectionStartPosition || !_this._textAreaState.selectionEndPosition) {
                // Cannot correlate a position in the textarea with a position in the editor...
                return;
            }
            var newValue = _this._textArea.getValue();
            if (_this._textAreaState.value !== newValue) {
                // Cannot correlate a position in the textarea with a position in the editor...
                return;
            }
            var newSelectionStart = _this._textArea.getSelectionStart();
            var newSelectionEnd = _this._textArea.getSelectionEnd();
            if (_this._textAreaState.selectionStart === newSelectionStart && _this._textAreaState.selectionEnd === newSelectionEnd) {
                // Nothing to do...
                return;
            }
            var _newSelectionStartPosition = _this._textAreaState.deduceEditorPosition(newSelectionStart);
            var newSelectionStartPosition = _this._host.deduceModelPosition(_newSelectionStartPosition[0], _newSelectionStartPosition[1], _newSelectionStartPosition[2]);
            var _newSelectionEndPosition = _this._textAreaState.deduceEditorPosition(newSelectionEnd);
            var newSelectionEndPosition = _this._host.deduceModelPosition(_newSelectionEndPosition[0], _newSelectionEndPosition[1], _newSelectionEndPosition[2]);
            var newSelection = new Selection(newSelectionStartPosition.lineNumber, newSelectionStartPosition.column, newSelectionEndPosition.lineNumber, newSelectionEndPosition.column);
            _this._onSelectionChangeRequest.fire(newSelection);
        }));
        return _this;
    }
    TextAreaInput.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
    };
    TextAreaInput.prototype.focusTextArea = function () {
        // Setting this._hasFocus and writing the screen reader content
        // will result in a focus() and setSelectionRange() in the textarea
        this._setHasFocus(true);
    };
    TextAreaInput.prototype.isFocused = function () {
        return this._hasFocus;
    };
    TextAreaInput.prototype._setHasFocus = function (newHasFocus) {
        if (this._hasFocus === newHasFocus) {
            // no change
            return;
        }
        this._hasFocus = newHasFocus;
        if (this._hasFocus) {
            if (isEdge) {
                // Edge has a bug where setting the selection range while the focus event
                // is dispatching doesn't work. To reproduce, "tab into" the editor.
                this._setAndWriteTextAreaState('focusgain', TextAreaState.EMPTY);
            }
            else {
                this.writeScreenReaderContent('focusgain');
            }
        }
        if (this._hasFocus) {
            this._onFocus.fire();
        }
        else {
            this._onBlur.fire();
        }
    };
    TextAreaInput.prototype._setAndWriteTextAreaState = function (reason, textAreaState) {
        if (!this._hasFocus) {
            textAreaState = textAreaState.collapseSelection();
        }
        textAreaState.writeToTextArea(reason, this._textArea, this._hasFocus);
        this._textAreaState = textAreaState;
    };
    TextAreaInput.prototype.writeScreenReaderContent = function (reason) {
        if (this._isDoingComposition) {
            // Do not write to the text area when doing composition
            return;
        }
        this._setAndWriteTextAreaState(reason, this._host.getScreenReaderContent(this._textAreaState));
    };
    TextAreaInput.prototype._ensureClipboardGetsEditorSelection = function (e) {
        var copyPlainText = this._host.getPlainTextToCopy();
        if (!ClipboardEventUtils.canUseTextData(e)) {
            // Looks like an old browser. The strategy is to place the text
            // we'd like to be copied to the clipboard in the textarea and select it.
            this._setAndWriteTextAreaState('copy or cut', TextAreaState.selectedText(copyPlainText));
            return;
        }
        var copyHTML = null;
        if (hasClipboardSupport() && (copyPlainText.length < 65536 || CopyOptions.forceCopyWithSyntaxHighlighting)) {
            copyHTML = this._host.getHTMLToCopy();
        }
        ClipboardEventUtils.setTextData(e, copyPlainText, copyHTML);
    };
    return TextAreaInput;
}(Disposable));
var ClipboardEventUtils = /** @class */ (function () {
    function ClipboardEventUtils() {
    }
    ClipboardEventUtils.canUseTextData = function (e) {
        if (e.clipboardData) {
            return true;
        }
        if (window.clipboardData) {
            return true;
        }
        return false;
    };
    ClipboardEventUtils.getTextData = function (e) {
        if (e.clipboardData) {
            e.preventDefault();
            return e.clipboardData.getData('text/plain');
        }
        if (window.clipboardData) {
            e.preventDefault();
            return window.clipboardData.getData('Text');
        }
        throw new Error('ClipboardEventUtils.getTextData: Cannot use text data!');
    };
    ClipboardEventUtils.setTextData = function (e, text, richText) {
        if (e.clipboardData) {
            e.clipboardData.setData('text/plain', text);
            if (richText !== null) {
                e.clipboardData.setData('text/html', richText);
            }
            e.preventDefault();
            return;
        }
        if (window.clipboardData) {
            window.clipboardData.setData('Text', text);
            e.preventDefault();
            return;
        }
        throw new Error('ClipboardEventUtils.setTextData: Cannot use text data!');
    };
    return ClipboardEventUtils;
}());
var TextAreaWrapper = /** @class */ (function (_super) {
    __extends$n(TextAreaWrapper, _super);
    function TextAreaWrapper(_textArea) {
        var _this = _super.call(this) || this;
        _this._actual = _textArea;
        _this._ignoreSelectionChangeTime = 0;
        return _this;
    }
    TextAreaWrapper.prototype.setIgnoreSelectionChangeTime = function (reason) {
        this._ignoreSelectionChangeTime = Date.now();
    };
    TextAreaWrapper.prototype.getIgnoreSelectionChangeTime = function () {
        return this._ignoreSelectionChangeTime;
    };
    TextAreaWrapper.prototype.resetSelectionChangeTime = function () {
        this._ignoreSelectionChangeTime = 0;
    };
    TextAreaWrapper.prototype.getValue = function () {
        // console.log('current value: ' + this._textArea.value);
        return this._actual.domNode.value;
    };
    TextAreaWrapper.prototype.setValue = function (reason, value) {
        var textArea = this._actual.domNode;
        if (textArea.value === value) {
            // No change
            return;
        }
        // console.log('reason: ' + reason + ', current value: ' + textArea.value + ' => new value: ' + value);
        this.setIgnoreSelectionChangeTime('setValue');
        textArea.value = value;
    };
    TextAreaWrapper.prototype.getSelectionStart = function () {
        return this._actual.domNode.selectionStart;
    };
    TextAreaWrapper.prototype.getSelectionEnd = function () {
        return this._actual.domNode.selectionEnd;
    };
    TextAreaWrapper.prototype.setSelectionRange = function (reason, selectionStart, selectionEnd) {
        var textArea = this._actual.domNode;
        var currentIsFocused = (document.activeElement === textArea);
        var currentSelectionStart = textArea.selectionStart;
        var currentSelectionEnd = textArea.selectionEnd;
        if (currentIsFocused && currentSelectionStart === selectionStart && currentSelectionEnd === selectionEnd) {
            // No change
            // Firefox iframe bug https://github.com/Microsoft/monaco-editor/issues/643#issuecomment-367871377
            if (isFirefox && window.parent !== window) {
                textArea.focus();
            }
            return;
        }
        // console.log('reason: ' + reason + ', setSelectionRange: ' + selectionStart + ' -> ' + selectionEnd);
        if (currentIsFocused) {
            // No need to focus, only need to change the selection range
            this.setIgnoreSelectionChangeTime('setSelectionRange');
            textArea.setSelectionRange(selectionStart, selectionEnd);
            if (isFirefox && window.parent !== window) {
                textArea.focus();
            }
            return;
        }
        // If the focus is outside the textarea, browsers will try really hard to reveal the textarea.
        // Here, we try to undo the browser's desperate reveal.
        try {
            var scrollState = saveParentsScrollTop(textArea);
            this.setIgnoreSelectionChangeTime('setSelectionRange');
            textArea.focus();
            textArea.setSelectionRange(selectionStart, selectionEnd);
            restoreParentsScrollTop(textArea, scrollState);
        }
        catch (e) {
            // Sometimes IE throws when setting selection (e.g. textarea is off-DOM)
        }
    };
    return TextAreaWrapper;
}(Disposable));

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$o = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var ViewPart = /** @class */ (function (_super) {
    __extends$o(ViewPart, _super);
    function ViewPart(context) {
        var _this = _super.call(this) || this;
        _this._context = context;
        _this._context.addEventHandler(_this);
        return _this;
    }
    ViewPart.prototype.dispose = function () {
        this._context.removeEventHandler(this);
        this._context = null;
        _super.prototype.dispose.call(this);
    };
    return ViewPart;
}(ViewEventHandler));
var PartFingerprints = /** @class */ (function () {
    function PartFingerprints() {
    }
    PartFingerprints.write = function (target, partId) {
        if (target instanceof FastDomNode) {
            target.setAttribute('data-mprt', String(partId));
        }
        else {
            target.setAttribute('data-mprt', String(partId));
        }
    };
    PartFingerprints.read = function (target) {
        var r = target.getAttribute('data-mprt');
        if (r === null) {
            return 0 /* None */;
        }
        return parseInt(r, 10);
    };
    PartFingerprints.collect = function (child, stopAt) {
        var result = [], resultLen = 0;
        while (child && child !== document.body) {
            if (child === stopAt) {
                break;
            }
            if (child.nodeType === child.ELEMENT_NODE) {
                result[resultLen++] = this.read(child);
            }
            child = child.parentElement;
        }
        var r = new Uint8Array(resultLen);
        for (var i = 0; i < resultLen; i++) {
            r[i] = result[resultLen - i - 1];
        }
        return r;
    };
    return PartFingerprints;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$p = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var Margin = /** @class */ (function (_super) {
    __extends$p(Margin, _super);
    function Margin(context) {
        var _this = _super.call(this, context) || this;
        _this._canUseLayerHinting = _this._context.configuration.editor.canUseLayerHinting;
        _this._contentLeft = _this._context.configuration.editor.layoutInfo.contentLeft;
        _this._glyphMarginLeft = _this._context.configuration.editor.layoutInfo.glyphMarginLeft;
        _this._glyphMarginWidth = _this._context.configuration.editor.layoutInfo.glyphMarginWidth;
        _this._domNode = _this._createDomNode();
        return _this;
    }
    Margin.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
    };
    Margin.prototype.getDomNode = function () {
        return this._domNode;
    };
    Margin.prototype._createDomNode = function () {
        var domNode = createFastDomNode(document.createElement('div'));
        domNode.setClassName(Margin.OUTER_CLASS_NAME);
        domNode.setPosition('absolute');
        domNode.setAttribute('role', 'presentation');
        domNode.setAttribute('aria-hidden', 'true');
        this._glyphMarginBackgroundDomNode = createFastDomNode(document.createElement('div'));
        this._glyphMarginBackgroundDomNode.setClassName(Margin.CLASS_NAME);
        domNode.appendChild(this._glyphMarginBackgroundDomNode);
        return domNode;
    };
    // --- begin event handlers
    Margin.prototype.onConfigurationChanged = function (e) {
        if (e.canUseLayerHinting) {
            this._canUseLayerHinting = this._context.configuration.editor.canUseLayerHinting;
        }
        if (e.layoutInfo) {
            this._contentLeft = this._context.configuration.editor.layoutInfo.contentLeft;
            this._glyphMarginLeft = this._context.configuration.editor.layoutInfo.glyphMarginLeft;
            this._glyphMarginWidth = this._context.configuration.editor.layoutInfo.glyphMarginWidth;
        }
        return true;
    };
    Margin.prototype.onScrollChanged = function (e) {
        return _super.prototype.onScrollChanged.call(this, e) || e.scrollTopChanged;
    };
    // --- end event handlers
    Margin.prototype.prepareRender = function (ctx) {
        // Nothing to read
    };
    Margin.prototype.render = function (ctx) {
        this._domNode.setLayerHinting(this._canUseLayerHinting);
        var adjustedScrollTop = ctx.scrollTop - ctx.bigNumbersDelta;
        this._domNode.setTop(-adjustedScrollTop);
        var height = Math.min(ctx.scrollHeight, 1000000);
        this._domNode.setHeight(height);
        this._domNode.setWidth(this._contentLeft);
        this._glyphMarginBackgroundDomNode.setLeft(this._glyphMarginLeft);
        this._glyphMarginBackgroundDomNode.setWidth(this._glyphMarginWidth);
        this._glyphMarginBackgroundDomNode.setHeight(height);
    };
    Margin.CLASS_NAME = 'glyph-margin';
    Margin.OUTER_CLASS_NAME = 'margin';
    return Margin;
}(ViewPart));

const css$4 = "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n.monaco-editor .margin-view-overlays .line-numbers {\n\tposition: absolute;\n\ttext-align: right;\n\tdisplay: inline-block;\n\tvertical-align: middle;\n\tbox-sizing: border-box;\n\tcursor: default;\n\theight: 100%;\n}\n\n.monaco-editor .relative-current-line-number {\n\ttext-align: left;\n\tdisplay: inline-block;\n\twidth: 100%;\n}\n\n.monaco-editor .margin-view-overlays .line-numbers {\n\tcursor: -webkit-image-set(\n\t\turl(\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNSIgaGVpZ2h0PSIyMSIgeD0iMHB4IiB5PSIwcHgiIHZpZXdCb3g9IjAgMCAxNSAyMSIgc3R5bGU9ImVuYWJsZS1iYWNrZ3JvdW5kOm5ldyAwIDAgMTUgMjE7Ij48cG9seWdvbiBzdHlsZT0iZmlsbDojRkZGRkZGO3N0cm9rZTojMDAwMDAwIiBwb2ludHM9IjE0LjUsMS4yIDEuOSwxMy44IDcuMSwxMy44IDQuNSwxOS4xIDcuNywyMC4xIDEwLjMsMTQuOSAxNC41LDE4Ii8+PC9zdmc+\") 1x,\n\t\turl(\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHg9IjBweCIgeT0iMHB4IiB3aWR0aD0iMzAiIGhlaWdodD0iNDIiIHZpZXdCb3g9IjAgMCAzMCA0MiIgc3R5bGU9ImVuYWJsZS1iYWNrZ3JvdW5kOm5ldyAwIDAgMzAgNDI7Ij48cG9seWdvbiBzdHlsZT0iZmlsbDojRkZGRkZGO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoyOyIgcG9pbnRzPSIyOSwyLjQgMy44LDI3LjYgMTQuMywyNy42IDksMzguMSAxNS40LDQwLjIgMjAuNiwyOS43IDI5LDM2Ii8+PC9zdmc+Cg==\") 2x\n\t) 30 0, default;\n}\n\n.monaco-editor.mac .margin-view-overlays .line-numbers {\n\tcursor: -webkit-image-set(\n\t\turl(\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMiIgaGVpZ2h0PSIxOCIgdmlld0JveD0iMCAwIDEyIDE4Ij48c3R5bGU+LnN0MHtmaWxsOiNmZmZ9PC9zdHlsZT48dGl0bGU+ZmxpcHBlZC1jdXJzb3ItbWFjPC90aXRsZT48cGF0aCBkPSJNNC4zIDE2LjVsMS42LTQuNkgxLjFMMTEuNSAxLjJ2MTQuNEw4LjcgMTNsLTEuNiA0LjV6Ii8+PHBhdGggY2xhc3M9InN0MCIgZD0iTTExIDE0LjVsLTIuNS0yLjNMNyAxNi43IDUgMTZsMS42LTQuNWgtNGw4LjUtOU0wIDEyLjVoNS4ybC0xLjUgNC4xTDcuNSAxOCA5IDE0LjJsMi45IDIuM1YwTDAgMTIuNXoiLz48L3N2Zz4=\") 1x,\n\t\turl(\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIzNiIgdmlld0JveD0iMCAwIDI0IDM2LjEiPjxkZWZzPjxzdHlsZT4uYXtmaWxsOiNmZmY7fTwvc3R5bGU+PC9kZWZzPjx0aXRsZT5mbGlwcGVkLWN1cnNvci1tYWMtMng8L3RpdGxlPjxwb2x5Z29uIHBvaW50cz0iOC42IDMzLjEgMTEuOCAyMy45IDIuMiAyMy45IDIzIDIuNSAyMyAzMS4zIDE3LjQgMjYuMSAxNC4yIDM1LjEgOC42IDMzLjEiLz48cGF0aCBjbGFzcz0iYSIgZD0iTTIyLDI5LjFsLTUtNC42LTMuMDYyLDguOTM4LTQuMDYyLTEuNUwxMywyM0g1TDIyLDVNMCwyNUgxMC40bC0zLDguM0wxNSwzNi4xbDMuMTI1LTcuNjYyTDI0LDMzVjBaIi8+PC9zdmc+\") 2x\n\t) 24 3, default;\n}\n\n.monaco-editor .margin-view-overlays .line-numbers.lh-odd {\n\tmargin-top: 1px;\n}\n";
  const element$4 = ((css, src) => {
if (typeof document !== 'object')
console.info(`Skipped loading "${src}"`);
try {
const id = src
  .replace(/\.css.*$/, '')
  .replace(/[\\:]/g, '/')
  .replace(/[^\w\/]+/g, '');
return (
  document.querySelector(`style[id="${id}"]`) ||
  document.head.appendChild(
    Object.assign(document.createElement('style'), {
      id,
      textContent: `${css}\n\n /* sourceURL=${src} */`,
    }),
  )
);
} catch (exception) {
console.warn(`Failed load "${src}"`, exception);
}
})(css$4, "…monaco-editor/esm/vs/editor/browser/viewParts/lineNumbers/lineNumbers.css");
  //@ sourceURL=/Users/daflair/Projects/packages/monaco-es/node_modules/monaco-editor/esm/vs/editor/browser/viewParts/lineNumbers/lineNumbers.css

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// color registry
var Extensions$4 = {
    ColorContribution: 'base.contributions.colors'
};
var ColorRegistry = /** @class */ (function () {
    function ColorRegistry() {
        this.colorSchema = { type: 'object', description: localize('schema.colors', "Colors used in the workbench."), properties: {}, additionalProperties: false };
        this.colorReferenceSchema = { type: 'string', enum: [], enumDescriptions: [] };
        this.colorsById = {};
    }
    ColorRegistry.prototype.registerColor = function (id, defaults, description, needsTransparency, deprecationMessage) {
        if (needsTransparency === void 0) { needsTransparency = false; }
        var colorContribution = { id: id, description: description, defaults: defaults, needsTransparency: needsTransparency };
        this.colorsById[id] = colorContribution;
        var propertySchema = { type: 'string', description: description, format: 'color-hex', default: '#ff0000' };
        if (deprecationMessage) {
            propertySchema.deprecationMessage = deprecationMessage;
        }
        this.colorSchema.properties[id] = propertySchema;
        this.colorReferenceSchema.enum.push(id);
        this.colorReferenceSchema.enumDescriptions.push(description);
        return id;
    };
    ColorRegistry.prototype.getColors = function () {
        var _this = this;
        return Object.keys(this.colorsById).map(function (id) { return _this.colorsById[id]; });
    };
    ColorRegistry.prototype.resolveDefaultColor = function (id, theme) {
        var colorDesc = this.colorsById[id];
        if (colorDesc && colorDesc.defaults) {
            var colorValue = colorDesc.defaults[theme.type];
            return resolveColorValue(colorValue, theme);
        }
        return null;
    };
    ColorRegistry.prototype.getColorSchema = function () {
        return this.colorSchema;
    };
    ColorRegistry.prototype.getColorReferenceSchema = function () {
        return this.colorReferenceSchema;
    };
    ColorRegistry.prototype.toString = function () {
        var _this = this;
        var sorter = function (a, b) {
            var cat1 = a.indexOf('.') === -1 ? 0 : 1;
            var cat2 = b.indexOf('.') === -1 ? 0 : 1;
            if (cat1 !== cat2) {
                return cat1 - cat2;
            }
            return a.localeCompare(b);
        };
        return Object.keys(this.colorsById).sort(sorter).map(function (k) { return "- `" + k + "`: " + _this.colorsById[k].description; }).join('\n');
    };
    return ColorRegistry;
}());
var colorRegistry = new ColorRegistry();
Registry.add(Extensions$4.ColorContribution, colorRegistry);
function registerColor(id, defaults, description, needsTransparency, deprecationMessage) {
    return colorRegistry.registerColor(id, defaults, description, needsTransparency, deprecationMessage);
}
// ----- base colors
var foreground = registerColor('foreground', { dark: '#CCCCCC', light: '#6C6C6C', hc: '#FFFFFF' }, localize('foreground', "Overall foreground color. This color is only used if not overridden by a component."));
var errorForeground = registerColor('errorForeground', { dark: '#F48771', light: '#A1260D', hc: '#F48771' }, localize('errorForeground', "Overall foreground color for error messages. This color is only used if not overridden by a component."));
var descriptionForeground = registerColor('descriptionForeground', { light: transparent(foreground, 0.7), dark: transparent(foreground, 0.7), hc: transparent(foreground, 0.7) }, localize('descriptionForeground', "Foreground color for description text providing additional information, for example for a label."));
var focusBorder = registerColor('focusBorder', { dark: Color.fromHex('#0E639C').transparent(0.6), light: Color.fromHex('#007ACC').transparent(0.4), hc: '#F38518' }, localize('focusBorder', "Overall border color for focused elements. This color is only used if not overridden by a component."));
var contrastBorder = registerColor('contrastBorder', { light: null, dark: null, hc: '#6FC3DF' }, localize('contrastBorder', "An extra border around elements to separate them from others for greater contrast."));
var activeContrastBorder = registerColor('contrastActiveBorder', { light: null, dark: null, hc: focusBorder }, localize('activeContrastBorder', "An extra border around active elements to separate them from others for greater contrast."));
var selectionBackground = registerColor('selection.background', { light: null, dark: null, hc: null }, localize('selectionBackground', "The background color of text selections in the workbench (e.g. for input fields or text areas). Note that this does not apply to selections within the editor."));
// ------ text colors
var textSeparatorForeground = registerColor('textSeparator.foreground', { light: '#0000002e', dark: '#ffffff2e', hc: Color.black }, localize('textSeparatorForeground', "Color for text separators."));
var textLinkForeground = registerColor('textLink.foreground', { light: '#4080D0', dark: '#4080D0', hc: '#4080D0' }, localize('textLinkForeground', "Foreground color for links in text."));
var textLinkActiveForeground = registerColor('textLink.activeForeground', { light: '#4080D0', dark: '#4080D0', hc: '#4080D0' }, localize('textLinkActiveForeground', "Foreground color for active links in text."));
var textPreformatForeground = registerColor('textPreformat.foreground', { light: '#A31515', dark: '#D7BA7D', hc: '#D7BA7D' }, localize('textPreformatForeground', "Foreground color for preformatted text segments."));
var textBlockQuoteBackground = registerColor('textBlockQuote.background', { light: '#7f7f7f1a', dark: '#7f7f7f1a', hc: null }, localize('textBlockQuoteBackground', "Background color for block quotes in text."));
var textBlockQuoteBorder = registerColor('textBlockQuote.border', { light: '#007acc80', dark: '#007acc80', hc: Color.white }, localize('textBlockQuoteBorder', "Border color for block quotes in text."));
var textCodeBlockBackground = registerColor('textCodeBlock.background', { light: '#dcdcdc66', dark: '#0a0a0a66', hc: Color.black }, localize('textCodeBlockBackground', "Background color for code blocks in text."));
// ----- widgets
var widgetShadow = registerColor('widget.shadow', { dark: '#000000', light: '#A8A8A8', hc: null }, localize('widgetShadow', 'Shadow color of widgets such as find/replace inside the editor.'));
var inputBackground = registerColor('input.background', { dark: '#3C3C3C', light: Color.white, hc: Color.black }, localize('inputBoxBackground', "Input box background."));
var inputForeground = registerColor('input.foreground', { dark: foreground, light: foreground, hc: foreground }, localize('inputBoxForeground', "Input box foreground."));
var inputBorder = registerColor('input.border', { dark: null, light: null, hc: contrastBorder }, localize('inputBoxBorder', "Input box border."));
var inputActiveOptionBorder = registerColor('inputOption.activeBorder', { dark: '#007ACC', light: '#007ACC', hc: activeContrastBorder }, localize('inputBoxActiveOptionBorder', "Border color of activated options in input fields."));
var inputPlaceholderForeground = registerColor('input.placeholderForeground', { dark: null, light: null, hc: null }, localize('inputPlaceholderForeground', "Input box foreground color for placeholder text."));
var inputValidationInfoBackground = registerColor('inputValidation.infoBackground', { dark: '#063B49', light: '#D6ECF2', hc: Color.black }, localize('inputValidationInfoBackground', "Input validation background color for information severity."));
var inputValidationInfoBorder = registerColor('inputValidation.infoBorder', { dark: '#007acc', light: '#007acc', hc: contrastBorder }, localize('inputValidationInfoBorder', "Input validation border color for information severity."));
var inputValidationWarningBackground = registerColor('inputValidation.warningBackground', { dark: '#352A05', light: '#F6F5D2', hc: Color.black }, localize('inputValidationWarningBackground', "Input validation background color for warning severity."));
var inputValidationWarningBorder = registerColor('inputValidation.warningBorder', { dark: '#B89500', light: '#B89500', hc: contrastBorder }, localize('inputValidationWarningBorder', "Input validation border color for warning severity."));
var inputValidationErrorBackground = registerColor('inputValidation.errorBackground', { dark: '#5A1D1D', light: '#F2DEDE', hc: Color.black }, localize('inputValidationErrorBackground', "Input validation background color for error severity."));
var inputValidationErrorBorder = registerColor('inputValidation.errorBorder', { dark: '#BE1100', light: '#BE1100', hc: contrastBorder }, localize('inputValidationErrorBorder', "Input validation border color for error severity."));
var selectBackground = registerColor('dropdown.background', { dark: '#3C3C3C', light: Color.white, hc: Color.black }, localize('dropdownBackground', "Dropdown background."));
var selectListBackground = registerColor('dropdown.listBackground', { dark: null, light: null, hc: Color.black }, localize('dropdownListBackground', "Dropdown list background."));
var selectForeground = registerColor('dropdown.foreground', { dark: '#F0F0F0', light: null, hc: Color.white }, localize('dropdownForeground', "Dropdown foreground."));
var selectBorder = registerColor('dropdown.border', { dark: selectBackground, light: '#CECECE', hc: contrastBorder }, localize('dropdownBorder', "Dropdown border."));
var listFocusBackground = registerColor('list.focusBackground', { dark: '#073655', light: '#DCEBFC', hc: null }, localize('listFocusBackground', "List/Tree background color for the focused item when the list/tree is active. An active list/tree has keyboard focus, an inactive does not."));
var listFocusForeground = registerColor('list.focusForeground', { dark: null, light: null, hc: null }, localize('listFocusForeground', "List/Tree foreground color for the focused item when the list/tree is active. An active list/tree has keyboard focus, an inactive does not."));
var listActiveSelectionBackground = registerColor('list.activeSelectionBackground', { dark: '#094771', light: '#3399FF', hc: null }, localize('listActiveSelectionBackground', "List/Tree background color for the selected item when the list/tree is active. An active list/tree has keyboard focus, an inactive does not."));
var listActiveSelectionForeground = registerColor('list.activeSelectionForeground', { dark: Color.white, light: Color.white, hc: null }, localize('listActiveSelectionForeground', "List/Tree foreground color for the selected item when the list/tree is active. An active list/tree has keyboard focus, an inactive does not."));
var listInactiveSelectionBackground = registerColor('list.inactiveSelectionBackground', { dark: '#3F3F46', light: '#CCCEDB', hc: null }, localize('listInactiveSelectionBackground', "List/Tree background color for the selected item when the list/tree is inactive. An active list/tree has keyboard focus, an inactive does not."));
var listInactiveSelectionForeground = registerColor('list.inactiveSelectionForeground', { dark: null, light: null, hc: null }, localize('listInactiveSelectionForeground', "List/Tree foreground color for the selected item when the list/tree is inactive. An active list/tree has keyboard focus, an inactive does not."));
var listInactiveFocusBackground = registerColor('list.inactiveFocusBackground', { dark: '#313135', light: '#d8dae6', hc: null }, localize('listInactiveSelectionBackground', "List/Tree background color for the selected item when the list/tree is inactive. An active list/tree has keyboard focus, an inactive does not."));
var listHoverBackground = registerColor('list.hoverBackground', { dark: '#2A2D2E', light: '#F0F0F0', hc: null }, localize('listHoverBackground', "List/Tree background when hovering over items using the mouse."));
var listHoverForeground = registerColor('list.hoverForeground', { dark: null, light: null, hc: null }, localize('listHoverForeground', "List/Tree foreground when hovering over items using the mouse."));
var listDropBackground = registerColor('list.dropBackground', { dark: listFocusBackground, light: listFocusBackground, hc: null }, localize('listDropBackground', "List/Tree drag and drop background when moving items around using the mouse."));
var listHighlightForeground = registerColor('list.highlightForeground', { dark: '#0097fb', light: '#007acc', hc: focusBorder }, localize('highlight', 'List/Tree foreground color of the match highlights when searching inside the list/tree.'));
var listInvalidItemForeground = registerColor('list.invalidItemForeground', { dark: '#B89500', light: '#B89500', hc: '#B89500' }, localize('invalidItemForeground', 'List/Tree foreground color for invalid items, for example an unresolved root in explorer.'));
var pickerGroupForeground = registerColor('pickerGroup.foreground', { dark: Color.fromHex('#0097FB').transparent(0.6), light: Color.fromHex('#007ACC').transparent(0.6), hc: Color.white }, localize('pickerGroupForeground', "Quick picker color for grouping labels."));
var pickerGroupBorder = registerColor('pickerGroup.border', { dark: '#3F3F46', light: '#CCCEDB', hc: Color.white }, localize('pickerGroupBorder', "Quick picker color for grouping borders."));
var buttonForeground = registerColor('button.foreground', { dark: Color.white, light: Color.white, hc: Color.white }, localize('buttonForeground', "Button foreground color."));
var buttonBackground = registerColor('button.background', { dark: '#0E639C', light: '#007ACC', hc: null }, localize('buttonBackground', "Button background color."));
var buttonHoverBackground = registerColor('button.hoverBackground', { dark: lighten(buttonBackground, 0.2), light: darken(buttonBackground, 0.2), hc: null }, localize('buttonHoverBackground', "Button background color when hovering."));
var badgeBackground = registerColor('badge.background', { dark: '#4D4D4D', light: '#BEBEBE', hc: Color.black }, localize('badgeBackground', "Badge background color. Badges are small information labels, e.g. for search results count."));
var badgeForeground = registerColor('badge.foreground', { dark: Color.white, light: Color.white, hc: Color.white }, localize('badgeForeground', "Badge foreground color. Badges are small information labels, e.g. for search results count."));
var scrollbarShadow = registerColor('scrollbar.shadow', { dark: '#000000', light: '#DDDDDD', hc: null }, localize('scrollbarShadow', "Scrollbar shadow to indicate that the view is scrolled."));
var scrollbarSliderBackground = registerColor('scrollbarSlider.background', { dark: Color.fromHex('#797979').transparent(0.4), light: Color.fromHex('#646464').transparent(0.4), hc: transparent(contrastBorder, 0.6) }, localize('scrollbarSliderBackground', "Scrollbar slider background color."));
var scrollbarSliderHoverBackground = registerColor('scrollbarSlider.hoverBackground', { dark: Color.fromHex('#646464').transparent(0.7), light: Color.fromHex('#646464').transparent(0.7), hc: transparent(contrastBorder, 0.8) }, localize('scrollbarSliderHoverBackground', "Scrollbar slider background color when hovering."));
var scrollbarSliderActiveBackground = registerColor('scrollbarSlider.activeBackground', { dark: Color.fromHex('#BFBFBF').transparent(0.4), light: Color.fromHex('#000000').transparent(0.6), hc: contrastBorder }, localize('scrollbarSliderActiveBackground', "Scrollbar slider background color when active."));
var progressBarBackground = registerColor('progressBar.background', { dark: Color.fromHex('#0E70C0'), light: Color.fromHex('#0E70C0'), hc: contrastBorder }, localize('progressBarBackground', "Background color of the progress bar that can show for long running operations."));
/**
 * Editor background color.
 * Because of bug https://monacotools.visualstudio.com/DefaultCollection/Monaco/_workitems/edit/13254
 * we are *not* using the color white (or #ffffff, rgba(255,255,255)) but something very close to white.
 */
var editorBackground = registerColor('editor.background', { light: '#fffffe', dark: '#1E1E1E', hc: Color.black }, localize('editorBackground', "Editor background color."));
/**
 * Editor foreground color.
 */
var editorForeground = registerColor('editor.foreground', { light: '#333333', dark: '#BBBBBB', hc: Color.white }, localize('editorForeground', "Editor default foreground color."));
/**
 * Editor widgets
 */
var editorWidgetBackground = registerColor('editorWidget.background', { dark: '#2D2D30', light: '#EFEFF2', hc: '#0C141F' }, localize('editorWidgetBackground', 'Background color of editor widgets, such as find/replace.'));
var editorWidgetBorder = registerColor('editorWidget.border', { dark: '#454545', light: '#C8C8C8', hc: contrastBorder }, localize('editorWidgetBorder', 'Border color of editor widgets. The color is only used if the widget chooses to have a border and if the color is not overridden by a widget.'));
/**
 * Editor selection colors.
 */
var editorSelectionBackground = registerColor('editor.selectionBackground', { light: '#ADD6FF', dark: '#264F78', hc: '#f3f518' }, localize('editorSelectionBackground', "Color of the editor selection."));
var editorSelectionForeground = registerColor('editor.selectionForeground', { light: null, dark: null, hc: '#000000' }, localize('editorSelectionForeground', "Color of the selected text for high contrast."));
var editorInactiveSelection = registerColor('editor.inactiveSelectionBackground', { light: transparent(editorSelectionBackground, 0.5), dark: transparent(editorSelectionBackground, 0.5), hc: transparent(editorSelectionBackground, 0.5) }, localize('editorInactiveSelection', "Color of the selection in an inactive editor. The color must not be opaque to not hide underlying decorations."), true);
var editorSelectionHighlight = registerColor('editor.selectionHighlightBackground', { light: lessProminent(editorSelectionBackground, editorBackground, 0.3, 0.6), dark: lessProminent(editorSelectionBackground, editorBackground, 0.3, 0.6), hc: null }, localize('editorSelectionHighlight', 'Color for regions with the same content as the selection. The color must not be opaque to not hide underlying decorations.'), true);
var editorSelectionHighlightBorder = registerColor('editor.selectionHighlightBorder', { light: null, dark: null, hc: activeContrastBorder }, localize('editorSelectionHighlightBorder', "Border color for regions with the same content as the selection."));
/**
 * Editor find match colors.
 */
var editorFindMatch = registerColor('editor.findMatchBackground', { light: '#A8AC94', dark: '#515C6A', hc: null }, localize('editorFindMatch', "Color of the current search match."));
var editorFindMatchHighlight = registerColor('editor.findMatchHighlightBackground', { light: '#EA5C0055', dark: '#EA5C0055', hc: null }, localize('findMatchHighlight', "Color of the other search matches. The color must not be opaque to not hide underlying decorations."), true);
var editorFindRangeHighlight = registerColor('editor.findRangeHighlightBackground', { dark: '#3a3d4166', light: '#b4b4b44d', hc: null }, localize('findRangeHighlight', "Color of the range limiting the search. The color must not be opaque to not hide underlying decorations."), true);
var editorFindMatchBorder = registerColor('editor.findMatchBorder', { light: null, dark: null, hc: activeContrastBorder }, localize('editorFindMatchBorder', "Border color of the current search match."));
var editorFindMatchHighlightBorder = registerColor('editor.findMatchHighlightBorder', { light: null, dark: null, hc: activeContrastBorder }, localize('findMatchHighlightBorder', "Border color of the other search matches."));
var editorFindRangeHighlightBorder = registerColor('editor.findRangeHighlightBorder', { dark: null, light: null, hc: transparent(activeContrastBorder, 0.4) }, localize('findRangeHighlightBorder', "Border color of the range limiting the search. The color must not be opaque to not hide underlying decorations."), true);
/**
 * Editor hover
 */
var editorHoverHighlight = registerColor('editor.hoverHighlightBackground', { light: '#ADD6FF26', dark: '#264f7840', hc: '#ADD6FF26' }, localize('hoverHighlight', 'Highlight below the word for which a hover is shown. The color must not be opaque to not hide underlying decorations.'), true);
var editorHoverBackground = registerColor('editorHoverWidget.background', { light: editorWidgetBackground, dark: editorWidgetBackground, hc: editorWidgetBackground }, localize('hoverBackground', 'Background color of the editor hover.'));
var editorHoverBorder = registerColor('editorHoverWidget.border', { light: editorWidgetBorder, dark: editorWidgetBorder, hc: editorWidgetBorder }, localize('hoverBorder', 'Border color of the editor hover.'));
/**
 * Editor link colors
 */
var editorActiveLinkForeground = registerColor('editorLink.activeForeground', { dark: '#4E94CE', light: Color.blue, hc: Color.cyan }, localize('activeLinkForeground', 'Color of active links.'));
/**
 * Diff Editor Colors
 */
var defaultInsertColor = new Color(new RGBA(155, 185, 85, 0.2));
var defaultRemoveColor = new Color(new RGBA(255, 0, 0, 0.2));
var diffInserted = registerColor('diffEditor.insertedTextBackground', { dark: defaultInsertColor, light: defaultInsertColor, hc: null }, localize('diffEditorInserted', 'Background color for text that got inserted. The color must not be opaque to not hide underlying decorations.'), true);
var diffRemoved = registerColor('diffEditor.removedTextBackground', { dark: defaultRemoveColor, light: defaultRemoveColor, hc: null }, localize('diffEditorRemoved', 'Background color for text that got removed. The color must not be opaque to not hide underlying decorations.'), true);
var diffInsertedOutline = registerColor('diffEditor.insertedTextBorder', { dark: null, light: null, hc: '#33ff2eff' }, localize('diffEditorInsertedOutline', 'Outline color for the text that got inserted.'));
var diffRemovedOutline = registerColor('diffEditor.removedTextBorder', { dark: null, light: null, hc: '#FF008F' }, localize('diffEditorRemovedOutline', 'Outline color for text that got removed.'));
/**
 * Merge-conflict colors
 */
var headerTransparency = 0.5;
var currentBaseColor = Color.fromHex('#40C8AE').transparent(headerTransparency);
var incomingBaseColor = Color.fromHex('#40A6FF').transparent(headerTransparency);
var commonBaseColor = Color.fromHex('#606060').transparent(0.4);
var contentTransparency = 0.4;
var rulerTransparency = 1;
var mergeCurrentHeaderBackground = registerColor('merge.currentHeaderBackground', { dark: currentBaseColor, light: currentBaseColor, hc: null }, localize('mergeCurrentHeaderBackground', 'Current header background in inline merge-conflicts. The color must not be opaque to not hide underlying decorations.'), true);
var mergeCurrentContentBackground = registerColor('merge.currentContentBackground', { dark: transparent(mergeCurrentHeaderBackground, contentTransparency), light: transparent(mergeCurrentHeaderBackground, contentTransparency), hc: transparent(mergeCurrentHeaderBackground, contentTransparency) }, localize('mergeCurrentContentBackground', 'Current content background in inline merge-conflicts. The color must not be opaque to not hide underlying decorations.'), true);
var mergeIncomingHeaderBackground = registerColor('merge.incomingHeaderBackground', { dark: incomingBaseColor, light: incomingBaseColor, hc: null }, localize('mergeIncomingHeaderBackground', 'Incoming header background in inline merge-conflicts. The color must not be opaque to not hide underlying decorations.'), true);
var mergeIncomingContentBackground = registerColor('merge.incomingContentBackground', { dark: transparent(mergeIncomingHeaderBackground, contentTransparency), light: transparent(mergeIncomingHeaderBackground, contentTransparency), hc: transparent(mergeIncomingHeaderBackground, contentTransparency) }, localize('mergeIncomingContentBackground', 'Incoming content background in inline merge-conflicts. The color must not be opaque to not hide underlying decorations.'), true);
var mergeCommonHeaderBackground = registerColor('merge.commonHeaderBackground', { dark: commonBaseColor, light: commonBaseColor, hc: null }, localize('mergeCommonHeaderBackground', 'Common ancestor header background in inline merge-conflicts. The color must not be opaque to not hide underlying decorations.'), true);
var mergeCommonContentBackground = registerColor('merge.commonContentBackground', { dark: transparent(mergeCommonHeaderBackground, contentTransparency), light: transparent(mergeCommonHeaderBackground, contentTransparency), hc: transparent(mergeCommonHeaderBackground, contentTransparency) }, localize('mergeCommonContentBackground', 'Common ancestor content background in inline merge-conflicts. The color must not be opaque to not hide underlying decorations.'), true);
var mergeBorder = registerColor('merge.border', { dark: null, light: null, hc: '#C3DF6F' }, localize('mergeBorder', 'Border color on headers and the splitter in inline merge-conflicts.'));
var overviewRulerCurrentContentForeground = registerColor('editorOverviewRuler.currentContentForeground', { dark: transparent(mergeCurrentHeaderBackground, rulerTransparency), light: transparent(mergeCurrentHeaderBackground, rulerTransparency), hc: mergeBorder }, localize('overviewRulerCurrentContentForeground', 'Current overview ruler foreground for inline merge-conflicts.'));
var overviewRulerIncomingContentForeground = registerColor('editorOverviewRuler.incomingContentForeground', { dark: transparent(mergeIncomingHeaderBackground, rulerTransparency), light: transparent(mergeIncomingHeaderBackground, rulerTransparency), hc: mergeBorder }, localize('overviewRulerIncomingContentForeground', 'Incoming overview ruler foreground for inline merge-conflicts.'));
var overviewRulerCommonContentForeground = registerColor('editorOverviewRuler.commonContentForeground', { dark: transparent(mergeCommonHeaderBackground, rulerTransparency), light: transparent(mergeCommonHeaderBackground, rulerTransparency), hc: mergeBorder }, localize('overviewRulerCommonContentForeground', 'Common ancestor overview ruler foreground for inline merge-conflicts.'));
var findMatchColorDefault = new Color(new RGBA(246, 185, 77, 0.7));
var overviewRulerFindMatchForeground = registerColor('editorOverviewRuler.findMatchForeground', { dark: findMatchColorDefault, light: findMatchColorDefault, hc: findMatchColorDefault }, localize('overviewRulerFindMatchForeground', 'Overview ruler marker color for find matches. The color must not be opaque to not hide underlying decorations.'), true);
var overviewRulerSelectionHighlightForeground = registerColor('editorOverviewRuler.selectionHighlightForeground', { dark: '#A0A0A0CC', light: '#A0A0A0CC', hc: '#A0A0A0CC' }, localize('overviewRulerSelectionHighlightForeground', 'Overview ruler marker color for selection highlights. The color must not be opaque to not hide underlying decorations.'), true);
// ----- color functions
function darken(colorValue, factor) {
    return function (theme) {
        var color = resolveColorValue(colorValue, theme);
        if (color) {
            return color.darken(factor);
        }
        return null;
    };
}
function lighten(colorValue, factor) {
    return function (theme) {
        var color = resolveColorValue(colorValue, theme);
        if (color) {
            return color.lighten(factor);
        }
        return null;
    };
}
function transparent(colorValue, factor) {
    return function (theme) {
        var color = resolveColorValue(colorValue, theme);
        if (color) {
            return color.transparent(factor);
        }
        return null;
    };
}
function oneOf() {
    var colorValues = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        colorValues[_i] = arguments[_i];
    }
    return function (theme) {
        for (var _i = 0, colorValues_1 = colorValues; _i < colorValues_1.length; _i++) {
            var colorValue = colorValues_1[_i];
            var color = resolveColorValue(colorValue, theme);
            if (color) {
                return color;
            }
        }
        return null;
    };
}
function lessProminent(colorValue, backgroundColorValue, factor, transparency) {
    return function (theme) {
        var from = resolveColorValue(colorValue, theme);
        if (from) {
            var backgroundColor = resolveColorValue(backgroundColorValue, theme);
            if (backgroundColor) {
                if (from.isDarkerThan(backgroundColor)) {
                    return Color.getLighterColor(from, backgroundColor, factor).transparent(transparency);
                }
                return Color.getDarkerColor(from, backgroundColor, factor).transparent(transparency);
            }
            return from.transparent(factor * transparency);
        }
        return null;
    };
}
// ----- implementation
/**
 * @param colorValue Resolve a color value in the context of a theme
 */
function resolveColorValue(colorValue, theme) {
    if (colorValue === null) {
        return null;
    }
    else if (typeof colorValue === 'string') {
        if (colorValue[0] === '#') {
            return Color.fromHex(colorValue);
        }
        return theme.getColor(colorValue);
    }
    else if (colorValue instanceof Color) {
        return colorValue;
    }
    else if (typeof colorValue === 'function') {
        return colorValue(theme);
    }
    return null;
}

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var IThemeService = createDecorator('themeService');
function themeColorFromId(id) {
    return { id: id };
}
// base themes
var DARK = 'dark';
var HIGH_CONTRAST = 'hc';
function getThemeTypeSelector(type) {
    switch (type) {
        case DARK: return 'vs-dark';
        case HIGH_CONTRAST: return 'hc-black';
        default: return 'vs';
    }
}
// static theming participant
var Extensions$5 = {
    ThemingContribution: 'base.contributions.theming'
};
var ThemingRegistry = /** @class */ (function () {
    function ThemingRegistry() {
        this.themingParticipants = [];
        this.themingParticipants = [];
        this.onThemingParticipantAddedEmitter = new Emitter();
    }
    ThemingRegistry.prototype.onThemeChange = function (participant) {
        var _this = this;
        this.themingParticipants.push(participant);
        this.onThemingParticipantAddedEmitter.fire(participant);
        return {
            dispose: function () {
                var idx = _this.themingParticipants.indexOf(participant);
                _this.themingParticipants.splice(idx, 1);
            }
        };
    };
    Object.defineProperty(ThemingRegistry.prototype, "onThemingParticipantAdded", {
        get: function () {
            return this.onThemingParticipantAddedEmitter.event;
        },
        enumerable: true,
        configurable: true
    });
    ThemingRegistry.prototype.getThemingParticipants = function () {
        return this.themingParticipants;
    };
    return ThemingRegistry;
}());
var themingRegistry = new ThemingRegistry();
Registry.add(Extensions$5.ThemingContribution, themingRegistry);
function registerThemingParticipant(participant) {
    return themingRegistry.onThemeChange(participant);
}

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
/**
 * Definition of the editor colors
 */
var editorLineHighlight = registerColor('editor.lineHighlightBackground', { dark: null, light: null, hc: null }, localize('lineHighlight', 'Background color for the highlight of line at the cursor position.'));
var editorLineHighlightBorder = registerColor('editor.lineHighlightBorder', { dark: '#282828', light: '#eeeeee', hc: '#f38518' }, localize('lineHighlightBorderBox', 'Background color for the border around the line at the cursor position.'));
var editorRangeHighlight = registerColor('editor.rangeHighlightBackground', { dark: '#ffffff0b', light: '#fdff0033', hc: null }, localize('rangeHighlight', 'Background color of highlighted ranges, like by quick open and find features. The color must not be opaque to not hide underlying decorations.'), true);
var editorRangeHighlightBorder = registerColor('editor.rangeHighlightBorder', { dark: null, light: null, hc: activeContrastBorder }, localize('rangeHighlightBorder', 'Background color of the border around highlighted ranges.'), true);
var editorCursorForeground = registerColor('editorCursor.foreground', { dark: '#AEAFAD', light: Color.black, hc: Color.white }, localize('caret', 'Color of the editor cursor.'));
var editorCursorBackground = registerColor('editorCursor.background', null, localize('editorCursorBackground', 'The background color of the editor cursor. Allows customizing the color of a character overlapped by a block cursor.'));
var editorWhitespaces = registerColor('editorWhitespace.foreground', { dark: '#e3e4e229', light: '#33333333', hc: '#e3e4e229' }, localize('editorWhitespaces', 'Color of whitespace characters in the editor.'));
var editorIndentGuides = registerColor('editorIndentGuide.background', { dark: editorWhitespaces, light: editorWhitespaces, hc: editorWhitespaces }, localize('editorIndentGuides', 'Color of the editor indentation guides.'));
var editorActiveIndentGuides = registerColor('editorIndentGuide.activeBackground', { dark: editorWhitespaces, light: editorWhitespaces, hc: editorWhitespaces }, localize('editorActiveIndentGuide', 'Color of the active editor indentation guides.'));
var editorLineNumbers = registerColor('editorLineNumber.foreground', { dark: '#5A5A5A', light: '#2B91AF', hc: Color.white }, localize('editorLineNumbers', 'Color of editor line numbers.'));
var deprecatedEditorActiveLineNumber = registerColor('editorActiveLineNumber.foreground', { dark: null, light: null, hc: null }, localize('editorActiveLineNumber', 'Color of editor active line number'), false, localize('deprecatedEditorActiveLineNumber', 'Id is deprecated. Use \'editorLineNumber.activeForeground\' instead.'));
var editorActiveLineNumber = registerColor('editorLineNumber.activeForeground', { dark: deprecatedEditorActiveLineNumber, light: deprecatedEditorActiveLineNumber, hc: deprecatedEditorActiveLineNumber }, localize('editorActiveLineNumber', 'Color of editor active line number'));
var editorRuler = registerColor('editorRuler.foreground', { dark: '#5A5A5A', light: Color.lightgrey, hc: Color.white }, localize('editorRuler', 'Color of the editor rulers.'));
var editorCodeLensForeground = registerColor('editorCodeLens.foreground', { dark: '#999999', light: '#999999', hc: '#999999' }, localize('editorCodeLensForeground', 'Foreground color of editor code lenses'));
var editorBracketMatchBackground = registerColor('editorBracketMatch.background', { dark: '#0064001a', light: '#0064001a', hc: '#0064001a' }, localize('editorBracketMatchBackground', 'Background color behind matching brackets'));
var editorBracketMatchBorder = registerColor('editorBracketMatch.border', { dark: '#888', light: '#B9B9B9', hc: '#fff' }, localize('editorBracketMatchBorder', 'Color for matching brackets boxes'));
var editorOverviewRulerBorder = registerColor('editorOverviewRuler.border', { dark: '#7f7f7f4d', light: '#7f7f7f4d', hc: '#7f7f7f4d' }, localize('editorOverviewRulerBorder', 'Color of the overview ruler border.'));
var editorGutter = registerColor('editorGutter.background', { dark: editorBackground, light: editorBackground, hc: editorBackground }, localize('editorGutter', 'Background color of the editor gutter. The gutter contains the glyph margins and the line numbers.'));
var editorErrorForeground = registerColor('editorError.foreground', { dark: '#ea4646', light: '#d60a0a', hc: null }, localize('errorForeground', 'Foreground color of error squigglies in the editor.'));
var editorErrorBorder = registerColor('editorError.border', { dark: null, light: null, hc: Color.fromHex('#E47777').transparent(0.8) }, localize('errorBorder', 'Border color of error squigglies in the editor.'));
var editorWarningForeground = registerColor('editorWarning.foreground', { dark: '#4d9e4d', light: '#117711', hc: null }, localize('warningForeground', 'Foreground color of warning squigglies in the editor.'));
var editorWarningBorder = registerColor('editorWarning.border', { dark: null, light: null, hc: Color.fromHex('#71B771').transparent(0.8) }, localize('warningBorder', 'Border color of warning squigglies in the editor.'));
var editorInfoForeground = registerColor('editorInfo.foreground', { dark: '#008000', light: '#008000', hc: null }, localize('infoForeground', 'Foreground color of info squigglies in the editor.'));
var editorInfoBorder = registerColor('editorInfo.border', { dark: null, light: null, hc: Color.fromHex('#71B771').transparent(0.8) }, localize('infoBorder', 'Border color of info squigglies in the editor.'));
var editorHintForeground = registerColor('editorHint.foreground', { dark: Color.fromHex('#eeeeee').transparent(0.7), light: '#6c6c6c', hc: null }, localize('hintForeground', 'Foreground color of hint squigglies in the editor.'));
var editorHintBorder = registerColor('editorHint.border', { dark: null, light: null, hc: Color.fromHex('#eeeeee').transparent(0.8) }, localize('hintBorder', 'Border color of hint squigglies in the editor.'));
var rulerRangeDefault = new Color(new RGBA(0, 122, 204, 0.6));
var overviewRulerRangeHighlight = registerColor('editorOverviewRuler.rangeHighlightForeground', { dark: rulerRangeDefault, light: rulerRangeDefault, hc: rulerRangeDefault }, localize('overviewRulerRangeHighlight', 'Overview ruler marker color for range highlights. The color must not be opaque to not hide underlying decorations.'), true);
var overviewRulerError = registerColor('editorOverviewRuler.errorForeground', { dark: new Color(new RGBA(255, 18, 18, 0.7)), light: new Color(new RGBA(255, 18, 18, 0.7)), hc: new Color(new RGBA(255, 50, 50, 1)) }, localize('overviewRuleError', 'Overview ruler marker color for errors.'));
var overviewRulerWarning = registerColor('editorOverviewRuler.warningForeground', { dark: new Color(new RGBA(18, 136, 18, 0.7)), light: new Color(new RGBA(18, 136, 18, 0.7)), hc: new Color(new RGBA(50, 255, 50, 1)) }, localize('overviewRuleWarning', 'Overview ruler marker color for warnings.'));
var overviewRulerInfo = registerColor('editorOverviewRuler.infoForeground', { dark: new Color(new RGBA(18, 18, 136, 0.7)), light: new Color(new RGBA(18, 18, 136, 0.7)), hc: new Color(new RGBA(50, 50, 255, 1)) }, localize('overviewRuleInfo', 'Overview ruler marker color for infos.'));
// contains all color rules that used to defined in editor/browser/widget/editor.css
registerThemingParticipant(function (theme, collector) {
    var background = theme.getColor(editorBackground);
    if (background) {
        collector.addRule(".monaco-editor, .monaco-editor-background, .monaco-editor .inputarea.ime-input { background-color: " + background + "; }");
    }
    var foreground$$1 = theme.getColor(editorForeground);
    if (foreground$$1) {
        collector.addRule(".monaco-editor, .monaco-editor .inputarea.ime-input { color: " + foreground$$1 + "; }");
    }
    var gutter = theme.getColor(editorGutter);
    if (gutter) {
        collector.addRule(".monaco-editor .margin { background-color: " + gutter + "; }");
    }
    var rangeHighlight = theme.getColor(editorRangeHighlight);
    if (rangeHighlight) {
        collector.addRule(".monaco-editor .rangeHighlight { background-color: " + rangeHighlight + "; }");
    }
    var rangeHighlightBorder = theme.getColor(editorRangeHighlightBorder);
    if (rangeHighlightBorder) {
        collector.addRule(".monaco-editor .rangeHighlight { border: 1px " + (theme.type === 'hc' ? 'dotted' : 'solid') + " " + rangeHighlightBorder + "; }");
    }
    var invisibles = theme.getColor(editorWhitespaces);
    if (invisibles) {
        collector.addRule(".vs-whitespace { color: " + invisibles + " !important; }");
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$q = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var DynamicViewOverlay = /** @class */ (function (_super) {
    __extends$q(DynamicViewOverlay, _super);
    function DynamicViewOverlay() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return DynamicViewOverlay;
}(ViewEventHandler));

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$r = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var LineNumbersOverlay = /** @class */ (function (_super) {
    __extends$r(LineNumbersOverlay, _super);
    function LineNumbersOverlay(context) {
        var _this = _super.call(this) || this;
        _this._context = context;
        _this._readConfig();
        _this._lastCursorModelPosition = new Position(1, 1);
        _this._renderResult = null;
        _this._context.addEventHandler(_this);
        return _this;
    }
    LineNumbersOverlay.prototype._readConfig = function () {
        var config = this._context.configuration.editor;
        this._lineHeight = config.lineHeight;
        this._renderLineNumbers = config.viewInfo.renderLineNumbers;
        this._renderCustomLineNumbers = config.viewInfo.renderCustomLineNumbers;
        this._lineNumbersLeft = config.layoutInfo.lineNumbersLeft;
        this._lineNumbersWidth = config.layoutInfo.lineNumbersWidth;
    };
    LineNumbersOverlay.prototype.dispose = function () {
        this._context.removeEventHandler(this);
        this._context = null;
        this._renderResult = null;
        _super.prototype.dispose.call(this);
    };
    // --- begin event handlers
    LineNumbersOverlay.prototype.onConfigurationChanged = function (e) {
        this._readConfig();
        return true;
    };
    LineNumbersOverlay.prototype.onCursorStateChanged = function (e) {
        var primaryViewPosition = e.selections[0].getPosition();
        this._lastCursorModelPosition = this._context.model.coordinatesConverter.convertViewPositionToModelPosition(primaryViewPosition);
        if (this._renderLineNumbers === 2 /* Relative */ || this._renderLineNumbers === 3 /* Interval */) {
            return true;
        }
        return false;
    };
    LineNumbersOverlay.prototype.onFlushed = function (e) {
        return true;
    };
    LineNumbersOverlay.prototype.onLinesChanged = function (e) {
        return true;
    };
    LineNumbersOverlay.prototype.onLinesDeleted = function (e) {
        return true;
    };
    LineNumbersOverlay.prototype.onLinesInserted = function (e) {
        return true;
    };
    LineNumbersOverlay.prototype.onScrollChanged = function (e) {
        return e.scrollTopChanged;
    };
    LineNumbersOverlay.prototype.onZonesChanged = function (e) {
        return true;
    };
    // --- end event handlers
    LineNumbersOverlay.prototype._getLineRenderLineNumber = function (viewLineNumber) {
        var modelPosition = this._context.model.coordinatesConverter.convertViewPositionToModelPosition(new Position(viewLineNumber, 1));
        if (modelPosition.column !== 1) {
            return '';
        }
        var modelLineNumber = modelPosition.lineNumber;
        if (this._renderCustomLineNumbers) {
            return this._renderCustomLineNumbers(modelLineNumber);
        }
        if (this._renderLineNumbers === 2 /* Relative */) {
            var diff = Math.abs(this._lastCursorModelPosition.lineNumber - modelLineNumber);
            if (diff === 0) {
                return '<span class="relative-current-line-number">' + modelLineNumber + '</span>';
            }
            return String(diff);
        }
        if (this._renderLineNumbers === 3 /* Interval */) {
            if (this._lastCursorModelPosition.lineNumber === modelLineNumber) {
                return String(modelLineNumber);
            }
            if (modelLineNumber % 10 === 0) {
                return String(modelLineNumber);
            }
            return '';
        }
        return String(modelLineNumber);
    };
    LineNumbersOverlay.prototype.prepareRender = function (ctx) {
        if (this._renderLineNumbers === 0 /* Off */) {
            this._renderResult = null;
            return;
        }
        var lineHeightClassName = (isLinux ? (this._lineHeight % 2 === 0 ? ' lh-even' : ' lh-odd') : '');
        var visibleStartLineNumber = ctx.visibleRange.startLineNumber;
        var visibleEndLineNumber = ctx.visibleRange.endLineNumber;
        var common = '<div class="' + LineNumbersOverlay.CLASS_NAME + lineHeightClassName + '" style="left:' + this._lineNumbersLeft.toString() + 'px;width:' + this._lineNumbersWidth.toString() + 'px;">';
        var output = [];
        for (var lineNumber = visibleStartLineNumber; lineNumber <= visibleEndLineNumber; lineNumber++) {
            var lineIndex = lineNumber - visibleStartLineNumber;
            var renderLineNumber = this._getLineRenderLineNumber(lineNumber);
            if (renderLineNumber) {
                output[lineIndex] = (common
                    + renderLineNumber
                    + '</div>');
            }
            else {
                output[lineIndex] = '';
            }
        }
        this._renderResult = output;
    };
    LineNumbersOverlay.prototype.render = function (startLineNumber, lineNumber) {
        if (!this._renderResult) {
            return '';
        }
        var lineIndex = lineNumber - startLineNumber;
        if (lineIndex < 0 || lineIndex >= this._renderResult.length) {
            return '';
        }
        return this._renderResult[lineIndex];
    };
    LineNumbersOverlay.CLASS_NAME = 'line-numbers';
    return LineNumbersOverlay;
}(DynamicViewOverlay));
// theming
registerThemingParticipant(function (theme, collector) {
    var lineNumbers = theme.getColor(editorLineNumbers);
    if (lineNumbers) {
        collector.addRule(".monaco-editor .line-numbers { color: " + lineNumbers + "; }");
    }
    var activeLineNumber = theme.getColor(editorActiveLineNumber);
    if (activeLineNumber) {
        collector.addRule(".monaco-editor .current-line ~ .line-numbers { color: " + activeLineNumber + "; }");
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$s = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var VisibleTextAreaData = /** @class */ (function () {
    function VisibleTextAreaData(top, left, width) {
        this.top = top;
        this.left = left;
        this.width = width;
    }
    VisibleTextAreaData.prototype.setWidth = function (width) {
        return new VisibleTextAreaData(this.top, this.left, width);
    };
    return VisibleTextAreaData;
}());
var canUseZeroSizeTextarea = (isEdgeOrIE || isFirefox);
/**
 * Every time we write to the clipboard, we record a bit of extra metadata here.
 * Every time we read from the cipboard, if the text matches our last written text,
 * we can fetch the previous metadata.
 */
var LocalClipboardMetadataManager = /** @class */ (function () {
    function LocalClipboardMetadataManager() {
        this._lastState = null;
    }
    LocalClipboardMetadataManager.prototype.set = function (state) {
        this._lastState = state;
    };
    LocalClipboardMetadataManager.prototype.get = function (pastedText) {
        if (this._lastState && this._lastState.lastCopiedValue === pastedText) {
            // match!
            return this._lastState;
        }
        this._lastState = null;
        return null;
    };
    LocalClipboardMetadataManager.INSTANCE = new LocalClipboardMetadataManager();
    return LocalClipboardMetadataManager;
}());
var TextAreaHandler = /** @class */ (function (_super) {
    __extends$s(TextAreaHandler, _super);
    function TextAreaHandler(context, viewController, viewHelper) {
        var _this = _super.call(this, context) || this;
        // --- end view API
        _this._primaryCursorVisibleRange = null;
        _this._viewController = viewController;
        _this._viewHelper = viewHelper;
        var conf = _this._context.configuration.editor;
        _this._accessibilitySupport = conf.accessibilitySupport;
        _this._contentLeft = conf.layoutInfo.contentLeft;
        _this._contentWidth = conf.layoutInfo.contentWidth;
        _this._contentHeight = conf.layoutInfo.contentHeight;
        _this._scrollLeft = 0;
        _this._scrollTop = 0;
        _this._fontInfo = conf.fontInfo;
        _this._lineHeight = conf.lineHeight;
        _this._emptySelectionClipboard = conf.emptySelectionClipboard;
        _this._visibleTextArea = null;
        _this._selections = [new Selection(1, 1, 1, 1)];
        // Text Area (The focus will always be in the textarea when the cursor is blinking)
        _this.textArea = createFastDomNode(document.createElement('textarea'));
        PartFingerprints.write(_this.textArea, 6 /* TextArea */);
        _this.textArea.setClassName('inputarea');
        _this.textArea.setAttribute('wrap', 'off');
        _this.textArea.setAttribute('autocorrect', 'off');
        _this.textArea.setAttribute('autocapitalize', 'off');
        _this.textArea.setAttribute('autocomplete', 'off');
        _this.textArea.setAttribute('spellcheck', 'false');
        _this.textArea.setAttribute('aria-label', conf.viewInfo.ariaLabel);
        _this.textArea.setAttribute('role', 'textbox');
        _this.textArea.setAttribute('aria-multiline', 'true');
        _this.textArea.setAttribute('aria-haspopup', 'false');
        _this.textArea.setAttribute('aria-autocomplete', 'both');
        _this.textAreaCover = createFastDomNode(document.createElement('div'));
        _this.textAreaCover.setPosition('absolute');
        var simpleModel = {
            getLineCount: function () {
                return _this._context.model.getLineCount();
            },
            getLineMaxColumn: function (lineNumber) {
                return _this._context.model.getLineMaxColumn(lineNumber);
            },
            getValueInRange: function (range, eol) {
                return _this._context.model.getValueInRange(range, eol);
            }
        };
        var textAreaInputHost = {
            getPlainTextToCopy: function () {
                var rawWhatToCopy = _this._context.model.getPlainTextToCopy(_this._selections, _this._emptySelectionClipboard, isWindows);
                var newLineCharacter = _this._context.model.getEOL();
                var isFromEmptySelection = (_this._emptySelectionClipboard && _this._selections.length === 1 && _this._selections[0].isEmpty());
                var multicursorText = (Array.isArray(rawWhatToCopy) ? rawWhatToCopy : null);
                var whatToCopy = (Array.isArray(rawWhatToCopy) ? rawWhatToCopy.join(newLineCharacter) : rawWhatToCopy);
                var metadata = null;
                if (isFromEmptySelection || multicursorText) {
                    // Only store the non-default metadata
                    // When writing "LINE\r\n" to the clipboard and then pasting,
                    // Firefox pastes "LINE\n", so let's work around this quirk
                    var lastCopiedValue = (isFirefox ? whatToCopy.replace(/\r\n/g, '\n') : whatToCopy);
                    metadata = {
                        lastCopiedValue: lastCopiedValue,
                        isFromEmptySelection: (_this._emptySelectionClipboard && _this._selections.length === 1 && _this._selections[0].isEmpty()),
                        multicursorText: multicursorText
                    };
                }
                LocalClipboardMetadataManager.INSTANCE.set(metadata);
                return whatToCopy;
            },
            getHTMLToCopy: function () {
                return _this._context.model.getHTMLToCopy(_this._selections, _this._emptySelectionClipboard);
            },
            getScreenReaderContent: function (currentState) {
                if (isIPad) {
                    // Do not place anything in the textarea for the iPad
                    return TextAreaState.EMPTY;
                }
                if (_this._accessibilitySupport === 1 /* Disabled */) {
                    // We know for a fact that a screen reader is not attached
                    // On OSX, we write the character before the cursor to allow for "long-press" composition
                    // Also on OSX, we write the word before the cursor to allow for the Accessibility Keyboard to give good hints
                    if (isMacintosh) {
                        var selection = _this._selections[0];
                        if (selection.isEmpty()) {
                            var position = selection.getStartPosition();
                            var textBefore = _this._getWordBeforePosition(position);
                            if (textBefore.length === 0) {
                                textBefore = _this._getCharacterBeforePosition(position);
                            }
                            if (textBefore.length > 0) {
                                return new TextAreaState(textBefore, textBefore.length, textBefore.length, position, position);
                            }
                        }
                    }
                    return TextAreaState.EMPTY;
                }
                return PagedScreenReaderStrategy.fromEditorSelection(currentState, simpleModel, _this._selections[0], _this._accessibilitySupport === 0 /* Unknown */);
            },
            deduceModelPosition: function (viewAnchorPosition, deltaOffset, lineFeedCnt) {
                return _this._context.model.deduceModelPositionRelativeToViewPosition(viewAnchorPosition, deltaOffset, lineFeedCnt);
            }
        };
        _this._textAreaInput = _this._register(new TextAreaInput(textAreaInputHost, _this.textArea));
        _this._register(_this._textAreaInput.onKeyDown(function (e) {
            _this._viewController.emitKeyDown(e);
        }));
        _this._register(_this._textAreaInput.onKeyUp(function (e) {
            _this._viewController.emitKeyUp(e);
        }));
        _this._register(_this._textAreaInput.onPaste(function (e) {
            var metadata = LocalClipboardMetadataManager.INSTANCE.get(e.text);
            var pasteOnNewLine = false;
            var multicursorText = null;
            if (metadata) {
                pasteOnNewLine = (_this._emptySelectionClipboard && metadata.isFromEmptySelection);
                multicursorText = metadata.multicursorText;
            }
            _this._viewController.paste('keyboard', e.text, pasteOnNewLine, multicursorText);
        }));
        _this._register(_this._textAreaInput.onCut(function () {
            _this._viewController.cut('keyboard');
        }));
        _this._register(_this._textAreaInput.onType(function (e) {
            if (e.replaceCharCnt) {
                _this._viewController.replacePreviousChar('keyboard', e.text, e.replaceCharCnt);
            }
            else {
                _this._viewController.type('keyboard', e.text);
            }
        }));
        _this._register(_this._textAreaInput.onSelectionChangeRequest(function (modelSelection) {
            _this._viewController.setSelection('keyboard', modelSelection);
        }));
        _this._register(_this._textAreaInput.onCompositionStart(function () {
            var lineNumber = _this._selections[0].startLineNumber;
            var column = _this._selections[0].startColumn;
            _this._context.privateViewEventBus.emit(new ViewRevealRangeRequestEvent(new Range(lineNumber, column, lineNumber, column), 0 /* Simple */, true, 1 /* Immediate */));
            // Find range pixel position
            var visibleRange = _this._viewHelper.visibleRangeForPositionRelativeToEditor(lineNumber, column);
            if (visibleRange) {
                _this._visibleTextArea = new VisibleTextAreaData(_this._context.viewLayout.getVerticalOffsetForLineNumber(lineNumber), visibleRange.left, canUseZeroSizeTextarea ? 0 : 1);
                _this._render();
            }
            // Show the textarea
            _this.textArea.setClassName('inputarea ime-input');
            _this._viewController.compositionStart('keyboard');
        }));
        _this._register(_this._textAreaInput.onCompositionUpdate(function (e) {
            if (isEdgeOrIE) {
                // Due to isEdgeOrIE (where the textarea was not cleared initially)
                // we cannot assume the text consists only of the composited text
                _this._visibleTextArea = _this._visibleTextArea.setWidth(0);
            }
            else {
                // adjust width by its size
                _this._visibleTextArea = _this._visibleTextArea.setWidth(measureText(e.data, _this._fontInfo));
            }
            _this._render();
        }));
        _this._register(_this._textAreaInput.onCompositionEnd(function () {
            _this._visibleTextArea = null;
            _this._render();
            _this.textArea.setClassName('inputarea');
            _this._viewController.compositionEnd('keyboard');
        }));
        _this._register(_this._textAreaInput.onFocus(function () {
            _this._context.privateViewEventBus.emit(new ViewFocusChangedEvent(true));
        }));
        _this._register(_this._textAreaInput.onBlur(function () {
            _this._context.privateViewEventBus.emit(new ViewFocusChangedEvent(false));
        }));
        return _this;
    }
    TextAreaHandler.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
    };
    TextAreaHandler.prototype._getWordBeforePosition = function (position) {
        var lineContent = this._context.model.getLineContent(position.lineNumber);
        var wordSeparators = getMapForWordSeparators(this._context.configuration.editor.wordSeparators);
        var column = position.column;
        var distance = 0;
        while (column > 1) {
            var charCode = lineContent.charCodeAt(column - 2);
            var charClass = wordSeparators.get(charCode);
            if (charClass !== 0 /* Regular */ || distance > 50) {
                return lineContent.substring(column - 1, position.column - 1);
            }
            distance++;
            column--;
        }
        return lineContent.substring(0, position.column - 1);
    };
    TextAreaHandler.prototype._getCharacterBeforePosition = function (position) {
        if (position.column > 1) {
            var lineContent = this._context.model.getLineContent(position.lineNumber);
            var charBefore = lineContent.charAt(position.column - 2);
            if (!isHighSurrogate(charBefore.charCodeAt(0))) {
                return charBefore;
            }
        }
        return '';
    };
    // --- begin event handlers
    TextAreaHandler.prototype.onConfigurationChanged = function (e) {
        var conf = this._context.configuration.editor;
        if (e.fontInfo) {
            this._fontInfo = conf.fontInfo;
        }
        if (e.viewInfo) {
            this.textArea.setAttribute('aria-label', conf.viewInfo.ariaLabel);
        }
        if (e.layoutInfo) {
            this._contentLeft = conf.layoutInfo.contentLeft;
            this._contentWidth = conf.layoutInfo.contentWidth;
            this._contentHeight = conf.layoutInfo.contentHeight;
        }
        if (e.lineHeight) {
            this._lineHeight = conf.lineHeight;
        }
        if (e.accessibilitySupport) {
            this._accessibilitySupport = conf.accessibilitySupport;
            this._textAreaInput.writeScreenReaderContent('strategy changed');
        }
        if (e.emptySelectionClipboard) {
            this._emptySelectionClipboard = conf.emptySelectionClipboard;
        }
        return true;
    };
    TextAreaHandler.prototype.onCursorStateChanged = function (e) {
        this._selections = e.selections.slice(0);
        this._textAreaInput.writeScreenReaderContent('selection changed');
        return true;
    };
    TextAreaHandler.prototype.onDecorationsChanged = function (e) {
        // true for inline decorations that can end up relayouting text
        return true;
    };
    TextAreaHandler.prototype.onFlushed = function (e) {
        return true;
    };
    TextAreaHandler.prototype.onLinesChanged = function (e) {
        return true;
    };
    TextAreaHandler.prototype.onLinesDeleted = function (e) {
        return true;
    };
    TextAreaHandler.prototype.onLinesInserted = function (e) {
        return true;
    };
    TextAreaHandler.prototype.onScrollChanged = function (e) {
        this._scrollLeft = e.scrollLeft;
        this._scrollTop = e.scrollTop;
        return true;
    };
    TextAreaHandler.prototype.onZonesChanged = function (e) {
        return true;
    };
    // --- end event handlers
    // --- begin view API
    TextAreaHandler.prototype.isFocused = function () {
        return this._textAreaInput.isFocused();
    };
    TextAreaHandler.prototype.focusTextArea = function () {
        this._textAreaInput.focusTextArea();
    };
    TextAreaHandler.prototype.prepareRender = function (ctx) {
        if (this._accessibilitySupport === 2 /* Enabled */) {
            // Do not move the textarea with the cursor, as this generates accessibility events that might confuse screen readers
            // See https://github.com/Microsoft/vscode/issues/26730
            this._primaryCursorVisibleRange = null;
        }
        else {
            var primaryCursorPosition = new Position(this._selections[0].positionLineNumber, this._selections[0].positionColumn);
            this._primaryCursorVisibleRange = ctx.visibleRangeForPosition(primaryCursorPosition);
        }
    };
    TextAreaHandler.prototype.render = function (ctx) {
        this._textAreaInput.writeScreenReaderContent('render');
        this._render();
    };
    TextAreaHandler.prototype._render = function () {
        if (this._visibleTextArea) {
            // The text area is visible for composition reasons
            this._renderInsideEditor(this._visibleTextArea.top - this._scrollTop, this._contentLeft + this._visibleTextArea.left - this._scrollLeft, this._visibleTextArea.width, this._lineHeight, true);
            return;
        }
        if (!this._primaryCursorVisibleRange) {
            // The primary cursor is outside the viewport => place textarea to the top left
            this._renderAtTopLeft();
            return;
        }
        var left = this._contentLeft + this._primaryCursorVisibleRange.left - this._scrollLeft;
        if (left < this._contentLeft || left > this._contentLeft + this._contentWidth) {
            // cursor is outside the viewport
            this._renderAtTopLeft();
            return;
        }
        var top = this._context.viewLayout.getVerticalOffsetForLineNumber(this._selections[0].positionLineNumber) - this._scrollTop;
        if (top < 0 || top > this._contentHeight) {
            // cursor is outside the viewport
            this._renderAtTopLeft();
            return;
        }
        // The primary cursor is in the viewport (at least vertically) => place textarea on the cursor
        this._renderInsideEditor(top, left, canUseZeroSizeTextarea ? 0 : 1, canUseZeroSizeTextarea ? 0 : 1, false);
    };
    TextAreaHandler.prototype._renderInsideEditor = function (top, left, width, height, useEditorFont) {
        var ta = this.textArea;
        var tac = this.textAreaCover;
        if (useEditorFont) {
            Configuration$1.applyFontInfo(ta, this._fontInfo);
        }
        else {
            ta.setFontSize(1);
            ta.setLineHeight(this._fontInfo.lineHeight);
        }
        ta.setTop(top);
        ta.setLeft(left);
        ta.setWidth(width);
        ta.setHeight(height);
        tac.setTop(0);
        tac.setLeft(0);
        tac.setWidth(0);
        tac.setHeight(0);
    };
    TextAreaHandler.prototype._renderAtTopLeft = function () {
        var ta = this.textArea;
        var tac = this.textAreaCover;
        Configuration$1.applyFontInfo(ta, this._fontInfo);
        ta.setTop(0);
        ta.setLeft(0);
        tac.setTop(0);
        tac.setLeft(0);
        if (canUseZeroSizeTextarea) {
            ta.setWidth(0);
            ta.setHeight(0);
            tac.setWidth(0);
            tac.setHeight(0);
            return;
        }
        // (in WebKit the textarea is 1px by 1px because it cannot handle input to a 0x0 textarea)
        // specifically, when doing Korean IME, setting the textare to 0x0 breaks IME badly.
        ta.setWidth(1);
        ta.setHeight(1);
        tac.setWidth(1);
        tac.setHeight(1);
        if (this._context.configuration.editor.viewInfo.glyphMargin) {
            tac.setClassName('monaco-editor-background textAreaCover ' + Margin.OUTER_CLASS_NAME);
        }
        else {
            if (this._context.configuration.editor.viewInfo.renderLineNumbers !== 0 /* Off */) {
                tac.setClassName('monaco-editor-background textAreaCover ' + LineNumbersOverlay.CLASS_NAME);
            }
            else {
                tac.setClassName('monaco-editor-background textAreaCover');
            }
        }
    };
    return TextAreaHandler;
}(ViewPart));
function measureText(text, fontInfo) {
    // adjust width by its size
    var canvasElem = document.createElement('canvas');
    var context = canvasElem.getContext('2d');
    context.font = createFontString(fontInfo);
    var metrics = context.measureText(text);
    if (isFirefox) {
        return metrics.width + 2; // +2 for Japanese...
    }
    else {
        return metrics.width;
    }
}
function createFontString(bareFontInfo) {
    return doCreateFontString('normal', bareFontInfo.fontWeight, bareFontInfo.fontSize, bareFontInfo.lineHeight, bareFontInfo.fontFamily);
}
function doCreateFontString(fontStyle, fontWeight, fontSize, lineHeight, fontFamily) {
    // The full font syntax is:
    // style | variant | weight | stretch | size/line-height | fontFamily
    // (https://developer.mozilla.org/en-US/docs/Web/CSS/font)
    // But it appears Edge and IE11 cannot properly parse `stretch`.
    return fontStyle + " normal " + fontWeight + " " + fontSize + "px / " + lineHeight + "px " + fontFamily;
}

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
function memoize(target, key, descriptor) {
    var fnKey = null;
    var fn = null;
    if (typeof descriptor.value === 'function') {
        fnKey = 'value';
        fn = descriptor.value;
        if (fn.length !== 0) {
            console.warn('Memoize should only be used in functions with zero parameters');
        }
    }
    else if (typeof descriptor.get === 'function') {
        fnKey = 'get';
        fn = descriptor.get;
    }
    if (!fn) {
        throw new Error('not supported');
    }
    var memoizeKey = "$memoize$" + key;
    descriptor[fnKey] = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (!this.hasOwnProperty(memoizeKey)) {
            Object.defineProperty(this, memoizeKey, {
                configurable: false,
                enumerable: false,
                writable: false,
                value: fn.apply(this, args)
            });
        }
        return this[memoizeKey];
    };
}

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __decorate$2 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var EventType$1;
(function (EventType$$1) {
    EventType$$1.Tap = '-monaco-gesturetap';
    EventType$$1.Change = '-monaco-gesturechange';
    EventType$$1.Start = '-monaco-gesturestart';
    EventType$$1.End = '-monaco-gesturesend';
    EventType$$1.Contextmenu = '-monaco-gesturecontextmenu';
})(EventType$1 || (EventType$1 = {}));
var Gesture = /** @class */ (function () {
    function Gesture() {
        var _this = this;
        this.toDispose = [];
        this.activeTouches = {};
        this.handle = null;
        this.targets = [];
        this.toDispose.push(addDisposableListener(document, 'touchstart', function (e) { return _this.onTouchStart(e); }));
        this.toDispose.push(addDisposableListener(document, 'touchend', function (e) { return _this.onTouchEnd(e); }));
        this.toDispose.push(addDisposableListener(document, 'touchmove', function (e) { return _this.onTouchMove(e); }));
    }
    Gesture.addTarget = function (element) {
        if (!Gesture.isTouchDevice()) {
            return;
        }
        if (!Gesture.INSTANCE) {
            Gesture.INSTANCE = new Gesture();
        }
        Gesture.INSTANCE.targets.push(element);
    };
    Gesture.isTouchDevice = function () {
        return 'ontouchstart' in window || navigator.maxTouchPoints > 0 || window.navigator.msMaxTouchPoints > 0;
    };
    Gesture.prototype.dispose = function () {
        if (this.handle) {
            this.handle.dispose();
            dispose(this.toDispose);
            this.handle = null;
        }
    };
    Gesture.prototype.onTouchStart = function (e) {
        var timestamp = Date.now(); // use Date.now() because on FF e.timeStamp is not epoch based.
        if (this.handle) {
            this.handle.dispose();
            this.handle = null;
        }
        for (var i = 0, len = e.targetTouches.length; i < len; i++) {
            var touch = e.targetTouches.item(i);
            this.activeTouches[touch.identifier] = {
                id: touch.identifier,
                initialTarget: touch.target,
                initialTimeStamp: timestamp,
                initialPageX: touch.pageX,
                initialPageY: touch.pageY,
                rollingTimestamps: [timestamp],
                rollingPageX: [touch.pageX],
                rollingPageY: [touch.pageY]
            };
            var evt = this.newGestureEvent(EventType$1.Start, touch.target);
            evt.pageX = touch.pageX;
            evt.pageY = touch.pageY;
            this.dispatchEvent(evt);
        }
        if (this.dispatched) {
            e.preventDefault();
            e.stopPropagation();
            this.dispatched = false;
        }
    };
    Gesture.prototype.onTouchEnd = function (e) {
        var timestamp = Date.now(); // use Date.now() because on FF e.timeStamp is not epoch based.
        var activeTouchCount = Object.keys(this.activeTouches).length;
        var _loop_1 = function (i, len) {
            var touch = e.changedTouches.item(i);
            if (!this_1.activeTouches.hasOwnProperty(String(touch.identifier))) {
                console.warn('move of an UNKNOWN touch', touch);
                return "continue";
            }
            var data = this_1.activeTouches[touch.identifier], holdTime = Date.now() - data.initialTimeStamp;
            if (holdTime < Gesture.HOLD_DELAY
                && Math.abs(data.initialPageX - tail(data.rollingPageX)) < 30
                && Math.abs(data.initialPageY - tail(data.rollingPageY)) < 30) {
                var evt = this_1.newGestureEvent(EventType$1.Tap, data.initialTarget);
                evt.pageX = tail(data.rollingPageX);
                evt.pageY = tail(data.rollingPageY);
                this_1.dispatchEvent(evt);
            }
            else if (holdTime >= Gesture.HOLD_DELAY
                && Math.abs(data.initialPageX - tail(data.rollingPageX)) < 30
                && Math.abs(data.initialPageY - tail(data.rollingPageY)) < 30) {
                var evt = this_1.newGestureEvent(EventType$1.Contextmenu, data.initialTarget);
                evt.pageX = tail(data.rollingPageX);
                evt.pageY = tail(data.rollingPageY);
                this_1.dispatchEvent(evt);
            }
            else if (activeTouchCount === 1) {
                var finalX = tail(data.rollingPageX);
                var finalY = tail(data.rollingPageY);
                var deltaT = tail(data.rollingTimestamps) - data.rollingTimestamps[0];
                var deltaX = finalX - data.rollingPageX[0];
                var deltaY = finalY - data.rollingPageY[0];
                // We need to get all the dispatch targets on the start of the inertia event
                var dispatchTo = this_1.targets.filter(function (t) { return data.initialTarget instanceof Node && t.contains(data.initialTarget); });
                this_1.inertia(dispatchTo, timestamp, // time now
                Math.abs(deltaX) / deltaT, // speed
                deltaX > 0 ? 1 : -1, // x direction
                finalX, // x now
                Math.abs(deltaY) / deltaT, // y speed
                deltaY > 0 ? 1 : -1, // y direction
                finalY // y now
                );
            }
            this_1.dispatchEvent(this_1.newGestureEvent(EventType$1.End, data.initialTarget));
            // forget about this touch
            delete this_1.activeTouches[touch.identifier];
        };
        var this_1 = this;
        for (var i = 0, len = e.changedTouches.length; i < len; i++) {
            _loop_1(i, len);
        }
        if (this.dispatched) {
            e.preventDefault();
            e.stopPropagation();
            this.dispatched = false;
        }
    };
    Gesture.prototype.newGestureEvent = function (type, intialTarget) {
        var event = document.createEvent('CustomEvent');
        event.initEvent(type, false, true);
        event.initialTarget = intialTarget;
        return event;
    };
    Gesture.prototype.dispatchEvent = function (event) {
        var _this = this;
        this.targets.forEach(function (target) {
            if (event.initialTarget instanceof Node && target.contains(event.initialTarget)) {
                target.dispatchEvent(event);
                _this.dispatched = true;
            }
        });
    };
    Gesture.prototype.inertia = function (dispatchTo, t1, vX, dirX, x, vY, dirY, y) {
        var _this = this;
        this.handle = scheduleAtNextAnimationFrame(function () {
            var now = Date.now();
            // velocity: old speed + accel_over_time
            var deltaT = now - t1, delta_pos_x = 0, delta_pos_y = 0, stopped = true;
            vX += Gesture.SCROLL_FRICTION * deltaT;
            vY += Gesture.SCROLL_FRICTION * deltaT;
            if (vX > 0) {
                stopped = false;
                delta_pos_x = dirX * vX * deltaT;
            }
            if (vY > 0) {
                stopped = false;
                delta_pos_y = dirY * vY * deltaT;
            }
            // dispatch translation event
            var evt = _this.newGestureEvent(EventType$1.Change);
            evt.translationX = delta_pos_x;
            evt.translationY = delta_pos_y;
            dispatchTo.forEach(function (d) { return d.dispatchEvent(evt); });
            if (!stopped) {
                _this.inertia(dispatchTo, now, vX, dirX, x + delta_pos_x, vY, dirY, y + delta_pos_y);
            }
        });
    };
    Gesture.prototype.onTouchMove = function (e) {
        var timestamp = Date.now(); // use Date.now() because on FF e.timeStamp is not epoch based.
        for (var i = 0, len = e.changedTouches.length; i < len; i++) {
            var touch = e.changedTouches.item(i);
            if (!this.activeTouches.hasOwnProperty(String(touch.identifier))) {
                console.warn('end of an UNKNOWN touch', touch);
                continue;
            }
            var data = this.activeTouches[touch.identifier];
            var evt = this.newGestureEvent(EventType$1.Change, data.initialTarget);
            evt.translationX = touch.pageX - tail(data.rollingPageX);
            evt.translationY = touch.pageY - tail(data.rollingPageY);
            evt.pageX = touch.pageX;
            evt.pageY = touch.pageY;
            this.dispatchEvent(evt);
            // only keep a few data points, to average the final speed
            if (data.rollingPageX.length > 3) {
                data.rollingPageX.shift();
                data.rollingPageY.shift();
                data.rollingTimestamps.shift();
            }
            data.rollingPageX.push(touch.pageX);
            data.rollingPageY.push(touch.pageY);
            data.rollingTimestamps.push(timestamp);
        }
        if (this.dispatched) {
            e.preventDefault();
            e.stopPropagation();
            this.dispatched = false;
        }
    };
    Gesture.SCROLL_FRICTION = -0.005;
    Gesture.HOLD_DELAY = 700;
    __decorate$2([
        memoize
    ], Gesture, "isTouchDevice", null);
    return Gesture;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$t = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
function standardMouseMoveMerger(lastEvent, currentEvent) {
    var ev = new StandardMouseEvent(currentEvent);
    ev.preventDefault();
    return {
        leftButton: ev.leftButton,
        posx: ev.posx,
        posy: ev.posy
    };
}
var GlobalMouseMoveMonitor = /** @class */ (function (_super) {
    __extends$t(GlobalMouseMoveMonitor, _super);
    function GlobalMouseMoveMonitor() {
        var _this = _super.call(this) || this;
        _this.hooks = [];
        _this.mouseMoveEventMerger = null;
        _this.mouseMoveCallback = null;
        _this.onStopCallback = null;
        return _this;
    }
    GlobalMouseMoveMonitor.prototype.dispose = function () {
        this.stopMonitoring(false);
        _super.prototype.dispose.call(this);
    };
    GlobalMouseMoveMonitor.prototype.stopMonitoring = function (invokeStopCallback) {
        if (!this.isMonitoring()) {
            // Not monitoring
            return;
        }
        // Unhook
        this.hooks = dispose(this.hooks);
        this.mouseMoveEventMerger = null;
        this.mouseMoveCallback = null;
        var onStopCallback = this.onStopCallback;
        this.onStopCallback = null;
        if (invokeStopCallback) {
            onStopCallback();
        }
    };
    GlobalMouseMoveMonitor.prototype.isMonitoring = function () {
        return this.hooks.length > 0;
    };
    GlobalMouseMoveMonitor.prototype.startMonitoring = function (mouseMoveEventMerger, mouseMoveCallback, onStopCallback) {
        var _this = this;
        if (this.isMonitoring()) {
            // I am already hooked
            return;
        }
        this.mouseMoveEventMerger = mouseMoveEventMerger;
        this.mouseMoveCallback = mouseMoveCallback;
        this.onStopCallback = onStopCallback;
        var windowChain = IframeUtils.getSameOriginWindowChain();
        for (var i = 0; i < windowChain.length; i++) {
            this.hooks.push(addDisposableThrottledListener(windowChain[i].window.document, 'mousemove', function (data) { return _this.mouseMoveCallback(data); }, function (lastEvent, currentEvent) { return _this.mouseMoveEventMerger(lastEvent, currentEvent); }));
            this.hooks.push(addDisposableListener(windowChain[i].window.document, 'mouseup', function (e) { return _this.stopMonitoring(true); }));
        }
        if (IframeUtils.hasDifferentOriginAncestor()) {
            var lastSameOriginAncestor = windowChain[windowChain.length - 1];
            // We might miss a mouse up if it happens outside the iframe
            // This one is for Chrome
            this.hooks.push(addDisposableListener(lastSameOriginAncestor.window.document, 'mouseout', function (browserEvent) {
                var e = new StandardMouseEvent(browserEvent);
                if (e.target.tagName.toLowerCase() === 'html') {
                    _this.stopMonitoring(true);
                }
            }));
            // This one is for FF
            this.hooks.push(addDisposableListener(lastSameOriginAncestor.window.document, 'mouseover', function (browserEvent) {
                var e = new StandardMouseEvent(browserEvent);
                if (e.target.tagName.toLowerCase() === 'html') {
                    _this.stopMonitoring(true);
                }
            }));
            // This one is for IE
            this.hooks.push(addDisposableListener(lastSameOriginAncestor.window.document.body, 'mouseleave', function (browserEvent) {
                _this.stopMonitoring(true);
            }));
        }
    };
    return GlobalMouseMoveMonitor;
}(Disposable));

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$u = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * Coordinates relative to the whole document (e.g. mouse event's pageX and pageY)
 */
var PageCoordinates = /** @class */ (function () {
    function PageCoordinates(x, y) {
        this.x = x;
        this.y = y;
    }
    PageCoordinates.prototype.toClientCoordinates = function () {
        return new ClientCoordinates(this.x - StandardWindow.scrollX, this.y - StandardWindow.scrollY);
    };
    return PageCoordinates;
}());
/**
 * Coordinates within the application's client area (i.e. origin is document's scroll position).
 *
 * For example, clicking in the top-left corner of the client area will
 * always result in a mouse event with a client.x value of 0, regardless
 * of whether the page is scrolled horizontally.
 */
var ClientCoordinates = /** @class */ (function () {
    function ClientCoordinates(clientX, clientY) {
        this.clientX = clientX;
        this.clientY = clientY;
    }
    ClientCoordinates.prototype.toPageCoordinates = function () {
        return new PageCoordinates(this.clientX + StandardWindow.scrollX, this.clientY + StandardWindow.scrollY);
    };
    return ClientCoordinates;
}());
/**
 * The position of the editor in the page.
 */
var EditorPagePosition = /** @class */ (function () {
    function EditorPagePosition(x, y, width, height) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
    }
    return EditorPagePosition;
}());
function createEditorPagePosition(editorViewDomNode) {
    var editorPos = getDomNodePagePosition(editorViewDomNode);
    return new EditorPagePosition(editorPos.left, editorPos.top, editorPos.width, editorPos.height);
}
var EditorMouseEvent = /** @class */ (function (_super) {
    __extends$u(EditorMouseEvent, _super);
    function EditorMouseEvent(e, editorViewDomNode) {
        var _this = _super.call(this, e) || this;
        _this.pos = new PageCoordinates(_this.posx, _this.posy);
        _this.editorPos = createEditorPagePosition(editorViewDomNode);
        return _this;
    }
    return EditorMouseEvent;
}(StandardMouseEvent));
var EditorMouseEventFactory = /** @class */ (function () {
    function EditorMouseEventFactory(editorViewDomNode) {
        this._editorViewDomNode = editorViewDomNode;
    }
    EditorMouseEventFactory.prototype._create = function (e) {
        return new EditorMouseEvent(e, this._editorViewDomNode);
    };
    EditorMouseEventFactory.prototype.onContextMenu = function (target, callback) {
        var _this = this;
        return addDisposableListener(target, 'contextmenu', function (e) {
            callback(_this._create(e));
        });
    };
    EditorMouseEventFactory.prototype.onMouseUp = function (target, callback) {
        var _this = this;
        return addDisposableListener(target, 'mouseup', function (e) {
            callback(_this._create(e));
        });
    };
    EditorMouseEventFactory.prototype.onMouseDown = function (target, callback) {
        var _this = this;
        return addDisposableListener(target, 'mousedown', function (e) {
            callback(_this._create(e));
        });
    };
    EditorMouseEventFactory.prototype.onMouseLeave = function (target, callback) {
        var _this = this;
        return addDisposableNonBubblingMouseOutListener(target, function (e) {
            callback(_this._create(e));
        });
    };
    EditorMouseEventFactory.prototype.onMouseMoveThrottled = function (target, callback, merger, minimumTimeMs) {
        var _this = this;
        var myMerger = function (lastEvent, currentEvent) {
            return merger(lastEvent, _this._create(currentEvent));
        };
        return addDisposableThrottledListener(target, 'mousemove', callback, myMerger, minimumTimeMs);
    };
    return EditorMouseEventFactory;
}());
var GlobalEditorMouseMoveMonitor = /** @class */ (function (_super) {
    __extends$u(GlobalEditorMouseMoveMonitor, _super);
    function GlobalEditorMouseMoveMonitor(editorViewDomNode) {
        var _this = _super.call(this) || this;
        _this._editorViewDomNode = editorViewDomNode;
        _this._globalMouseMoveMonitor = _this._register(new GlobalMouseMoveMonitor());
        _this._keydownListener = null;
        return _this;
    }
    GlobalEditorMouseMoveMonitor.prototype.startMonitoring = function (merger, mouseMoveCallback, onStopCallback) {
        var _this = this;
        // Add a <<capture>> keydown event listener that will cancel the monitoring
        // if something other than a modifier key is pressed
        this._keydownListener = addStandardDisposableListener(document, 'keydown', function (e) {
            var kb = e.toKeybinding();
            if (kb.isModifierKey()) {
                // Allow modifier keys
                return;
            }
            _this._globalMouseMoveMonitor.stopMonitoring(true);
        }, true);
        var myMerger = function (lastEvent, currentEvent) {
            return merger(lastEvent, new EditorMouseEvent(currentEvent, _this._editorViewDomNode));
        };
        this._globalMouseMoveMonitor.startMonitoring(myMerger, mouseMoveCallback, function () {
            _this._keydownListener.dispose();
            onStopCallback();
        });
    };
    return GlobalEditorMouseMoveMonitor;
}(Disposable));

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var LineDecoration = /** @class */ (function () {
    function LineDecoration(startColumn, endColumn, className, type) {
        this.startColumn = startColumn;
        this.endColumn = endColumn;
        this.className = className;
        this.type = type;
    }
    LineDecoration._equals = function (a, b) {
        return (a.startColumn === b.startColumn
            && a.endColumn === b.endColumn
            && a.className === b.className
            && a.type === b.type);
    };
    LineDecoration.equalsArr = function (a, b) {
        var aLen = a.length;
        var bLen = b.length;
        if (aLen !== bLen) {
            return false;
        }
        for (var i = 0; i < aLen; i++) {
            if (!LineDecoration._equals(a[i], b[i])) {
                return false;
            }
        }
        return true;
    };
    LineDecoration.filter = function (lineDecorations, lineNumber, minLineColumn, maxLineColumn) {
        if (lineDecorations.length === 0) {
            return [];
        }
        var result = [], resultLen = 0;
        for (var i = 0, len = lineDecorations.length; i < len; i++) {
            var d = lineDecorations[i];
            var range = d.range;
            if (range.endLineNumber < lineNumber || range.startLineNumber > lineNumber) {
                // Ignore decorations that sit outside this line
                continue;
            }
            if (range.isEmpty() && (d.type === 0 /* Regular */ || d.type === 3 /* RegularAffectingLetterSpacing */)) {
                // Ignore empty range decorations
                continue;
            }
            var startColumn = (range.startLineNumber === lineNumber ? range.startColumn : minLineColumn);
            var endColumn = (range.endLineNumber === lineNumber ? range.endColumn : maxLineColumn);
            result[resultLen++] = new LineDecoration(startColumn, endColumn, d.inlineClassName, d.type);
        }
        return result;
    };
    LineDecoration.compare = function (a, b) {
        if (a.startColumn === b.startColumn) {
            if (a.endColumn === b.endColumn) {
                if (a.className < b.className) {
                    return -1;
                }
                if (a.className > b.className) {
                    return 1;
                }
                return 0;
            }
            return a.endColumn - b.endColumn;
        }
        return a.startColumn - b.startColumn;
    };
    return LineDecoration;
}());
var DecorationSegment = /** @class */ (function () {
    function DecorationSegment(startOffset, endOffset, className) {
        this.startOffset = startOffset;
        this.endOffset = endOffset;
        this.className = className;
    }
    return DecorationSegment;
}());
var Stack = /** @class */ (function () {
    function Stack() {
        this.stopOffsets = [];
        this.classNames = [];
        this.count = 0;
    }
    Stack.prototype.consumeLowerThan = function (maxStopOffset, nextStartOffset, result) {
        while (this.count > 0 && this.stopOffsets[0] < maxStopOffset) {
            var i = 0;
            // Take all equal stopping offsets
            while (i + 1 < this.count && this.stopOffsets[i] === this.stopOffsets[i + 1]) {
                i++;
            }
            // Basically we are consuming the first i + 1 elements of the stack
            result.push(new DecorationSegment(nextStartOffset, this.stopOffsets[i], this.classNames.join(' ')));
            nextStartOffset = this.stopOffsets[i] + 1;
            // Consume them
            this.stopOffsets.splice(0, i + 1);
            this.classNames.splice(0, i + 1);
            this.count -= (i + 1);
        }
        if (this.count > 0 && nextStartOffset < maxStopOffset) {
            result.push(new DecorationSegment(nextStartOffset, maxStopOffset - 1, this.classNames.join(' ')));
            nextStartOffset = maxStopOffset;
        }
        return nextStartOffset;
    };
    Stack.prototype.insert = function (stopOffset, className) {
        if (this.count === 0 || this.stopOffsets[this.count - 1] <= stopOffset) {
            // Insert at the end
            this.stopOffsets.push(stopOffset);
            this.classNames.push(className);
        }
        else {
            // Find the insertion position for `stopOffset`
            for (var i = 0; i < this.count; i++) {
                if (this.stopOffsets[i] >= stopOffset) {
                    this.stopOffsets.splice(i, 0, stopOffset);
                    this.classNames.splice(i, 0, className);
                    break;
                }
            }
        }
        this.count++;
        return;
    };
    return Stack;
}());
var LineDecorationsNormalizer = /** @class */ (function () {
    function LineDecorationsNormalizer() {
    }
    /**
     * Normalize line decorations. Overlapping decorations will generate multiple segments
     */
    LineDecorationsNormalizer.normalize = function (lineContent, lineDecorations) {
        if (lineDecorations.length === 0) {
            return [];
        }
        var result = [];
        var stack = new Stack();
        var nextStartOffset = 0;
        for (var i = 0, len = lineDecorations.length; i < len; i++) {
            var d = lineDecorations[i];
            var startColumn = d.startColumn;
            var endColumn = d.endColumn;
            var className = d.className;
            // If the position would end up in the middle of a high-low surrogate pair, we move it to before the pair
            if (startColumn > 1) {
                var charCodeBefore = lineContent.charCodeAt(startColumn - 2);
                if (isHighSurrogate(charCodeBefore)) {
                    startColumn--;
                }
            }
            if (endColumn > 1) {
                var charCodeBefore = lineContent.charCodeAt(endColumn - 2);
                if (isHighSurrogate(charCodeBefore)) {
                    endColumn--;
                }
            }
            var currentStartOffset = startColumn - 1;
            var currentEndOffset = endColumn - 2;
            nextStartOffset = stack.consumeLowerThan(currentStartOffset, nextStartOffset, result);
            if (stack.count === 0) {
                nextStartOffset = currentStartOffset;
            }
            stack.insert(currentEndOffset, className);
        }
        stack.consumeLowerThan(1073741824 /* MAX_SAFE_SMALL_INTEGER */, nextStartOffset, result);
        return result;
    };
    return LineDecorationsNormalizer;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var createStringBuilder;
if (typeof TextDecoder !== 'undefined') {
    createStringBuilder = function (capacity) { return new StringBuilder(capacity); };
}
else {
    createStringBuilder = function (capacity) { return new CompatStringBuilder(); };
}
var StringBuilder = /** @class */ (function () {
    function StringBuilder(capacity) {
        this._decoder = new TextDecoder('UTF-16LE');
        this._capacity = capacity | 0;
        this._buffer = new Uint16Array(this._capacity);
        this._completedStrings = null;
        this._bufferLength = 0;
    }
    StringBuilder.prototype.reset = function () {
        this._completedStrings = null;
        this._bufferLength = 0;
    };
    StringBuilder.prototype.build = function () {
        if (this._completedStrings !== null) {
            this._flushBuffer();
            return this._completedStrings.join('');
        }
        return this._buildBuffer();
    };
    StringBuilder.prototype._buildBuffer = function () {
        if (this._bufferLength === 0) {
            return '';
        }
        var view = new Uint16Array(this._buffer.buffer, 0, this._bufferLength);
        return this._decoder.decode(view);
    };
    StringBuilder.prototype._flushBuffer = function () {
        var bufferString = this._buildBuffer();
        this._bufferLength = 0;
        if (this._completedStrings === null) {
            this._completedStrings = [bufferString];
        }
        else {
            this._completedStrings[this._completedStrings.length] = bufferString;
        }
    };
    StringBuilder.prototype.write1 = function (charCode) {
        var remainingSpace = this._capacity - this._bufferLength;
        if (remainingSpace <= 1) {
            if (remainingSpace === 0 || isHighSurrogate(charCode)) {
                this._flushBuffer();
            }
        }
        this._buffer[this._bufferLength++] = charCode;
    };
    StringBuilder.prototype.appendASCII = function (charCode) {
        if (this._bufferLength === this._capacity) {
            // buffer is full
            this._flushBuffer();
        }
        this._buffer[this._bufferLength++] = charCode;
    };
    StringBuilder.prototype.appendASCIIString = function (str) {
        var strLen = str.length;
        if (this._bufferLength + strLen >= this._capacity) {
            // This string does not fit in the remaining buffer space
            this._flushBuffer();
            this._completedStrings[this._completedStrings.length] = str;
            return;
        }
        for (var i = 0; i < strLen; i++) {
            this._buffer[this._bufferLength++] = str.charCodeAt(i);
        }
    };
    return StringBuilder;
}());
var CompatStringBuilder = /** @class */ (function () {
    function CompatStringBuilder() {
        this._pieces = [];
        this._piecesLen = 0;
    }
    CompatStringBuilder.prototype.reset = function () {
        this._pieces = [];
        this._piecesLen = 0;
    };
    CompatStringBuilder.prototype.build = function () {
        return this._pieces.join('');
    };
    CompatStringBuilder.prototype.write1 = function (charCode) {
        this._pieces[this._piecesLen++] = String.fromCharCode(charCode);
    };
    CompatStringBuilder.prototype.appendASCII = function (charCode) {
        this._pieces[this._piecesLen++] = String.fromCharCode(charCode);
    };
    CompatStringBuilder.prototype.appendASCIIString = function (str) {
        this._pieces[this._piecesLen++] = str;
    };
    return CompatStringBuilder;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var LinePart = /** @class */ (function () {
    function LinePart(endIndex, type) {
        this.endIndex = endIndex;
        this.type = type;
    }
    return LinePart;
}());
var RenderLineInput = /** @class */ (function () {
    function RenderLineInput(useMonospaceOptimizations, lineContent, isBasicASCII$$1, containsRTL$$1, fauxIndentLength, lineTokens, lineDecorations, tabSize, spaceWidth, stopRenderingLineAfter, renderWhitespace, renderControlCharacters, fontLigatures) {
        this.useMonospaceOptimizations = useMonospaceOptimizations;
        this.lineContent = lineContent;
        this.isBasicASCII = isBasicASCII$$1;
        this.containsRTL = containsRTL$$1;
        this.fauxIndentLength = fauxIndentLength;
        this.lineTokens = lineTokens;
        this.lineDecorations = lineDecorations;
        this.tabSize = tabSize;
        this.spaceWidth = spaceWidth;
        this.stopRenderingLineAfter = stopRenderingLineAfter;
        this.renderWhitespace = (renderWhitespace === 'all'
            ? 2 /* All */
            : renderWhitespace === 'boundary'
                ? 1 /* Boundary */
                : 0 /* None */);
        this.renderControlCharacters = renderControlCharacters;
        this.fontLigatures = fontLigatures;
    }
    RenderLineInput.prototype.equals = function (other) {
        return (this.useMonospaceOptimizations === other.useMonospaceOptimizations
            && this.lineContent === other.lineContent
            && this.isBasicASCII === other.isBasicASCII
            && this.containsRTL === other.containsRTL
            && this.fauxIndentLength === other.fauxIndentLength
            && this.tabSize === other.tabSize
            && this.spaceWidth === other.spaceWidth
            && this.stopRenderingLineAfter === other.stopRenderingLineAfter
            && this.renderWhitespace === other.renderWhitespace
            && this.renderControlCharacters === other.renderControlCharacters
            && this.fontLigatures === other.fontLigatures
            && LineDecoration.equalsArr(this.lineDecorations, other.lineDecorations)
            && this.lineTokens.equals(other.lineTokens));
    };
    return RenderLineInput;
}());
/**
 * Provides a both direction mapping between a line's character and its rendered position.
 */
var CharacterMapping = /** @class */ (function () {
    function CharacterMapping(length, partCount) {
        this.length = length;
        this._data = new Uint32Array(this.length);
        this._absoluteOffsets = new Uint32Array(this.length);
    }
    CharacterMapping.getPartIndex = function (partData) {
        return (partData & 4294901760 /* PART_INDEX_MASK */) >>> 16 /* PART_INDEX_OFFSET */;
    };
    CharacterMapping.getCharIndex = function (partData) {
        return (partData & 65535 /* CHAR_INDEX_MASK */) >>> 0 /* CHAR_INDEX_OFFSET */;
    };
    CharacterMapping.prototype.setPartData = function (charOffset, partIndex, charIndex, partAbsoluteOffset) {
        var partData = ((partIndex << 16 /* PART_INDEX_OFFSET */)
            | (charIndex << 0 /* CHAR_INDEX_OFFSET */)) >>> 0;
        this._data[charOffset] = partData;
        this._absoluteOffsets[charOffset] = partAbsoluteOffset + charIndex;
    };
    CharacterMapping.prototype.getAbsoluteOffsets = function () {
        return this._absoluteOffsets;
    };
    CharacterMapping.prototype.charOffsetToPartData = function (charOffset) {
        if (this.length === 0) {
            return 0;
        }
        if (charOffset < 0) {
            return this._data[0];
        }
        if (charOffset >= this.length) {
            return this._data[this.length - 1];
        }
        return this._data[charOffset];
    };
    CharacterMapping.prototype.partDataToCharOffset = function (partIndex, partLength, charIndex) {
        if (this.length === 0) {
            return 0;
        }
        var searchEntry = ((partIndex << 16 /* PART_INDEX_OFFSET */)
            | (charIndex << 0 /* CHAR_INDEX_OFFSET */)) >>> 0;
        var min = 0;
        var max = this.length - 1;
        while (min + 1 < max) {
            var mid = ((min + max) >>> 1);
            var midEntry = this._data[mid];
            if (midEntry === searchEntry) {
                return mid;
            }
            else if (midEntry > searchEntry) {
                max = mid;
            }
            else {
                min = mid;
            }
        }
        if (min === max) {
            return min;
        }
        var minEntry = this._data[min];
        var maxEntry = this._data[max];
        if (minEntry === searchEntry) {
            return min;
        }
        if (maxEntry === searchEntry) {
            return max;
        }
        var minPartIndex = CharacterMapping.getPartIndex(minEntry);
        var minCharIndex = CharacterMapping.getCharIndex(minEntry);
        var maxPartIndex = CharacterMapping.getPartIndex(maxEntry);
        var maxCharIndex;
        if (minPartIndex !== maxPartIndex) {
            // sitting between parts
            maxCharIndex = partLength;
        }
        else {
            maxCharIndex = CharacterMapping.getCharIndex(maxEntry);
        }
        var minEntryDistance = charIndex - minCharIndex;
        var maxEntryDistance = maxCharIndex - charIndex;
        if (minEntryDistance <= maxEntryDistance) {
            return min;
        }
        return max;
    };
    return CharacterMapping;
}());
var RenderLineOutput = /** @class */ (function () {
    function RenderLineOutput(characterMapping, containsRTL$$1, containsForeignElements) {
        this.characterMapping = characterMapping;
        this.containsRTL = containsRTL$$1;
        this.containsForeignElements = containsForeignElements;
    }
    return RenderLineOutput;
}());
function renderViewLine(input, sb) {
    if (input.lineContent.length === 0) {
        var containsForeignElements = 0 /* None */;
        // This is basically for IE's hit test to work
        var content = '<span><span>\u00a0</span></span>';
        if (input.lineDecorations.length > 0) {
            // This line is empty, but it contains inline decorations
            var classNames = [];
            for (var i = 0, len = input.lineDecorations.length; i < len; i++) {
                var lineDecoration = input.lineDecorations[i];
                if (lineDecoration.type === 1 /* Before */) {
                    classNames.push(input.lineDecorations[i].className);
                    containsForeignElements |= 1 /* Before */;
                }
                if (lineDecoration.type === 2 /* After */) {
                    classNames.push(input.lineDecorations[i].className);
                    containsForeignElements |= 2 /* After */;
                }
            }
            if (containsForeignElements !== 0 /* None */) {
                content = "<span><span class=\"" + classNames.join(' ') + "\"></span></span>";
            }
        }
        sb.appendASCIIString(content);
        return new RenderLineOutput(new CharacterMapping(0, 0), false, containsForeignElements);
    }
    return _renderLine(resolveRenderLineInput(input), sb);
}
var RenderLineOutput2 = /** @class */ (function () {
    function RenderLineOutput2(characterMapping, html, containsRTL$$1, containsForeignElements) {
        this.characterMapping = characterMapping;
        this.html = html;
        this.containsRTL = containsRTL$$1;
        this.containsForeignElements = containsForeignElements;
    }
    return RenderLineOutput2;
}());
function renderViewLine2(input) {
    var sb = createStringBuilder(10000);
    var out = renderViewLine(input, sb);
    return new RenderLineOutput2(out.characterMapping, sb.build(), out.containsRTL, out.containsForeignElements);
}
var ResolvedRenderLineInput = /** @class */ (function () {
    function ResolvedRenderLineInput(fontIsMonospace, lineContent, len, isOverflowing, parts, containsForeignElements, tabSize, containsRTL$$1, spaceWidth, renderWhitespace, renderControlCharacters) {
        this.fontIsMonospace = fontIsMonospace;
        this.lineContent = lineContent;
        this.len = len;
        this.isOverflowing = isOverflowing;
        this.parts = parts;
        this.containsForeignElements = containsForeignElements;
        this.tabSize = tabSize;
        this.containsRTL = containsRTL$$1;
        this.spaceWidth = spaceWidth;
        this.renderWhitespace = renderWhitespace;
        this.renderControlCharacters = renderControlCharacters;
        //
    }
    return ResolvedRenderLineInput;
}());
function resolveRenderLineInput(input) {
    var useMonospaceOptimizations = input.useMonospaceOptimizations;
    var lineContent = input.lineContent;
    var isOverflowing;
    var len;
    if (input.stopRenderingLineAfter !== -1 && input.stopRenderingLineAfter < lineContent.length) {
        isOverflowing = true;
        len = input.stopRenderingLineAfter;
    }
    else {
        isOverflowing = false;
        len = lineContent.length;
    }
    var tokens = transformAndRemoveOverflowing(input.lineTokens, input.fauxIndentLength, len);
    if (input.renderWhitespace === 2 /* All */ || input.renderWhitespace === 1 /* Boundary */) {
        tokens = _applyRenderWhitespace(lineContent, len, tokens, input.fauxIndentLength, input.tabSize, useMonospaceOptimizations, input.renderWhitespace === 1 /* Boundary */);
    }
    var containsForeignElements = 0 /* None */;
    if (input.lineDecorations.length > 0) {
        for (var i = 0, len_1 = input.lineDecorations.length; i < len_1; i++) {
            var lineDecoration = input.lineDecorations[i];
            if (lineDecoration.type === 3 /* RegularAffectingLetterSpacing */) {
                // Pretend there are foreign elements... although not 100% accurate.
                containsForeignElements |= 1 /* Before */;
            }
            else if (lineDecoration.type === 1 /* Before */) {
                containsForeignElements |= 1 /* Before */;
            }
            else if (lineDecoration.type === 2 /* After */) {
                containsForeignElements |= 2 /* After */;
            }
        }
        tokens = _applyInlineDecorations(lineContent, len, tokens, input.lineDecorations);
    }
    if (input.isBasicASCII && !input.fontLigatures) {
        tokens = splitLargeTokens(lineContent, tokens);
    }
    return new ResolvedRenderLineInput(useMonospaceOptimizations, lineContent, len, isOverflowing, tokens, containsForeignElements, input.tabSize, input.containsRTL, input.spaceWidth, input.renderWhitespace, input.renderControlCharacters);
}
/**
 * In the rendering phase, characters are always looped until token.endIndex.
 * Ensure that all tokens end before `len` and the last one ends precisely at `len`.
 */
function transformAndRemoveOverflowing(tokens, fauxIndentLength, len) {
    var result = [], resultLen = 0;
    // The faux indent part of the line should have no token type
    if (fauxIndentLength > 0) {
        result[resultLen++] = new LinePart(fauxIndentLength, '');
    }
    for (var tokenIndex = 0, tokensLen = tokens.getCount(); tokenIndex < tokensLen; tokenIndex++) {
        var endIndex = tokens.getEndOffset(tokenIndex);
        if (endIndex <= fauxIndentLength) {
            // The faux indent part of the line should have no token type
            continue;
        }
        var type = tokens.getClassName(tokenIndex);
        if (endIndex >= len) {
            result[resultLen++] = new LinePart(len, type);
            break;
        }
        result[resultLen++] = new LinePart(endIndex, type);
    }
    return result;
}
/**
 * See https://github.com/Microsoft/vscode/issues/6885.
 * It appears that having very large spans causes very slow reading of character positions.
 * So here we try to avoid that.
 */
function splitLargeTokens(lineContent, tokens) {
    var lastTokenEndIndex = 0;
    var result = [], resultLen = 0;
    for (var i = 0, len = tokens.length; i < len; i++) {
        var token = tokens[i];
        var tokenEndIndex = token.endIndex;
        var diff = (tokenEndIndex - lastTokenEndIndex);
        if (diff > 50 /* LongToken */) {
            var tokenType = token.type;
            var piecesCount = Math.ceil(diff / 50 /* LongToken */);
            for (var j = 1; j < piecesCount; j++) {
                var pieceEndIndex = lastTokenEndIndex + (j * 50 /* LongToken */);
                result[resultLen++] = new LinePart(pieceEndIndex, tokenType);
            }
            result[resultLen++] = new LinePart(tokenEndIndex, tokenType);
        }
        else {
            result[resultLen++] = token;
        }
        lastTokenEndIndex = tokenEndIndex;
    }
    return result;
}
/**
 * Whitespace is rendered by "replacing" tokens with a special-purpose `vs-whitespace` type that is later recognized in the rendering phase.
 * Moreover, a token is created for every visual indent because on some fonts the glyphs used for rendering whitespace (&rarr; or &middot;) do not have the same width as &nbsp;.
 * The rendering phase will generate `style="width:..."` for these tokens.
 */
function _applyRenderWhitespace(lineContent, len, tokens, fauxIndentLength, tabSize, useMonospaceOptimizations, onlyBoundary) {
    var result = [], resultLen = 0;
    var tokenIndex = 0;
    var tokenType = tokens[tokenIndex].type;
    var tokenEndIndex = tokens[tokenIndex].endIndex;
    var firstNonWhitespaceIndex$$1 = firstNonWhitespaceIndex(lineContent);
    var lastNonWhitespaceIndex$$1;
    if (firstNonWhitespaceIndex$$1 === -1) {
        // The entire line is whitespace
        firstNonWhitespaceIndex$$1 = len;
        lastNonWhitespaceIndex$$1 = len;
    }
    else {
        lastNonWhitespaceIndex$$1 = lastNonWhitespaceIndex(lineContent);
    }
    var tmpIndent = 0;
    for (var charIndex = 0; charIndex < fauxIndentLength; charIndex++) {
        var chCode = lineContent.charCodeAt(charIndex);
        if (chCode === 9 /* Tab */) {
            tmpIndent = tabSize;
        }
        else if (isFullWidthCharacter(chCode)) {
            tmpIndent += 2;
        }
        else {
            tmpIndent++;
        }
    }
    tmpIndent = tmpIndent % tabSize;
    var wasInWhitespace = false;
    for (var charIndex = fauxIndentLength; charIndex < len; charIndex++) {
        var chCode = lineContent.charCodeAt(charIndex);
        var isInWhitespace = void 0;
        if (charIndex < firstNonWhitespaceIndex$$1 || charIndex > lastNonWhitespaceIndex$$1) {
            // in leading or trailing whitespace
            isInWhitespace = true;
        }
        else if (chCode === 9 /* Tab */) {
            // a tab character is rendered both in all and boundary cases
            isInWhitespace = true;
        }
        else if (chCode === 32 /* Space */) {
            // hit a space character
            if (onlyBoundary) {
                // rendering only boundary whitespace
                if (wasInWhitespace) {
                    isInWhitespace = true;
                }
                else {
                    var nextChCode = (charIndex + 1 < len ? lineContent.charCodeAt(charIndex + 1) : 0 /* Null */);
                    isInWhitespace = (nextChCode === 32 /* Space */ || nextChCode === 9 /* Tab */);
                }
            }
            else {
                isInWhitespace = true;
            }
        }
        else {
            isInWhitespace = false;
        }
        if (wasInWhitespace) {
            // was in whitespace token
            if (!isInWhitespace || (!useMonospaceOptimizations && tmpIndent >= tabSize)) {
                // leaving whitespace token or entering a new indent
                result[resultLen++] = new LinePart(charIndex, 'vs-whitespace');
                tmpIndent = tmpIndent % tabSize;
            }
        }
        else {
            // was in regular token
            if (charIndex === tokenEndIndex || (isInWhitespace && charIndex > fauxIndentLength)) {
                result[resultLen++] = new LinePart(charIndex, tokenType);
                tmpIndent = tmpIndent % tabSize;
            }
        }
        if (chCode === 9 /* Tab */) {
            tmpIndent = tabSize;
        }
        else if (isFullWidthCharacter(chCode)) {
            tmpIndent += 2;
        }
        else {
            tmpIndent++;
        }
        wasInWhitespace = isInWhitespace;
        if (charIndex === tokenEndIndex) {
            tokenIndex++;
            tokenType = tokens[tokenIndex].type;
            tokenEndIndex = tokens[tokenIndex].endIndex;
        }
    }
    if (wasInWhitespace) {
        // was in whitespace token
        result[resultLen++] = new LinePart(len, 'vs-whitespace');
    }
    else {
        // was in regular token
        result[resultLen++] = new LinePart(len, tokenType);
    }
    return result;
}
/**
 * Inline decorations are "merged" on top of tokens.
 * Special care must be taken when multiple inline decorations are at play and they overlap.
 */
function _applyInlineDecorations(lineContent, len, tokens, _lineDecorations) {
    _lineDecorations.sort(LineDecoration.compare);
    var lineDecorations = LineDecorationsNormalizer.normalize(lineContent, _lineDecorations);
    var lineDecorationsLen = lineDecorations.length;
    var lineDecorationIndex = 0;
    var result = [], resultLen = 0, lastResultEndIndex = 0;
    for (var tokenIndex = 0, len_2 = tokens.length; tokenIndex < len_2; tokenIndex++) {
        var token = tokens[tokenIndex];
        var tokenEndIndex = token.endIndex;
        var tokenType = token.type;
        while (lineDecorationIndex < lineDecorationsLen && lineDecorations[lineDecorationIndex].startOffset < tokenEndIndex) {
            var lineDecoration = lineDecorations[lineDecorationIndex];
            if (lineDecoration.startOffset > lastResultEndIndex) {
                lastResultEndIndex = lineDecoration.startOffset;
                result[resultLen++] = new LinePart(lastResultEndIndex, tokenType);
            }
            if (lineDecoration.endOffset + 1 <= tokenEndIndex) {
                // This line decoration ends before this token ends
                lastResultEndIndex = lineDecoration.endOffset + 1;
                result[resultLen++] = new LinePart(lastResultEndIndex, tokenType + ' ' + lineDecoration.className);
                lineDecorationIndex++;
            }
            else {
                // This line decoration continues on to the next token
                lastResultEndIndex = tokenEndIndex;
                result[resultLen++] = new LinePart(lastResultEndIndex, tokenType + ' ' + lineDecoration.className);
                break;
            }
        }
        if (tokenEndIndex > lastResultEndIndex) {
            lastResultEndIndex = tokenEndIndex;
            result[resultLen++] = new LinePart(lastResultEndIndex, tokenType);
        }
    }
    var lastTokenEndIndex = tokens[tokens.length - 1].endIndex;
    if (lineDecorationIndex < lineDecorationsLen && lineDecorations[lineDecorationIndex].startOffset === lastTokenEndIndex) {
        var classNames = [];
        while (lineDecorationIndex < lineDecorationsLen && lineDecorations[lineDecorationIndex].startOffset === lastTokenEndIndex) {
            classNames.push(lineDecorations[lineDecorationIndex].className);
            lineDecorationIndex++;
        }
        result[resultLen++] = new LinePart(lastResultEndIndex, classNames.join(' '));
    }
    return result;
}
/**
 * This function is on purpose not split up into multiple functions to allow runtime type inference (i.e. performance reasons).
 * Notice how all the needed data is fully resolved and passed in (i.e. no other calls).
 */
function _renderLine(input, sb) {
    var fontIsMonospace = input.fontIsMonospace;
    var containsForeignElements = input.containsForeignElements;
    var lineContent = input.lineContent;
    var len = input.len;
    var isOverflowing = input.isOverflowing;
    var parts = input.parts;
    var tabSize = input.tabSize;
    var containsRTL$$1 = input.containsRTL;
    var spaceWidth = input.spaceWidth;
    var renderWhitespace = input.renderWhitespace;
    var renderControlCharacters = input.renderControlCharacters;
    var characterMapping = new CharacterMapping(len + 1, parts.length);
    var charIndex = 0;
    var tabsCharDelta = 0;
    var charOffsetInPart = 0;
    var prevPartContentCnt = 0;
    var partAbsoluteOffset = 0;
    sb.appendASCIIString('<span>');
    for (var partIndex = 0, tokensLen = parts.length; partIndex < tokensLen; partIndex++) {
        partAbsoluteOffset += prevPartContentCnt;
        var part = parts[partIndex];
        var partEndIndex = part.endIndex;
        var partType = part.type;
        var partRendersWhitespace = (renderWhitespace !== 0 /* None */ && (partType.indexOf('vs-whitespace') >= 0));
        charOffsetInPart = 0;
        sb.appendASCIIString('<span class="');
        sb.appendASCIIString(partType);
        sb.appendASCII(34 /* DoubleQuote */);
        if (partRendersWhitespace) {
            var partContentCnt = 0;
            {
                var _charIndex = charIndex;
                var _tabsCharDelta = tabsCharDelta;
                for (; _charIndex < partEndIndex; _charIndex++) {
                    var charCode = lineContent.charCodeAt(_charIndex);
                    if (charCode === 9 /* Tab */) {
                        var insertSpacesCount = tabSize - (_charIndex + _tabsCharDelta) % tabSize;
                        _tabsCharDelta += insertSpacesCount - 1;
                        partContentCnt += insertSpacesCount;
                    }
                    else {
                        // must be CharCode.Space
                        partContentCnt++;
                    }
                }
            }
            if (!fontIsMonospace) {
                var partIsOnlyWhitespace = (partType === 'vs-whitespace');
                if (partIsOnlyWhitespace || !containsForeignElements) {
                    sb.appendASCIIString(' style="width:');
                    sb.appendASCIIString(String(spaceWidth * partContentCnt));
                    sb.appendASCIIString('px"');
                }
            }
            sb.appendASCII(62 /* GreaterThan */);
            for (; charIndex < partEndIndex; charIndex++) {
                characterMapping.setPartData(charIndex, partIndex, charOffsetInPart, partAbsoluteOffset);
                var charCode = lineContent.charCodeAt(charIndex);
                if (charCode === 9 /* Tab */) {
                    var insertSpacesCount = tabSize - (charIndex + tabsCharDelta) % tabSize;
                    tabsCharDelta += insertSpacesCount - 1;
                    charOffsetInPart += insertSpacesCount - 1;
                    if (insertSpacesCount > 0) {
                        sb.write1(0x2192); // &rarr;
                        insertSpacesCount--;
                    }
                    while (insertSpacesCount > 0) {
                        sb.write1(0xA0); // &nbsp;
                        insertSpacesCount--;
                    }
                }
                else {
                    // must be CharCode.Space
                    sb.write1(0xb7); // &middot;
                }
                charOffsetInPart++;
            }
            prevPartContentCnt = partContentCnt;
        }
        else {
            var partContentCnt = 0;
            if (containsRTL$$1) {
                sb.appendASCIIString(' dir="ltr"');
            }
            sb.appendASCII(62 /* GreaterThan */);
            for (; charIndex < partEndIndex; charIndex++) {
                characterMapping.setPartData(charIndex, partIndex, charOffsetInPart, partAbsoluteOffset);
                var charCode = lineContent.charCodeAt(charIndex);
                switch (charCode) {
                    case 9 /* Tab */:
                        var insertSpacesCount = tabSize - (charIndex + tabsCharDelta) % tabSize;
                        tabsCharDelta += insertSpacesCount - 1;
                        charOffsetInPart += insertSpacesCount - 1;
                        while (insertSpacesCount > 0) {
                            sb.write1(0xA0); // &nbsp;
                            partContentCnt++;
                            insertSpacesCount--;
                        }
                        break;
                    case 32 /* Space */:
                        sb.write1(0xA0); // &nbsp;
                        partContentCnt++;
                        break;
                    case 60 /* LessThan */:
                        sb.appendASCIIString('&lt;');
                        partContentCnt++;
                        break;
                    case 62 /* GreaterThan */:
                        sb.appendASCIIString('&gt;');
                        partContentCnt++;
                        break;
                    case 38 /* Ampersand */:
                        sb.appendASCIIString('&amp;');
                        partContentCnt++;
                        break;
                    case 0 /* Null */:
                        sb.appendASCIIString('&#00;');
                        partContentCnt++;
                        break;
                    case 65279 /* UTF8_BOM */:
                    case 8232 /* LINE_SEPARATOR_2028 */:
                        sb.write1(0xfffd);
                        partContentCnt++;
                        break;
                    default:
                        if (isFullWidthCharacter(charCode)) {
                            tabsCharDelta++;
                        }
                        if (renderControlCharacters && charCode < 32) {
                            sb.write1(9216 + charCode);
                            partContentCnt++;
                        }
                        else {
                            sb.write1(charCode);
                            partContentCnt++;
                        }
                }
                charOffsetInPart++;
            }
            prevPartContentCnt = partContentCnt;
        }
        sb.appendASCIIString('</span>');
    }
    // When getting client rects for the last character, we will position the
    // text range at the end of the span, insteaf of at the beginning of next span
    characterMapping.setPartData(len, parts.length - 1, charOffsetInPart, partAbsoluteOffset);
    if (isOverflowing) {
        sb.appendASCIIString('<span>&hellip;</span>');
    }
    sb.appendASCIIString('</span>');
    return new RenderLineOutput(characterMapping, containsRTL$$1, containsForeignElements);
}

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$v = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var RestrictedRenderingContext = /** @class */ (function () {
    function RestrictedRenderingContext(viewLayout, viewportData) {
        this._viewLayout = viewLayout;
        this.viewportData = viewportData;
        this.scrollWidth = this._viewLayout.getScrollWidth();
        this.scrollHeight = this._viewLayout.getScrollHeight();
        this.visibleRange = this.viewportData.visibleRange;
        this.bigNumbersDelta = this.viewportData.bigNumbersDelta;
        var vInfo = this._viewLayout.getCurrentViewport();
        this.scrollTop = vInfo.top;
        this.scrollLeft = vInfo.left;
        this.viewportWidth = vInfo.width;
        this.viewportHeight = vInfo.height;
    }
    RestrictedRenderingContext.prototype.getScrolledTopFromAbsoluteTop = function (absoluteTop) {
        return absoluteTop - this.scrollTop;
    };
    RestrictedRenderingContext.prototype.getVerticalOffsetForLineNumber = function (lineNumber) {
        return this._viewLayout.getVerticalOffsetForLineNumber(lineNumber);
    };
    RestrictedRenderingContext.prototype.getDecorationsInViewport = function () {
        return this.viewportData.getDecorationsInViewport();
    };
    return RestrictedRenderingContext;
}());
var RenderingContext = /** @class */ (function (_super) {
    __extends$v(RenderingContext, _super);
    function RenderingContext(viewLayout, viewportData, viewLines) {
        var _this = _super.call(this, viewLayout, viewportData) || this;
        _this._viewLines = viewLines;
        return _this;
    }
    RenderingContext.prototype.linesVisibleRangesForRange = function (range, includeNewLines) {
        return this._viewLines.linesVisibleRangesForRange(range, includeNewLines);
    };
    RenderingContext.prototype.visibleRangeForPosition = function (position) {
        var visibleRanges = this._viewLines.visibleRangesForRange2(new Range(position.lineNumber, position.column, position.lineNumber, position.column));
        if (!visibleRanges) {
            return null;
        }
        return visibleRanges[0];
    };
    return RenderingContext;
}(RestrictedRenderingContext));
var LineVisibleRanges = /** @class */ (function () {
    function LineVisibleRanges(lineNumber, ranges) {
        this.lineNumber = lineNumber;
        this.ranges = ranges;
    }
    return LineVisibleRanges;
}());
var HorizontalRange = /** @class */ (function () {
    function HorizontalRange(left, width) {
        this.left = Math.round(left);
        this.width = Math.round(width);
    }
    HorizontalRange.prototype.toString = function () {
        return "[" + this.left + "," + this.width + "]";
    };
    return HorizontalRange;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var FloatHorizontalRange = /** @class */ (function () {
    function FloatHorizontalRange(left, width) {
        this.left = left;
        this.width = width;
    }
    FloatHorizontalRange.prototype.toString = function () {
        return "[" + this.left + "," + this.width + "]";
    };
    FloatHorizontalRange.compare = function (a, b) {
        return a.left - b.left;
    };
    return FloatHorizontalRange;
}());
var RangeUtil = /** @class */ (function () {
    function RangeUtil() {
    }
    RangeUtil._createRange = function () {
        if (!this._handyReadyRange) {
            this._handyReadyRange = document.createRange();
        }
        return this._handyReadyRange;
    };
    RangeUtil._detachRange = function (range, endNode) {
        // Move range out of the span node, IE doesn't like having many ranges in
        // the same spot and will act badly for lines containing dashes ('-')
        range.selectNodeContents(endNode);
    };
    RangeUtil._readClientRects = function (startElement, startOffset, endElement, endOffset, endNode) {
        var range = this._createRange();
        try {
            range.setStart(startElement, startOffset);
            range.setEnd(endElement, endOffset);
            return range.getClientRects();
        }
        catch (e) {
            // This is life ...
            return null;
        }
        finally {
            this._detachRange(range, endNode);
        }
    };
    RangeUtil._mergeAdjacentRanges = function (ranges) {
        if (ranges.length === 1) {
            // There is nothing to merge
            return [new HorizontalRange(ranges[0].left, ranges[0].width)];
        }
        ranges.sort(FloatHorizontalRange.compare);
        var result = [], resultLen = 0;
        var prevLeft = ranges[0].left;
        var prevWidth = ranges[0].width;
        for (var i = 1, len = ranges.length; i < len; i++) {
            var range = ranges[i];
            var myLeft = range.left;
            var myWidth = range.width;
            if (prevLeft + prevWidth + 0.9 /* account for browser's rounding errors*/ >= myLeft) {
                prevWidth = Math.max(prevWidth, myLeft + myWidth - prevLeft);
            }
            else {
                result[resultLen++] = new HorizontalRange(prevLeft, prevWidth);
                prevLeft = myLeft;
                prevWidth = myWidth;
            }
        }
        result[resultLen++] = new HorizontalRange(prevLeft, prevWidth);
        return result;
    };
    RangeUtil._createHorizontalRangesFromClientRects = function (clientRects, clientRectDeltaLeft) {
        if (!clientRects || clientRects.length === 0) {
            return null;
        }
        // We go through FloatHorizontalRange because it has been observed in bi-di text
        // that the clientRects are not coming in sorted from the browser
        var result = [];
        for (var i = 0, len = clientRects.length; i < len; i++) {
            var clientRect = clientRects[i];
            result[i] = new FloatHorizontalRange(Math.max(0, clientRect.left - clientRectDeltaLeft), clientRect.width);
        }
        return this._mergeAdjacentRanges(result);
    };
    RangeUtil.readHorizontalRanges = function (domNode, startChildIndex, startOffset, endChildIndex, endOffset, clientRectDeltaLeft, endNode) {
        // Panic check
        var min = 0;
        var max = domNode.children.length - 1;
        if (min > max) {
            return null;
        }
        startChildIndex = Math.min(max, Math.max(min, startChildIndex));
        endChildIndex = Math.min(max, Math.max(min, endChildIndex));
        // If crossing over to a span only to select offset 0, then use the previous span's maximum offset
        // Chrome is buggy and doesn't handle 0 offsets well sometimes.
        if (startChildIndex !== endChildIndex) {
            if (endChildIndex > 0 && endOffset === 0) {
                endChildIndex--;
                endOffset = Number.MAX_VALUE;
            }
        }
        var startElement = domNode.children[startChildIndex].firstChild;
        var endElement = domNode.children[endChildIndex].firstChild;
        if (!startElement || !endElement) {
            // When having an empty <span> (without any text content), try to move to the previous <span>
            if (!startElement && startOffset === 0 && startChildIndex > 0) {
                startElement = domNode.children[startChildIndex - 1].firstChild;
                startOffset = 1073741824 /* MAX_SAFE_SMALL_INTEGER */;
            }
            if (!endElement && endOffset === 0 && endChildIndex > 0) {
                endElement = domNode.children[endChildIndex - 1].firstChild;
                endOffset = 1073741824 /* MAX_SAFE_SMALL_INTEGER */;
            }
        }
        if (!startElement || !endElement) {
            return null;
        }
        startOffset = Math.min(startElement.textContent.length, Math.max(0, startOffset));
        endOffset = Math.min(endElement.textContent.length, Math.max(0, endOffset));
        var clientRects = this._readClientRects(startElement, startOffset, endElement, endOffset, endNode);
        return this._createHorizontalRangesFromClientRects(clientRects, clientRectDeltaLeft);
    };
    return RangeUtil;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$w = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var canUseFastRenderedViewLine = (function () {
    if (isNative) {
        // In VSCode we know very well when the zoom level changes
        return true;
    }
    if (isLinux || isFirefox || isSafari) {
        // On Linux, it appears that zooming affects char widths (in pixels), which is unexpected.
        // --
        // Even though we read character widths correctly, having read them at a specific zoom level
        // does not mean they are the same at the current zoom level.
        // --
        // This could be improved if we ever figure out how to get an event when browsers zoom,
        // but until then we have to stick with reading client rects.
        // --
        // The same has been observed with Firefox on Windows7
        // --
        // The same has been oversved with Safari
        return false;
    }
    return true;
})();
var alwaysRenderInlineSelection = (isEdgeOrIE);
var DomReadingContext = /** @class */ (function () {
    function DomReadingContext(domNode, endNode) {
        this._domNode = domNode;
        this._clientRectDeltaLeft = 0;
        this._clientRectDeltaLeftRead = false;
        this.endNode = endNode;
    }
    Object.defineProperty(DomReadingContext.prototype, "clientRectDeltaLeft", {
        get: function () {
            if (!this._clientRectDeltaLeftRead) {
                this._clientRectDeltaLeftRead = true;
                this._clientRectDeltaLeft = this._domNode.getBoundingClientRect().left;
            }
            return this._clientRectDeltaLeft;
        },
        enumerable: true,
        configurable: true
    });
    return DomReadingContext;
}());
var ViewLineOptions = /** @class */ (function () {
    function ViewLineOptions(config, themeType) {
        this.themeType = themeType;
        this.renderWhitespace = config.editor.viewInfo.renderWhitespace;
        this.renderControlCharacters = config.editor.viewInfo.renderControlCharacters;
        this.spaceWidth = config.editor.fontInfo.spaceWidth;
        this.useMonospaceOptimizations = (config.editor.fontInfo.isMonospace
            && !config.editor.viewInfo.disableMonospaceOptimizations);
        this.lineHeight = config.editor.lineHeight;
        this.stopRenderingLineAfter = config.editor.viewInfo.stopRenderingLineAfter;
        this.fontLigatures = config.editor.viewInfo.fontLigatures;
    }
    ViewLineOptions.prototype.equals = function (other) {
        return (this.themeType === other.themeType
            && this.renderWhitespace === other.renderWhitespace
            && this.renderControlCharacters === other.renderControlCharacters
            && this.spaceWidth === other.spaceWidth
            && this.useMonospaceOptimizations === other.useMonospaceOptimizations
            && this.lineHeight === other.lineHeight
            && this.stopRenderingLineAfter === other.stopRenderingLineAfter
            && this.fontLigatures === other.fontLigatures);
    };
    return ViewLineOptions;
}());
var ViewLine = /** @class */ (function () {
    function ViewLine(options) {
        this._options = options;
        this._isMaybeInvalid = true;
        this._renderedViewLine = null;
    }
    // --- begin IVisibleLineData
    ViewLine.prototype.getDomNode = function () {
        if (this._renderedViewLine && this._renderedViewLine.domNode) {
            return this._renderedViewLine.domNode.domNode;
        }
        return null;
    };
    ViewLine.prototype.setDomNode = function (domNode) {
        if (this._renderedViewLine) {
            this._renderedViewLine.domNode = createFastDomNode(domNode);
        }
        else {
            throw new Error('I have no rendered view line to set the dom node to...');
        }
    };
    ViewLine.prototype.onContentChanged = function () {
        this._isMaybeInvalid = true;
    };
    ViewLine.prototype.onTokensChanged = function () {
        this._isMaybeInvalid = true;
    };
    ViewLine.prototype.onDecorationsChanged = function () {
        this._isMaybeInvalid = true;
    };
    ViewLine.prototype.onOptionsChanged = function (newOptions) {
        this._isMaybeInvalid = true;
        this._options = newOptions;
    };
    ViewLine.prototype.onSelectionChanged = function () {
        if (alwaysRenderInlineSelection || this._options.themeType === HIGH_CONTRAST) {
            this._isMaybeInvalid = true;
            return true;
        }
        return false;
    };
    ViewLine.prototype.renderLine = function (lineNumber, deltaTop, viewportData, sb) {
        if (this._isMaybeInvalid === false) {
            // it appears that nothing relevant has changed
            return false;
        }
        this._isMaybeInvalid = false;
        var lineData = viewportData.getViewLineRenderingData(lineNumber);
        var options = this._options;
        var actualInlineDecorations = LineDecoration.filter(lineData.inlineDecorations, lineNumber, lineData.minColumn, lineData.maxColumn);
        if (alwaysRenderInlineSelection || options.themeType === HIGH_CONTRAST) {
            var selections = viewportData.selections;
            for (var i = 0, len = selections.length; i < len; i++) {
                var selection = selections[i];
                if (selection.endLineNumber < lineNumber || selection.startLineNumber > lineNumber) {
                    // Selection does not intersect line
                    continue;
                }
                var startColumn = (selection.startLineNumber === lineNumber ? selection.startColumn : lineData.minColumn);
                var endColumn = (selection.endLineNumber === lineNumber ? selection.endColumn : lineData.maxColumn);
                if (startColumn < endColumn) {
                    actualInlineDecorations.push(new LineDecoration(startColumn, endColumn, 'inline-selected-text', 0 /* Regular */));
                }
            }
        }
        var renderLineInput = new RenderLineInput(options.useMonospaceOptimizations, lineData.content, lineData.isBasicASCII, lineData.containsRTL, lineData.minColumn - 1, lineData.tokens, actualInlineDecorations, lineData.tabSize, options.spaceWidth, options.stopRenderingLineAfter, options.renderWhitespace, options.renderControlCharacters, options.fontLigatures);
        if (this._renderedViewLine && this._renderedViewLine.input.equals(renderLineInput)) {
            // no need to do anything, we have the same render input
            return false;
        }
        sb.appendASCIIString('<div style="top:');
        sb.appendASCIIString(String(deltaTop));
        sb.appendASCIIString('px;height:');
        sb.appendASCIIString(String(this._options.lineHeight));
        sb.appendASCIIString('px;" class="');
        sb.appendASCIIString(ViewLine.CLASS_NAME);
        sb.appendASCIIString('">');
        var output = renderViewLine(renderLineInput, sb);
        sb.appendASCIIString('</div>');
        var renderedViewLine = null;
        if (canUseFastRenderedViewLine && lineData.isBasicASCII && options.useMonospaceOptimizations && output.containsForeignElements === 0 /* None */) {
            if (lineData.content.length < 300 && renderLineInput.lineTokens.getCount() < 100) {
                // Browser rounding errors have been observed in Chrome and IE, so using the fast
                // view line only for short lines. Please test before removing the length check...
                // ---
                // Another rounding error has been observed on Linux in VSCode, where <span> width
                // rounding errors add up to an observable large number...
                // ---
                // Also see another example of rounding errors on Windows in 
                // https://github.com/Microsoft/vscode/issues/33178
                renderedViewLine = new FastRenderedViewLine(this._renderedViewLine ? this._renderedViewLine.domNode : null, renderLineInput, output.characterMapping);
            }
        }
        if (!renderedViewLine) {
            renderedViewLine = createRenderedLine(this._renderedViewLine ? this._renderedViewLine.domNode : null, renderLineInput, output.characterMapping, output.containsRTL, output.containsForeignElements);
        }
        this._renderedViewLine = renderedViewLine;
        return true;
    };
    ViewLine.prototype.layoutLine = function (lineNumber, deltaTop) {
        if (this._renderedViewLine && this._renderedViewLine.domNode) {
            this._renderedViewLine.domNode.setTop(deltaTop);
            this._renderedViewLine.domNode.setHeight(this._options.lineHeight);
        }
    };
    // --- end IVisibleLineData
    ViewLine.prototype.getWidth = function () {
        if (!this._renderedViewLine) {
            return 0;
        }
        return this._renderedViewLine.getWidth();
    };
    ViewLine.prototype.getWidthIsFast = function () {
        if (!this._renderedViewLine) {
            return true;
        }
        return this._renderedViewLine.getWidthIsFast();
    };
    ViewLine.prototype.getVisibleRangesForRange = function (startColumn, endColumn, context) {
        startColumn = startColumn | 0; // @perf
        endColumn = endColumn | 0; // @perf
        startColumn = Math.min(this._renderedViewLine.input.lineContent.length + 1, Math.max(1, startColumn));
        endColumn = Math.min(this._renderedViewLine.input.lineContent.length + 1, Math.max(1, endColumn));
        var stopRenderingLineAfter = this._renderedViewLine.input.stopRenderingLineAfter | 0; // @perf
        if (stopRenderingLineAfter !== -1 && startColumn > stopRenderingLineAfter && endColumn > stopRenderingLineAfter) {
            // This range is obviously not visible
            return null;
        }
        if (stopRenderingLineAfter !== -1 && startColumn > stopRenderingLineAfter) {
            startColumn = stopRenderingLineAfter;
        }
        if (stopRenderingLineAfter !== -1 && endColumn > stopRenderingLineAfter) {
            endColumn = stopRenderingLineAfter;
        }
        return this._renderedViewLine.getVisibleRangesForRange(startColumn, endColumn, context);
    };
    ViewLine.prototype.getColumnOfNodeOffset = function (lineNumber, spanNode, offset) {
        return this._renderedViewLine.getColumnOfNodeOffset(lineNumber, spanNode, offset);
    };
    ViewLine.CLASS_NAME = 'view-line';
    return ViewLine;
}());
/**
 * A rendered line which is guaranteed to contain only regular ASCII and is rendered with a monospace font.
 */
var FastRenderedViewLine = /** @class */ (function () {
    function FastRenderedViewLine(domNode, renderLineInput, characterMapping) {
        this.domNode = domNode;
        this.input = renderLineInput;
        this._characterMapping = characterMapping;
        this._charWidth = renderLineInput.spaceWidth;
    }
    FastRenderedViewLine.prototype.getWidth = function () {
        return this._getCharPosition(this._characterMapping.length);
    };
    FastRenderedViewLine.prototype.getWidthIsFast = function () {
        return true;
    };
    FastRenderedViewLine.prototype.getVisibleRangesForRange = function (startColumn, endColumn, context) {
        var startPosition = this._getCharPosition(startColumn);
        var endPosition = this._getCharPosition(endColumn);
        return [new HorizontalRange(startPosition, endPosition - startPosition)];
    };
    FastRenderedViewLine.prototype._getCharPosition = function (column) {
        var charOffset = this._characterMapping.getAbsoluteOffsets();
        if (charOffset.length === 0) {
            // No characters on this line
            return 0;
        }
        return Math.round(this._charWidth * charOffset[column - 1]);
    };
    FastRenderedViewLine.prototype.getColumnOfNodeOffset = function (lineNumber, spanNode, offset) {
        var spanNodeTextContentLength = spanNode.textContent.length;
        var spanIndex = -1;
        while (spanNode) {
            spanNode = spanNode.previousSibling;
            spanIndex++;
        }
        var charOffset = this._characterMapping.partDataToCharOffset(spanIndex, spanNodeTextContentLength, offset);
        return charOffset + 1;
    };
    return FastRenderedViewLine;
}());
/**
 * Every time we render a line, we save what we have rendered in an instance of this class.
 */
var RenderedViewLine = /** @class */ (function () {
    function RenderedViewLine(domNode, renderLineInput, characterMapping, containsRTL$$1, containsForeignElements) {
        this.domNode = domNode;
        this.input = renderLineInput;
        this._characterMapping = characterMapping;
        this._isWhitespaceOnly = /^\s*$/.test(renderLineInput.lineContent);
        this._containsForeignElements = containsForeignElements;
        this._cachedWidth = -1;
        this._pixelOffsetCache = null;
        if (!containsRTL$$1 || this._characterMapping.length === 0 /* the line is empty */) {
            this._pixelOffsetCache = new Int32Array(Math.max(2, this._characterMapping.length + 1));
            for (var column = 0, len = this._characterMapping.length; column <= len; column++) {
                this._pixelOffsetCache[column] = -1;
            }
        }
    }
    // --- Reading from the DOM methods
    RenderedViewLine.prototype._getReadingTarget = function () {
        return this.domNode.domNode.firstChild;
    };
    /**
     * Width of the line in pixels
     */
    RenderedViewLine.prototype.getWidth = function () {
        if (this._cachedWidth === -1) {
            this._cachedWidth = this._getReadingTarget().offsetWidth;
        }
        return this._cachedWidth;
    };
    RenderedViewLine.prototype.getWidthIsFast = function () {
        if (this._cachedWidth === -1) {
            return false;
        }
        return true;
    };
    /**
     * Visible ranges for a model range
     */
    RenderedViewLine.prototype.getVisibleRangesForRange = function (startColumn, endColumn, context) {
        if (this._pixelOffsetCache !== null) {
            // the text is LTR
            var startOffset = this._readPixelOffset(startColumn, context);
            if (startOffset === -1) {
                return null;
            }
            var endOffset = this._readPixelOffset(endColumn, context);
            if (endOffset === -1) {
                return null;
            }
            return [new HorizontalRange(startOffset, endOffset - startOffset)];
        }
        return this._readVisibleRangesForRange(startColumn, endColumn, context);
    };
    RenderedViewLine.prototype._readVisibleRangesForRange = function (startColumn, endColumn, context) {
        if (startColumn === endColumn) {
            var pixelOffset = this._readPixelOffset(startColumn, context);
            if (pixelOffset === -1) {
                return null;
            }
            else {
                return [new HorizontalRange(pixelOffset, 0)];
            }
        }
        else {
            return this._readRawVisibleRangesForRange(startColumn, endColumn, context);
        }
    };
    RenderedViewLine.prototype._readPixelOffset = function (column, context) {
        if (this._characterMapping.length === 0) {
            // This line has no content
            if (this._containsForeignElements === 0 /* None */) {
                // We can assume the line is really empty
                return 0;
            }
            if (this._containsForeignElements === 2 /* After */) {
                // We have foreign elements after the (empty) line
                return 0;
            }
            if (this._containsForeignElements === 1 /* Before */) {
                // We have foreign element before the (empty) line
                return this.getWidth();
            }
        }
        if (this._pixelOffsetCache !== null) {
            // the text is LTR
            var cachedPixelOffset = this._pixelOffsetCache[column];
            if (cachedPixelOffset !== -1) {
                return cachedPixelOffset;
            }
            var result = this._actualReadPixelOffset(column, context);
            this._pixelOffsetCache[column] = result;
            return result;
        }
        return this._actualReadPixelOffset(column, context);
    };
    RenderedViewLine.prototype._actualReadPixelOffset = function (column, context) {
        if (this._characterMapping.length === 0) {
            // This line has no content
            var r_1 = RangeUtil.readHorizontalRanges(this._getReadingTarget(), 0, 0, 0, 0, context.clientRectDeltaLeft, context.endNode);
            if (!r_1 || r_1.length === 0) {
                return -1;
            }
            return r_1[0].left;
        }
        if (column === this._characterMapping.length && this._isWhitespaceOnly && this._containsForeignElements === 0 /* None */) {
            // This branch helps in the case of whitespace only lines which have a width set
            return this.getWidth();
        }
        var partData = this._characterMapping.charOffsetToPartData(column - 1);
        var partIndex = CharacterMapping.getPartIndex(partData);
        var charOffsetInPart = CharacterMapping.getCharIndex(partData);
        var r = RangeUtil.readHorizontalRanges(this._getReadingTarget(), partIndex, charOffsetInPart, partIndex, charOffsetInPart, context.clientRectDeltaLeft, context.endNode);
        if (!r || r.length === 0) {
            return -1;
        }
        return r[0].left;
    };
    RenderedViewLine.prototype._readRawVisibleRangesForRange = function (startColumn, endColumn, context) {
        if (startColumn === 1 && endColumn === this._characterMapping.length) {
            // This branch helps IE with bidi text & gives a performance boost to other browsers when reading visible ranges for an entire line
            return [new HorizontalRange(0, this.getWidth())];
        }
        var startPartData = this._characterMapping.charOffsetToPartData(startColumn - 1);
        var startPartIndex = CharacterMapping.getPartIndex(startPartData);
        var startCharOffsetInPart = CharacterMapping.getCharIndex(startPartData);
        var endPartData = this._characterMapping.charOffsetToPartData(endColumn - 1);
        var endPartIndex = CharacterMapping.getPartIndex(endPartData);
        var endCharOffsetInPart = CharacterMapping.getCharIndex(endPartData);
        return RangeUtil.readHorizontalRanges(this._getReadingTarget(), startPartIndex, startCharOffsetInPart, endPartIndex, endCharOffsetInPart, context.clientRectDeltaLeft, context.endNode);
    };
    /**
     * Returns the column for the text found at a specific offset inside a rendered dom node
     */
    RenderedViewLine.prototype.getColumnOfNodeOffset = function (lineNumber, spanNode, offset) {
        var spanNodeTextContentLength = spanNode.textContent.length;
        var spanIndex = -1;
        while (spanNode) {
            spanNode = spanNode.previousSibling;
            spanIndex++;
        }
        var charOffset = this._characterMapping.partDataToCharOffset(spanIndex, spanNodeTextContentLength, offset);
        return charOffset + 1;
    };
    return RenderedViewLine;
}());
var WebKitRenderedViewLine = /** @class */ (function (_super) {
    __extends$w(WebKitRenderedViewLine, _super);
    function WebKitRenderedViewLine() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    WebKitRenderedViewLine.prototype._readVisibleRangesForRange = function (startColumn, endColumn, context) {
        var output = _super.prototype._readVisibleRangesForRange.call(this, startColumn, endColumn, context);
        if (!output || output.length === 0 || startColumn === endColumn || (startColumn === 1 && endColumn === this._characterMapping.length)) {
            return output;
        }
        // WebKit is buggy and returns an expanded range (to contain words in some cases)
        // The last client rect is enlarged (I think)
        // This is an attempt to patch things up
        // Find position of previous column
        var beforeEndPixelOffset = this._readPixelOffset(endColumn - 1, context);
        // Find position of last column
        var endPixelOffset = this._readPixelOffset(endColumn, context);
        if (beforeEndPixelOffset !== -1 && endPixelOffset !== -1) {
            var isLTR = (beforeEndPixelOffset <= endPixelOffset);
            var lastRange = output[output.length - 1];
            if (isLTR && lastRange.left < endPixelOffset) {
                // Trim down the width of the last visible range to not go after the last column's position
                lastRange.width = endPixelOffset - lastRange.left;
            }
        }
        return output;
    };
    return WebKitRenderedViewLine;
}(RenderedViewLine));
var createRenderedLine = (function () {
    if (isWebKit) {
        return createWebKitRenderedLine;
    }
    return createNormalRenderedLine;
})();
function createWebKitRenderedLine(domNode, renderLineInput, characterMapping, containsRTL$$1, containsForeignElements) {
    return new WebKitRenderedViewLine(domNode, renderLineInput, characterMapping, containsRTL$$1, containsForeignElements);
}
function createNormalRenderedLine(domNode, renderLineInput, characterMapping, containsRTL$$1, containsForeignElements) {
    return new RenderedViewLine(domNode, renderLineInput, characterMapping, containsRTL$$1, containsForeignElements);
}

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$x = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var MouseTarget = /** @class */ (function () {
    function MouseTarget(element, type, mouseColumn, position, range, detail) {
        if (mouseColumn === void 0) { mouseColumn = 0; }
        if (position === void 0) { position = null; }
        if (range === void 0) { range = null; }
        if (detail === void 0) { detail = null; }
        this.element = element;
        this.type = type;
        this.mouseColumn = mouseColumn;
        this.position = position;
        if (!range && position) {
            range = new Range(position.lineNumber, position.column, position.lineNumber, position.column);
        }
        this.range = range;
        this.detail = detail;
    }
    MouseTarget._typeToString = function (type) {
        if (type === MouseTargetType.TEXTAREA) {
            return 'TEXTAREA';
        }
        if (type === MouseTargetType.GUTTER_GLYPH_MARGIN) {
            return 'GUTTER_GLYPH_MARGIN';
        }
        if (type === MouseTargetType.GUTTER_LINE_NUMBERS) {
            return 'GUTTER_LINE_NUMBERS';
        }
        if (type === MouseTargetType.GUTTER_LINE_DECORATIONS) {
            return 'GUTTER_LINE_DECORATIONS';
        }
        if (type === MouseTargetType.GUTTER_VIEW_ZONE) {
            return 'GUTTER_VIEW_ZONE';
        }
        if (type === MouseTargetType.CONTENT_TEXT) {
            return 'CONTENT_TEXT';
        }
        if (type === MouseTargetType.CONTENT_EMPTY) {
            return 'CONTENT_EMPTY';
        }
        if (type === MouseTargetType.CONTENT_VIEW_ZONE) {
            return 'CONTENT_VIEW_ZONE';
        }
        if (type === MouseTargetType.CONTENT_WIDGET) {
            return 'CONTENT_WIDGET';
        }
        if (type === MouseTargetType.OVERVIEW_RULER) {
            return 'OVERVIEW_RULER';
        }
        if (type === MouseTargetType.SCROLLBAR) {
            return 'SCROLLBAR';
        }
        if (type === MouseTargetType.OVERLAY_WIDGET) {
            return 'OVERLAY_WIDGET';
        }
        return 'UNKNOWN';
    };
    MouseTarget.toString = function (target) {
        return this._typeToString(target.type) + ': ' + target.position + ' - ' + target.range + ' - ' + target.detail;
    };
    MouseTarget.prototype.toString = function () {
        return MouseTarget.toString(this);
    };
    return MouseTarget;
}());
var ElementPath = /** @class */ (function () {
    function ElementPath() {
    }
    ElementPath.isTextArea = function (path) {
        return (path.length === 2
            && path[0] === 3 /* OverflowGuard */
            && path[1] === 6 /* TextArea */);
    };
    ElementPath.isChildOfViewLines = function (path) {
        return (path.length >= 4
            && path[0] === 3 /* OverflowGuard */
            && path[3] === 7 /* ViewLines */);
    };
    ElementPath.isStrictChildOfViewLines = function (path) {
        return (path.length > 4
            && path[0] === 3 /* OverflowGuard */
            && path[3] === 7 /* ViewLines */);
    };
    ElementPath.isChildOfScrollableElement = function (path) {
        return (path.length >= 2
            && path[0] === 3 /* OverflowGuard */
            && path[1] === 5 /* ScrollableElement */);
    };
    ElementPath.isChildOfMinimap = function (path) {
        return (path.length >= 2
            && path[0] === 3 /* OverflowGuard */
            && path[1] === 8 /* Minimap */);
    };
    ElementPath.isChildOfContentWidgets = function (path) {
        return (path.length >= 4
            && path[0] === 3 /* OverflowGuard */
            && path[3] === 1 /* ContentWidgets */);
    };
    ElementPath.isChildOfOverflowingContentWidgets = function (path) {
        return (path.length >= 1
            && path[0] === 2 /* OverflowingContentWidgets */);
    };
    ElementPath.isChildOfOverlayWidgets = function (path) {
        return (path.length >= 2
            && path[0] === 3 /* OverflowGuard */
            && path[1] === 4 /* OverlayWidgets */);
    };
    return ElementPath;
}());
var HitTestContext = /** @class */ (function () {
    function HitTestContext(context, viewHelper, lastViewCursorsRenderData) {
        this.model = context.model;
        this.layoutInfo = context.configuration.editor.layoutInfo;
        this.viewDomNode = viewHelper.viewDomNode;
        this.lineHeight = context.configuration.editor.lineHeight;
        this.typicalHalfwidthCharacterWidth = context.configuration.editor.fontInfo.typicalHalfwidthCharacterWidth;
        this.lastViewCursorsRenderData = lastViewCursorsRenderData;
        this._context = context;
        this._viewHelper = viewHelper;
    }
    HitTestContext.prototype.getZoneAtCoord = function (mouseVerticalOffset) {
        return HitTestContext.getZoneAtCoord(this._context, mouseVerticalOffset);
    };
    HitTestContext.getZoneAtCoord = function (context, mouseVerticalOffset) {
        // The target is either a view zone or the empty space after the last view-line
        var viewZoneWhitespace = context.viewLayout.getWhitespaceAtVerticalOffset(mouseVerticalOffset);
        if (viewZoneWhitespace) {
            var viewZoneMiddle = viewZoneWhitespace.verticalOffset + viewZoneWhitespace.height / 2, lineCount = context.model.getLineCount(), positionBefore = null, position = void 0, positionAfter = null;
            if (viewZoneWhitespace.afterLineNumber !== lineCount) {
                // There are more lines after this view zone
                positionAfter = new Position(viewZoneWhitespace.afterLineNumber + 1, 1);
            }
            if (viewZoneWhitespace.afterLineNumber > 0) {
                // There are more lines above this view zone
                positionBefore = new Position(viewZoneWhitespace.afterLineNumber, context.model.getLineMaxColumn(viewZoneWhitespace.afterLineNumber));
            }
            if (positionAfter === null) {
                position = positionBefore;
            }
            else if (positionBefore === null) {
                position = positionAfter;
            }
            else if (mouseVerticalOffset < viewZoneMiddle) {
                position = positionBefore;
            }
            else {
                position = positionAfter;
            }
            return {
                viewZoneId: viewZoneWhitespace.id,
                afterLineNumber: viewZoneWhitespace.afterLineNumber,
                positionBefore: positionBefore,
                positionAfter: positionAfter,
                position: position
            };
        }
        return null;
    };
    HitTestContext.prototype.getFullLineRangeAtCoord = function (mouseVerticalOffset) {
        if (this._context.viewLayout.isAfterLines(mouseVerticalOffset)) {
            // Below the last line
            var lineNumber_1 = this._context.model.getLineCount();
            var maxLineColumn_1 = this._context.model.getLineMaxColumn(lineNumber_1);
            return {
                range: new Range(lineNumber_1, maxLineColumn_1, lineNumber_1, maxLineColumn_1),
                isAfterLines: true
            };
        }
        var lineNumber = this._context.viewLayout.getLineNumberAtVerticalOffset(mouseVerticalOffset);
        var maxLineColumn = this._context.model.getLineMaxColumn(lineNumber);
        return {
            range: new Range(lineNumber, 1, lineNumber, maxLineColumn),
            isAfterLines: false
        };
    };
    HitTestContext.prototype.getLineNumberAtVerticalOffset = function (mouseVerticalOffset) {
        return this._context.viewLayout.getLineNumberAtVerticalOffset(mouseVerticalOffset);
    };
    HitTestContext.prototype.isAfterLines = function (mouseVerticalOffset) {
        return this._context.viewLayout.isAfterLines(mouseVerticalOffset);
    };
    HitTestContext.prototype.getVerticalOffsetForLineNumber = function (lineNumber) {
        return this._context.viewLayout.getVerticalOffsetForLineNumber(lineNumber);
    };
    HitTestContext.prototype.findAttribute = function (element, attr) {
        return HitTestContext._findAttribute(element, attr, this._viewHelper.viewDomNode);
    };
    HitTestContext._findAttribute = function (element, attr, stopAt) {
        while (element && element !== document.body) {
            if (element.hasAttribute && element.hasAttribute(attr)) {
                return element.getAttribute(attr);
            }
            if (element === stopAt) {
                return null;
            }
            element = element.parentNode;
        }
        return null;
    };
    HitTestContext.prototype.getLineWidth = function (lineNumber) {
        return this._viewHelper.getLineWidth(lineNumber);
    };
    HitTestContext.prototype.visibleRangeForPosition2 = function (lineNumber, column) {
        return this._viewHelper.visibleRangeForPosition2(lineNumber, column);
    };
    HitTestContext.prototype.getPositionFromDOMInfo = function (spanNode, offset) {
        return this._viewHelper.getPositionFromDOMInfo(spanNode, offset);
    };
    HitTestContext.prototype.getCurrentScrollTop = function () {
        return this._context.viewLayout.getCurrentScrollTop();
    };
    HitTestContext.prototype.getCurrentScrollLeft = function () {
        return this._context.viewLayout.getCurrentScrollLeft();
    };
    return HitTestContext;
}());
var BareHitTestRequest = /** @class */ (function () {
    function BareHitTestRequest(ctx, editorPos, pos) {
        this.editorPos = editorPos;
        this.pos = pos;
        this.mouseVerticalOffset = Math.max(0, ctx.getCurrentScrollTop() + pos.y - editorPos.y);
        this.mouseContentHorizontalOffset = ctx.getCurrentScrollLeft() + pos.x - editorPos.x - ctx.layoutInfo.contentLeft;
        this.isInMarginArea = (pos.x - editorPos.x < ctx.layoutInfo.contentLeft && pos.x - editorPos.x >= ctx.layoutInfo.glyphMarginLeft);
        this.isInContentArea = !this.isInMarginArea;
        this.mouseColumn = Math.max(0, MouseTargetFactory._getMouseColumn(this.mouseContentHorizontalOffset, ctx.typicalHalfwidthCharacterWidth));
    }
    return BareHitTestRequest;
}());
var HitTestRequest = /** @class */ (function (_super) {
    __extends$x(HitTestRequest, _super);
    function HitTestRequest(ctx, editorPos, pos, target) {
        var _this = _super.call(this, ctx, editorPos, pos) || this;
        _this._ctx = ctx;
        if (target) {
            _this.target = target;
            _this.targetPath = PartFingerprints.collect(target, ctx.viewDomNode);
        }
        else {
            _this.target = null;
            _this.targetPath = new Uint8Array(0);
        }
        return _this;
    }
    HitTestRequest.prototype.toString = function () {
        return "pos(" + this.pos.x + "," + this.pos.y + "), editorPos(" + this.editorPos.x + "," + this.editorPos.y + "), mouseVerticalOffset: " + this.mouseVerticalOffset + ", mouseContentHorizontalOffset: " + this.mouseContentHorizontalOffset + "\n\ttarget: " + (this.target ? this.target.outerHTML : null);
    };
    HitTestRequest.prototype.fulfill = function (type, position, range, detail) {
        if (position === void 0) { position = null; }
        if (range === void 0) { range = null; }
        if (detail === void 0) { detail = null; }
        return new MouseTarget(this.target, type, this.mouseColumn, position, range, detail);
    };
    HitTestRequest.prototype.withTarget = function (target) {
        return new HitTestRequest(this._ctx, this.editorPos, this.pos, target);
    };
    return HitTestRequest;
}(BareHitTestRequest));
var EMPTY_CONTENT_AFTER_LINES = { isAfterLines: true };
function createEmptyContentDataInLines(horizontalDistanceToText) {
    return {
        isAfterLines: false,
        horizontalDistanceToText: horizontalDistanceToText
    };
}
var MouseTargetFactory = /** @class */ (function () {
    function MouseTargetFactory(context, viewHelper) {
        this._context = context;
        this._viewHelper = viewHelper;
    }
    MouseTargetFactory.prototype.mouseTargetIsWidget = function (e) {
        var t = e.target;
        var path = PartFingerprints.collect(t, this._viewHelper.viewDomNode);
        // Is it a content widget?
        if (ElementPath.isChildOfContentWidgets(path) || ElementPath.isChildOfOverflowingContentWidgets(path)) {
            return true;
        }
        // Is it an overlay widget?
        if (ElementPath.isChildOfOverlayWidgets(path)) {
            return true;
        }
        return false;
    };
    MouseTargetFactory.prototype.createMouseTarget = function (lastViewCursorsRenderData, editorPos, pos, target) {
        var ctx = new HitTestContext(this._context, this._viewHelper, lastViewCursorsRenderData);
        var request = new HitTestRequest(ctx, editorPos, pos, target);
        try {
            var r = MouseTargetFactory._createMouseTarget(ctx, request, false);
            // console.log(r.toString());
            return r;
        }
        catch (err) {
            // console.log(err);
            return request.fulfill(MouseTargetType.UNKNOWN);
        }
    };
    MouseTargetFactory._createMouseTarget = function (ctx, request, domHitTestExecuted) {
        // console.log(`${domHitTestExecuted ? '=>' : ''}CAME IN REQUEST: ${request}`);
        // First ensure the request has a target
        if (request.target === null) {
            if (domHitTestExecuted) {
                // Still no target... and we have already executed hit test...
                return request.fulfill(MouseTargetType.UNKNOWN);
            }
            var hitTestResult = MouseTargetFactory._doHitTest(ctx, request);
            if (hitTestResult.position) {
                return MouseTargetFactory.createMouseTargetFromHitTestPosition(ctx, request, hitTestResult.position.lineNumber, hitTestResult.position.column);
            }
            return this._createMouseTarget(ctx, request.withTarget(hitTestResult.hitTarget), true);
        }
        var result = null;
        result = result || MouseTargetFactory._hitTestContentWidget(ctx, request);
        result = result || MouseTargetFactory._hitTestOverlayWidget(ctx, request);
        result = result || MouseTargetFactory._hitTestMinimap(ctx, request);
        result = result || MouseTargetFactory._hitTestScrollbarSlider(ctx, request);
        result = result || MouseTargetFactory._hitTestViewZone(ctx, request);
        result = result || MouseTargetFactory._hitTestMargin(ctx, request);
        result = result || MouseTargetFactory._hitTestViewCursor(ctx, request);
        result = result || MouseTargetFactory._hitTestTextArea(ctx, request);
        result = result || MouseTargetFactory._hitTestViewLines(ctx, request, domHitTestExecuted);
        result = result || MouseTargetFactory._hitTestScrollbar(ctx, request);
        return (result || request.fulfill(MouseTargetType.UNKNOWN));
    };
    MouseTargetFactory._hitTestContentWidget = function (ctx, request) {
        // Is it a content widget?
        if (ElementPath.isChildOfContentWidgets(request.targetPath) || ElementPath.isChildOfOverflowingContentWidgets(request.targetPath)) {
            var widgetId = ctx.findAttribute(request.target, 'widgetId');
            if (widgetId) {
                return request.fulfill(MouseTargetType.CONTENT_WIDGET, null, null, widgetId);
            }
            else {
                return request.fulfill(MouseTargetType.UNKNOWN);
            }
        }
        return null;
    };
    MouseTargetFactory._hitTestOverlayWidget = function (ctx, request) {
        // Is it an overlay widget?
        if (ElementPath.isChildOfOverlayWidgets(request.targetPath)) {
            var widgetId = ctx.findAttribute(request.target, 'widgetId');
            if (widgetId) {
                return request.fulfill(MouseTargetType.OVERLAY_WIDGET, null, null, widgetId);
            }
            else {
                return request.fulfill(MouseTargetType.UNKNOWN);
            }
        }
        return null;
    };
    MouseTargetFactory._hitTestViewCursor = function (ctx, request) {
        if (request.target) {
            // Check if we've hit a painted cursor
            var lastViewCursorsRenderData = ctx.lastViewCursorsRenderData;
            for (var i = 0, len = lastViewCursorsRenderData.length; i < len; i++) {
                var d = lastViewCursorsRenderData[i];
                if (request.target === d.domNode) {
                    return request.fulfill(MouseTargetType.CONTENT_TEXT, d.position);
                }
            }
        }
        if (request.isInContentArea) {
            // Edge has a bug when hit-testing the exact position of a cursor,
            // instead of returning the correct dom node, it returns the
            // first or last rendered view line dom node, therefore help it out
            // and first check if we are on top of a cursor
            var lastViewCursorsRenderData = ctx.lastViewCursorsRenderData;
            var mouseContentHorizontalOffset = request.mouseContentHorizontalOffset;
            var mouseVerticalOffset = request.mouseVerticalOffset;
            for (var i = 0, len = lastViewCursorsRenderData.length; i < len; i++) {
                var d = lastViewCursorsRenderData[i];
                if (mouseContentHorizontalOffset < d.contentLeft) {
                    // mouse position is to the left of the cursor
                    continue;
                }
                if (mouseContentHorizontalOffset > d.contentLeft + d.width) {
                    // mouse position is to the right of the cursor
                    continue;
                }
                var cursorVerticalOffset = ctx.getVerticalOffsetForLineNumber(d.position.lineNumber);
                if (cursorVerticalOffset <= mouseVerticalOffset
                    && mouseVerticalOffset <= cursorVerticalOffset + d.height) {
                    return request.fulfill(MouseTargetType.CONTENT_TEXT, d.position);
                }
            }
        }
        return null;
    };
    MouseTargetFactory._hitTestViewZone = function (ctx, request) {
        var viewZoneData = ctx.getZoneAtCoord(request.mouseVerticalOffset);
        if (viewZoneData) {
            var mouseTargetType = (request.isInContentArea ? MouseTargetType.CONTENT_VIEW_ZONE : MouseTargetType.GUTTER_VIEW_ZONE);
            return request.fulfill(mouseTargetType, viewZoneData.position, null, viewZoneData);
        }
        return null;
    };
    MouseTargetFactory._hitTestTextArea = function (ctx, request) {
        // Is it the textarea?
        if (ElementPath.isTextArea(request.targetPath)) {
            return request.fulfill(MouseTargetType.TEXTAREA);
        }
        return null;
    };
    MouseTargetFactory._hitTestMargin = function (ctx, request) {
        if (request.isInMarginArea) {
            var res = ctx.getFullLineRangeAtCoord(request.mouseVerticalOffset);
            var pos = res.range.getStartPosition();
            var offset = Math.abs(request.pos.x - request.editorPos.x);
            var detail = {
                isAfterLines: res.isAfterLines,
                glyphMarginWidth: ctx.layoutInfo.glyphMarginWidth,
                lineNumbersWidth: ctx.layoutInfo.lineNumbersWidth,
                offsetX: offset
            };
            offset -= ctx.layoutInfo.glyphMarginLeft;
            if (offset <= ctx.layoutInfo.glyphMarginWidth) {
                // On the glyph margin
                return request.fulfill(MouseTargetType.GUTTER_GLYPH_MARGIN, pos, res.range, detail);
            }
            offset -= ctx.layoutInfo.glyphMarginWidth;
            if (offset <= ctx.layoutInfo.lineNumbersWidth) {
                // On the line numbers
                return request.fulfill(MouseTargetType.GUTTER_LINE_NUMBERS, pos, res.range, detail);
            }
            offset -= ctx.layoutInfo.lineNumbersWidth;
            // On the line decorations
            return request.fulfill(MouseTargetType.GUTTER_LINE_DECORATIONS, pos, res.range, detail);
        }
        return null;
    };
    MouseTargetFactory._hitTestViewLines = function (ctx, request, domHitTestExecuted) {
        if (!ElementPath.isChildOfViewLines(request.targetPath)) {
            return null;
        }
        // Check if it is below any lines and any view zones
        if (ctx.isAfterLines(request.mouseVerticalOffset)) {
            // This most likely indicates it happened after the last view-line
            var lineCount = ctx.model.getLineCount();
            var maxLineColumn = ctx.model.getLineMaxColumn(lineCount);
            return request.fulfill(MouseTargetType.CONTENT_EMPTY, new Position(lineCount, maxLineColumn), void 0, EMPTY_CONTENT_AFTER_LINES);
        }
        if (domHitTestExecuted) {
            // Check if we are hitting a view-line (can happen in the case of inline decorations on empty lines)
            // See https://github.com/Microsoft/vscode/issues/46942
            if (ElementPath.isStrictChildOfViewLines(request.targetPath)) {
                var lineNumber = ctx.getLineNumberAtVerticalOffset(request.mouseVerticalOffset);
                if (ctx.model.getLineLength(lineNumber) === 0) {
                    var lineWidth = ctx.getLineWidth(lineNumber);
                    var detail = createEmptyContentDataInLines(request.mouseContentHorizontalOffset - lineWidth);
                    return request.fulfill(MouseTargetType.CONTENT_EMPTY, new Position(lineNumber, 1), void 0, detail);
                }
            }
            // We have already executed hit test...
            return request.fulfill(MouseTargetType.UNKNOWN);
        }
        var hitTestResult = MouseTargetFactory._doHitTest(ctx, request);
        if (hitTestResult.position) {
            return MouseTargetFactory.createMouseTargetFromHitTestPosition(ctx, request, hitTestResult.position.lineNumber, hitTestResult.position.column);
        }
        return this._createMouseTarget(ctx, request.withTarget(hitTestResult.hitTarget), true);
    };
    MouseTargetFactory._hitTestMinimap = function (ctx, request) {
        if (ElementPath.isChildOfMinimap(request.targetPath)) {
            var possibleLineNumber = ctx.getLineNumberAtVerticalOffset(request.mouseVerticalOffset);
            var maxColumn = ctx.model.getLineMaxColumn(possibleLineNumber);
            return request.fulfill(MouseTargetType.SCROLLBAR, new Position(possibleLineNumber, maxColumn));
        }
        return null;
    };
    MouseTargetFactory._hitTestScrollbarSlider = function (ctx, request) {
        if (ElementPath.isChildOfScrollableElement(request.targetPath)) {
            if (request.target && request.target.nodeType === 1) {
                var className = request.target.className;
                if (className && /\b(slider|scrollbar)\b/.test(className)) {
                    var possibleLineNumber = ctx.getLineNumberAtVerticalOffset(request.mouseVerticalOffset);
                    var maxColumn = ctx.model.getLineMaxColumn(possibleLineNumber);
                    return request.fulfill(MouseTargetType.SCROLLBAR, new Position(possibleLineNumber, maxColumn));
                }
            }
        }
        return null;
    };
    MouseTargetFactory._hitTestScrollbar = function (ctx, request) {
        // Is it the overview ruler?
        // Is it a child of the scrollable element?
        if (ElementPath.isChildOfScrollableElement(request.targetPath)) {
            var possibleLineNumber = ctx.getLineNumberAtVerticalOffset(request.mouseVerticalOffset);
            var maxColumn = ctx.model.getLineMaxColumn(possibleLineNumber);
            return request.fulfill(MouseTargetType.SCROLLBAR, new Position(possibleLineNumber, maxColumn));
        }
        return null;
    };
    MouseTargetFactory.prototype.getMouseColumn = function (editorPos, pos) {
        var layoutInfo = this._context.configuration.editor.layoutInfo;
        var mouseContentHorizontalOffset = this._context.viewLayout.getCurrentScrollLeft() + pos.x - editorPos.x - layoutInfo.contentLeft;
        return MouseTargetFactory._getMouseColumn(mouseContentHorizontalOffset, this._context.configuration.editor.fontInfo.typicalHalfwidthCharacterWidth);
    };
    MouseTargetFactory._getMouseColumn = function (mouseContentHorizontalOffset, typicalHalfwidthCharacterWidth) {
        if (mouseContentHorizontalOffset < 0) {
            return 1;
        }
        var chars = Math.round(mouseContentHorizontalOffset / typicalHalfwidthCharacterWidth);
        return (chars + 1);
    };
    MouseTargetFactory.createMouseTargetFromHitTestPosition = function (ctx, request, lineNumber, column) {
        var pos = new Position(lineNumber, column);
        var lineWidth = ctx.getLineWidth(lineNumber);
        if (request.mouseContentHorizontalOffset > lineWidth) {
            if (isEdge && pos.column === 1) {
                // See https://github.com/Microsoft/vscode/issues/10875
                var detail_1 = createEmptyContentDataInLines(request.mouseContentHorizontalOffset - lineWidth);
                return request.fulfill(MouseTargetType.CONTENT_EMPTY, new Position(lineNumber, ctx.model.getLineMaxColumn(lineNumber)), void 0, detail_1);
            }
            var detail = createEmptyContentDataInLines(request.mouseContentHorizontalOffset - lineWidth);
            return request.fulfill(MouseTargetType.CONTENT_EMPTY, pos, void 0, detail);
        }
        var visibleRange = ctx.visibleRangeForPosition2(lineNumber, column);
        if (!visibleRange) {
            return request.fulfill(MouseTargetType.UNKNOWN, pos);
        }
        var columnHorizontalOffset = visibleRange.left;
        if (request.mouseContentHorizontalOffset === columnHorizontalOffset) {
            return request.fulfill(MouseTargetType.CONTENT_TEXT, pos);
        }
        var points = [];
        points.push({ offset: visibleRange.left, column: column });
        if (column > 1) {
            var visibleRange_1 = ctx.visibleRangeForPosition2(lineNumber, column - 1);
            if (visibleRange_1) {
                points.push({ offset: visibleRange_1.left, column: column - 1 });
            }
        }
        var lineMaxColumn = ctx.model.getLineMaxColumn(lineNumber);
        if (column < lineMaxColumn) {
            var visibleRange_2 = ctx.visibleRangeForPosition2(lineNumber, column + 1);
            if (visibleRange_2) {
                points.push({ offset: visibleRange_2.left, column: column + 1 });
            }
        }
        points.sort(function (a, b) { return a.offset - b.offset; });
        for (var i = 1; i < points.length; i++) {
            var prev = points[i - 1];
            var curr = points[i];
            if (prev.offset <= request.mouseContentHorizontalOffset && request.mouseContentHorizontalOffset <= curr.offset) {
                var rng = new Range(lineNumber, prev.column, lineNumber, curr.column);
                return request.fulfill(MouseTargetType.CONTENT_TEXT, pos, rng);
            }
        }
        return request.fulfill(MouseTargetType.CONTENT_TEXT, pos);
    };
    /**
     * Most probably WebKit browsers and Edge
     */
    MouseTargetFactory._doHitTestWithCaretRangeFromPoint = function (ctx, request) {
        // In Chrome, especially on Linux it is possible to click between lines,
        // so try to adjust the `hity` below so that it lands in the center of a line
        var lineNumber = ctx.getLineNumberAtVerticalOffset(request.mouseVerticalOffset);
        var lineVerticalOffset = ctx.getVerticalOffsetForLineNumber(lineNumber);
        var lineCenteredVerticalOffset = lineVerticalOffset + Math.floor(ctx.lineHeight / 2);
        var adjustedPageY = request.pos.y + (lineCenteredVerticalOffset - request.mouseVerticalOffset);
        if (adjustedPageY <= request.editorPos.y) {
            adjustedPageY = request.editorPos.y + 1;
        }
        if (adjustedPageY >= request.editorPos.y + ctx.layoutInfo.height) {
            adjustedPageY = request.editorPos.y + ctx.layoutInfo.height - 1;
        }
        var adjustedPage = new PageCoordinates(request.pos.x, adjustedPageY);
        var r = this._actualDoHitTestWithCaretRangeFromPoint(ctx, adjustedPage.toClientCoordinates());
        if (r.position) {
            return r;
        }
        // Also try to hit test without the adjustment (for the edge cases that we are near the top or bottom)
        return this._actualDoHitTestWithCaretRangeFromPoint(ctx, request.pos.toClientCoordinates());
    };
    MouseTargetFactory._actualDoHitTestWithCaretRangeFromPoint = function (ctx, coords) {
        var range = document.caretRangeFromPoint(coords.clientX, coords.clientY);
        if (!range || !range.startContainer) {
            return {
                position: null,
                hitTarget: null
            };
        }
        // Chrome always hits a TEXT_NODE, while Edge sometimes hits a token span
        var startContainer = range.startContainer;
        var hitTarget;
        if (startContainer.nodeType === startContainer.TEXT_NODE) {
            // startContainer is expected to be the token text
            var parent1 = startContainer.parentNode; // expected to be the token span
            var parent2 = parent1 ? parent1.parentNode : null; // expected to be the view line container span
            var parent3 = parent2 ? parent2.parentNode : null; // expected to be the view line div
            var parent3ClassName = parent3 && parent3.nodeType === parent3.ELEMENT_NODE ? parent3.className : null;
            if (parent3ClassName === ViewLine.CLASS_NAME) {
                var p = ctx.getPositionFromDOMInfo(parent1, range.startOffset);
                return {
                    position: p,
                    hitTarget: null
                };
            }
            else {
                hitTarget = startContainer.parentNode;
            }
        }
        else if (startContainer.nodeType === startContainer.ELEMENT_NODE) {
            // startContainer is expected to be the token span
            var parent1 = startContainer.parentNode; // expected to be the view line container span
            var parent2 = parent1 ? parent1.parentNode : null; // expected to be the view line div
            var parent2ClassName = parent2 && parent2.nodeType === parent2.ELEMENT_NODE ? parent2.className : null;
            if (parent2ClassName === ViewLine.CLASS_NAME) {
                var p = ctx.getPositionFromDOMInfo(startContainer, startContainer.textContent.length);
                return {
                    position: p,
                    hitTarget: null
                };
            }
            else {
                hitTarget = startContainer;
            }
        }
        return {
            position: null,
            hitTarget: hitTarget
        };
    };
    /**
     * Most probably Gecko
     */
    MouseTargetFactory._doHitTestWithCaretPositionFromPoint = function (ctx, coords) {
        var hitResult = document.caretPositionFromPoint(coords.clientX, coords.clientY);
        if (hitResult.offsetNode.nodeType === hitResult.offsetNode.TEXT_NODE) {
            // offsetNode is expected to be the token text
            var parent1 = hitResult.offsetNode.parentNode; // expected to be the token span
            var parent2 = parent1 ? parent1.parentNode : null; // expected to be the view line container span
            var parent3 = parent2 ? parent2.parentNode : null; // expected to be the view line div
            var parent3ClassName = parent3 && parent3.nodeType === parent3.ELEMENT_NODE ? parent3.className : null;
            if (parent3ClassName === ViewLine.CLASS_NAME) {
                var p = ctx.getPositionFromDOMInfo(hitResult.offsetNode.parentNode, hitResult.offset);
                return {
                    position: p,
                    hitTarget: null
                };
            }
            else {
                return {
                    position: null,
                    hitTarget: hitResult.offsetNode.parentNode
                };
            }
        }
        return {
            position: null,
            hitTarget: hitResult.offsetNode
        };
    };
    /**
     * Most probably IE
     */
    MouseTargetFactory._doHitTestWithMoveToPoint = function (ctx, coords) {
        var resultPosition = null;
        var resultHitTarget = null;
        var textRange = document.body.createTextRange();
        try {
            textRange.moveToPoint(coords.clientX, coords.clientY);
        }
        catch (err) {
            return {
                position: null,
                hitTarget: null
            };
        }
        textRange.collapse(true);
        // Now, let's do our best to figure out what we hit :)
        var parentElement = textRange ? textRange.parentElement() : null;
        var parent1 = parentElement ? parentElement.parentNode : null;
        var parent2 = parent1 ? parent1.parentNode : null;
        var parent2ClassName = parent2 && parent2.nodeType === parent2.ELEMENT_NODE ? parent2.className : '';
        if (parent2ClassName === ViewLine.CLASS_NAME) {
            var rangeToContainEntireSpan = textRange.duplicate();
            rangeToContainEntireSpan.moveToElementText(parentElement);
            rangeToContainEntireSpan.setEndPoint('EndToStart', textRange);
            resultPosition = ctx.getPositionFromDOMInfo(parentElement, rangeToContainEntireSpan.text.length);
            // Move range out of the span node, IE doesn't like having many ranges in
            // the same spot and will act badly for lines containing dashes ('-')
            rangeToContainEntireSpan.moveToElementText(ctx.viewDomNode);
        }
        else {
            // Looks like we've hit the hover or something foreign
            resultHitTarget = parentElement;
        }
        // Move range out of the span node, IE doesn't like having many ranges in
        // the same spot and will act badly for lines containing dashes ('-')
        textRange.moveToElementText(ctx.viewDomNode);
        return {
            position: resultPosition,
            hitTarget: resultHitTarget
        };
    };
    MouseTargetFactory._doHitTest = function (ctx, request) {
        // State of the art (18.10.2012):
        // The spec says browsers should support document.caretPositionFromPoint, but nobody implemented it (http://dev.w3.org/csswg/cssom-view/)
        // Gecko:
        //    - they tried to implement it once, but failed: https://bugzilla.mozilla.org/show_bug.cgi?id=654352
        //    - however, they do give out rangeParent/rangeOffset properties on mouse events
        // Webkit:
        //    - they have implemented a previous version of the spec which was using document.caretRangeFromPoint
        // IE:
        //    - they have a proprietary method on ranges, moveToPoint: https://msdn.microsoft.com/en-us/library/ie/ms536632(v=vs.85).aspx
        // 24.08.2016: Edge has added WebKit's document.caretRangeFromPoint, but it is quite buggy
        //    - when hit testing the cursor it returns the first or the last line in the viewport
        //    - it inconsistently hits text nodes or span nodes, while WebKit only hits text nodes
        //    - when toggling render whitespace on, and hit testing in the empty content after a line, it always hits offset 0 of the first span of the line
        // Thank you browsers for making this so 'easy' :)
        if (document.caretRangeFromPoint) {
            return this._doHitTestWithCaretRangeFromPoint(ctx, request);
        }
        else if (document.caretPositionFromPoint) {
            return this._doHitTestWithCaretPositionFromPoint(ctx, request.pos.toClientCoordinates());
        }
        else if (document.body.createTextRange) {
            return this._doHitTestWithMoveToPoint(ctx, request.pos.toClientCoordinates());
        }
        return {
            position: null,
            hitTarget: null
        };
    };
    return MouseTargetFactory;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$y = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * Merges mouse events when mouse move events are throttled
 */
function createMouseMoveEventMerger(mouseTargetFactory) {
    return function (lastEvent, currentEvent) {
        var targetIsWidget = false;
        if (mouseTargetFactory) {
            targetIsWidget = mouseTargetFactory.mouseTargetIsWidget(currentEvent);
        }
        if (!targetIsWidget) {
            currentEvent.preventDefault();
        }
        return currentEvent;
    };
}
var MouseHandler = /** @class */ (function (_super) {
    __extends$y(MouseHandler, _super);
    function MouseHandler(context, viewController, viewHelper) {
        var _this = _super.call(this) || this;
        _this._isFocused = false;
        _this._context = context;
        _this.viewController = viewController;
        _this.viewHelper = viewHelper;
        _this.mouseTargetFactory = new MouseTargetFactory(_this._context, viewHelper);
        _this._mouseDownOperation = _this._register(new MouseDownOperation(_this._context, _this.viewController, _this.viewHelper, function (e, testEventTarget) { return _this._createMouseTarget(e, testEventTarget); }, function (e) { return _this._getMouseColumn(e); }));
        _this._asyncFocus = _this._register(new RunOnceScheduler(function () { return _this.viewHelper.focusTextArea(); }, 0));
        _this.lastMouseLeaveTime = -1;
        var mouseEvents = new EditorMouseEventFactory(_this.viewHelper.viewDomNode);
        _this._register(mouseEvents.onContextMenu(_this.viewHelper.viewDomNode, function (e) { return _this._onContextMenu(e, true); }));
        _this._register(mouseEvents.onMouseMoveThrottled(_this.viewHelper.viewDomNode, function (e) { return _this._onMouseMove(e); }, createMouseMoveEventMerger(_this.mouseTargetFactory), MouseHandler.MOUSE_MOVE_MINIMUM_TIME));
        _this._register(mouseEvents.onMouseUp(_this.viewHelper.viewDomNode, function (e) { return _this._onMouseUp(e); }));
        _this._register(mouseEvents.onMouseLeave(_this.viewHelper.viewDomNode, function (e) { return _this._onMouseLeave(e); }));
        _this._register(mouseEvents.onMouseDown(_this.viewHelper.viewDomNode, function (e) { return _this._onMouseDown(e); }));
        var onMouseWheel = function (browserEvent) {
            if (!_this._context.configuration.editor.viewInfo.mouseWheelZoom) {
                return;
            }
            var e = new StandardMouseWheelEvent(browserEvent);
            if (e.browserEvent.ctrlKey || e.browserEvent.metaKey) {
                var zoomLevel = EditorZoom.getZoomLevel();
                var delta = e.deltaY > 0 ? 1 : -1;
                EditorZoom.setZoomLevel(zoomLevel + delta);
                e.preventDefault();
                e.stopPropagation();
            }
        };
        _this._register(addDisposableListener(_this.viewHelper.viewDomNode, 'mousewheel', onMouseWheel, true));
        _this._register(addDisposableListener(_this.viewHelper.viewDomNode, 'DOMMouseScroll', onMouseWheel, true));
        _this._context.addEventHandler(_this);
        return _this;
    }
    MouseHandler.prototype.dispose = function () {
        this._context.removeEventHandler(this);
        _super.prototype.dispose.call(this);
    };
    // --- begin event handlers
    MouseHandler.prototype.onCursorStateChanged = function (e) {
        this._mouseDownOperation.onCursorStateChanged(e);
        return false;
    };
    MouseHandler.prototype.onFocusChanged = function (e) {
        this._isFocused = e.isFocused;
        return false;
    };
    MouseHandler.prototype.onScrollChanged = function (e) {
        this._mouseDownOperation.onScrollChanged();
        return false;
    };
    // --- end event handlers
    MouseHandler.prototype.getTargetAtClientPoint = function (clientX, clientY) {
        var clientPos = new ClientCoordinates(clientX, clientY);
        var pos = clientPos.toPageCoordinates();
        var editorPos = createEditorPagePosition(this.viewHelper.viewDomNode);
        if (pos.y < editorPos.y || pos.y > editorPos.y + editorPos.height || pos.x < editorPos.x || pos.x > editorPos.x + editorPos.width) {
            return null;
        }
        var lastViewCursorsRenderData = this.viewHelper.getLastViewCursorsRenderData();
        return this.mouseTargetFactory.createMouseTarget(lastViewCursorsRenderData, editorPos, pos, null);
    };
    MouseHandler.prototype._createMouseTarget = function (e, testEventTarget) {
        var lastViewCursorsRenderData = this.viewHelper.getLastViewCursorsRenderData();
        return this.mouseTargetFactory.createMouseTarget(lastViewCursorsRenderData, e.editorPos, e.pos, testEventTarget ? e.target : null);
    };
    MouseHandler.prototype._getMouseColumn = function (e) {
        return this.mouseTargetFactory.getMouseColumn(e.editorPos, e.pos);
    };
    MouseHandler.prototype._onContextMenu = function (e, testEventTarget) {
        this.viewController.emitContextMenu({
            event: e,
            target: this._createMouseTarget(e, testEventTarget)
        });
    };
    MouseHandler.prototype._onMouseMove = function (e) {
        if (this._mouseDownOperation.isActive()) {
            // In selection/drag operation
            return;
        }
        var actualMouseMoveTime = e.timestamp;
        if (actualMouseMoveTime < this.lastMouseLeaveTime) {
            // Due to throttling, this event occurred before the mouse left the editor, therefore ignore it.
            return;
        }
        this.viewController.emitMouseMove({
            event: e,
            target: this._createMouseTarget(e, true)
        });
    };
    MouseHandler.prototype._onMouseLeave = function (e) {
        this.lastMouseLeaveTime = (new Date()).getTime();
        this.viewController.emitMouseLeave({
            event: e,
            target: null
        });
    };
    MouseHandler.prototype._onMouseUp = function (e) {
        this.viewController.emitMouseUp({
            event: e,
            target: this._createMouseTarget(e, true)
        });
    };
    MouseHandler.prototype._onMouseDown = function (e) {
        var _this = this;
        var t = this._createMouseTarget(e, true);
        var targetIsContent = (t.type === MouseTargetType.CONTENT_TEXT || t.type === MouseTargetType.CONTENT_EMPTY);
        var targetIsGutter = (t.type === MouseTargetType.GUTTER_GLYPH_MARGIN || t.type === MouseTargetType.GUTTER_LINE_NUMBERS || t.type === MouseTargetType.GUTTER_LINE_DECORATIONS);
        var targetIsLineNumbers = (t.type === MouseTargetType.GUTTER_LINE_NUMBERS);
        var selectOnLineNumbers = this._context.configuration.editor.viewInfo.selectOnLineNumbers;
        var targetIsViewZone = (t.type === MouseTargetType.CONTENT_VIEW_ZONE || t.type === MouseTargetType.GUTTER_VIEW_ZONE);
        var targetIsWidget = (t.type === MouseTargetType.CONTENT_WIDGET);
        var shouldHandle = e.leftButton || e.middleButton;
        if (isMacintosh && e.leftButton && e.ctrlKey) {
            shouldHandle = false;
        }
        var focus = function () {
            // In IE11, if the focus is in the browser's address bar and
            // then you click in the editor, calling preventDefault()
            // will not move focus properly (focus remains the address bar)
            if (isIE && !_this._isFocused) {
                _this._asyncFocus.schedule();
            }
            else {
                e.preventDefault();
                _this.viewHelper.focusTextArea();
            }
        };
        if (shouldHandle && (targetIsContent || (targetIsLineNumbers && selectOnLineNumbers))) {
            focus();
            this._mouseDownOperation.start(t.type, e);
        }
        else if (targetIsGutter) {
            // Do not steal focus
            e.preventDefault();
        }
        else if (targetIsViewZone) {
            var viewZoneData = t.detail;
            if (this.viewHelper.shouldSuppressMouseDownOnViewZone(viewZoneData.viewZoneId)) {
                focus();
                this._mouseDownOperation.start(t.type, e);
                e.preventDefault();
            }
        }
        else if (targetIsWidget && this.viewHelper.shouldSuppressMouseDownOnWidget(t.detail)) {
            focus();
            e.preventDefault();
        }
        this.viewController.emitMouseDown({
            event: e,
            target: t
        });
    };
    MouseHandler.MOUSE_MOVE_MINIMUM_TIME = 100; // ms
    return MouseHandler;
}(ViewEventHandler));
var MouseDownOperation = /** @class */ (function (_super) {
    __extends$y(MouseDownOperation, _super);
    function MouseDownOperation(context, viewController, viewHelper, createMouseTarget, getMouseColumn) {
        var _this = _super.call(this) || this;
        _this._context = context;
        _this._viewController = viewController;
        _this._viewHelper = viewHelper;
        _this._createMouseTarget = createMouseTarget;
        _this._getMouseColumn = getMouseColumn;
        _this._mouseMoveMonitor = _this._register(new GlobalEditorMouseMoveMonitor(_this._viewHelper.viewDomNode));
        _this._onScrollTimeout = _this._register(new TimeoutTimer());
        _this._mouseState = new MouseDownState();
        _this._currentSelection = new Selection(1, 1, 1, 1);
        _this._isActive = false;
        _this._lastMouseEvent = null;
        return _this;
    }
    MouseDownOperation.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
    };
    MouseDownOperation.prototype.isActive = function () {
        return this._isActive;
    };
    MouseDownOperation.prototype._onMouseDownThenMove = function (e) {
        this._lastMouseEvent = e;
        this._mouseState.setModifiers(e);
        var position$$1 = this._findMousePosition(e, true);
        if (!position$$1) {
            // Ignoring because position is unknown
            return;
        }
        if (this._mouseState.isDragAndDrop) {
            this._viewController.emitMouseDrag({
                event: e,
                target: position$$1
            });
        }
        else {
            this._dispatchMouse(position$$1, true);
        }
    };
    MouseDownOperation.prototype.start = function (targetType, e) {
        var _this = this;
        this._lastMouseEvent = e;
        this._mouseState.setStartedOnLineNumbers(targetType === MouseTargetType.GUTTER_LINE_NUMBERS);
        this._mouseState.setStartButtons(e);
        this._mouseState.setModifiers(e);
        var position$$1 = this._findMousePosition(e, true);
        if (!position$$1) {
            // Ignoring because position is unknown
            return;
        }
        this._mouseState.trySetCount(e.detail, position$$1.position);
        // Overwrite the detail of the MouseEvent, as it will be sent out in an event and contributions might rely on it.
        e.detail = this._mouseState.count;
        if (!this._context.configuration.editor.readOnly
            && this._context.configuration.editor.dragAndDrop
            && !this._mouseState.altKey // we don't support multiple mouse
            && e.detail < 2 // only single click on a selection can work
            && !this._isActive // the mouse is not down yet
            && !this._currentSelection.isEmpty() // we don't drag single cursor
            && this._currentSelection.containsPosition(position$$1.position) // single click on a selection
        ) {
            this._mouseState.isDragAndDrop = true;
            this._isActive = true;
            this._mouseMoveMonitor.startMonitoring(createMouseMoveEventMerger(null), function (e) { return _this._onMouseDownThenMove(e); }, function () {
                var position$$1 = _this._findMousePosition(_this._lastMouseEvent, true);
                _this._viewController.emitMouseDrop({
                    event: _this._lastMouseEvent,
                    target: position$$1 ? _this._createMouseTarget(_this._lastMouseEvent, true) : null // Ignoring because position is unknown, e.g., Content View Zone
                });
                _this._stop();
            });
            return;
        }
        this._mouseState.isDragAndDrop = false;
        this._dispatchMouse(position$$1, e.shiftKey);
        if (!this._isActive) {
            this._isActive = true;
            this._mouseMoveMonitor.startMonitoring(createMouseMoveEventMerger(null), function (e) { return _this._onMouseDownThenMove(e); }, function () { return _this._stop(); });
        }
    };
    MouseDownOperation.prototype._stop = function () {
        this._isActive = false;
        this._onScrollTimeout.cancel();
    };
    MouseDownOperation.prototype.onScrollChanged = function () {
        var _this = this;
        if (!this._isActive) {
            return;
        }
        this._onScrollTimeout.setIfNotSet(function () {
            var position$$1 = _this._findMousePosition(_this._lastMouseEvent, false);
            if (!position$$1) {
                // Ignoring because position is unknown
                return;
            }
            if (_this._mouseState.isDragAndDrop) {
                // Ignoring because users are dragging the text
                return;
            }
            _this._dispatchMouse(position$$1, true);
        }, 10);
    };
    MouseDownOperation.prototype.onCursorStateChanged = function (e) {
        this._currentSelection = e.selections[0];
    };
    MouseDownOperation.prototype._getPositionOutsideEditor = function (e) {
        var editorContent = e.editorPos;
        var model = this._context.model;
        var viewLayout = this._context.viewLayout;
        var mouseColumn = this._getMouseColumn(e);
        if (e.posy < editorContent.y) {
            var verticalOffset = Math.max(viewLayout.getCurrentScrollTop() - (editorContent.y - e.posy), 0);
            var viewZoneData = HitTestContext.getZoneAtCoord(this._context, verticalOffset);
            if (viewZoneData) {
                var newPosition = this._helpPositionJumpOverViewZone(viewZoneData);
                if (newPosition) {
                    return new MouseTarget(null, MouseTargetType.OUTSIDE_EDITOR, mouseColumn, newPosition);
                }
            }
            var aboveLineNumber = viewLayout.getLineNumberAtVerticalOffset(verticalOffset);
            return new MouseTarget(null, MouseTargetType.OUTSIDE_EDITOR, mouseColumn, new Position(aboveLineNumber, 1));
        }
        if (e.posy > editorContent.y + editorContent.height) {
            var verticalOffset = viewLayout.getCurrentScrollTop() + (e.posy - editorContent.y);
            var viewZoneData = HitTestContext.getZoneAtCoord(this._context, verticalOffset);
            if (viewZoneData) {
                var newPosition = this._helpPositionJumpOverViewZone(viewZoneData);
                if (newPosition) {
                    return new MouseTarget(null, MouseTargetType.OUTSIDE_EDITOR, mouseColumn, newPosition);
                }
            }
            var belowLineNumber = viewLayout.getLineNumberAtVerticalOffset(verticalOffset);
            return new MouseTarget(null, MouseTargetType.OUTSIDE_EDITOR, mouseColumn, new Position(belowLineNumber, model.getLineMaxColumn(belowLineNumber)));
        }
        var possibleLineNumber = viewLayout.getLineNumberAtVerticalOffset(viewLayout.getCurrentScrollTop() + (e.posy - editorContent.y));
        if (e.posx < editorContent.x) {
            return new MouseTarget(null, MouseTargetType.OUTSIDE_EDITOR, mouseColumn, new Position(possibleLineNumber, 1));
        }
        if (e.posx > editorContent.x + editorContent.width) {
            return new MouseTarget(null, MouseTargetType.OUTSIDE_EDITOR, mouseColumn, new Position(possibleLineNumber, model.getLineMaxColumn(possibleLineNumber)));
        }
        return null;
    };
    MouseDownOperation.prototype._findMousePosition = function (e, testEventTarget) {
        var positionOutsideEditor = this._getPositionOutsideEditor(e);
        if (positionOutsideEditor) {
            return positionOutsideEditor;
        }
        var t = this._createMouseTarget(e, testEventTarget);
        var hintedPosition = t.position;
        if (!hintedPosition) {
            return null;
        }
        if (t.type === MouseTargetType.CONTENT_VIEW_ZONE || t.type === MouseTargetType.GUTTER_VIEW_ZONE) {
            var newPosition = this._helpPositionJumpOverViewZone(t.detail);
            if (newPosition) {
                return new MouseTarget(t.element, t.type, t.mouseColumn, newPosition, null, t.detail);
            }
        }
        return t;
    };
    MouseDownOperation.prototype._helpPositionJumpOverViewZone = function (viewZoneData) {
        // Force position on view zones to go above or below depending on where selection started from
        var selectionStart = new Position(this._currentSelection.selectionStartLineNumber, this._currentSelection.selectionStartColumn);
        var positionBefore = viewZoneData.positionBefore;
        var positionAfter = viewZoneData.positionAfter;
        if (positionBefore && positionAfter) {
            if (positionBefore.isBefore(selectionStart)) {
                return positionBefore;
            }
            else {
                return positionAfter;
            }
        }
        return null;
    };
    MouseDownOperation.prototype._dispatchMouse = function (position$$1, inSelectionMode) {
        this._viewController.dispatchMouse({
            position: position$$1.position,
            mouseColumn: position$$1.mouseColumn,
            startedOnLineNumbers: this._mouseState.startedOnLineNumbers,
            inSelectionMode: inSelectionMode,
            mouseDownCount: this._mouseState.count,
            altKey: this._mouseState.altKey,
            ctrlKey: this._mouseState.ctrlKey,
            metaKey: this._mouseState.metaKey,
            shiftKey: this._mouseState.shiftKey,
            leftButton: this._mouseState.leftButton,
            middleButton: this._mouseState.middleButton,
        });
    };
    return MouseDownOperation;
}(Disposable));
var MouseDownState = /** @class */ (function () {
    function MouseDownState() {
        this._altKey = false;
        this._ctrlKey = false;
        this._metaKey = false;
        this._shiftKey = false;
        this._leftButton = false;
        this._middleButton = false;
        this._startedOnLineNumbers = false;
        this._lastMouseDownPosition = null;
        this._lastMouseDownPositionEqualCount = 0;
        this._lastMouseDownCount = 0;
        this._lastSetMouseDownCountTime = 0;
        this.isDragAndDrop = false;
    }
    Object.defineProperty(MouseDownState.prototype, "altKey", {
        get: function () { return this._altKey; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MouseDownState.prototype, "ctrlKey", {
        get: function () { return this._ctrlKey; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MouseDownState.prototype, "metaKey", {
        get: function () { return this._metaKey; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MouseDownState.prototype, "shiftKey", {
        get: function () { return this._shiftKey; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MouseDownState.prototype, "leftButton", {
        get: function () { return this._leftButton; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MouseDownState.prototype, "middleButton", {
        get: function () { return this._middleButton; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MouseDownState.prototype, "startedOnLineNumbers", {
        get: function () { return this._startedOnLineNumbers; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MouseDownState.prototype, "count", {
        get: function () {
            return this._lastMouseDownCount;
        },
        enumerable: true,
        configurable: true
    });
    MouseDownState.prototype.setModifiers = function (source) {
        this._altKey = source.altKey;
        this._ctrlKey = source.ctrlKey;
        this._metaKey = source.metaKey;
        this._shiftKey = source.shiftKey;
    };
    MouseDownState.prototype.setStartButtons = function (source) {
        this._leftButton = source.leftButton;
        this._middleButton = source.middleButton;
    };
    MouseDownState.prototype.setStartedOnLineNumbers = function (startedOnLineNumbers) {
        this._startedOnLineNumbers = startedOnLineNumbers;
    };
    MouseDownState.prototype.trySetCount = function (setMouseDownCount, newMouseDownPosition) {
        // a. Invalidate multiple clicking if too much time has passed (will be hit by IE because the detail field of mouse events contains garbage in IE10)
        var currentTime = (new Date()).getTime();
        if (currentTime - this._lastSetMouseDownCountTime > MouseDownState.CLEAR_MOUSE_DOWN_COUNT_TIME) {
            setMouseDownCount = 1;
        }
        this._lastSetMouseDownCountTime = currentTime;
        // b. Ensure that we don't jump from single click to triple click in one go (will be hit by IE because the detail field of mouse events contains garbage in IE10)
        if (setMouseDownCount > this._lastMouseDownCount + 1) {
            setMouseDownCount = this._lastMouseDownCount + 1;
        }
        // c. Invalidate multiple clicking if the logical position is different
        if (this._lastMouseDownPosition && this._lastMouseDownPosition.equals(newMouseDownPosition)) {
            this._lastMouseDownPositionEqualCount++;
        }
        else {
            this._lastMouseDownPositionEqualCount = 1;
        }
        this._lastMouseDownPosition = newMouseDownPosition;
        // Finally set the lastMouseDownCount
        this._lastMouseDownCount = Math.min(setMouseDownCount, this._lastMouseDownPositionEqualCount);
    };
    MouseDownState.CLEAR_MOUSE_DOWN_COUNT_TIME = 400; // ms
    return MouseDownState;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$z = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
function gestureChangeEventMerger(lastEvent, currentEvent) {
    var r = {
        translationY: currentEvent.translationY,
        translationX: currentEvent.translationX
    };
    if (lastEvent) {
        r.translationY += lastEvent.translationY;
        r.translationX += lastEvent.translationX;
    }
    return r;
}
/**
 * Basically IE10 and IE11
 */
var MsPointerHandler = /** @class */ (function (_super) {
    __extends$z(MsPointerHandler, _super);
    function MsPointerHandler(context, viewController, viewHelper) {
        var _this = _super.call(this, context, viewController, viewHelper) || this;
        _this.viewHelper.linesContentDomNode.style.msTouchAction = 'none';
        _this.viewHelper.linesContentDomNode.style.msContentZooming = 'none';
        // TODO@Alex -> this expects that the view is added in 100 ms, might not be the case
        // This handler should be added when the dom node is in the dom tree
        _this._installGestureHandlerTimeout = window.setTimeout(function () {
            _this._installGestureHandlerTimeout = -1;
            if (window.MSGesture) {
                var touchGesture_1 = new MSGesture();
                var penGesture_1 = new MSGesture();
                touchGesture_1.target = _this.viewHelper.linesContentDomNode;
                penGesture_1.target = _this.viewHelper.linesContentDomNode;
                _this.viewHelper.linesContentDomNode.addEventListener('MSPointerDown', function (e) {
                    // Circumvent IE11 breaking change in e.pointerType & TypeScript's stale definitions
                    var pointerType = e.pointerType;
                    if (pointerType === (e.MSPOINTER_TYPE_MOUSE || 'mouse')) {
                        _this._lastPointerType = 'mouse';
                        return;
                    }
                    else if (pointerType === (e.MSPOINTER_TYPE_TOUCH || 'touch')) {
                        _this._lastPointerType = 'touch';
                        touchGesture_1.addPointer(e.pointerId);
                    }
                    else {
                        _this._lastPointerType = 'pen';
                        penGesture_1.addPointer(e.pointerId);
                    }
                });
                _this._register(addDisposableThrottledListener(_this.viewHelper.linesContentDomNode, 'MSGestureChange', function (e) { return _this._onGestureChange(e); }, gestureChangeEventMerger));
                _this._register(addDisposableListener(_this.viewHelper.linesContentDomNode, 'MSGestureTap', function (e) { return _this._onCaptureGestureTap(e); }, true));
            }
        }, 100);
        _this._lastPointerType = 'mouse';
        return _this;
    }
    MsPointerHandler.prototype._onMouseDown = function (e) {
        if (this._lastPointerType === 'mouse') {
            _super.prototype._onMouseDown.call(this, e);
        }
    };
    MsPointerHandler.prototype._onCaptureGestureTap = function (rawEvent) {
        var _this = this;
        var e = new EditorMouseEvent(rawEvent, this.viewHelper.viewDomNode);
        var t = this._createMouseTarget(e, false);
        if (t.position) {
            this.viewController.moveTo(t.position);
        }
        // IE does not want to focus when coming in from the browser's address bar
        if (e.browserEvent.fromElement) {
            e.preventDefault();
            this.viewHelper.focusTextArea();
        }
        else {
            // TODO@Alex -> cancel this is focus is lost
            setTimeout(function () {
                _this.viewHelper.focusTextArea();
            });
        }
    };
    MsPointerHandler.prototype._onGestureChange = function (e) {
        this._context.viewLayout.deltaScrollNow(-e.translationX, -e.translationY);
    };
    MsPointerHandler.prototype.dispose = function () {
        window.clearTimeout(this._installGestureHandlerTimeout);
        _super.prototype.dispose.call(this);
    };
    return MsPointerHandler;
}(MouseHandler));
/**
 * Basically Edge but should be modified to handle any pointerEnabled, even without support of MSGesture
 */
var StandardPointerHandler = /** @class */ (function (_super) {
    __extends$z(StandardPointerHandler, _super);
    function StandardPointerHandler(context, viewController, viewHelper) {
        var _this = _super.call(this, context, viewController, viewHelper) || this;
        _this.viewHelper.linesContentDomNode.style.touchAction = 'none';
        // TODO@Alex -> this expects that the view is added in 100 ms, might not be the case
        // This handler should be added when the dom node is in the dom tree
        _this._installGestureHandlerTimeout = window.setTimeout(function () {
            _this._installGestureHandlerTimeout = -1;
            // TODO@Alex: replace the usage of MSGesture here with something that works across all browsers
            if (window.MSGesture) {
                var touchGesture_2 = new MSGesture();
                var penGesture_2 = new MSGesture();
                touchGesture_2.target = _this.viewHelper.linesContentDomNode;
                penGesture_2.target = _this.viewHelper.linesContentDomNode;
                _this.viewHelper.linesContentDomNode.addEventListener('pointerdown', function (e) {
                    var pointerType = e.pointerType;
                    if (pointerType === 'mouse') {
                        _this._lastPointerType = 'mouse';
                        return;
                    }
                    else if (pointerType === 'touch') {
                        _this._lastPointerType = 'touch';
                        touchGesture_2.addPointer(e.pointerId);
                    }
                    else {
                        _this._lastPointerType = 'pen';
                        penGesture_2.addPointer(e.pointerId);
                    }
                });
                _this._register(addDisposableThrottledListener(_this.viewHelper.linesContentDomNode, 'MSGestureChange', function (e) { return _this._onGestureChange(e); }, gestureChangeEventMerger));
                _this._register(addDisposableListener(_this.viewHelper.linesContentDomNode, 'MSGestureTap', function (e) { return _this._onCaptureGestureTap(e); }, true));
            }
        }, 100);
        _this._lastPointerType = 'mouse';
        return _this;
    }
    StandardPointerHandler.prototype._onMouseDown = function (e) {
        if (this._lastPointerType === 'mouse') {
            _super.prototype._onMouseDown.call(this, e);
        }
    };
    StandardPointerHandler.prototype._onCaptureGestureTap = function (rawEvent) {
        var _this = this;
        var e = new EditorMouseEvent(rawEvent, this.viewHelper.viewDomNode);
        var t = this._createMouseTarget(e, false);
        if (t.position) {
            this.viewController.moveTo(t.position);
        }
        // IE does not want to focus when coming in from the browser's address bar
        if (e.browserEvent.fromElement) {
            e.preventDefault();
            this.viewHelper.focusTextArea();
        }
        else {
            // TODO@Alex -> cancel this is focus is lost
            setTimeout(function () {
                _this.viewHelper.focusTextArea();
            });
        }
    };
    StandardPointerHandler.prototype._onGestureChange = function (e) {
        this._context.viewLayout.deltaScrollNow(-e.translationX, -e.translationY);
    };
    StandardPointerHandler.prototype.dispose = function () {
        window.clearTimeout(this._installGestureHandlerTimeout);
        _super.prototype.dispose.call(this);
    };
    return StandardPointerHandler;
}(MouseHandler));
var TouchHandler = /** @class */ (function (_super) {
    __extends$z(TouchHandler, _super);
    function TouchHandler(context, viewController, viewHelper) {
        var _this = _super.call(this, context, viewController, viewHelper) || this;
        Gesture.addTarget(_this.viewHelper.linesContentDomNode);
        _this._register(addDisposableListener(_this.viewHelper.linesContentDomNode, EventType$1.Tap, function (e) { return _this.onTap(e); }));
        _this._register(addDisposableListener(_this.viewHelper.linesContentDomNode, EventType$1.Change, function (e) { return _this.onChange(e); }));
        _this._register(addDisposableListener(_this.viewHelper.linesContentDomNode, EventType$1.Contextmenu, function (e) { return _this._onContextMenu(new EditorMouseEvent(e, _this.viewHelper.viewDomNode), false); }));
        return _this;
    }
    TouchHandler.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
    };
    TouchHandler.prototype.onTap = function (event) {
        event.preventDefault();
        this.viewHelper.focusTextArea();
        var target = this._createMouseTarget(new EditorMouseEvent(event, this.viewHelper.viewDomNode), false);
        if (target.position) {
            this.viewController.moveTo(target.position);
        }
    };
    TouchHandler.prototype.onChange = function (e) {
        this._context.viewLayout.deltaScrollNow(-e.translationX, -e.translationY);
    };
    return TouchHandler;
}(MouseHandler));
var PointerHandler = /** @class */ (function () {
    function PointerHandler(context, viewController, viewHelper) {
        if (window.navigator.msPointerEnabled) {
            this.handler = new MsPointerHandler(context, viewController, viewHelper);
        }
        else if (window.TouchEvent) {
            this.handler = new TouchHandler(context, viewController, viewHelper);
        }
        else if (window.navigator.pointerEnabled || window.PointerEvent) {
            this.handler = new StandardPointerHandler(context, viewController, viewHelper);
        }
        else {
            this.handler = new MouseHandler(context, viewController, viewHelper);
        }
    }
    PointerHandler.prototype.getTargetAtClientPoint = function (clientX, clientY) {
        return this.handler.getTargetAtClientPoint(clientX, clientY);
    };
    PointerHandler.prototype.dispose = function () {
        this.handler.dispose();
    };
    return PointerHandler;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var WordOperations = /** @class */ (function () {
    function WordOperations() {
    }
    WordOperations._createWord = function (lineContent, wordType, nextCharClass, start, end) {
        // console.log('WORD ==> ' + start + ' => ' + end + ':::: <<<' + lineContent.substring(start, end) + '>>>');
        return { start: start, end: end, wordType: wordType, nextCharClass: nextCharClass };
    };
    WordOperations._findPreviousWordOnLine = function (wordSeparators, model, position) {
        var lineContent = model.getLineContent(position.lineNumber);
        return this._doFindPreviousWordOnLine(lineContent, wordSeparators, position);
    };
    WordOperations._doFindPreviousWordOnLine = function (lineContent, wordSeparators, position) {
        var wordType = 0 /* None */;
        for (var chIndex = position.column - 2; chIndex >= 0; chIndex--) {
            var chCode = lineContent.charCodeAt(chIndex);
            var chClass = wordSeparators.get(chCode);
            if (chClass === 0 /* Regular */) {
                if (wordType === 2 /* Separator */) {
                    return this._createWord(lineContent, wordType, chClass, chIndex + 1, this._findEndOfWord(lineContent, wordSeparators, wordType, chIndex + 1));
                }
                wordType = 1 /* Regular */;
            }
            else if (chClass === 2 /* WordSeparator */) {
                if (wordType === 1 /* Regular */) {
                    return this._createWord(lineContent, wordType, chClass, chIndex + 1, this._findEndOfWord(lineContent, wordSeparators, wordType, chIndex + 1));
                }
                wordType = 2 /* Separator */;
            }
            else if (chClass === 1 /* Whitespace */) {
                if (wordType !== 0 /* None */) {
                    return this._createWord(lineContent, wordType, chClass, chIndex + 1, this._findEndOfWord(lineContent, wordSeparators, wordType, chIndex + 1));
                }
            }
        }
        if (wordType !== 0 /* None */) {
            return this._createWord(lineContent, wordType, 1 /* Whitespace */, 0, this._findEndOfWord(lineContent, wordSeparators, wordType, 0));
        }
        return null;
    };
    WordOperations._findEndOfWord = function (lineContent, wordSeparators, wordType, startIndex) {
        var len = lineContent.length;
        for (var chIndex = startIndex; chIndex < len; chIndex++) {
            var chCode = lineContent.charCodeAt(chIndex);
            var chClass = wordSeparators.get(chCode);
            if (chClass === 1 /* Whitespace */) {
                return chIndex;
            }
            if (wordType === 1 /* Regular */ && chClass === 2 /* WordSeparator */) {
                return chIndex;
            }
            if (wordType === 2 /* Separator */ && chClass === 0 /* Regular */) {
                return chIndex;
            }
        }
        return len;
    };
    WordOperations._findNextWordOnLine = function (wordSeparators, model, position) {
        var lineContent = model.getLineContent(position.lineNumber);
        return this._doFindNextWordOnLine(lineContent, wordSeparators, position);
    };
    WordOperations._doFindNextWordOnLine = function (lineContent, wordSeparators, position) {
        var wordType = 0 /* None */;
        var len = lineContent.length;
        for (var chIndex = position.column - 1; chIndex < len; chIndex++) {
            var chCode = lineContent.charCodeAt(chIndex);
            var chClass = wordSeparators.get(chCode);
            if (chClass === 0 /* Regular */) {
                if (wordType === 2 /* Separator */) {
                    return this._createWord(lineContent, wordType, chClass, this._findStartOfWord(lineContent, wordSeparators, wordType, chIndex - 1), chIndex);
                }
                wordType = 1 /* Regular */;
            }
            else if (chClass === 2 /* WordSeparator */) {
                if (wordType === 1 /* Regular */) {
                    return this._createWord(lineContent, wordType, chClass, this._findStartOfWord(lineContent, wordSeparators, wordType, chIndex - 1), chIndex);
                }
                wordType = 2 /* Separator */;
            }
            else if (chClass === 1 /* Whitespace */) {
                if (wordType !== 0 /* None */) {
                    return this._createWord(lineContent, wordType, chClass, this._findStartOfWord(lineContent, wordSeparators, wordType, chIndex - 1), chIndex);
                }
            }
        }
        if (wordType !== 0 /* None */) {
            return this._createWord(lineContent, wordType, 1 /* Whitespace */, this._findStartOfWord(lineContent, wordSeparators, wordType, len - 1), len);
        }
        return null;
    };
    WordOperations._findStartOfWord = function (lineContent, wordSeparators, wordType, startIndex) {
        for (var chIndex = startIndex; chIndex >= 0; chIndex--) {
            var chCode = lineContent.charCodeAt(chIndex);
            var chClass = wordSeparators.get(chCode);
            if (chClass === 1 /* Whitespace */) {
                return chIndex + 1;
            }
            if (wordType === 1 /* Regular */ && chClass === 2 /* WordSeparator */) {
                return chIndex + 1;
            }
            if (wordType === 2 /* Separator */ && chClass === 0 /* Regular */) {
                return chIndex + 1;
            }
        }
        return 0;
    };
    WordOperations.moveWordLeft = function (wordSeparators, model, position, wordNavigationType) {
        var lineNumber = position.lineNumber;
        var column = position.column;
        if (column === 1) {
            if (lineNumber > 1) {
                lineNumber = lineNumber - 1;
                column = model.getLineMaxColumn(lineNumber);
            }
        }
        var prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, column));
        if (wordNavigationType === 0 /* WordStart */) {
            if (prevWordOnLine && prevWordOnLine.wordType === 2 /* Separator */) {
                if (prevWordOnLine.end - prevWordOnLine.start === 1 && prevWordOnLine.nextCharClass === 0 /* Regular */) {
                    // Skip over a word made up of one single separator and followed by a regular character
                    prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, prevWordOnLine.start + 1));
                }
            }
            if (prevWordOnLine) {
                column = prevWordOnLine.start + 1;
            }
            else {
                column = 1;
            }
        }
        else {
            if (prevWordOnLine && column <= prevWordOnLine.end + 1) {
                prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, prevWordOnLine.start + 1));
            }
            if (prevWordOnLine) {
                column = prevWordOnLine.end + 1;
            }
            else {
                column = 1;
            }
        }
        return new Position(lineNumber, column);
    };
    WordOperations.moveWordRight = function (wordSeparators, model, position, wordNavigationType) {
        var lineNumber = position.lineNumber;
        var column = position.column;
        if (column === model.getLineMaxColumn(lineNumber)) {
            if (lineNumber < model.getLineCount()) {
                lineNumber = lineNumber + 1;
                column = 1;
            }
        }
        var nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, column));
        if (wordNavigationType === 1 /* WordEnd */) {
            if (nextWordOnLine && nextWordOnLine.wordType === 2 /* Separator */) {
                if (nextWordOnLine.end - nextWordOnLine.start === 1 && nextWordOnLine.nextCharClass === 0 /* Regular */) {
                    // Skip over a word made up of one single separator and followed by a regular character
                    nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, nextWordOnLine.end + 1));
                }
            }
            if (nextWordOnLine) {
                column = nextWordOnLine.end + 1;
            }
            else {
                column = model.getLineMaxColumn(lineNumber);
            }
        }
        else {
            if (nextWordOnLine && column >= nextWordOnLine.start + 1) {
                nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, nextWordOnLine.end + 1));
            }
            if (nextWordOnLine) {
                column = nextWordOnLine.start + 1;
            }
            else {
                column = model.getLineMaxColumn(lineNumber);
            }
        }
        return new Position(lineNumber, column);
    };
    WordOperations._deleteWordLeftWhitespace = function (model, position) {
        var lineContent = model.getLineContent(position.lineNumber);
        var startIndex = position.column - 2;
        var lastNonWhitespace = lastNonWhitespaceIndex(lineContent, startIndex);
        if (lastNonWhitespace + 1 < startIndex) {
            return new Range(position.lineNumber, lastNonWhitespace + 2, position.lineNumber, position.column);
        }
        return null;
    };
    WordOperations.deleteWordLeft = function (wordSeparators, model, selection, whitespaceHeuristics, wordNavigationType) {
        if (!selection.isEmpty()) {
            return selection;
        }
        var position = new Position(selection.positionLineNumber, selection.positionColumn);
        var lineNumber = position.lineNumber;
        var column = position.column;
        if (lineNumber === 1 && column === 1) {
            // Ignore deleting at beginning of file
            return null;
        }
        if (whitespaceHeuristics) {
            var r = this._deleteWordLeftWhitespace(model, position);
            if (r) {
                return r;
            }
        }
        var prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);
        if (wordNavigationType === 0 /* WordStart */) {
            if (prevWordOnLine) {
                column = prevWordOnLine.start + 1;
            }
            else {
                if (column > 1) {
                    column = 1;
                }
                else {
                    lineNumber--;
                    column = model.getLineMaxColumn(lineNumber);
                }
            }
        }
        else {
            if (prevWordOnLine && column <= prevWordOnLine.end + 1) {
                prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, prevWordOnLine.start + 1));
            }
            if (prevWordOnLine) {
                column = prevWordOnLine.end + 1;
            }
            else {
                if (column > 1) {
                    column = 1;
                }
                else {
                    lineNumber--;
                    column = model.getLineMaxColumn(lineNumber);
                }
            }
        }
        return new Range(lineNumber, column, position.lineNumber, position.column);
    };
    WordOperations._findFirstNonWhitespaceChar = function (str, startIndex) {
        var len = str.length;
        for (var chIndex = startIndex; chIndex < len; chIndex++) {
            var ch = str.charAt(chIndex);
            if (ch !== ' ' && ch !== '\t') {
                return chIndex;
            }
        }
        return len;
    };
    WordOperations._deleteWordRightWhitespace = function (model, position) {
        var lineContent = model.getLineContent(position.lineNumber);
        var startIndex = position.column - 1;
        var firstNonWhitespace = this._findFirstNonWhitespaceChar(lineContent, startIndex);
        if (startIndex + 1 < firstNonWhitespace) {
            // bingo
            return new Range(position.lineNumber, position.column, position.lineNumber, firstNonWhitespace + 1);
        }
        return null;
    };
    WordOperations.deleteWordRight = function (wordSeparators, model, selection, whitespaceHeuristics, wordNavigationType) {
        if (!selection.isEmpty()) {
            return selection;
        }
        var position = new Position(selection.positionLineNumber, selection.positionColumn);
        var lineNumber = position.lineNumber;
        var column = position.column;
        var lineCount = model.getLineCount();
        var maxColumn = model.getLineMaxColumn(lineNumber);
        if (lineNumber === lineCount && column === maxColumn) {
            // Ignore deleting at end of file
            return null;
        }
        if (whitespaceHeuristics) {
            var r = this._deleteWordRightWhitespace(model, position);
            if (r) {
                return r;
            }
        }
        var nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, position);
        if (wordNavigationType === 1 /* WordEnd */) {
            if (nextWordOnLine) {
                column = nextWordOnLine.end + 1;
            }
            else {
                if (column < maxColumn || lineNumber === lineCount) {
                    column = maxColumn;
                }
                else {
                    lineNumber++;
                    nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, 1));
                    if (nextWordOnLine) {
                        column = nextWordOnLine.start + 1;
                    }
                    else {
                        column = model.getLineMaxColumn(lineNumber);
                    }
                }
            }
        }
        else {
            if (nextWordOnLine && column >= nextWordOnLine.start + 1) {
                nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, nextWordOnLine.end + 1));
            }
            if (nextWordOnLine) {
                column = nextWordOnLine.start + 1;
            }
            else {
                if (column < maxColumn || lineNumber === lineCount) {
                    column = maxColumn;
                }
                else {
                    lineNumber++;
                    nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, 1));
                    if (nextWordOnLine) {
                        column = nextWordOnLine.start + 1;
                    }
                    else {
                        column = model.getLineMaxColumn(lineNumber);
                    }
                }
            }
        }
        return new Range(lineNumber, column, position.lineNumber, position.column);
    };
    WordOperations.word = function (config, model, cursor, inSelectionMode, position) {
        var wordSeparators = getMapForWordSeparators(config.wordSeparators);
        var prevWord = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);
        var nextWord = WordOperations._findNextWordOnLine(wordSeparators, model, position);
        if (!inSelectionMode) {
            // Entering word selection for the first time
            var isTouchingPrevWord = (prevWord && prevWord.wordType === 1 /* Regular */ && prevWord.start <= position.column - 1 && position.column - 1 <= prevWord.end);
            var isTouchingNextWord = (nextWord && nextWord.wordType === 1 /* Regular */ && nextWord.start <= position.column - 1 && position.column - 1 <= nextWord.end);
            var startColumn_1;
            var endColumn_1;
            if (isTouchingPrevWord) {
                startColumn_1 = prevWord.start + 1;
                endColumn_1 = prevWord.end + 1;
            }
            else if (isTouchingNextWord) {
                startColumn_1 = nextWord.start + 1;
                endColumn_1 = nextWord.end + 1;
            }
            else {
                if (prevWord) {
                    startColumn_1 = prevWord.end + 1;
                }
                else {
                    startColumn_1 = 1;
                }
                if (nextWord) {
                    endColumn_1 = nextWord.start + 1;
                }
                else {
                    endColumn_1 = model.getLineMaxColumn(position.lineNumber);
                }
            }
            return new SingleCursorState(new Range(position.lineNumber, startColumn_1, position.lineNumber, endColumn_1), 0, new Position(position.lineNumber, endColumn_1), 0);
        }
        var isInsidePrevWord = (prevWord && prevWord.wordType === 1 /* Regular */ && prevWord.start < position.column - 1 && position.column - 1 < prevWord.end);
        var isInsideNextWord = (nextWord && nextWord.wordType === 1 /* Regular */ && nextWord.start < position.column - 1 && position.column - 1 < nextWord.end);
        var startColumn;
        var endColumn;
        if (isInsidePrevWord) {
            startColumn = prevWord.start + 1;
            endColumn = prevWord.end + 1;
        }
        else if (isInsideNextWord) {
            startColumn = nextWord.start + 1;
            endColumn = nextWord.end + 1;
        }
        else {
            startColumn = position.column;
            endColumn = position.column;
        }
        var lineNumber = position.lineNumber;
        var column;
        if (cursor.selectionStart.containsPosition(position)) {
            column = cursor.selectionStart.endColumn;
        }
        else if (position.isBeforeOrEqual(cursor.selectionStart.getStartPosition())) {
            column = startColumn;
            var possiblePosition = new Position(lineNumber, column);
            if (cursor.selectionStart.containsPosition(possiblePosition)) {
                column = cursor.selectionStart.endColumn;
            }
        }
        else {
            column = endColumn;
            var possiblePosition = new Position(lineNumber, column);
            if (cursor.selectionStart.containsPosition(possiblePosition)) {
                column = cursor.selectionStart.startColumn;
            }
        }
        return cursor.move(true, lineNumber, column, 0);
    };
    return WordOperations;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var CursorMoveCommands = /** @class */ (function () {
    function CursorMoveCommands() {
    }
    CursorMoveCommands.addCursorDown = function (context, cursors) {
        var result = [], resultLen = 0;
        for (var i = 0, len = cursors.length; i < len; i++) {
            var cursor = cursors[i];
            result[resultLen++] = new CursorState(cursor.modelState, cursor.viewState);
            result[resultLen++] = CursorState.fromViewState(MoveOperations.translateDown(context.config, context.viewModel, cursor.viewState));
        }
        return result;
    };
    CursorMoveCommands.addCursorUp = function (context, cursors) {
        var result = [], resultLen = 0;
        for (var i = 0, len = cursors.length; i < len; i++) {
            var cursor = cursors[i];
            result[resultLen++] = new CursorState(cursor.modelState, cursor.viewState);
            result[resultLen++] = CursorState.fromViewState(MoveOperations.translateUp(context.config, context.viewModel, cursor.viewState));
        }
        return result;
    };
    CursorMoveCommands.moveToBeginningOfLine = function (context, cursors, inSelectionMode) {
        var result = [];
        for (var i = 0, len = cursors.length; i < len; i++) {
            var cursor = cursors[i];
            result[i] = this._moveToLineStart(context, cursor, inSelectionMode);
        }
        return result;
    };
    CursorMoveCommands._moveToLineStart = function (context, cursor, inSelectionMode) {
        var currentViewStateColumn = cursor.viewState.position.column;
        var currentModelStateColumn = cursor.modelState.position.column;
        var isFirstLineOfWrappedLine = currentViewStateColumn === currentModelStateColumn;
        var currentViewStatelineNumber = cursor.viewState.position.lineNumber;
        var firstNonBlankColumn = context.viewModel.getLineFirstNonWhitespaceColumn(currentViewStatelineNumber);
        var isBeginningOfViewLine = currentViewStateColumn === firstNonBlankColumn;
        if (!isFirstLineOfWrappedLine && !isBeginningOfViewLine) {
            return this._moveToLineStartByView(context, cursor, inSelectionMode);
        }
        else {
            return this._moveToLineStartByModel(context, cursor, inSelectionMode);
        }
    };
    CursorMoveCommands._moveToLineStartByView = function (context, cursor, inSelectionMode) {
        return CursorState.fromViewState(MoveOperations.moveToBeginningOfLine(context.config, context.viewModel, cursor.viewState, inSelectionMode));
    };
    CursorMoveCommands._moveToLineStartByModel = function (context, cursor, inSelectionMode) {
        return CursorState.fromModelState(MoveOperations.moveToBeginningOfLine(context.config, context.model, cursor.modelState, inSelectionMode));
    };
    CursorMoveCommands.moveToEndOfLine = function (context, cursors, inSelectionMode) {
        var result = [];
        for (var i = 0, len = cursors.length; i < len; i++) {
            var cursor = cursors[i];
            result[i] = this._moveToLineEnd(context, cursor, inSelectionMode);
        }
        return result;
    };
    CursorMoveCommands._moveToLineEnd = function (context, cursor, inSelectionMode) {
        var viewStatePosition = cursor.viewState.position;
        var viewModelMaxColumn = context.viewModel.getLineMaxColumn(viewStatePosition.lineNumber);
        var isEndOfViewLine = viewStatePosition.column === viewModelMaxColumn;
        var modelStatePosition = cursor.modelState.position;
        var modelMaxColumn = context.model.getLineMaxColumn(modelStatePosition.lineNumber);
        var isEndLineOfWrappedLine = viewModelMaxColumn - viewStatePosition.column === modelMaxColumn - modelStatePosition.column;
        if (isEndOfViewLine || isEndLineOfWrappedLine) {
            return this._moveToLineEndByModel(context, cursor, inSelectionMode);
        }
        else {
            return this._moveToLineEndByView(context, cursor, inSelectionMode);
        }
    };
    CursorMoveCommands._moveToLineEndByView = function (context, cursor, inSelectionMode) {
        return CursorState.fromViewState(MoveOperations.moveToEndOfLine(context.config, context.viewModel, cursor.viewState, inSelectionMode));
    };
    CursorMoveCommands._moveToLineEndByModel = function (context, cursor, inSelectionMode) {
        return CursorState.fromModelState(MoveOperations.moveToEndOfLine(context.config, context.model, cursor.modelState, inSelectionMode));
    };
    CursorMoveCommands.expandLineSelection = function (context, cursors) {
        var result = [];
        for (var i = 0, len = cursors.length; i < len; i++) {
            var cursor = cursors[i];
            var viewSelection = cursor.viewState.selection;
            var startLineNumber = viewSelection.startLineNumber;
            var lineCount = context.viewModel.getLineCount();
            var endLineNumber = viewSelection.endLineNumber;
            var endColumn = void 0;
            if (endLineNumber === lineCount) {
                endColumn = context.viewModel.getLineMaxColumn(lineCount);
            }
            else {
                endLineNumber++;
                endColumn = 1;
            }
            result[i] = CursorState.fromViewState(new SingleCursorState(new Range(startLineNumber, 1, startLineNumber, 1), 0, new Position(endLineNumber, endColumn), 0));
        }
        return result;
    };
    CursorMoveCommands.moveToBeginningOfBuffer = function (context, cursors, inSelectionMode) {
        var result = [];
        for (var i = 0, len = cursors.length; i < len; i++) {
            var cursor = cursors[i];
            result[i] = CursorState.fromModelState(MoveOperations.moveToBeginningOfBuffer(context.config, context.model, cursor.modelState, inSelectionMode));
        }
        return result;
    };
    CursorMoveCommands.moveToEndOfBuffer = function (context, cursors, inSelectionMode) {
        var result = [];
        for (var i = 0, len = cursors.length; i < len; i++) {
            var cursor = cursors[i];
            result[i] = CursorState.fromModelState(MoveOperations.moveToEndOfBuffer(context.config, context.model, cursor.modelState, inSelectionMode));
        }
        return result;
    };
    CursorMoveCommands.selectAll = function (context, cursor) {
        var lineCount = context.model.getLineCount();
        var maxColumn = context.model.getLineMaxColumn(lineCount);
        return CursorState.fromModelState(new SingleCursorState(new Range(1, 1, 1, 1), 0, new Position(lineCount, maxColumn), 0));
    };
    CursorMoveCommands.line = function (context, cursor, inSelectionMode, _position, _viewPosition) {
        var position = context.model.validatePosition(_position);
        var viewPosition = (_viewPosition
            ? context.validateViewPosition(new Position(_viewPosition.lineNumber, _viewPosition.column), position)
            : context.convertModelPositionToViewPosition(position));
        if (!inSelectionMode || !cursor.modelState.hasSelection()) {
            // Entering line selection for the first time
            var lineCount = context.model.getLineCount();
            var selectToLineNumber = position.lineNumber + 1;
            var selectToColumn = 1;
            if (selectToLineNumber > lineCount) {
                selectToLineNumber = lineCount;
                selectToColumn = context.model.getLineMaxColumn(selectToLineNumber);
            }
            return CursorState.fromModelState(new SingleCursorState(new Range(position.lineNumber, 1, selectToLineNumber, selectToColumn), 0, new Position(selectToLineNumber, selectToColumn), 0));
        }
        // Continuing line selection
        var enteringLineNumber = cursor.modelState.selectionStart.getStartPosition().lineNumber;
        if (position.lineNumber < enteringLineNumber) {
            return CursorState.fromViewState(cursor.viewState.move(cursor.modelState.hasSelection(), viewPosition.lineNumber, 1, 0));
        }
        else if (position.lineNumber > enteringLineNumber) {
            var lineCount = context.viewModel.getLineCount();
            var selectToViewLineNumber = viewPosition.lineNumber + 1;
            var selectToViewColumn = 1;
            if (selectToViewLineNumber > lineCount) {
                selectToViewLineNumber = lineCount;
                selectToViewColumn = context.viewModel.getLineMaxColumn(selectToViewLineNumber);
            }
            return CursorState.fromViewState(cursor.viewState.move(cursor.modelState.hasSelection(), selectToViewLineNumber, selectToViewColumn, 0));
        }
        else {
            var endPositionOfSelectionStart = cursor.modelState.selectionStart.getEndPosition();
            return CursorState.fromModelState(cursor.modelState.move(cursor.modelState.hasSelection(), endPositionOfSelectionStart.lineNumber, endPositionOfSelectionStart.column, 0));
        }
    };
    CursorMoveCommands.word = function (context, cursor, inSelectionMode, _position) {
        var position = context.model.validatePosition(_position);
        return CursorState.fromModelState(WordOperations.word(context.config, context.model, cursor.modelState, inSelectionMode, position));
    };
    CursorMoveCommands.cancelSelection = function (context, cursor) {
        if (!cursor.modelState.hasSelection()) {
            return new CursorState(cursor.modelState, cursor.viewState);
        }
        var lineNumber = cursor.viewState.position.lineNumber;
        var column = cursor.viewState.position.column;
        return CursorState.fromViewState(new SingleCursorState(new Range(lineNumber, column, lineNumber, column), 0, new Position(lineNumber, column), 0));
    };
    CursorMoveCommands.moveTo = function (context, cursor, inSelectionMode, _position, _viewPosition) {
        var position = context.model.validatePosition(_position);
        var viewPosition = (_viewPosition
            ? context.validateViewPosition(new Position(_viewPosition.lineNumber, _viewPosition.column), position)
            : context.convertModelPositionToViewPosition(position));
        return CursorState.fromViewState(cursor.viewState.move(inSelectionMode, viewPosition.lineNumber, viewPosition.column, 0));
    };
    CursorMoveCommands.move = function (context, cursors, args) {
        var inSelectionMode = args.select;
        var value = args.value;
        switch (args.direction) {
            case 0 /* Left */: {
                if (args.unit === 4 /* HalfLine */) {
                    // Move left by half the current line length
                    return this._moveHalfLineLeft(context, cursors, inSelectionMode);
                }
                else {
                    // Move left by `moveParams.value` columns
                    return this._moveLeft(context, cursors, inSelectionMode, value);
                }
            }
            case 1 /* Right */: {
                if (args.unit === 4 /* HalfLine */) {
                    // Move right by half the current line length
                    return this._moveHalfLineRight(context, cursors, inSelectionMode);
                }
                else {
                    // Move right by `moveParams.value` columns
                    return this._moveRight(context, cursors, inSelectionMode, value);
                }
            }
            case 2 /* Up */: {
                if (args.unit === 2 /* WrappedLine */) {
                    // Move up by view lines
                    return this._moveUpByViewLines(context, cursors, inSelectionMode, value);
                }
                else {
                    // Move up by model lines
                    return this._moveUpByModelLines(context, cursors, inSelectionMode, value);
                }
            }
            case 3 /* Down */: {
                if (args.unit === 2 /* WrappedLine */) {
                    // Move down by view lines
                    return this._moveDownByViewLines(context, cursors, inSelectionMode, value);
                }
                else {
                    // Move down by model lines
                    return this._moveDownByModelLines(context, cursors, inSelectionMode, value);
                }
            }
            case 4 /* WrappedLineStart */: {
                // Move to the beginning of the current view line
                return this._moveToViewMinColumn(context, cursors, inSelectionMode);
            }
            case 5 /* WrappedLineFirstNonWhitespaceCharacter */: {
                // Move to the first non-whitespace column of the current view line
                return this._moveToViewFirstNonWhitespaceColumn(context, cursors, inSelectionMode);
            }
            case 6 /* WrappedLineColumnCenter */: {
                // Move to the "center" of the current view line
                return this._moveToViewCenterColumn(context, cursors, inSelectionMode);
            }
            case 7 /* WrappedLineEnd */: {
                // Move to the end of the current view line
                return this._moveToViewMaxColumn(context, cursors, inSelectionMode);
            }
            case 8 /* WrappedLineLastNonWhitespaceCharacter */: {
                // Move to the last non-whitespace column of the current view line
                return this._moveToViewLastNonWhitespaceColumn(context, cursors, inSelectionMode);
            }
            case 9 /* ViewPortTop */: {
                // Move to the nth line start in the viewport (from the top)
                var cursor = cursors[0];
                var visibleModelRange = context.getCompletelyVisibleModelRange();
                var modelLineNumber = this._firstLineNumberInRange(context.model, visibleModelRange, value);
                var modelColumn = context.model.getLineFirstNonWhitespaceColumn(modelLineNumber);
                return [this._moveToModelPosition(context, cursor, inSelectionMode, modelLineNumber, modelColumn)];
            }
            case 11 /* ViewPortBottom */: {
                // Move to the nth line start in the viewport (from the bottom)
                var cursor = cursors[0];
                var visibleModelRange = context.getCompletelyVisibleModelRange();
                var modelLineNumber = this._lastLineNumberInRange(context.model, visibleModelRange, value);
                var modelColumn = context.model.getLineFirstNonWhitespaceColumn(modelLineNumber);
                return [this._moveToModelPosition(context, cursor, inSelectionMode, modelLineNumber, modelColumn)];
            }
            case 10 /* ViewPortCenter */: {
                // Move to the line start in the viewport center
                var cursor = cursors[0];
                var visibleModelRange = context.getCompletelyVisibleModelRange();
                var modelLineNumber = Math.round((visibleModelRange.startLineNumber + visibleModelRange.endLineNumber) / 2);
                var modelColumn = context.model.getLineFirstNonWhitespaceColumn(modelLineNumber);
                return [this._moveToModelPosition(context, cursor, inSelectionMode, modelLineNumber, modelColumn)];
            }
            case 12 /* ViewPortIfOutside */: {
                // Move to a position inside the viewport
                var visibleViewRange = context.getCompletelyVisibleViewRange();
                var result = [];
                for (var i = 0, len = cursors.length; i < len; i++) {
                    var cursor = cursors[i];
                    result[i] = this.findPositionInViewportIfOutside(context, cursor, visibleViewRange, inSelectionMode);
                }
                return result;
            }
        }
        return null;
    };
    CursorMoveCommands.findPositionInViewportIfOutside = function (context, cursor, visibleViewRange, inSelectionMode) {
        var viewLineNumber = cursor.viewState.position.lineNumber;
        if (visibleViewRange.startLineNumber <= viewLineNumber && viewLineNumber <= visibleViewRange.endLineNumber - 1) {
            // Nothing to do, cursor is in viewport
            return new CursorState(cursor.modelState, cursor.viewState);
        }
        else {
            if (viewLineNumber > visibleViewRange.endLineNumber - 1) {
                viewLineNumber = visibleViewRange.endLineNumber - 1;
            }
            if (viewLineNumber < visibleViewRange.startLineNumber) {
                viewLineNumber = visibleViewRange.startLineNumber;
            }
            var viewColumn = context.viewModel.getLineFirstNonWhitespaceColumn(viewLineNumber);
            return this._moveToViewPosition(context, cursor, inSelectionMode, viewLineNumber, viewColumn);
        }
    };
    /**
     * Find the nth line start included in the range (from the start).
     */
    CursorMoveCommands._firstLineNumberInRange = function (model, range, count) {
        var startLineNumber = range.startLineNumber;
        if (range.startColumn !== model.getLineMinColumn(startLineNumber)) {
            // Move on to the second line if the first line start is not included in the range
            startLineNumber++;
        }
        return Math.min(range.endLineNumber, startLineNumber + count - 1);
    };
    /**
     * Find the nth line start included in the range (from the end).
     */
    CursorMoveCommands._lastLineNumberInRange = function (model, range, count) {
        var startLineNumber = range.startLineNumber;
        if (range.startColumn !== model.getLineMinColumn(startLineNumber)) {
            // Move on to the second line if the first line start is not included in the range
            startLineNumber++;
        }
        return Math.max(startLineNumber, range.endLineNumber - count + 1);
    };
    CursorMoveCommands._moveLeft = function (context, cursors, inSelectionMode, noOfColumns) {
        var result = [];
        for (var i = 0, len = cursors.length; i < len; i++) {
            var cursor = cursors[i];
            var newViewState = MoveOperations.moveLeft(context.config, context.viewModel, cursor.viewState, inSelectionMode, noOfColumns);
            if (noOfColumns === 1 && newViewState.position.lineNumber !== cursor.viewState.position.lineNumber) {
                // moved over to the previous view line
                var newViewModelPosition = context.viewModel.coordinatesConverter.convertViewPositionToModelPosition(newViewState.position);
                if (newViewModelPosition.lineNumber === cursor.modelState.position.lineNumber) {
                    // stayed on the same model line => pass wrapping point where 2 view positions map to a single model position
                    newViewState = MoveOperations.moveLeft(context.config, context.viewModel, newViewState, inSelectionMode, 1);
                }
            }
            result[i] = CursorState.fromViewState(newViewState);
        }
        return result;
    };
    CursorMoveCommands._moveHalfLineLeft = function (context, cursors, inSelectionMode) {
        var result = [];
        for (var i = 0, len = cursors.length; i < len; i++) {
            var cursor = cursors[i];
            var viewLineNumber = cursor.viewState.position.lineNumber;
            var halfLine = Math.round(context.viewModel.getLineContent(viewLineNumber).length / 2);
            result[i] = CursorState.fromViewState(MoveOperations.moveLeft(context.config, context.viewModel, cursor.viewState, inSelectionMode, halfLine));
        }
        return result;
    };
    CursorMoveCommands._moveRight = function (context, cursors, inSelectionMode, noOfColumns) {
        var result = [];
        for (var i = 0, len = cursors.length; i < len; i++) {
            var cursor = cursors[i];
            var newViewState = MoveOperations.moveRight(context.config, context.viewModel, cursor.viewState, inSelectionMode, noOfColumns);
            if (noOfColumns === 1 && newViewState.position.lineNumber !== cursor.viewState.position.lineNumber) {
                // moved over to the next view line
                var newViewModelPosition = context.viewModel.coordinatesConverter.convertViewPositionToModelPosition(newViewState.position);
                if (newViewModelPosition.lineNumber === cursor.modelState.position.lineNumber) {
                    // stayed on the same model line => pass wrapping point where 2 view positions map to a single model position
                    newViewState = MoveOperations.moveRight(context.config, context.viewModel, newViewState, inSelectionMode, 1);
                }
            }
            result[i] = CursorState.fromViewState(newViewState);
        }
        return result;
    };
    CursorMoveCommands._moveHalfLineRight = function (context, cursors, inSelectionMode) {
        var result = [];
        for (var i = 0, len = cursors.length; i < len; i++) {
            var cursor = cursors[i];
            var viewLineNumber = cursor.viewState.position.lineNumber;
            var halfLine = Math.round(context.viewModel.getLineContent(viewLineNumber).length / 2);
            result[i] = CursorState.fromViewState(MoveOperations.moveRight(context.config, context.viewModel, cursor.viewState, inSelectionMode, halfLine));
        }
        return result;
    };
    CursorMoveCommands._moveDownByViewLines = function (context, cursors, inSelectionMode, linesCount) {
        var result = [];
        for (var i = 0, len = cursors.length; i < len; i++) {
            var cursor = cursors[i];
            result[i] = CursorState.fromViewState(MoveOperations.moveDown(context.config, context.viewModel, cursor.viewState, inSelectionMode, linesCount));
        }
        return result;
    };
    CursorMoveCommands._moveDownByModelLines = function (context, cursors, inSelectionMode, linesCount) {
        var result = [];
        for (var i = 0, len = cursors.length; i < len; i++) {
            var cursor = cursors[i];
            result[i] = CursorState.fromModelState(MoveOperations.moveDown(context.config, context.model, cursor.modelState, inSelectionMode, linesCount));
        }
        return result;
    };
    CursorMoveCommands._moveUpByViewLines = function (context, cursors, inSelectionMode, linesCount) {
        var result = [];
        for (var i = 0, len = cursors.length; i < len; i++) {
            var cursor = cursors[i];
            result[i] = CursorState.fromViewState(MoveOperations.moveUp(context.config, context.viewModel, cursor.viewState, inSelectionMode, linesCount));
        }
        return result;
    };
    CursorMoveCommands._moveUpByModelLines = function (context, cursors, inSelectionMode, linesCount) {
        var result = [];
        for (var i = 0, len = cursors.length; i < len; i++) {
            var cursor = cursors[i];
            result[i] = CursorState.fromModelState(MoveOperations.moveUp(context.config, context.model, cursor.modelState, inSelectionMode, linesCount));
        }
        return result;
    };
    CursorMoveCommands._moveToViewPosition = function (context, cursor, inSelectionMode, toViewLineNumber, toViewColumn) {
        return CursorState.fromViewState(cursor.viewState.move(inSelectionMode, toViewLineNumber, toViewColumn, 0));
    };
    CursorMoveCommands._moveToModelPosition = function (context, cursor, inSelectionMode, toModelLineNumber, toModelColumn) {
        return CursorState.fromModelState(cursor.modelState.move(inSelectionMode, toModelLineNumber, toModelColumn, 0));
    };
    CursorMoveCommands._moveToViewMinColumn = function (context, cursors, inSelectionMode) {
        var result = [];
        for (var i = 0, len = cursors.length; i < len; i++) {
            var cursor = cursors[i];
            var viewLineNumber = cursor.viewState.position.lineNumber;
            var viewColumn = context.viewModel.getLineMinColumn(viewLineNumber);
            result[i] = this._moveToViewPosition(context, cursor, inSelectionMode, viewLineNumber, viewColumn);
        }
        return result;
    };
    CursorMoveCommands._moveToViewFirstNonWhitespaceColumn = function (context, cursors, inSelectionMode) {
        var result = [];
        for (var i = 0, len = cursors.length; i < len; i++) {
            var cursor = cursors[i];
            var viewLineNumber = cursor.viewState.position.lineNumber;
            var viewColumn = context.viewModel.getLineFirstNonWhitespaceColumn(viewLineNumber);
            result[i] = this._moveToViewPosition(context, cursor, inSelectionMode, viewLineNumber, viewColumn);
        }
        return result;
    };
    CursorMoveCommands._moveToViewCenterColumn = function (context, cursors, inSelectionMode) {
        var result = [];
        for (var i = 0, len = cursors.length; i < len; i++) {
            var cursor = cursors[i];
            var viewLineNumber = cursor.viewState.position.lineNumber;
            var viewColumn = Math.round((context.viewModel.getLineMaxColumn(viewLineNumber) + context.viewModel.getLineMinColumn(viewLineNumber)) / 2);
            result[i] = this._moveToViewPosition(context, cursor, inSelectionMode, viewLineNumber, viewColumn);
        }
        return result;
    };
    CursorMoveCommands._moveToViewMaxColumn = function (context, cursors, inSelectionMode) {
        var result = [];
        for (var i = 0, len = cursors.length; i < len; i++) {
            var cursor = cursors[i];
            var viewLineNumber = cursor.viewState.position.lineNumber;
            var viewColumn = context.viewModel.getLineMaxColumn(viewLineNumber);
            result[i] = this._moveToViewPosition(context, cursor, inSelectionMode, viewLineNumber, viewColumn);
        }
        return result;
    };
    CursorMoveCommands._moveToViewLastNonWhitespaceColumn = function (context, cursors, inSelectionMode) {
        var result = [];
        for (var i = 0, len = cursors.length; i < len; i++) {
            var cursor = cursors[i];
            var viewLineNumber = cursor.viewState.position.lineNumber;
            var viewColumn = context.viewModel.getLineLastNonWhitespaceColumn(viewLineNumber);
            result[i] = this._moveToViewPosition(context, cursor, inSelectionMode, viewLineNumber, viewColumn);
        }
        return result;
    };
    return CursorMoveCommands;
}());
var CursorMove;
(function (CursorMove) {
    var isCursorMoveArgs = function (arg) {
        if (!isObject(arg)) {
            return false;
        }
        var cursorMoveArg = arg;
        if (!isString(cursorMoveArg.to)) {
            return false;
        }
        if (!isUndefined(cursorMoveArg.select) && !isBoolean(cursorMoveArg.select)) {
            return false;
        }
        if (!isUndefined(cursorMoveArg.by) && !isString(cursorMoveArg.by)) {
            return false;
        }
        if (!isUndefined(cursorMoveArg.value) && !isNumber(cursorMoveArg.value)) {
            return false;
        }
        return true;
    };
    CursorMove.description = {
        description: 'Move cursor to a logical position in the view',
        args: [
            {
                name: 'Cursor move argument object',
                description: "Property-value pairs that can be passed through this argument:\n\t\t\t\t\t* 'to': A mandatory logical position value providing where to move the cursor.\n\t\t\t\t\t\t```\n\t\t\t\t\t\t'left', 'right', 'up', 'down'\n\t\t\t\t\t\t'wrappedLineStart', 'wrappedLineEnd', 'wrappedLineColumnCenter'\n\t\t\t\t\t\t'wrappedLineFirstNonWhitespaceCharacter', 'wrappedLineLastNonWhitespaceCharacter',\n\t\t\t\t\t\t'viewPortTop', 'viewPortCenter', 'viewPortBottom', 'viewPortIfOutside'\n\t\t\t\t\t\t```\n\t\t\t\t\t* 'by': Unit to move. Default is computed based on 'to' value.\n\t\t\t\t\t\t```\n\t\t\t\t\t\t'line', 'wrappedLine', 'character', 'halfLine'\n\t\t\t\t\t\t```\n\t\t\t\t\t* 'value': Number of units to move. Default is '1'.\n\t\t\t\t\t* 'select': If 'true' makes the selection. Default is 'false'.\n\t\t\t\t",
                constraint: isCursorMoveArgs
            }
        ]
    };
    /**
     * Positions in the view for cursor move command.
     */
    CursorMove.RawDirection = {
        Left: 'left',
        Right: 'right',
        Up: 'up',
        Down: 'down',
        WrappedLineStart: 'wrappedLineStart',
        WrappedLineFirstNonWhitespaceCharacter: 'wrappedLineFirstNonWhitespaceCharacter',
        WrappedLineColumnCenter: 'wrappedLineColumnCenter',
        WrappedLineEnd: 'wrappedLineEnd',
        WrappedLineLastNonWhitespaceCharacter: 'wrappedLineLastNonWhitespaceCharacter',
        ViewPortTop: 'viewPortTop',
        ViewPortCenter: 'viewPortCenter',
        ViewPortBottom: 'viewPortBottom',
        ViewPortIfOutside: 'viewPortIfOutside'
    };
    /**
     * Units for Cursor move 'by' argument
     */
    CursorMove.RawUnit = {
        Line: 'line',
        WrappedLine: 'wrappedLine',
        Character: 'character',
        HalfLine: 'halfLine'
    };
    function parse(args) {
        if (!args.to) {
            // illegal arguments
            return null;
        }
        var direction;
        switch (args.to) {
            case CursorMove.RawDirection.Left:
                direction = 0 /* Left */;
                break;
            case CursorMove.RawDirection.Right:
                direction = 1 /* Right */;
                break;
            case CursorMove.RawDirection.Up:
                direction = 2 /* Up */;
                break;
            case CursorMove.RawDirection.Down:
                direction = 3 /* Down */;
                break;
            case CursorMove.RawDirection.WrappedLineStart:
                direction = 4 /* WrappedLineStart */;
                break;
            case CursorMove.RawDirection.WrappedLineFirstNonWhitespaceCharacter:
                direction = 5 /* WrappedLineFirstNonWhitespaceCharacter */;
                break;
            case CursorMove.RawDirection.WrappedLineColumnCenter:
                direction = 6 /* WrappedLineColumnCenter */;
                break;
            case CursorMove.RawDirection.WrappedLineEnd:
                direction = 7 /* WrappedLineEnd */;
                break;
            case CursorMove.RawDirection.WrappedLineLastNonWhitespaceCharacter:
                direction = 8 /* WrappedLineLastNonWhitespaceCharacter */;
                break;
            case CursorMove.RawDirection.ViewPortTop:
                direction = 9 /* ViewPortTop */;
                break;
            case CursorMove.RawDirection.ViewPortBottom:
                direction = 11 /* ViewPortBottom */;
                break;
            case CursorMove.RawDirection.ViewPortCenter:
                direction = 10 /* ViewPortCenter */;
                break;
            case CursorMove.RawDirection.ViewPortIfOutside:
                direction = 12 /* ViewPortIfOutside */;
                break;
            default:
                // illegal arguments
                return null;
        }
        var unit = 0 /* None */;
        switch (args.by) {
            case CursorMove.RawUnit.Line:
                unit = 1 /* Line */;
                break;
            case CursorMove.RawUnit.WrappedLine:
                unit = 2 /* WrappedLine */;
                break;
            case CursorMove.RawUnit.Character:
                unit = 3 /* Character */;
                break;
            case CursorMove.RawUnit.HalfLine:
                unit = 4 /* HalfLine */;
                break;
        }
        return {
            direction: direction,
            unit: unit,
            select: (!!args.select),
            value: (args.value || 1)
        };
    }
    CursorMove.parse = parse;
})(CursorMove || (CursorMove = {}));

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var ColumnSelection = /** @class */ (function () {
    function ColumnSelection() {
    }
    ColumnSelection._columnSelect = function (config, model, fromLineNumber, fromVisibleColumn, toLineNumber, toVisibleColumn) {
        var lineCount = Math.abs(toLineNumber - fromLineNumber) + 1;
        var reversed = (fromLineNumber > toLineNumber);
        var isRTL = (fromVisibleColumn > toVisibleColumn);
        var isLTR = (fromVisibleColumn < toVisibleColumn);
        var result = [];
        // console.log(`fromVisibleColumn: ${fromVisibleColumn}, toVisibleColumn: ${toVisibleColumn}`);
        for (var i = 0; i < lineCount; i++) {
            var lineNumber = fromLineNumber + (reversed ? -i : i);
            var startColumn = CursorColumns.columnFromVisibleColumn2(config, model, lineNumber, fromVisibleColumn);
            var endColumn = CursorColumns.columnFromVisibleColumn2(config, model, lineNumber, toVisibleColumn);
            var visibleStartColumn = CursorColumns.visibleColumnFromColumn2(config, model, new Position(lineNumber, startColumn));
            var visibleEndColumn = CursorColumns.visibleColumnFromColumn2(config, model, new Position(lineNumber, endColumn));
            // console.log(`lineNumber: ${lineNumber}: visibleStartColumn: ${visibleStartColumn}, visibleEndColumn: ${visibleEndColumn}`);
            if (isLTR) {
                if (visibleStartColumn > toVisibleColumn) {
                    continue;
                }
                if (visibleEndColumn < fromVisibleColumn) {
                    continue;
                }
            }
            if (isRTL) {
                if (visibleEndColumn > fromVisibleColumn) {
                    continue;
                }
                if (visibleStartColumn < toVisibleColumn) {
                    continue;
                }
            }
            result.push(new SingleCursorState(new Range(lineNumber, startColumn, lineNumber, startColumn), 0, new Position(lineNumber, endColumn), 0));
        }
        return {
            viewStates: result,
            reversed: reversed,
            toLineNumber: toLineNumber,
            toVisualColumn: toVisibleColumn
        };
    };
    ColumnSelection.columnSelect = function (config, model, fromViewSelection, toViewLineNumber, toViewVisualColumn) {
        var fromViewPosition = new Position(fromViewSelection.selectionStartLineNumber, fromViewSelection.selectionStartColumn);
        var fromViewVisibleColumn = CursorColumns.visibleColumnFromColumn2(config, model, fromViewPosition);
        return ColumnSelection._columnSelect(config, model, fromViewPosition.lineNumber, fromViewVisibleColumn, toViewLineNumber, toViewVisualColumn);
    };
    ColumnSelection.columnSelectLeft = function (config, model, cursor, toViewLineNumber, toViewVisualColumn) {
        if (toViewVisualColumn > 1) {
            toViewVisualColumn--;
        }
        return this.columnSelect(config, model, cursor.selection, toViewLineNumber, toViewVisualColumn);
    };
    ColumnSelection.columnSelectRight = function (config, model, cursor, toViewLineNumber, toViewVisualColumn) {
        var maxVisualViewColumn = 0;
        var minViewLineNumber = Math.min(cursor.position.lineNumber, toViewLineNumber);
        var maxViewLineNumber = Math.max(cursor.position.lineNumber, toViewLineNumber);
        for (var lineNumber = minViewLineNumber; lineNumber <= maxViewLineNumber; lineNumber++) {
            var lineMaxViewColumn = model.getLineMaxColumn(lineNumber);
            var lineMaxVisualViewColumn = CursorColumns.visibleColumnFromColumn2(config, model, new Position(lineNumber, lineMaxViewColumn));
            maxVisualViewColumn = Math.max(maxVisualViewColumn, lineMaxVisualViewColumn);
        }
        if (toViewVisualColumn < maxVisualViewColumn) {
            toViewVisualColumn++;
        }
        return this.columnSelect(config, model, cursor.selection, toViewLineNumber, toViewVisualColumn);
    };
    ColumnSelection.columnSelectUp = function (config, model, cursor, isPaged, toViewLineNumber, toViewVisualColumn) {
        var linesCount = isPaged ? config.pageSize : 1;
        toViewLineNumber -= linesCount;
        if (toViewLineNumber < 1) {
            toViewLineNumber = 1;
        }
        return this.columnSelect(config, model, cursor.selection, toViewLineNumber, toViewVisualColumn);
    };
    ColumnSelection.columnSelectDown = function (config, model, cursor, isPaged, toViewLineNumber, toViewVisualColumn) {
        var linesCount = isPaged ? config.pageSize : 1;
        toViewLineNumber += linesCount;
        if (toViewLineNumber > model.getLineCount()) {
            toViewLineNumber = model.getLineCount();
        }
        return this.columnSelect(config, model, cursor.selection, toViewLineNumber, toViewVisualColumn);
    };
    return ColumnSelection;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$A = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var H = Handler;
var CORE_WEIGHT = KeybindingsRegistry.WEIGHT.editorCore();
var CoreEditorCommand = /** @class */ (function (_super) {
    __extends$A(CoreEditorCommand, _super);
    function CoreEditorCommand() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    CoreEditorCommand.prototype.runEditorCommand = function (accessor, editor, args) {
        var cursors = editor._getCursors();
        if (!cursors) {
            // the editor has no view => has no cursors
            return;
        }
        this.runCoreEditorCommand(cursors, args || {});
    };
    return CoreEditorCommand;
}(EditorCommand));
var EditorScroll_;
(function (EditorScroll_) {
    var isEditorScrollArgs = function (arg) {
        if (!isObject(arg)) {
            return false;
        }
        var scrollArg = arg;
        if (!isString(scrollArg.to)) {
            return false;
        }
        if (!isUndefined(scrollArg.by) && !isString(scrollArg.by)) {
            return false;
        }
        if (!isUndefined(scrollArg.value) && !isNumber(scrollArg.value)) {
            return false;
        }
        if (!isUndefined(scrollArg.revealCursor) && !isBoolean(scrollArg.revealCursor)) {
            return false;
        }
        return true;
    };
    EditorScroll_.description = {
        description: 'Scroll editor in the given direction',
        args: [
            {
                name: 'Editor scroll argument object',
                description: "Property-value pairs that can be passed through this argument:\n\t\t\t\t\t* 'to': A mandatory direction value.\n\t\t\t\t\t\t```\n\t\t\t\t\t\t'up', 'down'\n\t\t\t\t\t\t```\n\t\t\t\t\t* 'by': Unit to move. Default is computed based on 'to' value.\n\t\t\t\t\t\t```\n\t\t\t\t\t\t'line', 'wrappedLine', 'page', 'halfPage'\n\t\t\t\t\t\t```\n\t\t\t\t\t* 'value': Number of units to move. Default is '1'.\n\t\t\t\t\t* 'revealCursor': If 'true' reveals the cursor if it is outside view port.\n\t\t\t\t",
                constraint: isEditorScrollArgs
            }
        ]
    };
    /**
     * Directions in the view for editor scroll command.
     */
    EditorScroll_.RawDirection = {
        Up: 'up',
        Down: 'down',
    };
    /**
     * Units for editor scroll 'by' argument
     */
    EditorScroll_.RawUnit = {
        Line: 'line',
        WrappedLine: 'wrappedLine',
        Page: 'page',
        HalfPage: 'halfPage'
    };
    function parse(args) {
        var direction;
        switch (args.to) {
            case EditorScroll_.RawDirection.Up:
                direction = 1 /* Up */;
                break;
            case EditorScroll_.RawDirection.Down:
                direction = 2 /* Down */;
                break;
            default:
                // Illegal arguments
                return null;
        }
        var unit;
        switch (args.by) {
            case EditorScroll_.RawUnit.Line:
                unit = 1 /* Line */;
                break;
            case EditorScroll_.RawUnit.WrappedLine:
                unit = 2 /* WrappedLine */;
                break;
            case EditorScroll_.RawUnit.Page:
                unit = 3 /* Page */;
                break;
            case EditorScroll_.RawUnit.HalfPage:
                unit = 4 /* HalfPage */;
                break;
            default:
                unit = 2 /* WrappedLine */;
        }
        var value = Math.floor(args.value || 1);
        var revealCursor = !!args.revealCursor;
        return {
            direction: direction,
            unit: unit,
            value: value,
            revealCursor: revealCursor,
            select: (!!args.select)
        };
    }
    EditorScroll_.parse = parse;
})(EditorScroll_ || (EditorScroll_ = {}));
var RevealLine_;
(function (RevealLine_) {
    var isRevealLineArgs = function (arg) {
        if (!isObject(arg)) {
            return false;
        }
        var reveaLineArg = arg;
        if (!isNumber(reveaLineArg.lineNumber)) {
            return false;
        }
        if (!isUndefined(reveaLineArg.at) && !isString(reveaLineArg.at)) {
            return false;
        }
        return true;
    };
    RevealLine_.description = {
        description: 'Reveal the given line at the given logical position',
        args: [
            {
                name: 'Reveal line argument object',
                description: "Property-value pairs that can be passed through this argument:\n\t\t\t\t\t* 'lineNumber': A mandatory line number value.\n\t\t\t\t\t* 'at': Logical position at which line has to be revealed .\n\t\t\t\t\t\t```\n\t\t\t\t\t\t'top', 'center', 'bottom'\n\t\t\t\t\t\t```\n\t\t\t\t",
                constraint: isRevealLineArgs
            }
        ]
    };
    /**
     * Values for reveal line 'at' argument
     */
    RevealLine_.RawAtArgument = {
        Top: 'top',
        Center: 'center',
        Bottom: 'bottom'
    };
})(RevealLine_ || (RevealLine_ = {}));
var CoreNavigationCommands;
(function (CoreNavigationCommands) {
    var BaseMoveToCommand = /** @class */ (function (_super) {
        __extends$A(BaseMoveToCommand, _super);
        function BaseMoveToCommand(opts) {
            var _this = _super.call(this, opts) || this;
            _this._inSelectionMode = opts.inSelectionMode;
            return _this;
        }
        BaseMoveToCommand.prototype.runCoreEditorCommand = function (cursors, args) {
            cursors.context.model.pushStackElement();
            cursors.setStates(args.source, CursorChangeReason.Explicit, [
                CursorMoveCommands.moveTo(cursors.context, cursors.getPrimaryCursor(), this._inSelectionMode, args.position, args.viewPosition)
            ]);
            cursors.reveal(true, 0 /* Primary */, 0 /* Smooth */);
        };
        return BaseMoveToCommand;
    }(CoreEditorCommand));
    CoreNavigationCommands.MoveTo = registerEditorCommand(new BaseMoveToCommand({
        id: '_moveTo',
        inSelectionMode: false,
        precondition: null
    }));
    CoreNavigationCommands.MoveToSelect = registerEditorCommand(new BaseMoveToCommand({
        id: '_moveToSelect',
        inSelectionMode: true,
        precondition: null
    }));
    var ColumnSelectCommand = /** @class */ (function (_super) {
        __extends$A(ColumnSelectCommand, _super);
        function ColumnSelectCommand() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        ColumnSelectCommand.prototype.runCoreEditorCommand = function (cursors, args) {
            cursors.context.model.pushStackElement();
            var result = this._getColumnSelectResult(cursors.context, cursors.getPrimaryCursor(), cursors.getColumnSelectData(), args);
            cursors.setStates(args.source, CursorChangeReason.Explicit, result.viewStates.map(function (viewState) { return CursorState.fromViewState(viewState); }));
            cursors.setColumnSelectData({
                toViewLineNumber: result.toLineNumber,
                toViewVisualColumn: result.toVisualColumn
            });
            cursors.reveal(true, (result.reversed ? 1 /* TopMost */ : 2 /* BottomMost */), 0 /* Smooth */);
        };
        return ColumnSelectCommand;
    }(CoreEditorCommand));
    CoreNavigationCommands.ColumnSelect = registerEditorCommand(new /** @class */ (function (_super) {
        __extends$A(class_1, _super);
        function class_1() {
            return _super.call(this, {
                id: 'columnSelect',
                precondition: null
            }) || this;
        }
        class_1.prototype._getColumnSelectResult = function (context, primary, prevColumnSelectData, args) {
            // validate `args`
            var validatedPosition = context.model.validatePosition(args.position);
            var validatedViewPosition;
            if (args.viewPosition) {
                validatedViewPosition = context.validateViewPosition(new Position(args.viewPosition.lineNumber, args.viewPosition.column), validatedPosition);
            }
            else {
                validatedViewPosition = context.convertModelPositionToViewPosition(validatedPosition);
            }
            return ColumnSelection.columnSelect(context.config, context.viewModel, primary.viewState.selection, validatedViewPosition.lineNumber, args.mouseColumn - 1);
        };
        return class_1;
    }(ColumnSelectCommand)));
    CoreNavigationCommands.CursorColumnSelectLeft = registerEditorCommand(new /** @class */ (function (_super) {
        __extends$A(class_2, _super);
        function class_2() {
            return _super.call(this, {
                id: 'cursorColumnSelectLeft',
                precondition: null,
                kbOpts: {
                    weight: CORE_WEIGHT,
                    kbExpr: EditorContextKeys.textInputFocus,
                    primary: 2048 /* CtrlCmd */ | 1024 /* Shift */ | 512 /* Alt */ | 15 /* LeftArrow */,
                    linux: { primary: 0 }
                }
            }) || this;
        }
        class_2.prototype._getColumnSelectResult = function (context, primary, prevColumnSelectData, args) {
            return ColumnSelection.columnSelectLeft(context.config, context.viewModel, primary.viewState, prevColumnSelectData.toViewLineNumber, prevColumnSelectData.toViewVisualColumn);
        };
        return class_2;
    }(ColumnSelectCommand)));
    CoreNavigationCommands.CursorColumnSelectRight = registerEditorCommand(new /** @class */ (function (_super) {
        __extends$A(class_3, _super);
        function class_3() {
            return _super.call(this, {
                id: 'cursorColumnSelectRight',
                precondition: null,
                kbOpts: {
                    weight: CORE_WEIGHT,
                    kbExpr: EditorContextKeys.textInputFocus,
                    primary: 2048 /* CtrlCmd */ | 1024 /* Shift */ | 512 /* Alt */ | 17 /* RightArrow */,
                    linux: { primary: 0 }
                }
            }) || this;
        }
        class_3.prototype._getColumnSelectResult = function (context, primary, prevColumnSelectData, args) {
            return ColumnSelection.columnSelectRight(context.config, context.viewModel, primary.viewState, prevColumnSelectData.toViewLineNumber, prevColumnSelectData.toViewVisualColumn);
        };
        return class_3;
    }(ColumnSelectCommand)));
    var ColumnSelectUpCommand = /** @class */ (function (_super) {
        __extends$A(ColumnSelectUpCommand, _super);
        function ColumnSelectUpCommand(opts) {
            var _this = _super.call(this, opts) || this;
            _this._isPaged = opts.isPaged;
            return _this;
        }
        ColumnSelectUpCommand.prototype._getColumnSelectResult = function (context, primary, prevColumnSelectData, args) {
            return ColumnSelection.columnSelectUp(context.config, context.viewModel, primary.viewState, this._isPaged, prevColumnSelectData.toViewLineNumber, prevColumnSelectData.toViewVisualColumn);
        };
        return ColumnSelectUpCommand;
    }(ColumnSelectCommand));
    CoreNavigationCommands.CursorColumnSelectUp = registerEditorCommand(new ColumnSelectUpCommand({
        isPaged: false,
        id: 'cursorColumnSelectUp',
        precondition: null,
        kbOpts: {
            weight: CORE_WEIGHT,
            kbExpr: EditorContextKeys.textInputFocus,
            primary: 2048 /* CtrlCmd */ | 1024 /* Shift */ | 512 /* Alt */ | 16 /* UpArrow */,
            linux: { primary: 0 }
        }
    }));
    CoreNavigationCommands.CursorColumnSelectPageUp = registerEditorCommand(new ColumnSelectUpCommand({
        isPaged: true,
        id: 'cursorColumnSelectPageUp',
        precondition: null,
        kbOpts: {
            weight: CORE_WEIGHT,
            kbExpr: EditorContextKeys.textInputFocus,
            primary: 2048 /* CtrlCmd */ | 1024 /* Shift */ | 512 /* Alt */ | 11 /* PageUp */,
            linux: { primary: 0 }
        }
    }));
    var ColumnSelectDownCommand = /** @class */ (function (_super) {
        __extends$A(ColumnSelectDownCommand, _super);
        function ColumnSelectDownCommand(opts) {
            var _this = _super.call(this, opts) || this;
            _this._isPaged = opts.isPaged;
            return _this;
        }
        ColumnSelectDownCommand.prototype._getColumnSelectResult = function (context, primary, prevColumnSelectData, args) {
            return ColumnSelection.columnSelectDown(context.config, context.viewModel, primary.viewState, this._isPaged, prevColumnSelectData.toViewLineNumber, prevColumnSelectData.toViewVisualColumn);
        };
        return ColumnSelectDownCommand;
    }(ColumnSelectCommand));
    CoreNavigationCommands.CursorColumnSelectDown = registerEditorCommand(new ColumnSelectDownCommand({
        isPaged: false,
        id: 'cursorColumnSelectDown',
        precondition: null,
        kbOpts: {
            weight: CORE_WEIGHT,
            kbExpr: EditorContextKeys.textInputFocus,
            primary: 2048 /* CtrlCmd */ | 1024 /* Shift */ | 512 /* Alt */ | 18 /* DownArrow */,
            linux: { primary: 0 }
        }
    }));
    CoreNavigationCommands.CursorColumnSelectPageDown = registerEditorCommand(new ColumnSelectDownCommand({
        isPaged: true,
        id: 'cursorColumnSelectPageDown',
        precondition: null,
        kbOpts: {
            weight: CORE_WEIGHT,
            kbExpr: EditorContextKeys.textInputFocus,
            primary: 2048 /* CtrlCmd */ | 1024 /* Shift */ | 512 /* Alt */ | 12 /* PageDown */,
            linux: { primary: 0 }
        }
    }));
    var CursorMoveImpl = /** @class */ (function (_super) {
        __extends$A(CursorMoveImpl, _super);
        function CursorMoveImpl() {
            return _super.call(this, {
                id: 'cursorMove',
                precondition: null,
                description: CursorMove.description
            }) || this;
        }
        CursorMoveImpl.prototype.runCoreEditorCommand = function (cursors, args) {
            var parsed = CursorMove.parse(args);
            if (!parsed) {
                // illegal arguments
                return;
            }
            this._runCursorMove(cursors, args.source, parsed);
        };
        CursorMoveImpl.prototype._runCursorMove = function (cursors, source, args) {
            cursors.context.model.pushStackElement();
            cursors.setStates(source, CursorChangeReason.Explicit, CursorMoveCommands.move(cursors.context, cursors.getAll(), args));
            cursors.reveal(true, 0 /* Primary */, 0 /* Smooth */);
        };
        return CursorMoveImpl;
    }(CoreEditorCommand));
    CoreNavigationCommands.CursorMoveImpl = CursorMoveImpl;
    CoreNavigationCommands.CursorMove = registerEditorCommand(new CursorMoveImpl());
    var CursorMoveBasedCommand = /** @class */ (function (_super) {
        __extends$A(CursorMoveBasedCommand, _super);
        function CursorMoveBasedCommand(opts) {
            var _this = _super.call(this, opts) || this;
            _this._staticArgs = opts.args;
            return _this;
        }
        CursorMoveBasedCommand.prototype.runCoreEditorCommand = function (cursors, dynamicArgs) {
            var args = this._staticArgs;
            if (this._staticArgs.value === -1 /* PAGE_SIZE_MARKER */) {
                // -1 is a marker for page size
                args = {
                    direction: this._staticArgs.direction,
                    unit: this._staticArgs.unit,
                    select: this._staticArgs.select,
                    value: cursors.context.config.pageSize
                };
            }
            CoreNavigationCommands.CursorMove._runCursorMove(cursors, dynamicArgs.source, args);
        };
        return CursorMoveBasedCommand;
    }(CoreEditorCommand));
    CoreNavigationCommands.CursorLeft = registerEditorCommand(new CursorMoveBasedCommand({
        args: {
            direction: 0 /* Left */,
            unit: 0 /* None */,
            select: false,
            value: 1
        },
        id: 'cursorLeft',
        precondition: null,
        kbOpts: {
            weight: CORE_WEIGHT,
            kbExpr: EditorContextKeys.textInputFocus,
            primary: 15 /* LeftArrow */,
            mac: { primary: 15 /* LeftArrow */, secondary: [256 /* WinCtrl */ | 32 /* KEY_B */] }
        }
    }));
    CoreNavigationCommands.CursorLeftSelect = registerEditorCommand(new CursorMoveBasedCommand({
        args: {
            direction: 0 /* Left */,
            unit: 0 /* None */,
            select: true,
            value: 1
        },
        id: 'cursorLeftSelect',
        precondition: null,
        kbOpts: {
            weight: CORE_WEIGHT,
            kbExpr: EditorContextKeys.textInputFocus,
            primary: 1024 /* Shift */ | 15 /* LeftArrow */
        }
    }));
    CoreNavigationCommands.CursorRight = registerEditorCommand(new CursorMoveBasedCommand({
        args: {
            direction: 1 /* Right */,
            unit: 0 /* None */,
            select: false,
            value: 1
        },
        id: 'cursorRight',
        precondition: null,
        kbOpts: {
            weight: CORE_WEIGHT,
            kbExpr: EditorContextKeys.textInputFocus,
            primary: 17 /* RightArrow */,
            mac: { primary: 17 /* RightArrow */, secondary: [256 /* WinCtrl */ | 36 /* KEY_F */] }
        }
    }));
    CoreNavigationCommands.CursorRightSelect = registerEditorCommand(new CursorMoveBasedCommand({
        args: {
            direction: 1 /* Right */,
            unit: 0 /* None */,
            select: true,
            value: 1
        },
        id: 'cursorRightSelect',
        precondition: null,
        kbOpts: {
            weight: CORE_WEIGHT,
            kbExpr: EditorContextKeys.textInputFocus,
            primary: 1024 /* Shift */ | 17 /* RightArrow */
        }
    }));
    CoreNavigationCommands.CursorUp = registerEditorCommand(new CursorMoveBasedCommand({
        args: {
            direction: 2 /* Up */,
            unit: 2 /* WrappedLine */,
            select: false,
            value: 1
        },
        id: 'cursorUp',
        precondition: null,
        kbOpts: {
            weight: CORE_WEIGHT,
            kbExpr: EditorContextKeys.textInputFocus,
            primary: 16 /* UpArrow */,
            mac: { primary: 16 /* UpArrow */, secondary: [256 /* WinCtrl */ | 46 /* KEY_P */] }
        }
    }));
    CoreNavigationCommands.CursorUpSelect = registerEditorCommand(new CursorMoveBasedCommand({
        args: {
            direction: 2 /* Up */,
            unit: 2 /* WrappedLine */,
            select: true,
            value: 1
        },
        id: 'cursorUpSelect',
        precondition: null,
        kbOpts: {
            weight: CORE_WEIGHT,
            kbExpr: EditorContextKeys.textInputFocus,
            primary: 1024 /* Shift */ | 16 /* UpArrow */,
            secondary: [2048 /* CtrlCmd */ | 1024 /* Shift */ | 16 /* UpArrow */],
            mac: { primary: 1024 /* Shift */ | 16 /* UpArrow */ },
            linux: { primary: 1024 /* Shift */ | 16 /* UpArrow */ }
        }
    }));
    CoreNavigationCommands.CursorPageUp = registerEditorCommand(new CursorMoveBasedCommand({
        args: {
            direction: 2 /* Up */,
            unit: 2 /* WrappedLine */,
            select: false,
            value: -1 /* PAGE_SIZE_MARKER */
        },
        id: 'cursorPageUp',
        precondition: null,
        kbOpts: {
            weight: CORE_WEIGHT,
            kbExpr: EditorContextKeys.textInputFocus,
            primary: 11 /* PageUp */
        }
    }));
    CoreNavigationCommands.CursorPageUpSelect = registerEditorCommand(new CursorMoveBasedCommand({
        args: {
            direction: 2 /* Up */,
            unit: 2 /* WrappedLine */,
            select: true,
            value: -1 /* PAGE_SIZE_MARKER */
        },
        id: 'cursorPageUpSelect',
        precondition: null,
        kbOpts: {
            weight: CORE_WEIGHT,
            kbExpr: EditorContextKeys.textInputFocus,
            primary: 1024 /* Shift */ | 11 /* PageUp */
        }
    }));
    CoreNavigationCommands.CursorDown = registerEditorCommand(new CursorMoveBasedCommand({
        args: {
            direction: 3 /* Down */,
            unit: 2 /* WrappedLine */,
            select: false,
            value: 1
        },
        id: 'cursorDown',
        precondition: null,
        kbOpts: {
            weight: CORE_WEIGHT,
            kbExpr: EditorContextKeys.textInputFocus,
            primary: 18 /* DownArrow */,
            mac: { primary: 18 /* DownArrow */, secondary: [256 /* WinCtrl */ | 44 /* KEY_N */] }
        }
    }));
    CoreNavigationCommands.CursorDownSelect = registerEditorCommand(new CursorMoveBasedCommand({
        args: {
            direction: 3 /* Down */,
            unit: 2 /* WrappedLine */,
            select: true,
            value: 1
        },
        id: 'cursorDownSelect',
        precondition: null,
        kbOpts: {
            weight: CORE_WEIGHT,
            kbExpr: EditorContextKeys.textInputFocus,
            primary: 1024 /* Shift */ | 18 /* DownArrow */,
            secondary: [2048 /* CtrlCmd */ | 1024 /* Shift */ | 18 /* DownArrow */],
            mac: { primary: 1024 /* Shift */ | 18 /* DownArrow */ },
            linux: { primary: 1024 /* Shift */ | 18 /* DownArrow */ }
        }
    }));
    CoreNavigationCommands.CursorPageDown = registerEditorCommand(new CursorMoveBasedCommand({
        args: {
            direction: 3 /* Down */,
            unit: 2 /* WrappedLine */,
            select: false,
            value: -1 /* PAGE_SIZE_MARKER */
        },
        id: 'cursorPageDown',
        precondition: null,
        kbOpts: {
            weight: CORE_WEIGHT,
            kbExpr: EditorContextKeys.textInputFocus,
            primary: 12 /* PageDown */
        }
    }));
    CoreNavigationCommands.CursorPageDownSelect = registerEditorCommand(new CursorMoveBasedCommand({
        args: {
            direction: 3 /* Down */,
            unit: 2 /* WrappedLine */,
            select: true,
            value: -1 /* PAGE_SIZE_MARKER */
        },
        id: 'cursorPageDownSelect',
        precondition: null,
        kbOpts: {
            weight: CORE_WEIGHT,
            kbExpr: EditorContextKeys.textInputFocus,
            primary: 1024 /* Shift */ | 12 /* PageDown */
        }
    }));
    CoreNavigationCommands.CreateCursor = registerEditorCommand(new /** @class */ (function (_super) {
        __extends$A(class_4, _super);
        function class_4() {
            return _super.call(this, {
                id: 'createCursor',
                precondition: null
            }) || this;
        }
        class_4.prototype.runCoreEditorCommand = function (cursors, args) {
            var context = cursors.context;
            if (context.config.readOnly) {
                return;
            }
            var newState;
            if (args.wholeLine) {
                newState = CursorMoveCommands.line(context, cursors.getPrimaryCursor(), false, args.position, args.viewPosition);
            }
            else {
                newState = CursorMoveCommands.moveTo(context, cursors.getPrimaryCursor(), false, args.position, args.viewPosition);
            }
            var states = cursors.getAll();
            // Check if we should remove a cursor (sort of like a toggle)
            if (states.length > 1) {
                var newModelPosition = (newState.modelState ? newState.modelState.position : null);
                var newViewPosition = (newState.viewState ? newState.viewState.position : null);
                for (var i = 0, len = states.length; i < len; i++) {
                    var state = states[i];
                    if (newModelPosition && !state.modelState.selection.containsPosition(newModelPosition)) {
                        continue;
                    }
                    if (newViewPosition && !state.viewState.selection.containsPosition(newViewPosition)) {
                        continue;
                    }
                    // => Remove the cursor
                    states.splice(i, 1);
                    cursors.context.model.pushStackElement();
                    cursors.setStates(args.source, CursorChangeReason.Explicit, states);
                    return;
                }
            }
            // => Add the new cursor
            states.push(newState);
            cursors.context.model.pushStackElement();
            cursors.setStates(args.source, CursorChangeReason.Explicit, states);
        };
        return class_4;
    }(CoreEditorCommand)));
    CoreNavigationCommands.LastCursorMoveToSelect = registerEditorCommand(new /** @class */ (function (_super) {
        __extends$A(class_5, _super);
        function class_5() {
            return _super.call(this, {
                id: '_lastCursorMoveToSelect',
                precondition: null
            }) || this;
        }
        class_5.prototype.runCoreEditorCommand = function (cursors, args) {
            var context = cursors.context;
            if (context.config.readOnly) {
                return;
            }
            var lastAddedCursorIndex = cursors.getLastAddedCursorIndex();
            var newStates = cursors.getAll().slice(0);
            newStates[lastAddedCursorIndex] = CursorMoveCommands.moveTo(context, newStates[lastAddedCursorIndex], true, args.position, args.viewPosition);
            cursors.context.model.pushStackElement();
            cursors.setStates(args.source, CursorChangeReason.Explicit, newStates);
        };
        return class_5;
    }(CoreEditorCommand)));
    var HomeCommand = /** @class */ (function (_super) {
        __extends$A(HomeCommand, _super);
        function HomeCommand(opts) {
            var _this = _super.call(this, opts) || this;
            _this._inSelectionMode = opts.inSelectionMode;
            return _this;
        }
        HomeCommand.prototype.runCoreEditorCommand = function (cursors, args) {
            cursors.context.model.pushStackElement();
            cursors.setStates(args.source, CursorChangeReason.Explicit, CursorMoveCommands.moveToBeginningOfLine(cursors.context, cursors.getAll(), this._inSelectionMode));
            cursors.reveal(true, 0 /* Primary */, 0 /* Smooth */);
        };
        return HomeCommand;
    }(CoreEditorCommand));
    CoreNavigationCommands.CursorHome = registerEditorCommand(new HomeCommand({
        inSelectionMode: false,
        id: 'cursorHome',
        precondition: null,
        kbOpts: {
            weight: CORE_WEIGHT,
            kbExpr: EditorContextKeys.textInputFocus,
            primary: 14 /* Home */,
            mac: { primary: 14 /* Home */, secondary: [2048 /* CtrlCmd */ | 15 /* LeftArrow */] }
        }
    }));
    CoreNavigationCommands.CursorHomeSelect = registerEditorCommand(new HomeCommand({
        inSelectionMode: true,
        id: 'cursorHomeSelect',
        precondition: null,
        kbOpts: {
            weight: CORE_WEIGHT,
            kbExpr: EditorContextKeys.textInputFocus,
            primary: 1024 /* Shift */ | 14 /* Home */,
            mac: { primary: 1024 /* Shift */ | 14 /* Home */, secondary: [2048 /* CtrlCmd */ | 1024 /* Shift */ | 15 /* LeftArrow */] }
        }
    }));
    CoreNavigationCommands.CursorLineStart = registerEditorCommand(new /** @class */ (function (_super) {
        __extends$A(class_6, _super);
        function class_6() {
            return _super.call(this, {
                id: 'cursorLineStart',
                precondition: null,
                kbOpts: {
                    weight: CORE_WEIGHT,
                    kbExpr: EditorContextKeys.textInputFocus,
                    primary: 0,
                    mac: { primary: 256 /* WinCtrl */ | 31 /* KEY_A */ }
                }
            }) || this;
        }
        class_6.prototype.runCoreEditorCommand = function (cursors, args) {
            cursors.context.model.pushStackElement();
            cursors.setStates(args.source, CursorChangeReason.Explicit, this._exec(cursors.context, cursors.getAll()));
            cursors.reveal(true, 0 /* Primary */, 0 /* Smooth */);
        };
        class_6.prototype._exec = function (context, cursors) {
            var result = [];
            for (var i = 0, len = cursors.length; i < len; i++) {
                var cursor = cursors[i];
                var lineNumber = cursor.modelState.position.lineNumber;
                result[i] = CursorState.fromModelState(cursor.modelState.move(false, lineNumber, 1, 0));
            }
            return result;
        };
        return class_6;
    }(CoreEditorCommand)));
    var EndCommand = /** @class */ (function (_super) {
        __extends$A(EndCommand, _super);
        function EndCommand(opts) {
            var _this = _super.call(this, opts) || this;
            _this._inSelectionMode = opts.inSelectionMode;
            return _this;
        }
        EndCommand.prototype.runCoreEditorCommand = function (cursors, args) {
            cursors.context.model.pushStackElement();
            cursors.setStates(args.source, CursorChangeReason.Explicit, CursorMoveCommands.moveToEndOfLine(cursors.context, cursors.getAll(), this._inSelectionMode));
            cursors.reveal(true, 0 /* Primary */, 0 /* Smooth */);
        };
        return EndCommand;
    }(CoreEditorCommand));
    CoreNavigationCommands.CursorEnd = registerEditorCommand(new EndCommand({
        inSelectionMode: false,
        id: 'cursorEnd',
        precondition: null,
        kbOpts: {
            weight: CORE_WEIGHT,
            kbExpr: EditorContextKeys.textInputFocus,
            primary: 13 /* End */,
            mac: { primary: 13 /* End */, secondary: [2048 /* CtrlCmd */ | 17 /* RightArrow */] }
        }
    }));
    CoreNavigationCommands.CursorEndSelect = registerEditorCommand(new EndCommand({
        inSelectionMode: true,
        id: 'cursorEndSelect',
        precondition: null,
        kbOpts: {
            weight: CORE_WEIGHT,
            kbExpr: EditorContextKeys.textInputFocus,
            primary: 1024 /* Shift */ | 13 /* End */,
            mac: { primary: 1024 /* Shift */ | 13 /* End */, secondary: [2048 /* CtrlCmd */ | 1024 /* Shift */ | 17 /* RightArrow */] }
        }
    }));
    CoreNavigationCommands.CursorLineEnd = registerEditorCommand(new /** @class */ (function (_super) {
        __extends$A(class_7, _super);
        function class_7() {
            return _super.call(this, {
                id: 'cursorLineEnd',
                precondition: null,
                kbOpts: {
                    weight: CORE_WEIGHT,
                    kbExpr: EditorContextKeys.textInputFocus,
                    primary: 0,
                    mac: { primary: 256 /* WinCtrl */ | 35 /* KEY_E */ }
                }
            }) || this;
        }
        class_7.prototype.runCoreEditorCommand = function (cursors, args) {
            cursors.context.model.pushStackElement();
            cursors.setStates(args.source, CursorChangeReason.Explicit, this._exec(cursors.context, cursors.getAll()));
            cursors.reveal(true, 0 /* Primary */, 0 /* Smooth */);
        };
        class_7.prototype._exec = function (context, cursors) {
            var result = [];
            for (var i = 0, len = cursors.length; i < len; i++) {
                var cursor = cursors[i];
                var lineNumber = cursor.modelState.position.lineNumber;
                var maxColumn = context.model.getLineMaxColumn(lineNumber);
                result[i] = CursorState.fromModelState(cursor.modelState.move(false, lineNumber, maxColumn, 0));
            }
            return result;
        };
        return class_7;
    }(CoreEditorCommand)));
    var TopCommand = /** @class */ (function (_super) {
        __extends$A(TopCommand, _super);
        function TopCommand(opts) {
            var _this = _super.call(this, opts) || this;
            _this._inSelectionMode = opts.inSelectionMode;
            return _this;
        }
        TopCommand.prototype.runCoreEditorCommand = function (cursors, args) {
            cursors.context.model.pushStackElement();
            cursors.setStates(args.source, CursorChangeReason.Explicit, CursorMoveCommands.moveToBeginningOfBuffer(cursors.context, cursors.getAll(), this._inSelectionMode));
            cursors.reveal(true, 0 /* Primary */, 0 /* Smooth */);
        };
        return TopCommand;
    }(CoreEditorCommand));
    CoreNavigationCommands.CursorTop = registerEditorCommand(new TopCommand({
        inSelectionMode: false,
        id: 'cursorTop',
        precondition: null,
        kbOpts: {
            weight: CORE_WEIGHT,
            kbExpr: EditorContextKeys.textInputFocus,
            primary: 2048 /* CtrlCmd */ | 14 /* Home */,
            mac: { primary: 2048 /* CtrlCmd */ | 16 /* UpArrow */ }
        }
    }));
    CoreNavigationCommands.CursorTopSelect = registerEditorCommand(new TopCommand({
        inSelectionMode: true,
        id: 'cursorTopSelect',
        precondition: null,
        kbOpts: {
            weight: CORE_WEIGHT,
            kbExpr: EditorContextKeys.textInputFocus,
            primary: 2048 /* CtrlCmd */ | 1024 /* Shift */ | 14 /* Home */,
            mac: { primary: 2048 /* CtrlCmd */ | 1024 /* Shift */ | 16 /* UpArrow */ }
        }
    }));
    var BottomCommand = /** @class */ (function (_super) {
        __extends$A(BottomCommand, _super);
        function BottomCommand(opts) {
            var _this = _super.call(this, opts) || this;
            _this._inSelectionMode = opts.inSelectionMode;
            return _this;
        }
        BottomCommand.prototype.runCoreEditorCommand = function (cursors, args) {
            cursors.context.model.pushStackElement();
            cursors.setStates(args.source, CursorChangeReason.Explicit, CursorMoveCommands.moveToEndOfBuffer(cursors.context, cursors.getAll(), this._inSelectionMode));
            cursors.reveal(true, 0 /* Primary */, 0 /* Smooth */);
        };
        return BottomCommand;
    }(CoreEditorCommand));
    CoreNavigationCommands.CursorBottom = registerEditorCommand(new BottomCommand({
        inSelectionMode: false,
        id: 'cursorBottom',
        precondition: null,
        kbOpts: {
            weight: CORE_WEIGHT,
            kbExpr: EditorContextKeys.textInputFocus,
            primary: 2048 /* CtrlCmd */ | 13 /* End */,
            mac: { primary: 2048 /* CtrlCmd */ | 18 /* DownArrow */ }
        }
    }));
    CoreNavigationCommands.CursorBottomSelect = registerEditorCommand(new BottomCommand({
        inSelectionMode: true,
        id: 'cursorBottomSelect',
        precondition: null,
        kbOpts: {
            weight: CORE_WEIGHT,
            kbExpr: EditorContextKeys.textInputFocus,
            primary: 2048 /* CtrlCmd */ | 1024 /* Shift */ | 13 /* End */,
            mac: { primary: 2048 /* CtrlCmd */ | 1024 /* Shift */ | 18 /* DownArrow */ }
        }
    }));
    var EditorScrollImpl = /** @class */ (function (_super) {
        __extends$A(EditorScrollImpl, _super);
        function EditorScrollImpl() {
            return _super.call(this, {
                id: 'editorScroll',
                precondition: null,
                description: EditorScroll_.description
            }) || this;
        }
        EditorScrollImpl.prototype.runCoreEditorCommand = function (cursors, args) {
            var parsed = EditorScroll_.parse(args);
            if (!parsed) {
                // illegal arguments
                return;
            }
            this._runEditorScroll(cursors, args.source, parsed);
        };
        EditorScrollImpl.prototype._runEditorScroll = function (cursors, source, args) {
            var desiredScrollTop = this._computeDesiredScrollTop(cursors.context, args);
            if (args.revealCursor) {
                // must ensure cursor is in new visible range
                var desiredVisibleViewRange = cursors.context.getCompletelyVisibleViewRangeAtScrollTop(desiredScrollTop);
                cursors.setStates(source, CursorChangeReason.Explicit, [
                    CursorMoveCommands.findPositionInViewportIfOutside(cursors.context, cursors.getPrimaryCursor(), desiredVisibleViewRange, args.select)
                ]);
            }
            cursors.scrollTo(desiredScrollTop);
        };
        EditorScrollImpl.prototype._computeDesiredScrollTop = function (context, args) {
            if (args.unit === 1 /* Line */) {
                // scrolling by model lines
                var visibleModelRange = context.getCompletelyVisibleModelRange();
                var desiredTopModelLineNumber = void 0;
                if (args.direction === 1 /* Up */) {
                    // must go x model lines up
                    desiredTopModelLineNumber = Math.max(1, visibleModelRange.startLineNumber - args.value);
                }
                else {
                    // must go x model lines down
                    desiredTopModelLineNumber = Math.min(context.model.getLineCount(), visibleModelRange.startLineNumber + args.value);
                }
                var desiredTopViewPosition = context.convertModelPositionToViewPosition(new Position(desiredTopModelLineNumber, 1));
                return context.getVerticalOffsetForViewLine(desiredTopViewPosition.lineNumber);
            }
            var noOfLines;
            if (args.unit === 3 /* Page */) {
                noOfLines = context.config.pageSize * args.value;
            }
            else if (args.unit === 4 /* HalfPage */) {
                noOfLines = Math.round(context.config.pageSize / 2) * args.value;
            }
            else {
                noOfLines = args.value;
            }
            var deltaLines = (args.direction === 1 /* Up */ ? -1 : 1) * noOfLines;
            return context.getCurrentScrollTop() + deltaLines * context.config.lineHeight;
        };
        return EditorScrollImpl;
    }(CoreEditorCommand));
    CoreNavigationCommands.EditorScrollImpl = EditorScrollImpl;
    CoreNavigationCommands.EditorScroll = registerEditorCommand(new EditorScrollImpl());
    CoreNavigationCommands.ScrollLineUp = registerEditorCommand(new /** @class */ (function (_super) {
        __extends$A(class_8, _super);
        function class_8() {
            return _super.call(this, {
                id: 'scrollLineUp',
                precondition: null,
                kbOpts: {
                    weight: CORE_WEIGHT,
                    kbExpr: EditorContextKeys.textInputFocus,
                    primary: 2048 /* CtrlCmd */ | 16 /* UpArrow */,
                    mac: { primary: 256 /* WinCtrl */ | 11 /* PageUp */ }
                }
            }) || this;
        }
        class_8.prototype.runCoreEditorCommand = function (cursors, args) {
            CoreNavigationCommands.EditorScroll._runEditorScroll(cursors, args.source, {
                direction: 1 /* Up */,
                unit: 2 /* WrappedLine */,
                value: 1,
                revealCursor: false,
                select: false
            });
        };
        return class_8;
    }(CoreEditorCommand)));
    CoreNavigationCommands.ScrollPageUp = registerEditorCommand(new /** @class */ (function (_super) {
        __extends$A(class_9, _super);
        function class_9() {
            return _super.call(this, {
                id: 'scrollPageUp',
                precondition: null,
                kbOpts: {
                    weight: CORE_WEIGHT,
                    kbExpr: EditorContextKeys.textInputFocus,
                    primary: 2048 /* CtrlCmd */ | 11 /* PageUp */,
                    win: { primary: 512 /* Alt */ | 11 /* PageUp */ },
                    linux: { primary: 512 /* Alt */ | 11 /* PageUp */ }
                }
            }) || this;
        }
        class_9.prototype.runCoreEditorCommand = function (cursors, args) {
            CoreNavigationCommands.EditorScroll._runEditorScroll(cursors, args.source, {
                direction: 1 /* Up */,
                unit: 3 /* Page */,
                value: 1,
                revealCursor: false,
                select: false
            });
        };
        return class_9;
    }(CoreEditorCommand)));
    CoreNavigationCommands.ScrollLineDown = registerEditorCommand(new /** @class */ (function (_super) {
        __extends$A(class_10, _super);
        function class_10() {
            return _super.call(this, {
                id: 'scrollLineDown',
                precondition: null,
                kbOpts: {
                    weight: CORE_WEIGHT,
                    kbExpr: EditorContextKeys.textInputFocus,
                    primary: 2048 /* CtrlCmd */ | 18 /* DownArrow */,
                    mac: { primary: 256 /* WinCtrl */ | 12 /* PageDown */ }
                }
            }) || this;
        }
        class_10.prototype.runCoreEditorCommand = function (cursors, args) {
            CoreNavigationCommands.EditorScroll._runEditorScroll(cursors, args.source, {
                direction: 2 /* Down */,
                unit: 2 /* WrappedLine */,
                value: 1,
                revealCursor: false,
                select: false
            });
        };
        return class_10;
    }(CoreEditorCommand)));
    CoreNavigationCommands.ScrollPageDown = registerEditorCommand(new /** @class */ (function (_super) {
        __extends$A(class_11, _super);
        function class_11() {
            return _super.call(this, {
                id: 'scrollPageDown',
                precondition: null,
                kbOpts: {
                    weight: CORE_WEIGHT,
                    kbExpr: EditorContextKeys.textInputFocus,
                    primary: 2048 /* CtrlCmd */ | 12 /* PageDown */,
                    win: { primary: 512 /* Alt */ | 12 /* PageDown */ },
                    linux: { primary: 512 /* Alt */ | 12 /* PageDown */ }
                }
            }) || this;
        }
        class_11.prototype.runCoreEditorCommand = function (cursors, args) {
            CoreNavigationCommands.EditorScroll._runEditorScroll(cursors, args.source, {
                direction: 2 /* Down */,
                unit: 3 /* Page */,
                value: 1,
                revealCursor: false,
                select: false
            });
        };
        return class_11;
    }(CoreEditorCommand)));
    var WordCommand = /** @class */ (function (_super) {
        __extends$A(WordCommand, _super);
        function WordCommand(opts) {
            var _this = _super.call(this, opts) || this;
            _this._inSelectionMode = opts.inSelectionMode;
            return _this;
        }
        WordCommand.prototype.runCoreEditorCommand = function (cursors, args) {
            cursors.context.model.pushStackElement();
            cursors.setStates(args.source, CursorChangeReason.Explicit, [
                CursorMoveCommands.word(cursors.context, cursors.getPrimaryCursor(), this._inSelectionMode, args.position)
            ]);
            cursors.reveal(true, 0 /* Primary */, 0 /* Smooth */);
        };
        return WordCommand;
    }(CoreEditorCommand));
    CoreNavigationCommands.WordSelect = registerEditorCommand(new WordCommand({
        inSelectionMode: false,
        id: '_wordSelect',
        precondition: null
    }));
    CoreNavigationCommands.WordSelectDrag = registerEditorCommand(new WordCommand({
        inSelectionMode: true,
        id: '_wordSelectDrag',
        precondition: null
    }));
    CoreNavigationCommands.LastCursorWordSelect = registerEditorCommand(new /** @class */ (function (_super) {
        __extends$A(class_12, _super);
        function class_12() {
            return _super.call(this, {
                id: 'lastCursorWordSelect',
                precondition: null
            }) || this;
        }
        class_12.prototype.runCoreEditorCommand = function (cursors, args) {
            var context = cursors.context;
            if (context.config.readOnly) {
                return;
            }
            var lastAddedCursorIndex = cursors.getLastAddedCursorIndex();
            var newStates = cursors.getAll().slice(0);
            var lastAddedState = newStates[lastAddedCursorIndex];
            newStates[lastAddedCursorIndex] = CursorMoveCommands.word(context, lastAddedState, lastAddedState.modelState.hasSelection(), args.position);
            context.model.pushStackElement();
            cursors.setStates(args.source, CursorChangeReason.Explicit, newStates);
        };
        return class_12;
    }(CoreEditorCommand)));
    var LineCommand = /** @class */ (function (_super) {
        __extends$A(LineCommand, _super);
        function LineCommand(opts) {
            var _this = _super.call(this, opts) || this;
            _this._inSelectionMode = opts.inSelectionMode;
            return _this;
        }
        LineCommand.prototype.runCoreEditorCommand = function (cursors, args) {
            cursors.context.model.pushStackElement();
            cursors.setStates(args.source, CursorChangeReason.Explicit, [
                CursorMoveCommands.line(cursors.context, cursors.getPrimaryCursor(), this._inSelectionMode, args.position, args.viewPosition)
            ]);
            cursors.reveal(false, 0 /* Primary */, 0 /* Smooth */);
        };
        return LineCommand;
    }(CoreEditorCommand));
    CoreNavigationCommands.LineSelect = registerEditorCommand(new LineCommand({
        inSelectionMode: false,
        id: '_lineSelect',
        precondition: null
    }));
    CoreNavigationCommands.LineSelectDrag = registerEditorCommand(new LineCommand({
        inSelectionMode: true,
        id: '_lineSelectDrag',
        precondition: null
    }));
    var LastCursorLineCommand = /** @class */ (function (_super) {
        __extends$A(LastCursorLineCommand, _super);
        function LastCursorLineCommand(opts) {
            var _this = _super.call(this, opts) || this;
            _this._inSelectionMode = opts.inSelectionMode;
            return _this;
        }
        LastCursorLineCommand.prototype.runCoreEditorCommand = function (cursors, args) {
            var context = cursors.context;
            if (context.config.readOnly) {
                return;
            }
            var lastAddedCursorIndex = cursors.getLastAddedCursorIndex();
            var newStates = cursors.getAll().slice(0);
            newStates[lastAddedCursorIndex] = CursorMoveCommands.line(cursors.context, newStates[lastAddedCursorIndex], this._inSelectionMode, args.position, args.viewPosition);
            cursors.context.model.pushStackElement();
            cursors.setStates(args.source, CursorChangeReason.Explicit, newStates);
        };
        return LastCursorLineCommand;
    }(CoreEditorCommand));
    CoreNavigationCommands.LastCursorLineSelect = registerEditorCommand(new LastCursorLineCommand({
        inSelectionMode: false,
        id: 'lastCursorLineSelect',
        precondition: null
    }));
    CoreNavigationCommands.LastCursorLineSelectDrag = registerEditorCommand(new LastCursorLineCommand({
        inSelectionMode: true,
        id: 'lastCursorLineSelectDrag',
        precondition: null
    }));
    CoreNavigationCommands.ExpandLineSelection = registerEditorCommand(new /** @class */ (function (_super) {
        __extends$A(class_13, _super);
        function class_13() {
            return _super.call(this, {
                id: 'expandLineSelection',
                precondition: null,
                kbOpts: {
                    weight: CORE_WEIGHT,
                    kbExpr: EditorContextKeys.textInputFocus,
                    primary: 2048 /* CtrlCmd */ | 39 /* KEY_I */
                }
            }) || this;
        }
        class_13.prototype.runCoreEditorCommand = function (cursors, args) {
            cursors.context.model.pushStackElement();
            cursors.setStates(args.source, CursorChangeReason.Explicit, CursorMoveCommands.expandLineSelection(cursors.context, cursors.getAll()));
            cursors.reveal(true, 0 /* Primary */, 0 /* Smooth */);
        };
        return class_13;
    }(CoreEditorCommand)));
    CoreNavigationCommands.CancelSelection = registerEditorCommand(new /** @class */ (function (_super) {
        __extends$A(class_14, _super);
        function class_14() {
            return _super.call(this, {
                id: 'cancelSelection',
                precondition: EditorContextKeys.hasNonEmptySelection,
                kbOpts: {
                    weight: CORE_WEIGHT,
                    kbExpr: EditorContextKeys.textInputFocus,
                    primary: 9 /* Escape */,
                    secondary: [1024 /* Shift */ | 9 /* Escape */]
                }
            }) || this;
        }
        class_14.prototype.runCoreEditorCommand = function (cursors, args) {
            cursors.context.model.pushStackElement();
            cursors.setStates(args.source, CursorChangeReason.Explicit, [
                CursorMoveCommands.cancelSelection(cursors.context, cursors.getPrimaryCursor())
            ]);
            cursors.reveal(true, 0 /* Primary */, 0 /* Smooth */);
        };
        return class_14;
    }(CoreEditorCommand)));
    CoreNavigationCommands.RemoveSecondaryCursors = registerEditorCommand(new /** @class */ (function (_super) {
        __extends$A(class_15, _super);
        function class_15() {
            return _super.call(this, {
                id: 'removeSecondaryCursors',
                precondition: EditorContextKeys.hasMultipleSelections,
                kbOpts: {
                    weight: CORE_WEIGHT + 1,
                    kbExpr: EditorContextKeys.textInputFocus,
                    primary: 9 /* Escape */,
                    secondary: [1024 /* Shift */ | 9 /* Escape */]
                }
            }) || this;
        }
        class_15.prototype.runCoreEditorCommand = function (cursors, args) {
            cursors.context.model.pushStackElement();
            cursors.setStates(args.source, CursorChangeReason.Explicit, [
                cursors.getPrimaryCursor()
            ]);
            cursors.reveal(true, 0 /* Primary */, 0 /* Smooth */);
        };
        return class_15;
    }(CoreEditorCommand)));
    CoreNavigationCommands.RevealLine = registerEditorCommand(new /** @class */ (function (_super) {
        __extends$A(class_16, _super);
        function class_16() {
            return _super.call(this, {
                id: 'revealLine',
                precondition: null,
                description: RevealLine_.description
            }) || this;
        }
        class_16.prototype.runCoreEditorCommand = function (cursors, args) {
            var revealLineArg = args;
            var lineNumber = revealLineArg.lineNumber + 1;
            if (lineNumber < 1) {
                lineNumber = 1;
            }
            var lineCount = cursors.context.model.getLineCount();
            if (lineNumber > lineCount) {
                lineNumber = lineCount;
            }
            var range = new Range(lineNumber, 1, lineNumber, cursors.context.model.getLineMaxColumn(lineNumber));
            var revealAt = 0 /* Simple */;
            if (revealLineArg.at) {
                switch (revealLineArg.at) {
                    case RevealLine_.RawAtArgument.Top:
                        revealAt = 3 /* Top */;
                        break;
                    case RevealLine_.RawAtArgument.Center:
                        revealAt = 1 /* Center */;
                        break;
                    case RevealLine_.RawAtArgument.Bottom:
                        revealAt = 4 /* Bottom */;
                        break;
                    default:
                        break;
                }
            }
            var viewRange = cursors.context.convertModelRangeToViewRange(range);
            cursors.revealRange(false, viewRange, revealAt, 0 /* Smooth */);
        };
        return class_16;
    }(CoreEditorCommand)));
    CoreNavigationCommands.SelectAll = registerEditorCommand(new /** @class */ (function (_super) {
        __extends$A(class_17, _super);
        function class_17() {
            return _super.call(this, {
                id: 'selectAll',
                precondition: null
            }) || this;
        }
        class_17.prototype.runCoreEditorCommand = function (cursors, args) {
            cursors.context.model.pushStackElement();
            cursors.setStates(args.source, CursorChangeReason.Explicit, [
                CursorMoveCommands.selectAll(cursors.context, cursors.getPrimaryCursor())
            ]);
        };
        return class_17;
    }(CoreEditorCommand)));
    CoreNavigationCommands.SetSelection = registerEditorCommand(new /** @class */ (function (_super) {
        __extends$A(class_18, _super);
        function class_18() {
            return _super.call(this, {
                id: 'setSelection',
                precondition: null
            }) || this;
        }
        class_18.prototype.runCoreEditorCommand = function (cursors, args) {
            cursors.context.model.pushStackElement();
            cursors.setStates(args.source, CursorChangeReason.Explicit, [
                CursorState.fromModelSelection(args.selection)
            ]);
        };
        return class_18;
    }(CoreEditorCommand)));
})(CoreNavigationCommands || (CoreNavigationCommands = {}));
var CoreEditingCommands;
(function (CoreEditingCommands) {
    CoreEditingCommands.LineBreakInsert = registerEditorCommand(new /** @class */ (function (_super) {
        __extends$A(class_19, _super);
        function class_19() {
            return _super.call(this, {
                id: 'lineBreakInsert',
                precondition: EditorContextKeys.writable,
                kbOpts: {
                    weight: CORE_WEIGHT,
                    kbExpr: EditorContextKeys.textInputFocus,
                    primary: null,
                    mac: { primary: 256 /* WinCtrl */ | 45 /* KEY_O */ }
                }
            }) || this;
        }
        class_19.prototype.runEditorCommand = function (accessor, editor, args) {
            editor.pushUndoStop();
            editor.executeCommands(this.id, TypeOperations.lineBreakInsert(editor._getCursorConfiguration(), editor.getModel(), editor.getSelections()));
        };
        return class_19;
    }(EditorCommand)));
    CoreEditingCommands.Outdent = registerEditorCommand(new /** @class */ (function (_super) {
        __extends$A(class_20, _super);
        function class_20() {
            return _super.call(this, {
                id: 'outdent',
                precondition: EditorContextKeys.writable,
                kbOpts: {
                    weight: CORE_WEIGHT,
                    kbExpr: ContextKeyExpr.and(EditorContextKeys.editorTextFocus, EditorContextKeys.tabDoesNotMoveFocus),
                    primary: 1024 /* Shift */ | 2 /* Tab */
                }
            }) || this;
        }
        class_20.prototype.runEditorCommand = function (accessor, editor, args) {
            editor.pushUndoStop();
            editor.executeCommands(this.id, TypeOperations.outdent(editor._getCursorConfiguration(), editor.getModel(), editor.getSelections()));
            editor.pushUndoStop();
        };
        return class_20;
    }(EditorCommand)));
    CoreEditingCommands.Tab = registerEditorCommand(new /** @class */ (function (_super) {
        __extends$A(class_21, _super);
        function class_21() {
            return _super.call(this, {
                id: 'tab',
                precondition: EditorContextKeys.writable,
                kbOpts: {
                    weight: CORE_WEIGHT,
                    kbExpr: ContextKeyExpr.and(EditorContextKeys.editorTextFocus, EditorContextKeys.tabDoesNotMoveFocus),
                    primary: 2 /* Tab */
                }
            }) || this;
        }
        class_21.prototype.runEditorCommand = function (accessor, editor, args) {
            editor.pushUndoStop();
            editor.executeCommands(this.id, TypeOperations.tab(editor._getCursorConfiguration(), editor.getModel(), editor.getSelections()));
            editor.pushUndoStop();
        };
        return class_21;
    }(EditorCommand)));
    CoreEditingCommands.DeleteLeft = registerEditorCommand(new /** @class */ (function (_super) {
        __extends$A(class_22, _super);
        function class_22() {
            return _super.call(this, {
                id: 'deleteLeft',
                precondition: EditorContextKeys.writable,
                kbOpts: {
                    weight: CORE_WEIGHT,
                    kbExpr: EditorContextKeys.textInputFocus,
                    primary: 1 /* Backspace */,
                    secondary: [1024 /* Shift */ | 1 /* Backspace */],
                    mac: { primary: 1 /* Backspace */, secondary: [1024 /* Shift */ | 1 /* Backspace */, 256 /* WinCtrl */ | 38 /* KEY_H */, 256 /* WinCtrl */ | 1 /* Backspace */] }
                }
            }) || this;
        }
        class_22.prototype.runEditorCommand = function (accessor, editor, args) {
            var cursors = editor._getCursors();
            var _a = DeleteOperations.deleteLeft(cursors.getPrevEditOperationType(), editor._getCursorConfiguration(), editor.getModel(), editor.getSelections()), shouldPushStackElementBefore = _a[0], commands = _a[1];
            if (shouldPushStackElementBefore) {
                editor.pushUndoStop();
            }
            editor.executeCommands(this.id, commands);
            cursors.setPrevEditOperationType(2 /* DeletingLeft */);
        };
        return class_22;
    }(EditorCommand)));
    CoreEditingCommands.DeleteRight = registerEditorCommand(new /** @class */ (function (_super) {
        __extends$A(class_23, _super);
        function class_23() {
            return _super.call(this, {
                id: 'deleteRight',
                precondition: EditorContextKeys.writable,
                kbOpts: {
                    weight: CORE_WEIGHT,
                    kbExpr: EditorContextKeys.textInputFocus,
                    primary: 20 /* Delete */,
                    mac: { primary: 20 /* Delete */, secondary: [256 /* WinCtrl */ | 34 /* KEY_D */, 256 /* WinCtrl */ | 20 /* Delete */] }
                }
            }) || this;
        }
        class_23.prototype.runEditorCommand = function (accessor, editor, args) {
            var cursors = editor._getCursors();
            var _a = DeleteOperations.deleteRight(cursors.getPrevEditOperationType(), editor._getCursorConfiguration(), editor.getModel(), editor.getSelections()), shouldPushStackElementBefore = _a[0], commands = _a[1];
            if (shouldPushStackElementBefore) {
                editor.pushUndoStop();
            }
            editor.executeCommands(this.id, commands);
            cursors.setPrevEditOperationType(3 /* DeletingRight */);
        };
        return class_23;
    }(EditorCommand)));
})(CoreEditingCommands || (CoreEditingCommands = {}));
function findFocusedEditor(accessor) {
    return accessor.get(ICodeEditorService).getFocusedCodeEditor();
}
function getWorkbenchActiveEditor$1(accessor) {
    var editorService = accessor.get(IEditorService);
    var activeEditor = editorService.getActiveEditor && editorService.getActiveEditor();
    return getCodeEditor(activeEditor);
}
function registerCommand(command) {
    KeybindingsRegistry.registerCommandAndKeybindingRule(command.toCommandAndKeybindingRule(CORE_WEIGHT));
}
/**
 * A command that will:
 *  1. invoke a command on the focused editor.
 *  2. otherwise, invoke a browser built-in command on the `activeElement`.
 *  3. otherwise, invoke a command on the workbench active editor.
 */
var EditorOrNativeTextInputCommand = /** @class */ (function (_super) {
    __extends$A(EditorOrNativeTextInputCommand, _super);
    function EditorOrNativeTextInputCommand(opts) {
        var _this = _super.call(this, opts) || this;
        _this._editorHandler = opts.editorHandler;
        _this._inputHandler = opts.inputHandler;
        return _this;
    }
    EditorOrNativeTextInputCommand.prototype.runCommand = function (accessor, args) {
        var focusedEditor = findFocusedEditor(accessor);
        // Only if editor text focus (i.e. not if editor has widget focus).
        if (focusedEditor && focusedEditor.isFocused()) {
            return this._runEditorHandler(focusedEditor, args);
        }
        // Ignore this action when user is focused on an element that allows for entering text
        var activeElement = document.activeElement;
        if (activeElement && ['input', 'textarea'].indexOf(activeElement.tagName.toLowerCase()) >= 0) {
            document.execCommand(this._inputHandler);
            return;
        }
        // Redirecting to last active editor
        var activeEditor = getWorkbenchActiveEditor$1(accessor);
        if (activeEditor) {
            activeEditor.focus();
            return this._runEditorHandler(activeEditor, args);
        }
    };
    EditorOrNativeTextInputCommand.prototype._runEditorHandler = function (editor, args) {
        var HANDLER = this._editorHandler;
        if (typeof HANDLER === 'string') {
            editor.trigger('keyboard', HANDLER, args);
        }
        else {
            args = args || {};
            args.source = 'keyboard';
            HANDLER.runEditorCommand(null, editor, args);
        }
    };
    return EditorOrNativeTextInputCommand;
}(Command));
/**
 * A command that will invoke a command on the focused editor.
 */
var EditorHandlerCommand = /** @class */ (function (_super) {
    __extends$A(EditorHandlerCommand, _super);
    function EditorHandlerCommand(id, handlerId) {
        var _this = _super.call(this, {
            id: id,
            precondition: null
        }) || this;
        _this._handlerId = handlerId;
        return _this;
    }
    EditorHandlerCommand.prototype.runCommand = function (accessor, args) {
        var editor = findFocusedEditor(accessor);
        if (!editor) {
            return;
        }
        editor.trigger('keyboard', this._handlerId, args);
    };
    return EditorHandlerCommand;
}(Command));
registerCommand(new EditorOrNativeTextInputCommand({
    editorHandler: CoreNavigationCommands.SelectAll,
    inputHandler: 'selectAll',
    id: 'editor.action.selectAll',
    precondition: null,
    kbOpts: {
        weight: CORE_WEIGHT,
        kbExpr: null,
        primary: 2048 /* CtrlCmd */ | 31 /* KEY_A */
    }
}));
registerCommand(new EditorOrNativeTextInputCommand({
    editorHandler: H.Undo,
    inputHandler: 'undo',
    id: H.Undo,
    precondition: EditorContextKeys.writable,
    kbOpts: {
        weight: CORE_WEIGHT,
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 2048 /* CtrlCmd */ | 56 /* KEY_Z */
    }
}));
registerCommand(new EditorHandlerCommand('default:' + H.Undo, H.Undo));
registerCommand(new EditorOrNativeTextInputCommand({
    editorHandler: H.Redo,
    inputHandler: 'redo',
    id: H.Redo,
    precondition: EditorContextKeys.writable,
    kbOpts: {
        weight: CORE_WEIGHT,
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 2048 /* CtrlCmd */ | 55 /* KEY_Y */,
        secondary: [2048 /* CtrlCmd */ | 1024 /* Shift */ | 56 /* KEY_Z */],
        mac: { primary: 2048 /* CtrlCmd */ | 1024 /* Shift */ | 56 /* KEY_Z */ }
    }
}));
registerCommand(new EditorHandlerCommand('default:' + H.Redo, H.Redo));
function registerOverwritableCommand(handlerId) {
    registerCommand(new EditorHandlerCommand('default:' + handlerId, handlerId));
    registerCommand(new EditorHandlerCommand(handlerId, handlerId));
}
registerOverwritableCommand(H.Type);
registerOverwritableCommand(H.ReplacePreviousChar);
registerOverwritableCommand(H.CompositionStart);
registerOverwritableCommand(H.CompositionEnd);
registerOverwritableCommand(H.Paste);
registerOverwritableCommand(H.Cut);

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var ViewController = /** @class */ (function () {
    function ViewController(configuration, viewModel, execCommandFunc, outgoingEvents, commandDelegate) {
        this.configuration = configuration;
        this.viewModel = viewModel;
        this._execCoreEditorCommandFunc = execCommandFunc;
        this.outgoingEvents = outgoingEvents;
        this.commandDelegate = commandDelegate;
    }
    ViewController.prototype._execMouseCommand = function (editorCommand, args) {
        args.source = 'mouse';
        this._execCoreEditorCommandFunc(editorCommand, args);
    };
    ViewController.prototype.paste = function (source, text, pasteOnNewLine, multicursorText) {
        this.commandDelegate.paste(source, text, pasteOnNewLine, multicursorText);
    };
    ViewController.prototype.type = function (source, text) {
        this.commandDelegate.type(source, text);
    };
    ViewController.prototype.replacePreviousChar = function (source, text, replaceCharCnt) {
        this.commandDelegate.replacePreviousChar(source, text, replaceCharCnt);
    };
    ViewController.prototype.compositionStart = function (source) {
        this.commandDelegate.compositionStart(source);
    };
    ViewController.prototype.compositionEnd = function (source) {
        this.commandDelegate.compositionEnd(source);
    };
    ViewController.prototype.cut = function (source) {
        this.commandDelegate.cut(source);
    };
    ViewController.prototype.setSelection = function (source, modelSelection) {
        this._execCoreEditorCommandFunc(CoreNavigationCommands.SetSelection, {
            source: source,
            selection: modelSelection
        });
    };
    ViewController.prototype._validateViewColumn = function (viewPosition) {
        var minColumn = this.viewModel.getLineMinColumn(viewPosition.lineNumber);
        if (viewPosition.column < minColumn) {
            return new Position(viewPosition.lineNumber, minColumn);
        }
        return viewPosition;
    };
    ViewController.prototype._hasMulticursorModifier = function (data) {
        switch (this.configuration.editor.multiCursorModifier) {
            case 'altKey':
                return data.altKey;
            case 'ctrlKey':
                return data.ctrlKey;
            case 'metaKey':
                return data.metaKey;
        }
        return false;
    };
    ViewController.prototype._hasNonMulticursorModifier = function (data) {
        switch (this.configuration.editor.multiCursorModifier) {
            case 'altKey':
                return data.ctrlKey || data.metaKey;
            case 'ctrlKey':
                return data.altKey || data.metaKey;
            case 'metaKey':
                return data.ctrlKey || data.altKey;
        }
        return false;
    };
    ViewController.prototype.dispatchMouse = function (data) {
        if (data.middleButton) {
            if (data.inSelectionMode) {
                this.columnSelect(data.position, data.mouseColumn);
            }
            else {
                this.moveTo(data.position);
            }
        }
        else if (data.startedOnLineNumbers) {
            // If the dragging started on the gutter, then have operations work on the entire line
            if (this._hasMulticursorModifier(data)) {
                if (data.inSelectionMode) {
                    this.lastCursorLineSelect(data.position);
                }
                else {
                    this.createCursor(data.position, true);
                }
            }
            else {
                if (data.inSelectionMode) {
                    this.lineSelectDrag(data.position);
                }
                else {
                    this.lineSelect(data.position);
                }
            }
        }
        else if (data.mouseDownCount >= 4) {
            this.selectAll();
        }
        else if (data.mouseDownCount === 3) {
            if (this._hasMulticursorModifier(data)) {
                if (data.inSelectionMode) {
                    this.lastCursorLineSelectDrag(data.position);
                }
                else {
                    this.lastCursorLineSelect(data.position);
                }
            }
            else {
                if (data.inSelectionMode) {
                    this.lineSelectDrag(data.position);
                }
                else {
                    this.lineSelect(data.position);
                }
            }
        }
        else if (data.mouseDownCount === 2) {
            if (this._hasMulticursorModifier(data)) {
                this.lastCursorWordSelect(data.position);
            }
            else {
                if (data.inSelectionMode) {
                    this.wordSelectDrag(data.position);
                }
                else {
                    this.wordSelect(data.position);
                }
            }
        }
        else {
            if (this._hasMulticursorModifier(data)) {
                if (!this._hasNonMulticursorModifier(data)) {
                    if (data.shiftKey) {
                        this.columnSelect(data.position, data.mouseColumn);
                    }
                    else {
                        // Do multi-cursor operations only when purely alt is pressed
                        if (data.inSelectionMode) {
                            this.lastCursorMoveToSelect(data.position);
                        }
                        else {
                            this.createCursor(data.position, false);
                        }
                    }
                }
            }
            else {
                if (data.inSelectionMode) {
                    this.moveToSelect(data.position);
                }
                else {
                    this.moveTo(data.position);
                }
            }
        }
    };
    ViewController.prototype._usualArgs = function (viewPosition) {
        viewPosition = this._validateViewColumn(viewPosition);
        return {
            position: this.convertViewToModelPosition(viewPosition),
            viewPosition: viewPosition
        };
    };
    ViewController.prototype.moveTo = function (viewPosition) {
        this._execMouseCommand(CoreNavigationCommands.MoveTo, this._usualArgs(viewPosition));
    };
    ViewController.prototype.moveToSelect = function (viewPosition) {
        this._execMouseCommand(CoreNavigationCommands.MoveToSelect, this._usualArgs(viewPosition));
    };
    ViewController.prototype.columnSelect = function (viewPosition, mouseColumn) {
        viewPosition = this._validateViewColumn(viewPosition);
        this._execMouseCommand(CoreNavigationCommands.ColumnSelect, {
            position: this.convertViewToModelPosition(viewPosition),
            viewPosition: viewPosition,
            mouseColumn: mouseColumn
        });
    };
    ViewController.prototype.createCursor = function (viewPosition, wholeLine) {
        viewPosition = this._validateViewColumn(viewPosition);
        this._execMouseCommand(CoreNavigationCommands.CreateCursor, {
            position: this.convertViewToModelPosition(viewPosition),
            viewPosition: viewPosition,
            wholeLine: wholeLine
        });
    };
    ViewController.prototype.lastCursorMoveToSelect = function (viewPosition) {
        this._execMouseCommand(CoreNavigationCommands.LastCursorMoveToSelect, this._usualArgs(viewPosition));
    };
    ViewController.prototype.wordSelect = function (viewPosition) {
        this._execMouseCommand(CoreNavigationCommands.WordSelect, this._usualArgs(viewPosition));
    };
    ViewController.prototype.wordSelectDrag = function (viewPosition) {
        this._execMouseCommand(CoreNavigationCommands.WordSelectDrag, this._usualArgs(viewPosition));
    };
    ViewController.prototype.lastCursorWordSelect = function (viewPosition) {
        this._execMouseCommand(CoreNavigationCommands.LastCursorWordSelect, this._usualArgs(viewPosition));
    };
    ViewController.prototype.lineSelect = function (viewPosition) {
        this._execMouseCommand(CoreNavigationCommands.LineSelect, this._usualArgs(viewPosition));
    };
    ViewController.prototype.lineSelectDrag = function (viewPosition) {
        this._execMouseCommand(CoreNavigationCommands.LineSelectDrag, this._usualArgs(viewPosition));
    };
    ViewController.prototype.lastCursorLineSelect = function (viewPosition) {
        this._execMouseCommand(CoreNavigationCommands.LastCursorLineSelect, this._usualArgs(viewPosition));
    };
    ViewController.prototype.lastCursorLineSelectDrag = function (viewPosition) {
        this._execMouseCommand(CoreNavigationCommands.LastCursorLineSelectDrag, this._usualArgs(viewPosition));
    };
    ViewController.prototype.selectAll = function () {
        this._execMouseCommand(CoreNavigationCommands.SelectAll, {});
    };
    // ----------------------
    ViewController.prototype.convertViewToModelPosition = function (viewPosition) {
        return this.viewModel.coordinatesConverter.convertViewPositionToModelPosition(viewPosition);
    };
    ViewController.prototype.emitKeyDown = function (e) {
        this.outgoingEvents.emitKeyDown(e);
    };
    ViewController.prototype.emitKeyUp = function (e) {
        this.outgoingEvents.emitKeyUp(e);
    };
    ViewController.prototype.emitContextMenu = function (e) {
        this.outgoingEvents.emitContextMenu(e);
    };
    ViewController.prototype.emitMouseMove = function (e) {
        this.outgoingEvents.emitMouseMove(e);
    };
    ViewController.prototype.emitMouseLeave = function (e) {
        this.outgoingEvents.emitMouseLeave(e);
    };
    ViewController.prototype.emitMouseUp = function (e) {
        this.outgoingEvents.emitMouseUp(e);
    };
    ViewController.prototype.emitMouseDown = function (e) {
        this.outgoingEvents.emitMouseDown(e);
    };
    ViewController.prototype.emitMouseDrag = function (e) {
        this.outgoingEvents.emitMouseDrag(e);
    };
    ViewController.prototype.emitMouseDrop = function (e) {
        this.outgoingEvents.emitMouseDrop(e);
    };
    return ViewController;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var ViewEventDispatcher = /** @class */ (function () {
    function ViewEventDispatcher(eventHandlerGateKeeper) {
        this._eventHandlerGateKeeper = eventHandlerGateKeeper;
        this._eventHandlers = [];
        this._eventQueue = null;
        this._isConsumingQueue = false;
    }
    ViewEventDispatcher.prototype.addEventHandler = function (eventHandler) {
        for (var i = 0, len = this._eventHandlers.length; i < len; i++) {
            if (this._eventHandlers[i] === eventHandler) {
                console.warn('Detected duplicate listener in ViewEventDispatcher', eventHandler);
            }
        }
        this._eventHandlers.push(eventHandler);
    };
    ViewEventDispatcher.prototype.removeEventHandler = function (eventHandler) {
        for (var i = 0; i < this._eventHandlers.length; i++) {
            if (this._eventHandlers[i] === eventHandler) {
                this._eventHandlers.splice(i, 1);
                break;
            }
        }
    };
    ViewEventDispatcher.prototype.emit = function (event) {
        if (this._eventQueue) {
            this._eventQueue.push(event);
        }
        else {
            this._eventQueue = [event];
        }
        if (!this._isConsumingQueue) {
            this.consumeQueue();
        }
    };
    ViewEventDispatcher.prototype.emitMany = function (events) {
        if (this._eventQueue) {
            this._eventQueue = this._eventQueue.concat(events);
        }
        else {
            this._eventQueue = events;
        }
        if (!this._isConsumingQueue) {
            this.consumeQueue();
        }
    };
    ViewEventDispatcher.prototype.consumeQueue = function () {
        var _this = this;
        this._eventHandlerGateKeeper(function () {
            try {
                _this._isConsumingQueue = true;
                _this._doConsumeQueue();
            }
            finally {
                _this._isConsumingQueue = false;
            }
        });
    };
    ViewEventDispatcher.prototype._doConsumeQueue = function () {
        while (this._eventQueue) {
            // Empty event queue, as events might come in while sending these off
            var events = this._eventQueue;
            this._eventQueue = null;
            // Use a clone of the event handlers list, as they might remove themselves
            var eventHandlers = this._eventHandlers.slice(0);
            for (var i = 0, len = eventHandlers.length; i < len; i++) {
                eventHandlers[i].handleEvents(events);
            }
        }
    };
    return ViewEventDispatcher;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var RenderedLinesCollection = /** @class */ (function () {
    function RenderedLinesCollection(createLine) {
        this._createLine = createLine;
        this._set(1, []);
    }
    RenderedLinesCollection.prototype.flush = function () {
        this._set(1, []);
    };
    RenderedLinesCollection.prototype._set = function (rendLineNumberStart, lines) {
        this._lines = lines;
        this._rendLineNumberStart = rendLineNumberStart;
    };
    RenderedLinesCollection.prototype._get = function () {
        return {
            rendLineNumberStart: this._rendLineNumberStart,
            lines: this._lines
        };
    };
    /**
     * @returns Inclusive line number that is inside this collection
     */
    RenderedLinesCollection.prototype.getStartLineNumber = function () {
        return this._rendLineNumberStart;
    };
    /**
     * @returns Inclusive line number that is inside this collection
     */
    RenderedLinesCollection.prototype.getEndLineNumber = function () {
        return this._rendLineNumberStart + this._lines.length - 1;
    };
    RenderedLinesCollection.prototype.getCount = function () {
        return this._lines.length;
    };
    RenderedLinesCollection.prototype.getLine = function (lineNumber) {
        var lineIndex = lineNumber - this._rendLineNumberStart;
        if (lineIndex < 0 || lineIndex >= this._lines.length) {
            throw new Error('Illegal value for lineNumber');
        }
        return this._lines[lineIndex];
    };
    /**
     * @returns Lines that were removed from this collection
     */
    RenderedLinesCollection.prototype.onLinesDeleted = function (deleteFromLineNumber, deleteToLineNumber) {
        if (this.getCount() === 0) {
            // no lines
            return null;
        }
        var startLineNumber = this.getStartLineNumber();
        var endLineNumber = this.getEndLineNumber();
        if (deleteToLineNumber < startLineNumber) {
            // deleting above the viewport
            var deleteCnt = deleteToLineNumber - deleteFromLineNumber + 1;
            this._rendLineNumberStart -= deleteCnt;
            return null;
        }
        if (deleteFromLineNumber > endLineNumber) {
            // deleted below the viewport
            return null;
        }
        // Record what needs to be deleted
        var deleteStartIndex = 0;
        var deleteCount = 0;
        for (var lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {
            var lineIndex = lineNumber - this._rendLineNumberStart;
            if (deleteFromLineNumber <= lineNumber && lineNumber <= deleteToLineNumber) {
                // this is a line to be deleted
                if (deleteCount === 0) {
                    // this is the first line to be deleted
                    deleteStartIndex = lineIndex;
                    deleteCount = 1;
                }
                else {
                    deleteCount++;
                }
            }
        }
        // Adjust this._rendLineNumberStart for lines deleted above
        if (deleteFromLineNumber < startLineNumber) {
            // Something was deleted above
            var deleteAboveCount = 0;
            if (deleteToLineNumber < startLineNumber) {
                // the entire deleted lines are above
                deleteAboveCount = deleteToLineNumber - deleteFromLineNumber + 1;
            }
            else {
                deleteAboveCount = startLineNumber - deleteFromLineNumber;
            }
            this._rendLineNumberStart -= deleteAboveCount;
        }
        var deleted = this._lines.splice(deleteStartIndex, deleteCount);
        return deleted;
    };
    RenderedLinesCollection.prototype.onLinesChanged = function (changeFromLineNumber, changeToLineNumber) {
        if (this.getCount() === 0) {
            // no lines
            return false;
        }
        var startLineNumber = this.getStartLineNumber();
        var endLineNumber = this.getEndLineNumber();
        var someoneNotified = false;
        for (var changedLineNumber = changeFromLineNumber; changedLineNumber <= changeToLineNumber; changedLineNumber++) {
            if (changedLineNumber >= startLineNumber && changedLineNumber <= endLineNumber) {
                // Notify the line
                this._lines[changedLineNumber - this._rendLineNumberStart].onContentChanged();
                someoneNotified = true;
            }
        }
        return someoneNotified;
    };
    RenderedLinesCollection.prototype.onLinesInserted = function (insertFromLineNumber, insertToLineNumber) {
        if (this.getCount() === 0) {
            // no lines
            return null;
        }
        var insertCnt = insertToLineNumber - insertFromLineNumber + 1;
        var startLineNumber = this.getStartLineNumber();
        var endLineNumber = this.getEndLineNumber();
        if (insertFromLineNumber <= startLineNumber) {
            // inserting above the viewport
            this._rendLineNumberStart += insertCnt;
            return null;
        }
        if (insertFromLineNumber > endLineNumber) {
            // inserting below the viewport
            return null;
        }
        if (insertCnt + insertFromLineNumber > endLineNumber) {
            // insert inside the viewport in such a way that all remaining lines are pushed outside
            var deleted = this._lines.splice(insertFromLineNumber - this._rendLineNumberStart, endLineNumber - insertFromLineNumber + 1);
            return deleted;
        }
        // insert inside the viewport, push out some lines, but not all remaining lines
        var newLines = [];
        for (var i = 0; i < insertCnt; i++) {
            newLines[i] = this._createLine();
        }
        var insertIndex = insertFromLineNumber - this._rendLineNumberStart;
        var beforeLines = this._lines.slice(0, insertIndex);
        var afterLines = this._lines.slice(insertIndex, this._lines.length - insertCnt);
        var deletedLines = this._lines.slice(this._lines.length - insertCnt, this._lines.length);
        this._lines = beforeLines.concat(newLines).concat(afterLines);
        return deletedLines;
    };
    RenderedLinesCollection.prototype.onTokensChanged = function (ranges) {
        if (this.getCount() === 0) {
            // no lines
            return false;
        }
        var startLineNumber = this.getStartLineNumber();
        var endLineNumber = this.getEndLineNumber();
        var notifiedSomeone = false;
        for (var i = 0, len = ranges.length; i < len; i++) {
            var rng = ranges[i];
            if (rng.toLineNumber < startLineNumber || rng.fromLineNumber > endLineNumber) {
                // range outside viewport
                continue;
            }
            var from = Math.max(startLineNumber, rng.fromLineNumber);
            var to = Math.min(endLineNumber, rng.toLineNumber);
            for (var lineNumber = from; lineNumber <= to; lineNumber++) {
                var lineIndex = lineNumber - this._rendLineNumberStart;
                this._lines[lineIndex].onTokensChanged();
                notifiedSomeone = true;
            }
        }
        return notifiedSomeone;
    };
    return RenderedLinesCollection;
}());
var VisibleLinesCollection = /** @class */ (function () {
    function VisibleLinesCollection(host) {
        var _this = this;
        this._host = host;
        this.domNode = this._createDomNode();
        this._linesCollection = new RenderedLinesCollection(function () { return _this._host.createVisibleLine(); });
    }
    VisibleLinesCollection.prototype._createDomNode = function () {
        var domNode = createFastDomNode(document.createElement('div'));
        domNode.setClassName('view-layer');
        domNode.setPosition('absolute');
        domNode.domNode.setAttribute('role', 'presentation');
        domNode.domNode.setAttribute('aria-hidden', 'true');
        return domNode;
    };
    // ---- begin view event handlers
    VisibleLinesCollection.prototype.onConfigurationChanged = function (e) {
        return e.layoutInfo;
    };
    VisibleLinesCollection.prototype.onFlushed = function (e) {
        this._linesCollection.flush();
        // No need to clear the dom node because a full .innerHTML will occur in ViewLayerRenderer._render
        return true;
    };
    VisibleLinesCollection.prototype.onLinesChanged = function (e) {
        return this._linesCollection.onLinesChanged(e.fromLineNumber, e.toLineNumber);
    };
    VisibleLinesCollection.prototype.onLinesDeleted = function (e) {
        var deleted = this._linesCollection.onLinesDeleted(e.fromLineNumber, e.toLineNumber);
        if (deleted) {
            // Remove from DOM
            for (var i = 0, len = deleted.length; i < len; i++) {
                var lineDomNode = deleted[i].getDomNode();
                if (lineDomNode) {
                    this.domNode.domNode.removeChild(lineDomNode);
                }
            }
        }
        return true;
    };
    VisibleLinesCollection.prototype.onLinesInserted = function (e) {
        var deleted = this._linesCollection.onLinesInserted(e.fromLineNumber, e.toLineNumber);
        if (deleted) {
            // Remove from DOM
            for (var i = 0, len = deleted.length; i < len; i++) {
                var lineDomNode = deleted[i].getDomNode();
                if (lineDomNode) {
                    this.domNode.domNode.removeChild(lineDomNode);
                }
            }
        }
        return true;
    };
    VisibleLinesCollection.prototype.onScrollChanged = function (e) {
        return e.scrollTopChanged;
    };
    VisibleLinesCollection.prototype.onTokensChanged = function (e) {
        return this._linesCollection.onTokensChanged(e.ranges);
    };
    VisibleLinesCollection.prototype.onZonesChanged = function (e) {
        return true;
    };
    // ---- end view event handlers
    VisibleLinesCollection.prototype.getStartLineNumber = function () {
        return this._linesCollection.getStartLineNumber();
    };
    VisibleLinesCollection.prototype.getEndLineNumber = function () {
        return this._linesCollection.getEndLineNumber();
    };
    VisibleLinesCollection.prototype.getVisibleLine = function (lineNumber) {
        return this._linesCollection.getLine(lineNumber);
    };
    VisibleLinesCollection.prototype.renderLines = function (viewportData) {
        var inp = this._linesCollection._get();
        var renderer = new ViewLayerRenderer(this.domNode.domNode, this._host, viewportData);
        var ctx = {
            rendLineNumberStart: inp.rendLineNumberStart,
            lines: inp.lines,
            linesLength: inp.lines.length
        };
        // Decide if this render will do a single update (single large .innerHTML) or many updates (inserting/removing dom nodes)
        var resCtx = renderer.render(ctx, viewportData.startLineNumber, viewportData.endLineNumber, viewportData.relativeVerticalOffset);
        this._linesCollection._set(resCtx.rendLineNumberStart, resCtx.lines);
    };
    return VisibleLinesCollection;
}());
var ViewLayerRenderer = /** @class */ (function () {
    function ViewLayerRenderer(domNode, host, viewportData) {
        this.domNode = domNode;
        this.host = host;
        this.viewportData = viewportData;
    }
    ViewLayerRenderer.prototype.render = function (inContext, startLineNumber, stopLineNumber, deltaTop) {
        var ctx = {
            rendLineNumberStart: inContext.rendLineNumberStart,
            lines: inContext.lines.slice(0),
            linesLength: inContext.linesLength
        };
        if ((ctx.rendLineNumberStart + ctx.linesLength - 1 < startLineNumber) || (stopLineNumber < ctx.rendLineNumberStart)) {
            // There is no overlap whatsoever
            ctx.rendLineNumberStart = startLineNumber;
            ctx.linesLength = stopLineNumber - startLineNumber + 1;
            ctx.lines = [];
            for (var x = startLineNumber; x <= stopLineNumber; x++) {
                ctx.lines[x - startLineNumber] = this.host.createVisibleLine();
            }
            this._finishRendering(ctx, true, deltaTop);
            return ctx;
        }
        // Update lines which will remain untouched
        this._renderUntouchedLines(ctx, Math.max(startLineNumber - ctx.rendLineNumberStart, 0), Math.min(stopLineNumber - ctx.rendLineNumberStart, ctx.linesLength - 1), deltaTop, startLineNumber);
        if (ctx.rendLineNumberStart > startLineNumber) {
            // Insert lines before
            var fromLineNumber = startLineNumber;
            var toLineNumber = Math.min(stopLineNumber, ctx.rendLineNumberStart - 1);
            if (fromLineNumber <= toLineNumber) {
                this._insertLinesBefore(ctx, fromLineNumber, toLineNumber, deltaTop, startLineNumber);
                ctx.linesLength += toLineNumber - fromLineNumber + 1;
            }
        }
        else if (ctx.rendLineNumberStart < startLineNumber) {
            // Remove lines before
            var removeCnt = Math.min(ctx.linesLength, startLineNumber - ctx.rendLineNumberStart);
            if (removeCnt > 0) {
                this._removeLinesBefore(ctx, removeCnt);
                ctx.linesLength -= removeCnt;
            }
        }
        ctx.rendLineNumberStart = startLineNumber;
        if (ctx.rendLineNumberStart + ctx.linesLength - 1 < stopLineNumber) {
            // Insert lines after
            var fromLineNumber = ctx.rendLineNumberStart + ctx.linesLength;
            var toLineNumber = stopLineNumber;
            if (fromLineNumber <= toLineNumber) {
                this._insertLinesAfter(ctx, fromLineNumber, toLineNumber, deltaTop, startLineNumber);
                ctx.linesLength += toLineNumber - fromLineNumber + 1;
            }
        }
        else if (ctx.rendLineNumberStart + ctx.linesLength - 1 > stopLineNumber) {
            // Remove lines after
            var fromLineNumber = Math.max(0, stopLineNumber - ctx.rendLineNumberStart + 1);
            var toLineNumber = ctx.linesLength - 1;
            var removeCnt = toLineNumber - fromLineNumber + 1;
            if (removeCnt > 0) {
                this._removeLinesAfter(ctx, removeCnt);
                ctx.linesLength -= removeCnt;
            }
        }
        this._finishRendering(ctx, false, deltaTop);
        return ctx;
    };
    ViewLayerRenderer.prototype._renderUntouchedLines = function (ctx, startIndex, endIndex, deltaTop, deltaLN) {
        var rendLineNumberStart = ctx.rendLineNumberStart;
        var lines = ctx.lines;
        for (var i = startIndex; i <= endIndex; i++) {
            var lineNumber = rendLineNumberStart + i;
            lines[i].layoutLine(lineNumber, deltaTop[lineNumber - deltaLN]);
        }
    };
    ViewLayerRenderer.prototype._insertLinesBefore = function (ctx, fromLineNumber, toLineNumber, deltaTop, deltaLN) {
        var newLines = [];
        var newLinesLen = 0;
        for (var lineNumber = fromLineNumber; lineNumber <= toLineNumber; lineNumber++) {
            newLines[newLinesLen++] = this.host.createVisibleLine();
        }
        ctx.lines = newLines.concat(ctx.lines);
    };
    ViewLayerRenderer.prototype._removeLinesBefore = function (ctx, removeCount) {
        for (var i = 0; i < removeCount; i++) {
            var lineDomNode = ctx.lines[i].getDomNode();
            if (lineDomNode) {
                this.domNode.removeChild(lineDomNode);
            }
        }
        ctx.lines.splice(0, removeCount);
    };
    ViewLayerRenderer.prototype._insertLinesAfter = function (ctx, fromLineNumber, toLineNumber, deltaTop, deltaLN) {
        var newLines = [];
        var newLinesLen = 0;
        for (var lineNumber = fromLineNumber; lineNumber <= toLineNumber; lineNumber++) {
            newLines[newLinesLen++] = this.host.createVisibleLine();
        }
        ctx.lines = ctx.lines.concat(newLines);
    };
    ViewLayerRenderer.prototype._removeLinesAfter = function (ctx, removeCount) {
        var removeIndex = ctx.linesLength - removeCount;
        for (var i = 0; i < removeCount; i++) {
            var lineDomNode = ctx.lines[removeIndex + i].getDomNode();
            if (lineDomNode) {
                this.domNode.removeChild(lineDomNode);
            }
        }
        ctx.lines.splice(removeIndex, removeCount);
    };
    ViewLayerRenderer.prototype._finishRenderingNewLines = function (ctx, domNodeIsEmpty, newLinesHTML, wasNew) {
        var lastChild = this.domNode.lastChild;
        if (domNodeIsEmpty || !lastChild) {
            this.domNode.innerHTML = newLinesHTML;
        }
        else {
            lastChild.insertAdjacentHTML('afterend', newLinesHTML);
        }
        var currChild = this.domNode.lastChild;
        for (var i = ctx.linesLength - 1; i >= 0; i--) {
            var line = ctx.lines[i];
            if (wasNew[i]) {
                line.setDomNode(currChild);
                currChild = currChild.previousSibling;
            }
        }
    };
    ViewLayerRenderer.prototype._finishRenderingInvalidLines = function (ctx, invalidLinesHTML, wasInvalid) {
        var hugeDomNode = document.createElement('div');
        hugeDomNode.innerHTML = invalidLinesHTML;
        for (var i = 0; i < ctx.linesLength; i++) {
            var line = ctx.lines[i];
            if (wasInvalid[i]) {
                var source = hugeDomNode.firstChild;
                var lineDomNode = line.getDomNode();
                lineDomNode.parentNode.replaceChild(source, lineDomNode);
                line.setDomNode(source);
            }
        }
    };
    ViewLayerRenderer.prototype._finishRendering = function (ctx, domNodeIsEmpty, deltaTop) {
        var sb = ViewLayerRenderer._sb;
        var linesLength = ctx.linesLength;
        var lines = ctx.lines;
        var rendLineNumberStart = ctx.rendLineNumberStart;
        var wasNew = [];
        {
            sb.reset();
            var hadNewLine = false;
            for (var i = 0; i < linesLength; i++) {
                var line = lines[i];
                wasNew[i] = false;
                var lineDomNode = line.getDomNode();
                if (lineDomNode) {
                    // line is not new
                    continue;
                }
                var renderResult = line.renderLine(i + rendLineNumberStart, deltaTop[i], this.viewportData, sb);
                if (!renderResult) {
                    // line does not need rendering
                    continue;
                }
                wasNew[i] = true;
                hadNewLine = true;
            }
            if (hadNewLine) {
                this._finishRenderingNewLines(ctx, domNodeIsEmpty, sb.build(), wasNew);
            }
        }
        {
            sb.reset();
            var hadInvalidLine = false;
            var wasInvalid = [];
            for (var i = 0; i < linesLength; i++) {
                var line = lines[i];
                wasInvalid[i] = false;
                if (wasNew[i]) {
                    // line was new
                    continue;
                }
                var renderResult = line.renderLine(i + rendLineNumberStart, deltaTop[i], this.viewportData, sb);
                if (!renderResult) {
                    // line does not need rendering
                    continue;
                }
                wasInvalid[i] = true;
                hadInvalidLine = true;
            }
            if (hadInvalidLine) {
                this._finishRenderingInvalidLines(ctx, sb.build(), wasInvalid);
            }
        }
    };
    ViewLayerRenderer._sb = createStringBuilder(100000);
    return ViewLayerRenderer;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$B = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var ViewOverlays = /** @class */ (function (_super) {
    __extends$B(ViewOverlays, _super);
    function ViewOverlays(context) {
        var _this = _super.call(this, context) || this;
        _this._visibleLines = new VisibleLinesCollection(_this);
        _this.domNode = _this._visibleLines.domNode;
        _this._dynamicOverlays = [];
        _this._isFocused = false;
        _this.domNode.setClassName('view-overlays');
        return _this;
    }
    ViewOverlays.prototype.shouldRender = function () {
        if (_super.prototype.shouldRender.call(this)) {
            return true;
        }
        for (var i = 0, len = this._dynamicOverlays.length; i < len; i++) {
            var dynamicOverlay = this._dynamicOverlays[i];
            if (dynamicOverlay.shouldRender()) {
                return true;
            }
        }
        return false;
    };
    ViewOverlays.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
        for (var i = 0, len = this._dynamicOverlays.length; i < len; i++) {
            var dynamicOverlay = this._dynamicOverlays[i];
            dynamicOverlay.dispose();
        }
        this._dynamicOverlays = null;
    };
    ViewOverlays.prototype.getDomNode = function () {
        return this.domNode;
    };
    // ---- begin IVisibleLinesHost
    ViewOverlays.prototype.createVisibleLine = function () {
        return new ViewOverlayLine(this._context.configuration, this._dynamicOverlays);
    };
    // ---- end IVisibleLinesHost
    ViewOverlays.prototype.addDynamicOverlay = function (overlay) {
        this._dynamicOverlays.push(overlay);
    };
    // ----- event handlers
    ViewOverlays.prototype.onConfigurationChanged = function (e) {
        this._visibleLines.onConfigurationChanged(e);
        var startLineNumber = this._visibleLines.getStartLineNumber();
        var endLineNumber = this._visibleLines.getEndLineNumber();
        for (var lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {
            var line = this._visibleLines.getVisibleLine(lineNumber);
            line.onConfigurationChanged(e);
        }
        return true;
    };
    ViewOverlays.prototype.onFlushed = function (e) {
        return this._visibleLines.onFlushed(e);
    };
    ViewOverlays.prototype.onFocusChanged = function (e) {
        this._isFocused = e.isFocused;
        return true;
    };
    ViewOverlays.prototype.onLinesChanged = function (e) {
        return this._visibleLines.onLinesChanged(e);
    };
    ViewOverlays.prototype.onLinesDeleted = function (e) {
        return this._visibleLines.onLinesDeleted(e);
    };
    ViewOverlays.prototype.onLinesInserted = function (e) {
        return this._visibleLines.onLinesInserted(e);
    };
    ViewOverlays.prototype.onScrollChanged = function (e) {
        return this._visibleLines.onScrollChanged(e) || true;
    };
    ViewOverlays.prototype.onTokensChanged = function (e) {
        return this._visibleLines.onTokensChanged(e);
    };
    ViewOverlays.prototype.onZonesChanged = function (e) {
        return this._visibleLines.onZonesChanged(e);
    };
    // ----- end event handlers
    ViewOverlays.prototype.prepareRender = function (ctx) {
        var toRender = this._dynamicOverlays.filter(function (overlay) { return overlay.shouldRender(); });
        for (var i = 0, len = toRender.length; i < len; i++) {
            var dynamicOverlay = toRender[i];
            dynamicOverlay.prepareRender(ctx);
            dynamicOverlay.onDidRender();
        }
        return null;
    };
    ViewOverlays.prototype.render = function (ctx) {
        // Overwriting to bypass `shouldRender` flag
        this._viewOverlaysRender(ctx);
        this.domNode.toggleClassName('focused', this._isFocused);
    };
    ViewOverlays.prototype._viewOverlaysRender = function (ctx) {
        this._visibleLines.renderLines(ctx.viewportData);
    };
    return ViewOverlays;
}(ViewPart));
var ViewOverlayLine = /** @class */ (function () {
    function ViewOverlayLine(configuration, dynamicOverlays) {
        this._configuration = configuration;
        this._lineHeight = this._configuration.editor.lineHeight;
        this._dynamicOverlays = dynamicOverlays;
        this._domNode = null;
        this._renderedContent = null;
    }
    ViewOverlayLine.prototype.getDomNode = function () {
        if (!this._domNode) {
            return null;
        }
        return this._domNode.domNode;
    };
    ViewOverlayLine.prototype.setDomNode = function (domNode) {
        this._domNode = createFastDomNode(domNode);
    };
    ViewOverlayLine.prototype.onContentChanged = function () {
        // Nothing
    };
    ViewOverlayLine.prototype.onTokensChanged = function () {
        // Nothing
    };
    ViewOverlayLine.prototype.onConfigurationChanged = function (e) {
        if (e.lineHeight) {
            this._lineHeight = this._configuration.editor.lineHeight;
        }
    };
    ViewOverlayLine.prototype.renderLine = function (lineNumber, deltaTop, viewportData, sb) {
        var result = '';
        for (var i = 0, len = this._dynamicOverlays.length; i < len; i++) {
            var dynamicOverlay = this._dynamicOverlays[i];
            result += dynamicOverlay.render(viewportData.startLineNumber, lineNumber);
        }
        if (this._renderedContent === result) {
            // No rendering needed
            return false;
        }
        this._renderedContent = result;
        sb.appendASCIIString('<div style="position:absolute;top:');
        sb.appendASCIIString(String(deltaTop));
        sb.appendASCIIString('px;width:100%;height:');
        sb.appendASCIIString(String(this._lineHeight));
        sb.appendASCIIString('px;">');
        sb.appendASCIIString(result);
        sb.appendASCIIString('</div>');
        return true;
    };
    ViewOverlayLine.prototype.layoutLine = function (lineNumber, deltaTop) {
        if (this._domNode) {
            this._domNode.setTop(deltaTop);
            this._domNode.setHeight(this._lineHeight);
        }
    };
    return ViewOverlayLine;
}());
var ContentViewOverlays = /** @class */ (function (_super) {
    __extends$B(ContentViewOverlays, _super);
    function ContentViewOverlays(context) {
        var _this = _super.call(this, context) || this;
        _this._contentWidth = _this._context.configuration.editor.layoutInfo.contentWidth;
        _this.domNode.setHeight(0);
        return _this;
    }
    // --- begin event handlers
    ContentViewOverlays.prototype.onConfigurationChanged = function (e) {
        if (e.layoutInfo) {
            this._contentWidth = this._context.configuration.editor.layoutInfo.contentWidth;
        }
        return _super.prototype.onConfigurationChanged.call(this, e);
    };
    ContentViewOverlays.prototype.onScrollChanged = function (e) {
        return _super.prototype.onScrollChanged.call(this, e) || e.scrollWidthChanged;
    };
    // --- end event handlers
    ContentViewOverlays.prototype._viewOverlaysRender = function (ctx) {
        _super.prototype._viewOverlaysRender.call(this, ctx);
        this.domNode.setWidth(Math.max(ctx.scrollWidth, this._contentWidth));
    };
    return ContentViewOverlays;
}(ViewOverlays));
var MarginViewOverlays = /** @class */ (function (_super) {
    __extends$B(MarginViewOverlays, _super);
    function MarginViewOverlays(context) {
        var _this = _super.call(this, context) || this;
        _this._contentLeft = _this._context.configuration.editor.layoutInfo.contentLeft;
        _this.domNode.setClassName('margin-view-overlays');
        _this.domNode.setWidth(1);
        Configuration$1.applyFontInfo(_this.domNode, _this._context.configuration.editor.fontInfo);
        return _this;
    }
    MarginViewOverlays.prototype.onConfigurationChanged = function (e) {
        var shouldRender = false;
        if (e.fontInfo) {
            Configuration$1.applyFontInfo(this.domNode, this._context.configuration.editor.fontInfo);
            shouldRender = true;
        }
        if (e.layoutInfo) {
            this._contentLeft = this._context.configuration.editor.layoutInfo.contentLeft;
            shouldRender = true;
        }
        return _super.prototype.onConfigurationChanged.call(this, e) || shouldRender;
    };
    MarginViewOverlays.prototype.onScrollChanged = function (e) {
        return _super.prototype.onScrollChanged.call(this, e) || e.scrollHeightChanged;
    };
    MarginViewOverlays.prototype._viewOverlaysRender = function (ctx) {
        _super.prototype._viewOverlaysRender.call(this, ctx);
        var height = Math.min(ctx.scrollHeight, 1000000);
        this.domNode.setHeight(height);
        this.domNode.setWidth(this._contentLeft);
    };
    return MarginViewOverlays;
}(ViewOverlays));

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$C = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var Coordinate = /** @class */ (function () {
    function Coordinate(top, left) {
        this.top = top;
        this.left = left;
    }
    return Coordinate;
}());
var ViewContentWidgets = /** @class */ (function (_super) {
    __extends$C(ViewContentWidgets, _super);
    function ViewContentWidgets(context, viewDomNode) {
        var _this = _super.call(this, context) || this;
        _this._viewDomNode = viewDomNode;
        _this._widgets = {};
        _this.domNode = createFastDomNode(document.createElement('div'));
        PartFingerprints.write(_this.domNode, 1 /* ContentWidgets */);
        _this.domNode.setClassName('contentWidgets');
        _this.domNode.setPosition('absolute');
        _this.domNode.setTop(0);
        _this.overflowingContentWidgetsDomNode = createFastDomNode(document.createElement('div'));
        PartFingerprints.write(_this.overflowingContentWidgetsDomNode, 2 /* OverflowingContentWidgets */);
        _this.overflowingContentWidgetsDomNode.setClassName('overflowingContentWidgets');
        return _this;
    }
    ViewContentWidgets.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
        this._widgets = null;
        this.domNode = null;
    };
    // --- begin event handlers
    ViewContentWidgets.prototype.onConfigurationChanged = function (e) {
        var keys = Object.keys(this._widgets);
        for (var i = 0, len = keys.length; i < len; i++) {
            var widgetId = keys[i];
            this._widgets[widgetId].onConfigurationChanged(e);
        }
        return true;
    };
    ViewContentWidgets.prototype.onDecorationsChanged = function (e) {
        // true for inline decorations that can end up relayouting text
        return true;
    };
    ViewContentWidgets.prototype.onFlushed = function (e) {
        return true;
    };
    ViewContentWidgets.prototype.onLineMappingChanged = function (e) {
        var keys = Object.keys(this._widgets);
        for (var i = 0, len = keys.length; i < len; i++) {
            var widgetId = keys[i];
            this._widgets[widgetId].onLineMappingChanged(e);
        }
        return true;
    };
    ViewContentWidgets.prototype.onLinesChanged = function (e) {
        return true;
    };
    ViewContentWidgets.prototype.onLinesDeleted = function (e) {
        return true;
    };
    ViewContentWidgets.prototype.onLinesInserted = function (e) {
        return true;
    };
    ViewContentWidgets.prototype.onScrollChanged = function (e) {
        return true;
    };
    ViewContentWidgets.prototype.onZonesChanged = function (e) {
        return true;
    };
    // ---- end view event handlers
    ViewContentWidgets.prototype.addWidget = function (_widget) {
        var myWidget = new Widget(this._context, this._viewDomNode, _widget);
        this._widgets[myWidget.id] = myWidget;
        if (myWidget.allowEditorOverflow) {
            this.overflowingContentWidgetsDomNode.appendChild(myWidget.domNode);
        }
        else {
            this.domNode.appendChild(myWidget.domNode);
        }
        this.setShouldRender();
    };
    ViewContentWidgets.prototype.setWidgetPosition = function (widget, position$$1, preference) {
        var myWidget = this._widgets[widget.getId()];
        myWidget.setPosition(position$$1, preference);
        this.setShouldRender();
    };
    ViewContentWidgets.prototype.removeWidget = function (widget) {
        var widgetId = widget.getId();
        if (this._widgets.hasOwnProperty(widgetId)) {
            var myWidget = this._widgets[widgetId];
            delete this._widgets[widgetId];
            var domNode = myWidget.domNode.domNode;
            domNode.parentNode.removeChild(domNode);
            domNode.removeAttribute('monaco-visible-content-widget');
            this.setShouldRender();
        }
    };
    ViewContentWidgets.prototype.shouldSuppressMouseDownOnWidget = function (widgetId) {
        if (this._widgets.hasOwnProperty(widgetId)) {
            return this._widgets[widgetId].suppressMouseDown;
        }
        return false;
    };
    ViewContentWidgets.prototype.onBeforeRender = function (viewportData) {
        var keys = Object.keys(this._widgets);
        for (var i = 0, len = keys.length; i < len; i++) {
            var widgetId = keys[i];
            this._widgets[widgetId].onBeforeRender(viewportData);
        }
    };
    ViewContentWidgets.prototype.prepareRender = function (ctx) {
        var keys = Object.keys(this._widgets);
        for (var i = 0, len = keys.length; i < len; i++) {
            var widgetId = keys[i];
            this._widgets[widgetId].prepareRender(ctx);
        }
    };
    ViewContentWidgets.prototype.render = function (ctx) {
        var keys = Object.keys(this._widgets);
        for (var i = 0, len = keys.length; i < len; i++) {
            var widgetId = keys[i];
            this._widgets[widgetId].render(ctx);
        }
    };
    return ViewContentWidgets;
}(ViewPart));
var Widget = /** @class */ (function () {
    function Widget(context, viewDomNode, actual) {
        this._context = context;
        this._viewDomNode = viewDomNode;
        this._actual = actual;
        this.domNode = createFastDomNode(this._actual.getDomNode());
        this.id = this._actual.getId();
        this.allowEditorOverflow = this._actual.allowEditorOverflow || false;
        this.suppressMouseDown = this._actual.suppressMouseDown || false;
        this._fixedOverflowWidgets = this._context.configuration.editor.viewInfo.fixedOverflowWidgets;
        this._contentWidth = this._context.configuration.editor.layoutInfo.contentWidth;
        this._contentLeft = this._context.configuration.editor.layoutInfo.contentLeft;
        this._lineHeight = this._context.configuration.editor.lineHeight;
        this._setPosition(null);
        this._preference = null;
        this._cachedDomNodeClientWidth = -1;
        this._cachedDomNodeClientHeight = -1;
        this._maxWidth = this._getMaxWidth();
        this._isVisible = false;
        this._renderData = null;
        this.domNode.setPosition((this._fixedOverflowWidgets && this.allowEditorOverflow) ? 'fixed' : 'absolute');
        this.domNode.setVisibility('hidden');
        this.domNode.setAttribute('widgetId', this.id);
        this.domNode.setMaxWidth(this._maxWidth);
    }
    Widget.prototype.onConfigurationChanged = function (e) {
        if (e.lineHeight) {
            this._lineHeight = this._context.configuration.editor.lineHeight;
        }
        if (e.layoutInfo) {
            this._contentLeft = this._context.configuration.editor.layoutInfo.contentLeft;
            this._contentWidth = this._context.configuration.editor.layoutInfo.contentWidth;
            this._maxWidth = this._getMaxWidth();
        }
    };
    Widget.prototype.onLineMappingChanged = function (e) {
        this._setPosition(this._position);
    };
    Widget.prototype._setPosition = function (position$$1) {
        this._position = position$$1;
        this._viewPosition = null;
        if (this._position) {
            // Do not trust that widgets give a valid position
            var validModelPosition = this._context.model.validateModelPosition(this._position);
            if (this._context.model.coordinatesConverter.modelPositionIsVisible(validModelPosition)) {
                this._viewPosition = this._context.model.coordinatesConverter.convertModelPositionToViewPosition(validModelPosition);
            }
        }
    };
    Widget.prototype._getMaxWidth = function () {
        return (this.allowEditorOverflow
            ? window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth
            : this._contentWidth);
    };
    Widget.prototype.setPosition = function (position$$1, preference) {
        this._setPosition(position$$1);
        this._preference = preference;
        this._cachedDomNodeClientWidth = -1;
        this._cachedDomNodeClientHeight = -1;
    };
    Widget.prototype._layoutBoxInViewport = function (topLeft, width, height, ctx) {
        // Our visible box is split horizontally by the current line => 2 boxes
        // a) the box above the line
        var aboveLineTop = topLeft.top;
        var heightAboveLine = aboveLineTop;
        // b) the box under the line
        var underLineTop = topLeft.top + this._lineHeight;
        var heightUnderLine = ctx.viewportHeight - underLineTop;
        var aboveTop = aboveLineTop - height;
        var fitsAbove = (heightAboveLine >= height);
        var belowTop = underLineTop;
        var fitsBelow = (heightUnderLine >= height);
        // And its left
        var actualLeft = topLeft.left;
        if (actualLeft + width > ctx.scrollLeft + ctx.viewportWidth) {
            actualLeft = ctx.scrollLeft + ctx.viewportWidth - width;
        }
        if (actualLeft < ctx.scrollLeft) {
            actualLeft = ctx.scrollLeft;
        }
        return {
            aboveTop: aboveTop,
            fitsAbove: fitsAbove,
            belowTop: belowTop,
            fitsBelow: fitsBelow,
            left: actualLeft
        };
    };
    Widget.prototype._layoutBoxInPage = function (topLeft, width, height, ctx) {
        var left0 = topLeft.left - ctx.scrollLeft;
        if (left0 < 0 || left0 > this._contentWidth) {
            // Don't render if position is scrolled outside viewport
            return null;
        }
        var aboveTop = topLeft.top - height;
        var belowTop = topLeft.top + this._lineHeight;
        var left = left0 + this._contentLeft;
        var domNodePosition = getDomNodePagePosition(this._viewDomNode.domNode);
        var absoluteAboveTop = domNodePosition.top + aboveTop - StandardWindow.scrollY;
        var absoluteBelowTop = domNodePosition.top + belowTop - StandardWindow.scrollY;
        var absoluteLeft = domNodePosition.left + left - StandardWindow.scrollX;
        var INNER_WIDTH = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;
        var INNER_HEIGHT = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;
        // Leave some clearance to the bottom
        var TOP_PADDING = 22;
        var BOTTOM_PADDING = 22;
        var fitsAbove = (absoluteAboveTop >= TOP_PADDING), fitsBelow = (absoluteBelowTop + height <= INNER_HEIGHT - BOTTOM_PADDING);
        if (absoluteLeft + width + 20 > INNER_WIDTH) {
            var delta = absoluteLeft - (INNER_WIDTH - width - 20);
            absoluteLeft -= delta;
            left -= delta;
        }
        if (absoluteLeft < 0) {
            var delta = absoluteLeft;
            absoluteLeft -= delta;
            left -= delta;
        }
        if (this._fixedOverflowWidgets) {
            aboveTop = absoluteAboveTop;
            belowTop = absoluteBelowTop;
            left = absoluteLeft;
        }
        return { aboveTop: aboveTop, fitsAbove: fitsAbove, belowTop: belowTop, fitsBelow: fitsBelow, left: left };
    };
    Widget.prototype._prepareRenderWidgetAtExactPositionOverflowing = function (topLeft) {
        return new Coordinate(topLeft.top, topLeft.left + this._contentLeft);
    };
    /**
     * Compute `this._topLeft`
     */
    Widget.prototype._getTopLeft = function (ctx) {
        if (!this._viewPosition) {
            return null;
        }
        var visibleRange = ctx.visibleRangeForPosition(this._viewPosition);
        if (!visibleRange) {
            return null;
        }
        var top = ctx.getVerticalOffsetForLineNumber(this._viewPosition.lineNumber) - ctx.scrollTop;
        return new Coordinate(top, visibleRange.left);
    };
    Widget.prototype._prepareRenderWidget = function (topLeft, ctx) {
        var _this = this;
        if (!topLeft) {
            return null;
        }
        var placement = null;
        var fetchPlacement = function () {
            if (placement) {
                return;
            }
            if (_this._cachedDomNodeClientWidth === -1 || _this._cachedDomNodeClientHeight === -1) {
                var domNode = _this.domNode.domNode;
                _this._cachedDomNodeClientWidth = domNode.clientWidth;
                _this._cachedDomNodeClientHeight = domNode.clientHeight;
            }
            if (_this.allowEditorOverflow) {
                placement = _this._layoutBoxInPage(topLeft, _this._cachedDomNodeClientWidth, _this._cachedDomNodeClientHeight, ctx);
            }
            else {
                placement = _this._layoutBoxInViewport(topLeft, _this._cachedDomNodeClientWidth, _this._cachedDomNodeClientHeight, ctx);
            }
        };
        // Do two passes, first for perfect fit, second picks first option
        for (var pass = 1; pass <= 2; pass++) {
            for (var i = 0; i < this._preference.length; i++) {
                var pref = this._preference[i];
                if (pref === ContentWidgetPositionPreference.ABOVE) {
                    fetchPlacement();
                    if (!placement) {
                        // Widget outside of viewport
                        return null;
                    }
                    if (pass === 2 || placement.fitsAbove) {
                        return new Coordinate(placement.aboveTop, placement.left);
                    }
                }
                else if (pref === ContentWidgetPositionPreference.BELOW) {
                    fetchPlacement();
                    if (!placement) {
                        // Widget outside of viewport
                        return null;
                    }
                    if (pass === 2 || placement.fitsBelow) {
                        return new Coordinate(placement.belowTop, placement.left);
                    }
                }
                else {
                    if (this.allowEditorOverflow) {
                        return this._prepareRenderWidgetAtExactPositionOverflowing(topLeft);
                    }
                    else {
                        return topLeft;
                    }
                }
            }
        }
        return null;
    };
    /**
     * On this first pass, we ensure that the content widget (if it is in the viewport) has the max width set correctly.
     */
    Widget.prototype.onBeforeRender = function (viewportData) {
        if (!this._viewPosition || !this._preference) {
            return;
        }
        if (this._viewPosition.lineNumber < viewportData.startLineNumber || this._viewPosition.lineNumber > viewportData.endLineNumber) {
            // Outside of viewport
            return;
        }
        this.domNode.setMaxWidth(this._maxWidth);
    };
    Widget.prototype.prepareRender = function (ctx) {
        var topLeft = this._getTopLeft(ctx);
        this._renderData = this._prepareRenderWidget(topLeft, ctx);
    };
    Widget.prototype.render = function (ctx) {
        if (!this._renderData) {
            // This widget should be invisible
            if (this._isVisible) {
                this.domNode.removeAttribute('monaco-visible-content-widget');
                this._isVisible = false;
                this.domNode.setVisibility('hidden');
            }
            return;
        }
        // This widget should be visible
        if (this.allowEditorOverflow) {
            this.domNode.setTop(this._renderData.top);
            this.domNode.setLeft(this._renderData.left);
        }
        else {
            this.domNode.setTop(this._renderData.top + ctx.scrollTop - ctx.bigNumbersDelta);
            this.domNode.setLeft(this._renderData.left);
        }
        if (!this._isVisible) {
            this.domNode.setVisibility('inherit');
            this.domNode.setAttribute('monaco-visible-content-widget', 'true');
            this._isVisible = true;
        }
    };
    return Widget;
}());

const css$5 = "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n.monaco-editor .view-overlays .current-line {\n\tdisplay: block;\n\tposition: absolute;\n\tleft: 0;\n\ttop: 0;\n\tbox-sizing: border-box;\n}";
  const element$5 = ((css, src) => {
if (typeof document !== 'object')
console.info(`Skipped loading "${src}"`);
try {
const id = src
  .replace(/\.css.*$/, '')
  .replace(/[\\:]/g, '/')
  .replace(/[^\w\/]+/g, '');
return (
  document.querySelector(`style[id="${id}"]`) ||
  document.head.appendChild(
    Object.assign(document.createElement('style'), {
      id,
      textContent: `${css}\n\n /* sourceURL=${src} */`,
    }),
  )
);
} catch (exception) {
console.warn(`Failed load "${src}"`, exception);
}
})(css$5, "…monaco-editor/esm/vs/editor/browser/viewParts/currentLineHighlight/currentLineHighlight.css");
  //@ sourceURL=/Users/daflair/Projects/packages/monaco-es/node_modules/monaco-editor/esm/vs/editor/browser/viewParts/currentLineHighlight/currentLineHighlight.css

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$D = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var CurrentLineHighlightOverlay = /** @class */ (function (_super) {
    __extends$D(CurrentLineHighlightOverlay, _super);
    function CurrentLineHighlightOverlay(context) {
        var _this = _super.call(this) || this;
        _this._context = context;
        _this._lineHeight = _this._context.configuration.editor.lineHeight;
        _this._renderLineHighlight = _this._context.configuration.editor.viewInfo.renderLineHighlight;
        _this._selectionIsEmpty = true;
        _this._primaryCursorLineNumber = 1;
        _this._scrollWidth = 0;
        _this._contentWidth = _this._context.configuration.editor.layoutInfo.contentWidth;
        _this._context.addEventHandler(_this);
        return _this;
    }
    CurrentLineHighlightOverlay.prototype.dispose = function () {
        this._context.removeEventHandler(this);
        this._context = null;
        _super.prototype.dispose.call(this);
    };
    // --- begin event handlers
    CurrentLineHighlightOverlay.prototype.onConfigurationChanged = function (e) {
        if (e.lineHeight) {
            this._lineHeight = this._context.configuration.editor.lineHeight;
        }
        if (e.viewInfo) {
            this._renderLineHighlight = this._context.configuration.editor.viewInfo.renderLineHighlight;
        }
        if (e.layoutInfo) {
            this._contentWidth = this._context.configuration.editor.layoutInfo.contentWidth;
        }
        return true;
    };
    CurrentLineHighlightOverlay.prototype.onCursorStateChanged = function (e) {
        var hasChanged = false;
        var primaryCursorLineNumber = e.selections[0].positionLineNumber;
        if (this._primaryCursorLineNumber !== primaryCursorLineNumber) {
            this._primaryCursorLineNumber = primaryCursorLineNumber;
            hasChanged = true;
        }
        var selectionIsEmpty = e.selections[0].isEmpty();
        if (this._selectionIsEmpty !== selectionIsEmpty) {
            this._selectionIsEmpty = selectionIsEmpty;
            hasChanged = true;
            return true;
        }
        return hasChanged;
    };
    CurrentLineHighlightOverlay.prototype.onFlushed = function (e) {
        return true;
    };
    CurrentLineHighlightOverlay.prototype.onLinesDeleted = function (e) {
        return true;
    };
    CurrentLineHighlightOverlay.prototype.onLinesInserted = function (e) {
        return true;
    };
    CurrentLineHighlightOverlay.prototype.onScrollChanged = function (e) {
        return e.scrollWidthChanged;
    };
    CurrentLineHighlightOverlay.prototype.onZonesChanged = function (e) {
        return true;
    };
    // --- end event handlers
    CurrentLineHighlightOverlay.prototype.prepareRender = function (ctx) {
        this._scrollWidth = ctx.scrollWidth;
    };
    CurrentLineHighlightOverlay.prototype.render = function (startLineNumber, lineNumber) {
        if (lineNumber === this._primaryCursorLineNumber) {
            if (this._shouldShowCurrentLine()) {
                var paintedInMargin = this._willRenderMarginCurrentLine();
                var className = 'current-line' + (paintedInMargin ? ' current-line-both' : '');
                return ('<div class="'
                    + className
                    + '" style="width:'
                    + String(Math.max(this._scrollWidth, this._contentWidth))
                    + 'px; height:'
                    + String(this._lineHeight)
                    + 'px;"></div>');
            }
            else {
                return '';
            }
        }
        return '';
    };
    CurrentLineHighlightOverlay.prototype._shouldShowCurrentLine = function () {
        return ((this._renderLineHighlight === 'line' || this._renderLineHighlight === 'all')
            && this._selectionIsEmpty);
    };
    CurrentLineHighlightOverlay.prototype._willRenderMarginCurrentLine = function () {
        return ((this._renderLineHighlight === 'gutter' || this._renderLineHighlight === 'all'));
    };
    return CurrentLineHighlightOverlay;
}(DynamicViewOverlay));
registerThemingParticipant(function (theme, collector) {
    var lineHighlight = theme.getColor(editorLineHighlight);
    if (lineHighlight) {
        collector.addRule(".monaco-editor .view-overlays .current-line { background-color: " + lineHighlight + "; }");
    }
    if (!lineHighlight || lineHighlight.isTransparent() || theme.defines(editorLineHighlightBorder)) {
        var lineHighlightBorder = theme.getColor(editorLineHighlightBorder);
        if (lineHighlightBorder) {
            collector.addRule(".monaco-editor .view-overlays .current-line { border: 2px solid " + lineHighlightBorder + "; }");
            if (theme.type === 'hc') {
                collector.addRule(".monaco-editor .view-overlays .current-line { border-width: 1px; }");
            }
        }
    }
});

const css$6 = "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n.monaco-editor .margin-view-overlays .current-line {\n\tdisplay: block;\n\tposition: absolute;\n\tleft: 0;\n\ttop: 0;\n\tbox-sizing: border-box;\n}\n\n.monaco-editor .margin-view-overlays .current-line.current-line-margin.current-line-margin-both {\n\tborder-right: 0;\n}";
  const element$6 = ((css, src) => {
if (typeof document !== 'object')
console.info(`Skipped loading "${src}"`);
try {
const id = src
  .replace(/\.css.*$/, '')
  .replace(/[\\:]/g, '/')
  .replace(/[^\w\/]+/g, '');
return (
  document.querySelector(`style[id="${id}"]`) ||
  document.head.appendChild(
    Object.assign(document.createElement('style'), {
      id,
      textContent: `${css}\n\n /* sourceURL=${src} */`,
    }),
  )
);
} catch (exception) {
console.warn(`Failed load "${src}"`, exception);
}
})(css$6, "…monaco-editor/esm/vs/editor/browser/viewParts/currentLineMarginHighlight/currentLineMarginHighlight.css");
  //@ sourceURL=/Users/daflair/Projects/packages/monaco-es/node_modules/monaco-editor/esm/vs/editor/browser/viewParts/currentLineMarginHighlight/currentLineMarginHighlight.css

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$E = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var CurrentLineMarginHighlightOverlay = /** @class */ (function (_super) {
    __extends$E(CurrentLineMarginHighlightOverlay, _super);
    function CurrentLineMarginHighlightOverlay(context) {
        var _this = _super.call(this) || this;
        _this._context = context;
        _this._lineHeight = _this._context.configuration.editor.lineHeight;
        _this._renderLineHighlight = _this._context.configuration.editor.viewInfo.renderLineHighlight;
        _this._selectionIsEmpty = true;
        _this._primaryCursorLineNumber = 1;
        _this._contentLeft = _this._context.configuration.editor.layoutInfo.contentLeft;
        _this._context.addEventHandler(_this);
        return _this;
    }
    CurrentLineMarginHighlightOverlay.prototype.dispose = function () {
        this._context.removeEventHandler(this);
        this._context = null;
        _super.prototype.dispose.call(this);
    };
    // --- begin event handlers
    CurrentLineMarginHighlightOverlay.prototype.onConfigurationChanged = function (e) {
        if (e.lineHeight) {
            this._lineHeight = this._context.configuration.editor.lineHeight;
        }
        if (e.viewInfo) {
            this._renderLineHighlight = this._context.configuration.editor.viewInfo.renderLineHighlight;
        }
        if (e.layoutInfo) {
            this._contentLeft = this._context.configuration.editor.layoutInfo.contentLeft;
        }
        return true;
    };
    CurrentLineMarginHighlightOverlay.prototype.onCursorStateChanged = function (e) {
        var hasChanged = false;
        var primaryCursorLineNumber = e.selections[0].positionLineNumber;
        if (this._primaryCursorLineNumber !== primaryCursorLineNumber) {
            this._primaryCursorLineNumber = primaryCursorLineNumber;
            hasChanged = true;
        }
        var selectionIsEmpty = e.selections[0].isEmpty();
        if (this._selectionIsEmpty !== selectionIsEmpty) {
            this._selectionIsEmpty = selectionIsEmpty;
            hasChanged = true;
            return true;
        }
        return hasChanged;
    };
    CurrentLineMarginHighlightOverlay.prototype.onFlushed = function (e) {
        return true;
    };
    CurrentLineMarginHighlightOverlay.prototype.onLinesDeleted = function (e) {
        return true;
    };
    CurrentLineMarginHighlightOverlay.prototype.onLinesInserted = function (e) {
        return true;
    };
    CurrentLineMarginHighlightOverlay.prototype.onZonesChanged = function (e) {
        return true;
    };
    // --- end event handlers
    CurrentLineMarginHighlightOverlay.prototype.prepareRender = function (ctx) {
    };
    CurrentLineMarginHighlightOverlay.prototype.render = function (startLineNumber, lineNumber) {
        if (lineNumber === this._primaryCursorLineNumber) {
            var className = 'current-line';
            if (this._shouldShowCurrentLine()) {
                var paintedInContent = this._willRenderContentCurrentLine();
                className = 'current-line current-line-margin' + (paintedInContent ? ' current-line-margin-both' : '');
            }
            return ('<div class="'
                + className
                + '" style="width:'
                + String(this._contentLeft)
                + 'px; height:'
                + String(this._lineHeight)
                + 'px;"></div>');
        }
        return '';
    };
    CurrentLineMarginHighlightOverlay.prototype._shouldShowCurrentLine = function () {
        return ((this._renderLineHighlight === 'gutter' || this._renderLineHighlight === 'all'));
    };
    CurrentLineMarginHighlightOverlay.prototype._willRenderContentCurrentLine = function () {
        return ((this._renderLineHighlight === 'line' || this._renderLineHighlight === 'all')
            && this._selectionIsEmpty);
    };
    return CurrentLineMarginHighlightOverlay;
}(DynamicViewOverlay));
registerThemingParticipant(function (theme, collector) {
    var lineHighlight = theme.getColor(editorLineHighlight);
    if (lineHighlight) {
        collector.addRule(".monaco-editor .margin-view-overlays .current-line-margin { background-color: " + lineHighlight + "; border: none; }");
    }
    else {
        var lineHighlightBorder = theme.getColor(editorLineHighlightBorder);
        if (lineHighlightBorder) {
            collector.addRule(".monaco-editor .margin-view-overlays .current-line-margin { border: 2px solid " + lineHighlightBorder + "; }");
        }
        if (theme.type === 'hc') {
            collector.addRule(".monaco-editor .margin-view-overlays .current-line-margin { border-width: 1px; }");
        }
    }
});

const css$7 = "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n/*\n\tKeeping name short for faster parsing.\n\tcdr = core decorations rendering (div)\n*/\n.monaco-editor .lines-content .cdr {\n\tposition: absolute;\n}";
  const element$7 = ((css, src) => {
if (typeof document !== 'object')
console.info(`Skipped loading "${src}"`);
try {
const id = src
  .replace(/\.css.*$/, '')
  .replace(/[\\:]/g, '/')
  .replace(/[^\w\/]+/g, '');
return (
  document.querySelector(`style[id="${id}"]`) ||
  document.head.appendChild(
    Object.assign(document.createElement('style'), {
      id,
      textContent: `${css}\n\n /* sourceURL=${src} */`,
    }),
  )
);
} catch (exception) {
console.warn(`Failed load "${src}"`, exception);
}
})(css$7, "…monaco-editor/esm/vs/editor/browser/viewParts/decorations/decorations.css");
  //@ sourceURL=/Users/daflair/Projects/packages/monaco-es/node_modules/monaco-editor/esm/vs/editor/browser/viewParts/decorations/decorations.css

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$F = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var DecorationsOverlay = /** @class */ (function (_super) {
    __extends$F(DecorationsOverlay, _super);
    function DecorationsOverlay(context) {
        var _this = _super.call(this) || this;
        _this._context = context;
        _this._lineHeight = _this._context.configuration.editor.lineHeight;
        _this._typicalHalfwidthCharacterWidth = _this._context.configuration.editor.fontInfo.typicalHalfwidthCharacterWidth;
        _this._renderResult = null;
        _this._context.addEventHandler(_this);
        return _this;
    }
    DecorationsOverlay.prototype.dispose = function () {
        this._context.removeEventHandler(this);
        this._context = null;
        this._renderResult = null;
        _super.prototype.dispose.call(this);
    };
    // --- begin event handlers
    DecorationsOverlay.prototype.onConfigurationChanged = function (e) {
        if (e.lineHeight) {
            this._lineHeight = this._context.configuration.editor.lineHeight;
        }
        if (e.fontInfo) {
            this._typicalHalfwidthCharacterWidth = this._context.configuration.editor.fontInfo.typicalHalfwidthCharacterWidth;
        }
        return true;
    };
    DecorationsOverlay.prototype.onDecorationsChanged = function (e) {
        return true;
    };
    DecorationsOverlay.prototype.onFlushed = function (e) {
        return true;
    };
    DecorationsOverlay.prototype.onLinesChanged = function (e) {
        return true;
    };
    DecorationsOverlay.prototype.onLinesDeleted = function (e) {
        return true;
    };
    DecorationsOverlay.prototype.onLinesInserted = function (e) {
        return true;
    };
    DecorationsOverlay.prototype.onScrollChanged = function (e) {
        return e.scrollTopChanged || e.scrollWidthChanged;
    };
    DecorationsOverlay.prototype.onZonesChanged = function (e) {
        return true;
    };
    // --- end event handlers
    DecorationsOverlay.prototype.prepareRender = function (ctx) {
        var _decorations = ctx.getDecorationsInViewport();
        // Keep only decorations with `className`
        var decorations = [], decorationsLen = 0;
        for (var i = 0, len = _decorations.length; i < len; i++) {
            var d = _decorations[i];
            if (d.options.className) {
                decorations[decorationsLen++] = d;
            }
        }
        // Sort decorations for consistent render output
        decorations = decorations.sort(function (a, b) {
            if (a.options.zIndex < b.options.zIndex) {
                return -1;
            }
            if (a.options.zIndex > b.options.zIndex) {
                return 1;
            }
            var aClassName = a.options.className;
            var bClassName = b.options.className;
            if (aClassName < bClassName) {
                return -1;
            }
            if (aClassName > bClassName) {
                return 1;
            }
            return Range.compareRangesUsingStarts(a.range, b.range);
        });
        var visibleStartLineNumber = ctx.visibleRange.startLineNumber;
        var visibleEndLineNumber = ctx.visibleRange.endLineNumber;
        var output = [];
        for (var lineNumber = visibleStartLineNumber; lineNumber <= visibleEndLineNumber; lineNumber++) {
            var lineIndex = lineNumber - visibleStartLineNumber;
            output[lineIndex] = '';
        }
        // Render first whole line decorations and then regular decorations
        this._renderWholeLineDecorations(ctx, decorations, output);
        this._renderNormalDecorations(ctx, decorations, output);
        this._renderResult = output;
    };
    DecorationsOverlay.prototype._renderWholeLineDecorations = function (ctx, decorations, output) {
        var lineHeight = String(this._lineHeight);
        var visibleStartLineNumber = ctx.visibleRange.startLineNumber;
        var visibleEndLineNumber = ctx.visibleRange.endLineNumber;
        for (var i = 0, lenI = decorations.length; i < lenI; i++) {
            var d = decorations[i];
            if (!d.options.isWholeLine) {
                continue;
            }
            var decorationOutput = ('<div class="cdr '
                + d.options.className
                + '" style="left:0;width:100%;height:'
                + lineHeight
                + 'px;"></div>');
            var startLineNumber = Math.max(d.range.startLineNumber, visibleStartLineNumber);
            var endLineNumber = Math.min(d.range.endLineNumber, visibleEndLineNumber);
            for (var j = startLineNumber; j <= endLineNumber; j++) {
                var lineIndex = j - visibleStartLineNumber;
                output[lineIndex] += decorationOutput;
            }
        }
    };
    DecorationsOverlay.prototype._renderNormalDecorations = function (ctx, decorations, output) {
        var lineHeight = String(this._lineHeight);
        var visibleStartLineNumber = ctx.visibleRange.startLineNumber;
        var prevClassName = null;
        var prevShowIfCollapsed = false;
        var prevRange = null;
        for (var i = 0, lenI = decorations.length; i < lenI; i++) {
            var d = decorations[i];
            if (d.options.isWholeLine) {
                continue;
            }
            var className = d.options.className;
            var showIfCollapsed = d.options.showIfCollapsed;
            var range = d.range;
            if (showIfCollapsed && range.endColumn === 1 && range.endLineNumber !== range.startLineNumber) {
                range = new Range(range.startLineNumber, range.startColumn, range.endLineNumber - 1, this._context.model.getLineMaxColumn(range.endLineNumber - 1));
            }
            if (prevClassName === className && prevShowIfCollapsed === showIfCollapsed && Range.areIntersectingOrTouching(prevRange, range)) {
                // merge into previous decoration
                prevRange = Range.plusRange(prevRange, range);
                continue;
            }
            // flush previous decoration
            if (prevClassName !== null) {
                this._renderNormalDecoration(ctx, prevRange, prevClassName, prevShowIfCollapsed, lineHeight, visibleStartLineNumber, output);
            }
            prevClassName = className;
            prevShowIfCollapsed = showIfCollapsed;
            prevRange = range;
        }
        if (prevClassName !== null) {
            this._renderNormalDecoration(ctx, prevRange, prevClassName, prevShowIfCollapsed, lineHeight, visibleStartLineNumber, output);
        }
    };
    DecorationsOverlay.prototype._renderNormalDecoration = function (ctx, range, className, showIfCollapsed, lineHeight, visibleStartLineNumber, output) {
        var linesVisibleRanges = ctx.linesVisibleRangesForRange(range, /*TODO@Alex*/ className === 'findMatch');
        if (!linesVisibleRanges) {
            return;
        }
        for (var j = 0, lenJ = linesVisibleRanges.length; j < lenJ; j++) {
            var lineVisibleRanges = linesVisibleRanges[j];
            var lineIndex = lineVisibleRanges.lineNumber - visibleStartLineNumber;
            if (showIfCollapsed && lineVisibleRanges.ranges.length === 1) {
                var singleVisibleRange = lineVisibleRanges.ranges[0];
                if (singleVisibleRange.width === 0) {
                    // collapsed range case => make the decoration visible by faking its width
                    lineVisibleRanges.ranges[0] = new HorizontalRange(singleVisibleRange.left, this._typicalHalfwidthCharacterWidth);
                }
            }
            for (var k = 0, lenK = lineVisibleRanges.ranges.length; k < lenK; k++) {
                var visibleRange = lineVisibleRanges.ranges[k];
                var decorationOutput = ('<div class="cdr '
                    + className
                    + '" style="left:'
                    + String(visibleRange.left)
                    + 'px;width:'
                    + String(visibleRange.width)
                    + 'px;height:'
                    + lineHeight
                    + 'px;"></div>');
                output[lineIndex] += decorationOutput;
            }
        }
    };
    DecorationsOverlay.prototype.render = function (startLineNumber, lineNumber) {
        if (!this._renderResult) {
            return '';
        }
        var lineIndex = lineNumber - startLineNumber;
        if (lineIndex < 0 || lineIndex >= this._renderResult.length) {
            return '';
        }
        return this._renderResult[lineIndex];
    };
    return DecorationsOverlay;
}(DynamicViewOverlay));

const css$8 = "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n.monaco-editor .glyph-margin {\n\tposition: absolute;\n\ttop: 0;\n}\n\n/*\n\tKeeping name short for faster parsing.\n\tcgmr = core glyph margin rendering (div)\n*/\n.monaco-editor .margin-view-overlays .cgmr {\n\tposition: absolute;\n}\n";
  const element$8 = ((css, src) => {
if (typeof document !== 'object')
console.info(`Skipped loading "${src}"`);
try {
const id = src
  .replace(/\.css.*$/, '')
  .replace(/[\\:]/g, '/')
  .replace(/[^\w\/]+/g, '');
return (
  document.querySelector(`style[id="${id}"]`) ||
  document.head.appendChild(
    Object.assign(document.createElement('style'), {
      id,
      textContent: `${css}\n\n /* sourceURL=${src} */`,
    }),
  )
);
} catch (exception) {
console.warn(`Failed load "${src}"`, exception);
}
})(css$8, "…monaco-editor/esm/vs/editor/browser/viewParts/glyphMargin/glyphMargin.css");
  //@ sourceURL=/Users/daflair/Projects/packages/monaco-es/node_modules/monaco-editor/esm/vs/editor/browser/viewParts/glyphMargin/glyphMargin.css

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$G = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var DecorationToRender = /** @class */ (function () {
    function DecorationToRender(startLineNumber, endLineNumber, className) {
        this.startLineNumber = +startLineNumber;
        this.endLineNumber = +endLineNumber;
        this.className = String(className);
    }
    return DecorationToRender;
}());
var DedupOverlay = /** @class */ (function (_super) {
    __extends$G(DedupOverlay, _super);
    function DedupOverlay() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    DedupOverlay.prototype._render = function (visibleStartLineNumber, visibleEndLineNumber, decorations) {
        var output = [];
        for (var lineNumber = visibleStartLineNumber; lineNumber <= visibleEndLineNumber; lineNumber++) {
            var lineIndex = lineNumber - visibleStartLineNumber;
            output[lineIndex] = [];
        }
        if (decorations.length === 0) {
            return output;
        }
        decorations.sort(function (a, b) {
            if (a.className === b.className) {
                if (a.startLineNumber === b.startLineNumber) {
                    return a.endLineNumber - b.endLineNumber;
                }
                return a.startLineNumber - b.startLineNumber;
            }
            return (a.className < b.className ? -1 : 1);
        });
        var prevClassName = null;
        var prevEndLineIndex = 0;
        for (var i = 0, len = decorations.length; i < len; i++) {
            var d = decorations[i];
            var className = d.className;
            var startLineIndex = Math.max(d.startLineNumber, visibleStartLineNumber) - visibleStartLineNumber;
            var endLineIndex = Math.min(d.endLineNumber, visibleEndLineNumber) - visibleStartLineNumber;
            if (prevClassName === className) {
                startLineIndex = Math.max(prevEndLineIndex + 1, startLineIndex);
                prevEndLineIndex = Math.max(prevEndLineIndex, endLineIndex);
            }
            else {
                prevClassName = className;
                prevEndLineIndex = endLineIndex;
            }
            for (var i_1 = startLineIndex; i_1 <= prevEndLineIndex; i_1++) {
                output[i_1].push(prevClassName);
            }
        }
        return output;
    };
    return DedupOverlay;
}(DynamicViewOverlay));
var GlyphMarginOverlay = /** @class */ (function (_super) {
    __extends$G(GlyphMarginOverlay, _super);
    function GlyphMarginOverlay(context) {
        var _this = _super.call(this) || this;
        _this._context = context;
        _this._lineHeight = _this._context.configuration.editor.lineHeight;
        _this._glyphMargin = _this._context.configuration.editor.viewInfo.glyphMargin;
        _this._glyphMarginLeft = _this._context.configuration.editor.layoutInfo.glyphMarginLeft;
        _this._glyphMarginWidth = _this._context.configuration.editor.layoutInfo.glyphMarginWidth;
        _this._renderResult = null;
        _this._context.addEventHandler(_this);
        return _this;
    }
    GlyphMarginOverlay.prototype.dispose = function () {
        this._context.removeEventHandler(this);
        this._context = null;
        this._renderResult = null;
        _super.prototype.dispose.call(this);
    };
    // --- begin event handlers
    GlyphMarginOverlay.prototype.onConfigurationChanged = function (e) {
        if (e.lineHeight) {
            this._lineHeight = this._context.configuration.editor.lineHeight;
        }
        if (e.viewInfo) {
            this._glyphMargin = this._context.configuration.editor.viewInfo.glyphMargin;
        }
        if (e.layoutInfo) {
            this._glyphMarginLeft = this._context.configuration.editor.layoutInfo.glyphMarginLeft;
            this._glyphMarginWidth = this._context.configuration.editor.layoutInfo.glyphMarginWidth;
        }
        return true;
    };
    GlyphMarginOverlay.prototype.onDecorationsChanged = function (e) {
        return true;
    };
    GlyphMarginOverlay.prototype.onFlushed = function (e) {
        return true;
    };
    GlyphMarginOverlay.prototype.onLinesChanged = function (e) {
        return true;
    };
    GlyphMarginOverlay.prototype.onLinesDeleted = function (e) {
        return true;
    };
    GlyphMarginOverlay.prototype.onLinesInserted = function (e) {
        return true;
    };
    GlyphMarginOverlay.prototype.onScrollChanged = function (e) {
        return e.scrollTopChanged;
    };
    GlyphMarginOverlay.prototype.onZonesChanged = function (e) {
        return true;
    };
    // --- end event handlers
    GlyphMarginOverlay.prototype._getDecorations = function (ctx) {
        var decorations = ctx.getDecorationsInViewport();
        var r = [], rLen = 0;
        for (var i = 0, len = decorations.length; i < len; i++) {
            var d = decorations[i];
            var glyphMarginClassName = d.options.glyphMarginClassName;
            if (glyphMarginClassName) {
                r[rLen++] = new DecorationToRender(d.range.startLineNumber, d.range.endLineNumber, glyphMarginClassName);
            }
        }
        return r;
    };
    GlyphMarginOverlay.prototype.prepareRender = function (ctx) {
        if (!this._glyphMargin) {
            this._renderResult = null;
            return;
        }
        var visibleStartLineNumber = ctx.visibleRange.startLineNumber;
        var visibleEndLineNumber = ctx.visibleRange.endLineNumber;
        var toRender = this._render(visibleStartLineNumber, visibleEndLineNumber, this._getDecorations(ctx));
        var lineHeight = this._lineHeight.toString();
        var left = this._glyphMarginLeft.toString();
        var width = this._glyphMarginWidth.toString();
        var common = '" style="left:' + left + 'px;width:' + width + 'px' + ';height:' + lineHeight + 'px;"></div>';
        var output = [];
        for (var lineNumber = visibleStartLineNumber; lineNumber <= visibleEndLineNumber; lineNumber++) {
            var lineIndex = lineNumber - visibleStartLineNumber;
            var classNames = toRender[lineIndex];
            if (classNames.length === 0) {
                output[lineIndex] = '';
            }
            else {
                output[lineIndex] = ('<div class="cgmr '
                    + classNames.join(' ')
                    + common);
            }
        }
        this._renderResult = output;
    };
    GlyphMarginOverlay.prototype.render = function (startLineNumber, lineNumber) {
        if (!this._renderResult) {
            return '';
        }
        var lineIndex = lineNumber - startLineNumber;
        if (lineIndex < 0 || lineIndex >= this._renderResult.length) {
            return '';
        }
        return this._renderResult[lineIndex];
    };
    return GlyphMarginOverlay;
}(DedupOverlay));

const css$9 = "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n/*\n\tKeeping name short for faster parsing.\n\tcigr = core ident guides rendering (div)\n*/\n.monaco-editor .lines-content .cigr {\n\tposition: absolute;\n}\n.monaco-editor .lines-content .cigra {\n\tposition: absolute;\n}\n";
  const element$9 = ((css, src) => {
if (typeof document !== 'object')
console.info(`Skipped loading "${src}"`);
try {
const id = src
  .replace(/\.css.*$/, '')
  .replace(/[\\:]/g, '/')
  .replace(/[^\w\/]+/g, '');
return (
  document.querySelector(`style[id="${id}"]`) ||
  document.head.appendChild(
    Object.assign(document.createElement('style'), {
      id,
      textContent: `${css}\n\n /* sourceURL=${src} */`,
    }),
  )
);
} catch (exception) {
console.warn(`Failed load "${src}"`, exception);
}
})(css$9, "…monaco-editor/esm/vs/editor/browser/viewParts/indentGuides/indentGuides.css");
  //@ sourceURL=/Users/daflair/Projects/packages/monaco-es/node_modules/monaco-editor/esm/vs/editor/browser/viewParts/indentGuides/indentGuides.css

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$H = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var IndentGuidesOverlay = /** @class */ (function (_super) {
    __extends$H(IndentGuidesOverlay, _super);
    function IndentGuidesOverlay(context) {
        var _this = _super.call(this) || this;
        _this._context = context;
        _this._primaryLineNumber = 0;
        _this._lineHeight = _this._context.configuration.editor.lineHeight;
        _this._spaceWidth = _this._context.configuration.editor.fontInfo.spaceWidth;
        _this._enabled = _this._context.configuration.editor.viewInfo.renderIndentGuides;
        _this._renderResult = null;
        _this._context.addEventHandler(_this);
        return _this;
    }
    IndentGuidesOverlay.prototype.dispose = function () {
        this._context.removeEventHandler(this);
        this._context = null;
        this._renderResult = null;
        _super.prototype.dispose.call(this);
    };
    // --- begin event handlers
    IndentGuidesOverlay.prototype.onConfigurationChanged = function (e) {
        if (e.lineHeight) {
            this._lineHeight = this._context.configuration.editor.lineHeight;
        }
        if (e.fontInfo) {
            this._spaceWidth = this._context.configuration.editor.fontInfo.spaceWidth;
        }
        if (e.viewInfo) {
            this._enabled = this._context.configuration.editor.viewInfo.renderIndentGuides;
        }
        return true;
    };
    IndentGuidesOverlay.prototype.onCursorStateChanged = function (e) {
        var selection = e.selections[0];
        var newPrimaryLineNumber = selection.isEmpty() ? selection.positionLineNumber : 0;
        if (this._primaryLineNumber !== newPrimaryLineNumber) {
            this._primaryLineNumber = newPrimaryLineNumber;
            return true;
        }
        return false;
    };
    IndentGuidesOverlay.prototype.onDecorationsChanged = function (e) {
        // true for inline decorations
        return true;
    };
    IndentGuidesOverlay.prototype.onFlushed = function (e) {
        return true;
    };
    IndentGuidesOverlay.prototype.onLinesChanged = function (e) {
        return true;
    };
    IndentGuidesOverlay.prototype.onLinesDeleted = function (e) {
        return true;
    };
    IndentGuidesOverlay.prototype.onLinesInserted = function (e) {
        return true;
    };
    IndentGuidesOverlay.prototype.onScrollChanged = function (e) {
        return e.scrollTopChanged; // || e.scrollWidthChanged;
    };
    IndentGuidesOverlay.prototype.onZonesChanged = function (e) {
        return true;
    };
    IndentGuidesOverlay.prototype.onLanguageConfigurationChanged = function (e) {
        return true;
    };
    // --- end event handlers
    IndentGuidesOverlay.prototype.prepareRender = function (ctx) {
        if (!this._enabled) {
            this._renderResult = null;
            return;
        }
        var visibleStartLineNumber = ctx.visibleRange.startLineNumber;
        var visibleEndLineNumber = ctx.visibleRange.endLineNumber;
        var tabSize = this._context.model.getTabSize();
        var tabWidth = tabSize * this._spaceWidth;
        var lineHeight = this._lineHeight;
        var indentGuideWidth = tabWidth;
        var indents = this._context.model.getLinesIndentGuides(visibleStartLineNumber, visibleEndLineNumber);
        var activeIndentStartLineNumber = 0;
        var activeIndentEndLineNumber = 0;
        var activeIndentLevel = 0;
        if (this._primaryLineNumber) {
            var activeIndentInfo = this._context.model.getActiveIndentGuide(this._primaryLineNumber, visibleStartLineNumber, visibleEndLineNumber);
            activeIndentStartLineNumber = activeIndentInfo.startLineNumber;
            activeIndentEndLineNumber = activeIndentInfo.endLineNumber;
            activeIndentLevel = activeIndentInfo.indent;
        }
        var output = [];
        for (var lineNumber = visibleStartLineNumber; lineNumber <= visibleEndLineNumber; lineNumber++) {
            var containsActiveIndentGuide = (activeIndentStartLineNumber <= lineNumber && lineNumber <= activeIndentEndLineNumber);
            var lineIndex = lineNumber - visibleStartLineNumber;
            var indent = indents[lineIndex];
            var result = '';
            var leftMostVisiblePosition = ctx.visibleRangeForPosition(new Position(lineNumber, 1));
            var left = leftMostVisiblePosition ? leftMostVisiblePosition.left : 0;
            for (var i = 1; i <= indent; i++) {
                var className = (containsActiveIndentGuide && i === activeIndentLevel ? 'cigra' : 'cigr');
                result += "<div class=\"" + className + "\" style=\"left:" + left + "px;height:" + lineHeight + "px;width:" + indentGuideWidth + "px\"></div>";
                left += tabWidth;
            }
            output[lineIndex] = result;
        }
        this._renderResult = output;
    };
    IndentGuidesOverlay.prototype.render = function (startLineNumber, lineNumber) {
        if (!this._renderResult) {
            return '';
        }
        var lineIndex = lineNumber - startLineNumber;
        if (lineIndex < 0 || lineIndex >= this._renderResult.length) {
            return '';
        }
        return this._renderResult[lineIndex];
    };
    return IndentGuidesOverlay;
}(DynamicViewOverlay));
registerThemingParticipant(function (theme, collector) {
    var editorIndentGuidesColor = theme.getColor(editorIndentGuides);
    if (editorIndentGuidesColor) {
        collector.addRule(".monaco-editor .lines-content .cigr { box-shadow: 1px 0 0 0 " + editorIndentGuidesColor + " inset; }");
    }
    var editorActiveIndentGuidesColor = theme.getColor(editorActiveIndentGuides) || editorIndentGuidesColor;
    if (editorActiveIndentGuidesColor) {
        collector.addRule(".monaco-editor .lines-content .cigra { box-shadow: 1px 0 0 0 " + editorActiveIndentGuidesColor + " inset; }");
    }
});

const css$a = "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n/* Uncomment to see lines flashing when they're painted */\n/*.monaco-editor .view-lines > .view-line {\n\tbackground-color: none;\n\tanimation-name: flash-background;\n\tanimation-duration: 800ms;\n}\n@keyframes flash-background {\n\t0%   { background-color: lightgreen; }\n\t100% { background-color: none }\n}*/\n\n.monaco-editor.safari .lines-content,\n.monaco-editor.safari .view-line,\n.monaco-editor.safari .view-lines {\n\t-webkit-user-select: text;\n\tuser-select: text;\n}\n\n.monaco-editor .lines-content,\n.monaco-editor .view-line,\n.monaco-editor .view-lines {\n\t-webkit-user-select: none;\n\t-ms-user-select: none;\n\t-khtml-user-select: none;\n\t-moz-user-select: none;\n\t-o-user-select: none;\n\tuser-select: none;\n}\n\n.monaco-editor .view-lines {\n\tcursor: text;\n\twhite-space: nowrap;\n}\n\n.monaco-editor.vs-dark.mac .view-lines,\n.monaco-editor.hc-black.mac .view-lines {\n\tcursor: -webkit-image-set(url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAQAAAC1+jfqAAAAL0lEQVQoz2NgCD3x//9/BhBYBWdhgFVAiVW4JBFKGIa4AqD0//9D3pt4I4tAdAMAHTQ/j5Zom30AAAAASUVORK5CYII=) 1x, url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAQAAADZc7J/AAAAz0lEQVRIx2NgYGBY/R8I/vx5eelX3n82IJ9FxGf6tksvf/8FiTMQAcAGQMDvSwu09abffY8QYSAScNk45G198eX//yev73/4///701eh//kZSARckrNBRvz//+8+6ZohwCzjGNjdgQxkAg7B9WADeBjIBqtJCbhRA0YNoIkBSNmaPEMoNmA0FkYNoFKhapJ6FGyAH3nauaSmPfwI0v/3OukVi0CIZ+F25KrtYcx/CTIy0e+rC7R1Z4KMICVTQQ14feVXIbR695u14+Ir4gwAAD49E54wc1kWAAAAAElFTkSuQmCC) 2x) 5 8, text;\n}\n\n.monaco-editor .view-line {\n\tposition: absolute;\n\twidth: 100%;\n}\n\n/* TODO@tokenization bootstrap fix */\n/*.monaco-editor .view-line > span > span {\n\tfloat: none;\n\tmin-height: inherit;\n\tmargin-left: inherit;\n}*/";
  const element$a = ((css, src) => {
if (typeof document !== 'object')
console.info(`Skipped loading "${src}"`);
try {
const id = src
  .replace(/\.css.*$/, '')
  .replace(/[\\:]/g, '/')
  .replace(/[^\w\/]+/g, '');
return (
  document.querySelector(`style[id="${id}"]`) ||
  document.head.appendChild(
    Object.assign(document.createElement('style'), {
      id,
      textContent: `${css}\n\n /* sourceURL=${src} */`,
    }),
  )
);
} catch (exception) {
console.warn(`Failed load "${src}"`, exception);
}
})(css$a, "…monaco-editor/esm/vs/editor/browser/viewParts/lines/viewLines.css");
  //@ sourceURL=/Users/daflair/Projects/packages/monaco-es/node_modules/monaco-editor/esm/vs/editor/browser/viewParts/lines/viewLines.css

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$I = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var LastRenderedData = /** @class */ (function () {
    function LastRenderedData() {
        this._currentVisibleRange = new Range(1, 1, 1, 1);
    }
    LastRenderedData.prototype.getCurrentVisibleRange = function () {
        return this._currentVisibleRange;
    };
    LastRenderedData.prototype.setCurrentVisibleRange = function (currentVisibleRange) {
        this._currentVisibleRange = currentVisibleRange;
    };
    return LastRenderedData;
}());
var HorizontalRevealRequest = /** @class */ (function () {
    function HorizontalRevealRequest(lineNumber, startColumn, endColumn, startScrollTop, stopScrollTop, scrollType) {
        this.lineNumber = lineNumber;
        this.startColumn = startColumn;
        this.endColumn = endColumn;
        this.startScrollTop = startScrollTop;
        this.stopScrollTop = stopScrollTop;
        this.scrollType = scrollType;
    }
    return HorizontalRevealRequest;
}());
var ViewLines = /** @class */ (function (_super) {
    __extends$I(ViewLines, _super);
    function ViewLines(context, linesContent) {
        var _this = _super.call(this, context) || this;
        _this._linesContent = linesContent;
        _this._textRangeRestingSpot = document.createElement('div');
        _this._visibleLines = new VisibleLinesCollection(_this);
        _this.domNode = _this._visibleLines.domNode;
        var conf = _this._context.configuration;
        _this._lineHeight = conf.editor.lineHeight;
        _this._typicalHalfwidthCharacterWidth = conf.editor.fontInfo.typicalHalfwidthCharacterWidth;
        _this._isViewportWrapping = conf.editor.wrappingInfo.isViewportWrapping;
        _this._revealHorizontalRightPadding = conf.editor.viewInfo.revealHorizontalRightPadding;
        _this._canUseLayerHinting = conf.editor.canUseLayerHinting;
        _this._viewLineOptions = new ViewLineOptions(conf, _this._context.theme.type);
        PartFingerprints.write(_this.domNode, 7 /* ViewLines */);
        _this.domNode.setClassName('view-lines');
        Configuration$1.applyFontInfo(_this.domNode, conf.editor.fontInfo);
        // --- width & height
        _this._maxLineWidth = 0;
        _this._asyncUpdateLineWidths = new RunOnceScheduler(function () {
            _this._updateLineWidthsSlow();
        }, 200);
        _this._lastRenderedData = new LastRenderedData();
        _this._horizontalRevealRequest = null;
        return _this;
    }
    ViewLines.prototype.dispose = function () {
        this._asyncUpdateLineWidths.dispose();
        _super.prototype.dispose.call(this);
    };
    ViewLines.prototype.getDomNode = function () {
        return this.domNode;
    };
    // ---- begin IVisibleLinesHost
    ViewLines.prototype.createVisibleLine = function () {
        return new ViewLine(this._viewLineOptions);
    };
    // ---- end IVisibleLinesHost
    // ---- begin view event handlers
    ViewLines.prototype.onConfigurationChanged = function (e) {
        this._visibleLines.onConfigurationChanged(e);
        if (e.wrappingInfo) {
            this._maxLineWidth = 0;
        }
        var conf = this._context.configuration;
        if (e.lineHeight) {
            this._lineHeight = conf.editor.lineHeight;
        }
        if (e.fontInfo) {
            this._typicalHalfwidthCharacterWidth = conf.editor.fontInfo.typicalHalfwidthCharacterWidth;
        }
        if (e.wrappingInfo) {
            this._isViewportWrapping = conf.editor.wrappingInfo.isViewportWrapping;
        }
        if (e.viewInfo) {
            this._revealHorizontalRightPadding = conf.editor.viewInfo.revealHorizontalRightPadding;
        }
        if (e.canUseLayerHinting) {
            this._canUseLayerHinting = conf.editor.canUseLayerHinting;
        }
        if (e.fontInfo) {
            Configuration$1.applyFontInfo(this.domNode, conf.editor.fontInfo);
        }
        this._onOptionsMaybeChanged();
        if (e.layoutInfo) {
            this._maxLineWidth = 0;
        }
        return true;
    };
    ViewLines.prototype._onOptionsMaybeChanged = function () {
        var conf = this._context.configuration;
        var newViewLineOptions = new ViewLineOptions(conf, this._context.theme.type);
        if (!this._viewLineOptions.equals(newViewLineOptions)) {
            this._viewLineOptions = newViewLineOptions;
            var startLineNumber = this._visibleLines.getStartLineNumber();
            var endLineNumber = this._visibleLines.getEndLineNumber();
            for (var lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {
                var line = this._visibleLines.getVisibleLine(lineNumber);
                line.onOptionsChanged(this._viewLineOptions);
            }
            return true;
        }
        return false;
    };
    ViewLines.prototype.onCursorStateChanged = function (e) {
        var rendStartLineNumber = this._visibleLines.getStartLineNumber();
        var rendEndLineNumber = this._visibleLines.getEndLineNumber();
        var r = false;
        for (var lineNumber = rendStartLineNumber; lineNumber <= rendEndLineNumber; lineNumber++) {
            r = this._visibleLines.getVisibleLine(lineNumber).onSelectionChanged() || r;
        }
        return r;
    };
    ViewLines.prototype.onDecorationsChanged = function (e) {
        {
            var rendStartLineNumber = this._visibleLines.getStartLineNumber();
            var rendEndLineNumber = this._visibleLines.getEndLineNumber();
            for (var lineNumber = rendStartLineNumber; lineNumber <= rendEndLineNumber; lineNumber++) {
                this._visibleLines.getVisibleLine(lineNumber).onDecorationsChanged();
            }
        }
        return true;
    };
    ViewLines.prototype.onFlushed = function (e) {
        var shouldRender = this._visibleLines.onFlushed(e);
        this._maxLineWidth = 0;
        return shouldRender;
    };
    ViewLines.prototype.onLinesChanged = function (e) {
        return this._visibleLines.onLinesChanged(e);
    };
    ViewLines.prototype.onLinesDeleted = function (e) {
        return this._visibleLines.onLinesDeleted(e);
    };
    ViewLines.prototype.onLinesInserted = function (e) {
        return this._visibleLines.onLinesInserted(e);
    };
    ViewLines.prototype.onRevealRangeRequest = function (e) {
        // Using the future viewport here in order to handle multiple
        // incoming reveal range requests that might all desire to be animated
        var desiredScrollTop = this._computeScrollTopToRevealRange(this._context.viewLayout.getFutureViewport(), e.range, e.verticalType);
        // validate the new desired scroll top
        var newScrollPosition = this._context.viewLayout.validateScrollPosition({ scrollTop: desiredScrollTop });
        if (e.revealHorizontal) {
            if (e.range.startLineNumber !== e.range.endLineNumber) {
                // Two or more lines? => scroll to base (That's how you see most of the two lines)
                newScrollPosition = {
                    scrollTop: newScrollPosition.scrollTop,
                    scrollLeft: 0
                };
            }
            else {
                // We don't necessarily know the horizontal offset of this range since the line might not be in the view...
                this._horizontalRevealRequest = new HorizontalRevealRequest(e.range.startLineNumber, e.range.startColumn, e.range.endColumn, this._context.viewLayout.getCurrentScrollTop(), newScrollPosition.scrollTop, e.scrollType);
            }
        }
        else {
            this._horizontalRevealRequest = null;
        }
        var scrollTopDelta = Math.abs(this._context.viewLayout.getCurrentScrollTop() - newScrollPosition.scrollTop);
        if (e.scrollType === 0 /* Smooth */ && scrollTopDelta > this._lineHeight) {
            this._context.viewLayout.setScrollPositionSmooth(newScrollPosition);
        }
        else {
            this._context.viewLayout.setScrollPositionNow(newScrollPosition);
        }
        return true;
    };
    ViewLines.prototype.onScrollChanged = function (e) {
        if (this._horizontalRevealRequest && e.scrollLeftChanged) {
            // cancel any outstanding horizontal reveal request if someone else scrolls horizontally.
            this._horizontalRevealRequest = null;
        }
        if (this._horizontalRevealRequest && e.scrollTopChanged) {
            var min = Math.min(this._horizontalRevealRequest.startScrollTop, this._horizontalRevealRequest.stopScrollTop);
            var max = Math.max(this._horizontalRevealRequest.startScrollTop, this._horizontalRevealRequest.stopScrollTop);
            if (e.scrollTop < min || e.scrollTop > max) {
                // cancel any outstanding horizontal reveal request if someone else scrolls vertically.
                this._horizontalRevealRequest = null;
            }
        }
        this.domNode.setWidth(e.scrollWidth);
        return this._visibleLines.onScrollChanged(e) || true;
    };
    ViewLines.prototype.onTokensChanged = function (e) {
        return this._visibleLines.onTokensChanged(e);
    };
    ViewLines.prototype.onZonesChanged = function (e) {
        return this._visibleLines.onZonesChanged(e);
    };
    ViewLines.prototype.onThemeChanged = function (e) {
        return this._onOptionsMaybeChanged();
    };
    // ---- end view event handlers
    // ----------- HELPERS FOR OTHERS
    ViewLines.prototype.getPositionFromDOMInfo = function (spanNode, offset) {
        var viewLineDomNode = this._getViewLineDomNode(spanNode);
        if (viewLineDomNode === null) {
            // Couldn't find view line node
            return null;
        }
        var lineNumber = this._getLineNumberFor(viewLineDomNode);
        if (lineNumber === -1) {
            // Couldn't find view line node
            return null;
        }
        if (lineNumber < 1 || lineNumber > this._context.model.getLineCount()) {
            // lineNumber is outside range
            return null;
        }
        if (this._context.model.getLineMaxColumn(lineNumber) === 1) {
            // Line is empty
            return new Position(lineNumber, 1);
        }
        var rendStartLineNumber = this._visibleLines.getStartLineNumber();
        var rendEndLineNumber = this._visibleLines.getEndLineNumber();
        if (lineNumber < rendStartLineNumber || lineNumber > rendEndLineNumber) {
            // Couldn't find line
            return null;
        }
        var column = this._visibleLines.getVisibleLine(lineNumber).getColumnOfNodeOffset(lineNumber, spanNode, offset);
        var minColumn = this._context.model.getLineMinColumn(lineNumber);
        if (column < minColumn) {
            column = minColumn;
        }
        return new Position(lineNumber, column);
    };
    ViewLines.prototype._getViewLineDomNode = function (node) {
        while (node && node.nodeType === 1) {
            if (node.className === ViewLine.CLASS_NAME) {
                return node;
            }
            node = node.parentElement;
        }
        return null;
    };
    /**
     * @returns the line number of this view line dom node.
     */
    ViewLines.prototype._getLineNumberFor = function (domNode) {
        var startLineNumber = this._visibleLines.getStartLineNumber();
        var endLineNumber = this._visibleLines.getEndLineNumber();
        for (var lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {
            var line = this._visibleLines.getVisibleLine(lineNumber);
            if (domNode === line.getDomNode()) {
                return lineNumber;
            }
        }
        return -1;
    };
    ViewLines.prototype.getLineWidth = function (lineNumber) {
        var rendStartLineNumber = this._visibleLines.getStartLineNumber();
        var rendEndLineNumber = this._visibleLines.getEndLineNumber();
        if (lineNumber < rendStartLineNumber || lineNumber > rendEndLineNumber) {
            // Couldn't find line
            return -1;
        }
        return this._visibleLines.getVisibleLine(lineNumber).getWidth();
    };
    ViewLines.prototype.linesVisibleRangesForRange = function (range, includeNewLines) {
        if (this.shouldRender()) {
            // Cannot read from the DOM because it is dirty
            // i.e. the model & the dom are out of sync, so I'd be reading something stale
            return null;
        }
        var originalEndLineNumber = range.endLineNumber;
        range = Range.intersectRanges(range, this._lastRenderedData.getCurrentVisibleRange());
        if (!range) {
            return null;
        }
        var visibleRanges = [], visibleRangesLen = 0;
        var domReadingContext = new DomReadingContext(this.domNode.domNode, this._textRangeRestingSpot);
        var nextLineModelLineNumber;
        if (includeNewLines) {
            nextLineModelLineNumber = this._context.model.coordinatesConverter.convertViewPositionToModelPosition(new Position(range.startLineNumber, 1)).lineNumber;
        }
        var rendStartLineNumber = this._visibleLines.getStartLineNumber();
        var rendEndLineNumber = this._visibleLines.getEndLineNumber();
        for (var lineNumber = range.startLineNumber; lineNumber <= range.endLineNumber; lineNumber++) {
            if (lineNumber < rendStartLineNumber || lineNumber > rendEndLineNumber) {
                continue;
            }
            var startColumn = lineNumber === range.startLineNumber ? range.startColumn : 1;
            var endColumn = lineNumber === range.endLineNumber ? range.endColumn : this._context.model.getLineMaxColumn(lineNumber);
            var visibleRangesForLine = this._visibleLines.getVisibleLine(lineNumber).getVisibleRangesForRange(startColumn, endColumn, domReadingContext);
            if (!visibleRangesForLine || visibleRangesForLine.length === 0) {
                continue;
            }
            if (includeNewLines && lineNumber < originalEndLineNumber) {
                var currentLineModelLineNumber = nextLineModelLineNumber;
                nextLineModelLineNumber = this._context.model.coordinatesConverter.convertViewPositionToModelPosition(new Position(lineNumber + 1, 1)).lineNumber;
                if (currentLineModelLineNumber !== nextLineModelLineNumber) {
                    visibleRangesForLine[visibleRangesForLine.length - 1].width += this._typicalHalfwidthCharacterWidth;
                }
            }
            visibleRanges[visibleRangesLen++] = new LineVisibleRanges(lineNumber, visibleRangesForLine);
        }
        if (visibleRangesLen === 0) {
            return null;
        }
        return visibleRanges;
    };
    ViewLines.prototype.visibleRangesForRange2 = function (range) {
        if (this.shouldRender()) {
            // Cannot read from the DOM because it is dirty
            // i.e. the model & the dom are out of sync, so I'd be reading something stale
            return null;
        }
        range = Range.intersectRanges(range, this._lastRenderedData.getCurrentVisibleRange());
        if (!range) {
            return null;
        }
        var result = [];
        var domReadingContext = new DomReadingContext(this.domNode.domNode, this._textRangeRestingSpot);
        var rendStartLineNumber = this._visibleLines.getStartLineNumber();
        var rendEndLineNumber = this._visibleLines.getEndLineNumber();
        for (var lineNumber = range.startLineNumber; lineNumber <= range.endLineNumber; lineNumber++) {
            if (lineNumber < rendStartLineNumber || lineNumber > rendEndLineNumber) {
                continue;
            }
            var startColumn = lineNumber === range.startLineNumber ? range.startColumn : 1;
            var endColumn = lineNumber === range.endLineNumber ? range.endColumn : this._context.model.getLineMaxColumn(lineNumber);
            var visibleRangesForLine = this._visibleLines.getVisibleLine(lineNumber).getVisibleRangesForRange(startColumn, endColumn, domReadingContext);
            if (!visibleRangesForLine || visibleRangesForLine.length === 0) {
                continue;
            }
            result = result.concat(visibleRangesForLine);
        }
        if (result.length === 0) {
            return null;
        }
        return result;
    };
    // --- implementation
    ViewLines.prototype.updateLineWidths = function () {
        this._updateLineWidths(false);
    };
    /**
     * Updates the max line width if it is fast to compute.
     * Returns true if all lines were taken into account.
     * Returns false if some lines need to be reevaluated (in a slow fashion).
     */
    ViewLines.prototype._updateLineWidthsFast = function () {
        return this._updateLineWidths(true);
    };
    ViewLines.prototype._updateLineWidthsSlow = function () {
        this._updateLineWidths(false);
    };
    ViewLines.prototype._updateLineWidths = function (fast) {
        var rendStartLineNumber = this._visibleLines.getStartLineNumber();
        var rendEndLineNumber = this._visibleLines.getEndLineNumber();
        var localMaxLineWidth = 1;
        var allWidthsComputed = true;
        for (var lineNumber = rendStartLineNumber; lineNumber <= rendEndLineNumber; lineNumber++) {
            var visibleLine = this._visibleLines.getVisibleLine(lineNumber);
            if (fast && !visibleLine.getWidthIsFast()) {
                // Cannot compute width in a fast way for this line
                allWidthsComputed = false;
                continue;
            }
            localMaxLineWidth = Math.max(localMaxLineWidth, visibleLine.getWidth());
        }
        if (allWidthsComputed && rendStartLineNumber === 1 && rendEndLineNumber === this._context.model.getLineCount()) {
            // we know the max line width for all the lines
            this._maxLineWidth = 0;
        }
        this._ensureMaxLineWidth(localMaxLineWidth);
        return allWidthsComputed;
    };
    ViewLines.prototype.prepareRender = function () {
        throw new Error('Not supported');
    };
    ViewLines.prototype.render = function () {
        throw new Error('Not supported');
    };
    ViewLines.prototype.renderText = function (viewportData) {
        // (1) render lines - ensures lines are in the DOM
        this._visibleLines.renderLines(viewportData);
        this._lastRenderedData.setCurrentVisibleRange(viewportData.visibleRange);
        this.domNode.setWidth(this._context.viewLayout.getScrollWidth());
        this.domNode.setHeight(Math.min(this._context.viewLayout.getScrollHeight(), 1000000));
        // (2) compute horizontal scroll position:
        //  - this must happen after the lines are in the DOM since it might need a line that rendered just now
        //  - it might change `scrollWidth` and `scrollLeft`
        if (this._horizontalRevealRequest) {
            var revealLineNumber = this._horizontalRevealRequest.lineNumber;
            var revealStartColumn = this._horizontalRevealRequest.startColumn;
            var revealEndColumn = this._horizontalRevealRequest.endColumn;
            var scrollType = this._horizontalRevealRequest.scrollType;
            // Check that we have the line that contains the horizontal range in the viewport
            if (viewportData.startLineNumber <= revealLineNumber && revealLineNumber <= viewportData.endLineNumber) {
                this._horizontalRevealRequest = null;
                // allow `visibleRangesForRange2` to work
                this.onDidRender();
                // compute new scroll position
                var newScrollLeft = this._computeScrollLeftToRevealRange(revealLineNumber, revealStartColumn, revealEndColumn);
                var isViewportWrapping = this._isViewportWrapping;
                if (!isViewportWrapping) {
                    // ensure `scrollWidth` is large enough
                    this._ensureMaxLineWidth(newScrollLeft.maxHorizontalOffset);
                }
                // set `scrollLeft`
                if (scrollType === 0 /* Smooth */) {
                    this._context.viewLayout.setScrollPositionSmooth({
                        scrollLeft: newScrollLeft.scrollLeft
                    });
                }
                else {
                    this._context.viewLayout.setScrollPositionNow({
                        scrollLeft: newScrollLeft.scrollLeft
                    });
                }
            }
        }
        // Update max line width (not so important, it is just so the horizontal scrollbar doesn't get too small)
        if (!this._updateLineWidthsFast()) {
            // Computing the width of some lines would be slow => delay it
            this._asyncUpdateLineWidths.schedule();
        }
        // (3) handle scrolling
        this._linesContent.setLayerHinting(this._canUseLayerHinting);
        var adjustedScrollTop = this._context.viewLayout.getCurrentScrollTop() - viewportData.bigNumbersDelta;
        this._linesContent.setTop(-adjustedScrollTop);
        this._linesContent.setLeft(-this._context.viewLayout.getCurrentScrollLeft());
    };
    // --- width
    ViewLines.prototype._ensureMaxLineWidth = function (lineWidth) {
        var iLineWidth = Math.ceil(lineWidth);
        if (this._maxLineWidth < iLineWidth) {
            this._maxLineWidth = iLineWidth;
            this._context.viewLayout.onMaxLineWidthChanged(this._maxLineWidth);
        }
    };
    ViewLines.prototype._computeScrollTopToRevealRange = function (viewport, range, verticalType) {
        var viewportStartY = viewport.top;
        var viewportHeight = viewport.height;
        var viewportEndY = viewportStartY + viewportHeight;
        var boxStartY;
        var boxEndY;
        // Have a box that includes one extra line height (for the horizontal scrollbar)
        boxStartY = this._context.viewLayout.getVerticalOffsetForLineNumber(range.startLineNumber);
        boxEndY = this._context.viewLayout.getVerticalOffsetForLineNumber(range.endLineNumber) + this._lineHeight;
        if (verticalType === 0 /* Simple */ || verticalType === 4 /* Bottom */) {
            // Reveal one line more when the last line would be covered by the scrollbar - arrow down case or revealing a line explicitly at bottom
            boxEndY += this._lineHeight;
        }
        var newScrollTop;
        if (verticalType === 1 /* Center */ || verticalType === 2 /* CenterIfOutsideViewport */) {
            if (verticalType === 2 /* CenterIfOutsideViewport */ && viewportStartY <= boxStartY && boxEndY <= viewportEndY) {
                // Box is already in the viewport... do nothing
                newScrollTop = viewportStartY;
            }
            else {
                // Box is outside the viewport... center it
                var boxMiddleY = (boxStartY + boxEndY) / 2;
                newScrollTop = Math.max(0, boxMiddleY - viewportHeight / 2);
            }
        }
        else {
            newScrollTop = this._computeMinimumScrolling(viewportStartY, viewportEndY, boxStartY, boxEndY, verticalType === 3 /* Top */, verticalType === 4 /* Bottom */);
        }
        return newScrollTop;
    };
    ViewLines.prototype._computeScrollLeftToRevealRange = function (lineNumber, startColumn, endColumn) {
        var maxHorizontalOffset = 0;
        var viewport = this._context.viewLayout.getCurrentViewport();
        var viewportStartX = viewport.left;
        var viewportEndX = viewportStartX + viewport.width;
        var visibleRanges = this.visibleRangesForRange2(new Range(lineNumber, startColumn, lineNumber, endColumn));
        var boxStartX = Number.MAX_VALUE;
        var boxEndX = 0;
        if (!visibleRanges) {
            // Unknown
            return {
                scrollLeft: viewportStartX,
                maxHorizontalOffset: maxHorizontalOffset
            };
        }
        for (var i = 0; i < visibleRanges.length; i++) {
            var visibleRange = visibleRanges[i];
            if (visibleRange.left < boxStartX) {
                boxStartX = visibleRange.left;
            }
            if (visibleRange.left + visibleRange.width > boxEndX) {
                boxEndX = visibleRange.left + visibleRange.width;
            }
        }
        maxHorizontalOffset = boxEndX;
        boxStartX = Math.max(0, boxStartX - ViewLines.HORIZONTAL_EXTRA_PX);
        boxEndX += this._revealHorizontalRightPadding;
        var newScrollLeft = this._computeMinimumScrolling(viewportStartX, viewportEndX, boxStartX, boxEndX);
        return {
            scrollLeft: newScrollLeft,
            maxHorizontalOffset: maxHorizontalOffset
        };
    };
    ViewLines.prototype._computeMinimumScrolling = function (viewportStart, viewportEnd, boxStart, boxEnd, revealAtStart, revealAtEnd) {
        viewportStart = viewportStart | 0;
        viewportEnd = viewportEnd | 0;
        boxStart = boxStart | 0;
        boxEnd = boxEnd | 0;
        revealAtStart = !!revealAtStart;
        revealAtEnd = !!revealAtEnd;
        var viewportLength = viewportEnd - viewportStart;
        var boxLength = boxEnd - boxStart;
        if (boxLength < viewportLength) {
            // The box would fit in the viewport
            if (revealAtStart) {
                return boxStart;
            }
            if (revealAtEnd) {
                return Math.max(0, boxEnd - viewportLength);
            }
            if (boxStart < viewportStart) {
                // The box is above the viewport
                return boxStart;
            }
            else if (boxEnd > viewportEnd) {
                // The box is below the viewport
                return Math.max(0, boxEnd - viewportLength);
            }
        }
        else {
            // The box would not fit in the viewport
            // Reveal the beginning of the box
            return boxStart;
        }
        return viewportStart;
    };
    /**
     * Adds this ammount of pixels to the right of lines (no-one wants to type near the edge of the viewport)
     */
    ViewLines.HORIZONTAL_EXTRA_PX = 30;
    return ViewLines;
}(ViewPart));

const css$b = "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n.monaco-editor .lines-decorations {\n\tposition: absolute;\n\ttop: 0;\n\tbackground: white;\n}\n\n/*\n\tKeeping name short for faster parsing.\n\tcldr = core lines decorations rendering (div)\n*/\n.monaco-editor .margin-view-overlays .cldr {\n\tposition: absolute;\n\theight: 100%;\n}";
  const element$b = ((css, src) => {
if (typeof document !== 'object')
console.info(`Skipped loading "${src}"`);
try {
const id = src
  .replace(/\.css.*$/, '')
  .replace(/[\\:]/g, '/')
  .replace(/[^\w\/]+/g, '');
return (
  document.querySelector(`style[id="${id}"]`) ||
  document.head.appendChild(
    Object.assign(document.createElement('style'), {
      id,
      textContent: `${css}\n\n /* sourceURL=${src} */`,
    }),
  )
);
} catch (exception) {
console.warn(`Failed load "${src}"`, exception);
}
})(css$b, "…monaco-editor/esm/vs/editor/browser/viewParts/linesDecorations/linesDecorations.css");
  //@ sourceURL=/Users/daflair/Projects/packages/monaco-es/node_modules/monaco-editor/esm/vs/editor/browser/viewParts/linesDecorations/linesDecorations.css

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$J = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var LinesDecorationsOverlay = /** @class */ (function (_super) {
    __extends$J(LinesDecorationsOverlay, _super);
    function LinesDecorationsOverlay(context) {
        var _this = _super.call(this) || this;
        _this._context = context;
        _this._decorationsLeft = _this._context.configuration.editor.layoutInfo.decorationsLeft;
        _this._decorationsWidth = _this._context.configuration.editor.layoutInfo.decorationsWidth;
        _this._renderResult = null;
        _this._context.addEventHandler(_this);
        return _this;
    }
    LinesDecorationsOverlay.prototype.dispose = function () {
        this._context.removeEventHandler(this);
        this._context = null;
        this._renderResult = null;
        _super.prototype.dispose.call(this);
    };
    // --- begin event handlers
    LinesDecorationsOverlay.prototype.onConfigurationChanged = function (e) {
        if (e.layoutInfo) {
            this._decorationsLeft = this._context.configuration.editor.layoutInfo.decorationsLeft;
            this._decorationsWidth = this._context.configuration.editor.layoutInfo.decorationsWidth;
        }
        return true;
    };
    LinesDecorationsOverlay.prototype.onDecorationsChanged = function (e) {
        return true;
    };
    LinesDecorationsOverlay.prototype.onFlushed = function (e) {
        return true;
    };
    LinesDecorationsOverlay.prototype.onLinesChanged = function (e) {
        return true;
    };
    LinesDecorationsOverlay.prototype.onLinesDeleted = function (e) {
        return true;
    };
    LinesDecorationsOverlay.prototype.onLinesInserted = function (e) {
        return true;
    };
    LinesDecorationsOverlay.prototype.onScrollChanged = function (e) {
        return e.scrollTopChanged;
    };
    LinesDecorationsOverlay.prototype.onZonesChanged = function (e) {
        return true;
    };
    // --- end event handlers
    LinesDecorationsOverlay.prototype._getDecorations = function (ctx) {
        var decorations = ctx.getDecorationsInViewport();
        var r = [], rLen = 0;
        for (var i = 0, len = decorations.length; i < len; i++) {
            var d = decorations[i];
            var linesDecorationsClassName = d.options.linesDecorationsClassName;
            if (linesDecorationsClassName) {
                r[rLen++] = new DecorationToRender(d.range.startLineNumber, d.range.endLineNumber, linesDecorationsClassName);
            }
        }
        return r;
    };
    LinesDecorationsOverlay.prototype.prepareRender = function (ctx) {
        var visibleStartLineNumber = ctx.visibleRange.startLineNumber;
        var visibleEndLineNumber = ctx.visibleRange.endLineNumber;
        var toRender = this._render(visibleStartLineNumber, visibleEndLineNumber, this._getDecorations(ctx));
        var left = this._decorationsLeft.toString();
        var width = this._decorationsWidth.toString();
        var common = '" style="left:' + left + 'px;width:' + width + 'px;"></div>';
        var output = [];
        for (var lineNumber = visibleStartLineNumber; lineNumber <= visibleEndLineNumber; lineNumber++) {
            var lineIndex = lineNumber - visibleStartLineNumber;
            var classNames = toRender[lineIndex];
            var lineOutput = '';
            for (var i = 0, len = classNames.length; i < len; i++) {
                lineOutput += '<div class="cldr ' + classNames[i] + common;
            }
            output[lineIndex] = lineOutput;
        }
        this._renderResult = output;
    };
    LinesDecorationsOverlay.prototype.render = function (startLineNumber, lineNumber) {
        if (!this._renderResult) {
            return '';
        }
        return this._renderResult[lineNumber - startLineNumber];
    };
    return LinesDecorationsOverlay;
}(DedupOverlay));

const css$c = "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n/*\n\tKeeping name short for faster parsing.\n\tcmdr = core margin decorations rendering (div)\n*/\n.monaco-editor .margin-view-overlays .cmdr {\n\tposition: absolute;\n\tleft: 0;\n\twidth: 100%;\n\theight: 100%;\n}";
  const element$c = ((css, src) => {
if (typeof document !== 'object')
console.info(`Skipped loading "${src}"`);
try {
const id = src
  .replace(/\.css.*$/, '')
  .replace(/[\\:]/g, '/')
  .replace(/[^\w\/]+/g, '');
return (
  document.querySelector(`style[id="${id}"]`) ||
  document.head.appendChild(
    Object.assign(document.createElement('style'), {
      id,
      textContent: `${css}\n\n /* sourceURL=${src} */`,
    }),
  )
);
} catch (exception) {
console.warn(`Failed load "${src}"`, exception);
}
})(css$c, "…monaco-editor/esm/vs/editor/browser/viewParts/marginDecorations/marginDecorations.css");
  //@ sourceURL=/Users/daflair/Projects/packages/monaco-es/node_modules/monaco-editor/esm/vs/editor/browser/viewParts/marginDecorations/marginDecorations.css

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$K = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var MarginViewLineDecorationsOverlay = /** @class */ (function (_super) {
    __extends$K(MarginViewLineDecorationsOverlay, _super);
    function MarginViewLineDecorationsOverlay(context) {
        var _this = _super.call(this) || this;
        _this._context = context;
        _this._renderResult = null;
        _this._context.addEventHandler(_this);
        return _this;
    }
    MarginViewLineDecorationsOverlay.prototype.dispose = function () {
        this._context.removeEventHandler(this);
        this._context = null;
        this._renderResult = null;
        _super.prototype.dispose.call(this);
    };
    // --- begin event handlers
    MarginViewLineDecorationsOverlay.prototype.onConfigurationChanged = function (e) {
        return true;
    };
    MarginViewLineDecorationsOverlay.prototype.onDecorationsChanged = function (e) {
        return true;
    };
    MarginViewLineDecorationsOverlay.prototype.onFlushed = function (e) {
        return true;
    };
    MarginViewLineDecorationsOverlay.prototype.onLinesChanged = function (e) {
        return true;
    };
    MarginViewLineDecorationsOverlay.prototype.onLinesDeleted = function (e) {
        return true;
    };
    MarginViewLineDecorationsOverlay.prototype.onLinesInserted = function (e) {
        return true;
    };
    MarginViewLineDecorationsOverlay.prototype.onScrollChanged = function (e) {
        return e.scrollTopChanged;
    };
    MarginViewLineDecorationsOverlay.prototype.onZonesChanged = function (e) {
        return true;
    };
    // --- end event handlers
    MarginViewLineDecorationsOverlay.prototype._getDecorations = function (ctx) {
        var decorations = ctx.getDecorationsInViewport();
        var r = [], rLen = 0;
        for (var i = 0, len = decorations.length; i < len; i++) {
            var d = decorations[i];
            var marginClassName = d.options.marginClassName;
            if (marginClassName) {
                r[rLen++] = new DecorationToRender(d.range.startLineNumber, d.range.endLineNumber, marginClassName);
            }
        }
        return r;
    };
    MarginViewLineDecorationsOverlay.prototype.prepareRender = function (ctx) {
        var visibleStartLineNumber = ctx.visibleRange.startLineNumber;
        var visibleEndLineNumber = ctx.visibleRange.endLineNumber;
        var toRender = this._render(visibleStartLineNumber, visibleEndLineNumber, this._getDecorations(ctx));
        var output = [];
        for (var lineNumber = visibleStartLineNumber; lineNumber <= visibleEndLineNumber; lineNumber++) {
            var lineIndex = lineNumber - visibleStartLineNumber;
            var classNames = toRender[lineIndex];
            var lineOutput = '';
            for (var i = 0, len = classNames.length; i < len; i++) {
                lineOutput += '<div class="cmdr ' + classNames[i] + '" style=""></div>';
            }
            output[lineIndex] = lineOutput;
        }
        this._renderResult = output;
    };
    MarginViewLineDecorationsOverlay.prototype.render = function (startLineNumber, lineNumber) {
        if (!this._renderResult) {
            return '';
        }
        return this._renderResult[lineNumber - startLineNumber];
    };
    return MarginViewLineDecorationsOverlay;
}(DedupOverlay));

const css$d = "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n.monaco-editor .overlayWidgets {\n\tposition: absolute;\n\ttop: 0;\n\tleft:0;\n}";
  const element$d = ((css, src) => {
if (typeof document !== 'object')
console.info(`Skipped loading "${src}"`);
try {
const id = src
  .replace(/\.css.*$/, '')
  .replace(/[\\:]/g, '/')
  .replace(/[^\w\/]+/g, '');
return (
  document.querySelector(`style[id="${id}"]`) ||
  document.head.appendChild(
    Object.assign(document.createElement('style'), {
      id,
      textContent: `${css}\n\n /* sourceURL=${src} */`,
    }),
  )
);
} catch (exception) {
console.warn(`Failed load "${src}"`, exception);
}
})(css$d, "…monaco-editor/esm/vs/editor/browser/viewParts/overlayWidgets/overlayWidgets.css");
  //@ sourceURL=/Users/daflair/Projects/packages/monaco-es/node_modules/monaco-editor/esm/vs/editor/browser/viewParts/overlayWidgets/overlayWidgets.css

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$L = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var ViewOverlayWidgets = /** @class */ (function (_super) {
    __extends$L(ViewOverlayWidgets, _super);
    function ViewOverlayWidgets(context) {
        var _this = _super.call(this, context) || this;
        _this._widgets = {};
        _this._verticalScrollbarWidth = _this._context.configuration.editor.layoutInfo.verticalScrollbarWidth;
        _this._minimapWidth = _this._context.configuration.editor.layoutInfo.minimapWidth;
        _this._horizontalScrollbarHeight = _this._context.configuration.editor.layoutInfo.horizontalScrollbarHeight;
        _this._editorHeight = _this._context.configuration.editor.layoutInfo.height;
        _this._editorWidth = _this._context.configuration.editor.layoutInfo.width;
        _this._domNode = createFastDomNode(document.createElement('div'));
        PartFingerprints.write(_this._domNode, 4 /* OverlayWidgets */);
        _this._domNode.setClassName('overlayWidgets');
        return _this;
    }
    ViewOverlayWidgets.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
        this._widgets = null;
    };
    ViewOverlayWidgets.prototype.getDomNode = function () {
        return this._domNode;
    };
    // ---- begin view event handlers
    ViewOverlayWidgets.prototype.onConfigurationChanged = function (e) {
        if (e.layoutInfo) {
            this._verticalScrollbarWidth = this._context.configuration.editor.layoutInfo.verticalScrollbarWidth;
            this._minimapWidth = this._context.configuration.editor.layoutInfo.minimapWidth;
            this._horizontalScrollbarHeight = this._context.configuration.editor.layoutInfo.horizontalScrollbarHeight;
            this._editorHeight = this._context.configuration.editor.layoutInfo.height;
            this._editorWidth = this._context.configuration.editor.layoutInfo.width;
            return true;
        }
        return false;
    };
    // ---- end view event handlers
    ViewOverlayWidgets.prototype.addWidget = function (widget) {
        var domNode = createFastDomNode(widget.getDomNode());
        this._widgets[widget.getId()] = {
            widget: widget,
            preference: null,
            domNode: domNode
        };
        // This is sync because a widget wants to be in the dom
        domNode.setPosition('absolute');
        domNode.setAttribute('widgetId', widget.getId());
        this._domNode.appendChild(domNode);
        this.setShouldRender();
    };
    ViewOverlayWidgets.prototype.setWidgetPosition = function (widget, preference) {
        var widgetData = this._widgets[widget.getId()];
        if (widgetData.preference === preference) {
            return false;
        }
        widgetData.preference = preference;
        this.setShouldRender();
        return true;
    };
    ViewOverlayWidgets.prototype.removeWidget = function (widget) {
        var widgetId = widget.getId();
        if (this._widgets.hasOwnProperty(widgetId)) {
            var widgetData = this._widgets[widgetId];
            var domNode = widgetData.domNode.domNode;
            delete this._widgets[widgetId];
            domNode.parentNode.removeChild(domNode);
            this.setShouldRender();
        }
    };
    ViewOverlayWidgets.prototype._renderWidget = function (widgetData) {
        var domNode = widgetData.domNode;
        if (widgetData.preference === null) {
            domNode.unsetTop();
            return;
        }
        if (widgetData.preference === OverlayWidgetPositionPreference.TOP_RIGHT_CORNER) {
            domNode.setTop(0);
            domNode.setRight((2 * this._verticalScrollbarWidth) + this._minimapWidth);
        }
        else if (widgetData.preference === OverlayWidgetPositionPreference.BOTTOM_RIGHT_CORNER) {
            var widgetHeight = domNode.domNode.clientHeight;
            domNode.setTop((this._editorHeight - widgetHeight - 2 * this._horizontalScrollbarHeight));
            domNode.setRight((2 * this._verticalScrollbarWidth) + this._minimapWidth);
        }
        else if (widgetData.preference === OverlayWidgetPositionPreference.TOP_CENTER) {
            domNode.setTop(0);
            domNode.domNode.style.right = '50%';
        }
    };
    ViewOverlayWidgets.prototype.prepareRender = function (ctx) {
        // Nothing to read
    };
    ViewOverlayWidgets.prototype.render = function (ctx) {
        this._domNode.setWidth(this._editorWidth);
        var keys = Object.keys(this._widgets);
        for (var i = 0, len = keys.length; i < len; i++) {
            var widgetId = keys[i];
            this._renderWidget(this._widgets[widgetId]);
        }
    };
    return ViewOverlayWidgets;
}(ViewPart));

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$M = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var Settings = /** @class */ (function () {
    function Settings(config, theme) {
        this.lineHeight = config.editor.lineHeight;
        this.pixelRatio = config.editor.pixelRatio;
        this.overviewRulerLanes = config.editor.viewInfo.overviewRulerLanes;
        this.renderBorder = config.editor.viewInfo.overviewRulerBorder;
        var borderColor = theme.getColor(editorOverviewRulerBorder);
        this.borderColor = borderColor ? borderColor.toString() : null;
        this.hideCursor = config.editor.viewInfo.hideCursorInOverviewRuler;
        var cursorColor = theme.getColor(editorCursorForeground);
        this.cursorColor = cursorColor ? cursorColor.transparent(0.7).toString() : null;
        this.themeType = theme.type;
        var minimapEnabled = config.editor.viewInfo.minimap.enabled;
        var minimapSide = config.editor.viewInfo.minimap.side;
        var backgroundColor = (minimapEnabled ? TokenizationRegistry.getDefaultBackground() : null);
        if (backgroundColor === null || minimapSide === 'left') {
            this.backgroundColor = null;
        }
        else {
            this.backgroundColor = Color.Format.CSS.formatHex(backgroundColor);
        }
        var position = config.editor.layoutInfo.overviewRuler;
        this.top = position.top;
        this.right = position.right;
        this.domWidth = position.width;
        this.domHeight = position.height;
        this.canvasWidth = (this.domWidth * this.pixelRatio) | 0;
        this.canvasHeight = (this.domHeight * this.pixelRatio) | 0;
        var _a = this._initLanes(1, this.canvasWidth, this.overviewRulerLanes), x = _a[0], w = _a[1];
        this.x = x;
        this.w = w;
    }
    Settings.prototype._initLanes = function (canvasLeftOffset, canvasWidth, laneCount) {
        var remainingWidth = canvasWidth - canvasLeftOffset;
        if (laneCount >= 3) {
            var leftWidth = Math.floor(remainingWidth / 3);
            var rightWidth = Math.floor(remainingWidth / 3);
            var centerWidth = remainingWidth - leftWidth - rightWidth;
            var leftOffset = canvasLeftOffset;
            var centerOffset = leftOffset + leftWidth;
            var rightOffset = leftOffset + leftWidth + centerWidth;
            return [
                [
                    0,
                    leftOffset,
                    centerOffset,
                    leftOffset,
                    rightOffset,
                    leftOffset,
                    centerOffset,
                    leftOffset,
                ], [
                    0,
                    leftWidth,
                    centerWidth,
                    leftWidth + centerWidth,
                    rightWidth,
                    leftWidth + centerWidth + rightWidth,
                    centerWidth + rightWidth,
                    leftWidth + centerWidth + rightWidth,
                ]
            ];
        }
        else if (laneCount === 2) {
            var leftWidth = Math.floor(remainingWidth / 2);
            var rightWidth = remainingWidth - leftWidth;
            var leftOffset = canvasLeftOffset;
            var rightOffset = leftOffset + leftWidth;
            return [
                [
                    0,
                    leftOffset,
                    leftOffset,
                    leftOffset,
                    rightOffset,
                    leftOffset,
                    leftOffset,
                    leftOffset,
                ], [
                    0,
                    leftWidth,
                    leftWidth,
                    leftWidth,
                    rightWidth,
                    leftWidth + rightWidth,
                    leftWidth + rightWidth,
                    leftWidth + rightWidth,
                ]
            ];
        }
        else {
            var offset = canvasLeftOffset;
            var width = remainingWidth;
            return [
                [
                    0,
                    offset,
                    offset,
                    offset,
                    offset,
                    offset,
                    offset,
                    offset,
                ], [
                    0,
                    width,
                    width,
                    width,
                    width,
                    width,
                    width,
                    width,
                ]
            ];
        }
    };
    Settings.prototype.equals = function (other) {
        return (this.lineHeight === other.lineHeight
            && this.pixelRatio === other.pixelRatio
            && this.overviewRulerLanes === other.overviewRulerLanes
            && this.renderBorder === other.renderBorder
            && this.borderColor === other.borderColor
            && this.hideCursor === other.hideCursor
            && this.cursorColor === other.cursorColor
            && this.themeType === other.themeType
            && this.backgroundColor === other.backgroundColor
            && this.top === other.top
            && this.right === other.right
            && this.domWidth === other.domWidth
            && this.domHeight === other.domHeight
            && this.canvasWidth === other.canvasWidth
            && this.canvasHeight === other.canvasHeight);
    };
    return Settings;
}());
var DecorationsOverviewRuler = /** @class */ (function (_super) {
    __extends$M(DecorationsOverviewRuler, _super);
    function DecorationsOverviewRuler(context) {
        var _this = _super.call(this, context) || this;
        _this._domNode = createFastDomNode(document.createElement('canvas'));
        _this._domNode.setClassName('decorationsOverviewRuler');
        _this._domNode.setPosition('absolute');
        _this._domNode.setLayerHinting(true);
        _this._domNode.setAttribute('aria-hidden', 'true');
        _this._settings = null;
        _this._updateSettings(false);
        _this._tokensColorTrackerListener = TokenizationRegistry.onDidChange(function (e) {
            if (e.changedColorMap) {
                _this._updateSettings(true);
            }
        });
        _this._cursorPositions = [];
        return _this;
    }
    DecorationsOverviewRuler.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
        this._tokensColorTrackerListener.dispose();
    };
    DecorationsOverviewRuler.prototype._updateSettings = function (renderNow) {
        var newSettings = new Settings(this._context.configuration, this._context.theme);
        if (this._settings !== null && this._settings.equals(newSettings)) {
            // nothing to do
            return false;
        }
        this._settings = newSettings;
        this._domNode.setTop(this._settings.top);
        this._domNode.setRight(this._settings.right);
        this._domNode.setWidth(this._settings.domWidth);
        this._domNode.setHeight(this._settings.domHeight);
        this._domNode.domNode.width = this._settings.canvasWidth;
        this._domNode.domNode.height = this._settings.canvasHeight;
        if (renderNow) {
            this._render();
        }
        return true;
    };
    // ---- begin view event handlers
    DecorationsOverviewRuler.prototype.onConfigurationChanged = function (e) {
        return this._updateSettings(false);
    };
    DecorationsOverviewRuler.prototype.onCursorStateChanged = function (e) {
        this._cursorPositions = [];
        for (var i = 0, len = e.selections.length; i < len; i++) {
            this._cursorPositions[i] = e.selections[i].getPosition();
        }
        this._cursorPositions.sort(Position.compare);
        return true;
    };
    DecorationsOverviewRuler.prototype.onDecorationsChanged = function (e) {
        return true;
    };
    DecorationsOverviewRuler.prototype.onFlushed = function (e) {
        return true;
    };
    DecorationsOverviewRuler.prototype.onScrollChanged = function (e) {
        return e.scrollHeightChanged;
    };
    DecorationsOverviewRuler.prototype.onZonesChanged = function (e) {
        return true;
    };
    DecorationsOverviewRuler.prototype.onThemeChanged = function (e) {
        // invalidate color cache
        this._context.model.invalidateOverviewRulerColorCache();
        return this._updateSettings(false);
    };
    // ---- end view event handlers
    DecorationsOverviewRuler.prototype.getDomNode = function () {
        return this._domNode.domNode;
    };
    DecorationsOverviewRuler.prototype.prepareRender = function (ctx) {
        // Nothing to read
    };
    DecorationsOverviewRuler.prototype.render = function (editorCtx) {
        this._render();
    };
    DecorationsOverviewRuler.prototype._render = function () {
        var canvasWidth = this._settings.canvasWidth;
        var canvasHeight = this._settings.canvasHeight;
        var lineHeight = this._settings.lineHeight;
        var viewLayout = this._context.viewLayout;
        var outerHeight = this._context.viewLayout.getScrollHeight();
        var heightRatio = canvasHeight / outerHeight;
        var decorations = this._context.model.getAllOverviewRulerDecorations(this._context.theme);
        var minDecorationHeight = (6 /* MIN_DECORATION_HEIGHT */ * this._settings.pixelRatio) | 0;
        var halfMinDecorationHeight = (minDecorationHeight / 2) | 0;
        var canvasCtx = this._domNode.domNode.getContext('2d');
        if (this._settings.backgroundColor === null) {
            canvasCtx.clearRect(0, 0, canvasWidth, canvasHeight);
        }
        else {
            canvasCtx.fillStyle = this._settings.backgroundColor;
            canvasCtx.fillRect(0, 0, canvasWidth, canvasHeight);
        }
        var x = this._settings.x;
        var w = this._settings.w;
        // Avoid flickering by always rendering the colors in the same order
        // colors that don't use transparency will be sorted last (they start with #)
        var colors = Object.keys(decorations);
        colors.sort();
        for (var cIndex = 0, cLen = colors.length; cIndex < cLen; cIndex++) {
            var color = colors[cIndex];
            var colorDecorations = decorations[color];
            canvasCtx.fillStyle = color;
            var prevLane = 0;
            var prevY1 = 0;
            var prevY2 = 0;
            for (var i = 0, len = colorDecorations.length; i < len; i++) {
                var lane = colorDecorations[3 * i];
                var startLineNumber = colorDecorations[3 * i + 1];
                var endLineNumber = colorDecorations[3 * i + 2];
                var y1 = (viewLayout.getVerticalOffsetForLineNumber(startLineNumber) * heightRatio) | 0;
                var y2 = ((viewLayout.getVerticalOffsetForLineNumber(endLineNumber) + lineHeight) * heightRatio) | 0;
                var height = y2 - y1;
                if (height < minDecorationHeight) {
                    var yCenter = ((y1 + y2) / 2) | 0;
                    if (yCenter < halfMinDecorationHeight) {
                        yCenter = halfMinDecorationHeight;
                    }
                    else if (yCenter + halfMinDecorationHeight > canvasHeight) {
                        yCenter = canvasHeight - halfMinDecorationHeight;
                    }
                    y1 = yCenter - halfMinDecorationHeight;
                    y2 = yCenter + halfMinDecorationHeight;
                }
                if (y1 > prevY2 + 1 || lane !== prevLane) {
                    // flush prev
                    if (i !== 0) {
                        canvasCtx.fillRect(x[prevLane], prevY1, w[prevLane], prevY2 - prevY1);
                    }
                    prevLane = lane;
                    prevY1 = y1;
                    prevY2 = y2;
                }
                else {
                    // merge into prev
                    if (y2 > prevY2) {
                        prevY2 = y2;
                    }
                }
            }
            canvasCtx.fillRect(x[prevLane], prevY1, w[prevLane], prevY2 - prevY1);
        }
        // Draw cursors
        if (!this._settings.hideCursor) {
            var cursorHeight = (2 * this._settings.pixelRatio) | 0;
            var halfCursorHeight = (cursorHeight / 2) | 0;
            var cursorX = this._settings.x[7 /* Full */];
            var cursorW = this._settings.w[7 /* Full */];
            canvasCtx.fillStyle = this._settings.cursorColor;
            var prevY1 = -100;
            var prevY2 = -100;
            for (var i = 0, len = this._cursorPositions.length; i < len; i++) {
                var cursor = this._cursorPositions[i];
                var yCenter = (viewLayout.getVerticalOffsetForLineNumber(cursor.lineNumber) * heightRatio) | 0;
                if (yCenter < halfCursorHeight) {
                    yCenter = halfCursorHeight;
                }
                else if (yCenter + halfCursorHeight > canvasHeight) {
                    yCenter = canvasHeight - halfCursorHeight;
                }
                var y1 = yCenter - halfCursorHeight;
                var y2 = y1 + cursorHeight;
                if (y1 > prevY2 + 1) {
                    // flush prev
                    if (i !== 0) {
                        canvasCtx.fillRect(cursorX, prevY1, cursorW, prevY2 - prevY1);
                    }
                    prevY1 = y1;
                    prevY2 = y2;
                }
                else {
                    // merge into prev
                    if (y2 > prevY2) {
                        prevY2 = y2;
                    }
                }
            }
            canvasCtx.fillRect(cursorX, prevY1, cursorW, prevY2 - prevY1);
        }
        if (this._settings.renderBorder && this._settings.borderColor && this._settings.overviewRulerLanes > 0) {
            canvasCtx.beginPath();
            canvasCtx.lineWidth = 1;
            canvasCtx.strokeStyle = this._settings.borderColor;
            canvasCtx.moveTo(0, 0);
            canvasCtx.lineTo(0, canvasHeight);
            canvasCtx.stroke();
            canvasCtx.moveTo(0, 0);
            canvasCtx.lineTo(canvasWidth, 0);
            canvasCtx.stroke();
        }
    };
    return DecorationsOverviewRuler;
}(ViewPart));

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var ColorZone = /** @class */ (function () {
    function ColorZone(from, to, colorId) {
        this.from = from | 0;
        this.to = to | 0;
        this.colorId = colorId | 0;
    }
    ColorZone.compare = function (a, b) {
        if (a.colorId === b.colorId) {
            if (a.from === b.from) {
                return a.to - b.to;
            }
            return a.from - b.from;
        }
        return a.colorId - b.colorId;
    };
    return ColorZone;
}());
/**
 * A zone in the overview ruler
 */
var OverviewRulerZone = /** @class */ (function () {
    function OverviewRulerZone(startLineNumber, endLineNumber, color) {
        this.startLineNumber = startLineNumber;
        this.endLineNumber = endLineNumber;
        this.color = color;
        this._colorZone = null;
    }
    OverviewRulerZone.compare = function (a, b) {
        if (a.color === b.color) {
            if (a.startLineNumber === b.startLineNumber) {
                return a.endLineNumber - b.endLineNumber;
            }
            return a.startLineNumber - b.startLineNumber;
        }
        return a.color < b.color ? -1 : 1;
    };
    OverviewRulerZone.prototype.setColorZone = function (colorZone) {
        this._colorZone = colorZone;
    };
    OverviewRulerZone.prototype.getColorZones = function () {
        return this._colorZone;
    };
    return OverviewRulerZone;
}());
var OverviewZoneManager = /** @class */ (function () {
    function OverviewZoneManager(getVerticalOffsetForLine) {
        this._getVerticalOffsetForLine = getVerticalOffsetForLine;
        this._zones = [];
        this._colorZonesInvalid = false;
        this._lineHeight = 0;
        this._domWidth = 0;
        this._domHeight = 0;
        this._outerHeight = 0;
        this._pixelRatio = 1;
        this._lastAssignedId = 0;
        this._color2Id = Object.create(null);
        this._id2Color = [];
    }
    OverviewZoneManager.prototype.getId2Color = function () {
        return this._id2Color;
    };
    OverviewZoneManager.prototype.setZones = function (newZones) {
        this._zones = newZones;
        this._zones.sort(OverviewRulerZone.compare);
    };
    OverviewZoneManager.prototype.setLineHeight = function (lineHeight) {
        if (this._lineHeight === lineHeight) {
            return false;
        }
        this._lineHeight = lineHeight;
        this._colorZonesInvalid = true;
        return true;
    };
    OverviewZoneManager.prototype.setPixelRatio = function (pixelRatio) {
        this._pixelRatio = pixelRatio;
        this._colorZonesInvalid = true;
    };
    OverviewZoneManager.prototype.getDOMWidth = function () {
        return this._domWidth;
    };
    OverviewZoneManager.prototype.getCanvasWidth = function () {
        return this._domWidth * this._pixelRatio;
    };
    OverviewZoneManager.prototype.setDOMWidth = function (width) {
        if (this._domWidth === width) {
            return false;
        }
        this._domWidth = width;
        this._colorZonesInvalid = true;
        return true;
    };
    OverviewZoneManager.prototype.getDOMHeight = function () {
        return this._domHeight;
    };
    OverviewZoneManager.prototype.getCanvasHeight = function () {
        return this._domHeight * this._pixelRatio;
    };
    OverviewZoneManager.prototype.setDOMHeight = function (height) {
        if (this._domHeight === height) {
            return false;
        }
        this._domHeight = height;
        this._colorZonesInvalid = true;
        return true;
    };
    OverviewZoneManager.prototype.getOuterHeight = function () {
        return this._outerHeight;
    };
    OverviewZoneManager.prototype.setOuterHeight = function (outerHeight) {
        if (this._outerHeight === outerHeight) {
            return false;
        }
        this._outerHeight = outerHeight;
        this._colorZonesInvalid = true;
        return true;
    };
    OverviewZoneManager.prototype.resolveColorZones = function () {
        var colorZonesInvalid = this._colorZonesInvalid;
        var lineHeight = Math.floor(this._lineHeight); // @perf
        var totalHeight = Math.floor(this.getCanvasHeight()); // @perf
        var outerHeight = Math.floor(this._outerHeight); // @perf
        var heightRatio = totalHeight / outerHeight;
        var halfMinimumHeight = Math.floor(4 /* MINIMUM_HEIGHT */ * this._pixelRatio / 2);
        var allColorZones = [];
        for (var i = 0, len = this._zones.length; i < len; i++) {
            var zone = this._zones[i];
            if (!colorZonesInvalid) {
                var colorZone_1 = zone.getColorZones();
                if (colorZone_1) {
                    allColorZones.push(colorZone_1);
                    continue;
                }
            }
            var y1 = Math.floor(heightRatio * (this._getVerticalOffsetForLine(zone.startLineNumber)));
            var y2 = Math.floor(heightRatio * (this._getVerticalOffsetForLine(zone.endLineNumber) + lineHeight));
            var ycenter = Math.floor((y1 + y2) / 2);
            var halfHeight = (y2 - ycenter);
            if (halfHeight < halfMinimumHeight) {
                halfHeight = halfMinimumHeight;
            }
            if (ycenter - halfHeight < 0) {
                ycenter = halfHeight;
            }
            if (ycenter + halfHeight > totalHeight) {
                ycenter = totalHeight - halfHeight;
            }
            var color = zone.color;
            var colorId = this._color2Id[color];
            if (!colorId) {
                colorId = (++this._lastAssignedId);
                this._color2Id[color] = colorId;
                this._id2Color[colorId] = color;
            }
            var colorZone = new ColorZone(ycenter - halfHeight, ycenter + halfHeight, colorId);
            zone.setColorZone(colorZone);
            allColorZones.push(colorZone);
        }
        this._colorZonesInvalid = false;
        allColorZones.sort(ColorZone.compare);
        return allColorZones;
    };
    return OverviewZoneManager;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$N = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var OverviewRuler = /** @class */ (function (_super) {
    __extends$N(OverviewRuler, _super);
    function OverviewRuler(context, cssClassName) {
        var _this = _super.call(this) || this;
        _this._context = context;
        _this._domNode = createFastDomNode(document.createElement('canvas'));
        _this._domNode.setClassName(cssClassName);
        _this._domNode.setPosition('absolute');
        _this._domNode.setLayerHinting(true);
        _this._zoneManager = new OverviewZoneManager(function (lineNumber) { return _this._context.viewLayout.getVerticalOffsetForLineNumber(lineNumber); });
        _this._zoneManager.setDOMWidth(0);
        _this._zoneManager.setDOMHeight(0);
        _this._zoneManager.setOuterHeight(_this._context.viewLayout.getScrollHeight());
        _this._zoneManager.setLineHeight(_this._context.configuration.editor.lineHeight);
        _this._zoneManager.setPixelRatio(_this._context.configuration.editor.pixelRatio);
        _this._context.addEventHandler(_this);
        return _this;
    }
    OverviewRuler.prototype.dispose = function () {
        this._context.removeEventHandler(this);
        this._zoneManager = null;
        _super.prototype.dispose.call(this);
    };
    // ---- begin view event handlers
    OverviewRuler.prototype.onConfigurationChanged = function (e) {
        if (e.lineHeight) {
            this._zoneManager.setLineHeight(this._context.configuration.editor.lineHeight);
            this._render();
        }
        if (e.pixelRatio) {
            this._zoneManager.setPixelRatio(this._context.configuration.editor.pixelRatio);
            this._domNode.setWidth(this._zoneManager.getDOMWidth());
            this._domNode.setHeight(this._zoneManager.getDOMHeight());
            this._domNode.domNode.width = this._zoneManager.getCanvasWidth();
            this._domNode.domNode.height = this._zoneManager.getCanvasHeight();
            this._render();
        }
        return true;
    };
    OverviewRuler.prototype.onFlushed = function (e) {
        this._render();
        return true;
    };
    OverviewRuler.prototype.onScrollChanged = function (e) {
        if (e.scrollHeightChanged) {
            this._zoneManager.setOuterHeight(e.scrollHeight);
            this._render();
        }
        return true;
    };
    OverviewRuler.prototype.onZonesChanged = function (e) {
        this._render();
        return true;
    };
    // ---- end view event handlers
    OverviewRuler.prototype.getDomNode = function () {
        return this._domNode.domNode;
    };
    OverviewRuler.prototype.setLayout = function (position) {
        this._domNode.setTop(position.top);
        this._domNode.setRight(position.right);
        var hasChanged = false;
        hasChanged = this._zoneManager.setDOMWidth(position.width) || hasChanged;
        hasChanged = this._zoneManager.setDOMHeight(position.height) || hasChanged;
        if (hasChanged) {
            this._domNode.setWidth(this._zoneManager.getDOMWidth());
            this._domNode.setHeight(this._zoneManager.getDOMHeight());
            this._domNode.domNode.width = this._zoneManager.getCanvasWidth();
            this._domNode.domNode.height = this._zoneManager.getCanvasHeight();
            this._render();
        }
    };
    OverviewRuler.prototype.setZones = function (zones) {
        this._zoneManager.setZones(zones);
        this._render();
    };
    OverviewRuler.prototype._render = function () {
        if (this._zoneManager.getOuterHeight() === 0) {
            return false;
        }
        var width = this._zoneManager.getCanvasWidth();
        var height = this._zoneManager.getCanvasHeight();
        var colorZones = this._zoneManager.resolveColorZones();
        var id2Color = this._zoneManager.getId2Color();
        var ctx = this._domNode.domNode.getContext('2d');
        ctx.clearRect(0, 0, width, height);
        if (colorZones.length > 0) {
            this._renderOneLane(ctx, colorZones, id2Color, width);
        }
        return true;
    };
    OverviewRuler.prototype._renderOneLane = function (ctx, colorZones, id2Color, width) {
        var currentColorId = 0;
        var currentFrom = 0;
        var currentTo = 0;
        for (var i = 0, len = colorZones.length; i < len; i++) {
            var zone = colorZones[i];
            var zoneColorId = zone.colorId;
            var zoneFrom = zone.from;
            var zoneTo = zone.to;
            if (zoneColorId !== currentColorId) {
                ctx.fillRect(0, currentFrom, width, currentTo - currentFrom);
                currentColorId = zoneColorId;
                ctx.fillStyle = id2Color[currentColorId];
                currentFrom = zoneFrom;
                currentTo = zoneTo;
            }
            else {
                if (currentTo >= zoneFrom) {
                    currentTo = Math.max(currentTo, zoneTo);
                }
                else {
                    ctx.fillRect(0, currentFrom, width, currentTo - currentFrom);
                    currentFrom = zoneFrom;
                    currentTo = zoneTo;
                }
            }
        }
        ctx.fillRect(0, currentFrom, width, currentTo - currentFrom);
    };
    return OverviewRuler;
}(ViewEventHandler));

const css$e = "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n.monaco-editor .view-ruler {\n\tposition: absolute;\n\ttop: 0;\n}";
  const element$e = ((css, src) => {
if (typeof document !== 'object')
console.info(`Skipped loading "${src}"`);
try {
const id = src
  .replace(/\.css.*$/, '')
  .replace(/[\\:]/g, '/')
  .replace(/[^\w\/]+/g, '');
return (
  document.querySelector(`style[id="${id}"]`) ||
  document.head.appendChild(
    Object.assign(document.createElement('style'), {
      id,
      textContent: `${css}\n\n /* sourceURL=${src} */`,
    }),
  )
);
} catch (exception) {
console.warn(`Failed load "${src}"`, exception);
}
})(css$e, "…monaco-editor/esm/vs/editor/browser/viewParts/rulers/rulers.css");
  //@ sourceURL=/Users/daflair/Projects/packages/monaco-es/node_modules/monaco-editor/esm/vs/editor/browser/viewParts/rulers/rulers.css

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$O = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var Rulers = /** @class */ (function (_super) {
    __extends$O(Rulers, _super);
    function Rulers(context) {
        var _this = _super.call(this, context) || this;
        _this.domNode = createFastDomNode(document.createElement('div'));
        _this.domNode.setAttribute('role', 'presentation');
        _this.domNode.setAttribute('aria-hidden', 'true');
        _this.domNode.setClassName('view-rulers');
        _this._renderedRulers = [];
        _this._rulers = _this._context.configuration.editor.viewInfo.rulers;
        _this._typicalHalfwidthCharacterWidth = _this._context.configuration.editor.fontInfo.typicalHalfwidthCharacterWidth;
        return _this;
    }
    Rulers.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
    };
    // --- begin event handlers
    Rulers.prototype.onConfigurationChanged = function (e) {
        if (e.viewInfo || e.layoutInfo || e.fontInfo) {
            this._rulers = this._context.configuration.editor.viewInfo.rulers;
            this._typicalHalfwidthCharacterWidth = this._context.configuration.editor.fontInfo.typicalHalfwidthCharacterWidth;
            return true;
        }
        return false;
    };
    Rulers.prototype.onScrollChanged = function (e) {
        return e.scrollHeightChanged;
    };
    // --- end event handlers
    Rulers.prototype.prepareRender = function (ctx) {
        // Nothing to read
    };
    Rulers.prototype._ensureRulersCount = function () {
        var currentCount = this._renderedRulers.length;
        var desiredCount = this._rulers.length;
        if (currentCount === desiredCount) {
            // Nothing to do
            return;
        }
        if (currentCount < desiredCount) {
            var rulerWidth = this._context.model.getTabSize();
            var addCount = desiredCount - currentCount;
            while (addCount > 0) {
                var node = createFastDomNode(document.createElement('div'));
                node.setClassName('view-ruler');
                node.setWidth(rulerWidth);
                this.domNode.appendChild(node);
                this._renderedRulers.push(node);
                addCount--;
            }
            return;
        }
        var removeCount = currentCount - desiredCount;
        while (removeCount > 0) {
            var node = this._renderedRulers.pop();
            this.domNode.removeChild(node);
            removeCount--;
        }
    };
    Rulers.prototype.render = function (ctx) {
        this._ensureRulersCount();
        for (var i = 0, len = this._rulers.length; i < len; i++) {
            var node = this._renderedRulers[i];
            node.setHeight(Math.min(ctx.scrollHeight, 1000000));
            node.setLeft(this._rulers[i] * this._typicalHalfwidthCharacterWidth);
        }
    };
    return Rulers;
}(ViewPart));
registerThemingParticipant(function (theme, collector) {
    var rulerColor = theme.getColor(editorRuler);
    if (rulerColor) {
        collector.addRule(".monaco-editor .view-ruler { box-shadow: 1px 0 0 0 " + rulerColor + " inset; }");
    }
});

const css$f = "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n.monaco-editor .scroll-decoration {\n\tposition: absolute;\n\ttop: 0;\n\tleft: 0;\n\theight: 6px;\n}";
  const element$f = ((css, src) => {
if (typeof document !== 'object')
console.info(`Skipped loading "${src}"`);
try {
const id = src
  .replace(/\.css.*$/, '')
  .replace(/[\\:]/g, '/')
  .replace(/[^\w\/]+/g, '');
return (
  document.querySelector(`style[id="${id}"]`) ||
  document.head.appendChild(
    Object.assign(document.createElement('style'), {
      id,
      textContent: `${css}\n\n /* sourceURL=${src} */`,
    }),
  )
);
} catch (exception) {
console.warn(`Failed load "${src}"`, exception);
}
})(css$f, "…monaco-editor/esm/vs/editor/browser/viewParts/scrollDecoration/scrollDecoration.css");
  //@ sourceURL=/Users/daflair/Projects/packages/monaco-es/node_modules/monaco-editor/esm/vs/editor/browser/viewParts/scrollDecoration/scrollDecoration.css

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$P = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var ScrollDecorationViewPart = /** @class */ (function (_super) {
    __extends$P(ScrollDecorationViewPart, _super);
    function ScrollDecorationViewPart(context) {
        var _this = _super.call(this, context) || this;
        _this._scrollTop = 0;
        _this._width = 0;
        _this._updateWidth();
        _this._shouldShow = false;
        _this._useShadows = _this._context.configuration.editor.viewInfo.scrollbar.useShadows;
        _this._domNode = createFastDomNode(document.createElement('div'));
        _this._domNode.setAttribute('role', 'presentation');
        _this._domNode.setAttribute('aria-hidden', 'true');
        return _this;
    }
    ScrollDecorationViewPart.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
    };
    ScrollDecorationViewPart.prototype._updateShouldShow = function () {
        var newShouldShow = (this._useShadows && this._scrollTop > 0);
        if (this._shouldShow !== newShouldShow) {
            this._shouldShow = newShouldShow;
            return true;
        }
        return false;
    };
    ScrollDecorationViewPart.prototype.getDomNode = function () {
        return this._domNode;
    };
    ScrollDecorationViewPart.prototype._updateWidth = function () {
        var layoutInfo = this._context.configuration.editor.layoutInfo;
        var newWidth = 0;
        if (layoutInfo.renderMinimap === 0 || (layoutInfo.minimapWidth > 0 && layoutInfo.minimapLeft === 0)) {
            newWidth = layoutInfo.width;
        }
        else {
            newWidth = layoutInfo.width - layoutInfo.minimapWidth - layoutInfo.verticalScrollbarWidth;
        }
        if (this._width !== newWidth) {
            this._width = newWidth;
            return true;
        }
        return false;
    };
    // --- begin event handlers
    ScrollDecorationViewPart.prototype.onConfigurationChanged = function (e) {
        var shouldRender = false;
        if (e.viewInfo) {
            this._useShadows = this._context.configuration.editor.viewInfo.scrollbar.useShadows;
        }
        if (e.layoutInfo) {
            shouldRender = this._updateWidth();
        }
        return this._updateShouldShow() || shouldRender;
    };
    ScrollDecorationViewPart.prototype.onScrollChanged = function (e) {
        this._scrollTop = e.scrollTop;
        return this._updateShouldShow();
    };
    // --- end event handlers
    ScrollDecorationViewPart.prototype.prepareRender = function (ctx) {
        // Nothing to read
    };
    ScrollDecorationViewPart.prototype.render = function (ctx) {
        this._domNode.setWidth(this._width);
        this._domNode.setClassName(this._shouldShow ? 'scroll-decoration' : '');
    };
    return ScrollDecorationViewPart;
}(ViewPart));
registerThemingParticipant(function (theme, collector) {
    var shadow = theme.getColor(scrollbarShadow);
    if (shadow) {
        collector.addRule(".monaco-editor .scroll-decoration { box-shadow: " + shadow + " 0 6px 6px -6px inset; }");
    }
});

const css$g = "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n/*\n\tKeeping name short for faster parsing.\n\tcslr = core selections layer rendering (div)\n*/\n.monaco-editor .lines-content .cslr {\n\tposition: absolute;\n}\n\n.monaco-editor\t\t\t.top-left-radius\t\t{ border-top-left-radius: 3px; }\n.monaco-editor\t\t\t.bottom-left-radius\t\t{ border-bottom-left-radius: 3px; }\n.monaco-editor\t\t\t.top-right-radius\t\t{ border-top-right-radius: 3px; }\n.monaco-editor\t\t\t.bottom-right-radius\t{ border-bottom-right-radius: 3px; }\n\n.monaco-editor.hc-black .top-left-radius\t\t{ border-top-left-radius: 0; }\n.monaco-editor.hc-black .bottom-left-radius\t\t{ border-bottom-left-radius: 0; }\n.monaco-editor.hc-black .top-right-radius\t\t{ border-top-right-radius: 0; }\n.monaco-editor.hc-black .bottom-right-radius\t{ border-bottom-right-radius: 0; }\n";
  const element$g = ((css, src) => {
if (typeof document !== 'object')
console.info(`Skipped loading "${src}"`);
try {
const id = src
  .replace(/\.css.*$/, '')
  .replace(/[\\:]/g, '/')
  .replace(/[^\w\/]+/g, '');
return (
  document.querySelector(`style[id="${id}"]`) ||
  document.head.appendChild(
    Object.assign(document.createElement('style'), {
      id,
      textContent: `${css}\n\n /* sourceURL=${src} */`,
    }),
  )
);
} catch (exception) {
console.warn(`Failed load "${src}"`, exception);
}
})(css$g, "…monaco-editor/esm/vs/editor/browser/viewParts/selections/selections.css");
  //@ sourceURL=/Users/daflair/Projects/packages/monaco-es/node_modules/monaco-editor/esm/vs/editor/browser/viewParts/selections/selections.css

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$Q = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var HorizontalRangeWithStyle = /** @class */ (function () {
    function HorizontalRangeWithStyle(other) {
        this.left = other.left;
        this.width = other.width;
        this.startStyle = null;
        this.endStyle = null;
    }
    return HorizontalRangeWithStyle;
}());
var LineVisibleRangesWithStyle = /** @class */ (function () {
    function LineVisibleRangesWithStyle(lineNumber, ranges) {
        this.lineNumber = lineNumber;
        this.ranges = ranges;
    }
    return LineVisibleRangesWithStyle;
}());
function toStyledRange(item) {
    return new HorizontalRangeWithStyle(item);
}
function toStyled(item) {
    return new LineVisibleRangesWithStyle(item.lineNumber, item.ranges.map(toStyledRange));
}
// TODO@Alex: Remove this once IE11 fixes Bug #524217
// The problem in IE11 is that it does some sort of auto-zooming to accomodate for displays with different pixel density.
// Unfortunately, this auto-zooming is buggy around dealing with rounded borders
var isIEWithZoomingIssuesNearRoundedBorders = isEdgeOrIE;
var SelectionsOverlay = /** @class */ (function (_super) {
    __extends$Q(SelectionsOverlay, _super);
    function SelectionsOverlay(context) {
        var _this = _super.call(this) || this;
        _this._previousFrameVisibleRangesWithStyle = [];
        _this._context = context;
        _this._lineHeight = _this._context.configuration.editor.lineHeight;
        _this._roundedSelection = _this._context.configuration.editor.viewInfo.roundedSelection;
        _this._typicalHalfwidthCharacterWidth = _this._context.configuration.editor.fontInfo.typicalHalfwidthCharacterWidth;
        _this._selections = [];
        _this._renderResult = null;
        _this._context.addEventHandler(_this);
        return _this;
    }
    SelectionsOverlay.prototype.dispose = function () {
        this._context.removeEventHandler(this);
        this._context = null;
        this._selections = null;
        this._renderResult = null;
        _super.prototype.dispose.call(this);
    };
    // --- begin event handlers
    SelectionsOverlay.prototype.onConfigurationChanged = function (e) {
        if (e.lineHeight) {
            this._lineHeight = this._context.configuration.editor.lineHeight;
        }
        if (e.viewInfo) {
            this._roundedSelection = this._context.configuration.editor.viewInfo.roundedSelection;
        }
        if (e.fontInfo) {
            this._typicalHalfwidthCharacterWidth = this._context.configuration.editor.fontInfo.typicalHalfwidthCharacterWidth;
        }
        return true;
    };
    SelectionsOverlay.prototype.onCursorStateChanged = function (e) {
        this._selections = e.selections.slice(0);
        return true;
    };
    SelectionsOverlay.prototype.onDecorationsChanged = function (e) {
        // true for inline decorations that can end up relayouting text
        return true; //e.inlineDecorationsChanged;
    };
    SelectionsOverlay.prototype.onFlushed = function (e) {
        return true;
    };
    SelectionsOverlay.prototype.onLinesChanged = function (e) {
        return true;
    };
    SelectionsOverlay.prototype.onLinesDeleted = function (e) {
        return true;
    };
    SelectionsOverlay.prototype.onLinesInserted = function (e) {
        return true;
    };
    SelectionsOverlay.prototype.onScrollChanged = function (e) {
        return e.scrollTopChanged;
    };
    SelectionsOverlay.prototype.onZonesChanged = function (e) {
        return true;
    };
    // --- end event handlers
    SelectionsOverlay.prototype._visibleRangesHaveGaps = function (linesVisibleRanges) {
        for (var i = 0, len = linesVisibleRanges.length; i < len; i++) {
            var lineVisibleRanges = linesVisibleRanges[i];
            if (lineVisibleRanges.ranges.length > 1) {
                // There are two ranges on the same line
                return true;
            }
        }
        return false;
    };
    SelectionsOverlay.prototype._enrichVisibleRangesWithStyle = function (viewport, linesVisibleRanges, previousFrame) {
        var epsilon = this._typicalHalfwidthCharacterWidth / 4;
        var previousFrameTop = null;
        var previousFrameBottom = null;
        if (previousFrame && previousFrame.length > 0 && linesVisibleRanges.length > 0) {
            var topLineNumber = linesVisibleRanges[0].lineNumber;
            if (topLineNumber === viewport.startLineNumber) {
                for (var i = 0; !previousFrameTop && i < previousFrame.length; i++) {
                    if (previousFrame[i].lineNumber === topLineNumber) {
                        previousFrameTop = previousFrame[i].ranges[0];
                    }
                }
            }
            var bottomLineNumber = linesVisibleRanges[linesVisibleRanges.length - 1].lineNumber;
            if (bottomLineNumber === viewport.endLineNumber) {
                for (var i = previousFrame.length - 1; !previousFrameBottom && i >= 0; i--) {
                    if (previousFrame[i].lineNumber === bottomLineNumber) {
                        previousFrameBottom = previousFrame[i].ranges[0];
                    }
                }
            }
            if (previousFrameTop && !previousFrameTop.startStyle) {
                previousFrameTop = null;
            }
            if (previousFrameBottom && !previousFrameBottom.startStyle) {
                previousFrameBottom = null;
            }
        }
        for (var i = 0, len = linesVisibleRanges.length; i < len; i++) {
            // We know for a fact that there is precisely one range on each line
            var curLineRange = linesVisibleRanges[i].ranges[0];
            var curLeft = curLineRange.left;
            var curRight = curLineRange.left + curLineRange.width;
            var startStyle = {
                top: 0 /* EXTERN */,
                bottom: 0 /* EXTERN */
            };
            var endStyle = {
                top: 0 /* EXTERN */,
                bottom: 0 /* EXTERN */
            };
            if (i > 0) {
                // Look above
                var prevLeft = linesVisibleRanges[i - 1].ranges[0].left;
                var prevRight = linesVisibleRanges[i - 1].ranges[0].left + linesVisibleRanges[i - 1].ranges[0].width;
                if (abs(curLeft - prevLeft) < epsilon) {
                    startStyle.top = 2 /* FLAT */;
                }
                else if (curLeft > prevLeft) {
                    startStyle.top = 1 /* INTERN */;
                }
                if (abs(curRight - prevRight) < epsilon) {
                    endStyle.top = 2 /* FLAT */;
                }
                else if (prevLeft < curRight && curRight < prevRight) {
                    endStyle.top = 1 /* INTERN */;
                }
            }
            else if (previousFrameTop) {
                // Accept some hick-ups near the viewport edges to save on repaints
                startStyle.top = previousFrameTop.startStyle.top;
                endStyle.top = previousFrameTop.endStyle.top;
            }
            if (i + 1 < len) {
                // Look below
                var nextLeft = linesVisibleRanges[i + 1].ranges[0].left;
                var nextRight = linesVisibleRanges[i + 1].ranges[0].left + linesVisibleRanges[i + 1].ranges[0].width;
                if (abs(curLeft - nextLeft) < epsilon) {
                    startStyle.bottom = 2 /* FLAT */;
                }
                else if (nextLeft < curLeft && curLeft < nextRight) {
                    startStyle.bottom = 1 /* INTERN */;
                }
                if (abs(curRight - nextRight) < epsilon) {
                    endStyle.bottom = 2 /* FLAT */;
                }
                else if (curRight < nextRight) {
                    endStyle.bottom = 1 /* INTERN */;
                }
            }
            else if (previousFrameBottom) {
                // Accept some hick-ups near the viewport edges to save on repaints
                startStyle.bottom = previousFrameBottom.startStyle.bottom;
                endStyle.bottom = previousFrameBottom.endStyle.bottom;
            }
            curLineRange.startStyle = startStyle;
            curLineRange.endStyle = endStyle;
        }
    };
    SelectionsOverlay.prototype._getVisibleRangesWithStyle = function (selection, ctx, previousFrame) {
        var _linesVisibleRanges = ctx.linesVisibleRangesForRange(selection, true) || [];
        var linesVisibleRanges = _linesVisibleRanges.map(toStyled);
        var visibleRangesHaveGaps = this._visibleRangesHaveGaps(linesVisibleRanges);
        if (!isIEWithZoomingIssuesNearRoundedBorders && !visibleRangesHaveGaps && this._roundedSelection) {
            this._enrichVisibleRangesWithStyle(ctx.visibleRange, linesVisibleRanges, previousFrame);
        }
        // The visible ranges are sorted TOP-BOTTOM and LEFT-RIGHT
        return linesVisibleRanges;
    };
    SelectionsOverlay.prototype._createSelectionPiece = function (top, height, className, left, width) {
        return ('<div class="cslr '
            + className
            + '" style="top:'
            + top.toString()
            + 'px;left:'
            + left.toString()
            + 'px;width:'
            + width.toString()
            + 'px;height:'
            + height
            + 'px;"></div>');
    };
    SelectionsOverlay.prototype._actualRenderOneSelection = function (output2, visibleStartLineNumber, hasMultipleSelections, visibleRanges) {
        var visibleRangesHaveStyle = (visibleRanges.length > 0 && visibleRanges[0].ranges[0].startStyle);
        var fullLineHeight = (this._lineHeight).toString();
        var reducedLineHeight = (this._lineHeight - 1).toString();
        var firstLineNumber = (visibleRanges.length > 0 ? visibleRanges[0].lineNumber : 0);
        var lastLineNumber = (visibleRanges.length > 0 ? visibleRanges[visibleRanges.length - 1].lineNumber : 0);
        for (var i = 0, len = visibleRanges.length; i < len; i++) {
            var lineVisibleRanges = visibleRanges[i];
            var lineNumber = lineVisibleRanges.lineNumber;
            var lineIndex = lineNumber - visibleStartLineNumber;
            var lineHeight = hasMultipleSelections ? (lineNumber === lastLineNumber || lineNumber === firstLineNumber ? reducedLineHeight : fullLineHeight) : fullLineHeight;
            var top_1 = hasMultipleSelections ? (lineNumber === firstLineNumber ? 1 : 0) : 0;
            var lineOutput = '';
            for (var j = 0, lenJ = lineVisibleRanges.ranges.length; j < lenJ; j++) {
                var visibleRange = lineVisibleRanges.ranges[j];
                if (visibleRangesHaveStyle) {
                    if (visibleRange.startStyle.top === 1 /* INTERN */ || visibleRange.startStyle.bottom === 1 /* INTERN */) {
                        // Reverse rounded corner to the left
                        // First comes the selection (blue layer)
                        lineOutput += this._createSelectionPiece(top_1, lineHeight, SelectionsOverlay.SELECTION_CLASS_NAME, visibleRange.left - SelectionsOverlay.ROUNDED_PIECE_WIDTH, SelectionsOverlay.ROUNDED_PIECE_WIDTH);
                        // Second comes the background (white layer) with inverse border radius
                        var className_1 = SelectionsOverlay.EDITOR_BACKGROUND_CLASS_NAME;
                        if (visibleRange.startStyle.top === 1 /* INTERN */) {
                            className_1 += ' ' + SelectionsOverlay.SELECTION_TOP_RIGHT;
                        }
                        if (visibleRange.startStyle.bottom === 1 /* INTERN */) {
                            className_1 += ' ' + SelectionsOverlay.SELECTION_BOTTOM_RIGHT;
                        }
                        lineOutput += this._createSelectionPiece(top_1, lineHeight, className_1, visibleRange.left - SelectionsOverlay.ROUNDED_PIECE_WIDTH, SelectionsOverlay.ROUNDED_PIECE_WIDTH);
                    }
                    if (visibleRange.endStyle.top === 1 /* INTERN */ || visibleRange.endStyle.bottom === 1 /* INTERN */) {
                        // Reverse rounded corner to the right
                        // First comes the selection (blue layer)
                        lineOutput += this._createSelectionPiece(top_1, lineHeight, SelectionsOverlay.SELECTION_CLASS_NAME, visibleRange.left + visibleRange.width, SelectionsOverlay.ROUNDED_PIECE_WIDTH);
                        // Second comes the background (white layer) with inverse border radius
                        var className_2 = SelectionsOverlay.EDITOR_BACKGROUND_CLASS_NAME;
                        if (visibleRange.endStyle.top === 1 /* INTERN */) {
                            className_2 += ' ' + SelectionsOverlay.SELECTION_TOP_LEFT;
                        }
                        if (visibleRange.endStyle.bottom === 1 /* INTERN */) {
                            className_2 += ' ' + SelectionsOverlay.SELECTION_BOTTOM_LEFT;
                        }
                        lineOutput += this._createSelectionPiece(top_1, lineHeight, className_2, visibleRange.left + visibleRange.width, SelectionsOverlay.ROUNDED_PIECE_WIDTH);
                    }
                }
                var className = SelectionsOverlay.SELECTION_CLASS_NAME;
                if (visibleRangesHaveStyle) {
                    if (visibleRange.startStyle.top === 0 /* EXTERN */) {
                        className += ' ' + SelectionsOverlay.SELECTION_TOP_LEFT;
                    }
                    if (visibleRange.startStyle.bottom === 0 /* EXTERN */) {
                        className += ' ' + SelectionsOverlay.SELECTION_BOTTOM_LEFT;
                    }
                    if (visibleRange.endStyle.top === 0 /* EXTERN */) {
                        className += ' ' + SelectionsOverlay.SELECTION_TOP_RIGHT;
                    }
                    if (visibleRange.endStyle.bottom === 0 /* EXTERN */) {
                        className += ' ' + SelectionsOverlay.SELECTION_BOTTOM_RIGHT;
                    }
                }
                lineOutput += this._createSelectionPiece(top_1, lineHeight, className, visibleRange.left, visibleRange.width);
            }
            output2[lineIndex] += lineOutput;
        }
    };
    SelectionsOverlay.prototype.prepareRender = function (ctx) {
        var output = [];
        var visibleStartLineNumber = ctx.visibleRange.startLineNumber;
        var visibleEndLineNumber = ctx.visibleRange.endLineNumber;
        for (var lineNumber = visibleStartLineNumber; lineNumber <= visibleEndLineNumber; lineNumber++) {
            var lineIndex = lineNumber - visibleStartLineNumber;
            output[lineIndex] = '';
        }
        var thisFrameVisibleRangesWithStyle = [];
        for (var i = 0, len = this._selections.length; i < len; i++) {
            var selection = this._selections[i];
            if (selection.isEmpty()) {
                thisFrameVisibleRangesWithStyle[i] = null;
                continue;
            }
            var visibleRangesWithStyle = this._getVisibleRangesWithStyle(selection, ctx, this._previousFrameVisibleRangesWithStyle[i]);
            thisFrameVisibleRangesWithStyle[i] = visibleRangesWithStyle;
            this._actualRenderOneSelection(output, visibleStartLineNumber, this._selections.length > 1, visibleRangesWithStyle);
        }
        this._previousFrameVisibleRangesWithStyle = thisFrameVisibleRangesWithStyle;
        this._renderResult = output;
    };
    SelectionsOverlay.prototype.render = function (startLineNumber, lineNumber) {
        if (!this._renderResult) {
            return '';
        }
        var lineIndex = lineNumber - startLineNumber;
        if (lineIndex < 0 || lineIndex >= this._renderResult.length) {
            return '';
        }
        return this._renderResult[lineIndex];
    };
    SelectionsOverlay.SELECTION_CLASS_NAME = 'selected-text';
    SelectionsOverlay.SELECTION_TOP_LEFT = 'top-left-radius';
    SelectionsOverlay.SELECTION_BOTTOM_LEFT = 'bottom-left-radius';
    SelectionsOverlay.SELECTION_TOP_RIGHT = 'top-right-radius';
    SelectionsOverlay.SELECTION_BOTTOM_RIGHT = 'bottom-right-radius';
    SelectionsOverlay.EDITOR_BACKGROUND_CLASS_NAME = 'monaco-editor-background';
    SelectionsOverlay.ROUNDED_PIECE_WIDTH = 10;
    return SelectionsOverlay;
}(DynamicViewOverlay));
registerThemingParticipant(function (theme, collector) {
    var editorSelectionColor = theme.getColor(editorSelectionBackground);
    if (editorSelectionColor) {
        collector.addRule(".monaco-editor .focused .selected-text { background-color: " + editorSelectionColor + "; }");
    }
    var editorInactiveSelectionColor = theme.getColor(editorInactiveSelection);
    if (editorInactiveSelectionColor) {
        collector.addRule(".monaco-editor .selected-text { background-color: " + editorInactiveSelectionColor + "; }");
    }
    var editorSelectionForegroundColor = theme.getColor(editorSelectionForeground);
    if (editorSelectionForegroundColor) {
        collector.addRule(".monaco-editor .view-line span.inline-selected-text { color: " + editorSelectionForegroundColor + "; }");
    }
});
function abs(n) {
    return n < 0 ? -n : n;
}

const css$h = "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n.monaco-editor .cursors-layer {\n\tposition: absolute;\n\ttop: 0;\n}\n\n.monaco-editor .cursors-layer > .cursor {\n\tposition: absolute;\n\tcursor: text;\n\toverflow: hidden;\n}\n\n/* -- block-outline-style -- */\n.monaco-editor .cursors-layer.cursor-block-outline-style > .cursor {\n\tbox-sizing: border-box;\n\tbackground: transparent !important;\n\tborder-style: solid;\n\tborder-width: 1px;\n}\n\n/* -- underline-style -- */\n.monaco-editor .cursors-layer.cursor-underline-style > .cursor {\n\tborder-bottom-width: 2px;\n\tborder-bottom-style: solid;\n\tbackground: transparent !important;\n\tbox-sizing: border-box;\n}\n\n/* -- underline-thin-style -- */\n.monaco-editor .cursors-layer.cursor-underline-thin-style > .cursor {\n\tborder-bottom-width: 1px;\n\tborder-bottom-style: solid;\n\tbackground: transparent !important;\n\tbox-sizing: border-box;\n}\n\n@keyframes monaco-cursor-smooth {\n\t0%,\n\t20% {\n\t\topacity: 1;\n\t}\n\t60%,\n\t100% {\n\t\topacity: 0;\n\t}\n}\n\n@keyframes monaco-cursor-phase {\n\t0%,\n\t20% {\n\t\topacity: 1;\n\t}\n\t90%,\n\t100% {\n\t\topacity: 0;\n\t}\n}\n\n@keyframes monaco-cursor-expand {\n\t0%,\n\t20% {\n\t\ttransform: scaleY(1);\n\t}\n\t80%,\n\t100% {\n\t\ttransform: scaleY(0);\n\t}\n}\n\n.cursor-smooth {\n\tanimation: monaco-cursor-smooth 0.5s ease-in-out 0s 20 alternate;\n}\n\n.cursor-phase {\n\tanimation: monaco-cursor-phase 0.5s ease-in-out 0s 20 alternate;\n}\n\n.cursor-expand > .cursor {\n\tanimation: monaco-cursor-expand 0.5s ease-in-out 0s 20 alternate;\n}";
  const element$h = ((css, src) => {
if (typeof document !== 'object')
console.info(`Skipped loading "${src}"`);
try {
const id = src
  .replace(/\.css.*$/, '')
  .replace(/[\\:]/g, '/')
  .replace(/[^\w\/]+/g, '');
return (
  document.querySelector(`style[id="${id}"]`) ||
  document.head.appendChild(
    Object.assign(document.createElement('style'), {
      id,
      textContent: `${css}\n\n /* sourceURL=${src} */`,
    }),
  )
);
} catch (exception) {
console.warn(`Failed load "${src}"`, exception);
}
})(css$h, "…monaco-editor/esm/vs/editor/browser/viewParts/viewCursors/viewCursors.css");
  //@ sourceURL=/Users/daflair/Projects/packages/monaco-es/node_modules/monaco-editor/esm/vs/editor/browser/viewParts/viewCursors/viewCursors.css

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var ViewCursorRenderData = /** @class */ (function () {
    function ViewCursorRenderData(top, left, width, height, textContent, textContentClassName) {
        this.top = top;
        this.left = left;
        this.width = width;
        this.height = height;
        this.textContent = textContent;
        this.textContentClassName = textContentClassName;
    }
    return ViewCursorRenderData;
}());
var ViewCursor = /** @class */ (function () {
    function ViewCursor(context) {
        this._context = context;
        this._cursorStyle = this._context.configuration.editor.viewInfo.cursorStyle;
        this._lineHeight = this._context.configuration.editor.lineHeight;
        this._typicalHalfwidthCharacterWidth = this._context.configuration.editor.fontInfo.typicalHalfwidthCharacterWidth;
        this._lineCursorWidth = Math.min(this._context.configuration.editor.viewInfo.cursorWidth, this._typicalHalfwidthCharacterWidth);
        this._isVisible = true;
        // Create the dom node
        this._domNode = createFastDomNode(document.createElement('div'));
        this._domNode.setClassName('cursor');
        this._domNode.setHeight(this._lineHeight);
        this._domNode.setTop(0);
        this._domNode.setLeft(0);
        Configuration$1.applyFontInfo(this._domNode, this._context.configuration.editor.fontInfo);
        this._domNode.setDisplay('none');
        this.updatePosition(new Position(1, 1));
        this._lastRenderedContent = '';
        this._renderData = null;
    }
    ViewCursor.prototype.getDomNode = function () {
        return this._domNode;
    };
    ViewCursor.prototype.getPosition = function () {
        return this._position;
    };
    ViewCursor.prototype.show = function () {
        if (!this._isVisible) {
            this._domNode.setVisibility('inherit');
            this._isVisible = true;
        }
    };
    ViewCursor.prototype.hide = function () {
        if (this._isVisible) {
            this._domNode.setVisibility('hidden');
            this._isVisible = false;
        }
    };
    ViewCursor.prototype.onConfigurationChanged = function (e) {
        if (e.lineHeight) {
            this._lineHeight = this._context.configuration.editor.lineHeight;
        }
        if (e.fontInfo) {
            Configuration$1.applyFontInfo(this._domNode, this._context.configuration.editor.fontInfo);
            this._typicalHalfwidthCharacterWidth = this._context.configuration.editor.fontInfo.typicalHalfwidthCharacterWidth;
        }
        if (e.viewInfo) {
            this._cursorStyle = this._context.configuration.editor.viewInfo.cursorStyle;
            this._lineCursorWidth = Math.min(this._context.configuration.editor.viewInfo.cursorWidth, this._typicalHalfwidthCharacterWidth);
        }
        return true;
    };
    ViewCursor.prototype.onCursorPositionChanged = function (position$$1) {
        this.updatePosition(position$$1);
        return true;
    };
    ViewCursor.prototype._prepareRender = function (ctx) {
        var textContent = '';
        var textContentClassName = '';
        if (this._cursorStyle === TextEditorCursorStyle.Line || this._cursorStyle === TextEditorCursorStyle.LineThin) {
            var visibleRange = ctx.visibleRangeForPosition(this._position);
            if (!visibleRange) {
                // Outside viewport
                return null;
            }
            var width_1;
            if (this._cursorStyle === TextEditorCursorStyle.Line) {
                width_1 = computeScreenAwareSize(this._lineCursorWidth > 0 ? this._lineCursorWidth : 2);
                if (width_1 > 2) {
                    var lineContent = this._context.model.getLineContent(this._position.lineNumber);
                    textContent = lineContent.charAt(this._position.column - 1);
                }
            }
            else {
                width_1 = computeScreenAwareSize(1);
            }
            var top_1 = ctx.getVerticalOffsetForLineNumber(this._position.lineNumber) - ctx.bigNumbersDelta;
            return new ViewCursorRenderData(top_1, visibleRange.left, width_1, this._lineHeight, textContent, textContentClassName);
        }
        var visibleRangeForCharacter = ctx.linesVisibleRangesForRange(new Range(this._position.lineNumber, this._position.column, this._position.lineNumber, this._position.column + 1), false);
        if (!visibleRangeForCharacter || visibleRangeForCharacter.length === 0 || visibleRangeForCharacter[0].ranges.length === 0) {
            // Outside viewport
            return null;
        }
        var range = visibleRangeForCharacter[0].ranges[0];
        var width = range.width < 1 ? this._typicalHalfwidthCharacterWidth : range.width;
        if (this._cursorStyle === TextEditorCursorStyle.Block) {
            var lineData = this._context.model.getViewLineData(this._position.lineNumber);
            textContent = lineData.content.charAt(this._position.column - 1);
            if (isHighSurrogate(lineData.content.charCodeAt(this._position.column - 1))) {
                textContent += lineData.content.charAt(this._position.column);
            }
            var tokenIndex = lineData.tokens.findTokenIndexAtOffset(this._position.column - 1);
            textContentClassName = lineData.tokens.getClassName(tokenIndex);
        }
        var top = ctx.getVerticalOffsetForLineNumber(this._position.lineNumber) - ctx.bigNumbersDelta;
        var height = this._lineHeight;
        // Underline might interfere with clicking
        if (this._cursorStyle === TextEditorCursorStyle.Underline || this._cursorStyle === TextEditorCursorStyle.UnderlineThin) {
            top += this._lineHeight - 2;
            height = 2;
        }
        return new ViewCursorRenderData(top, range.left, width, height, textContent, textContentClassName);
    };
    ViewCursor.prototype.prepareRender = function (ctx) {
        this._renderData = this._prepareRender(ctx);
    };
    ViewCursor.prototype.render = function (ctx) {
        if (!this._renderData) {
            this._domNode.setDisplay('none');
            return null;
        }
        if (this._lastRenderedContent !== this._renderData.textContent) {
            this._lastRenderedContent = this._renderData.textContent;
            this._domNode.domNode.textContent = this._lastRenderedContent;
        }
        this._domNode.setClassName('cursor ' + this._renderData.textContentClassName);
        this._domNode.setDisplay('block');
        this._domNode.setTop(this._renderData.top);
        this._domNode.setLeft(this._renderData.left);
        this._domNode.setWidth(this._renderData.width);
        this._domNode.setLineHeight(this._renderData.height);
        this._domNode.setHeight(this._renderData.height);
        return {
            domNode: this._domNode.domNode,
            position: this._position,
            contentLeft: this._renderData.left,
            height: this._renderData.height,
            width: 2
        };
    };
    ViewCursor.prototype.updatePosition = function (newPosition) {
        this._position = newPosition;
    };
    return ViewCursor;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$R = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var ViewCursors = /** @class */ (function (_super) {
    __extends$R(ViewCursors, _super);
    function ViewCursors(context) {
        var _this = _super.call(this, context) || this;
        _this._readOnly = _this._context.configuration.editor.readOnly;
        _this._cursorBlinking = _this._context.configuration.editor.viewInfo.cursorBlinking;
        _this._cursorStyle = _this._context.configuration.editor.viewInfo.cursorStyle;
        _this._selectionIsEmpty = true;
        _this._primaryCursor = new ViewCursor(_this._context);
        _this._secondaryCursors = [];
        _this._renderData = [];
        _this._domNode = createFastDomNode(document.createElement('div'));
        _this._domNode.setAttribute('role', 'presentation');
        _this._domNode.setAttribute('aria-hidden', 'true');
        _this._updateDomClassName();
        _this._domNode.appendChild(_this._primaryCursor.getDomNode());
        _this._startCursorBlinkAnimation = new TimeoutTimer();
        _this._cursorFlatBlinkInterval = new IntervalTimer();
        _this._blinkingEnabled = false;
        _this._editorHasFocus = false;
        _this._updateBlinking();
        return _this;
    }
    ViewCursors.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
        this._startCursorBlinkAnimation.dispose();
        this._cursorFlatBlinkInterval.dispose();
    };
    ViewCursors.prototype.getDomNode = function () {
        return this._domNode;
    };
    // --- begin event handlers
    ViewCursors.prototype.onConfigurationChanged = function (e) {
        if (e.readOnly) {
            this._readOnly = this._context.configuration.editor.readOnly;
        }
        if (e.viewInfo) {
            this._cursorBlinking = this._context.configuration.editor.viewInfo.cursorBlinking;
            this._cursorStyle = this._context.configuration.editor.viewInfo.cursorStyle;
        }
        this._primaryCursor.onConfigurationChanged(e);
        this._updateBlinking();
        if (e.viewInfo) {
            this._updateDomClassName();
        }
        for (var i = 0, len = this._secondaryCursors.length; i < len; i++) {
            this._secondaryCursors[i].onConfigurationChanged(e);
        }
        return true;
    };
    ViewCursors.prototype._onCursorPositionChanged = function (position, secondaryPositions) {
        this._primaryCursor.onCursorPositionChanged(position);
        this._updateBlinking();
        if (this._secondaryCursors.length < secondaryPositions.length) {
            // Create new cursors
            var addCnt = secondaryPositions.length - this._secondaryCursors.length;
            for (var i = 0; i < addCnt; i++) {
                var newCursor = new ViewCursor(this._context);
                this._domNode.domNode.insertBefore(newCursor.getDomNode().domNode, this._primaryCursor.getDomNode().domNode.nextSibling);
                this._secondaryCursors.push(newCursor);
            }
        }
        else if (this._secondaryCursors.length > secondaryPositions.length) {
            // Remove some cursors
            var removeCnt = this._secondaryCursors.length - secondaryPositions.length;
            for (var i = 0; i < removeCnt; i++) {
                this._domNode.removeChild(this._secondaryCursors[0].getDomNode());
                this._secondaryCursors.splice(0, 1);
            }
        }
        for (var i = 0; i < secondaryPositions.length; i++) {
            this._secondaryCursors[i].onCursorPositionChanged(secondaryPositions[i]);
        }
    };
    ViewCursors.prototype.onCursorStateChanged = function (e) {
        var positions = [];
        for (var i = 0, len = e.selections.length; i < len; i++) {
            positions[i] = e.selections[i].getPosition();
        }
        this._onCursorPositionChanged(positions[0], positions.slice(1));
        var selectionIsEmpty = e.selections[0].isEmpty();
        if (this._selectionIsEmpty !== selectionIsEmpty) {
            this._selectionIsEmpty = selectionIsEmpty;
            this._updateDomClassName();
        }
        return true;
    };
    ViewCursors.prototype.onDecorationsChanged = function (e) {
        // true for inline decorations that can end up relayouting text
        return true;
    };
    ViewCursors.prototype.onFlushed = function (e) {
        return true;
    };
    ViewCursors.prototype.onFocusChanged = function (e) {
        this._editorHasFocus = e.isFocused;
        this._updateBlinking();
        return false;
    };
    ViewCursors.prototype.onLinesChanged = function (e) {
        return true;
    };
    ViewCursors.prototype.onLinesDeleted = function (e) {
        return true;
    };
    ViewCursors.prototype.onLinesInserted = function (e) {
        return true;
    };
    ViewCursors.prototype.onScrollChanged = function (e) {
        return true;
    };
    ViewCursors.prototype.onTokensChanged = function (e) {
        var shouldRender = function (position) {
            for (var i = 0, len = e.ranges.length; i < len; i++) {
                if (e.ranges[i].fromLineNumber <= position.lineNumber && position.lineNumber <= e.ranges[i].toLineNumber) {
                    return true;
                }
            }
            return false;
        };
        if (shouldRender(this._primaryCursor.getPosition())) {
            return true;
        }
        for (var i = 0; i < this._secondaryCursors.length; i++) {
            if (shouldRender(this._secondaryCursors[i].getPosition())) {
                return true;
            }
        }
        return false;
    };
    ViewCursors.prototype.onZonesChanged = function (e) {
        return true;
    };
    // --- end event handlers
    // ---- blinking logic
    ViewCursors.prototype._getCursorBlinking = function () {
        if (!this._editorHasFocus) {
            return TextEditorCursorBlinkingStyle.Hidden;
        }
        if (this._readOnly) {
            return TextEditorCursorBlinkingStyle.Solid;
        }
        return this._cursorBlinking;
    };
    ViewCursors.prototype._updateBlinking = function () {
        var _this = this;
        this._startCursorBlinkAnimation.cancel();
        this._cursorFlatBlinkInterval.cancel();
        var blinkingStyle = this._getCursorBlinking();
        // hidden and solid are special as they involve no animations
        var isHidden = (blinkingStyle === TextEditorCursorBlinkingStyle.Hidden);
        var isSolid = (blinkingStyle === TextEditorCursorBlinkingStyle.Solid);
        if (isHidden) {
            this._hide();
        }
        else {
            this._show();
        }
        this._blinkingEnabled = false;
        this._updateDomClassName();
        if (!isHidden && !isSolid) {
            if (blinkingStyle === TextEditorCursorBlinkingStyle.Blink) {
                // flat blinking is handled by JavaScript to save battery life due to Chromium step timing issue https://bugs.chromium.org/p/chromium/issues/detail?id=361587
                this._cursorFlatBlinkInterval.cancelAndSet(function () {
                    if (_this._isVisible) {
                        _this._hide();
                    }
                    else {
                        _this._show();
                    }
                }, ViewCursors.BLINK_INTERVAL);
            }
            else {
                this._startCursorBlinkAnimation.setIfNotSet(function () {
                    _this._blinkingEnabled = true;
                    _this._updateDomClassName();
                }, ViewCursors.BLINK_INTERVAL);
            }
        }
    };
    // --- end blinking logic
    ViewCursors.prototype._updateDomClassName = function () {
        this._domNode.setClassName(this._getClassName());
    };
    ViewCursors.prototype._getClassName = function () {
        var result = 'cursors-layer';
        if (!this._selectionIsEmpty) {
            result += ' has-selection';
        }
        switch (this._cursorStyle) {
            case TextEditorCursorStyle.Line:
                result += ' cursor-line-style';
                break;
            case TextEditorCursorStyle.Block:
                result += ' cursor-block-style';
                break;
            case TextEditorCursorStyle.Underline:
                result += ' cursor-underline-style';
                break;
            case TextEditorCursorStyle.LineThin:
                result += ' cursor-line-thin-style';
                break;
            case TextEditorCursorStyle.BlockOutline:
                result += ' cursor-block-outline-style';
                break;
            case TextEditorCursorStyle.UnderlineThin:
                result += ' cursor-underline-thin-style';
                break;
            default:
                result += ' cursor-line-style';
        }
        if (this._blinkingEnabled) {
            switch (this._getCursorBlinking()) {
                case TextEditorCursorBlinkingStyle.Blink:
                    result += ' cursor-blink';
                    break;
                case TextEditorCursorBlinkingStyle.Smooth:
                    result += ' cursor-smooth';
                    break;
                case TextEditorCursorBlinkingStyle.Phase:
                    result += ' cursor-phase';
                    break;
                case TextEditorCursorBlinkingStyle.Expand:
                    result += ' cursor-expand';
                    break;
                case TextEditorCursorBlinkingStyle.Solid:
                    result += ' cursor-solid';
                    break;
                default:
                    result += ' cursor-solid';
            }
        }
        else {
            result += ' cursor-solid';
        }
        return result;
    };
    ViewCursors.prototype._show = function () {
        this._primaryCursor.show();
        for (var i = 0, len = this._secondaryCursors.length; i < len; i++) {
            this._secondaryCursors[i].show();
        }
        this._isVisible = true;
    };
    ViewCursors.prototype._hide = function () {
        this._primaryCursor.hide();
        for (var i = 0, len = this._secondaryCursors.length; i < len; i++) {
            this._secondaryCursors[i].hide();
        }
        this._isVisible = false;
    };
    // ---- IViewPart implementation
    ViewCursors.prototype.prepareRender = function (ctx) {
        this._primaryCursor.prepareRender(ctx);
        for (var i = 0, len = this._secondaryCursors.length; i < len; i++) {
            this._secondaryCursors[i].prepareRender(ctx);
        }
    };
    ViewCursors.prototype.render = function (ctx) {
        var renderData = [], renderDataLen = 0;
        var primaryRenderData = this._primaryCursor.render(ctx);
        if (primaryRenderData) {
            renderData[renderDataLen++] = primaryRenderData;
        }
        for (var i = 0, len = this._secondaryCursors.length; i < len; i++) {
            var secondaryRenderData = this._secondaryCursors[i].render(ctx);
            if (secondaryRenderData) {
                renderData[renderDataLen++] = secondaryRenderData;
            }
        }
        this._renderData = renderData;
    };
    ViewCursors.prototype.getLastRenderData = function () {
        return this._renderData;
    };
    ViewCursors.BLINK_INTERVAL = 500;
    return ViewCursors;
}(ViewPart));
registerThemingParticipant(function (theme, collector) {
    var caret = theme.getColor(editorCursorForeground);
    if (caret) {
        var caretBackground = theme.getColor(editorCursorBackground);
        if (!caretBackground) {
            caretBackground = caret.opposite();
        }
        collector.addRule(".monaco-editor .cursor { background-color: " + caret + "; border-color: " + caret + "; color: " + caretBackground + "; }");
        if (theme.type === 'hc') {
            collector.addRule(".monaco-editor .cursors-layer.has-selection .cursor { border-left: 1px solid " + caretBackground + "; border-right: 1px solid " + caretBackground + "; }");
        }
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$S = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var ViewZones = /** @class */ (function (_super) {
    __extends$S(ViewZones, _super);
    function ViewZones(context) {
        var _this = _super.call(this, context) || this;
        _this._lineHeight = _this._context.configuration.editor.lineHeight;
        _this._contentWidth = _this._context.configuration.editor.layoutInfo.contentWidth;
        _this._contentLeft = _this._context.configuration.editor.layoutInfo.contentLeft;
        _this.domNode = createFastDomNode(document.createElement('div'));
        _this.domNode.setClassName('view-zones');
        _this.domNode.setPosition('absolute');
        _this.domNode.setAttribute('role', 'presentation');
        _this.domNode.setAttribute('aria-hidden', 'true');
        _this.marginDomNode = createFastDomNode(document.createElement('div'));
        _this.marginDomNode.setClassName('margin-view-zones');
        _this.marginDomNode.setPosition('absolute');
        _this.marginDomNode.setAttribute('role', 'presentation');
        _this.marginDomNode.setAttribute('aria-hidden', 'true');
        _this._zones = {};
        return _this;
    }
    ViewZones.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
        this._zones = {};
    };
    // ---- begin view event handlers
    ViewZones.prototype._recomputeWhitespacesProps = function () {
        var hadAChange = false;
        var keys = Object.keys(this._zones);
        for (var i = 0, len = keys.length; i < len; i++) {
            var id = keys[i];
            var zone = this._zones[id];
            var props = this._computeWhitespaceProps(zone.delegate);
            if (this._context.viewLayout.changeWhitespace(parseInt(id, 10), props.afterViewLineNumber, props.heightInPx)) {
                this._safeCallOnComputedHeight(zone.delegate, props.heightInPx);
                hadAChange = true;
            }
        }
        return hadAChange;
    };
    ViewZones.prototype.onConfigurationChanged = function (e) {
        if (e.lineHeight) {
            this._lineHeight = this._context.configuration.editor.lineHeight;
            return this._recomputeWhitespacesProps();
        }
        if (e.layoutInfo) {
            this._contentWidth = this._context.configuration.editor.layoutInfo.contentWidth;
            this._contentLeft = this._context.configuration.editor.layoutInfo.contentLeft;
        }
        return true;
    };
    ViewZones.prototype.onLineMappingChanged = function (e) {
        var hadAChange = this._recomputeWhitespacesProps();
        if (hadAChange) {
            this._context.viewLayout.onHeightMaybeChanged();
        }
        return hadAChange;
    };
    ViewZones.prototype.onLinesDeleted = function (e) {
        return true;
    };
    ViewZones.prototype.onScrollChanged = function (e) {
        return e.scrollTopChanged || e.scrollWidthChanged;
    };
    ViewZones.prototype.onZonesChanged = function (e) {
        return true;
    };
    ViewZones.prototype.onLinesInserted = function (e) {
        return true;
    };
    // ---- end view event handlers
    ViewZones.prototype._getZoneOrdinal = function (zone) {
        if (typeof zone.afterColumn !== 'undefined') {
            return zone.afterColumn;
        }
        return 10000;
    };
    ViewZones.prototype._computeWhitespaceProps = function (zone) {
        if (zone.afterLineNumber === 0) {
            return {
                afterViewLineNumber: 0,
                heightInPx: this._heightInPixels(zone)
            };
        }
        var zoneAfterModelPosition;
        if (typeof zone.afterColumn !== 'undefined') {
            zoneAfterModelPosition = this._context.model.validateModelPosition({
                lineNumber: zone.afterLineNumber,
                column: zone.afterColumn
            });
        }
        else {
            var validAfterLineNumber = this._context.model.validateModelPosition({
                lineNumber: zone.afterLineNumber,
                column: 1
            }).lineNumber;
            zoneAfterModelPosition = new Position(validAfterLineNumber, this._context.model.getModelLineMaxColumn(validAfterLineNumber));
        }
        var zoneBeforeModelPosition;
        if (zoneAfterModelPosition.column === this._context.model.getModelLineMaxColumn(zoneAfterModelPosition.lineNumber)) {
            zoneBeforeModelPosition = this._context.model.validateModelPosition({
                lineNumber: zoneAfterModelPosition.lineNumber + 1,
                column: 1
            });
        }
        else {
            zoneBeforeModelPosition = this._context.model.validateModelPosition({
                lineNumber: zoneAfterModelPosition.lineNumber,
                column: zoneAfterModelPosition.column + 1
            });
        }
        var viewPosition = this._context.model.coordinatesConverter.convertModelPositionToViewPosition(zoneAfterModelPosition);
        var isVisible = this._context.model.coordinatesConverter.modelPositionIsVisible(zoneBeforeModelPosition);
        return {
            afterViewLineNumber: viewPosition.lineNumber,
            heightInPx: (isVisible ? this._heightInPixels(zone) : 0)
        };
    };
    ViewZones.prototype.addZone = function (zone) {
        var props = this._computeWhitespaceProps(zone);
        var whitespaceId = this._context.viewLayout.addWhitespace(props.afterViewLineNumber, this._getZoneOrdinal(zone), props.heightInPx);
        var myZone = {
            whitespaceId: whitespaceId,
            delegate: zone,
            isVisible: false,
            domNode: createFastDomNode(zone.domNode),
            marginDomNode: zone.marginDomNode ? createFastDomNode(zone.marginDomNode) : null
        };
        this._safeCallOnComputedHeight(myZone.delegate, props.heightInPx);
        myZone.domNode.setPosition('absolute');
        myZone.domNode.domNode.style.width = '100%';
        myZone.domNode.setDisplay('none');
        myZone.domNode.setAttribute('monaco-view-zone', myZone.whitespaceId.toString());
        this.domNode.appendChild(myZone.domNode);
        if (myZone.marginDomNode) {
            myZone.marginDomNode.setPosition('absolute');
            myZone.marginDomNode.domNode.style.width = '100%';
            myZone.marginDomNode.setDisplay('none');
            myZone.marginDomNode.setAttribute('monaco-view-zone', myZone.whitespaceId.toString());
            this.marginDomNode.appendChild(myZone.marginDomNode);
        }
        this._zones[myZone.whitespaceId.toString()] = myZone;
        this.setShouldRender();
        return myZone.whitespaceId;
    };
    ViewZones.prototype.removeZone = function (id) {
        if (this._zones.hasOwnProperty(id.toString())) {
            var zone = this._zones[id.toString()];
            delete this._zones[id.toString()];
            this._context.viewLayout.removeWhitespace(zone.whitespaceId);
            zone.domNode.removeAttribute('monaco-visible-view-zone');
            zone.domNode.removeAttribute('monaco-view-zone');
            zone.domNode.domNode.parentNode.removeChild(zone.domNode.domNode);
            if (zone.marginDomNode) {
                zone.marginDomNode.removeAttribute('monaco-visible-view-zone');
                zone.marginDomNode.removeAttribute('monaco-view-zone');
                zone.marginDomNode.domNode.parentNode.removeChild(zone.marginDomNode.domNode);
            }
            this.setShouldRender();
            return true;
        }
        return false;
    };
    ViewZones.prototype.layoutZone = function (id) {
        var changed = false;
        if (this._zones.hasOwnProperty(id.toString())) {
            var zone = this._zones[id.toString()];
            var props = this._computeWhitespaceProps(zone.delegate);
            // let newOrdinal = this._getZoneOrdinal(zone.delegate);
            changed = this._context.viewLayout.changeWhitespace(zone.whitespaceId, props.afterViewLineNumber, props.heightInPx) || changed;
            // TODO@Alex: change `newOrdinal` too
            if (changed) {
                this._safeCallOnComputedHeight(zone.delegate, props.heightInPx);
                this.setShouldRender();
            }
        }
        return changed;
    };
    ViewZones.prototype.shouldSuppressMouseDownOnViewZone = function (id) {
        if (this._zones.hasOwnProperty(id.toString())) {
            var zone = this._zones[id.toString()];
            return zone.delegate.suppressMouseDown;
        }
        return false;
    };
    ViewZones.prototype._heightInPixels = function (zone) {
        if (typeof zone.heightInPx === 'number') {
            return zone.heightInPx;
        }
        if (typeof zone.heightInLines === 'number') {
            return this._lineHeight * zone.heightInLines;
        }
        return this._lineHeight;
    };
    ViewZones.prototype._safeCallOnComputedHeight = function (zone, height) {
        if (typeof zone.onComputedHeight === 'function') {
            try {
                zone.onComputedHeight(height);
            }
            catch (e) {
                onUnexpectedError(e);
            }
        }
    };
    ViewZones.prototype._safeCallOnDomNodeTop = function (zone, top) {
        if (typeof zone.onDomNodeTop === 'function') {
            try {
                zone.onDomNodeTop(top);
            }
            catch (e) {
                onUnexpectedError(e);
            }
        }
    };
    ViewZones.prototype.prepareRender = function (ctx) {
        // Nothing to read
    };
    ViewZones.prototype.render = function (ctx) {
        var visibleWhitespaces = ctx.viewportData.whitespaceViewportData;
        var visibleZones = {};
        var hasVisibleZone = false;
        for (var i = 0, len = visibleWhitespaces.length; i < len; i++) {
            visibleZones[visibleWhitespaces[i].id.toString()] = visibleWhitespaces[i];
            hasVisibleZone = true;
        }
        var keys = Object.keys(this._zones);
        for (var i = 0, len = keys.length; i < len; i++) {
            var id = keys[i];
            var zone = this._zones[id];
            var newTop = 0;
            var newHeight = 0;
            var newDisplay = 'none';
            if (visibleZones.hasOwnProperty(id)) {
                newTop = visibleZones[id].verticalOffset - ctx.bigNumbersDelta;
                newHeight = visibleZones[id].height;
                newDisplay = 'block';
                // zone is visible
                if (!zone.isVisible) {
                    zone.domNode.setAttribute('monaco-visible-view-zone', 'true');
                    zone.isVisible = true;
                }
                this._safeCallOnDomNodeTop(zone.delegate, ctx.getScrolledTopFromAbsoluteTop(visibleZones[id].verticalOffset));
            }
            else {
                if (zone.isVisible) {
                    zone.domNode.removeAttribute('monaco-visible-view-zone');
                    zone.isVisible = false;
                }
                this._safeCallOnDomNodeTop(zone.delegate, ctx.getScrolledTopFromAbsoluteTop(-1000000));
            }
            zone.domNode.setTop(newTop);
            zone.domNode.setHeight(newHeight);
            zone.domNode.setDisplay(newDisplay);
            if (zone.marginDomNode) {
                zone.marginDomNode.setTop(newTop);
                zone.marginDomNode.setHeight(newHeight);
                zone.marginDomNode.setDisplay(newDisplay);
            }
        }
        if (hasVisibleZone) {
            this.domNode.setWidth(Math.max(ctx.scrollWidth, this._contentWidth));
            this.marginDomNode.setWidth(this._contentLeft);
        }
    };
    return ViewZones;
}(ViewPart));

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var ViewContext = /** @class */ (function () {
    function ViewContext(configuration, theme, model, privateViewEventBus) {
        this.configuration = configuration;
        this.theme = theme;
        this.model = model;
        this.viewLayout = model.viewLayout;
        this.privateViewEventBus = privateViewEventBus;
    }
    ViewContext.prototype.addEventHandler = function (eventHandler) {
        this.privateViewEventBus.addEventHandler(eventHandler);
    };
    ViewContext.prototype.removeEventHandler = function (eventHandler) {
        this.privateViewEventBus.removeEventHandler(eventHandler);
    };
    return ViewContext;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$T = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var ViewOutgoingEvents = /** @class */ (function (_super) {
    __extends$T(ViewOutgoingEvents, _super);
    function ViewOutgoingEvents(viewModel) {
        var _this = _super.call(this) || this;
        _this.onDidScroll = null;
        _this.onDidGainFocus = null;
        _this.onDidLoseFocus = null;
        _this.onKeyDown = null;
        _this.onKeyUp = null;
        _this.onContextMenu = null;
        _this.onMouseMove = null;
        _this.onMouseLeave = null;
        _this.onMouseUp = null;
        _this.onMouseDown = null;
        _this.onMouseDrag = null;
        _this.onMouseDrop = null;
        _this._viewModel = viewModel;
        return _this;
    }
    ViewOutgoingEvents.prototype.emitScrollChanged = function (e) {
        if (this.onDidScroll) {
            this.onDidScroll(e);
        }
    };
    ViewOutgoingEvents.prototype.emitViewFocusGained = function () {
        if (this.onDidGainFocus) {
            this.onDidGainFocus(void 0);
        }
    };
    ViewOutgoingEvents.prototype.emitViewFocusLost = function () {
        if (this.onDidLoseFocus) {
            this.onDidLoseFocus(void 0);
        }
    };
    ViewOutgoingEvents.prototype.emitKeyDown = function (e) {
        if (this.onKeyDown) {
            this.onKeyDown(e);
        }
    };
    ViewOutgoingEvents.prototype.emitKeyUp = function (e) {
        if (this.onKeyUp) {
            this.onKeyUp(e);
        }
    };
    ViewOutgoingEvents.prototype.emitContextMenu = function (e) {
        if (this.onContextMenu) {
            this.onContextMenu(this._convertViewToModelMouseEvent(e));
        }
    };
    ViewOutgoingEvents.prototype.emitMouseMove = function (e) {
        if (this.onMouseMove) {
            this.onMouseMove(this._convertViewToModelMouseEvent(e));
        }
    };
    ViewOutgoingEvents.prototype.emitMouseLeave = function (e) {
        if (this.onMouseLeave) {
            this.onMouseLeave(this._convertViewToModelMouseEvent(e));
        }
    };
    ViewOutgoingEvents.prototype.emitMouseUp = function (e) {
        if (this.onMouseUp) {
            this.onMouseUp(this._convertViewToModelMouseEvent(e));
        }
    };
    ViewOutgoingEvents.prototype.emitMouseDown = function (e) {
        if (this.onMouseDown) {
            this.onMouseDown(this._convertViewToModelMouseEvent(e));
        }
    };
    ViewOutgoingEvents.prototype.emitMouseDrag = function (e) {
        if (this.onMouseDrag) {
            this.onMouseDrag(this._convertViewToModelMouseEvent(e));
        }
    };
    ViewOutgoingEvents.prototype.emitMouseDrop = function (e) {
        if (this.onMouseDrop) {
            this.onMouseDrop(this._convertViewToModelMouseEvent(e));
        }
    };
    ViewOutgoingEvents.prototype._convertViewToModelMouseEvent = function (e) {
        if (e.target) {
            return {
                event: e.event,
                target: this._convertViewToModelMouseTarget(e.target)
            };
        }
        return e;
    };
    ViewOutgoingEvents.prototype._convertViewToModelMouseTarget = function (target) {
        return new ExternalMouseTarget(target.element, target.type, target.mouseColumn, target.position ? this._convertViewToModelPosition(target.position) : null, target.range ? this._convertViewToModelRange(target.range) : null, target.detail);
    };
    ViewOutgoingEvents.prototype._convertViewToModelPosition = function (viewPosition) {
        return this._viewModel.coordinatesConverter.convertViewPositionToModelPosition(viewPosition);
    };
    ViewOutgoingEvents.prototype._convertViewToModelRange = function (viewRange) {
        return this._viewModel.coordinatesConverter.convertViewRangeToModelRange(viewRange);
    };
    return ViewOutgoingEvents;
}(Disposable));
var ExternalMouseTarget = /** @class */ (function () {
    function ExternalMouseTarget(element, type, mouseColumn, position, range, detail) {
        this.element = element;
        this.type = type;
        this.mouseColumn = mouseColumn;
        this.position = position;
        this.range = range;
        this.detail = detail;
    }
    ExternalMouseTarget.prototype.toString = function () {
        return MouseTarget.toString(this);
    };
    return ExternalMouseTarget;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
/**
 * Contains all data needed to render at a specific viewport.
 */
var ViewportData = /** @class */ (function () {
    function ViewportData(selections, partialData, whitespaceViewportData, model) {
        this.selections = selections;
        this.startLineNumber = partialData.startLineNumber | 0;
        this.endLineNumber = partialData.endLineNumber | 0;
        this.relativeVerticalOffset = partialData.relativeVerticalOffset;
        this.bigNumbersDelta = partialData.bigNumbersDelta | 0;
        this.whitespaceViewportData = whitespaceViewportData;
        this._model = model;
        this.visibleRange = new Range(partialData.startLineNumber, this._model.getLineMinColumn(partialData.startLineNumber), partialData.endLineNumber, this._model.getLineMaxColumn(partialData.endLineNumber));
    }
    ViewportData.prototype.getViewLineRenderingData = function (lineNumber) {
        return this._model.getViewLineRenderingData(this.visibleRange, lineNumber);
    };
    ViewportData.prototype.getDecorationsInViewport = function () {
        return this._model.getDecorationsInViewport(this.visibleRange);
    };
    return ViewportData;
}());

const css$i = "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n/* Arrows */\n.monaco-scrollable-element > .scrollbar > .up-arrow {\n\tbackground: url(\"data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMTEgMTEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0ibTkuNDgwNDYsOC45NjE1bDEuMjYsLTEuMjZsLTUuMDQsLTUuMDRsLTUuNDYsNS4wNGwxLjI2LDEuMjZsNC4yLC0zLjc4bDMuNzgsMy43OHoiIGZpbGw9IiM0MjQyNDIiLz48L3N2Zz4=\");\n\tcursor: pointer;\n}\n.monaco-scrollable-element > .scrollbar > .down-arrow {\n\tbackground: url(\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMSAxMSI+PHBhdGggdHJhbnNmb3JtPSJyb3RhdGUoLTE4MCA1LjQ5MDQ1OTkxODk3NTgzLDUuODExNTAwMDcyNDc5MjQ4KSIgZmlsbD0iIzQyNDI0MiIgZD0ibTkuNDgwNDYsOC45NjE1bDEuMjYsLTEuMjZsLTUuMDQsLTUuMDRsLTUuNDYsNS4wNGwxLjI2LDEuMjZsNC4yLC0zLjc4bDMuNzgsMy43OHoiLz48L3N2Zz4=\");\n\tcursor: pointer;\n}\n.monaco-scrollable-element > .scrollbar > .left-arrow {\n\tbackground: url(\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMSAxMSI+PHBhdGggdHJhbnNmb3JtPSJyb3RhdGUoLTkwIDUuNDkwNDU5OTE4OTc1ODMxLDUuNDMxMzgyMTc5MjYwMjU0KSIgZmlsbD0iIzQyNDI0MiIgZD0ibTkuNDgwNDYsOC41ODEzOGwxLjI2LC0xLjI2bC01LjA0LC01LjA0bC01LjQ2LDUuMDRsMS4yNiwxLjI2bDQuMiwtMy43OGwzLjc4LDMuNzh6Ii8+PC9zdmc+\");\n\tcursor: pointer;\n}\n.monaco-scrollable-element > .scrollbar > .right-arrow {\n\tbackground: url(\"data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMTEgMTEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggdHJhbnNmb3JtPSJyb3RhdGUoOTAgNS42MTcxNjUwODg2NTM1NjQ1LDUuNTU4MDg5NzMzMTIzNzgpICIgZmlsbD0iIzQyNDI0MiIgZD0ibTkuNjA3MTcsOC43MDgwOWwxLjI2LC0xLjI2bC01LjA0LC01LjA0bC01LjQ2LDUuMDRsMS4yNiwxLjI2bDQuMiwtMy43OGwzLjc4LDMuNzh6Ii8+PC9zdmc+\");\n\tcursor: pointer;\n}\n\n.hc-black .monaco-scrollable-element > .scrollbar > .up-arrow,\n.vs-dark .monaco-scrollable-element > .scrollbar > .up-arrow {\n\tbackground: url(\"data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMTEgMTEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0ibTkuNDgwNDYsOC45NjE1bDEuMjYsLTEuMjZsLTUuMDQsLTUuMDRsLTUuNDYsNS4wNGwxLjI2LDEuMjZsNC4yLC0zLjc4bDMuNzgsMy43OHoiIGZpbGw9IiNFOEU4RTgiLz48L3N2Zz4=\");\n}\n.hc-black .monaco-scrollable-element > .scrollbar > .down-arrow,\n.vs-dark .monaco-scrollable-element > .scrollbar > .down-arrow {\n\tbackground: url(\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMSAxMSI+PHBhdGggdHJhbnNmb3JtPSJyb3RhdGUoLTE4MCA1LjQ5MDQ1OTkxODk3NTgzLDUuODExNTAwMDcyNDc5MjQ4KSIgZmlsbD0iI0U4RThFOCIgZD0ibTkuNDgwNDYsOC45NjE1bDEuMjYsLTEuMjZsLTUuMDQsLTUuMDRsLTUuNDYsNS4wNGwxLjI2LDEuMjZsNC4yLC0zLjc4bDMuNzgsMy43OHoiLz48L3N2Zz4=\");\n}\n.hc-black .monaco-scrollable-element > .scrollbar > .left-arrow,\n.vs-dark .monaco-scrollable-element > .scrollbar > .left-arrow {\n\tbackground: url(\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMSAxMSI+PHBhdGggdHJhbnNmb3JtPSJyb3RhdGUoLTkwIDUuNDkwNDU5OTE4OTc1ODMxLDUuNDMxMzgyMTc5MjYwMjU0KSIgZmlsbD0iI0U4RThFOCIgZD0ibTkuNDgwNDYsOC41ODEzOGwxLjI2LC0xLjI2bC01LjA0LC01LjA0bC01LjQ2LDUuMDRsMS4yNiwxLjI2bDQuMiwtMy43OGwzLjc4LDMuNzh6Ii8+PC9zdmc+\");\n}\n.hc-black .monaco-scrollable-element > .scrollbar > .right-arrow,\n.vs-dark .monaco-scrollable-element > .scrollbar > .right-arrow {\n\tbackground: url(\"data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMTEgMTEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggdHJhbnNmb3JtPSJyb3RhdGUoOTAgNS42MTcxNjUwODg2NTM1NjQ1LDUuNTU4MDg5NzMzMTIzNzgpICIgZmlsbD0iI0U4RThFOCIgZD0ibTkuNjA3MTcsOC43MDgwOWwxLjI2LC0xLjI2bC01LjA0LC01LjA0bC01LjQ2LDUuMDRsMS4yNiwxLjI2bDQuMiwtMy43OGwzLjc4LDMuNzh6Ii8+PC9zdmc+\");\n}\n\n.monaco-scrollable-element > .visible {\n\topacity: 1;\n\n\t/* Background rule added for IE9 - to allow clicks on dom node */\n\tbackground:rgba(0,0,0,0);\n\n\t-webkit-transition: opacity 100ms linear;\n\t-o-transition: opacity 100ms linear;\n\t-moz-transition: opacity 100ms linear;\n\t-ms-transition: opacity 100ms linear;\n\ttransition: opacity 100ms linear;\n}\n.monaco-scrollable-element > .invisible {\n\topacity: 0;\n\tpointer-events: none;\n}\n.monaco-scrollable-element > .invisible.fade {\n\t-webkit-transition: opacity 800ms linear;\n\t-o-transition: opacity 800ms linear;\n\t-moz-transition: opacity 800ms linear;\n\t-ms-transition: opacity 800ms linear;\n\ttransition: opacity 800ms linear;\n}\n\n/* Scrollable Content Inset Shadow */\n.monaco-scrollable-element > .shadow {\n\tposition: absolute;\n\tdisplay: none;\n}\n.monaco-scrollable-element > .shadow.top {\n\tdisplay: block;\n\ttop: 0;\n\tleft: 3px;\n\theight: 3px;\n\twidth: 100%;\n\tbox-shadow: #DDD 0 6px 6px -6px inset;\n}\n.monaco-scrollable-element > .shadow.left {\n\tdisplay: block;\n\ttop: 3px;\n\tleft: 0;\n\theight: 100%;\n\twidth: 3px;\n\tbox-shadow: #DDD 6px 0 6px -6px inset;\n}\n.monaco-scrollable-element > .shadow.top-left-corner {\n\tdisplay: block;\n\ttop: 0;\n\tleft: 0;\n\theight: 3px;\n\twidth: 3px;\n}\n.monaco-scrollable-element > .shadow.top.left {\n\tbox-shadow: #DDD 6px 6px 6px -6px inset;\n}\n\n/* ---------- Default Style ---------- */\n\n.vs .monaco-scrollable-element > .scrollbar > .slider {\n\tbackground: rgba(100, 100, 100, .4);\n}\n.vs-dark .monaco-scrollable-element > .scrollbar > .slider {\n\tbackground: rgba(121, 121, 121, .4);\n}\n.hc-black .monaco-scrollable-element > .scrollbar > .slider {\n\tbackground: rgba(111, 195, 223, .6);\n}\n\n.monaco-scrollable-element > .scrollbar > .slider:hover {\n\tbackground: rgba(100, 100, 100, .7);\n}\n.hc-black .monaco-scrollable-element > .scrollbar > .slider:hover {\n\tbackground: rgba(111, 195, 223, .8);\n}\n\n.monaco-scrollable-element > .scrollbar > .slider.active {\n\tbackground: rgba(0, 0, 0, .6);\n}\n.vs-dark .monaco-scrollable-element > .scrollbar > .slider.active {\n\tbackground: rgba(191, 191, 191, .4);\n}\n.hc-black .monaco-scrollable-element > .scrollbar > .slider.active {\n\tbackground: rgba(111, 195, 223, 1);\n}\n\n.vs-dark .monaco-scrollable-element .shadow.top {\n\tbox-shadow: none;\n}\n\n.vs-dark .monaco-scrollable-element .shadow.left {\n\tbox-shadow: #000 6px 0 6px -6px inset;\n}\n\n.vs-dark .monaco-scrollable-element .shadow.top.left {\n\tbox-shadow: #000 6px 6px 6px -6px inset;\n}\n\n.hc-black .monaco-scrollable-element .shadow.top {\n\tbox-shadow: none;\n}\n\n.hc-black .monaco-scrollable-element .shadow.left {\n\tbox-shadow: none;\n}\n\n.hc-black .monaco-scrollable-element .shadow.top.left {\n\tbox-shadow: none;\n}";
  const element$i = ((css, src) => {
if (typeof document !== 'object')
console.info(`Skipped loading "${src}"`);
try {
const id = src
  .replace(/\.css.*$/, '')
  .replace(/[\\:]/g, '/')
  .replace(/[^\w\/]+/g, '');
return (
  document.querySelector(`style[id="${id}"]`) ||
  document.head.appendChild(
    Object.assign(document.createElement('style'), {
      id,
      textContent: `${css}\n\n /* sourceURL=${src} */`,
    }),
  )
);
} catch (exception) {
console.warn(`Failed load "${src}"`, exception);
}
})(css$i, "…monaco-editor/esm/vs/base/browser/ui/scrollbar/media/scrollbars.css");
  //@ sourceURL=/Users/daflair/Projects/packages/monaco-es/node_modules/monaco-editor/esm/vs/base/browser/ui/scrollbar/media/scrollbars.css

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$U = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var Widget$1 = /** @class */ (function (_super) {
    __extends$U(Widget, _super);
    function Widget() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Widget.prototype.onclick = function (domNode, listener) {
        this._register(addDisposableListener(domNode, EventType.CLICK, function (e) { return listener(new StandardMouseEvent(e)); }));
    };
    Widget.prototype.onmousedown = function (domNode, listener) {
        this._register(addDisposableListener(domNode, EventType.MOUSE_DOWN, function (e) { return listener(new StandardMouseEvent(e)); }));
    };
    Widget.prototype.onmouseover = function (domNode, listener) {
        this._register(addDisposableListener(domNode, EventType.MOUSE_OVER, function (e) { return listener(new StandardMouseEvent(e)); }));
    };
    Widget.prototype.onnonbubblingmouseout = function (domNode, listener) {
        this._register(addDisposableNonBubblingMouseOutListener(domNode, function (e) { return listener(new StandardMouseEvent(e)); }));
    };
    Widget.prototype.onkeydown = function (domNode, listener) {
        this._register(addDisposableListener(domNode, EventType.KEY_DOWN, function (e) { return listener(new StandardKeyboardEvent(e)); }));
    };
    Widget.prototype.onkeyup = function (domNode, listener) {
        this._register(addDisposableListener(domNode, EventType.KEY_UP, function (e) { return listener(new StandardKeyboardEvent(e)); }));
    };
    Widget.prototype.oninput = function (domNode, listener) {
        this._register(addDisposableListener(domNode, EventType.INPUT, listener));
    };
    Widget.prototype.onblur = function (domNode, listener) {
        this._register(addDisposableListener(domNode, EventType.BLUR, listener));
    };
    Widget.prototype.onfocus = function (domNode, listener) {
        this._register(addDisposableListener(domNode, EventType.FOCUS, listener));
    };
    Widget.prototype.onchange = function (domNode, listener) {
        this._register(addDisposableListener(domNode, EventType.CHANGE, listener));
    };
    return Widget;
}(Disposable));

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$V = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * The arrow image size.
 */
var ARROW_IMG_SIZE = 11;
var ScrollbarArrow = /** @class */ (function (_super) {
    __extends$V(ScrollbarArrow, _super);
    function ScrollbarArrow(opts) {
        var _this = _super.call(this) || this;
        _this._onActivate = opts.onActivate;
        _this.bgDomNode = document.createElement('div');
        _this.bgDomNode.className = 'arrow-background';
        _this.bgDomNode.style.position = 'absolute';
        _this.bgDomNode.style.width = opts.bgWidth + 'px';
        _this.bgDomNode.style.height = opts.bgHeight + 'px';
        if (typeof opts.top !== 'undefined') {
            _this.bgDomNode.style.top = '0px';
        }
        if (typeof opts.left !== 'undefined') {
            _this.bgDomNode.style.left = '0px';
        }
        if (typeof opts.bottom !== 'undefined') {
            _this.bgDomNode.style.bottom = '0px';
        }
        if (typeof opts.right !== 'undefined') {
            _this.bgDomNode.style.right = '0px';
        }
        _this.domNode = document.createElement('div');
        _this.domNode.className = opts.className;
        _this.domNode.style.position = 'absolute';
        _this.domNode.style.width = ARROW_IMG_SIZE + 'px';
        _this.domNode.style.height = ARROW_IMG_SIZE + 'px';
        if (typeof opts.top !== 'undefined') {
            _this.domNode.style.top = opts.top + 'px';
        }
        if (typeof opts.left !== 'undefined') {
            _this.domNode.style.left = opts.left + 'px';
        }
        if (typeof opts.bottom !== 'undefined') {
            _this.domNode.style.bottom = opts.bottom + 'px';
        }
        if (typeof opts.right !== 'undefined') {
            _this.domNode.style.right = opts.right + 'px';
        }
        _this._mouseMoveMonitor = _this._register(new GlobalMouseMoveMonitor());
        _this.onmousedown(_this.bgDomNode, function (e) { return _this._arrowMouseDown(e); });
        _this.onmousedown(_this.domNode, function (e) { return _this._arrowMouseDown(e); });
        _this._mousedownRepeatTimer = _this._register(new IntervalTimer());
        _this._mousedownScheduleRepeatTimer = _this._register(new TimeoutTimer());
        return _this;
    }
    ScrollbarArrow.prototype._arrowMouseDown = function (e) {
        var _this = this;
        var scheduleRepeater = function () {
            _this._mousedownRepeatTimer.cancelAndSet(function () { return _this._onActivate(); }, 1000 / 24);
        };
        this._onActivate();
        this._mousedownRepeatTimer.cancel();
        this._mousedownScheduleRepeatTimer.cancelAndSet(scheduleRepeater, 200);
        this._mouseMoveMonitor.startMonitoring(standardMouseMoveMerger, function (mouseMoveData) {
            /* Intentional empty */
        }, function () {
            _this._mousedownRepeatTimer.cancel();
            _this._mousedownScheduleRepeatTimer.cancel();
        });
        e.preventDefault();
    };
    return ScrollbarArrow;
}(Widget$1));

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$W = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var ScrollbarVisibilityController = /** @class */ (function (_super) {
    __extends$W(ScrollbarVisibilityController, _super);
    function ScrollbarVisibilityController(visibility, visibleClassName, invisibleClassName) {
        var _this = _super.call(this) || this;
        _this._visibility = visibility;
        _this._visibleClassName = visibleClassName;
        _this._invisibleClassName = invisibleClassName;
        _this._domNode = null;
        _this._isVisible = false;
        _this._isNeeded = false;
        _this._shouldBeVisible = false;
        _this._revealTimer = _this._register(new TimeoutTimer());
        return _this;
    }
    // ----------------- Hide / Reveal
    ScrollbarVisibilityController.prototype.applyVisibilitySetting = function (shouldBeVisible) {
        if (this._visibility === ScrollbarVisibility.Hidden) {
            return false;
        }
        if (this._visibility === ScrollbarVisibility.Visible) {
            return true;
        }
        return shouldBeVisible;
    };
    ScrollbarVisibilityController.prototype.setShouldBeVisible = function (rawShouldBeVisible) {
        var shouldBeVisible = this.applyVisibilitySetting(rawShouldBeVisible);
        if (this._shouldBeVisible !== shouldBeVisible) {
            this._shouldBeVisible = shouldBeVisible;
            this.ensureVisibility();
        }
    };
    ScrollbarVisibilityController.prototype.setIsNeeded = function (isNeeded) {
        if (this._isNeeded !== isNeeded) {
            this._isNeeded = isNeeded;
            this.ensureVisibility();
        }
    };
    ScrollbarVisibilityController.prototype.setDomNode = function (domNode) {
        this._domNode = domNode;
        this._domNode.setClassName(this._invisibleClassName);
        // Now that the flags & the dom node are in a consistent state, ensure the Hidden/Visible configuration
        this.setShouldBeVisible(false);
    };
    ScrollbarVisibilityController.prototype.ensureVisibility = function () {
        if (!this._isNeeded) {
            // Nothing to be rendered
            this._hide(false);
            return;
        }
        if (this._shouldBeVisible) {
            this._reveal();
        }
        else {
            this._hide(true);
        }
    };
    ScrollbarVisibilityController.prototype._reveal = function () {
        var _this = this;
        if (this._isVisible) {
            return;
        }
        this._isVisible = true;
        // The CSS animation doesn't play otherwise
        this._revealTimer.setIfNotSet(function () {
            _this._domNode.setClassName(_this._visibleClassName);
        }, 0);
    };
    ScrollbarVisibilityController.prototype._hide = function (withFadeAway) {
        this._revealTimer.cancel();
        if (!this._isVisible) {
            return;
        }
        this._isVisible = false;
        this._domNode.setClassName(this._invisibleClassName + (withFadeAway ? ' fade' : ''));
    };
    return ScrollbarVisibilityController;
}(Disposable));

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$X = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * The orthogonal distance to the slider at which dragging "resets". This implements "snapping"
 */
var MOUSE_DRAG_RESET_DISTANCE = 140;
var AbstractScrollbar = /** @class */ (function (_super) {
    __extends$X(AbstractScrollbar, _super);
    function AbstractScrollbar(opts) {
        var _this = _super.call(this) || this;
        _this._lazyRender = opts.lazyRender;
        _this._host = opts.host;
        _this._scrollable = opts.scrollable;
        _this._scrollbarState = opts.scrollbarState;
        _this._visibilityController = _this._register(new ScrollbarVisibilityController(opts.visibility, 'visible scrollbar ' + opts.extraScrollbarClassName, 'invisible scrollbar ' + opts.extraScrollbarClassName));
        _this._mouseMoveMonitor = _this._register(new GlobalMouseMoveMonitor());
        _this._shouldRender = true;
        _this.domNode = createFastDomNode(document.createElement('div'));
        _this.domNode.setAttribute('role', 'presentation');
        _this.domNode.setAttribute('aria-hidden', 'true');
        _this._visibilityController.setDomNode(_this.domNode);
        _this.domNode.setPosition('absolute');
        _this.onmousedown(_this.domNode.domNode, function (e) { return _this._domNodeMouseDown(e); });
        return _this;
    }
    // ----------------- creation
    /**
     * Creates the dom node for an arrow & adds it to the container
     */
    AbstractScrollbar.prototype._createArrow = function (opts) {
        var arrow = this._register(new ScrollbarArrow(opts));
        this.domNode.domNode.appendChild(arrow.bgDomNode);
        this.domNode.domNode.appendChild(arrow.domNode);
    };
    /**
     * Creates the slider dom node, adds it to the container & hooks up the events
     */
    AbstractScrollbar.prototype._createSlider = function (top, left, width, height) {
        var _this = this;
        this.slider = createFastDomNode(document.createElement('div'));
        this.slider.setClassName('slider');
        this.slider.setPosition('absolute');
        this.slider.setTop(top);
        this.slider.setLeft(left);
        this.slider.setWidth(width);
        this.slider.setHeight(height);
        this.slider.setLayerHinting(true);
        this.domNode.domNode.appendChild(this.slider.domNode);
        this.onmousedown(this.slider.domNode, function (e) {
            if (e.leftButton) {
                e.preventDefault();
                _this._sliderMouseDown(e, function () { });
            }
        });
    };
    // ----------------- Update state
    AbstractScrollbar.prototype._onElementSize = function (visibleSize) {
        if (this._scrollbarState.setVisibleSize(visibleSize)) {
            this._visibilityController.setIsNeeded(this._scrollbarState.isNeeded());
            this._shouldRender = true;
            if (!this._lazyRender) {
                this.render();
            }
        }
        return this._shouldRender;
    };
    AbstractScrollbar.prototype._onElementScrollSize = function (elementScrollSize) {
        if (this._scrollbarState.setScrollSize(elementScrollSize)) {
            this._visibilityController.setIsNeeded(this._scrollbarState.isNeeded());
            this._shouldRender = true;
            if (!this._lazyRender) {
                this.render();
            }
        }
        return this._shouldRender;
    };
    AbstractScrollbar.prototype._onElementScrollPosition = function (elementScrollPosition) {
        if (this._scrollbarState.setScrollPosition(elementScrollPosition)) {
            this._visibilityController.setIsNeeded(this._scrollbarState.isNeeded());
            this._shouldRender = true;
            if (!this._lazyRender) {
                this.render();
            }
        }
        return this._shouldRender;
    };
    // ----------------- rendering
    AbstractScrollbar.prototype.beginReveal = function () {
        this._visibilityController.setShouldBeVisible(true);
    };
    AbstractScrollbar.prototype.beginHide = function () {
        this._visibilityController.setShouldBeVisible(false);
    };
    AbstractScrollbar.prototype.render = function () {
        if (!this._shouldRender) {
            return;
        }
        this._shouldRender = false;
        this._renderDomNode(this._scrollbarState.getRectangleLargeSize(), this._scrollbarState.getRectangleSmallSize());
        this._updateSlider(this._scrollbarState.getSliderSize(), this._scrollbarState.getArrowSize() + this._scrollbarState.getSliderPosition());
    };
    // ----------------- DOM events
    AbstractScrollbar.prototype._domNodeMouseDown = function (e) {
        if (e.target !== this.domNode.domNode) {
            return;
        }
        this._onMouseDown(e);
    };
    AbstractScrollbar.prototype.delegateMouseDown = function (e) {
        var domTop = this.domNode.domNode.getClientRects()[0].top;
        var sliderStart = domTop + this._scrollbarState.getSliderPosition();
        var sliderStop = domTop + this._scrollbarState.getSliderPosition() + this._scrollbarState.getSliderSize();
        var mousePos = this._sliderMousePosition(e);
        if (sliderStart <= mousePos && mousePos <= sliderStop) {
            // Act as if it was a mouse down on the slider
            if (e.leftButton) {
                e.preventDefault();
                this._sliderMouseDown(e, function () { });
            }
        }
        else {
            // Act as if it was a mouse down on the scrollbar
            this._onMouseDown(e);
        }
    };
    AbstractScrollbar.prototype._onMouseDown = function (e) {
        var offsetX;
        var offsetY;
        if (e.target === this.domNode.domNode && typeof e.browserEvent.offsetX === 'number' && typeof e.browserEvent.offsetY === 'number') {
            offsetX = e.browserEvent.offsetX;
            offsetY = e.browserEvent.offsetY;
        }
        else {
            var domNodePosition = getDomNodePagePosition(this.domNode.domNode);
            offsetX = e.posx - domNodePosition.left;
            offsetY = e.posy - domNodePosition.top;
        }
        this._setDesiredScrollPositionNow(this._scrollbarState.getDesiredScrollPositionFromOffset(this._mouseDownRelativePosition(offsetX, offsetY)));
        if (e.leftButton) {
            e.preventDefault();
            this._sliderMouseDown(e, function () { });
        }
    };
    AbstractScrollbar.prototype._sliderMouseDown = function (e, onDragFinished) {
        var _this = this;
        var initialMousePosition = this._sliderMousePosition(e);
        var initialMouseOrthogonalPosition = this._sliderOrthogonalMousePosition(e);
        var initialScrollbarState = this._scrollbarState.clone();
        this.slider.toggleClassName('active', true);
        this._mouseMoveMonitor.startMonitoring(standardMouseMoveMerger, function (mouseMoveData) {
            var mouseOrthogonalPosition = _this._sliderOrthogonalMousePosition(mouseMoveData);
            var mouseOrthogonalDelta = Math.abs(mouseOrthogonalPosition - initialMouseOrthogonalPosition);
            if (isWindows && mouseOrthogonalDelta > MOUSE_DRAG_RESET_DISTANCE) {
                // The mouse has wondered away from the scrollbar => reset dragging
                _this._setDesiredScrollPositionNow(initialScrollbarState.getScrollPosition());
                return;
            }
            var mousePosition = _this._sliderMousePosition(mouseMoveData);
            var mouseDelta = mousePosition - initialMousePosition;
            _this._setDesiredScrollPositionNow(initialScrollbarState.getDesiredScrollPositionFromDelta(mouseDelta));
        }, function () {
            _this.slider.toggleClassName('active', false);
            _this._host.onDragEnd();
            onDragFinished();
        });
        this._host.onDragStart();
    };
    AbstractScrollbar.prototype._setDesiredScrollPositionNow = function (_desiredScrollPosition) {
        var desiredScrollPosition = {};
        this.writeScrollPosition(desiredScrollPosition, _desiredScrollPosition);
        this._scrollable.setScrollPositionNow(desiredScrollPosition);
    };
    return AbstractScrollbar;
}(Widget$1));

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
/**
 * The minimal size of the slider (such that it can still be clickable) -- it is artificially enlarged.
 */
var MINIMUM_SLIDER_SIZE = 20;
var ScrollbarState = /** @class */ (function () {
    function ScrollbarState(arrowSize, scrollbarSize, oppositeScrollbarSize) {
        this._scrollbarSize = Math.round(scrollbarSize);
        this._oppositeScrollbarSize = Math.round(oppositeScrollbarSize);
        this._arrowSize = Math.round(arrowSize);
        this._visibleSize = 0;
        this._scrollSize = 0;
        this._scrollPosition = 0;
        this._computedAvailableSize = 0;
        this._computedIsNeeded = false;
        this._computedSliderSize = 0;
        this._computedSliderRatio = 0;
        this._computedSliderPosition = 0;
        this._refreshComputedValues();
    }
    ScrollbarState.prototype.clone = function () {
        var r = new ScrollbarState(this._arrowSize, this._scrollbarSize, this._oppositeScrollbarSize);
        r.setVisibleSize(this._visibleSize);
        r.setScrollSize(this._scrollSize);
        r.setScrollPosition(this._scrollPosition);
        return r;
    };
    ScrollbarState.prototype.setVisibleSize = function (visibleSize) {
        var iVisibleSize = Math.round(visibleSize);
        if (this._visibleSize !== iVisibleSize) {
            this._visibleSize = iVisibleSize;
            this._refreshComputedValues();
            return true;
        }
        return false;
    };
    ScrollbarState.prototype.setScrollSize = function (scrollSize) {
        var iScrollSize = Math.round(scrollSize);
        if (this._scrollSize !== iScrollSize) {
            this._scrollSize = iScrollSize;
            this._refreshComputedValues();
            return true;
        }
        return false;
    };
    ScrollbarState.prototype.setScrollPosition = function (scrollPosition) {
        var iScrollPosition = Math.round(scrollPosition);
        if (this._scrollPosition !== iScrollPosition) {
            this._scrollPosition = iScrollPosition;
            this._refreshComputedValues();
            return true;
        }
        return false;
    };
    ScrollbarState._computeValues = function (oppositeScrollbarSize, arrowSize, visibleSize, scrollSize, scrollPosition) {
        var computedAvailableSize = Math.max(0, visibleSize - oppositeScrollbarSize);
        var computedRepresentableSize = Math.max(0, computedAvailableSize - 2 * arrowSize);
        var computedIsNeeded = (scrollSize > 0 && scrollSize > visibleSize);
        if (!computedIsNeeded) {
            // There is no need for a slider
            return {
                computedAvailableSize: Math.round(computedAvailableSize),
                computedIsNeeded: computedIsNeeded,
                computedSliderSize: Math.round(computedRepresentableSize),
                computedSliderRatio: 0,
                computedSliderPosition: 0,
            };
        }
        // We must artificially increase the size of the slider if needed, since the slider would be too small to grab with the mouse otherwise
        var computedSliderSize = Math.round(Math.max(MINIMUM_SLIDER_SIZE, Math.floor(visibleSize * computedRepresentableSize / scrollSize)));
        // The slider can move from 0 to `computedRepresentableSize` - `computedSliderSize`
        // in the same way `scrollPosition` can move from 0 to `scrollSize` - `visibleSize`.
        var computedSliderRatio = (computedRepresentableSize - computedSliderSize) / (scrollSize - visibleSize);
        var computedSliderPosition = (scrollPosition * computedSliderRatio);
        return {
            computedAvailableSize: Math.round(computedAvailableSize),
            computedIsNeeded: computedIsNeeded,
            computedSliderSize: Math.round(computedSliderSize),
            computedSliderRatio: computedSliderRatio,
            computedSliderPosition: Math.round(computedSliderPosition),
        };
    };
    ScrollbarState.prototype._refreshComputedValues = function () {
        var r = ScrollbarState._computeValues(this._oppositeScrollbarSize, this._arrowSize, this._visibleSize, this._scrollSize, this._scrollPosition);
        this._computedAvailableSize = r.computedAvailableSize;
        this._computedIsNeeded = r.computedIsNeeded;
        this._computedSliderSize = r.computedSliderSize;
        this._computedSliderRatio = r.computedSliderRatio;
        this._computedSliderPosition = r.computedSliderPosition;
    };
    ScrollbarState.prototype.getArrowSize = function () {
        return this._arrowSize;
    };
    ScrollbarState.prototype.getScrollPosition = function () {
        return this._scrollPosition;
    };
    ScrollbarState.prototype.getRectangleLargeSize = function () {
        return this._computedAvailableSize;
    };
    ScrollbarState.prototype.getRectangleSmallSize = function () {
        return this._scrollbarSize;
    };
    ScrollbarState.prototype.isNeeded = function () {
        return this._computedIsNeeded;
    };
    ScrollbarState.prototype.getSliderSize = function () {
        return this._computedSliderSize;
    };
    ScrollbarState.prototype.getSliderPosition = function () {
        return this._computedSliderPosition;
    };
    /**
     * Compute a desired `scrollPosition` such that `offset` ends up in the center of the slider.
     * `offset` is based on the same coordinate system as the `sliderPosition`.
     */
    ScrollbarState.prototype.getDesiredScrollPositionFromOffset = function (offset) {
        if (!this._computedIsNeeded) {
            // no need for a slider
            return 0;
        }
        var desiredSliderPosition = offset - this._arrowSize - this._computedSliderSize / 2;
        return Math.round(desiredSliderPosition / this._computedSliderRatio);
    };
    /**
     * Compute a desired `scrollPosition` such that the slider moves by `delta`.
     */
    ScrollbarState.prototype.getDesiredScrollPositionFromDelta = function (delta) {
        if (!this._computedIsNeeded) {
            // no need for a slider
            return 0;
        }
        var desiredSliderPosition = this._computedSliderPosition + delta;
        return Math.round(desiredSliderPosition / this._computedSliderRatio);
    };
    return ScrollbarState;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$Y = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var HorizontalScrollbar = /** @class */ (function (_super) {
    __extends$Y(HorizontalScrollbar, _super);
    function HorizontalScrollbar(scrollable, options, host) {
        var _this = _super.call(this, {
            lazyRender: options.lazyRender,
            host: host,
            scrollbarState: new ScrollbarState((options.horizontalHasArrows ? options.arrowSize : 0), (options.horizontal === ScrollbarVisibility.Hidden ? 0 : options.horizontalScrollbarSize), (options.vertical === ScrollbarVisibility.Hidden ? 0 : options.verticalScrollbarSize)),
            visibility: options.horizontal,
            extraScrollbarClassName: 'horizontal',
            scrollable: scrollable
        }) || this;
        if (options.horizontalHasArrows) {
            var arrowDelta = (options.arrowSize - ARROW_IMG_SIZE) / 2;
            var scrollbarDelta = (options.horizontalScrollbarSize - ARROW_IMG_SIZE) / 2;
            _this._createArrow({
                className: 'left-arrow',
                top: scrollbarDelta,
                left: arrowDelta,
                bottom: void 0,
                right: void 0,
                bgWidth: options.arrowSize,
                bgHeight: options.horizontalScrollbarSize,
                onActivate: function () { return _this._host.onMouseWheel(new StandardMouseWheelEvent(null, 1, 0)); },
            });
            _this._createArrow({
                className: 'right-arrow',
                top: scrollbarDelta,
                left: void 0,
                bottom: void 0,
                right: arrowDelta,
                bgWidth: options.arrowSize,
                bgHeight: options.horizontalScrollbarSize,
                onActivate: function () { return _this._host.onMouseWheel(new StandardMouseWheelEvent(null, -1, 0)); },
            });
        }
        _this._createSlider(Math.floor((options.horizontalScrollbarSize - options.horizontalSliderSize) / 2), 0, null, options.horizontalSliderSize);
        return _this;
    }
    HorizontalScrollbar.prototype._updateSlider = function (sliderSize, sliderPosition) {
        this.slider.setWidth(sliderSize);
        this.slider.setLeft(sliderPosition);
    };
    HorizontalScrollbar.prototype._renderDomNode = function (largeSize, smallSize) {
        this.domNode.setWidth(largeSize);
        this.domNode.setHeight(smallSize);
        this.domNode.setLeft(0);
        this.domNode.setBottom(0);
    };
    HorizontalScrollbar.prototype.onDidScroll = function (e) {
        this._shouldRender = this._onElementScrollSize(e.scrollWidth) || this._shouldRender;
        this._shouldRender = this._onElementScrollPosition(e.scrollLeft) || this._shouldRender;
        this._shouldRender = this._onElementSize(e.width) || this._shouldRender;
        return this._shouldRender;
    };
    HorizontalScrollbar.prototype._mouseDownRelativePosition = function (offsetX, offsetY) {
        return offsetX;
    };
    HorizontalScrollbar.prototype._sliderMousePosition = function (e) {
        return e.posx;
    };
    HorizontalScrollbar.prototype._sliderOrthogonalMousePosition = function (e) {
        return e.posy;
    };
    HorizontalScrollbar.prototype.writeScrollPosition = function (target, scrollPosition) {
        target.scrollLeft = scrollPosition;
    };
    return HorizontalScrollbar;
}(AbstractScrollbar));

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$Z = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var VerticalScrollbar = /** @class */ (function (_super) {
    __extends$Z(VerticalScrollbar, _super);
    function VerticalScrollbar(scrollable, options, host) {
        var _this = _super.call(this, {
            lazyRender: options.lazyRender,
            host: host,
            scrollbarState: new ScrollbarState((options.verticalHasArrows ? options.arrowSize : 0), (options.vertical === ScrollbarVisibility.Hidden ? 0 : options.verticalScrollbarSize), 
            // give priority to vertical scroll bar over horizontal and let it scroll all the way to the bottom
            0),
            visibility: options.vertical,
            extraScrollbarClassName: 'vertical',
            scrollable: scrollable
        }) || this;
        if (options.verticalHasArrows) {
            var arrowDelta = (options.arrowSize - ARROW_IMG_SIZE) / 2;
            var scrollbarDelta = (options.verticalScrollbarSize - ARROW_IMG_SIZE) / 2;
            _this._createArrow({
                className: 'up-arrow',
                top: arrowDelta,
                left: scrollbarDelta,
                bottom: void 0,
                right: void 0,
                bgWidth: options.verticalScrollbarSize,
                bgHeight: options.arrowSize,
                onActivate: function () { return _this._host.onMouseWheel(new StandardMouseWheelEvent(null, 0, 1)); },
            });
            _this._createArrow({
                className: 'down-arrow',
                top: void 0,
                left: scrollbarDelta,
                bottom: arrowDelta,
                right: void 0,
                bgWidth: options.verticalScrollbarSize,
                bgHeight: options.arrowSize,
                onActivate: function () { return _this._host.onMouseWheel(new StandardMouseWheelEvent(null, 0, -1)); },
            });
        }
        _this._createSlider(0, Math.floor((options.verticalScrollbarSize - options.verticalSliderSize) / 2), options.verticalSliderSize, null);
        return _this;
    }
    VerticalScrollbar.prototype._updateSlider = function (sliderSize, sliderPosition) {
        this.slider.setHeight(sliderSize);
        this.slider.setTop(sliderPosition);
    };
    VerticalScrollbar.prototype._renderDomNode = function (largeSize, smallSize) {
        this.domNode.setWidth(smallSize);
        this.domNode.setHeight(largeSize);
        this.domNode.setRight(0);
        this.domNode.setTop(0);
    };
    VerticalScrollbar.prototype.onDidScroll = function (e) {
        this._shouldRender = this._onElementScrollSize(e.scrollHeight) || this._shouldRender;
        this._shouldRender = this._onElementScrollPosition(e.scrollTop) || this._shouldRender;
        this._shouldRender = this._onElementSize(e.height) || this._shouldRender;
        return this._shouldRender;
    };
    VerticalScrollbar.prototype._mouseDownRelativePosition = function (offsetX, offsetY) {
        return offsetY;
    };
    VerticalScrollbar.prototype._sliderMousePosition = function (e) {
        return e.posy;
    };
    VerticalScrollbar.prototype._sliderOrthogonalMousePosition = function (e) {
        return e.posx;
    };
    VerticalScrollbar.prototype.writeScrollPosition = function (target, scrollPosition) {
        target.scrollTop = scrollPosition;
    };
    return VerticalScrollbar;
}(AbstractScrollbar));

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$_ = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var HIDE_TIMEOUT = 500;
var SCROLL_WHEEL_SENSITIVITY = 50;
var MouseWheelClassifierItem = /** @class */ (function () {
    function MouseWheelClassifierItem(timestamp, deltaX, deltaY) {
        this.timestamp = timestamp;
        this.deltaX = deltaX;
        this.deltaY = deltaY;
        this.score = 0;
    }
    return MouseWheelClassifierItem;
}());
var MouseWheelClassifier = /** @class */ (function () {
    function MouseWheelClassifier() {
        this._capacity = 5;
        this._memory = [];
        this._front = -1;
        this._rear = -1;
    }
    MouseWheelClassifier.prototype.isPhysicalMouseWheel = function () {
        if (this._front === -1 && this._rear === -1) {
            // no elements
            return false;
        }
        // 0.5 * last + 0.25 * before last + 0.125 * before before last + ...
        var remainingInfluence = 1;
        var score = 0;
        var iteration = 1;
        var index = this._rear;
        do {
            var influence = (index === this._front ? remainingInfluence : Math.pow(2, -iteration));
            remainingInfluence -= influence;
            score += this._memory[index].score * influence;
            if (index === this._front) {
                break;
            }
            index = (this._capacity + index - 1) % this._capacity;
            iteration++;
        } while (true);
        return (score <= 0.5);
    };
    MouseWheelClassifier.prototype.accept = function (timestamp, deltaX, deltaY) {
        var item = new MouseWheelClassifierItem(timestamp, deltaX, deltaY);
        item.score = this._computeScore(item);
        if (this._front === -1 && this._rear === -1) {
            this._memory[0] = item;
            this._front = 0;
            this._rear = 0;
        }
        else {
            this._rear = (this._rear + 1) % this._capacity;
            if (this._rear === this._front) {
                // Drop oldest
                this._front = (this._front + 1) % this._capacity;
            }
            this._memory[this._rear] = item;
        }
    };
    /**
     * A score between 0 and 1 for `item`.
     *  - a score towards 0 indicates that the source appears to be a physical mouse wheel
     *  - a score towards 1 indicates that the source appears to be a touchpad or magic mouse, etc.
     */
    MouseWheelClassifier.prototype._computeScore = function (item) {
        if (Math.abs(item.deltaX) > 0 && Math.abs(item.deltaY) > 0) {
            // both axes exercised => definitely not a physical mouse wheel
            return 1;
        }
        var score = 0.5;
        var prev = (this._front === -1 && this._rear === -1 ? null : this._memory[this._rear]);
        if (Math.abs(item.deltaX - Math.round(item.deltaX)) > 0 || Math.abs(item.deltaY - Math.round(item.deltaY)) > 0) {
            // non-integer deltas => indicator that this is not a physical mouse wheel
            score += 0.25;
        }
        return Math.min(Math.max(score, 0), 1);
    };
    MouseWheelClassifier.INSTANCE = new MouseWheelClassifier();
    return MouseWheelClassifier;
}());
var AbstractScrollableElement = /** @class */ (function (_super) {
    __extends$_(AbstractScrollableElement, _super);
    function AbstractScrollableElement(element, options, scrollable) {
        var _this = _super.call(this) || this;
        _this._onScroll = _this._register(new Emitter());
        _this.onScroll = _this._onScroll.event;
        element.style.overflow = 'hidden';
        _this._options = resolveOptions(options);
        _this._scrollable = scrollable;
        _this._register(_this._scrollable.onScroll(function (e) {
            _this._onDidScroll(e);
            _this._onScroll.fire(e);
        }));
        var scrollbarHost = {
            onMouseWheel: function (mouseWheelEvent) { return _this._onMouseWheel(mouseWheelEvent); },
            onDragStart: function () { return _this._onDragStart(); },
            onDragEnd: function () { return _this._onDragEnd(); },
        };
        _this._verticalScrollbar = _this._register(new VerticalScrollbar(_this._scrollable, _this._options, scrollbarHost));
        _this._horizontalScrollbar = _this._register(new HorizontalScrollbar(_this._scrollable, _this._options, scrollbarHost));
        _this._domNode = document.createElement('div');
        _this._domNode.className = 'monaco-scrollable-element ' + _this._options.className;
        _this._domNode.setAttribute('role', 'presentation');
        _this._domNode.style.position = 'relative';
        _this._domNode.style.overflow = 'hidden';
        _this._domNode.appendChild(element);
        _this._domNode.appendChild(_this._horizontalScrollbar.domNode.domNode);
        _this._domNode.appendChild(_this._verticalScrollbar.domNode.domNode);
        if (_this._options.useShadows) {
            _this._leftShadowDomNode = createFastDomNode(document.createElement('div'));
            _this._leftShadowDomNode.setClassName('shadow');
            _this._domNode.appendChild(_this._leftShadowDomNode.domNode);
            _this._topShadowDomNode = createFastDomNode(document.createElement('div'));
            _this._topShadowDomNode.setClassName('shadow');
            _this._domNode.appendChild(_this._topShadowDomNode.domNode);
            _this._topLeftShadowDomNode = createFastDomNode(document.createElement('div'));
            _this._topLeftShadowDomNode.setClassName('shadow top-left-corner');
            _this._domNode.appendChild(_this._topLeftShadowDomNode.domNode);
        }
        _this._listenOnDomNode = _this._options.listenOnDomNode || _this._domNode;
        _this._mouseWheelToDispose = [];
        _this._setListeningToMouseWheel(_this._options.handleMouseWheel);
        _this.onmouseover(_this._listenOnDomNode, function (e) { return _this._onMouseOver(e); });
        _this.onnonbubblingmouseout(_this._listenOnDomNode, function (e) { return _this._onMouseOut(e); });
        _this._hideTimeout = _this._register(new TimeoutTimer());
        _this._isDragging = false;
        _this._mouseIsOver = false;
        _this._shouldRender = true;
        return _this;
    }
    AbstractScrollableElement.prototype.dispose = function () {
        this._mouseWheelToDispose = dispose(this._mouseWheelToDispose);
        _super.prototype.dispose.call(this);
    };
    /**
     * Get the generated 'scrollable' dom node
     */
    AbstractScrollableElement.prototype.getDomNode = function () {
        return this._domNode;
    };
    AbstractScrollableElement.prototype.getOverviewRulerLayoutInfo = function () {
        return {
            parent: this._domNode,
            insertBefore: this._verticalScrollbar.domNode.domNode,
        };
    };
    /**
     * Delegate a mouse down event to the vertical scrollbar.
     * This is to help with clicking somewhere else and having the scrollbar react.
     */
    AbstractScrollableElement.prototype.delegateVerticalScrollbarMouseDown = function (browserEvent) {
        this._verticalScrollbar.delegateMouseDown(browserEvent);
    };
    AbstractScrollableElement.prototype.getScrollDimensions = function () {
        return this._scrollable.getScrollDimensions();
    };
    AbstractScrollableElement.prototype.setScrollDimensions = function (dimensions) {
        this._scrollable.setScrollDimensions(dimensions);
    };
    /**
     * Update the class name of the scrollable element.
     */
    AbstractScrollableElement.prototype.updateClassName = function (newClassName) {
        this._options.className = newClassName;
        // Defaults are different on Macs
        if (isMacintosh) {
            this._options.className += ' mac';
        }
        this._domNode.className = 'monaco-scrollable-element ' + this._options.className;
    };
    /**
     * Update configuration options for the scrollbar.
     * Really this is Editor.IEditorScrollbarOptions, but base shouldn't
     * depend on Editor.
     */
    AbstractScrollableElement.prototype.updateOptions = function (newOptions) {
        var massagedOptions = resolveOptions(newOptions);
        this._options.handleMouseWheel = massagedOptions.handleMouseWheel;
        this._options.mouseWheelScrollSensitivity = massagedOptions.mouseWheelScrollSensitivity;
        this._setListeningToMouseWheel(this._options.handleMouseWheel);
        if (!this._options.lazyRender) {
            this._render();
        }
    };
    // -------------------- mouse wheel scrolling --------------------
    AbstractScrollableElement.prototype._setListeningToMouseWheel = function (shouldListen) {
        var _this = this;
        var isListening = (this._mouseWheelToDispose.length > 0);
        if (isListening === shouldListen) {
            // No change
            return;
        }
        // Stop listening (if necessary)
        this._mouseWheelToDispose = dispose(this._mouseWheelToDispose);
        // Start listening (if necessary)
        if (shouldListen) {
            var onMouseWheel = function (browserEvent) {
                var e = new StandardMouseWheelEvent(browserEvent);
                _this._onMouseWheel(e);
            };
            this._mouseWheelToDispose.push(addDisposableListener(this._listenOnDomNode, 'mousewheel', onMouseWheel));
            this._mouseWheelToDispose.push(addDisposableListener(this._listenOnDomNode, 'DOMMouseScroll', onMouseWheel));
        }
    };
    AbstractScrollableElement.prototype._onMouseWheel = function (e) {
        var classifier = MouseWheelClassifier.INSTANCE;
        {
            classifier.accept(Date.now(), e.deltaX, e.deltaY);
        }
        // console.log(`${Date.now()}, ${e.deltaY}, ${e.deltaX}`);
        if (e.deltaY || e.deltaX) {
            var deltaY = e.deltaY * this._options.mouseWheelScrollSensitivity;
            var deltaX = e.deltaX * this._options.mouseWheelScrollSensitivity;
            if (this._options.flipAxes) {
                _a = [deltaX, deltaY], deltaY = _a[0], deltaX = _a[1];
            }
            // Convert vertical scrolling to horizontal if shift is held, this
            // is handled at a higher level on Mac
            var shiftConvert = !isMacintosh && e.browserEvent && e.browserEvent.shiftKey;
            if ((this._options.scrollYToX || shiftConvert) && !deltaX) {
                deltaX = deltaY;
                deltaY = 0;
            }
            var futureScrollPosition = this._scrollable.getFutureScrollPosition();
            var desiredScrollPosition = {};
            if (deltaY) {
                var desiredScrollTop = futureScrollPosition.scrollTop - SCROLL_WHEEL_SENSITIVITY * deltaY;
                this._verticalScrollbar.writeScrollPosition(desiredScrollPosition, desiredScrollTop);
            }
            if (deltaX) {
                var desiredScrollLeft = futureScrollPosition.scrollLeft - SCROLL_WHEEL_SENSITIVITY * deltaX;
                this._horizontalScrollbar.writeScrollPosition(desiredScrollPosition, desiredScrollLeft);
            }
            // Check that we are scrolling towards a location which is valid
            desiredScrollPosition = this._scrollable.validateScrollPosition(desiredScrollPosition);
            if (futureScrollPosition.scrollLeft !== desiredScrollPosition.scrollLeft || futureScrollPosition.scrollTop !== desiredScrollPosition.scrollTop) {
                var canPerformSmoothScroll = (this._options.mouseWheelSmoothScroll
                    && classifier.isPhysicalMouseWheel());
                if (canPerformSmoothScroll) {
                    this._scrollable.setScrollPositionSmooth(desiredScrollPosition);
                }
                else {
                    this._scrollable.setScrollPositionNow(desiredScrollPosition);
                }
                this._shouldRender = true;
            }
        }
        if (this._options.alwaysConsumeMouseWheel || this._shouldRender) {
            e.preventDefault();
            e.stopPropagation();
        }
        var _a;
    };
    AbstractScrollableElement.prototype._onDidScroll = function (e) {
        this._shouldRender = this._horizontalScrollbar.onDidScroll(e) || this._shouldRender;
        this._shouldRender = this._verticalScrollbar.onDidScroll(e) || this._shouldRender;
        if (this._options.useShadows) {
            this._shouldRender = true;
        }
        this._reveal();
        if (!this._options.lazyRender) {
            this._render();
        }
    };
    /**
     * Render / mutate the DOM now.
     * Should be used together with the ctor option `lazyRender`.
     */
    AbstractScrollableElement.prototype.renderNow = function () {
        if (!this._options.lazyRender) {
            throw new Error('Please use `lazyRender` together with `renderNow`!');
        }
        this._render();
    };
    AbstractScrollableElement.prototype._render = function () {
        if (!this._shouldRender) {
            return;
        }
        this._shouldRender = false;
        this._horizontalScrollbar.render();
        this._verticalScrollbar.render();
        if (this._options.useShadows) {
            var scrollState = this._scrollable.getCurrentScrollPosition();
            var enableTop = scrollState.scrollTop > 0;
            var enableLeft = scrollState.scrollLeft > 0;
            this._leftShadowDomNode.setClassName('shadow' + (enableLeft ? ' left' : ''));
            this._topShadowDomNode.setClassName('shadow' + (enableTop ? ' top' : ''));
            this._topLeftShadowDomNode.setClassName('shadow top-left-corner' + (enableTop ? ' top' : '') + (enableLeft ? ' left' : ''));
        }
    };
    // -------------------- fade in / fade out --------------------
    AbstractScrollableElement.prototype._onDragStart = function () {
        this._isDragging = true;
        this._reveal();
    };
    AbstractScrollableElement.prototype._onDragEnd = function () {
        this._isDragging = false;
        this._hide();
    };
    AbstractScrollableElement.prototype._onMouseOut = function (e) {
        this._mouseIsOver = false;
        this._hide();
    };
    AbstractScrollableElement.prototype._onMouseOver = function (e) {
        this._mouseIsOver = true;
        this._reveal();
    };
    AbstractScrollableElement.prototype._reveal = function () {
        this._verticalScrollbar.beginReveal();
        this._horizontalScrollbar.beginReveal();
        this._scheduleHide();
    };
    AbstractScrollableElement.prototype._hide = function () {
        if (!this._mouseIsOver && !this._isDragging) {
            this._verticalScrollbar.beginHide();
            this._horizontalScrollbar.beginHide();
        }
    };
    AbstractScrollableElement.prototype._scheduleHide = function () {
        var _this = this;
        if (!this._mouseIsOver && !this._isDragging) {
            this._hideTimeout.cancelAndSet(function () { return _this._hide(); }, HIDE_TIMEOUT);
        }
    };
    return AbstractScrollableElement;
}(Widget$1));
var ScrollableElement = /** @class */ (function (_super) {
    __extends$_(ScrollableElement, _super);
    function ScrollableElement(element, options) {
        var _this = this;
        options = options || {};
        options.mouseWheelSmoothScroll = false;
        var scrollable = new Scrollable(0, function (callback) { return scheduleAtNextAnimationFrame(callback); });
        _this = _super.call(this, element, options, scrollable) || this;
        _this._register(scrollable);
        return _this;
    }
    ScrollableElement.prototype.setScrollPosition = function (update) {
        this._scrollable.setScrollPositionNow(update);
    };
    ScrollableElement.prototype.getScrollPosition = function () {
        return this._scrollable.getCurrentScrollPosition();
    };
    return ScrollableElement;
}(AbstractScrollableElement));
var SmoothScrollableElement = /** @class */ (function (_super) {
    __extends$_(SmoothScrollableElement, _super);
    function SmoothScrollableElement(element, options, scrollable) {
        return _super.call(this, element, options, scrollable) || this;
    }
    return SmoothScrollableElement;
}(AbstractScrollableElement));
var DomScrollableElement = /** @class */ (function (_super) {
    __extends$_(DomScrollableElement, _super);
    function DomScrollableElement(element, options) {
        var _this = _super.call(this, element, options) || this;
        _this._element = element;
        _this.onScroll(function (e) {
            if (e.scrollTopChanged) {
                _this._element.scrollTop = e.scrollTop;
            }
            if (e.scrollLeftChanged) {
                _this._element.scrollLeft = e.scrollLeft;
            }
        });
        _this.scanDomNode();
        return _this;
    }
    DomScrollableElement.prototype.scanDomNode = function () {
        // widh, scrollLeft, scrollWidth, height, scrollTop, scrollHeight
        this.setScrollDimensions({
            width: this._element.clientWidth,
            scrollWidth: this._element.scrollWidth,
            height: this._element.clientHeight,
            scrollHeight: this._element.scrollHeight
        });
        this.setScrollPosition({
            scrollLeft: this._element.scrollLeft,
            scrollTop: this._element.scrollTop,
        });
    };
    return DomScrollableElement;
}(ScrollableElement));
function resolveOptions(opts) {
    var result = {
        lazyRender: (typeof opts.lazyRender !== 'undefined' ? opts.lazyRender : false),
        className: (typeof opts.className !== 'undefined' ? opts.className : ''),
        useShadows: (typeof opts.useShadows !== 'undefined' ? opts.useShadows : true),
        handleMouseWheel: (typeof opts.handleMouseWheel !== 'undefined' ? opts.handleMouseWheel : true),
        flipAxes: (typeof opts.flipAxes !== 'undefined' ? opts.flipAxes : false),
        alwaysConsumeMouseWheel: (typeof opts.alwaysConsumeMouseWheel !== 'undefined' ? opts.alwaysConsumeMouseWheel : false),
        scrollYToX: (typeof opts.scrollYToX !== 'undefined' ? opts.scrollYToX : false),
        mouseWheelScrollSensitivity: (typeof opts.mouseWheelScrollSensitivity !== 'undefined' ? opts.mouseWheelScrollSensitivity : 1),
        mouseWheelSmoothScroll: (typeof opts.mouseWheelSmoothScroll !== 'undefined' ? opts.mouseWheelSmoothScroll : true),
        arrowSize: (typeof opts.arrowSize !== 'undefined' ? opts.arrowSize : 11),
        listenOnDomNode: (typeof opts.listenOnDomNode !== 'undefined' ? opts.listenOnDomNode : null),
        horizontal: (typeof opts.horizontal !== 'undefined' ? opts.horizontal : ScrollbarVisibility.Auto),
        horizontalScrollbarSize: (typeof opts.horizontalScrollbarSize !== 'undefined' ? opts.horizontalScrollbarSize : 10),
        horizontalSliderSize: (typeof opts.horizontalSliderSize !== 'undefined' ? opts.horizontalSliderSize : 0),
        horizontalHasArrows: (typeof opts.horizontalHasArrows !== 'undefined' ? opts.horizontalHasArrows : false),
        vertical: (typeof opts.vertical !== 'undefined' ? opts.vertical : ScrollbarVisibility.Auto),
        verticalScrollbarSize: (typeof opts.verticalScrollbarSize !== 'undefined' ? opts.verticalScrollbarSize : 10),
        verticalHasArrows: (typeof opts.verticalHasArrows !== 'undefined' ? opts.verticalHasArrows : false),
        verticalSliderSize: (typeof opts.verticalSliderSize !== 'undefined' ? opts.verticalSliderSize : 0)
    };
    result.horizontalSliderSize = (typeof opts.horizontalSliderSize !== 'undefined' ? opts.horizontalSliderSize : result.horizontalScrollbarSize);
    result.verticalSliderSize = (typeof opts.verticalSliderSize !== 'undefined' ? opts.verticalSliderSize : result.verticalScrollbarSize);
    // Defaults are different on Macs
    if (isMacintosh) {
        result.className += ' mac';
    }
    return result;
}

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$10 = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var EditorScrollbar = /** @class */ (function (_super) {
    __extends$10(EditorScrollbar, _super);
    function EditorScrollbar(context, linesContent, viewDomNode, overflowGuardDomNode) {
        var _this = _super.call(this, context) || this;
        var editor = _this._context.configuration.editor;
        var configScrollbarOpts = editor.viewInfo.scrollbar;
        var scrollbarOptions = {
            listenOnDomNode: viewDomNode.domNode,
            className: 'editor-scrollable' + ' ' + getThemeTypeSelector(context.theme.type),
            useShadows: false,
            lazyRender: true,
            vertical: configScrollbarOpts.vertical,
            horizontal: configScrollbarOpts.horizontal,
            verticalHasArrows: configScrollbarOpts.verticalHasArrows,
            horizontalHasArrows: configScrollbarOpts.horizontalHasArrows,
            verticalScrollbarSize: configScrollbarOpts.verticalScrollbarSize,
            verticalSliderSize: configScrollbarOpts.verticalSliderSize,
            horizontalScrollbarSize: configScrollbarOpts.horizontalScrollbarSize,
            horizontalSliderSize: configScrollbarOpts.horizontalSliderSize,
            handleMouseWheel: configScrollbarOpts.handleMouseWheel,
            arrowSize: configScrollbarOpts.arrowSize,
            mouseWheelScrollSensitivity: configScrollbarOpts.mouseWheelScrollSensitivity,
        };
        _this.scrollbar = _this._register(new SmoothScrollableElement(linesContent.domNode, scrollbarOptions, _this._context.viewLayout.scrollable));
        PartFingerprints.write(_this.scrollbar.getDomNode(), 5 /* ScrollableElement */);
        _this.scrollbarDomNode = createFastDomNode(_this.scrollbar.getDomNode());
        _this.scrollbarDomNode.setPosition('absolute');
        _this._setLayout();
        // When having a zone widget that calls .focus() on one of its dom elements,
        // the browser will try desperately to reveal that dom node, unexpectedly
        // changing the .scrollTop of this.linesContent
        var onBrowserDesperateReveal = function (domNode, lookAtScrollTop, lookAtScrollLeft) {
            var newScrollPosition = {};
            if (lookAtScrollTop) {
                var deltaTop = domNode.scrollTop;
                if (deltaTop) {
                    newScrollPosition.scrollTop = _this._context.viewLayout.getCurrentScrollTop() + deltaTop;
                    domNode.scrollTop = 0;
                }
            }
            if (lookAtScrollLeft) {
                var deltaLeft = domNode.scrollLeft;
                if (deltaLeft) {
                    newScrollPosition.scrollLeft = _this._context.viewLayout.getCurrentScrollLeft() + deltaLeft;
                    domNode.scrollLeft = 0;
                }
            }
            _this._context.viewLayout.setScrollPositionNow(newScrollPosition);
        };
        // I've seen this happen both on the view dom node & on the lines content dom node.
        _this._register(addDisposableListener(viewDomNode.domNode, 'scroll', function (e) { return onBrowserDesperateReveal(viewDomNode.domNode, true, true); }));
        _this._register(addDisposableListener(linesContent.domNode, 'scroll', function (e) { return onBrowserDesperateReveal(linesContent.domNode, true, false); }));
        _this._register(addDisposableListener(overflowGuardDomNode.domNode, 'scroll', function (e) { return onBrowserDesperateReveal(overflowGuardDomNode.domNode, true, false); }));
        _this._register(addDisposableListener(_this.scrollbarDomNode.domNode, 'scroll', function (e) { return onBrowserDesperateReveal(_this.scrollbarDomNode.domNode, true, false); }));
        return _this;
    }
    EditorScrollbar.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
    };
    EditorScrollbar.prototype._setLayout = function () {
        var layoutInfo = this._context.configuration.editor.layoutInfo;
        this.scrollbarDomNode.setLeft(layoutInfo.contentLeft);
        var side = this._context.configuration.editor.viewInfo.minimap.side;
        if (side === 'right') {
            this.scrollbarDomNode.setWidth(layoutInfo.contentWidth + layoutInfo.minimapWidth);
        }
        else {
            this.scrollbarDomNode.setWidth(layoutInfo.contentWidth);
        }
        this.scrollbarDomNode.setHeight(layoutInfo.contentHeight);
    };
    EditorScrollbar.prototype.getOverviewRulerLayoutInfo = function () {
        return this.scrollbar.getOverviewRulerLayoutInfo();
    };
    EditorScrollbar.prototype.getDomNode = function () {
        return this.scrollbarDomNode;
    };
    EditorScrollbar.prototype.delegateVerticalScrollbarMouseDown = function (browserEvent) {
        this.scrollbar.delegateVerticalScrollbarMouseDown(browserEvent);
    };
    // --- begin event handlers
    EditorScrollbar.prototype.onConfigurationChanged = function (e) {
        if (e.viewInfo) {
            var editor = this._context.configuration.editor;
            var newOpts = {
                handleMouseWheel: editor.viewInfo.scrollbar.handleMouseWheel,
                mouseWheelScrollSensitivity: editor.viewInfo.scrollbar.mouseWheelScrollSensitivity
            };
            this.scrollbar.updateOptions(newOpts);
        }
        if (e.layoutInfo) {
            this._setLayout();
        }
        return true;
    };
    EditorScrollbar.prototype.onScrollChanged = function (e) {
        return true;
    };
    EditorScrollbar.prototype.onThemeChanged = function (e) {
        this.scrollbar.updateClassName('editor-scrollable' + ' ' + getThemeTypeSelector(this._context.theme.type));
        return true;
    };
    // --- end event handlers
    EditorScrollbar.prototype.prepareRender = function (ctx) {
        // Nothing to do
    };
    EditorScrollbar.prototype.render = function (ctx) {
        this.scrollbar.renderNow();
    };
    return EditorScrollbar;
}(ViewPart));

const css$j = "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n/* START cover the case that slider is visible on mouseover */\n.monaco-editor .minimap.slider-mouseover .minimap-slider {\n\topacity: 0;\n\ttransition: opacity 100ms linear;\n}\n.monaco-editor .minimap.slider-mouseover:hover .minimap-slider {\n\topacity: 1;\n}\n.monaco-editor .minimap.slider-mouseover .minimap-slider.active {\n\topacity: 1;\n}\n/* END cover the case that slider is visible on mouseover */\n\n.monaco-editor .minimap-shadow-hidden {\n\tposition: absolute;\n\twidth: 0;\n}\n.monaco-editor .minimap-shadow-visible {\n\tposition: absolute;\n\tleft: -6px;\n\twidth: 6px;\n}\n";
  const element$j = ((css, src) => {
if (typeof document !== 'object')
console.info(`Skipped loading "${src}"`);
try {
const id = src
  .replace(/\.css.*$/, '')
  .replace(/[\\:]/g, '/')
  .replace(/[^\w\/]+/g, '');
return (
  document.querySelector(`style[id="${id}"]`) ||
  document.head.appendChild(
    Object.assign(document.createElement('style'), {
      id,
      textContent: `${css}\n\n /* sourceURL=${src} */`,
    }),
  )
);
} catch (exception) {
console.warn(`Failed load "${src}"`, exception);
}
})(css$j, "…monaco-editor/esm/vs/editor/browser/viewParts/minimap/minimap.css");
  //@ sourceURL=/Users/daflair/Projects/packages/monaco-es/node_modules/monaco-editor/esm/vs/editor/browser/viewParts/minimap/minimap.css

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
function toUint8ClampedArrat(arr) {
    var r = new Uint8ClampedArray(arr.length);
    for (var i = 0, len = arr.length; i < len; i++) {
        r[i] = arr[i];
    }
    return r;
}
var minimapCharRenderer = null;
function getOrCreateMinimapCharRenderer() {
    if (!minimapCharRenderer) {
        var _x1Data = toUint8ClampedArrat(x1Data);
        x1Data = null;
        var _x2Data = toUint8ClampedArrat(x2Data);
        x2Data = null;
        minimapCharRenderer = new MinimapCharRenderer(_x2Data, _x1Data);
    }
    return minimapCharRenderer;
}
var x2Data = [
    //
    0, 0,
    0, 0,
    0, 0,
    0, 0,
    // !
    39, 14,
    39, 14,
    14, 5,
    29, 10,
    // "
    96, 96,
    29, 29,
    0, 0,
    0, 0,
    // #
    49, 113,
    195, 214,
    227, 166,
    135, 42,
    // $
    40, 29,
    194, 38,
    75, 148,
    197, 187,
    // %
    145, 0,
    160, 61,
    75, 143,
    2, 183,
    // &
    138, 58,
    163, 6,
    177, 223,
    197, 227,
    // '
    38, 13,
    11, 4,
    0, 0,
    0, 0,
    // (
    10, 54,
    52, 8,
    62, 4,
    71, 122,
    // )
    73, 2,
    19, 40,
    10, 50,
    155, 36,
    // *
    79, 70,
    145, 121,
    7, 5,
    0, 0,
    // +
    2, 1,
    36, 12,
    204, 166,
    16, 5,
    // ,
    0, 0,
    0, 0,
    1, 0,
    154, 34,
    // -
    0, 0,
    0, 0,
    96, 83,
    0, 0,
    // .
    0, 0,
    0, 0,
    0, 0,
    46, 34,
    // /
    0, 82,
    2, 56,
    53, 3,
    146, 0,
    // 0
    146, 119,
    152, 132,
    152, 131,
    145, 119,
    // 1
    170, 42,
    15, 42,
    15, 42,
    172, 194,
    // 2
    131, 132,
    0, 139,
    80, 28,
    227, 143,
    // 3
    159, 135,
    15, 118,
    11, 126,
    171, 144,
    // 4
    20, 124,
    88, 106,
    217, 196,
    0, 106,
    // 5
    189, 92,
    168, 43,
    5, 130,
    164, 133,
    // 6
    130, 115,
    183, 65,
    134, 120,
    141, 141,
    // 7
    170, 196,
    2, 106,
    31, 32,
    105, 2,
    // 8
    145, 130,
    116, 114,
    132, 135,
    138, 140,
    // 9
    138, 113,
    147, 137,
    81, 183,
    129, 94,
    // :
    0, 0,
    21, 16,
    4, 3,
    46, 34,
    // ;
    0, 0,
    45, 34,
    1, 0,
    160, 49,
    // <
    0, 0,
    43, 143,
    203, 23,
    1, 76,
    // =
    0, 0,
    38, 28,
    131, 96,
    38, 28,
    // >
    0, 0,
    168, 31,
    29, 191,
    98, 0,
    // ?
    118, 139,
    5, 113,
    45, 13,
    37, 6,
    // @
    97, 115,
    161, 179,
    204, 105,
    223, 224,
    // A
    83, 52,
    111, 100,
    184, 186,
    120, 132,
    // B
    212, 145,
    180, 139,
    174, 161,
    212, 182,
    // C
    104, 162,
    131, 0,
    131, 0,
    104, 161,
    // D
    219, 120,
    110, 116,
    110, 116,
    219, 120,
    // E
    207, 154,
    163, 40,
    147, 22,
    207, 154,
    // F
    202, 159,
    161, 47,
    145, 23,
    111, 0,
    // G
    139, 154,
    144, 30,
    144, 135,
    139, 187,
    // H
    110, 110,
    168, 161,
    150, 145,
    110, 110,
    // I
    185, 162,
    43, 16,
    43, 16,
    185, 162,
    // J
    73, 129,
    0, 110,
    0, 110,
    191, 87,
    // K
    149, 149,
    236, 48,
    195, 91,
    146, 149,
    // L
    146, 0,
    146, 0,
    146, 0,
    187, 173,
    // M
    200, 201,
    222, 215,
    172, 147,
    95, 95,
    // N
    193, 97,
    224, 129,
    159, 206,
    97, 192,
    // O
    155, 139,
    153, 115,
    153, 115,
    156, 140,
    // P
    189, 158,
    123, 136,
    190, 64,
    111, 0,
    // Q
    155, 139,
    153, 115,
    153, 114,
    156, 241,
    // R
    197, 148,
    150, 152,
    170, 116,
    110, 157,
    // S
    156, 128,
    169, 14,
    13, 159,
    158, 149,
    // T
    212, 189,
    43, 16,
    43, 16,
    43, 16,
    // U
    148, 110,
    148, 110,
    147, 109,
    182, 151,
    // V
    133, 121,
    106, 118,
    114, 103,
    89, 66,
    // W
    94, 94,
    211, 188,
    205, 207,
    139, 168,
    // X
    151, 152,
    87, 76,
    101, 79,
    151, 152,
    // Y
    130, 156,
    125, 116,
    47, 29,
    43, 16,
    // Z
    169, 228,
    11, 103,
    120, 6,
    230, 176,
    // [
    55, 49,
    55, 6,
    55, 6,
    193, 102,
    // \
    92, 0,
    71, 0,
    13, 30,
    0, 147,
    // ]
    63, 43,
    12, 43,
    12, 43,
    142, 152,
    // ^
    71, 53,
    61, 61,
    0, 0,
    0, 0,
    // _
    0, 0,
    0, 0,
    0, 0,
    158, 146,
    // `
    25, 2,
    0, 0,
    0, 0,
    0, 0,
    // a
    0, 0,
    107, 130,
    170, 194,
    176, 188,
    // b
    109, 0,
    203, 159,
    113, 111,
    202, 158,
    // c
    0, 0,
    135, 135,
    114, 0,
    136, 135,
    // d
    0, 109,
    187, 190,
    148, 126,
    177, 187,
    // e
    0, 0,
    149, 130,
    218, 105,
    169, 135,
    // f
    37, 113,
    146, 113,
    49, 13,
    49, 13,
    // g
    0, 0,
    178, 195,
    147, 114,
    255, 255,
    // h
    109, 0,
    193, 149,
    110, 109,
    109, 109,
    // i
    12, 15,
    125, 41,
    33, 41,
    144, 188,
    // j
    1, 6,
    75, 53,
    10, 53,
    210, 161,
    // k
    110, 0,
    152, 148,
    210, 60,
    110, 156,
    // l
    213, 5,
    63, 5,
    63, 5,
    45, 111,
    // m
    0, 0,
    232, 172,
    190, 168,
    190, 169,
    // n
    0, 0,
    190, 144,
    109, 109,
    109, 109,
    // o
    0, 0,
    168, 140,
    148, 111,
    168, 140,
    // p
    0, 0,
    200, 151,
    113, 110,
    255, 158,
    // q
    0, 0,
    184, 188,
    147, 139,
    186, 255,
    // r
    0, 0,
    122, 130,
    111, 0,
    109, 0,
    // s
    0, 0,
    132, 69,
    109, 93,
    110, 136,
    // t
    51, 5,
    205, 103,
    61, 6,
    47, 106,
    // u
    0, 0,
    110, 109,
    110, 122,
    155, 179,
    // v
    0, 0,
    132, 120,
    113, 114,
    84, 63,
    // w
    0, 0,
    124, 108,
    202, 189,
    160, 174,
    // x
    0, 0,
    144, 142,
    79, 57,
    159, 146,
    // y
    0, 0,
    138, 138,
    119, 117,
    255, 69,
    // z
    0, 0,
    97, 198,
    47, 38,
    208, 84,
    // {
    23, 112,
    41, 14,
    157, 7,
    121, 192,
    // |
    35, 11,
    35, 11,
    35, 11,
    160, 61,
    // }
    129, 9,
    40, 19,
    20, 139,
    236, 44,
    // ~
    0, 0,
    15, 3,
    97, 93,
    0, 0,
];
var x1Data = [
    //
    0,
    0,
    // !
    23,
    12,
    // "
    53,
    0,
    // #
    130,
    127,
    // $
    58,
    149,
    // %
    67,
    77,
    // &
    72,
    198,
    // '
    13,
    0,
    // (
    25,
    51,
    // )
    25,
    49,
    // *
    94,
    2,
    // +
    8,
    64,
    // ,
    0,
    24,
    // -
    0,
    21,
    // .
    0,
    9,
    // /
    19,
    27,
    // 0
    126,
    126,
    // 1
    51,
    80,
    // 2
    72,
    105,
    // 3
    87,
    98,
    // 4
    73,
    93,
    // 5
    106,
    85,
    // 6
    111,
    123,
    // 7
    87,
    30,
    // 8
    116,
    126,
    // 9
    123,
    110,
    // :
    4,
    16,
    // ;
    9,
    28,
    // <
    21,
    53,
    // =
    8,
    62,
    // >
    23,
    52,
    // ?
    73,
    21,
    // @
    132,
    183,
    // A
    78,
    142,
    // B
    168,
    175,
    // C
    70,
    70,
    // D
    128,
    128,
    // E
    123,
    110,
    // F
    125,
    43,
    // G
    100,
    139,
    // H
    125,
    119,
    // I
    78,
    78,
    // J
    54,
    77,
    // K
    139,
    139,
    // L
    33,
    87,
    // M
    201,
    117,
    // N
    162,
    149,
    // O
    130,
    130,
    // P
    138,
    60,
    // Q
    130,
    172,
    // R
    149,
    127,
    // S
    95,
    98,
    // T
    95,
    25,
    // U
    118,
    135,
    // V
    110,
    85,
    // W
    147,
    175,
    // X
    105,
    110,
    // Y
    121,
    30,
    // Z
    101,
    113,
    // [
    34,
    68,
    // \
    20,
    26,
    // ]
    34,
    68,
    // ^
    56,
    0,
    // _
    0,
    44,
    // `
    3,
    0,
    // a
    27,
    175,
    // b
    80,
    133,
    // c
    31,
    66,
    // d
    85,
    147,
    // e
    32,
    150,
    // f
    90,
    25,
    // g
    45,
    230,
    // h
    77,
    101,
    // i
    36,
    83,
    // j
    22,
    84,
    // k
    71,
    118,
    // l
    44,
    44,
    // m
    52,
    172,
    // n
    38,
    101,
    // o
    35,
    130,
    // p
    40,
    197,
    // q
    43,
    197,
    // r
    29,
    26,
    // s
    23,
    103,
    // t
    67,
    44,
    // u
    25,
    129,
    // v
    29,
    85,
    // w
    27,
    177,
    // x
    33,
    97,
    // y
    32,
    145,
    // z
    33,
    77,
    // {
    38,
    96,
    // |
    20,
    55,
    // }
    36,
    95,
    // ~
    2,
    22,
];

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$11 = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
function getMinimapLineHeight(renderMinimap) {
    if (renderMinimap === 2 /* Large */) {
        return 4 /* x2_CHAR_HEIGHT */;
    }
    if (renderMinimap === 4 /* LargeBlocks */) {
        return 4 /* x2_CHAR_HEIGHT */ + 2;
    }
    if (renderMinimap === 1 /* Small */) {
        return 2 /* x1_CHAR_HEIGHT */;
    }
    // RenderMinimap.SmallBlocks
    return 2 /* x1_CHAR_HEIGHT */ + 1;
}
function getMinimapCharWidth(renderMinimap) {
    if (renderMinimap === 2 /* Large */) {
        return 2 /* x2_CHAR_WIDTH */;
    }
    if (renderMinimap === 4 /* LargeBlocks */) {
        return 2 /* x2_CHAR_WIDTH */;
    }
    if (renderMinimap === 1 /* Small */) {
        return 1 /* x1_CHAR_WIDTH */;
    }
    // RenderMinimap.SmallBlocks
    return 1 /* x1_CHAR_WIDTH */;
}
/**
 * The orthogonal distance to the slider at which dragging "resets". This implements "snapping"
 */
var MOUSE_DRAG_RESET_DISTANCE$1 = 140;
var MinimapOptions = /** @class */ (function () {
    function MinimapOptions(configuration) {
        var pixelRatio = configuration.editor.pixelRatio;
        var layoutInfo = configuration.editor.layoutInfo;
        var viewInfo = configuration.editor.viewInfo;
        var fontInfo = configuration.editor.fontInfo;
        this.renderMinimap = layoutInfo.renderMinimap | 0;
        this.scrollBeyondLastLine = viewInfo.scrollBeyondLastLine;
        this.showSlider = viewInfo.minimap.showSlider;
        this.pixelRatio = pixelRatio;
        this.typicalHalfwidthCharacterWidth = fontInfo.typicalHalfwidthCharacterWidth;
        this.lineHeight = configuration.editor.lineHeight;
        this.minimapLeft = layoutInfo.minimapLeft;
        this.minimapWidth = layoutInfo.minimapWidth;
        this.minimapHeight = layoutInfo.height;
        this.canvasInnerWidth = Math.max(1, Math.floor(pixelRatio * this.minimapWidth));
        this.canvasInnerHeight = Math.max(1, Math.floor(pixelRatio * this.minimapHeight));
        this.canvasOuterWidth = this.canvasInnerWidth / pixelRatio;
        this.canvasOuterHeight = this.canvasInnerHeight / pixelRatio;
    }
    MinimapOptions.prototype.equals = function (other) {
        return (this.renderMinimap === other.renderMinimap
            && this.scrollBeyondLastLine === other.scrollBeyondLastLine
            && this.showSlider === other.showSlider
            && this.pixelRatio === other.pixelRatio
            && this.typicalHalfwidthCharacterWidth === other.typicalHalfwidthCharacterWidth
            && this.lineHeight === other.lineHeight
            && this.minimapLeft === other.minimapLeft
            && this.minimapWidth === other.minimapWidth
            && this.minimapHeight === other.minimapHeight
            && this.canvasInnerWidth === other.canvasInnerWidth
            && this.canvasInnerHeight === other.canvasInnerHeight
            && this.canvasOuterWidth === other.canvasOuterWidth
            && this.canvasOuterHeight === other.canvasOuterHeight);
    };
    return MinimapOptions;
}());
var MinimapLayout = /** @class */ (function () {
    function MinimapLayout(scrollTop, scrollHeight, computedSliderRatio, sliderTop, sliderHeight, startLineNumber, endLineNumber) {
        this.scrollTop = scrollTop;
        this.scrollHeight = scrollHeight;
        this._computedSliderRatio = computedSliderRatio;
        this.sliderTop = sliderTop;
        this.sliderHeight = sliderHeight;
        this.startLineNumber = startLineNumber;
        this.endLineNumber = endLineNumber;
    }
    /**
     * Compute a desired `scrollPosition` such that the slider moves by `delta`.
     */
    MinimapLayout.prototype.getDesiredScrollTopFromDelta = function (delta) {
        var desiredSliderPosition = this.sliderTop + delta;
        return Math.round(desiredSliderPosition / this._computedSliderRatio);
    };
    MinimapLayout.create = function (options, viewportStartLineNumber, viewportEndLineNumber, viewportHeight, viewportContainsWhitespaceGaps, lineCount, scrollTop, scrollHeight, previousLayout) {
        var pixelRatio = options.pixelRatio;
        var minimapLineHeight = getMinimapLineHeight(options.renderMinimap);
        var minimapLinesFitting = Math.floor(options.canvasInnerHeight / minimapLineHeight);
        var lineHeight = options.lineHeight;
        // The visible line count in a viewport can change due to a number of reasons:
        //  a) with the same viewport width, different scroll positions can result in partial lines being visible:
        //    e.g. for a line height of 20, and a viewport height of 600
        //          * scrollTop = 0  => visible lines are [1, 30]
        //          * scrollTop = 10 => visible lines are [1, 31] (with lines 1 and 31 partially visible)
        //          * scrollTop = 20 => visible lines are [2, 31]
        //  b) whitespace gaps might make their way in the viewport (which results in a decrease in the visible line count)
        //  c) we could be in the scroll beyond last line case (which also results in a decrease in the visible line count, down to possibly only one line being visible)
        // We must first establish a desirable slider height.
        var sliderHeight;
        if (viewportContainsWhitespaceGaps && viewportEndLineNumber !== lineCount) {
            // case b) from above: there are whitespace gaps in the viewport.
            // In this case, the height of the slider directly reflects the visible line count.
            var viewportLineCount = viewportEndLineNumber - viewportStartLineNumber + 1;
            sliderHeight = Math.floor(viewportLineCount * minimapLineHeight / pixelRatio);
        }
        else {
            // The slider has a stable height
            var expectedViewportLineCount = viewportHeight / lineHeight;
            sliderHeight = Math.floor(expectedViewportLineCount * minimapLineHeight / pixelRatio);
        }
        var maxMinimapSliderTop;
        if (options.scrollBeyondLastLine) {
            // The minimap slider, when dragged all the way down, will contain the last line at its top
            maxMinimapSliderTop = (lineCount - 1) * minimapLineHeight / pixelRatio;
        }
        else {
            // The minimap slider, when dragged all the way down, will contain the last line at its bottom
            maxMinimapSliderTop = Math.max(0, lineCount * minimapLineHeight / pixelRatio - sliderHeight);
        }
        maxMinimapSliderTop = Math.min(options.minimapHeight - sliderHeight, maxMinimapSliderTop);
        // The slider can move from 0 to `maxMinimapSliderTop`
        // in the same way `scrollTop` can move from 0 to `scrollHeight` - `viewportHeight`.
        var computedSliderRatio = (maxMinimapSliderTop) / (scrollHeight - viewportHeight);
        var sliderTop = (scrollTop * computedSliderRatio);
        if (minimapLinesFitting >= lineCount) {
            // All lines fit in the minimap
            var startLineNumber = 1;
            var endLineNumber = lineCount;
            return new MinimapLayout(scrollTop, scrollHeight, computedSliderRatio, sliderTop, sliderHeight, startLineNumber, endLineNumber);
        }
        else {
            var startLineNumber = Math.max(1, Math.floor(viewportStartLineNumber - sliderTop * pixelRatio / minimapLineHeight));
            // Avoid flickering caused by a partial viewport start line
            // by being consistent w.r.t. the previous layout decision
            if (previousLayout && previousLayout.scrollHeight === scrollHeight) {
                if (previousLayout.scrollTop > scrollTop) {
                    // Scrolling up => never increase `startLineNumber`
                    startLineNumber = Math.min(startLineNumber, previousLayout.startLineNumber);
                }
                if (previousLayout.scrollTop < scrollTop) {
                    // Scrolling down => never decrease `startLineNumber`
                    startLineNumber = Math.max(startLineNumber, previousLayout.startLineNumber);
                }
            }
            var endLineNumber = Math.min(lineCount, startLineNumber + minimapLinesFitting - 1);
            return new MinimapLayout(scrollTop, scrollHeight, computedSliderRatio, sliderTop, sliderHeight, startLineNumber, endLineNumber);
        }
    };
    return MinimapLayout;
}());
var MinimapLine = /** @class */ (function () {
    function MinimapLine(dy) {
        this.dy = dy;
    }
    MinimapLine.prototype.onContentChanged = function () {
        this.dy = -1;
    };
    MinimapLine.prototype.onTokensChanged = function () {
        this.dy = -1;
    };
    MinimapLine.INVALID = new MinimapLine(-1);
    return MinimapLine;
}());
var RenderData = /** @class */ (function () {
    function RenderData(renderedLayout, imageData, lines) {
        this.renderedLayout = renderedLayout;
        this._imageData = imageData;
        this._renderedLines = new RenderedLinesCollection(function () { return MinimapLine.INVALID; });
        this._renderedLines._set(renderedLayout.startLineNumber, lines);
    }
    /**
     * Check if the current RenderData matches accurately the new desired layout and no painting is needed.
     */
    RenderData.prototype.linesEquals = function (layout) {
        if (this.renderedLayout.startLineNumber !== layout.startLineNumber) {
            return false;
        }
        if (this.renderedLayout.endLineNumber !== layout.endLineNumber) {
            return false;
        }
        var tmp = this._renderedLines._get();
        var lines = tmp.lines;
        for (var i = 0, len = lines.length; i < len; i++) {
            if (lines[i].dy === -1) {
                // This line is invalid
                return false;
            }
        }
        return true;
    };
    RenderData.prototype._get = function () {
        var tmp = this._renderedLines._get();
        return {
            imageData: this._imageData,
            rendLineNumberStart: tmp.rendLineNumberStart,
            lines: tmp.lines
        };
    };
    RenderData.prototype.onLinesChanged = function (e) {
        return this._renderedLines.onLinesChanged(e.fromLineNumber, e.toLineNumber);
    };
    RenderData.prototype.onLinesDeleted = function (e) {
        this._renderedLines.onLinesDeleted(e.fromLineNumber, e.toLineNumber);
    };
    RenderData.prototype.onLinesInserted = function (e) {
        this._renderedLines.onLinesInserted(e.fromLineNumber, e.toLineNumber);
    };
    RenderData.prototype.onTokensChanged = function (e) {
        return this._renderedLines.onTokensChanged(e.ranges);
    };
    return RenderData;
}());
/**
 * Some sort of double buffering.
 *
 * Keeps two buffers around that will be rotated for painting.
 * Always gives a buffer that is filled with the background color.
 */
var MinimapBuffers = /** @class */ (function () {
    function MinimapBuffers(ctx, WIDTH, HEIGHT, background) {
        this._backgroundFillData = MinimapBuffers._createBackgroundFillData(WIDTH, HEIGHT, background);
        this._buffers = [
            ctx.createImageData(WIDTH, HEIGHT),
            ctx.createImageData(WIDTH, HEIGHT)
        ];
        this._lastUsedBuffer = 0;
    }
    MinimapBuffers.prototype.getBuffer = function () {
        // rotate buffers
        this._lastUsedBuffer = 1 - this._lastUsedBuffer;
        var result = this._buffers[this._lastUsedBuffer];
        // fill with background color
        result.data.set(this._backgroundFillData);
        return result;
    };
    MinimapBuffers._createBackgroundFillData = function (WIDTH, HEIGHT, background) {
        var backgroundR = background.r;
        var backgroundG = background.g;
        var backgroundB = background.b;
        var result = new Uint8ClampedArray(WIDTH * HEIGHT * 4);
        var offset = 0;
        for (var i = 0; i < HEIGHT; i++) {
            for (var j = 0; j < WIDTH; j++) {
                result[offset] = backgroundR;
                result[offset + 1] = backgroundG;
                result[offset + 2] = backgroundB;
                result[offset + 3] = 255;
                offset += 4;
            }
        }
        return result;
    };
    return MinimapBuffers;
}());
var Minimap = /** @class */ (function (_super) {
    __extends$11(Minimap, _super);
    function Minimap(context) {
        var _this = _super.call(this, context) || this;
        _this._options = new MinimapOptions(_this._context.configuration);
        _this._lastRenderData = null;
        _this._buffers = null;
        _this._domNode = createFastDomNode(document.createElement('div'));
        PartFingerprints.write(_this._domNode, 8 /* Minimap */);
        _this._domNode.setClassName(_this._getMinimapDomNodeClassName());
        _this._domNode.setPosition('absolute');
        _this._domNode.setAttribute('role', 'presentation');
        _this._domNode.setAttribute('aria-hidden', 'true');
        _this._shadow = createFastDomNode(document.createElement('div'));
        _this._shadow.setClassName('minimap-shadow-hidden');
        _this._domNode.appendChild(_this._shadow);
        _this._canvas = createFastDomNode(document.createElement('canvas'));
        _this._canvas.setPosition('absolute');
        _this._canvas.setLeft(0);
        _this._domNode.appendChild(_this._canvas);
        _this._slider = createFastDomNode(document.createElement('div'));
        _this._slider.setPosition('absolute');
        _this._slider.setClassName('minimap-slider');
        _this._slider.setLayerHinting(true);
        _this._domNode.appendChild(_this._slider);
        _this._sliderHorizontal = createFastDomNode(document.createElement('div'));
        _this._sliderHorizontal.setPosition('absolute');
        _this._sliderHorizontal.setClassName('minimap-slider-horizontal');
        _this._slider.appendChild(_this._sliderHorizontal);
        _this._tokensColorTracker = MinimapTokensColorTracker.getInstance();
        _this._applyLayout();
        _this._mouseDownListener = addStandardDisposableListener(_this._canvas.domNode, 'mousedown', function (e) {
            e.preventDefault();
            var renderMinimap = _this._options.renderMinimap;
            if (renderMinimap === 0 /* None */) {
                return;
            }
            if (!_this._lastRenderData) {
                return;
            }
            var minimapLineHeight = getMinimapLineHeight(renderMinimap);
            var internalOffsetY = _this._options.pixelRatio * e.browserEvent.offsetY;
            var lineIndex = Math.floor(internalOffsetY / minimapLineHeight);
            var lineNumber = lineIndex + _this._lastRenderData.renderedLayout.startLineNumber;
            lineNumber = Math.min(lineNumber, _this._context.model.getLineCount());
            _this._context.privateViewEventBus.emit(new ViewRevealRangeRequestEvent(new Range(lineNumber, 1, lineNumber, 1), 1 /* Center */, false, 0 /* Smooth */));
        });
        _this._sliderMouseMoveMonitor = new GlobalMouseMoveMonitor();
        _this._sliderMouseDownListener = addStandardDisposableListener(_this._slider.domNode, 'mousedown', function (e) {
            e.preventDefault();
            if (e.leftButton && _this._lastRenderData) {
                var initialMousePosition_1 = e.posy;
                var initialMouseOrthogonalPosition_1 = e.posx;
                var initialSliderState_1 = _this._lastRenderData.renderedLayout;
                _this._slider.toggleClassName('active', true);
                _this._sliderMouseMoveMonitor.startMonitoring(standardMouseMoveMerger, function (mouseMoveData) {
                    var mouseOrthogonalDelta = Math.abs(mouseMoveData.posx - initialMouseOrthogonalPosition_1);
                    if (isWindows && mouseOrthogonalDelta > MOUSE_DRAG_RESET_DISTANCE$1) {
                        // The mouse has wondered away from the scrollbar => reset dragging
                        _this._context.viewLayout.setScrollPositionNow({
                            scrollTop: initialSliderState_1.scrollTop
                        });
                        return;
                    }
                    var mouseDelta = mouseMoveData.posy - initialMousePosition_1;
                    _this._context.viewLayout.setScrollPositionNow({
                        scrollTop: initialSliderState_1.getDesiredScrollTopFromDelta(mouseDelta)
                    });
                }, function () {
                    _this._slider.toggleClassName('active', false);
                });
            }
        });
        return _this;
    }
    Minimap.prototype.dispose = function () {
        this._mouseDownListener.dispose();
        this._sliderMouseMoveMonitor.dispose();
        this._sliderMouseDownListener.dispose();
        _super.prototype.dispose.call(this);
    };
    Minimap.prototype._getMinimapDomNodeClassName = function () {
        if (this._options.showSlider === 'always') {
            return 'minimap slider-always';
        }
        return 'minimap slider-mouseover';
    };
    Minimap.prototype.getDomNode = function () {
        return this._domNode;
    };
    Minimap.prototype._applyLayout = function () {
        this._domNode.setLeft(this._options.minimapLeft);
        this._domNode.setWidth(this._options.minimapWidth);
        this._domNode.setHeight(this._options.minimapHeight);
        this._shadow.setHeight(this._options.minimapHeight);
        this._canvas.setWidth(this._options.canvasOuterWidth);
        this._canvas.setHeight(this._options.canvasOuterHeight);
        this._canvas.domNode.width = this._options.canvasInnerWidth;
        this._canvas.domNode.height = this._options.canvasInnerHeight;
        this._slider.setWidth(this._options.minimapWidth);
    };
    Minimap.prototype._getBuffer = function () {
        if (!this._buffers) {
            this._buffers = new MinimapBuffers(this._canvas.domNode.getContext('2d'), this._options.canvasInnerWidth, this._options.canvasInnerHeight, this._tokensColorTracker.getColor(2 /* DefaultBackground */));
        }
        return this._buffers.getBuffer();
    };
    Minimap.prototype._onOptionsMaybeChanged = function () {
        var opts = new MinimapOptions(this._context.configuration);
        if (this._options.equals(opts)) {
            return false;
        }
        this._options = opts;
        this._lastRenderData = null;
        this._buffers = null;
        this._applyLayout();
        this._domNode.setClassName(this._getMinimapDomNodeClassName());
        return true;
    };
    // ---- begin view event handlers
    Minimap.prototype.onConfigurationChanged = function (e) {
        return this._onOptionsMaybeChanged();
    };
    Minimap.prototype.onFlushed = function (e) {
        this._lastRenderData = null;
        return true;
    };
    Minimap.prototype.onLinesChanged = function (e) {
        if (this._lastRenderData) {
            return this._lastRenderData.onLinesChanged(e);
        }
        return false;
    };
    Minimap.prototype.onLinesDeleted = function (e) {
        if (this._lastRenderData) {
            this._lastRenderData.onLinesDeleted(e);
        }
        return true;
    };
    Minimap.prototype.onLinesInserted = function (e) {
        if (this._lastRenderData) {
            this._lastRenderData.onLinesInserted(e);
        }
        return true;
    };
    Minimap.prototype.onScrollChanged = function (e) {
        return true;
    };
    Minimap.prototype.onTokensChanged = function (e) {
        if (this._lastRenderData) {
            return this._lastRenderData.onTokensChanged(e);
        }
        return false;
    };
    Minimap.prototype.onTokensColorsChanged = function (e) {
        this._lastRenderData = null;
        this._buffers = null;
        return true;
    };
    Minimap.prototype.onZonesChanged = function (e) {
        this._lastRenderData = null;
        return true;
    };
    // --- end event handlers
    Minimap.prototype.prepareRender = function (ctx) {
        // Nothing to read
    };
    Minimap.prototype.render = function (renderingCtx) {
        var renderMinimap = this._options.renderMinimap;
        if (renderMinimap === 0 /* None */) {
            this._shadow.setClassName('minimap-shadow-hidden');
            this._sliderHorizontal.setWidth(0);
            this._sliderHorizontal.setHeight(0);
            return;
        }
        if (renderingCtx.scrollLeft + renderingCtx.viewportWidth >= renderingCtx.scrollWidth) {
            this._shadow.setClassName('minimap-shadow-hidden');
        }
        else {
            this._shadow.setClassName('minimap-shadow-visible');
        }
        var layout = MinimapLayout.create(this._options, renderingCtx.visibleRange.startLineNumber, renderingCtx.visibleRange.endLineNumber, renderingCtx.viewportHeight, (renderingCtx.viewportData.whitespaceViewportData.length > 0), this._context.model.getLineCount(), renderingCtx.scrollTop, renderingCtx.scrollHeight, this._lastRenderData ? this._lastRenderData.renderedLayout : null);
        this._slider.setTop(layout.sliderTop);
        this._slider.setHeight(layout.sliderHeight);
        // Compute horizontal slider coordinates
        var scrollLeftChars = renderingCtx.scrollLeft / this._options.typicalHalfwidthCharacterWidth;
        var horizontalSliderLeft = Math.min(this._options.minimapWidth, Math.round(scrollLeftChars * getMinimapCharWidth(this._options.renderMinimap) / this._options.pixelRatio));
        this._sliderHorizontal.setLeft(horizontalSliderLeft);
        this._sliderHorizontal.setWidth(this._options.minimapWidth - horizontalSliderLeft);
        this._sliderHorizontal.setTop(0);
        this._sliderHorizontal.setHeight(layout.sliderHeight);
        this._lastRenderData = this.renderLines(layout);
    };
    Minimap.prototype.renderLines = function (layout) {
        var renderMinimap = this._options.renderMinimap;
        var startLineNumber = layout.startLineNumber;
        var endLineNumber = layout.endLineNumber;
        var minimapLineHeight = getMinimapLineHeight(renderMinimap);
        // Check if nothing changed w.r.t. lines from last frame
        if (this._lastRenderData && this._lastRenderData.linesEquals(layout)) {
            var _lastData = this._lastRenderData._get();
            // Nice!! Nothing changed from last frame
            return new RenderData(layout, _lastData.imageData, _lastData.lines);
        }
        // Oh well!! We need to repaint some lines...
        var imageData = this._getBuffer();
        // Render untouched lines by using last rendered data.
        var _a = Minimap._renderUntouchedLines(imageData, startLineNumber, endLineNumber, minimapLineHeight, this._lastRenderData), _dirtyY1 = _a[0], _dirtyY2 = _a[1], needed = _a[2];
        // Fetch rendering info from view model for rest of lines that need rendering.
        var lineInfo = this._context.model.getMinimapLinesRenderingData(startLineNumber, endLineNumber, needed);
        var tabSize = lineInfo.tabSize;
        var background = this._tokensColorTracker.getColor(2 /* DefaultBackground */);
        var useLighterFont = this._tokensColorTracker.backgroundIsLight();
        // Render the rest of lines
        var dy = 0;
        var renderedLines = [];
        for (var lineIndex = 0, lineCount = endLineNumber - startLineNumber + 1; lineIndex < lineCount; lineIndex++) {
            if (needed[lineIndex]) {
                Minimap._renderLine(imageData, background, useLighterFont, renderMinimap, this._tokensColorTracker, getOrCreateMinimapCharRenderer(), dy, tabSize, lineInfo.data[lineIndex]);
            }
            renderedLines[lineIndex] = new MinimapLine(dy);
            dy += minimapLineHeight;
        }
        var dirtyY1 = (_dirtyY1 === -1 ? 0 : _dirtyY1);
        var dirtyY2 = (_dirtyY2 === -1 ? imageData.height : _dirtyY2);
        var dirtyHeight = dirtyY2 - dirtyY1;
        // Finally, paint to the canvas
        var ctx = this._canvas.domNode.getContext('2d');
        ctx.putImageData(imageData, 0, 0, 0, dirtyY1, imageData.width, dirtyHeight);
        // Save rendered data for reuse on next frame if possible
        return new RenderData(layout, imageData, renderedLines);
    };
    Minimap._renderUntouchedLines = function (target, startLineNumber, endLineNumber, minimapLineHeight, lastRenderData) {
        var needed = [];
        if (!lastRenderData) {
            for (var i = 0, len = endLineNumber - startLineNumber + 1; i < len; i++) {
                needed[i] = true;
            }
            return [-1, -1, needed];
        }
        var _lastData = lastRenderData._get();
        var lastTargetData = _lastData.imageData.data;
        var lastStartLineNumber = _lastData.rendLineNumberStart;
        var lastLines = _lastData.lines;
        var lastLinesLength = lastLines.length;
        var WIDTH = target.width;
        var targetData = target.data;
        var maxDestPixel = (endLineNumber - startLineNumber + 1) * minimapLineHeight * WIDTH * 4;
        var dirtyPixel1 = -1; // the pixel offset up to which all the data is equal to the prev frame
        var dirtyPixel2 = -1; // the pixel offset after which all the data is equal to the prev frame
        var copySourceStart = -1;
        var copySourceEnd = -1;
        var copyDestStart = -1;
        var copyDestEnd = -1;
        var dest_dy = 0;
        for (var lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {
            var lineIndex = lineNumber - startLineNumber;
            var lastLineIndex = lineNumber - lastStartLineNumber;
            var source_dy = (lastLineIndex >= 0 && lastLineIndex < lastLinesLength ? lastLines[lastLineIndex].dy : -1);
            if (source_dy === -1) {
                needed[lineIndex] = true;
                dest_dy += minimapLineHeight;
                continue;
            }
            var sourceStart = source_dy * WIDTH * 4;
            var sourceEnd = (source_dy + minimapLineHeight) * WIDTH * 4;
            var destStart = dest_dy * WIDTH * 4;
            var destEnd = (dest_dy + minimapLineHeight) * WIDTH * 4;
            if (copySourceEnd === sourceStart && copyDestEnd === destStart) {
                // contiguous zone => extend copy request
                copySourceEnd = sourceEnd;
                copyDestEnd = destEnd;
            }
            else {
                if (copySourceStart !== -1) {
                    // flush existing copy request
                    targetData.set(lastTargetData.subarray(copySourceStart, copySourceEnd), copyDestStart);
                    if (dirtyPixel1 === -1 && copySourceStart === 0 && copySourceStart === copyDestStart) {
                        dirtyPixel1 = copySourceEnd;
                    }
                    if (dirtyPixel2 === -1 && copySourceEnd === maxDestPixel && copySourceStart === copyDestStart) {
                        dirtyPixel2 = copySourceStart;
                    }
                }
                copySourceStart = sourceStart;
                copySourceEnd = sourceEnd;
                copyDestStart = destStart;
                copyDestEnd = destEnd;
            }
            needed[lineIndex] = false;
            dest_dy += minimapLineHeight;
        }
        if (copySourceStart !== -1) {
            // flush existing copy request
            targetData.set(lastTargetData.subarray(copySourceStart, copySourceEnd), copyDestStart);
            if (dirtyPixel1 === -1 && copySourceStart === 0 && copySourceStart === copyDestStart) {
                dirtyPixel1 = copySourceEnd;
            }
            if (dirtyPixel2 === -1 && copySourceEnd === maxDestPixel && copySourceStart === copyDestStart) {
                dirtyPixel2 = copySourceStart;
            }
        }
        var dirtyY1 = (dirtyPixel1 === -1 ? -1 : dirtyPixel1 / (WIDTH * 4));
        var dirtyY2 = (dirtyPixel2 === -1 ? -1 : dirtyPixel2 / (WIDTH * 4));
        return [dirtyY1, dirtyY2, needed];
    };
    Minimap._renderLine = function (target, backgroundColor, useLighterFont, renderMinimap, colorTracker, minimapCharRenderer, dy, tabSize, lineData) {
        var content = lineData.content;
        var tokens = lineData.tokens;
        var charWidth = getMinimapCharWidth(renderMinimap);
        var maxDx = target.width - charWidth;
        var dx = 0;
        var charIndex = 0;
        var tabsCharDelta = 0;
        for (var tokenIndex = 0, tokensLen = tokens.getCount(); tokenIndex < tokensLen; tokenIndex++) {
            var tokenEndIndex = tokens.getEndOffset(tokenIndex);
            var tokenColorId = tokens.getForeground(tokenIndex);
            var tokenColor = colorTracker.getColor(tokenColorId);
            for (; charIndex < tokenEndIndex; charIndex++) {
                if (dx > maxDx) {
                    // hit edge of minimap
                    return;
                }
                var charCode = content.charCodeAt(charIndex);
                if (charCode === 9 /* Tab */) {
                    var insertSpacesCount = tabSize - (charIndex + tabsCharDelta) % tabSize;
                    tabsCharDelta += insertSpacesCount - 1;
                    // No need to render anything since tab is invisible
                    dx += insertSpacesCount * charWidth;
                }
                else if (charCode === 32 /* Space */) {
                    // No need to render anything since space is invisible
                    dx += charWidth;
                }
                else {
                    // Render twice for a full width character
                    var count = isFullWidthCharacter(charCode) ? 2 : 1;
                    for (var i = 0; i < count; i++) {
                        if (renderMinimap === 2 /* Large */) {
                            minimapCharRenderer.x2RenderChar(target, dx, dy, charCode, tokenColor, backgroundColor, useLighterFont);
                        }
                        else if (renderMinimap === 1 /* Small */) {
                            minimapCharRenderer.x1RenderChar(target, dx, dy, charCode, tokenColor, backgroundColor, useLighterFont);
                        }
                        else if (renderMinimap === 4 /* LargeBlocks */) {
                            minimapCharRenderer.x2BlockRenderChar(target, dx, dy, tokenColor, backgroundColor, useLighterFont);
                        }
                        else {
                            // RenderMinimap.SmallBlocks
                            minimapCharRenderer.x1BlockRenderChar(target, dx, dy, tokenColor, backgroundColor, useLighterFont);
                        }
                        dx += charWidth;
                    }
                }
            }
        }
    };
    return Minimap;
}(ViewPart));
registerThemingParticipant(function (theme, collector) {
    var sliderBackground = theme.getColor(scrollbarSliderBackground);
    if (sliderBackground) {
        var halfSliderBackground = sliderBackground.transparent(0.5);
        collector.addRule(".monaco-editor .minimap-slider, .monaco-editor .minimap-slider .minimap-slider-horizontal { background: " + halfSliderBackground + "; }");
    }
    var sliderHoverBackground = theme.getColor(scrollbarSliderHoverBackground);
    if (sliderHoverBackground) {
        var halfSliderHoverBackground = sliderHoverBackground.transparent(0.5);
        collector.addRule(".monaco-editor .minimap-slider:hover, .monaco-editor .minimap-slider:hover .minimap-slider-horizontal { background: " + halfSliderHoverBackground + "; }");
    }
    var sliderActiveBackground = theme.getColor(scrollbarSliderActiveBackground);
    if (sliderActiveBackground) {
        var halfSliderActiveBackground = sliderActiveBackground.transparent(0.5);
        collector.addRule(".monaco-editor .minimap-slider.active, .monaco-editor .minimap-slider.active .minimap-slider-horizontal { background: " + halfSliderActiveBackground + "; }");
    }
    var shadow = theme.getColor(scrollbarShadow);
    if (shadow) {
        collector.addRule(".monaco-editor .minimap-shadow-visible { box-shadow: " + shadow + " -6px 0 6px -6px inset; }");
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$12 = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var View = /** @class */ (function (_super) {
    __extends$12(View, _super);
    function View(commandDelegate, configuration, themeService, model, cursor, execCoreEditorCommandFunc) {
        var _this = _super.call(this) || this;
        _this._cursor = cursor;
        _this._renderAnimationFrame = null;
        _this.outgoingEvents = new ViewOutgoingEvents(model);
        var viewController = new ViewController(configuration, model, execCoreEditorCommandFunc, _this.outgoingEvents, commandDelegate);
        // The event dispatcher will always go through _renderOnce before dispatching any events
        _this.eventDispatcher = new ViewEventDispatcher(function (callback) { return _this._renderOnce(callback); });
        // Ensure the view is the first event handler in order to update the layout
        _this.eventDispatcher.addEventHandler(_this);
        // The view context is passed on to most classes (basically to reduce param. counts in ctors)
        _this._context = new ViewContext(configuration, themeService.getTheme(), model, _this.eventDispatcher);
        _this._register(themeService.onThemeChange(function (theme) {
            _this._context.theme = theme;
            _this.eventDispatcher.emit(new ViewThemeChangedEvent());
            _this.render(true, false);
        }));
        _this.viewParts = [];
        // Keyboard handler
        _this._textAreaHandler = new TextAreaHandler(_this._context, viewController, _this.createTextAreaHandlerHelper());
        _this.viewParts.push(_this._textAreaHandler);
        _this.createViewParts();
        _this._setLayout();
        // Pointer handler
        _this.pointerHandler = new PointerHandler(_this._context, viewController, _this.createPointerHandlerHelper());
        _this._register(model.addEventListener(function (events) {
            _this.eventDispatcher.emitMany(events);
        }));
        _this._register(_this._cursor.addEventListener(function (events) {
            _this.eventDispatcher.emitMany(events);
        }));
        return _this;
    }
    View.prototype.createViewParts = function () {
        // These two dom nodes must be constructed up front, since references are needed in the layout provider (scrolling & co.)
        this.linesContent = createFastDomNode(document.createElement('div'));
        this.linesContent.setClassName('lines-content' + ' monaco-editor-background');
        this.linesContent.setPosition('absolute');
        this.domNode = createFastDomNode(document.createElement('div'));
        this.domNode.setClassName(this.getEditorClassName());
        this.overflowGuardContainer = createFastDomNode(document.createElement('div'));
        PartFingerprints.write(this.overflowGuardContainer, 3 /* OverflowGuard */);
        this.overflowGuardContainer.setClassName('overflow-guard');
        this._scrollbar = new EditorScrollbar(this._context, this.linesContent, this.domNode, this.overflowGuardContainer);
        this.viewParts.push(this._scrollbar);
        // View Lines
        this.viewLines = new ViewLines(this._context, this.linesContent);
        // View Zones
        this.viewZones = new ViewZones(this._context);
        this.viewParts.push(this.viewZones);
        // Decorations overview ruler
        var decorationsOverviewRuler = new DecorationsOverviewRuler(this._context);
        this.viewParts.push(decorationsOverviewRuler);
        var scrollDecoration = new ScrollDecorationViewPart(this._context);
        this.viewParts.push(scrollDecoration);
        var contentViewOverlays = new ContentViewOverlays(this._context);
        this.viewParts.push(contentViewOverlays);
        contentViewOverlays.addDynamicOverlay(new CurrentLineHighlightOverlay(this._context));
        contentViewOverlays.addDynamicOverlay(new SelectionsOverlay(this._context));
        contentViewOverlays.addDynamicOverlay(new IndentGuidesOverlay(this._context));
        contentViewOverlays.addDynamicOverlay(new DecorationsOverlay(this._context));
        var marginViewOverlays = new MarginViewOverlays(this._context);
        this.viewParts.push(marginViewOverlays);
        marginViewOverlays.addDynamicOverlay(new CurrentLineMarginHighlightOverlay(this._context));
        marginViewOverlays.addDynamicOverlay(new GlyphMarginOverlay(this._context));
        marginViewOverlays.addDynamicOverlay(new MarginViewLineDecorationsOverlay(this._context));
        marginViewOverlays.addDynamicOverlay(new LinesDecorationsOverlay(this._context));
        marginViewOverlays.addDynamicOverlay(new LineNumbersOverlay(this._context));
        var margin = new Margin(this._context);
        margin.getDomNode().appendChild(this.viewZones.marginDomNode);
        margin.getDomNode().appendChild(marginViewOverlays.getDomNode());
        this.viewParts.push(margin);
        // Content widgets
        this.contentWidgets = new ViewContentWidgets(this._context, this.domNode);
        this.viewParts.push(this.contentWidgets);
        this.viewCursors = new ViewCursors(this._context);
        this.viewParts.push(this.viewCursors);
        // Overlay widgets
        this.overlayWidgets = new ViewOverlayWidgets(this._context);
        this.viewParts.push(this.overlayWidgets);
        var rulers = new Rulers(this._context);
        this.viewParts.push(rulers);
        var minimap = new Minimap(this._context);
        this.viewParts.push(minimap);
        // -------------- Wire dom nodes up
        if (decorationsOverviewRuler) {
            var overviewRulerData = this._scrollbar.getOverviewRulerLayoutInfo();
            overviewRulerData.parent.insertBefore(decorationsOverviewRuler.getDomNode(), overviewRulerData.insertBefore);
        }
        this.linesContent.appendChild(contentViewOverlays.getDomNode());
        this.linesContent.appendChild(rulers.domNode);
        this.linesContent.appendChild(this.viewZones.domNode);
        this.linesContent.appendChild(this.viewLines.getDomNode());
        this.linesContent.appendChild(this.contentWidgets.domNode);
        this.linesContent.appendChild(this.viewCursors.getDomNode());
        this.overflowGuardContainer.appendChild(margin.getDomNode());
        this.overflowGuardContainer.appendChild(this._scrollbar.getDomNode());
        this.overflowGuardContainer.appendChild(scrollDecoration.getDomNode());
        this.overflowGuardContainer.appendChild(this._textAreaHandler.textArea);
        this.overflowGuardContainer.appendChild(this._textAreaHandler.textAreaCover);
        this.overflowGuardContainer.appendChild(this.overlayWidgets.getDomNode());
        this.overflowGuardContainer.appendChild(minimap.getDomNode());
        this.domNode.appendChild(this.overflowGuardContainer);
        this.domNode.appendChild(this.contentWidgets.overflowingContentWidgetsDomNode);
    };
    View.prototype._flushAccumulatedAndRenderNow = function () {
        this._renderNow();
    };
    View.prototype.createPointerHandlerHelper = function () {
        var _this = this;
        return {
            viewDomNode: this.domNode.domNode,
            linesContentDomNode: this.linesContent.domNode,
            focusTextArea: function () {
                _this.focus();
            },
            getLastViewCursorsRenderData: function () {
                return _this.viewCursors.getLastRenderData() || [];
            },
            shouldSuppressMouseDownOnViewZone: function (viewZoneId) {
                return _this.viewZones.shouldSuppressMouseDownOnViewZone(viewZoneId);
            },
            shouldSuppressMouseDownOnWidget: function (widgetId) {
                return _this.contentWidgets.shouldSuppressMouseDownOnWidget(widgetId);
            },
            getPositionFromDOMInfo: function (spanNode, offset) {
                _this._flushAccumulatedAndRenderNow();
                return _this.viewLines.getPositionFromDOMInfo(spanNode, offset);
            },
            visibleRangeForPosition2: function (lineNumber, column) {
                _this._flushAccumulatedAndRenderNow();
                var visibleRanges = _this.viewLines.visibleRangesForRange2(new Range(lineNumber, column, lineNumber, column));
                if (!visibleRanges) {
                    return null;
                }
                return visibleRanges[0];
            },
            getLineWidth: function (lineNumber) {
                _this._flushAccumulatedAndRenderNow();
                return _this.viewLines.getLineWidth(lineNumber);
            }
        };
    };
    View.prototype.createTextAreaHandlerHelper = function () {
        var _this = this;
        return {
            visibleRangeForPositionRelativeToEditor: function (lineNumber, column) {
                _this._flushAccumulatedAndRenderNow();
                var visibleRanges = _this.viewLines.visibleRangesForRange2(new Range(lineNumber, column, lineNumber, column));
                if (!visibleRanges) {
                    return null;
                }
                return visibleRanges[0];
            }
        };
    };
    View.prototype._setLayout = function () {
        var layoutInfo = this._context.configuration.editor.layoutInfo;
        this.domNode.setWidth(layoutInfo.width);
        this.domNode.setHeight(layoutInfo.height);
        this.overflowGuardContainer.setWidth(layoutInfo.width);
        this.overflowGuardContainer.setHeight(layoutInfo.height);
        this.linesContent.setWidth(1000000);
        this.linesContent.setHeight(1000000);
    };
    View.prototype.getEditorClassName = function () {
        var focused = this._textAreaHandler.isFocused() ? ' focused' : '';
        return this._context.configuration.editor.editorClassName + ' ' + getThemeTypeSelector(this._context.theme.type) + focused;
    };
    // --- begin event handlers
    View.prototype.onConfigurationChanged = function (e) {
        if (e.editorClassName) {
            this.domNode.setClassName(this.getEditorClassName());
        }
        if (e.layoutInfo) {
            this._setLayout();
        }
        return false;
    };
    View.prototype.onFocusChanged = function (e) {
        this.domNode.setClassName(this.getEditorClassName());
        this._context.model.setHasFocus(e.isFocused);
        if (e.isFocused) {
            this.outgoingEvents.emitViewFocusGained();
        }
        else {
            this.outgoingEvents.emitViewFocusLost();
        }
        return false;
    };
    View.prototype.onScrollChanged = function (e) {
        this.outgoingEvents.emitScrollChanged(e);
        return false;
    };
    View.prototype.onThemeChanged = function (e) {
        this.domNode.setClassName(this.getEditorClassName());
        return false;
    };
    // --- end event handlers
    View.prototype.dispose = function () {
        if (this._renderAnimationFrame !== null) {
            this._renderAnimationFrame.dispose();
            this._renderAnimationFrame = null;
        }
        this.eventDispatcher.removeEventHandler(this);
        this.outgoingEvents.dispose();
        this.pointerHandler.dispose();
        this.viewLines.dispose();
        // Destroy view parts
        for (var i = 0, len = this.viewParts.length; i < len; i++) {
            this.viewParts[i].dispose();
        }
        this.viewParts = [];
        _super.prototype.dispose.call(this);
    };
    View.prototype._renderOnce = function (callback) {
        var r = safeInvokeNoArg(callback);
        this._scheduleRender();
        return r;
    };
    View.prototype._scheduleRender = function () {
        if (this._renderAnimationFrame === null) {
            this._renderAnimationFrame = runAtThisOrScheduleAtNextAnimationFrame(this._onRenderScheduled.bind(this), 100);
        }
    };
    View.prototype._onRenderScheduled = function () {
        this._renderAnimationFrame = null;
        this._flushAccumulatedAndRenderNow();
    };
    View.prototype._renderNow = function () {
        var _this = this;
        safeInvokeNoArg(function () { return _this._actualRender(); });
    };
    View.prototype._getViewPartsToRender = function () {
        var result = [], resultLen = 0;
        for (var i = 0, len = this.viewParts.length; i < len; i++) {
            var viewPart = this.viewParts[i];
            if (viewPart.shouldRender()) {
                result[resultLen++] = viewPart;
            }
        }
        return result;
    };
    View.prototype._actualRender = function () {
        if (!isInDOM(this.domNode.domNode)) {
            return;
        }
        var viewPartsToRender = this._getViewPartsToRender();
        if (!this.viewLines.shouldRender() && viewPartsToRender.length === 0) {
            // Nothing to render
            return;
        }
        var partialViewportData = this._context.viewLayout.getLinesViewportData();
        this._context.model.setViewport(partialViewportData.startLineNumber, partialViewportData.endLineNumber, partialViewportData.centeredLineNumber);
        var viewportData = new ViewportData(this._cursor.getViewSelections(), partialViewportData, this._context.viewLayout.getWhitespaceViewportData(), this._context.model);
        if (this.contentWidgets.shouldRender()) {
            // Give the content widgets a chance to set their max width before a possible synchronous layout
            this.contentWidgets.onBeforeRender(viewportData);
        }
        if (this.viewLines.shouldRender()) {
            this.viewLines.renderText(viewportData);
            this.viewLines.onDidRender();
            // Rendering of viewLines might cause scroll events to occur, so collect view parts to render again
            viewPartsToRender = this._getViewPartsToRender();
        }
        var renderingContext = new RenderingContext(this._context.viewLayout, viewportData, this.viewLines);
        // Render the rest of the parts
        for (var i = 0, len = viewPartsToRender.length; i < len; i++) {
            var viewPart = viewPartsToRender[i];
            viewPart.prepareRender(renderingContext);
        }
        for (var i = 0, len = viewPartsToRender.length; i < len; i++) {
            var viewPart = viewPartsToRender[i];
            viewPart.render(renderingContext);
            viewPart.onDidRender();
        }
    };
    // --- BEGIN CodeEditor helpers
    View.prototype.delegateVerticalScrollbarMouseDown = function (browserEvent) {
        this._scrollbar.delegateVerticalScrollbarMouseDown(browserEvent);
    };
    View.prototype.restoreState = function (scrollPosition) {
        this._context.viewLayout.setScrollPositionNow({ scrollTop: scrollPosition.scrollTop });
        this._renderNow();
        this.viewLines.updateLineWidths();
        this._context.viewLayout.setScrollPositionNow({ scrollLeft: scrollPosition.scrollLeft });
    };
    View.prototype.getOffsetForColumn = function (modelLineNumber, modelColumn) {
        var modelPosition = this._context.model.validateModelPosition({
            lineNumber: modelLineNumber,
            column: modelColumn
        });
        var viewPosition = this._context.model.coordinatesConverter.convertModelPositionToViewPosition(modelPosition);
        this._flushAccumulatedAndRenderNow();
        var visibleRanges = this.viewLines.visibleRangesForRange2(new Range(viewPosition.lineNumber, viewPosition.column, viewPosition.lineNumber, viewPosition.column));
        if (!visibleRanges) {
            return -1;
        }
        return visibleRanges[0].left;
    };
    View.prototype.getTargetAtClientPoint = function (clientX, clientY) {
        return this.pointerHandler.getTargetAtClientPoint(clientX, clientY);
    };
    View.prototype.getInternalEventBus = function () {
        return this.outgoingEvents;
    };
    View.prototype.createOverviewRuler = function (cssClassName) {
        return new OverviewRuler(this._context, cssClassName);
    };
    View.prototype.change = function (callback) {
        var _this = this;
        var zonesHaveChanged = false;
        this._renderOnce(function () {
            var changeAccessor = {
                addZone: function (zone) {
                    zonesHaveChanged = true;
                    return _this.viewZones.addZone(zone);
                },
                removeZone: function (id) {
                    if (!id) {
                        return;
                    }
                    zonesHaveChanged = _this.viewZones.removeZone(id) || zonesHaveChanged;
                },
                layoutZone: function (id) {
                    if (!id) {
                        return;
                    }
                    zonesHaveChanged = _this.viewZones.layoutZone(id) || zonesHaveChanged;
                }
            };
            safeInvoke1Arg(callback, changeAccessor);
            // Invalidate changeAccessor
            changeAccessor.addZone = null;
            changeAccessor.removeZone = null;
            if (zonesHaveChanged) {
                _this._context.viewLayout.onHeightMaybeChanged();
                _this._context.privateViewEventBus.emit(new ViewZonesChangedEvent());
            }
        });
        return zonesHaveChanged;
    };
    View.prototype.render = function (now, everything) {
        if (everything) {
            // Force everything to render...
            this.viewLines.forceShouldRender();
            for (var i = 0, len = this.viewParts.length; i < len; i++) {
                var viewPart = this.viewParts[i];
                viewPart.forceShouldRender();
            }
        }
        if (now) {
            this._flushAccumulatedAndRenderNow();
        }
        else {
            this._scheduleRender();
        }
    };
    View.prototype.focus = function () {
        this._textAreaHandler.focusTextArea();
    };
    View.prototype.isFocused = function () {
        return this._textAreaHandler.isFocused();
    };
    View.prototype.addContentWidget = function (widgetData) {
        this.contentWidgets.addWidget(widgetData.widget);
        this.layoutContentWidget(widgetData);
        this._scheduleRender();
    };
    View.prototype.layoutContentWidget = function (widgetData) {
        var newPosition = widgetData.position ? widgetData.position.position : null;
        var newPreference = widgetData.position ? widgetData.position.preference : null;
        this.contentWidgets.setWidgetPosition(widgetData.widget, newPosition, newPreference);
        this._scheduleRender();
    };
    View.prototype.removeContentWidget = function (widgetData) {
        this.contentWidgets.removeWidget(widgetData.widget);
        this._scheduleRender();
    };
    View.prototype.addOverlayWidget = function (widgetData) {
        this.overlayWidgets.addWidget(widgetData.widget);
        this.layoutOverlayWidget(widgetData);
        this._scheduleRender();
    };
    View.prototype.layoutOverlayWidget = function (widgetData) {
        var newPreference = widgetData.position ? widgetData.position.preference : null;
        var shouldRender = this.overlayWidgets.setWidgetPosition(widgetData.widget, newPreference);
        if (shouldRender) {
            this._scheduleRender();
        }
    };
    View.prototype.removeOverlayWidget = function (widgetData) {
        this.overlayWidgets.removeWidget(widgetData.widget);
        this._scheduleRender();
    };
    return View;
}(ViewEventHandler));
function safeInvokeNoArg(func) {
    try {
        return func();
    }
    catch (e) {
        onUnexpectedError(e);
    }
}
function safeInvoke1Arg(func, arg1) {
    try {
        return func(arg1);
    }
    catch (e) {
        onUnexpectedError(e);
    }
}

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var InternalEditorAction = /** @class */ (function () {
    function InternalEditorAction(id, label, alias, precondition, run, contextKeyService) {
        this.id = id;
        this.label = label;
        this.alias = alias;
        this._precondition = precondition;
        this._run = run;
        this._contextKeyService = contextKeyService;
    }
    InternalEditorAction.prototype.isSupported = function () {
        return this._contextKeyService.contextMatchesRules(this._precondition);
    };
    InternalEditorAction.prototype.run = function () {
        if (!this.isSupported()) {
            return TPromise.as(void 0);
        }
        var r = this._run();
        return r ? r : TPromise.as(void 0);
    };
    return InternalEditorAction;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$13 = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate$3 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$2 = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var CodeEditorWidget = /** @class */ (function (_super) {
    __extends$13(CodeEditorWidget, _super);
    function CodeEditorWidget(domElement, options, isSimpleWidget, instantiationService, codeEditorService, commandService, contextKeyService, themeService, notificationService) {
        var _this = _super.call(this, domElement, options, isSimpleWidget, instantiationService, contextKeyService, notificationService) || this;
        _this._onMouseUp = _this._register(new Emitter());
        _this.onMouseUp = _this._onMouseUp.event;
        _this._onMouseDown = _this._register(new Emitter());
        _this.onMouseDown = _this._onMouseDown.event;
        _this._onMouseDrag = _this._register(new Emitter());
        _this.onMouseDrag = _this._onMouseDrag.event;
        _this._onMouseDrop = _this._register(new Emitter());
        _this.onMouseDrop = _this._onMouseDrop.event;
        _this._onContextMenu = _this._register(new Emitter());
        _this.onContextMenu = _this._onContextMenu.event;
        _this._onMouseMove = _this._register(new Emitter());
        _this.onMouseMove = _this._onMouseMove.event;
        _this._onMouseLeave = _this._register(new Emitter());
        _this.onMouseLeave = _this._onMouseLeave.event;
        _this._onKeyUp = _this._register(new Emitter());
        _this.onKeyUp = _this._onKeyUp.event;
        _this._onKeyDown = _this._register(new Emitter());
        _this.onKeyDown = _this._onKeyDown.event;
        _this._onDidScrollChange = _this._register(new Emitter());
        _this.onDidScrollChange = _this._onDidScrollChange.event;
        _this._onDidChangeViewZones = _this._register(new Emitter());
        _this.onDidChangeViewZones = _this._onDidChangeViewZones.event;
        _this._codeEditorService = codeEditorService;
        _this._commandService = commandService;
        _this._themeService = themeService;
        _this._focusTracker = new CodeEditorWidgetFocusTracker(domElement);
        _this._focusTracker.onChange(function () {
            _this._editorFocus.setValue(_this._focusTracker.hasFocus());
        });
        _this.contentWidgets = {};
        _this.overlayWidgets = {};
        var contributions = _this._getContributions();
        for (var i = 0, len = contributions.length; i < len; i++) {
            var ctor = contributions[i];
            try {
                var contribution = _this._instantiationService.createInstance(ctor, _this);
                _this._contributions[contribution.getId()] = contribution;
            }
            catch (err) {
                onUnexpectedError(err);
            }
        }
        _this._getActions().forEach(function (action) {
            var internalAction = new InternalEditorAction(action.id, action.label, action.alias, action.precondition, function () {
                return _this._instantiationService.invokeFunction(function (accessor) {
                    return action.runEditorCommand(accessor, _this, null);
                });
            }, _this._contextKeyService);
            _this._actions[internalAction.id] = internalAction;
        });
        _this._codeEditorService.addCodeEditor(_this);
        return _this;
    }
    CodeEditorWidget.prototype._createConfiguration = function (options) {
        return new Configuration$1(options, this.domElement);
    };
    CodeEditorWidget.prototype.dispose = function () {
        this._codeEditorService.removeCodeEditor(this);
        this.contentWidgets = {};
        this.overlayWidgets = {};
        this._focusTracker.dispose();
        _super.prototype.dispose.call(this);
    };
    CodeEditorWidget.prototype.createOverviewRuler = function (cssClassName) {
        return this._view.createOverviewRuler(cssClassName);
    };
    CodeEditorWidget.prototype.getDomNode = function () {
        if (!this.hasView) {
            return null;
        }
        return this._view.domNode.domNode;
    };
    CodeEditorWidget.prototype.delegateVerticalScrollbarMouseDown = function (browserEvent) {
        if (!this.hasView) {
            return;
        }
        this._view.delegateVerticalScrollbarMouseDown(browserEvent);
    };
    CodeEditorWidget.prototype.layout = function (dimension) {
        this._configuration.observeReferenceElement(dimension);
        this.render();
    };
    CodeEditorWidget.prototype.focus = function () {
        if (!this.hasView) {
            return;
        }
        this._view.focus();
    };
    CodeEditorWidget.prototype.isFocused = function () {
        return this.hasView && this._view.isFocused();
    };
    CodeEditorWidget.prototype.hasWidgetFocus = function () {
        return this._focusTracker && this._focusTracker.hasFocus();
    };
    CodeEditorWidget.prototype.addContentWidget = function (widget) {
        var widgetData = {
            widget: widget,
            position: widget.getPosition()
        };
        if (this.contentWidgets.hasOwnProperty(widget.getId())) {
            console.warn('Overwriting a content widget with the same id.');
        }
        this.contentWidgets[widget.getId()] = widgetData;
        if (this.hasView) {
            this._view.addContentWidget(widgetData);
        }
    };
    CodeEditorWidget.prototype.layoutContentWidget = function (widget) {
        var widgetId = widget.getId();
        if (this.contentWidgets.hasOwnProperty(widgetId)) {
            var widgetData = this.contentWidgets[widgetId];
            widgetData.position = widget.getPosition();
            if (this.hasView) {
                this._view.layoutContentWidget(widgetData);
            }
        }
    };
    CodeEditorWidget.prototype.removeContentWidget = function (widget) {
        var widgetId = widget.getId();
        if (this.contentWidgets.hasOwnProperty(widgetId)) {
            var widgetData = this.contentWidgets[widgetId];
            delete this.contentWidgets[widgetId];
            if (this.hasView) {
                this._view.removeContentWidget(widgetData);
            }
        }
    };
    CodeEditorWidget.prototype.addOverlayWidget = function (widget) {
        var widgetData = {
            widget: widget,
            position: widget.getPosition()
        };
        if (this.overlayWidgets.hasOwnProperty(widget.getId())) {
            console.warn('Overwriting an overlay widget with the same id.');
        }
        this.overlayWidgets[widget.getId()] = widgetData;
        if (this.hasView) {
            this._view.addOverlayWidget(widgetData);
        }
    };
    CodeEditorWidget.prototype.layoutOverlayWidget = function (widget) {
        var widgetId = widget.getId();
        if (this.overlayWidgets.hasOwnProperty(widgetId)) {
            var widgetData = this.overlayWidgets[widgetId];
            widgetData.position = widget.getPosition();
            if (this.hasView) {
                this._view.layoutOverlayWidget(widgetData);
            }
        }
    };
    CodeEditorWidget.prototype.removeOverlayWidget = function (widget) {
        var widgetId = widget.getId();
        if (this.overlayWidgets.hasOwnProperty(widgetId)) {
            var widgetData = this.overlayWidgets[widgetId];
            delete this.overlayWidgets[widgetId];
            if (this.hasView) {
                this._view.removeOverlayWidget(widgetData);
            }
        }
    };
    CodeEditorWidget.prototype.changeViewZones = function (callback) {
        if (!this.hasView) {
            return;
        }
        var hasChanges = this._view.change(callback);
        if (hasChanges) {
            this._onDidChangeViewZones.fire();
        }
    };
    CodeEditorWidget.prototype.getTargetAtClientPoint = function (clientX, clientY) {
        if (!this.hasView) {
            return null;
        }
        return this._view.getTargetAtClientPoint(clientX, clientY);
    };
    CodeEditorWidget.prototype.getScrolledVisiblePosition = function (rawPosition) {
        if (!this.hasView) {
            return null;
        }
        var position$$1 = this.model.validatePosition(rawPosition);
        var layoutInfo = this._configuration.editor.layoutInfo;
        var top = this._getVerticalOffsetForPosition(position$$1.lineNumber, position$$1.column) - this.getScrollTop();
        var left = this._view.getOffsetForColumn(position$$1.lineNumber, position$$1.column) + layoutInfo.glyphMarginWidth + layoutInfo.lineNumbersWidth + layoutInfo.decorationsWidth - this.getScrollLeft();
        return {
            top: top,
            left: left,
            height: this._configuration.editor.lineHeight
        };
    };
    CodeEditorWidget.prototype.getOffsetForColumn = function (lineNumber, column) {
        if (!this.hasView) {
            return -1;
        }
        return this._view.getOffsetForColumn(lineNumber, column);
    };
    CodeEditorWidget.prototype.render = function () {
        if (!this.hasView) {
            return;
        }
        this._view.render(true, false);
    };
    CodeEditorWidget.prototype.applyFontInfo = function (target) {
        Configuration$1.applyFontInfoSlow(target, this._configuration.editor.fontInfo);
    };
    CodeEditorWidget.prototype._attachModel = function (model) {
        this._view = null;
        _super.prototype._attachModel.call(this, model);
        if (this._view) {
            this.domElement.appendChild(this._view.domNode.domNode);
            var keys = Object.keys(this.contentWidgets);
            for (var i = 0, len = keys.length; i < len; i++) {
                var widgetId = keys[i];
                this._view.addContentWidget(this.contentWidgets[widgetId]);
            }
            keys = Object.keys(this.overlayWidgets);
            for (var i = 0, len = keys.length; i < len; i++) {
                var widgetId = keys[i];
                this._view.addOverlayWidget(this.overlayWidgets[widgetId]);
            }
            this._view.render(false, true);
            this.hasView = true;
            this._view.domNode.domNode.setAttribute('data-uri', model.uri.toString());
        }
    };
    CodeEditorWidget.prototype._scheduleAtNextAnimationFrame = function (callback) {
        return scheduleAtNextAnimationFrame(callback);
    };
    CodeEditorWidget.prototype._createView = function () {
        var _this = this;
        var commandDelegate;
        if (this.isSimpleWidget) {
            commandDelegate = {
                paste: function (source, text, pasteOnNewLine, multicursorText) {
                    _this.cursor.trigger(source, Handler.Paste, { text: text, pasteOnNewLine: pasteOnNewLine, multicursorText: multicursorText });
                },
                type: function (source, text) {
                    _this.cursor.trigger(source, Handler.Type, { text: text });
                },
                replacePreviousChar: function (source, text, replaceCharCnt) {
                    _this.cursor.trigger(source, Handler.ReplacePreviousChar, { text: text, replaceCharCnt: replaceCharCnt });
                },
                compositionStart: function (source) {
                    _this.cursor.trigger(source, Handler.CompositionStart, undefined);
                },
                compositionEnd: function (source) {
                    _this.cursor.trigger(source, Handler.CompositionEnd, undefined);
                },
                cut: function (source) {
                    _this.cursor.trigger(source, Handler.Cut, undefined);
                }
            };
        }
        else {
            commandDelegate = {
                paste: function (source, text, pasteOnNewLine, multicursorText) {
                    _this._commandService.executeCommand(Handler.Paste, {
                        text: text,
                        pasteOnNewLine: pasteOnNewLine,
                        multicursorText: multicursorText
                    });
                },
                type: function (source, text) {
                    _this._commandService.executeCommand(Handler.Type, {
                        text: text
                    });
                },
                replacePreviousChar: function (source, text, replaceCharCnt) {
                    _this._commandService.executeCommand(Handler.ReplacePreviousChar, {
                        text: text,
                        replaceCharCnt: replaceCharCnt
                    });
                },
                compositionStart: function (source) {
                    _this._commandService.executeCommand(Handler.CompositionStart, {});
                },
                compositionEnd: function (source) {
                    _this._commandService.executeCommand(Handler.CompositionEnd, {});
                },
                cut: function (source) {
                    _this._commandService.executeCommand(Handler.Cut, {});
                }
            };
        }
        this._view = new View(commandDelegate, this._configuration, this._themeService, this.viewModel, this.cursor, function (editorCommand, args) {
            if (!_this.cursor) {
                return;
            }
            editorCommand.runCoreEditorCommand(_this.cursor, args);
        });
        var viewEventBus = this._view.getInternalEventBus();
        viewEventBus.onDidGainFocus = function () {
            _this._editorTextFocus.setValue(true);
            // In IE, the focus is not synchronous, so we give it a little help
            _this._editorFocus.setValue(true);
        };
        viewEventBus.onDidScroll = function (e) { return _this._onDidScrollChange.fire(e); };
        viewEventBus.onDidLoseFocus = function () { return _this._editorTextFocus.setValue(false); };
        viewEventBus.onContextMenu = function (e) { return _this._onContextMenu.fire(e); };
        viewEventBus.onMouseDown = function (e) { return _this._onMouseDown.fire(e); };
        viewEventBus.onMouseUp = function (e) { return _this._onMouseUp.fire(e); };
        viewEventBus.onMouseDrag = function (e) { return _this._onMouseDrag.fire(e); };
        viewEventBus.onMouseDrop = function (e) { return _this._onMouseDrop.fire(e); };
        viewEventBus.onKeyUp = function (e) { return _this._onKeyUp.fire(e); };
        viewEventBus.onMouseMove = function (e) { return _this._onMouseMove.fire(e); };
        viewEventBus.onMouseLeave = function (e) { return _this._onMouseLeave.fire(e); };
        viewEventBus.onKeyDown = function (e) { return _this._onKeyDown.fire(e); };
    };
    CodeEditorWidget.prototype.restoreViewState = function (s) {
        _super.prototype.restoreViewState.call(this, s);
        if (!this.cursor || !this.hasView) {
            return;
        }
        if (s && s.cursorState && s.viewState) {
            var reducedState = this.viewModel.reduceRestoreState(s.viewState);
            var linesViewportData = this.viewModel.viewLayout.getLinesViewportDataAtScrollTop(reducedState.scrollTop);
            var startPosition = this.viewModel.coordinatesConverter.convertViewPositionToModelPosition(new Position(linesViewportData.startLineNumber, 1));
            var endPosition = this.viewModel.coordinatesConverter.convertViewPositionToModelPosition(new Position(linesViewportData.endLineNumber, 1));
            this.model.tokenizeViewport(startPosition.lineNumber, endPosition.lineNumber);
            this._view.restoreState(reducedState);
        }
    };
    CodeEditorWidget.prototype._detachModel = function () {
        var removeDomNode = null;
        if (this._view) {
            this._view.dispose();
            removeDomNode = this._view.domNode.domNode;
            this._view = null;
        }
        var result = _super.prototype._detachModel.call(this);
        if (removeDomNode) {
            this.domElement.removeChild(removeDomNode);
        }
        return result;
    };
    // BEGIN decorations
    CodeEditorWidget.prototype._registerDecorationType = function (key, options, parentTypeKey) {
        this._codeEditorService.registerDecorationType(key, options, parentTypeKey);
    };
    CodeEditorWidget.prototype._removeDecorationType = function (key) {
        this._codeEditorService.removeDecorationType(key);
    };
    CodeEditorWidget.prototype._resolveDecorationOptions = function (typeKey, writable) {
        return this._codeEditorService.resolveDecorationOptions(typeKey, writable);
    };
    // END decorations
    CodeEditorWidget.prototype._triggerEditorCommand = function (source, handlerId, payload) {
        var command = EditorExtensionsRegistry.getEditorCommand(handlerId);
        if (command) {
            payload = payload || {};
            payload.source = source;
            TPromise.as(command.runEditorCommand(null, this, payload)).done(null, onUnexpectedError);
            return true;
        }
        return false;
    };
    CodeEditorWidget = __decorate$3([
        __param$2(3, IInstantiationService),
        __param$2(4, ICodeEditorService),
        __param$2(5, ICommandService),
        __param$2(6, IContextKeyService),
        __param$2(7, IThemeService),
        __param$2(8, INotificationService)
    ], CodeEditorWidget);
    return CodeEditorWidget;
}(CommonCodeEditor));
var CodeEditorWidgetFocusTracker = /** @class */ (function (_super) {
    __extends$13(CodeEditorWidgetFocusTracker, _super);
    function CodeEditorWidgetFocusTracker(domElement) {
        var _this = _super.call(this) || this;
        _this._onChange = _this._register(new Emitter());
        _this.onChange = _this._onChange.event;
        _this._hasFocus = false;
        _this._domFocusTracker = _this._register(trackFocus(domElement));
        _this._register(_this._domFocusTracker.onDidFocus(function () {
            _this._hasFocus = true;
            _this._onChange.fire(void 0);
        }));
        _this._register(_this._domFocusTracker.onDidBlur(function () {
            _this._hasFocus = false;
            _this._onChange.fire(void 0);
        }));
        return _this;
    }
    CodeEditorWidgetFocusTracker.prototype.hasFocus = function () {
        return this._hasFocus;
    };
    return CodeEditorWidgetFocusTracker;
}(Disposable));
var squigglyStart = encodeURIComponent("<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 6 3' enable-background='new 0 0 6 3' height='3' width='6'><g fill='");
var squigglyEnd = encodeURIComponent("'><polygon points='5.5,0 2.5,3 1.1,3 4.1,0'/><polygon points='4,0 6,2 6,0.6 5.4,0'/><polygon points='0,2 1,3 2.4,3 0,0.6'/></g></svg>");
function getSquigglySVGData(color) {
    return squigglyStart + encodeURIComponent(color.toString()) + squigglyEnd;
}
var dotdotdotStart = encodeURIComponent("<svg xmlns=\"http://www.w3.org/2000/svg\" height=\"3\" width=\"12\"><g fill=\"");
var dotdotdotEnd = encodeURIComponent("\"><circle cx=\"1\" cy=\"1\" r=\"1\"/><circle cx=\"5\" cy=\"1\" r=\"1\"/><circle cx=\"9\" cy=\"1\" r=\"1\"/></g></svg>");
function getDotDotDotSVGData(color) {
    return dotdotdotStart + encodeURIComponent(color.toString()) + dotdotdotEnd;
}
registerThemingParticipant(function (theme, collector) {
    var errorBorderColor = theme.getColor(editorErrorBorder);
    if (errorBorderColor) {
        collector.addRule(".monaco-editor ." + ClassName.EditorErrorDecoration + " { border-bottom: 4px double " + errorBorderColor + "; }");
    }
    var errorForeground = theme.getColor(editorErrorForeground);
    if (errorForeground) {
        collector.addRule(".monaco-editor ." + ClassName.EditorErrorDecoration + " { background: url(\"data:image/svg+xml," + getSquigglySVGData(errorForeground) + "\") repeat-x bottom left; }");
    }
    var warningBorderColor = theme.getColor(editorWarningBorder);
    if (warningBorderColor) {
        collector.addRule(".monaco-editor ." + ClassName.EditorWarningDecoration + " { border-bottom: 4px double " + warningBorderColor + "; }");
    }
    var warningForeground = theme.getColor(editorWarningForeground);
    if (warningForeground) {
        collector.addRule(".monaco-editor ." + ClassName.EditorWarningDecoration + " { background: url(\"data:image/svg+xml," + getSquigglySVGData(warningForeground) + "\") repeat-x bottom left; }");
    }
    var infoBorderColor = theme.getColor(editorInfoBorder);
    if (infoBorderColor) {
        collector.addRule(".monaco-editor ." + ClassName.EditorInfoDecoration + " { border-bottom: 4px double " + infoBorderColor + "; }");
    }
    var infoForeground = theme.getColor(editorInfoForeground);
    if (infoForeground) {
        collector.addRule(".monaco-editor ." + ClassName.EditorInfoDecoration + " { background: url(\"data:image/svg+xml," + getSquigglySVGData(infoForeground) + "\") repeat-x bottom left; }");
    }
    var hintBorderColor = theme.getColor(editorHintBorder);
    if (hintBorderColor) {
        collector.addRule(".monaco-editor ." + ClassName.EditorHintDecoration + " { border-bottom: 2px dotted " + hintBorderColor + "; }");
    }
    var hintForeground = theme.getColor(editorHintForeground);
    if (hintForeground) {
        collector.addRule(".monaco-editor ." + ClassName.EditorHintDecoration + " { background: url(\"data:image/svg+xml," + getDotDotDotSVGData(hintForeground) + "\") no-repeat bottom left; }");
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$14 = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate$4 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$3 = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var CodeEditor = /** @class */ (function (_super) {
    __extends$14(CodeEditor, _super);
    function CodeEditor(domElement, options, instantiationService, codeEditorService, commandService, contextKeyService, themeService, notificationService) {
        return _super.call(this, domElement, options, false, instantiationService, codeEditorService, commandService, contextKeyService, themeService, notificationService) || this;
    }
    CodeEditor.prototype._getContributions = function () {
        return EditorExtensionsRegistry.getEditorContributions();
    };
    CodeEditor.prototype._getActions = function () {
        return EditorExtensionsRegistry.getEditorActions();
    };
    CodeEditor = __decorate$4([
        __param$3(2, IInstantiationService),
        __param$3(3, ICodeEditorService),
        __param$3(4, ICommandService),
        __param$3(5, IContextKeyService),
        __param$3(6, IThemeService),
        __param$3(7, INotificationService)
    ], CodeEditor);
    return CodeEditor;
}(CodeEditorWidget));

const css$k = "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/* ---------- DiffEditor ---------- */\n\n.monaco-diff-editor .diffOverview {\n\tz-index: 9;\n}\n\n/* colors not externalized: using transparancy on background */\n.monaco-diff-editor.vs\t\t\t.diffOverview { background: rgba(0, 0, 0, 0.03); }\n.monaco-diff-editor.vs-dark\t\t.diffOverview { background: rgba(255, 255, 255, 0.01); }\n\n.monaco-diff-editor .diffViewport {\n\tbox-shadow: inset 0px 0px 1px 0px #B9B9B9;\n\tbackground: rgba(0, 0, 0, 0.10);\n}\n\n.monaco-diff-editor.vs-dark .diffViewport,\n.monaco-diff-editor.hc-black .diffViewport {\n\tbackground: rgba(255, 255, 255, 0.10);\n}\n.monaco-scrollable-element.modified-in-monaco-diff-editor.vs\t\t.scrollbar { background: rgba(0,0,0,0); }\n.monaco-scrollable-element.modified-in-monaco-diff-editor.vs-dark\t.scrollbar { background: rgba(0,0,0,0); }\n.monaco-scrollable-element.modified-in-monaco-diff-editor.hc-black\t.scrollbar { background: none; }\n\n.monaco-scrollable-element.modified-in-monaco-diff-editor .slider {\n\tz-index: 10;\n}\n.modified-in-monaco-diff-editor\t\t\t\t.slider.active { background: rgba(171, 171, 171, .4); }\n.modified-in-monaco-diff-editor.hc-black\t.slider.active { background: none; }\n\n/* ---------- Diff ---------- */\n\n.monaco-editor .insert-sign,\n.monaco-diff-editor .insert-sign,\n.monaco-editor .delete-sign,\n.monaco-diff-editor .delete-sign {\n\tbackground-size: 60%;\n\topacity: 0.7;\n\tbackground-repeat: no-repeat;\n\tbackground-position: 50% 50%;\n}\n.monaco-editor.hc-black .insert-sign,\n.monaco-diff-editor.hc-black .insert-sign,\n.monaco-editor.hc-black .delete-sign,\n.monaco-diff-editor.hc-black .delete-sign {\n\topacity: 1;\n}\n.monaco-editor .insert-sign,\n.monaco-diff-editor .insert-sign {\n\tbackground-image: url(\"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHRpdGxlPkxheWVyIDE8L3RpdGxlPjxyZWN0IGhlaWdodD0iMTEiIHdpZHRoPSIzIiB5PSIzIiB4PSI3IiBmaWxsPSIjNDI0MjQyIi8+PHJlY3QgaGVpZ2h0PSIzIiB3aWR0aD0iMTEiIHk9IjciIHg9IjMiIGZpbGw9IiM0MjQyNDIiLz48L3N2Zz4=\");\n}\n.monaco-editor .delete-sign,\n.monaco-diff-editor .delete-sign {\n\tbackground-image: url(\"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHRpdGxlPkxheWVyIDE8L3RpdGxlPjxyZWN0IGhlaWdodD0iMyIgd2lkdGg9IjExIiB5PSI3IiB4PSIzIiBmaWxsPSIjNDI0MjQyIi8+PC9zdmc+\");\n}\n\n.monaco-editor.vs-dark .insert-sign,\n.monaco-diff-editor.vs-dark .insert-sign,\n.monaco-editor.hc-black .insert-sign,\n.monaco-diff-editor.hc-black .insert-sign {\n\tbackground-image: url(\"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHRpdGxlPkxheWVyIDE8L3RpdGxlPjxyZWN0IGhlaWdodD0iMTEiIHdpZHRoPSIzIiB5PSIzIiB4PSI3IiBmaWxsPSIjQzVDNUM1Ii8+PHJlY3QgaGVpZ2h0PSIzIiB3aWR0aD0iMTEiIHk9IjciIHg9IjMiIGZpbGw9IiNDNUM1QzUiLz48L3N2Zz4=\");\n}\n.monaco-editor.vs-dark .delete-sign,\n.monaco-diff-editor.vs-dark .delete-sign,\n.monaco-editor.hc-black .delete-sign,\n.monaco-diff-editor.hc-black .delete-sign {\n\tbackground-image: url(\"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHRpdGxlPkxheWVyIDE8L3RpdGxlPjxyZWN0IGhlaWdodD0iMyIgd2lkdGg9IjExIiB5PSI3IiB4PSIzIiBmaWxsPSIjQzVDNUM1Ii8+PC9zdmc+\");\n}\n\n.monaco-editor .inline-deleted-margin-view-zone {\n\ttext-align: right;\n}\n.monaco-editor .inline-added-margin-view-zone {\n\ttext-align: right;\n}\n\n.monaco-editor .diagonal-fill {\n\tbackground: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJCAYAAADgkQYQAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAadEVYdFNvZnR3YXJlAFBhaW50Lk5FVCB2My41LjEwMPRyoQAAAChJREFUKFNjOH/+fAMDDgCSu3Dhwn9c8gwwBTgNGR4KQP4HhQOhsAIAZCBTkhtqePcAAAAASUVORK5CYII=\");\n}\n.monaco-editor.vs-dark .diagonal-fill {\n\topacity: 0.2;\n}\n.monaco-editor.hc-black .diagonal-fill {\n\tbackground: none;\n}\n\n/* ---------- Inline Diff ---------- */\n\n.monaco-editor .view-zones .view-lines .view-line span {\n\tdisplay: inline-block;\n}\n";
  const element$k = ((css, src) => {
if (typeof document !== 'object')
console.info(`Skipped loading "${src}"`);
try {
const id = src
  .replace(/\.css.*$/, '')
  .replace(/[\\:]/g, '/')
  .replace(/[^\w\/]+/g, '');
return (
  document.querySelector(`style[id="${id}"]`) ||
  document.head.appendChild(
    Object.assign(document.createElement('style'), {
      id,
      textContent: `${css}\n\n /* sourceURL=${src} */`,
    }),
  )
);
} catch (exception) {
console.warn(`Failed load "${src}"`, exception);
}
})(css$k, "…monaco-editor/esm/vs/editor/browser/widget/media/diffEditor.css");
  //@ sourceURL=/Users/daflair/Projects/packages/monaco-es/node_modules/monaco-editor/esm/vs/editor/browser/widget/media/diffEditor.css

const css$l = "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n.monaco-sash {\n\tposition: absolute;\n\tz-index: 90;\n\ttouch-action: none;\n}\n\n.monaco-sash.vertical {\n\tcursor: ew-resize;\n\theight: 100%;\n\ttop: 0;\n}\n\n.monaco-sash.horizontal {\n\tcursor: ns-resize;\n\twidth: 100%;\n\tleft: 0;\n}\n\n.monaco-sash.disabled {\n\tcursor: default !important;\n}\n\n/** Custom Mac Cursor */\n\n.monaco-sash.mac.vertical {\n\tcursor: col-resize;\n}\n\n.monaco-sash.mac.horizontal {\n\tcursor: row-resize;\n}";
  const element$l = ((css, src) => {
if (typeof document !== 'object')
console.info(`Skipped loading "${src}"`);
try {
const id = src
  .replace(/\.css.*$/, '')
  .replace(/[\\:]/g, '/')
  .replace(/[^\w\/]+/g, '');
return (
  document.querySelector(`style[id="${id}"]`) ||
  document.head.appendChild(
    Object.assign(document.createElement('style'), {
      id,
      textContent: `${css}\n\n /* sourceURL=${src} */`,
    }),
  )
);
} catch (exception) {
console.warn(`Failed load "${src}"`, exception);
}
})(css$l, "…monaco-editor/esm/vs/base/browser/ui/sash/sash.css");
  //@ sourceURL=/Users/daflair/Projects/packages/monaco-es/node_modules/monaco-editor/esm/vs/base/browser/ui/sash/sash.css

const css$m = "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n.monaco-builder-hidden {\n\tdisplay: none !important;\n}";
  const element$m = ((css, src) => {
if (typeof document !== 'object')
console.info(`Skipped loading "${src}"`);
try {
const id = src
  .replace(/\.css.*$/, '')
  .replace(/[\\:]/g, '/')
  .replace(/[^\w\/]+/g, '');
return (
  document.querySelector(`style[id="${id}"]`) ||
  document.head.appendChild(
    Object.assign(document.createElement('style'), {
      id,
      textContent: `${css}\n\n /* sourceURL=${src} */`,
    }),
  )
);
} catch (exception) {
console.warn(`Failed load "${src}"`, exception);
}
})(css$m, "…monaco-editor/esm/vs/base/browser/builder.css");
  //@ sourceURL=/Users/daflair/Projects/packages/monaco-es/node_modules/monaco-editor/esm/vs/base/browser/builder.css

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$15 = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
// --- Implementation starts here
var MS_DATA_KEY = '_msDataKey';
var LISTENER_BINDING_ID = '__$listeners';
var VISIBILITY_BINDING_ID = '__$visibility';
function data(element) {
    if (!element[MS_DATA_KEY]) {
        element[MS_DATA_KEY] = {};
    }
    return element[MS_DATA_KEY];
}
function hasData(element) {
    return !!element[MS_DATA_KEY];
}
/**
 *  Wraps around the provided element to manipulate it and add more child elements.
 */
var Builder = /** @class */ (function () {
    function Builder(element, offdom) {
        this.offdom = offdom;
        this.container = element;
        this.currentElement = element;
        this.createdElements = [];
        this.toUnbind = {};
        this.captureToUnbind = {};
    }
    /**
     *  Returns a new builder that lets the current HTML Element of this builder be the container
     *  for future additions on the builder.
     */
    Builder.prototype.asContainer = function () {
        return withBuilder(this, this.offdom);
    };
    /**
     *  Clones the builder providing the same properties as this one.
     */
    Builder.prototype.clone = function () {
        var builder = new Builder(this.container, this.offdom);
        builder.currentElement = this.currentElement;
        builder.createdElements = this.createdElements;
        builder.captureToUnbind = this.captureToUnbind;
        builder.toUnbind = this.toUnbind;
        return builder;
    };
    Builder.prototype.build = function (container, index) {
        ok(this.offdom, 'This builder was not created off-dom, so build() can not be called.');
        // Use builders own container if present
        if (!container) {
            container = this.container;
        }
        // Handle case of passed in Builder
        else if (container instanceof Builder) {
            container = container.getHTMLElement();
        }
        ok(container, 'Builder can only be build() with a container provided.');
        ok(isHTMLElement(container), 'The container must either be a HTMLElement or a Builder.');
        var htmlContainer = container;
        // Append
        var i, len;
        var childNodes = htmlContainer.childNodes;
        if (isNumber(index) && index < childNodes.length) {
            for (i = 0, len = this.createdElements.length; i < len; i++) {
                htmlContainer.insertBefore(this.createdElements[i], childNodes[index++]);
            }
        }
        else {
            for (i = 0, len = this.createdElements.length; i < len; i++) {
                htmlContainer.appendChild(this.createdElements[i]);
            }
        }
        return this;
    };
    Builder.prototype.appendTo = function (container, index) {
        // Use builders own container if present
        if (!container) {
            container = this.container;
        }
        // Handle case of passed in Builder
        else if (container instanceof Builder) {
            container = container.getHTMLElement();
        }
        ok(container, 'Builder can only be build() with a container provided.');
        ok(isHTMLElement(container), 'The container must either be a HTMLElement or a Builder.');
        var htmlContainer = container;
        // Remove node from parent, if needed
        if (this.currentElement.parentNode) {
            this.currentElement.parentNode.removeChild(this.currentElement);
        }
        var childNodes = htmlContainer.childNodes;
        if (isNumber(index) && index < childNodes.length) {
            htmlContainer.insertBefore(this.currentElement, childNodes[index]);
        }
        else {
            htmlContainer.appendChild(this.currentElement);
        }
        return this;
    };
    Builder.prototype.append = function (child, index) {
        ok(child, 'Need a child to append');
        if (isHTMLElement(child)) {
            child = withElement(child);
        }
        ok(child instanceof Builder || child instanceof MultiBuilder, 'Need a child to append');
        child.appendTo(this, index);
        return this;
    };
    /**
     *  Removes the current element of this builder from its parent node.
     */
    Builder.prototype.offDOM = function () {
        if (this.currentElement.parentNode) {
            this.currentElement.parentNode.removeChild(this.currentElement);
        }
        return this;
    };
    /**
     *  Returns the HTML Element the builder is currently active on.
     */
    Builder.prototype.getHTMLElement = function () {
        return this.currentElement;
    };
    /**
     *  Returns the HTML Element the builder is building in.
     */
    Builder.prototype.getContainer = function () {
        return this.container;
    };
    // HTML Elements
    /**
     *  Creates a new element of this kind as child of the current element or parent.
     *  Accepts an object literal as first parameter that can be used to describe the
     *  attributes of the element.
     *  Accepts a function as second parameter that can be used to create child elements
     *  of the element. The function will be called with a new builder created with the
     *  provided element.
     */
    Builder.prototype.div = function (attributes, fn) {
        return this.doElement('div', attributes, fn);
    };
    /**
     *  Creates a new element of this kind as child of the current element or parent.
     *  Accepts an object literal as first parameter that can be used to describe the
     *  attributes of the element.
     *  Accepts a function as second parameter that can be used to create child elements
     *  of the element. The function will be called with a new builder created with the
     *  provided element.
     */
    Builder.prototype.p = function (attributes, fn) {
        return this.doElement('p', attributes, fn);
    };
    /**
     *  Creates a new element of this kind as child of the current element or parent.
     *  Accepts an object literal as first parameter that can be used to describe the
     *  attributes of the element.
     *  Accepts a function as second parameter that can be used to create child elements
     *  of the element. The function will be called with a new builder created with the
     *  provided element.
     */
    Builder.prototype.ul = function (attributes, fn) {
        return this.doElement('ul', attributes, fn);
    };
    /**
     *  Creates a new element of this kind as child of the current element or parent.
     *  Accepts an object literal as first parameter that can be used to describe the
     *  attributes of the element.
     *  Accepts a function as second parameter that can be used to create child elements
     *  of the element. The function will be called with a new builder created with the
     *  provided element.
     */
    Builder.prototype.li = function (attributes, fn) {
        return this.doElement('li', attributes, fn);
    };
    /**
     *  Creates a new element of this kind as child of the current element or parent.
     *  Accepts an object literal as first parameter that can be used to describe the
     *  attributes of the element.
     *  Accepts a function as second parameter that can be used to create child elements
     *  of the element. The function will be called with a new builder created with the
     *  provided element.
     */
    Builder.prototype.span = function (attributes, fn) {
        return this.doElement('span', attributes, fn);
    };
    /**
     *  Creates a new element of this kind as child of the current element or parent.
     *  Accepts an object literal as first parameter that can be used to describe the
     *  attributes of the element.
     *  Accepts a function as second parameter that can be used to create child elements
     *  of the element. The function will be called with a new builder created with the
     *  provided element.
     */
    Builder.prototype.img = function (attributes, fn) {
        return this.doElement('img', attributes, fn);
    };
    /**
     *  Creates a new element of this kind as child of the current element or parent.
     *  Accepts an object literal as first parameter that can be used to describe the
     *  attributes of the element.
     *  Accepts a function as second parameter that can be used to create child elements
     *  of the element. The function will be called with a new builder created with the
     *  provided element.
     */
    Builder.prototype.a = function (attributes, fn) {
        return this.doElement('a', attributes, fn);
    };
    /**
     *  Creates a new element of given tag name as child of the current element or parent.
     *  Accepts an object literal as first parameter that can be used to describe the
     *  attributes of the element.
     *  Accepts a function as second parameter that can be used to create child elements
     *  of the element. The function will be called with a new builder created with the
     *  provided element.
     */
    Builder.prototype.element = function (name, attributes, fn) {
        return this.doElement(name, attributes, fn);
    };
    Builder.prototype.doElement = function (name, attributesOrFn, fn) {
        // Create Element
        var element = document.createElement(name);
        this.currentElement = element;
        // Off-DOM: Remember in array of created elements
        if (this.offdom) {
            this.createdElements.push(element);
        }
        // Object (apply properties as attributes to HTML element)
        if (isObject(attributesOrFn)) {
            this.attr(attributesOrFn);
        }
        // Support second argument being function
        if (isFunction(attributesOrFn)) {
            fn = attributesOrFn;
        }
        // Apply Functions (Elements created in Functions will be added as child to current element)
        if (isFunction(fn)) {
            var builder = new Builder(element);
            fn.call(builder, builder); // Set both 'this' and the first parameter to the new builder
        }
        // Add to parent
        if (!this.offdom) {
            this.container.appendChild(element);
        }
        return this;
    };
    /**
     *  Calls focus() on the current HTML element;
     */
    Builder.prototype.domFocus = function () {
        this.currentElement.focus();
        return this;
    };
    /**
     *  Calls blur() on the current HTML element;
     */
    Builder.prototype.domBlur = function () {
        this.currentElement.blur();
        return this;
    };
    Builder.prototype.on = function (arg1, fn, listenerToUnbindContainer, useCapture) {
        var _this = this;
        // Event Type Array
        if (isArray(arg1)) {
            arg1.forEach(function (type) {
                _this.on(type, fn, listenerToUnbindContainer, useCapture);
            });
        }
        // Single Event Type
        else {
            var type = arg1;
            // Add Listener
            var unbind_1 = addDisposableListener(this.currentElement, type, function (e) {
                fn(e, _this, unbind_1); // Pass in Builder as Second Argument
            }, useCapture || false);
            // Remember for off() use
            if (useCapture) {
                if (!this.captureToUnbind[type]) {
                    this.captureToUnbind[type] = [];
                }
                this.captureToUnbind[type].push(unbind_1);
            }
            else {
                if (!this.toUnbind[type]) {
                    this.toUnbind[type] = [];
                }
                this.toUnbind[type].push(unbind_1);
            }
            // Bind to Element
            var listenerBinding = this.getProperty(LISTENER_BINDING_ID, []);
            listenerBinding.push(unbind_1);
            this.setProperty(LISTENER_BINDING_ID, listenerBinding);
            // Add to Array if passed in
            if (listenerToUnbindContainer && isArray(listenerToUnbindContainer)) {
                listenerToUnbindContainer.push(unbind_1);
            }
        }
        return this;
    };
    Builder.prototype.off = function (arg1, useCapture) {
        var _this = this;
        // Event Type Array
        if (isArray(arg1)) {
            arg1.forEach(function (type) {
                _this.off(type);
            });
        }
        // Single Event Type
        else {
            var type = arg1;
            if (useCapture) {
                if (this.captureToUnbind[type]) {
                    this.captureToUnbind[type] = dispose(this.captureToUnbind[type]);
                }
            }
            else {
                if (this.toUnbind[type]) {
                    this.toUnbind[type] = dispose(this.toUnbind[type]);
                }
            }
        }
        return this;
    };
    Builder.prototype.once = function (arg1, fn, listenerToUnbindContainer, useCapture) {
        var _this = this;
        // Event Type Array
        if (isArray(arg1)) {
            arg1.forEach(function (type) {
                _this.once(type, fn);
            });
        }
        // Single Event Type
        else {
            var type = arg1;
            // Add Listener
            var unbind_2 = addDisposableListener(this.currentElement, type, function (e) {
                fn(e, _this, unbind_2); // Pass in Builder as Second Argument
                unbind_2.dispose();
            }, useCapture || false);
            // Add to Array if passed in
            if (listenerToUnbindContainer && isArray(listenerToUnbindContainer)) {
                listenerToUnbindContainer.push(unbind_2);
            }
        }
        return this;
    };
    Builder.prototype.attr = function (firstP, secondP) {
        // Apply Object Literal to Attributes of Element
        if (isObject(firstP)) {
            for (var prop in firstP) {
                if (firstP.hasOwnProperty(prop)) {
                    var value = firstP[prop];
                    this.doSetAttr(prop, value);
                }
            }
            return this;
        }
        // Get Attribute Value
        if (isString(firstP) && !isString(secondP)) {
            return this.currentElement.getAttribute(firstP);
        }
        // Set Attribute Value
        if (isString(firstP)) {
            if (!isString(secondP)) {
                secondP = String(secondP);
            }
            this.doSetAttr(firstP, secondP);
        }
        return this;
    };
    Builder.prototype.doSetAttr = function (prop, value) {
        if (prop === 'class') {
            prop = 'addClass'; // Workaround for the issue that a function name can not be 'class' in ES
        }
        if (this[prop]) {
            if (isArray(value)) {
                this[prop].apply(this, value);
            }
            else {
                this[prop].call(this, value);
            }
        }
        else {
            this.currentElement.setAttribute(prop, value);
        }
    };
    /**
     * Removes an attribute by the given name.
     */
    Builder.prototype.removeAttribute = function (prop) {
        this.currentElement.removeAttribute(prop);
    };
    /**
     *  Sets the id attribute to the value provided for the current HTML element of the builder.
     */
    Builder.prototype.id = function (id) {
        this.currentElement.setAttribute('id', id);
        return this;
    };
    /**
     *  Sets the title attribute to the value provided for the current HTML element of the builder.
     */
    Builder.prototype.title = function (title) {
        this.currentElement.setAttribute('title', title);
        return this;
    };
    /**
     *  Sets the type attribute to the value provided for the current HTML element of the builder.
     */
    Builder.prototype.type = function (type) {
        this.currentElement.setAttribute('type', type);
        return this;
    };
    /**
     *  Sets the value attribute to the value provided for the current HTML element of the builder.
     */
    Builder.prototype.value = function (value) {
        this.currentElement.setAttribute('value', value);
        return this;
    };
    /**
     *  Sets the tabindex attribute to the value provided for the current HTML element of the builder.
     */
    Builder.prototype.tabindex = function (index) {
        this.currentElement.setAttribute('tabindex', index.toString());
        return this;
    };
    Builder.prototype.style = function (firstP, secondP) {
        // Apply Object Literal to Styles of Element
        if (isObject(firstP)) {
            for (var prop in firstP) {
                if (firstP.hasOwnProperty(prop)) {
                    var value = firstP[prop];
                    this.doSetStyle(prop, value);
                }
            }
            return this;
        }
        var hasFirstP = isString(firstP);
        // Get Style Value
        if (hasFirstP && isUndefined(secondP)) {
            return this.currentElement.style[this.cssKeyToJavaScriptProperty(firstP)];
        }
        // Set Style Value
        else if (hasFirstP) {
            this.doSetStyle(firstP, secondP);
        }
        return this;
    };
    Builder.prototype.doSetStyle = function (key, value) {
        if (key.indexOf('-') >= 0) {
            var segments = key.split('-');
            key = segments[0];
            for (var i = 1; i < segments.length; i++) {
                var segment = segments[i];
                key = key + segment.charAt(0).toUpperCase() + segment.substr(1);
            }
        }
        this.currentElement.style[this.cssKeyToJavaScriptProperty(key)] = value;
    };
    Builder.prototype.cssKeyToJavaScriptProperty = function (key) {
        // Automagically convert dashes as they are not allowed when programmatically
        // setting a CSS style property
        if (key.indexOf('-') >= 0) {
            var segments = key.split('-');
            key = segments[0];
            for (var i = 1; i < segments.length; i++) {
                var segment = segments[i];
                key = key + segment.charAt(0).toUpperCase() + segment.substr(1);
            }
        }
        // Float is special too
        else if (key === 'float') {
            key = 'cssFloat';
        }
        return key;
    };
    /**
     *  Returns the computed CSS style for the current HTML element of the builder.
     */
    Builder.prototype.getComputedStyle = function () {
        return getComputedStyle(this.currentElement);
    };
    /**
     *  Adds the variable list of arguments as class names to the current HTML element of the builder.
     */
    Builder.prototype.addClass = function () {
        var _this = this;
        var classes = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            classes[_i] = arguments[_i];
        }
        classes.forEach(function (nameValue) {
            var names = nameValue.split(' ');
            names.forEach(function (name) {
                addClass(_this.currentElement, name);
            });
        });
        return this;
    };
    /**
     *  Sets the class name of the current HTML element of the builder to the provided className.
     *  If shouldAddClass is provided - for true class is added, for false class is removed.
     */
    Builder.prototype.setClass = function (className, shouldAddClass) {
        if (shouldAddClass === void 0) { shouldAddClass = null; }
        if (shouldAddClass === null) {
            this.currentElement.className = className;
        }
        else if (shouldAddClass) {
            this.addClass(className);
        }
        else {
            this.removeClass(className);
        }
        return this;
    };
    /**
     *  Returns whether the current HTML element of the builder has the provided class assigned.
     */
    Builder.prototype.hasClass = function (className) {
        return hasClass(this.currentElement, className);
    };
    /**
     *  Removes the variable list of arguments as class names from the current HTML element of the builder.
     */
    Builder.prototype.removeClass = function () {
        var _this = this;
        var classes = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            classes[_i] = arguments[_i];
        }
        classes.forEach(function (nameValue) {
            var names = nameValue.split(' ');
            names.forEach(function (name) {
                removeClass(_this.currentElement, name);
            });
        });
        return this;
    };
    /**
     *  Adds or removes the provided className for the current HTML element of the builder.
     */
    Builder.prototype.toggleClass = function (className) {
        if (this.hasClass(className)) {
            this.removeClass(className);
        }
        else {
            this.addClass(className);
        }
        return this;
    };
    /**
     *  Sets the CSS property color.
     */
    Builder.prototype.color = function (color) {
        this.currentElement.style.color = color;
        return this;
    };
    Builder.prototype.padding = function (top, right, bottom, left) {
        if (isString(top) && top.indexOf(' ') >= 0) {
            return this.padding.apply(this, top.split(' '));
        }
        if (!isUndefinedOrNull(top)) {
            this.currentElement.style.paddingTop = this.toPixel(top);
        }
        if (!isUndefinedOrNull(right)) {
            this.currentElement.style.paddingRight = this.toPixel(right);
        }
        if (!isUndefinedOrNull(bottom)) {
            this.currentElement.style.paddingBottom = this.toPixel(bottom);
        }
        if (!isUndefinedOrNull(left)) {
            this.currentElement.style.paddingLeft = this.toPixel(left);
        }
        return this;
    };
    Builder.prototype.margin = function (top, right, bottom, left) {
        if (isString(top) && top.indexOf(' ') >= 0) {
            return this.margin.apply(this, top.split(' '));
        }
        if (!isUndefinedOrNull(top)) {
            this.currentElement.style.marginTop = this.toPixel(top);
        }
        if (!isUndefinedOrNull(right)) {
            this.currentElement.style.marginRight = this.toPixel(right);
        }
        if (!isUndefinedOrNull(bottom)) {
            this.currentElement.style.marginBottom = this.toPixel(bottom);
        }
        if (!isUndefinedOrNull(left)) {
            this.currentElement.style.marginLeft = this.toPixel(left);
        }
        return this;
    };
    Builder.prototype.position = function (top, right, bottom, left, position$$1) {
        if (isString(top) && top.indexOf(' ') >= 0) {
            return this.position.apply(this, top.split(' '));
        }
        if (!isUndefinedOrNull(top)) {
            this.currentElement.style.top = this.toPixel(top);
        }
        if (!isUndefinedOrNull(right)) {
            this.currentElement.style.right = this.toPixel(right);
        }
        if (!isUndefinedOrNull(bottom)) {
            this.currentElement.style.bottom = this.toPixel(bottom);
        }
        if (!isUndefinedOrNull(left)) {
            this.currentElement.style.left = this.toPixel(left);
        }
        if (!position$$1) {
            position$$1 = 'absolute';
        }
        this.currentElement.style.position = position$$1;
        return this;
    };
    Builder.prototype.size = function (width, height) {
        if (isString(width) && width.indexOf(' ') >= 0) {
            return this.size.apply(this, width.split(' '));
        }
        if (!isUndefinedOrNull(width)) {
            this.currentElement.style.width = this.toPixel(width);
        }
        if (!isUndefinedOrNull(height)) {
            this.currentElement.style.height = this.toPixel(height);
        }
        return this;
    };
    /**
     *  Sets the CSS property display.
     */
    Builder.prototype.display = function (display) {
        this.currentElement.style.display = display;
        return this;
    };
    /**
     *  Shows the current element of the builder.
     */
    Builder.prototype.show = function () {
        if (this.hasClass('monaco-builder-hidden')) {
            this.removeClass('monaco-builder-hidden');
        }
        this.attr('aria-hidden', 'false');
        // Cancel any pending showDelayed() invocation
        this.cancelVisibilityPromise();
        return this;
    };
    /**
     *  Shows the current builder element after the provided delay. If the builder
     *  was set to hidden using the hide() method before this method executed, the
     *  function will return without showing the current element. This is useful to
     *  only show the element when a specific delay is reached (e.g. for a long running
     *  operation.
     */
    Builder.prototype.showDelayed = function (delay) {
        var _this = this;
        // Cancel any pending showDelayed() invocation
        this.cancelVisibilityPromise();
        var promise = TPromise.timeout(delay);
        this.setProperty(VISIBILITY_BINDING_ID, promise);
        promise.done(function () {
            _this.removeProperty(VISIBILITY_BINDING_ID);
            _this.show();
        });
        return this;
    };
    /**
     *  Hides the current element of the builder.
     */
    Builder.prototype.hide = function () {
        if (!this.hasClass('monaco-builder-hidden')) {
            this.addClass('monaco-builder-hidden');
        }
        this.attr('aria-hidden', 'true');
        // Cancel any pending showDelayed() invocation
        this.cancelVisibilityPromise();
        return this;
    };
    /**
     *  Returns true if the current element of the builder is hidden.
     */
    Builder.prototype.isHidden = function () {
        return this.hasClass('monaco-builder-hidden') || this.currentElement.style.display === 'none';
    };
    Builder.prototype.cancelVisibilityPromise = function () {
        var promise = this.getProperty(VISIBILITY_BINDING_ID);
        if (promise) {
            promise.cancel();
            this.removeProperty(VISIBILITY_BINDING_ID);
        }
    };
    Builder.prototype.toPixel = function (obj) {
        if (obj.toString().indexOf('px') === -1) {
            return obj.toString() + 'px';
        }
        return obj;
    };
    /**
     *  Sets the innerHTML attribute.
     */
    Builder.prototype.innerHtml = function (html, append$$1) {
        if (append$$1) {
            this.currentElement.innerHTML += html;
        }
        else {
            this.currentElement.innerHTML = html;
        }
        return this;
    };
    /**
     *  Sets the textContent property of the element.
     *  All HTML special characters will be escaped.
     */
    Builder.prototype.text = function (text, append$$1) {
        if (append$$1) {
            // children is child Elements versus childNodes includes textNodes
            if (this.currentElement.children.length === 0) {
                this.currentElement.textContent += text;
            }
            else {
                // if there are elements inside this node, append the string as a new text node
                // to avoid wiping out the innerHTML and replacing it with only text content
                this.currentElement.appendChild(document.createTextNode(text));
            }
        }
        else {
            this.currentElement.textContent = text;
        }
        return this;
    };
    /**
     *  Sets the innerHTML attribute in escaped form.
     */
    Builder.prototype.safeInnerHtml = function (html, append$$1) {
        return this.innerHtml(escape(html), append$$1);
    };
    /**
     *  Allows to store arbritary data into the current element.
     */
    Builder.prototype.setProperty = function (key, value) {
        setPropertyOnElement(this.currentElement, key, value);
        return this;
    };
    /**
     *  Allows to get arbritary data from the current element.
     */
    Builder.prototype.getProperty = function (key, fallback) {
        return getPropertyFromElement(this.currentElement, key, fallback);
    };
    /**
     *  Removes a property from the current element that is stored under the given key.
     */
    Builder.prototype.removeProperty = function (key) {
        if (hasData(this.currentElement)) {
            delete data(this.currentElement)[key];
        }
        return this;
    };
    /**
     * Returns a new builder with the child at the given index.
     */
    Builder.prototype.child = function (index) {
        if (index === void 0) { index = 0; }
        var children = this.currentElement.children;
        return withElement(children.item(index));
    };
    /**
     * Recurse through all descendant nodes and remove their data binding.
     */
    Builder.prototype.unbindDescendants = function (current) {
        if (current && current.children) {
            for (var i = 0, length_1 = current.children.length; i < length_1; i++) {
                var element = current.children.item(i);
                // Unbind
                if (hasData(element)) {
                    // Listeners
                    var listeners = data(element)[LISTENER_BINDING_ID];
                    if (isArray(listeners)) {
                        while (listeners.length) {
                            listeners.pop().dispose();
                        }
                    }
                    // Delete Data Slot
                    delete element[MS_DATA_KEY];
                }
                // Recurse
                this.unbindDescendants(element);
            }
        }
    };
    /**
     *  Removes all HTML elements from the current element of the builder. Will also clean up any
     *  event listners registered and also clear any data binding and properties stored
     *  to any child element.
     */
    Builder.prototype.empty = function () {
        this.unbindDescendants(this.currentElement);
        this.clearChildren();
        if (this.offdom) {
            this.createdElements = [];
        }
        return this;
    };
    /**
     *  Removes all HTML elements from the current element of the builder.
     */
    Builder.prototype.clearChildren = function () {
        // Remove Elements
        if (this.currentElement) {
            clearNode(this.currentElement);
        }
        return this;
    };
    /**
     *  Removes the current HTML element and all its children from its parent and unbinds
     *  all listeners and properties set to the data slots.
     */
    Builder.prototype.destroy = function () {
        if (this.currentElement) {
            // Remove from parent
            if (this.currentElement.parentNode) {
                this.currentElement.parentNode.removeChild(this.currentElement);
            }
            // Empty to clear listeners and bindings from children
            this.empty();
            // Unbind
            if (hasData(this.currentElement)) {
                // Listeners
                var listeners = data(this.currentElement)[LISTENER_BINDING_ID];
                if (isArray(listeners)) {
                    while (listeners.length) {
                        listeners.pop().dispose();
                    }
                }
                // Delete Data Slot
                delete this.currentElement[MS_DATA_KEY];
            }
        }
        var type;
        for (type in this.toUnbind) {
            if (this.toUnbind.hasOwnProperty(type) && isArray(this.toUnbind[type])) {
                this.toUnbind[type] = dispose(this.toUnbind[type]);
            }
        }
        for (type in this.captureToUnbind) {
            if (this.captureToUnbind.hasOwnProperty(type) && isArray(this.captureToUnbind[type])) {
                this.captureToUnbind[type] = dispose(this.captureToUnbind[type]);
            }
        }
        // Nullify fields
        this.currentElement = null;
        this.container = null;
        this.offdom = null;
        this.createdElements = null;
        this.captureToUnbind = null;
        this.toUnbind = null;
    };
    /**
     *  Removes the current HTML element and all its children from its parent and unbinds
     *  all listeners and properties set to the data slots.
     */
    Builder.prototype.dispose = function () {
        this.destroy();
    };
    /**
     *  Gets the size (in pixels) of an element, including the margin.
     */
    Builder.prototype.getTotalSize = function () {
        var totalWidth = getTotalWidth(this.currentElement);
        var totalHeight = getTotalHeight(this.currentElement);
        return new Dimension(totalWidth, totalHeight);
    };
    /**
     *  Another variant of getting the inner dimensions of an element.
     */
    Builder.prototype.getClientArea = function () {
        return getClientArea(this.currentElement);
    };
    return Builder;
}());
/**
 *  The multi builder provides the same methods as the builder, but allows to call
 *  them on an array of builders.
 */
var MultiBuilder = /** @class */ (function (_super) {
    __extends$15(MultiBuilder, _super);
    function MultiBuilder(builders) {
        var _this = this;
        ok(isArray(builders) || builders instanceof MultiBuilder, 'Expected Array or MultiBuilder as parameter');
        _this = _super.call(this) || this;
        _this.length = 0;
        _this.builders = [];
        // Add Builders to Array
        if (isArray(builders)) {
            for (var i = 0; i < builders.length; i++) {
                if (builders[i] instanceof HTMLElement) {
                    _this.push(withElement(builders[i]));
                }
                else {
                    _this.push(builders[i]);
                }
            }
        }
        else {
            for (var i = 0; i < builders.length; i++) {
                _this.push(builders.item(i));
            }
        }
        // Mixin Builder functions to operate on all builders
        var $outer = _this;
        var propertyFn = function (prop) {
            $outer[prop] = function () {
                var args = Array.prototype.slice.call(arguments);
                var returnValues;
                var mergeBuilders = false;
                for (var i = 0; i < $outer.length; i++) {
                    var res = $outer.item(i)[prop].apply($outer.item(i), args);
                    // Merge MultiBuilders into one
                    if (res instanceof MultiBuilder) {
                        if (!returnValues) {
                            returnValues = [];
                        }
                        mergeBuilders = true;
                        for (var j = 0; j < res.length; j++) {
                            returnValues.push(res.item(j));
                        }
                    }
                    // Any other Return Type (e.g. boolean, integer)
                    else if (!isUndefined(res) && !(res instanceof Builder)) {
                        if (!returnValues) {
                            returnValues = [];
                        }
                        returnValues.push(res);
                    }
                }
                if (returnValues && mergeBuilders) {
                    return new MultiBuilder(returnValues);
                }
                return returnValues || $outer;
            };
        };
        for (var prop in Builder.prototype) {
            if (prop !== 'clone' && prop !== 'and') { // Skip methods that are explicitly defined in MultiBuilder
                if (Builder.prototype.hasOwnProperty(prop) && isFunction(Builder.prototype[prop])) {
                    propertyFn(prop);
                }
            }
        }
        return _this;
    }
    MultiBuilder.prototype.item = function (i) {
        return this.builders[i];
    };
    MultiBuilder.prototype.push = function () {
        var items = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            items[_i] = arguments[_i];
        }
        for (var i = 0; i < items.length; i++) {
            this.builders.push(items[i]);
        }
        this.length = this.builders.length;
    };
    MultiBuilder.prototype.clone = function () {
        return new MultiBuilder(this);
    };
    return MultiBuilder;
}(Builder));
function withBuilder(builder, offdom) {
    if (builder instanceof MultiBuilder) {
        return new MultiBuilder(builder);
    }
    return new Builder(builder.getHTMLElement(), offdom);
}
function withElement(element, offdom) {
    return new Builder(element, offdom);
}
function offDOM() {
    return new Builder(null, true);
}
// Binding functions
/**
 *  Allows to store arbritary data into element.
 */
function setPropertyOnElement(element, key, value) {
    data(element)[key] = value;
}
/**
 *  Allows to get arbritary data from element.
 */
function getPropertyFromElement(element, key, fallback) {
    if (hasData(element)) {
        var value = data(element)[key];
        if (!isUndefined(value)) {
            return value;
        }
    }
    return fallback;
}
var SELECTOR_REGEX$1 = /([\w\-]+)?(#([\w\-]+))?((.([\w\-]+))*)/;
var $$1 = function (arg) {
    // Off-DOM use
    if (isUndefined(arg)) {
        return offDOM();
    }
    // Falsified values cause error otherwise
    if (!arg) {
        throw new Error('Bad use of $');
    }
    // Wrap the given element
    if (isHTMLElement(arg) || arg === window) {
        return withElement(arg);
    }
    // Wrap the given builders
    if (isArray(arg)) {
        return new MultiBuilder(arg);
    }
    // Wrap the given builder
    if (arg instanceof Builder) {
        return withBuilder(arg);
    }
    if (isString(arg)) {
        // Use the argument as HTML code
        if (arg[0] === '<') {
            var element = void 0;
            var container = document.createElement('div');
            container.innerHTML = format.apply(strings, arguments);
            if (container.children.length === 0) {
                throw new Error('Bad use of $');
            }
            if (container.children.length === 1) {
                element = container.firstChild;
                container.removeChild(element);
                return withElement(element);
            }
            var builders = [];
            while (container.firstChild) {
                element = container.firstChild;
                container.removeChild(element);
                builders.push(withElement(element));
            }
            return new MultiBuilder(builders);
        }
        // Use the argument as a selector constructor
        else if (arguments.length === 1) {
            var match = SELECTOR_REGEX$1.exec(arg);
            if (!match) {
                throw new Error('Bad use of $');
            }
            var tag = match[1] || 'div';
            var id = match[3] || undefined;
            var classes = (match[4] || '').replace(/\./g, ' ');
            var props = {};
            if (id) {
                props['id'] = id;
            }
            if (classes) {
                props['class'] = classes;
            }
            return offDOM().element(tag, props);
        }
        // Use the arguments as the arguments to Builder#element(...)
        else {
            var result = offDOM();
            result.element.apply(result, arguments);
            return result;
        }
    }
    else {
        throw new Error('Bad use of $');
    }
};

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$16 = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var Orientation;
(function (Orientation) {
    Orientation[Orientation["VERTICAL"] = 0] = "VERTICAL";
    Orientation[Orientation["HORIZONTAL"] = 1] = "HORIZONTAL";
})(Orientation || (Orientation = {}));
var Sash = /** @class */ (function () {
    function Sash(container, layoutProvider, options) {
        if (options === void 0) { options = {}; }
        var _this = this;
        this._onDidStart = new Emitter();
        this._onDidChange = new Emitter();
        this._onDidReset = new Emitter();
        this._onDidEnd = new Emitter();
        this.$e = $$1('.monaco-sash').appendTo(container);
        if (isMacintosh) {
            this.$e.addClass('mac');
        }
        this.$e.on(EventType.MOUSE_DOWN, function (e) { _this.onMouseDown(e); });
        this.$e.on(EventType.DBLCLICK, function (e) { return _this._onDidReset.fire(); });
        Gesture.addTarget(this.$e.getHTMLElement());
        this.$e.on(EventType$1.Start, function (e) { _this.onTouchStart(e); });
        this.size = options.baseSize || 5;
        if (isIPad) {
            this.size *= 4; // see also http://ux.stackexchange.com/questions/39023/what-is-the-optimum-button-size-of-touch-screen-applications
            this.$e.addClass('touch');
        }
        this.setOrientation(options.orientation || Orientation.VERTICAL);
        this.isDisabled = false;
        this.hidden = false;
        this.layoutProvider = layoutProvider;
    }
    Object.defineProperty(Sash.prototype, "onDidStart", {
        get: function () {
            return this._onDidStart.event;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sash.prototype, "onDidChange", {
        get: function () {
            return this._onDidChange.event;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sash.prototype, "onDidReset", {
        get: function () {
            return this._onDidReset.event;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sash.prototype, "onDidEnd", {
        get: function () {
            return this._onDidEnd.event;
        },
        enumerable: true,
        configurable: true
    });
    Sash.prototype.setOrientation = function (orientation) {
        this.orientation = orientation;
        this.$e.removeClass('horizontal', 'vertical');
        this.$e.addClass(this.getOrientation());
        if (this.orientation === Orientation.HORIZONTAL) {
            this.$e.size(null, this.size);
        }
        else {
            this.$e.size(this.size);
        }
        if (this.layoutProvider) {
            this.layout();
        }
    };
    Sash.prototype.getOrientation = function () {
        return this.orientation === Orientation.HORIZONTAL ? 'horizontal' : 'vertical';
    };
    Sash.prototype.onMouseDown = function (e) {
        var _this = this;
        EventHelper.stop(e, false);
        if (this.isDisabled) {
            return;
        }
        var iframes = $$1(getElementsByTagName('iframe'));
        if (iframes) {
            iframes.style('pointer-events', 'none'); // disable mouse events on iframes as long as we drag the sash
        }
        var mouseDownEvent = new StandardMouseEvent(e);
        var startX = mouseDownEvent.posx;
        var startY = mouseDownEvent.posy;
        var altKey = mouseDownEvent.altKey;
        var startEvent = {
            startX: startX,
            currentX: startX,
            startY: startY,
            currentY: startY,
            altKey: altKey
        };
        this.$e.addClass('active');
        this._onDidStart.fire(startEvent);
        var $window = $$1(window);
        // fix https://github.com/Microsoft/vscode/issues/21675
        var globalStyle = createStyleSheet(this.$e.getHTMLElement());
        if (this.orientation === Orientation.HORIZONTAL) {
            globalStyle.innerHTML = "* { cursor: " + (isMacintosh ? 'row-resize' : 'ns-resize') + "; }";
        }
        else {
            globalStyle.innerHTML = "* { cursor: " + (isMacintosh ? 'col-resize' : 'ew-resize') + "; }";
        }
        $window.on('mousemove', function (e) {
            EventHelper.stop(e, false);
            var mouseMoveEvent = new StandardMouseEvent(e);
            var event = {
                startX: startX,
                currentX: mouseMoveEvent.posx,
                startY: startY,
                currentY: mouseMoveEvent.posy,
                altKey: altKey
            };
            _this._onDidChange.fire(event);
        }).once('mouseup', function (e) {
            EventHelper.stop(e, false);
            _this.$e.getHTMLElement().removeChild(globalStyle);
            _this.$e.removeClass('active');
            _this._onDidEnd.fire();
            $window.off('mousemove');
            var iframes = $$1(getElementsByTagName('iframe'));
            if (iframes) {
                iframes.style('pointer-events', 'auto');
            }
        });
    };
    Sash.prototype.onTouchStart = function (event) {
        var _this = this;
        EventHelper.stop(event);
        var listeners = [];
        var startX = event.pageX;
        var startY = event.pageY;
        var altKey = event.altKey;
        this._onDidStart.fire({
            startX: startX,
            currentX: startX,
            startY: startY,
            currentY: startY,
            altKey: altKey
        });
        listeners.push(addDisposableListener(this.$e.getHTMLElement(), EventType$1.Change, function (event) {
            if (isNumber(event.pageX) && isNumber(event.pageY)) {
                _this._onDidChange.fire({
                    startX: startX,
                    currentX: event.pageX,
                    startY: startY,
                    currentY: event.pageY,
                    altKey: altKey
                });
            }
        }));
        listeners.push(addDisposableListener(this.$e.getHTMLElement(), EventType$1.End, function (event) {
            _this._onDidEnd.fire();
            dispose(listeners);
        }));
    };
    Sash.prototype.layout = function () {
        var style;
        if (this.orientation === Orientation.VERTICAL) {
            var verticalProvider = this.layoutProvider;
            style = { left: verticalProvider.getVerticalSashLeft(this) - (this.size / 2) + 'px' };
            if (verticalProvider.getVerticalSashTop) {
                style.top = verticalProvider.getVerticalSashTop(this) + 'px';
            }
            if (verticalProvider.getVerticalSashHeight) {
                style.height = verticalProvider.getVerticalSashHeight(this) + 'px';
            }
        }
        else {
            var horizontalProvider = this.layoutProvider;
            style = { top: horizontalProvider.getHorizontalSashTop(this) - (this.size / 2) + 'px' };
            if (horizontalProvider.getHorizontalSashLeft) {
                style.left = horizontalProvider.getHorizontalSashLeft(this) + 'px';
            }
            if (horizontalProvider.getHorizontalSashWidth) {
                style.width = horizontalProvider.getHorizontalSashWidth(this) + 'px';
            }
        }
        this.$e.style(style);
    };
    Sash.prototype.show = function () {
        this.hidden = false;
        this.$e.show();
    };
    Sash.prototype.hide = function () {
        this.hidden = true;
        this.$e.hide();
    };
    Sash.prototype.isHidden = function () {
        return this.hidden;
    };
    Sash.prototype.enable = function () {
        this.$e.removeClass('disabled');
        this.isDisabled = false;
    };
    Sash.prototype.disable = function () {
        this.$e.addClass('disabled');
        this.isDisabled = true;
    };
    Object.defineProperty(Sash.prototype, "enabled", {
        get: function () {
            return !this.isDisabled;
        },
        enumerable: true,
        configurable: true
    });
    Sash.prototype.dispose = function () {
        if (this.$e) {
            this.$e.destroy();
            this.$e = null;
        }
    };
    return Sash;
}());
/**
 * A simple Vertical Sash that computes the position of the sash when it is moved between the given dimension.
 * Triggers onPositionChange event when the position is changed
 */
var VSash = /** @class */ (function (_super) {
    __extends$16(VSash, _super);
    function VSash(container, minWidth) {
        var _this = _super.call(this) || this;
        _this.minWidth = minWidth;
        _this._onPositionChange = new Emitter();
        _this.ratio = 0.5;
        _this.sash = new Sash(container, _this);
        _this._register(_this.sash.onDidStart(function () { return _this.onSashDragStart(); }));
        _this._register(_this.sash.onDidChange(function (e) { return _this.onSashDrag(e); }));
        _this._register(_this.sash.onDidEnd(function () { return _this.onSashDragEnd(); }));
        _this._register(_this.sash.onDidReset(function () { return _this.onSashReset(); }));
        return _this;
    }
    Object.defineProperty(VSash.prototype, "onPositionChange", {
        get: function () { return this._onPositionChange.event; },
        enumerable: true,
        configurable: true
    });
    VSash.prototype.getVerticalSashTop = function () {
        return 0;
    };
    VSash.prototype.getVerticalSashLeft = function () {
        return this.position;
    };
    VSash.prototype.getVerticalSashHeight = function () {
        return this.dimension.height;
    };
    VSash.prototype.setDimenesion = function (dimension) {
        this.dimension = dimension;
        this.compute(this.ratio);
    };
    VSash.prototype.onSashDragStart = function () {
        this.startPosition = this.position;
    };
    VSash.prototype.onSashDrag = function (e) {
        this.compute((this.startPosition + (e.currentX - e.startX)) / this.dimension.width);
    };
    VSash.prototype.compute = function (ratio) {
        this.computeSashPosition(ratio);
        this.ratio = this.position / this.dimension.width;
        this._onPositionChange.fire(this.position);
    };
    VSash.prototype.onSashDragEnd = function () {
        this.sash.layout();
    };
    VSash.prototype.onSashReset = function () {
        this.compute(0.5);
        this._onPositionChange.fire(this.position);
        this.sash.layout();
    };
    VSash.prototype.computeSashPosition = function (sashRatio) {
        if (sashRatio === void 0) { sashRatio = this.ratio; }
        var contentWidth = this.dimension.width;
        var sashPosition = Math.floor((sashRatio || 0.5) * contentWidth);
        var midPoint = Math.floor(0.5 * contentWidth);
        if (contentWidth > this.minWidth * 2) {
            if (sashPosition < this.minWidth) {
                sashPosition = this.minWidth;
            }
            if (sashPosition > contentWidth - this.minWidth) {
                sashPosition = contentWidth - this.minWidth;
            }
        }
        else {
            sashPosition = midPoint;
        }
        if (this.position !== sashPosition) {
            this.position = sashPosition;
            this.sash.layout();
        }
    };
    return VSash;
}(Disposable));

const css$n = "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n.monaco-diff-editor .diff-review-line-number {\n\ttext-align: right;\n\tdisplay: inline-block;\n}\n\n.monaco-diff-editor .diff-review {\n\tposition: absolute;\n\t-webkit-user-select: none;\n\t-ms-user-select: none;\n\t-khtml-user-select: none;\n\t-moz-user-select: none;\n\t-o-user-select: none;\n\tuser-select: none;\n}\n\n.monaco-diff-editor .diff-review-summary {\n\tpadding-left: 10px;\n}\n\n.monaco-diff-editor .diff-review-shadow {\n\tposition: absolute;\n}\n\n.monaco-diff-editor .diff-review-row {\n\twhite-space: pre;\n}\n\n.monaco-diff-editor .diff-review-table {\n\tdisplay: table;\n\tmin-width: 100%;\n}\n\n.monaco-diff-editor .diff-review-row {\n\tdisplay: table-row;\n\twidth: 100%;\n}\n\n.monaco-diff-editor .diff-review-cell {\n\tdisplay: table-cell;\n}\n\n.monaco-diff-editor .diff-review-spacer {\n\tdisplay: inline-block;\n\twidth: 10px;\n}\n\n.monaco-diff-editor .diff-review-actions {\n\tdisplay: inline-block;\n\tposition: absolute;\n\tright: 10px;\n\ttop: 2px;\n}\n\n.monaco-diff-editor .diff-review-actions .action-label {\n\twidth: 16px;\n\theight: 16px;\n\tmargin: 2px 0;\n}\n.monaco-diff-editor .action-label.icon.close-diff-review {\n\tbackground: url(\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgaGVpZ2h0PSIxNiIgdmlld0JveD0iMyAzIDE2IDE2IiBlbmFibGUtYmFja2dyb3VuZD0ibmV3IDMgMyAxNiAxNiI+PHBvbHlnb24gZmlsbD0iIzQyNDI0MiIgcG9pbnRzPSIxMi41OTcsMTEuMDQyIDE1LjQsMTMuODQ1IDEzLjg0NCwxNS40IDExLjA0MiwxMi41OTggOC4yMzksMTUuNCA2LjY4MywxMy44NDUgOS40ODUsMTEuMDQyIDYuNjgzLDguMjM5IDguMjM4LDYuNjgzIDExLjA0Miw5LjQ4NiAxMy44NDUsNi42ODMgMTUuNCw4LjIzOSIvPjwvc3ZnPg==\") center center no-repeat;\n}\n.monaco-diff-editor.hc-black .action-label.icon.close-diff-review,\n.monaco-diff-editor.vs-dark .action-label.icon.close-diff-review {\n\tbackground: url(\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgaGVpZ2h0PSIxNiIgdmlld0JveD0iMyAzIDE2IDE2IiBlbmFibGUtYmFja2dyb3VuZD0ibmV3IDMgMyAxNiAxNiI+PHBvbHlnb24gZmlsbD0iI2U4ZThlOCIgcG9pbnRzPSIxMi41OTcsMTEuMDQyIDE1LjQsMTMuODQ1IDEzLjg0NCwxNS40IDExLjA0MiwxMi41OTggOC4yMzksMTUuNCA2LjY4MywxMy44NDUgOS40ODUsMTEuMDQyIDYuNjgzLDguMjM5IDguMjM4LDYuNjgzIDExLjA0Miw5LjQ4NiAxMy44NDUsNi42ODMgMTUuNCw4LjIzOSIvPjwvc3ZnPg==\") center center no-repeat;\n}";
  const element$n = ((css, src) => {
if (typeof document !== 'object')
console.info(`Skipped loading "${src}"`);
try {
const id = src
  .replace(/\.css.*$/, '')
  .replace(/[\\:]/g, '/')
  .replace(/[^\w\/]+/g, '');
return (
  document.querySelector(`style[id="${id}"]`) ||
  document.head.appendChild(
    Object.assign(document.createElement('style'), {
      id,
      textContent: `${css}\n\n /* sourceURL=${src} */`,
    }),
  )
);
} catch (exception) {
console.warn(`Failed load "${src}"`, exception);
}
})(css$n, "…monaco-editor/esm/vs/editor/browser/widget/media/diffReview.css");
  //@ sourceURL=/Users/daflair/Projects/packages/monaco-es/node_modules/monaco-editor/esm/vs/editor/browser/widget/media/diffReview.css

const css$o = "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n.monaco-action-bar {\n\ttext-align: right;\n\toverflow: hidden;\n\twhite-space: nowrap;\n}\n\n.monaco-action-bar .actions-container {\n\tdisplay: flex;\n\tmargin: 0 auto;\n\tpadding: 0;\n\twidth: 100%;\n\tjustify-content: flex-end;\n}\n\n.monaco-action-bar.vertical .actions-container {\n\tdisplay: inline-block;\n}\n\n.monaco-action-bar.reverse .actions-container {\n\tflex-direction: row-reverse;\n}\n\n.monaco-action-bar .action-item {\n\tcursor: pointer;\n\tdisplay: inline-block;\n\t-ms-transition: -ms-transform 50ms ease;\n\t-webkit-transition: -webkit-transform 50ms ease;\n\t-moz-transition: -moz-transform 50ms ease;\n\t-o-transition: -o-transform 50ms ease;\n\ttransition: transform 50ms ease;\n\tposition: relative;  /* DO NOT REMOVE - this is the key to preventing the ghosting icon bug in Chrome 42 */\n}\n\n.monaco-action-bar .action-item.disabled {\n\tcursor: default;\n}\n\n.monaco-action-bar.animated .action-item.active {\n\t-ms-transform: scale(1.272019649, 1.272019649); /* 1.272019649 = √φ */\n\t-webkit-transform: scale(1.272019649, 1.272019649);\n\t-moz-transform: scale(1.272019649, 1.272019649);\n\t-o-transform: scale(1.272019649, 1.272019649);\n\ttransform: scale(1.272019649, 1.272019649);\n}\n\n.monaco-action-bar .action-item .icon {\n\tdisplay: inline-block;\n}\n\n.monaco-action-bar .action-label {\n\tfont-size: 12px;\n\tmargin-right: 0.3em;\n}\n\n.monaco-action-bar .action-label.octicon {\n\tfont-size: 15px;\n\tline-height: 35px;\n\ttext-align: center;\n}\n\n.monaco-action-bar .action-item.disabled .action-label,\n.monaco-action-bar .action-item.disabled .action-label:hover {\n\topacity: 0.4;\n}\n\n/* Vertical actions */\n\n.monaco-action-bar.vertical {\n\ttext-align: left;\n}\n\n.monaco-action-bar.vertical .action-item {\n\tdisplay: block;\n}\n\n.monaco-action-bar.vertical .action-label.separator {\n\tdisplay: block;\n\tborder-bottom: 1px solid #bbb;\n\tpadding-top: 1px;\n\tmargin-left: .8em;\n\tmargin-right: .8em;\n}\n\n.monaco-action-bar.animated.vertical .action-item.active {\n\t-ms-transform: translate(5px, 0);\n\t-webkit-transform: translate(5px, 0);\n\t-moz-transform: translate(5px, 0);\n\t-o-transform: translate(5px, 0);\n\ttransform: translate(5px, 0);\n}\n\n.secondary-actions .monaco-action-bar .action-label {\n\tmargin-left: 6px;\n}\n\n/* Action Items */\n.monaco-action-bar .action-item.select-container {\n\toverflow: hidden; /* somehow the dropdown overflows its container, we prevent it here to not push */\n\tflex: 1;\n\tmax-width: 170px;\n\tmin-width: 60px;\n\tmargin-right: 10px;\n}";
  const element$o = ((css, src) => {
if (typeof document !== 'object')
console.info(`Skipped loading "${src}"`);
try {
const id = src
  .replace(/\.css.*$/, '')
  .replace(/[\\:]/g, '/')
  .replace(/[^\w\/]+/g, '');
return (
  document.querySelector(`style[id="${id}"]`) ||
  document.head.appendChild(
    Object.assign(document.createElement('style'), {
      id,
      textContent: `${css}\n\n /* sourceURL=${src} */`,
    }),
  )
);
} catch (exception) {
console.warn(`Failed load "${src}"`, exception);
}
})(css$o, "…monaco-editor/esm/vs/base/browser/ui/actionbar/actionbar.css");
  //@ sourceURL=/Users/daflair/Projects/packages/monaco-es/node_modules/monaco-editor/esm/vs/base/browser/ui/actionbar/actionbar.css

const css$p = "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n.monaco-select-box {\n\twidth: 100%;\n}\n";
  const element$p = ((css, src) => {
if (typeof document !== 'object')
console.info(`Skipped loading "${src}"`);
try {
const id = src
  .replace(/\.css.*$/, '')
  .replace(/[\\:]/g, '/')
  .replace(/[^\w\/]+/g, '');
return (
  document.querySelector(`style[id="${id}"]`) ||
  document.head.appendChild(
    Object.assign(document.createElement('style'), {
      id,
      textContent: `${css}\n\n /* sourceURL=${src} */`,
    }),
  )
);
} catch (exception) {
console.warn(`Failed load "${src}"`, exception);
}
})(css$p, "…monaco-editor/esm/vs/base/browser/ui/selectBox/selectBox.css");
  //@ sourceURL=/Users/daflair/Projects/packages/monaco-es/node_modules/monaco-editor/esm/vs/base/browser/ui/selectBox/selectBox.css

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var SelectBoxNative = /** @class */ (function () {
    function SelectBoxNative(options, selected, styles) {
        this.toDispose = [];
        this.selectElement = document.createElement('select');
        this.selectElement.className = 'monaco-select-box';
        this._onDidSelect = new Emitter();
        this.styles = styles;
        this.registerListeners();
        this.setOptions(options, selected);
    }
    SelectBoxNative.prototype.registerListeners = function () {
        var _this = this;
        this.toDispose.push(addStandardDisposableListener(this.selectElement, 'change', function (e) {
            _this.selectElement.title = e.target.value;
            _this._onDidSelect.fire({
                index: e.target.selectedIndex,
                selected: e.target.value
            });
        }));
        this.toDispose.push(addStandardDisposableListener(this.selectElement, 'keydown', function (e) {
            var showSelect = false;
            if (isMacintosh) {
                if (e.keyCode === 18 /* DownArrow */ || e.keyCode === 16 /* UpArrow */ || e.keyCode === 10 /* Space */) {
                    showSelect = true;
                }
            }
            else {
                if (e.keyCode === 18 /* DownArrow */ && e.altKey || e.keyCode === 10 /* Space */ || e.keyCode === 3 /* Enter */) {
                    showSelect = true;
                }
            }
            if (showSelect) {
                // Space, Enter, is used to expand select box, do not propagate it (prevent action bar action run)
                e.stopPropagation();
            }
        }));
    };
    Object.defineProperty(SelectBoxNative.prototype, "onDidSelect", {
        get: function () {
            return this._onDidSelect.event;
        },
        enumerable: true,
        configurable: true
    });
    SelectBoxNative.prototype.setOptions = function (options, selected, disabled) {
        var _this = this;
        if (!this.options || !equals(this.options, options)) {
            this.options = options;
            this.selectElement.options.length = 0;
            var i_1 = 0;
            this.options.forEach(function (option) {
                _this.selectElement.add(_this.createOption(option, i_1, disabled === i_1++));
            });
        }
        if (selected !== undefined) {
            this.select(selected);
        }
    };
    SelectBoxNative.prototype.select = function (index$$1) {
        if (index$$1 >= 0 && index$$1 < this.options.length) {
            this.selected = index$$1;
        }
        else if (index$$1 > this.options.length - 1) {
            // Adjust index to end of list
            // This could make client out of sync with the select
            this.select(this.options.length - 1);
        }
        else if (this.selected < 0) {
            this.selected = 0;
        }
        this.selectElement.selectedIndex = this.selected;
        this.selectElement.title = this.options[this.selected];
    };
    SelectBoxNative.prototype.focus = function () {
        if (this.selectElement) {
            this.selectElement.focus();
        }
    };
    SelectBoxNative.prototype.blur = function () {
        if (this.selectElement) {
            this.selectElement.blur();
        }
    };
    SelectBoxNative.prototype.render = function (container) {
        addClass(container, 'select-container');
        container.appendChild(this.selectElement);
        this.setOptions(this.options, this.selected);
        this.applyStyles();
    };
    SelectBoxNative.prototype.style = function (styles) {
        this.styles = styles;
        this.applyStyles();
    };
    SelectBoxNative.prototype.applyStyles = function () {
        // Style native select
        if (this.selectElement) {
            var background = this.styles.selectBackground ? this.styles.selectBackground.toString() : null;
            var foreground = this.styles.selectForeground ? this.styles.selectForeground.toString() : null;
            var border = this.styles.selectBorder ? this.styles.selectBorder.toString() : null;
            this.selectElement.style.backgroundColor = background;
            this.selectElement.style.color = foreground;
            this.selectElement.style.borderColor = border;
        }
    };
    SelectBoxNative.prototype.createOption = function (value, index$$1, disabled) {
        var option = document.createElement('option');
        option.value = value;
        option.text = value;
        option.disabled = disabled;
        return option;
    };
    SelectBoxNative.prototype.dispose = function () {
        this.toDispose = dispose(this.toDispose);
    };
    return SelectBoxNative;
}());

const css$q = "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n.monaco-select-box-dropdown-container {\n\tdisplay: none;\n}\n\n.monaco-select-box-dropdown-container.visible {\n\tdisplay: flex;\n\tflex-direction: column;\n\ttext-align: left;\n\twidth: 1px;\n\toverflow: hidden;\n}\n\n.monaco-select-box-dropdown-container > .select-box-dropdown-list-container {\n\tflex: 0 0 auto;\n\talign-self: flex-start;\n\tpadding-bottom: 1px;\n\tpadding-top: 1px;\n\tpadding-left: 1px;\n\tpadding-right: 1px;\n\twidth: 100%;\n\toverflow: hidden;\n\t-webkit-box-sizing:\tborder-box;\n\t-o-box-sizing:\t\tborder-box;\n\t-moz-box-sizing:\tborder-box;\n\t-ms-box-sizing:\t\tborder-box;\n\tbox-sizing:\t\t\tborder-box;\n}\n\n.hc-black .monaco-select-box-dropdown-container > .select-box-dropdown-list-container {\n\tpadding-bottom: 4px;\n\tpadding-top: 3px;\n}\n\n.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row > .option-text {\n\ttext-overflow: ellipsis;\n\toverflow: hidden;\n\tpadding-left: 3.5px;\n\twhite-space: nowrap;\n}\n\n.monaco-select-box-dropdown-container > .select-box-dropdown-container-width-control {\n\tflex: 1 1 auto;\n\talign-self: flex-start;\n\topacity: 0;\n}\n\n.monaco-select-box-dropdown-container > .select-box-dropdown-container-width-control > .width-control-div {\n\toverflow: hidden;\n\tmax-height: 0px;\n}\n\n.monaco-select-box-dropdown-container > .select-box-dropdown-container-width-control > .width-control-div > .option-text-width-control {\n\tpadding-left: 4px;\n\tpadding-right: 8px;\n\twhite-space: nowrap;\n}\n";
  const element$q = ((css, src) => {
if (typeof document !== 'object')
console.info(`Skipped loading "${src}"`);
try {
const id = src
  .replace(/\.css.*$/, '')
  .replace(/[\\:]/g, '/')
  .replace(/[^\w\/]+/g, '');
return (
  document.querySelector(`style[id="${id}"]`) ||
  document.head.appendChild(
    Object.assign(document.createElement('style'), {
      id,
      textContent: `${css}\n\n /* sourceURL=${src} */`,
    }),
  )
);
} catch (exception) {
console.warn(`Failed load "${src}"`, exception);
}
})(css$q, "…monaco-editor/esm/vs/base/browser/ui/selectBox/selectBoxCustom.css");
  //@ sourceURL=/Users/daflair/Projects/packages/monaco-es/node_modules/monaco-editor/esm/vs/base/browser/ui/selectBox/selectBoxCustom.css

const css$r = "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n.monaco-list {\n\tposition: relative;\n\theight: 100%;\n\twidth: 100%;\n\twhite-space: nowrap;\n\t-webkit-user-select: none;\n\t-khtml-user-select: none;\n\t-moz-user-select: -moz-none;\n\t-ms-user-select: none;\n\t-o-user-select: none;\n\tuser-select: none;\n}\n\n.monaco-list > .monaco-scrollable-element {\n\theight: 100%;\n}\n\n.monaco-list-rows {\n\tposition: relative;\n\twidth: 100%;\n\theight: 100%;\n}\n\n.monaco-list-row {\n\tposition: absolute;\n\t-moz-box-sizing:\tborder-box;\n\t-o-box-sizing:\t\tborder-box;\n\t-ms-box-sizing:\t\tborder-box;\n\tbox-sizing:\t\t\tborder-box;\n\tcursor: pointer;\n\toverflow: hidden;\n\twidth: 100%;\n\ttouch-action: none;\n}\n\n/* for OS X ballistic scrolling */\n.monaco-list-row.scrolling {\n\tdisplay: none !important;\n}\n\n/* Focus */\n.monaco-list.element-focused, .monaco-list.selection-single, .monaco-list.selection-multiple {\n\toutline: 0 !important;\n}";
  const element$r = ((css, src) => {
if (typeof document !== 'object')
console.info(`Skipped loading "${src}"`);
try {
const id = src
  .replace(/\.css.*$/, '')
  .replace(/[\\:]/g, '/')
  .replace(/[^\w\/]+/g, '');
return (
  document.querySelector(`style[id="${id}"]`) ||
  document.head.appendChild(
    Object.assign(document.createElement('style'), {
      id,
      textContent: `${css}\n\n /* sourceURL=${src} */`,
    }),
  )
);
} catch (exception) {
console.warn(`Failed load "${src}"`, exception);
}
})(css$r, "…monaco-editor/esm/vs/base/browser/ui/list/list.css");
  //@ sourceURL=/Users/daflair/Projects/packages/monaco-es/node_modules/monaco-editor/esm/vs/base/browser/ui/list/list.css

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
/**
 * Returns the intersection between two ranges as a range itself.
 * Returns `{ start: 0, end: 0 }` if the intersection is empty.
 */
function intersect(one, other) {
    if (one.start >= other.end || other.start >= one.end) {
        return { start: 0, end: 0 };
    }
    var start = Math.max(one.start, other.start);
    var end = Math.min(one.end, other.end);
    if (end - start <= 0) {
        return { start: 0, end: 0 };
    }
    return { start: start, end: end };
}
function isEmpty(range) {
    return range.end - range.start <= 0;
}
function relativeComplement(one, other) {
    var result = [];
    var first = { start: one.start, end: Math.min(other.start, one.end) };
    var second = { start: Math.max(other.end, one.start), end: one.end };
    if (!isEmpty(first)) {
        result.push(first);
    }
    if (!isEmpty(second)) {
        result.push(second);
    }
    return result;
}
/**
 * Returns the intersection between a ranged group and a range.
 * Returns `[]` if the intersection is empty.
 */
function groupIntersect(range, groups) {
    var result = [];
    for (var _i = 0, groups_1 = groups; _i < groups_1.length; _i++) {
        var r = groups_1[_i];
        if (range.start >= r.range.end) {
            continue;
        }
        if (range.end < r.range.start) {
            break;
        }
        var intersection = intersect(range, r.range);
        if (isEmpty(intersection)) {
            continue;
        }
        result.push({
            range: intersection,
            size: r.size
        });
    }
    return result;
}
/**
 * Shifts a range by that `much`.
 */
function shift(_a, much) {
    var start = _a.start, end = _a.end;
    return { start: start + much, end: end + much };
}
/**
 * Consolidates a collection of ranged groups.
 *
 * Consolidation is the process of merging consecutive ranged groups
 * that share the same `size`.
 */
function consolidate(groups) {
    var result = [];
    var previousGroup = null;
    for (var _i = 0, groups_2 = groups; _i < groups_2.length; _i++) {
        var group = groups_2[_i];
        var start = group.range.start;
        var end = group.range.end;
        var size = group.size;
        if (previousGroup && size === previousGroup.size) {
            previousGroup.range.end = end;
            continue;
        }
        previousGroup = { range: { start: start, end: end }, size: size };
        result.push(previousGroup);
    }
    return result;
}
/**
 * Concatenates several collections of ranged groups into a single
 * collection.
 */
function concat() {
    var groups = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        groups[_i] = arguments[_i];
    }
    return consolidate(groups.reduce(function (r, g) { return r.concat(g); }, []));
}
var RangeMap = /** @class */ (function () {
    function RangeMap() {
        this.groups = [];
        this._size = 0;
    }
    RangeMap.prototype.splice = function (index, deleteCount) {
        var items = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            items[_i - 2] = arguments[_i];
        }
        var diff = items.length - deleteCount;
        var before = groupIntersect({ start: 0, end: index }, this.groups);
        var after = groupIntersect({ start: index + deleteCount, end: Number.POSITIVE_INFINITY }, this.groups)
            .map(function (g) { return ({ range: shift(g.range, diff), size: g.size }); });
        var middle = items.map(function (item, i) { return ({
            range: { start: index + i, end: index + i + 1 },
            size: item.size
        }); });
        this.groups = concat(before, middle, after);
        this._size = this.groups.reduce(function (t, g) { return t + (g.size * (g.range.end - g.range.start)); }, 0);
    };
    Object.defineProperty(RangeMap.prototype, "count", {
        /**
         * Returns the number of items in the range map.
         */
        get: function () {
            var len = this.groups.length;
            if (!len) {
                return 0;
            }
            return this.groups[len - 1].range.end;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RangeMap.prototype, "size", {
        /**
         * Returns the sum of the sizes of all items in the range map.
         */
        get: function () {
            return this._size;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns the index of the item at the given position.
     */
    RangeMap.prototype.indexAt = function (position) {
        if (position < 0) {
            return -1;
        }
        var index = 0;
        var size = 0;
        for (var _i = 0, _a = this.groups; _i < _a.length; _i++) {
            var group = _a[_i];
            var count = group.range.end - group.range.start;
            var newSize = size + (count * group.size);
            if (position < newSize) {
                return index + Math.floor((position - size) / group.size);
            }
            index += count;
            size = newSize;
        }
        return index;
    };
    /**
     * Returns the index of the item right after the item at the
     * index of the given position.
     */
    RangeMap.prototype.indexAfter = function (position) {
        return Math.min(this.indexAt(position) + 1, this.count);
    };
    /**
     * Returns the start position of the item at the given index.
     */
    RangeMap.prototype.positionAt = function (index) {
        if (index < 0) {
            return -1;
        }
        var position = 0;
        var count = 0;
        for (var _i = 0, _a = this.groups; _i < _a.length; _i++) {
            var group = _a[_i];
            var groupCount = group.range.end - group.range.start;
            var newCount = count + groupCount;
            if (index < newCount) {
                return position + ((index - count) * group.size);
            }
            position += groupCount * group.size;
            count = newCount;
        }
        return -1;
    };
    RangeMap.prototype.dispose = function () {
        this.groups = null;
    };
    return RangeMap;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
function removeFromParent(element) {
    try {
        element.parentElement.removeChild(element);
    }
    catch (e) {
        // this will throw if this happens due to a blur event, nasty business
    }
}
var RowCache = /** @class */ (function () {
    function RowCache(renderers) {
        this.renderers = renderers;
        this.cache = new Map();
    }
    /**
     * Returns a row either by creating a new one or reusing
     * a previously released row which shares the same templateId.
     */
    RowCache.prototype.alloc = function (templateId) {
        var result = this.getTemplateCache(templateId).pop();
        if (!result) {
            var domNode = $('.monaco-list-row');
            var renderer = this.renderers.get(templateId);
            var templateData = renderer.renderTemplate(domNode);
            result = { domNode: domNode, templateId: templateId, templateData: templateData };
        }
        return result;
    };
    /**
     * Releases the row for eventual reuse.
     */
    RowCache.prototype.release = function (row) {
        if (!row) {
            return;
        }
        this.releaseRow(row);
    };
    RowCache.prototype.releaseRow = function (row) {
        var domNode = row.domNode, templateId = row.templateId;
        removeClass(domNode, 'scrolling');
        removeFromParent(domNode);
        var cache = this.getTemplateCache(templateId);
        cache.push(row);
    };
    RowCache.prototype.getTemplateCache = function (templateId) {
        var result = this.cache.get(templateId);
        if (!result) {
            result = [];
            this.cache.set(templateId, result);
        }
        return result;
    };
    RowCache.prototype.garbageCollect = function () {
        var _this = this;
        if (!this.renderers) {
            return;
        }
        this.cache.forEach(function (cachedRows, templateId) {
            for (var _i = 0, cachedRows_1 = cachedRows; _i < cachedRows_1.length; _i++) {
                var cachedRow = cachedRows_1[_i];
                var renderer = _this.renderers.get(templateId);
                renderer.disposeTemplate(cachedRow.templateData);
                cachedRow.domNode = null;
                cachedRow.templateData = null;
            }
        });
        this.cache.clear();
    };
    RowCache.prototype.dispose = function () {
        this.garbageCollect();
        this.cache.clear();
        this.renderers = null;
    };
    return RowCache;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __decorate$5 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
function canUseTranslate3d() {
    if (isFirefox) {
        return false;
    }
    if (getZoomLevel() !== 0) {
        return false;
    }
    // see https://github.com/Microsoft/vscode/issues/24483
    if (isChromev56) {
        var pixelRatio = getPixelRatio();
        if (Math.floor(pixelRatio) !== pixelRatio) {
            // Not an integer
            return false;
        }
    }
    return true;
}
var DefaultOptions = {
    useShadows: true,
    verticalScrollMode: ScrollbarVisibility.Auto
};
var ListView = /** @class */ (function () {
    function ListView(container, delegate, renderers, options) {
        if (options === void 0) { options = DefaultOptions; }
        this.delegate = delegate;
        this.renderers = new Map();
        this.splicing = false;
        this.items = [];
        this.itemId = 0;
        this.rangeMap = new RangeMap();
        for (var _i = 0, renderers_1 = renderers; _i < renderers_1.length; _i++) {
            var renderer = renderers_1[_i];
            this.renderers.set(renderer.templateId, renderer);
        }
        this.cache = new RowCache(this.renderers);
        this.lastRenderTop = 0;
        this.lastRenderHeight = 0;
        this._domNode = document.createElement('div');
        this._domNode.className = 'monaco-list';
        this.rowsContainer = document.createElement('div');
        this.rowsContainer.className = 'monaco-list-rows';
        Gesture.addTarget(this.rowsContainer);
        this.scrollableElement = new ScrollableElement(this.rowsContainer, {
            alwaysConsumeMouseWheel: true,
            horizontal: ScrollbarVisibility.Hidden,
            vertical: getOrDefault(options, function (o) { return o.verticalScrollMode; }, DefaultOptions.verticalScrollMode),
            useShadows: getOrDefault(options, function (o) { return o.useShadows; }, DefaultOptions.useShadows)
        });
        this._domNode.appendChild(this.scrollableElement.getDomNode());
        container.appendChild(this._domNode);
        this.disposables = [this.rangeMap, this.gesture, this.scrollableElement, this.cache];
        this.scrollableElement.onScroll(this.onScroll, this, this.disposables);
        domEvent(this.rowsContainer, EventType$1.Change)(this.onTouchChange, this, this.disposables);
        // Prevent the monaco-scrollable-element from scrolling
        // https://github.com/Microsoft/vscode/issues/44181
        domEvent(this.scrollableElement.getDomNode(), 'scroll')(function (e) { return e.target.scrollTop = 0; }, null, this.disposables);
        var onDragOver = mapEvent(domEvent(this.rowsContainer, 'dragover'), function (e) { return new DragMouseEvent(e); });
        onDragOver(this.onDragOver, this, this.disposables);
        this.layout();
    }
    Object.defineProperty(ListView.prototype, "domNode", {
        get: function () {
            return this._domNode;
        },
        enumerable: true,
        configurable: true
    });
    ListView.prototype.splice = function (start, deleteCount, elements) {
        if (elements === void 0) { elements = []; }
        if (this.splicing) {
            throw new Error('Can\'t run recursive splices.');
        }
        this.splicing = true;
        try {
            return this._splice(start, deleteCount, elements);
        }
        finally {
            this.splicing = false;
        }
    };
    ListView.prototype._splice = function (start, deleteCount, elements) {
        var _this = this;
        if (elements === void 0) { elements = []; }
        var previousRenderRange = this.getRenderRange(this.lastRenderTop, this.lastRenderHeight);
        var deleteRange = { start: start, end: start + deleteCount };
        var removeRange = intersect(previousRenderRange, deleteRange);
        for (var i = removeRange.start; i < removeRange.end; i++) {
            this.removeItemFromDOM(i);
        }
        var previousRestRange = { start: start + deleteCount, end: this.items.length };
        var previousRenderedRestRange = intersect(previousRestRange, previousRenderRange);
        var previousUnrenderedRestRanges = relativeComplement(previousRestRange, previousRenderRange);
        var inserted = elements.map(function (element) { return ({
            id: String(_this.itemId++),
            element: element,
            size: _this.delegate.getHeight(element),
            templateId: _this.delegate.getTemplateId(element),
            row: null
        }); });
        (_a = this.rangeMap).splice.apply(_a, [start, deleteCount].concat(inserted));
        var deleted = (_b = this.items).splice.apply(_b, [start, deleteCount].concat(inserted));
        var delta = elements.length - deleteCount;
        var renderRange = this.getRenderRange(this.lastRenderTop, this.lastRenderHeight);
        var renderedRestRange = shift(previousRenderedRestRange, delta);
        var updateRange = intersect(renderRange, renderedRestRange);
        for (var i = updateRange.start; i < updateRange.end; i++) {
            this.updateItemInDOM(this.items[i], i);
        }
        var removeRanges = relativeComplement(renderedRestRange, renderRange);
        for (var r = 0; r < removeRanges.length; r++) {
            var removeRange_1 = removeRanges[r];
            for (var i = removeRange_1.start; i < removeRange_1.end; i++) {
                this.removeItemFromDOM(i);
            }
        }
        var unrenderedRestRanges = previousUnrenderedRestRanges.map(function (r) { return shift(r, delta); });
        var elementsRange = { start: start, end: start + elements.length };
        var insertRanges = [elementsRange].concat(unrenderedRestRanges).map(function (r) { return intersect(renderRange, r); });
        var beforeElement = this.getNextToLastElement(insertRanges);
        for (var r = 0; r < insertRanges.length; r++) {
            var insertRange = insertRanges[r];
            for (var i = insertRange.start; i < insertRange.end; i++) {
                this.insertItemInDOM(i, beforeElement);
            }
        }
        var scrollHeight = this.getContentHeight();
        this.rowsContainer.style.height = scrollHeight + "px";
        this.scrollableElement.setScrollDimensions({ scrollHeight: scrollHeight });
        return deleted.map(function (i) { return i.element; });
        var _a, _b;
    };
    Object.defineProperty(ListView.prototype, "length", {
        get: function () {
            return this.items.length;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ListView.prototype, "renderHeight", {
        get: function () {
            var scrollDimensions = this.scrollableElement.getScrollDimensions();
            return scrollDimensions.height;
        },
        enumerable: true,
        configurable: true
    });
    ListView.prototype.element = function (index) {
        return this.items[index].element;
    };
    ListView.prototype.domElement = function (index) {
        var row = this.items[index].row;
        return row && row.domNode;
    };
    ListView.prototype.elementHeight = function (index) {
        return this.items[index].size;
    };
    ListView.prototype.elementTop = function (index) {
        return this.rangeMap.positionAt(index);
    };
    ListView.prototype.indexAt = function (position$$1) {
        return this.rangeMap.indexAt(position$$1);
    };
    ListView.prototype.indexAfter = function (position$$1) {
        return this.rangeMap.indexAfter(position$$1);
    };
    ListView.prototype.layout = function (height) {
        this.scrollableElement.setScrollDimensions({
            height: height || getContentHeight(this._domNode)
        });
    };
    // Render
    ListView.prototype.render = function (renderTop, renderHeight) {
        var previousRenderRange = this.getRenderRange(this.lastRenderTop, this.lastRenderHeight);
        var renderRange = this.getRenderRange(renderTop, renderHeight);
        var rangesToInsert = relativeComplement(renderRange, previousRenderRange);
        var rangesToRemove = relativeComplement(previousRenderRange, renderRange);
        var beforeElement = this.getNextToLastElement(rangesToInsert);
        for (var _i = 0, rangesToInsert_1 = rangesToInsert; _i < rangesToInsert_1.length; _i++) {
            var range = rangesToInsert_1[_i];
            for (var i = range.start; i < range.end; i++) {
                this.insertItemInDOM(i, beforeElement);
            }
        }
        for (var _a = 0, rangesToRemove_1 = rangesToRemove; _a < rangesToRemove_1.length; _a++) {
            var range = rangesToRemove_1[_a];
            for (var i = range.start; i < range.end; i++) {
                this.removeItemFromDOM(i);
            }
        }
        if (canUseTranslate3d() && !isWindows /* Windows: translate3d breaks subpixel-antialias (ClearType) unless a background is defined */) {
            var transform = "translate3d(0px, -" + renderTop + "px, 0px)";
            this.rowsContainer.style.transform = transform;
            this.rowsContainer.style.webkitTransform = transform;
        }
        else {
            this.rowsContainer.style.top = "-" + renderTop + "px";
        }
        this.lastRenderTop = renderTop;
        this.lastRenderHeight = renderHeight;
    };
    // DOM operations
    ListView.prototype.insertItemInDOM = function (index, beforeElement) {
        var item = this.items[index];
        if (!item.row) {
            item.row = this.cache.alloc(item.templateId);
        }
        if (!item.row.domNode.parentElement) {
            if (beforeElement) {
                this.rowsContainer.insertBefore(item.row.domNode, beforeElement);
            }
            else {
                this.rowsContainer.appendChild(item.row.domNode);
            }
        }
        item.row.domNode.style.height = item.size + "px";
        this.updateItemInDOM(item, index);
        var renderer = this.renderers.get(item.templateId);
        renderer.renderElement(item.element, index, item.row.templateData);
    };
    ListView.prototype.updateItemInDOM = function (item, index) {
        item.row.domNode.style.top = this.elementTop(index) + "px";
        item.row.domNode.setAttribute('data-index', "" + index);
        item.row.domNode.setAttribute('data-last-element', index === this.length - 1 ? 'true' : 'false');
        item.row.domNode.setAttribute('aria-setsize', "" + this.length);
        item.row.domNode.setAttribute('aria-posinset', "" + (index + 1));
    };
    ListView.prototype.removeItemFromDOM = function (index) {
        var item = this.items[index];
        this.cache.release(item.row);
        item.row = null;
    };
    ListView.prototype.getContentHeight = function () {
        return this.rangeMap.size;
    };
    ListView.prototype.getScrollTop = function () {
        var scrollPosition = this.scrollableElement.getScrollPosition();
        return scrollPosition.scrollTop;
    };
    ListView.prototype.setScrollTop = function (scrollTop) {
        this.scrollableElement.setScrollPosition({ scrollTop: scrollTop });
    };
    Object.defineProperty(ListView.prototype, "scrollTop", {
        get: function () {
            return this.getScrollTop();
        },
        set: function (scrollTop) {
            this.setScrollTop(scrollTop);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ListView.prototype, "onMouseClick", {
        // Events
        get: function () {
            var _this = this;
            return filterEvent(mapEvent(domEvent(this.domNode, 'click'), function (e) { return _this.toMouseEvent(e); }), function (e) { return e.index >= 0; });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ListView.prototype, "onMouseDblClick", {
        get: function () {
            var _this = this;
            return filterEvent(mapEvent(domEvent(this.domNode, 'dblclick'), function (e) { return _this.toMouseEvent(e); }), function (e) { return e.index >= 0; });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ListView.prototype, "onMouseUp", {
        get: function () {
            var _this = this;
            return filterEvent(mapEvent(domEvent(this.domNode, 'mouseup'), function (e) { return _this.toMouseEvent(e); }), function (e) { return e.index >= 0; });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ListView.prototype, "onMouseDown", {
        get: function () {
            var _this = this;
            return filterEvent(mapEvent(domEvent(this.domNode, 'mousedown'), function (e) { return _this.toMouseEvent(e); }), function (e) { return e.index >= 0; });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ListView.prototype, "onMouseOver", {
        get: function () {
            var _this = this;
            return filterEvent(mapEvent(domEvent(this.domNode, 'mouseover'), function (e) { return _this.toMouseEvent(e); }), function (e) { return e.index >= 0; });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ListView.prototype, "onMouseMove", {
        get: function () {
            var _this = this;
            return filterEvent(mapEvent(domEvent(this.domNode, 'mousemove'), function (e) { return _this.toMouseEvent(e); }), function (e) { return e.index >= 0; });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ListView.prototype, "onMouseOut", {
        get: function () {
            var _this = this;
            return filterEvent(mapEvent(domEvent(this.domNode, 'mouseout'), function (e) { return _this.toMouseEvent(e); }), function (e) { return e.index >= 0; });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ListView.prototype, "onContextMenu", {
        get: function () {
            var _this = this;
            return filterEvent(mapEvent(domEvent(this.domNode, 'contextmenu'), function (e) { return _this.toMouseEvent(e); }), function (e) { return e.index >= 0; });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ListView.prototype, "onTouchStart", {
        get: function () {
            var _this = this;
            return filterEvent(mapEvent(domEvent(this.domNode, 'touchstart'), function (e) { return _this.toTouchEvent(e); }), function (e) { return e.index >= 0; });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ListView.prototype, "onTap", {
        get: function () {
            var _this = this;
            return filterEvent(mapEvent(domEvent(this.rowsContainer, EventType$1.Tap), function (e) { return _this.toGestureEvent(e); }), function (e) { return e.index >= 0; });
        },
        enumerable: true,
        configurable: true
    });
    ListView.prototype.toMouseEvent = function (browserEvent) {
        var index = this.getItemIndexFromEventTarget(browserEvent.target);
        var item = index < 0 ? undefined : this.items[index];
        var element = item && item.element;
        return { browserEvent: browserEvent, index: index, element: element };
    };
    ListView.prototype.toTouchEvent = function (browserEvent) {
        var index = this.getItemIndexFromEventTarget(browserEvent.target);
        var item = index < 0 ? undefined : this.items[index];
        var element = item && item.element;
        return { browserEvent: browserEvent, index: index, element: element };
    };
    ListView.prototype.toGestureEvent = function (browserEvent) {
        var index = this.getItemIndexFromEventTarget(browserEvent.initialTarget);
        var item = index < 0 ? undefined : this.items[index];
        var element = item && item.element;
        return { browserEvent: browserEvent, index: index, element: element };
    };
    ListView.prototype.onScroll = function (e) {
        this.render(e.scrollTop, e.height);
    };
    ListView.prototype.onTouchChange = function (event) {
        event.preventDefault();
        event.stopPropagation();
        this.scrollTop -= event.translationY;
    };
    ListView.prototype.onDragOver = function (event) {
        this.setupDragAndDropScrollInterval();
        this.dragAndDropMouseY = event.posy;
    };
    ListView.prototype.setupDragAndDropScrollInterval = function () {
        var _this = this;
        var viewTop = getTopLeftOffset(this._domNode).top;
        if (!this.dragAndDropScrollInterval) {
            this.dragAndDropScrollInterval = window.setInterval(function () {
                if (_this.dragAndDropMouseY === undefined) {
                    return;
                }
                var diff = _this.dragAndDropMouseY - viewTop;
                var scrollDiff = 0;
                var upperLimit = _this.renderHeight - 35;
                if (diff < 35) {
                    scrollDiff = Math.max(-14, 0.2 * (diff - 35));
                }
                else if (diff > upperLimit) {
                    scrollDiff = Math.min(14, 0.2 * (diff - upperLimit));
                }
                _this.scrollTop += scrollDiff;
            }, 10);
            this.cancelDragAndDropScrollTimeout();
            this.dragAndDropScrollTimeout = window.setTimeout(function () {
                _this.cancelDragAndDropScrollInterval();
                _this.dragAndDropScrollTimeout = null;
            }, 1000);
        }
    };
    ListView.prototype.cancelDragAndDropScrollInterval = function () {
        if (this.dragAndDropScrollInterval) {
            window.clearInterval(this.dragAndDropScrollInterval);
            this.dragAndDropScrollInterval = null;
        }
        this.cancelDragAndDropScrollTimeout();
    };
    ListView.prototype.cancelDragAndDropScrollTimeout = function () {
        if (this.dragAndDropScrollTimeout) {
            window.clearTimeout(this.dragAndDropScrollTimeout);
            this.dragAndDropScrollTimeout = null;
        }
    };
    // Util
    ListView.prototype.getItemIndexFromEventTarget = function (target) {
        while (target instanceof HTMLElement && target !== this.rowsContainer) {
            var element = target;
            var rawIndex = element.getAttribute('data-index');
            if (rawIndex) {
                var index = Number(rawIndex);
                if (!isNaN(index)) {
                    return index;
                }
            }
            target = element.parentElement;
        }
        return -1;
    };
    ListView.prototype.getRenderRange = function (renderTop, renderHeight) {
        return {
            start: this.rangeMap.indexAt(renderTop),
            end: this.rangeMap.indexAfter(renderTop + renderHeight - 1)
        };
    };
    ListView.prototype.getNextToLastElement = function (ranges) {
        var lastRange = ranges[ranges.length - 1];
        if (!lastRange) {
            return null;
        }
        var nextToLastItem = this.items[lastRange.end];
        if (!nextToLastItem) {
            return null;
        }
        if (!nextToLastItem.row) {
            return null;
        }
        return nextToLastItem.row.domNode;
    };
    // Dispose
    ListView.prototype.dispose = function () {
        this.items = null;
        if (this._domNode && this._domNode.parentElement) {
            this._domNode.parentNode.removeChild(this._domNode);
            this._domNode = null;
        }
        this.disposables = dispose(this.disposables);
    };
    __decorate$5([
        memoize
    ], ListView.prototype, "onMouseClick", null);
    __decorate$5([
        memoize
    ], ListView.prototype, "onMouseDblClick", null);
    __decorate$5([
        memoize
    ], ListView.prototype, "onMouseUp", null);
    __decorate$5([
        memoize
    ], ListView.prototype, "onMouseDown", null);
    __decorate$5([
        memoize
    ], ListView.prototype, "onMouseOver", null);
    __decorate$5([
        memoize
    ], ListView.prototype, "onMouseMove", null);
    __decorate$5([
        memoize
    ], ListView.prototype, "onMouseOut", null);
    __decorate$5([
        memoize
    ], ListView.prototype, "onContextMenu", null);
    __decorate$5([
        memoize
    ], ListView.prototype, "onTouchStart", null);
    __decorate$5([
        memoize
    ], ListView.prototype, "onTap", null);
    return ListView;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
function clamp$1(value, min, max) {
    return Math.min(Math.max(value, min), max);
}

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$17 = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate$6 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var CombinedSpliceable = /** @class */ (function () {
    function CombinedSpliceable(spliceables) {
        this.spliceables = spliceables;
    }
    CombinedSpliceable.prototype.splice = function (start, deleteCount, elements) {
        for (var _i = 0, _a = this.spliceables; _i < _a.length; _i++) {
            var spliceable = _a[_i];
            spliceable.splice(start, deleteCount, elements);
        }
    };
    return CombinedSpliceable;
}());
var TraitRenderer = /** @class */ (function () {
    function TraitRenderer(trait) {
        this.trait = trait;
        this.renderedElements = [];
    }
    Object.defineProperty(TraitRenderer.prototype, "templateId", {
        get: function () {
            return "template:" + this.trait.trait;
        },
        enumerable: true,
        configurable: true
    });
    TraitRenderer.prototype.renderTemplate = function (container) {
        return container;
    };
    TraitRenderer.prototype.renderElement = function (element, index$$1, templateData) {
        var renderedElementIndex = firstIndex(this.renderedElements, function (el) { return el.templateData === templateData; });
        if (renderedElementIndex >= 0) {
            var rendered = this.renderedElements[renderedElementIndex];
            this.trait.unrender(templateData);
            rendered.index = index$$1;
        }
        else {
            var rendered = { index: index$$1, templateData: templateData };
            this.renderedElements.push(rendered);
        }
        this.trait.renderIndex(index$$1, templateData);
    };
    TraitRenderer.prototype.splice = function (start, deleteCount, insertCount) {
        var rendered = [];
        for (var i = 0; i < this.renderedElements.length; i++) {
            var renderedElement = this.renderedElements[i];
            if (renderedElement.index < start) {
                rendered.push(renderedElement);
            }
            else if (renderedElement.index >= start + deleteCount) {
                rendered.push({
                    index: renderedElement.index + insertCount - deleteCount,
                    templateData: renderedElement.templateData
                });
            }
        }
        this.renderedElements = rendered;
    };
    TraitRenderer.prototype.renderIndexes = function (indexes) {
        for (var _i = 0, _a = this.renderedElements; _i < _a.length; _i++) {
            var _b = _a[_i], index$$1 = _b.index, templateData = _b.templateData;
            if (indexes.indexOf(index$$1) > -1) {
                this.trait.renderIndex(index$$1, templateData);
            }
        }
    };
    TraitRenderer.prototype.disposeTemplate = function (templateData) {
        var index$$1 = firstIndex(this.renderedElements, function (el) { return el.templateData === templateData; });
        if (index$$1 < 0) {
            return;
        }
        this.renderedElements.splice(index$$1, 1);
    };
    return TraitRenderer;
}());
var Trait = /** @class */ (function () {
    function Trait(_trait) {
        this._trait = _trait;
        this._onChange = new Emitter();
        this.indexes = [];
    }
    Object.defineProperty(Trait.prototype, "onChange", {
        get: function () { return this._onChange.event; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Trait.prototype, "trait", {
        get: function () { return this._trait; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Trait.prototype, "renderer", {
        get: function () {
            return new TraitRenderer(this);
        },
        enumerable: true,
        configurable: true
    });
    Trait.prototype.splice = function (start, deleteCount, elements) {
        var diff = elements.length - deleteCount;
        var end = start + deleteCount;
        var indexes = this.indexes.filter(function (i) { return i < start; }).concat(elements.map(function (hasTrait, i) { return hasTrait ? i + start : -1; }).filter(function (i) { return i !== -1; }), this.indexes.filter(function (i) { return i >= end; }).map(function (i) { return i + diff; }));
        this.renderer.splice(start, deleteCount, elements.length);
        this.set(indexes);
    };
    Trait.prototype.renderIndex = function (index$$1, container) {
        toggleClass(container, this._trait, this.contains(index$$1));
    };
    Trait.prototype.unrender = function (container) {
        removeClass(container, this._trait);
    };
    /**
     * Sets the indexes which should have this trait.
     *
     * @param indexes Indexes which should have this trait.
     * @return The old indexes which had this trait.
     */
    Trait.prototype.set = function (indexes) {
        var result = this.indexes;
        this.indexes = indexes;
        var toRender = disjunction(result, indexes);
        this.renderer.renderIndexes(toRender);
        this._onChange.fire({ indexes: indexes });
        return result;
    };
    Trait.prototype.get = function () {
        return this.indexes;
    };
    Trait.prototype.contains = function (index$$1) {
        return this.indexes.some(function (i) { return i === index$$1; });
    };
    Trait.prototype.dispose = function () {
        this.indexes = null;
        this._onChange = dispose(this._onChange);
    };
    __decorate$6([
        memoize
    ], Trait.prototype, "renderer", null);
    return Trait;
}());
var FocusTrait = /** @class */ (function (_super) {
    __extends$17(FocusTrait, _super);
    function FocusTrait(getDomId) {
        var _this = _super.call(this, 'focused') || this;
        _this.getDomId = getDomId;
        return _this;
    }
    FocusTrait.prototype.renderIndex = function (index$$1, container) {
        _super.prototype.renderIndex.call(this, index$$1, container);
        container.setAttribute('role', 'treeitem');
        container.setAttribute('id', this.getDomId(index$$1));
    };
    return FocusTrait;
}(Trait));
/**
 * The TraitSpliceable is used as a util class to be able
 * to preserve traits across splice calls, given an identity
 * provider.
 */
var TraitSpliceable = /** @class */ (function () {
    function TraitSpliceable(trait, view, getId) {
        this.trait = trait;
        this.view = view;
        this.getId = getId;
    }
    TraitSpliceable.prototype.splice = function (start, deleteCount, elements) {
        var _this = this;
        if (!this.getId) {
            return this.trait.splice(start, deleteCount, elements.map(function (e) { return false; }));
        }
        var pastElementsWithTrait = this.trait.get().map(function (i) { return _this.getId(_this.view.element(i)); });
        var elementsWithTrait = elements.map(function (e) { return pastElementsWithTrait.indexOf(_this.getId(e)) > -1; });
        this.trait.splice(start, deleteCount, elementsWithTrait);
    };
    return TraitSpliceable;
}());
function isInputElement(e) {
    return e.tagName === 'INPUT' || e.tagName === 'TEXTAREA';
}
var KeyboardController = /** @class */ (function () {
    function KeyboardController(list, view, options) {
        this.list = list;
        this.view = view;
        var multipleSelectionSupport = !(options.multipleSelectionSupport === false);
        this.disposables = [];
        this.openController = options.openController || DefaultOpenController;
        var onKeyDown = chain(domEvent(view.domNode, 'keydown'))
            .filter(function (e) { return !isInputElement(e.target); })
            .map(function (e) { return new StandardKeyboardEvent(e); });
        onKeyDown.filter(function (e) { return e.keyCode === 3 /* Enter */; }).on(this.onEnter, this, this.disposables);
        onKeyDown.filter(function (e) { return e.keyCode === 16 /* UpArrow */; }).on(this.onUpArrow, this, this.disposables);
        onKeyDown.filter(function (e) { return e.keyCode === 18 /* DownArrow */; }).on(this.onDownArrow, this, this.disposables);
        onKeyDown.filter(function (e) { return e.keyCode === 11 /* PageUp */; }).on(this.onPageUpArrow, this, this.disposables);
        onKeyDown.filter(function (e) { return e.keyCode === 12 /* PageDown */; }).on(this.onPageDownArrow, this, this.disposables);
        onKeyDown.filter(function (e) { return e.keyCode === 9 /* Escape */; }).on(this.onEscape, this, this.disposables);
        if (multipleSelectionSupport) {
            onKeyDown.filter(function (e) { return (isMacintosh ? e.metaKey : e.ctrlKey) && e.keyCode === 31 /* KEY_A */; }).on(this.onCtrlA, this, this.disposables);
        }
    }
    KeyboardController.prototype.onEnter = function (e) {
        e.preventDefault();
        e.stopPropagation();
        this.list.setSelection(this.list.getFocus());
        if (this.openController.shouldOpen(e.browserEvent)) {
            this.list.open(this.list.getFocus(), e.browserEvent);
        }
    };
    KeyboardController.prototype.onUpArrow = function (e) {
        e.preventDefault();
        e.stopPropagation();
        this.list.focusPrevious();
        this.list.reveal(this.list.getFocus()[0]);
        this.view.domNode.focus();
    };
    KeyboardController.prototype.onDownArrow = function (e) {
        e.preventDefault();
        e.stopPropagation();
        this.list.focusNext();
        this.list.reveal(this.list.getFocus()[0]);
        this.view.domNode.focus();
    };
    KeyboardController.prototype.onPageUpArrow = function (e) {
        e.preventDefault();
        e.stopPropagation();
        this.list.focusPreviousPage();
        this.list.reveal(this.list.getFocus()[0]);
        this.view.domNode.focus();
    };
    KeyboardController.prototype.onPageDownArrow = function (e) {
        e.preventDefault();
        e.stopPropagation();
        this.list.focusNextPage();
        this.list.reveal(this.list.getFocus()[0]);
        this.view.domNode.focus();
    };
    KeyboardController.prototype.onCtrlA = function (e) {
        e.preventDefault();
        e.stopPropagation();
        this.list.setSelection(range(this.list.length));
        this.view.domNode.focus();
    };
    KeyboardController.prototype.onEscape = function (e) {
        e.preventDefault();
        e.stopPropagation();
        this.list.setSelection([]);
        this.view.domNode.focus();
    };
    KeyboardController.prototype.dispose = function () {
        this.disposables = dispose(this.disposables);
    };
    return KeyboardController;
}());
var DOMFocusController = /** @class */ (function () {
    function DOMFocusController(list, view) {
        this.list = list;
        this.view = view;
        this.disposables = [];
        this.disposables = [];
        var onKeyDown = chain(domEvent(view.domNode, 'keydown'))
            .filter(function (e) { return !isInputElement(e.target); })
            .map(function (e) { return new StandardKeyboardEvent(e); });
        onKeyDown.filter(function (e) { return e.keyCode === 2 /* Tab */ && !e.ctrlKey && !e.metaKey && !e.shiftKey && !e.altKey; })
            .on(this.onTab, this, this.disposables);
    }
    DOMFocusController.prototype.onTab = function (e) {
        if (e.target !== this.view.domNode) {
            return;
        }
        var focus = this.list.getFocus();
        if (focus.length === 0) {
            return;
        }
        var focusedDomElement = this.view.domElement(focus[0]);
        var tabIndexElement = focusedDomElement.querySelector('[tabIndex]');
        if (!tabIndexElement || !(tabIndexElement instanceof HTMLElement)) {
            return;
        }
        e.preventDefault();
        e.stopPropagation();
        tabIndexElement.focus();
    };
    DOMFocusController.prototype.dispose = function () {
        this.disposables = dispose(this.disposables);
    };
    return DOMFocusController;
}());
function isSelectionSingleChangeEvent(event) {
    return isMacintosh ? event.browserEvent.metaKey : event.browserEvent.ctrlKey;
}
function isSelectionRangeChangeEvent(event) {
    return event.browserEvent.shiftKey;
}
function isMouseRightClick(event) {
    return event instanceof MouseEvent && event.button === 2;
}
var DefaultMultipleSelectionContoller = {
    isSelectionSingleChangeEvent: isSelectionSingleChangeEvent,
    isSelectionRangeChangeEvent: isSelectionRangeChangeEvent
};
var DefaultOpenController = {
    shouldOpen: function (event) {
        if (event instanceof MouseEvent) {
            return !isMouseRightClick(event);
        }
        return true;
    }
};
var MouseController = /** @class */ (function () {
    function MouseController(list, view, options) {
        if (options === void 0) { options = {}; }
        this.list = list;
        this.view = view;
        this.options = options;
        this.didJustPressContextMenuKey = false;
        this.disposables = [];
        this.multipleSelectionSupport = !(options.multipleSelectionSupport === false);
        if (this.multipleSelectionSupport) {
            this.multipleSelectionController = options.multipleSelectionController || DefaultMultipleSelectionContoller;
        }
        this.openController = options.openController || DefaultOpenController;
        view.onMouseDown(this.onMouseDown, this, this.disposables);
        view.onMouseClick(this.onPointer, this, this.disposables);
        view.onMouseDblClick(this.onDoubleClick, this, this.disposables);
        view.onTouchStart(this.onMouseDown, this, this.disposables);
        view.onTap(this.onPointer, this, this.disposables);
        Gesture.addTarget(view.domNode);
    }
    Object.defineProperty(MouseController.prototype, "onContextMenu", {
        get: function () {
            var _this = this;
            var fromKeydown = chain(domEvent(this.view.domNode, 'keydown'))
                .map(function (e) { return new StandardKeyboardEvent(e); })
                .filter(function (e) { return _this.didJustPressContextMenuKey = e.keyCode === 58 /* ContextMenu */ || (e.shiftKey && e.keyCode === 68 /* F10 */); })
                .filter(function (e) { e.preventDefault(); e.stopPropagation(); return false; })
                .event;
            var fromKeyup = chain(domEvent(this.view.domNode, 'keyup'))
                .filter(function () {
                var didJustPressContextMenuKey = _this.didJustPressContextMenuKey;
                _this.didJustPressContextMenuKey = false;
                return didJustPressContextMenuKey;
            })
                .filter(function () { return _this.list.getFocus().length > 0; })
                .map(function () {
                var index$$1 = _this.list.getFocus()[0];
                var element = _this.view.element(index$$1);
                var anchor = _this.view.domElement(index$$1);
                return { index: index$$1, element: element, anchor: anchor };
            })
                .filter(function (_a) {
                var anchor = _a.anchor;
                return !!anchor;
            })
                .event;
            var fromMouse = chain(this.view.onContextMenu)
                .filter(function () { return !_this.didJustPressContextMenuKey; })
                .map(function (_a) {
                var element = _a.element, index$$1 = _a.index, browserEvent = _a.browserEvent;
                return ({ element: element, index: index$$1, anchor: { x: browserEvent.clientX + 1, y: browserEvent.clientY } });
            })
                .event;
            return anyEvent(fromKeydown, fromKeyup, fromMouse);
        },
        enumerable: true,
        configurable: true
    });
    MouseController.prototype.isSelectionSingleChangeEvent = function (event) {
        if (this.multipleSelectionController) {
            return this.multipleSelectionController.isSelectionSingleChangeEvent(event);
        }
        return isMacintosh ? event.browserEvent.metaKey : event.browserEvent.ctrlKey;
    };
    MouseController.prototype.isSelectionRangeChangeEvent = function (event) {
        if (this.multipleSelectionController) {
            return this.multipleSelectionController.isSelectionRangeChangeEvent(event);
        }
        return event.browserEvent.shiftKey;
    };
    MouseController.prototype.isSelectionChangeEvent = function (event) {
        return this.isSelectionSingleChangeEvent(event) || this.isSelectionRangeChangeEvent(event);
    };
    MouseController.prototype.onMouseDown = function (e) {
        if (this.options.focusOnMouseDown === false) {
            e.browserEvent.preventDefault();
            e.browserEvent.stopPropagation();
        }
        else if (document.activeElement !== e.browserEvent.target) {
            this.view.domNode.focus();
        }
        var reference = this.list.getFocus()[0];
        var selection = this.list.getSelection();
        reference = reference === undefined ? selection[0] : reference;
        if (this.multipleSelectionSupport && this.isSelectionRangeChangeEvent(e)) {
            return this.changeSelection(e, reference);
        }
        var focus = e.index;
        if (selection.every(function (s) { return s !== focus; })) {
            this.list.setFocus([focus]);
        }
        if (this.multipleSelectionSupport && this.isSelectionChangeEvent(e)) {
            return this.changeSelection(e, reference);
        }
        if (this.options.selectOnMouseDown && !isMouseRightClick(e.browserEvent)) {
            this.list.setSelection([focus]);
            if (this.openController.shouldOpen(e.browserEvent)) {
                this.list.open([focus], e.browserEvent);
            }
        }
    };
    MouseController.prototype.onPointer = function (e) {
        if (this.multipleSelectionSupport && this.isSelectionChangeEvent(e)) {
            return;
        }
        if (!this.options.selectOnMouseDown) {
            var focus_1 = this.list.getFocus();
            this.list.setSelection(focus_1);
            if (this.openController.shouldOpen(e.browserEvent)) {
                this.list.open(focus_1, e.browserEvent);
            }
        }
    };
    MouseController.prototype.onDoubleClick = function (e) {
        if (this.multipleSelectionSupport && this.isSelectionChangeEvent(e)) {
            return;
        }
        var focus = this.list.getFocus();
        this.list.setSelection(focus);
        this.list.pin(focus);
    };
    MouseController.prototype.changeSelection = function (e, reference) {
        var focus = e.index;
        if (this.isSelectionRangeChangeEvent(e) && reference !== undefined) {
            var min = Math.min(reference, focus);
            var max = Math.max(reference, focus);
            var rangeSelection = range(min, max + 1);
            var selection = this.list.getSelection();
            var contiguousRange = getContiguousRangeContaining(disjunction(selection, [reference]), reference);
            if (contiguousRange.length === 0) {
                return;
            }
            var newSelection = disjunction(rangeSelection, relativeComplement$1(selection, contiguousRange));
            this.list.setSelection(newSelection);
        }
        else if (this.isSelectionSingleChangeEvent(e)) {
            var selection = this.list.getSelection();
            var newSelection = selection.filter(function (i) { return i !== focus; });
            if (selection.length === newSelection.length) {
                this.list.setSelection(newSelection.concat([focus]));
            }
            else {
                this.list.setSelection(newSelection);
            }
        }
    };
    MouseController.prototype.dispose = function () {
        this.disposables = dispose(this.disposables);
    };
    __decorate$6([
        memoize
    ], MouseController.prototype, "onContextMenu", null);
    return MouseController;
}());
var DefaultStyleController = /** @class */ (function () {
    function DefaultStyleController(styleElement, selectorSuffix) {
        this.styleElement = styleElement;
        this.selectorSuffix = selectorSuffix;
    }
    DefaultStyleController.prototype.style = function (styles) {
        var suffix = this.selectorSuffix ? "." + this.selectorSuffix : '';
        var content = [];
        if (styles.listFocusBackground) {
            content.push(".monaco-list" + suffix + ":focus .monaco-list-row.focused { background-color: " + styles.listFocusBackground + "; }");
            content.push(".monaco-list" + suffix + ":focus .monaco-list-row.focused:hover { background-color: " + styles.listFocusBackground + "; }"); // overwrite :hover style in this case!
        }
        if (styles.listFocusForeground) {
            content.push(".monaco-list" + suffix + ":focus .monaco-list-row.focused { color: " + styles.listFocusForeground + "; }");
        }
        if (styles.listActiveSelectionBackground) {
            content.push(".monaco-list" + suffix + ":focus .monaco-list-row.selected { background-color: " + styles.listActiveSelectionBackground + "; }");
            content.push(".monaco-list" + suffix + ":focus .monaco-list-row.selected:hover { background-color: " + styles.listActiveSelectionBackground + "; }"); // overwrite :hover style in this case!
        }
        if (styles.listActiveSelectionForeground) {
            content.push(".monaco-list" + suffix + ":focus .monaco-list-row.selected { color: " + styles.listActiveSelectionForeground + "; }");
        }
        if (styles.listFocusAndSelectionBackground) {
            content.push(".monaco-list" + suffix + ":focus .monaco-list-row.selected.focused { background-color: " + styles.listFocusAndSelectionBackground + "; }");
        }
        if (styles.listFocusAndSelectionForeground) {
            content.push(".monaco-list" + suffix + ":focus .monaco-list-row.selected.focused { color: " + styles.listFocusAndSelectionForeground + "; }");
        }
        if (styles.listInactiveFocusBackground) {
            content.push(".monaco-list" + suffix + " .monaco-list-row.focused { background-color:  " + styles.listInactiveFocusBackground + "; }");
            content.push(".monaco-list" + suffix + " .monaco-list-row.focused:hover { background-color:  " + styles.listInactiveFocusBackground + "; }"); // overwrite :hover style in this case!
        }
        if (styles.listInactiveSelectionBackground) {
            content.push(".monaco-list" + suffix + " .monaco-list-row.selected { background-color:  " + styles.listInactiveSelectionBackground + "; }");
            content.push(".monaco-list" + suffix + " .monaco-list-row.selected:hover { background-color:  " + styles.listInactiveSelectionBackground + "; }"); // overwrite :hover style in this case!
        }
        if (styles.listInactiveSelectionForeground) {
            content.push(".monaco-list" + suffix + " .monaco-list-row.selected { color: " + styles.listInactiveSelectionForeground + "; }");
        }
        if (styles.listHoverBackground) {
            content.push(".monaco-list" + suffix + " .monaco-list-row:hover { background-color:  " + styles.listHoverBackground + "; }");
        }
        if (styles.listHoverForeground) {
            content.push(".monaco-list" + suffix + " .monaco-list-row:hover { color:  " + styles.listHoverForeground + "; }");
        }
        if (styles.listSelectionOutline) {
            content.push(".monaco-list" + suffix + " .monaco-list-row.selected { outline: 1px dotted " + styles.listSelectionOutline + "; outline-offset: -1px; }");
        }
        if (styles.listFocusOutline) {
            content.push(".monaco-list" + suffix + ":focus .monaco-list-row.focused { outline: 1px solid " + styles.listFocusOutline + "; outline-offset: -1px; }");
        }
        if (styles.listInactiveFocusOutline) {
            content.push(".monaco-list" + suffix + " .monaco-list-row.focused { outline: 1px dotted " + styles.listInactiveFocusOutline + "; outline-offset: -1px; }");
        }
        if (styles.listHoverOutline) {
            content.push(".monaco-list" + suffix + " .monaco-list-row:hover { outline: 1px dashed " + styles.listHoverOutline + "; outline-offset: -1px; }");
        }
        var newStyles = content.join('\n');
        if (newStyles !== this.styleElement.innerHTML) {
            this.styleElement.innerHTML = newStyles;
        }
    };
    return DefaultStyleController;
}());
var defaultStyles = {
    listFocusBackground: Color.fromHex('#073655'),
    listActiveSelectionBackground: Color.fromHex('#0E639C'),
    listActiveSelectionForeground: Color.fromHex('#FFFFFF'),
    listFocusAndSelectionBackground: Color.fromHex('#094771'),
    listFocusAndSelectionForeground: Color.fromHex('#FFFFFF'),
    listInactiveSelectionBackground: Color.fromHex('#3F3F46'),
    listHoverBackground: Color.fromHex('#2A2D2E'),
    listDropBackground: Color.fromHex('#383B3D')
};
var DefaultOptions$1 = {
    keyboardSupport: true,
    mouseSupport: true,
    multipleSelectionSupport: true
};
// TODO@Joao: move these utils into a SortedArray class
function getContiguousRangeContaining(range$$1, value) {
    var index$$1 = range$$1.indexOf(value);
    if (index$$1 === -1) {
        return [];
    }
    var result = [];
    var i = index$$1 - 1;
    while (i >= 0 && range$$1[i] === value - (index$$1 - i)) {
        result.push(range$$1[i--]);
    }
    result.reverse();
    i = index$$1;
    while (i < range$$1.length && range$$1[i] === value + (i - index$$1)) {
        result.push(range$$1[i++]);
    }
    return result;
}
/**
 * Given two sorted collections of numbers, returns the intersection
 * betweem them (OR).
 */
function disjunction(one, other) {
    var result = [];
    var i = 0, j = 0;
    while (i < one.length || j < other.length) {
        if (i >= one.length) {
            result.push(other[j++]);
        }
        else if (j >= other.length) {
            result.push(one[i++]);
        }
        else if (one[i] === other[j]) {
            result.push(one[i]);
            i++;
            j++;
            continue;
        }
        else if (one[i] < other[j]) {
            result.push(one[i++]);
        }
        else {
            result.push(other[j++]);
        }
    }
    return result;
}
/**
 * Given two sorted collections of numbers, returns the relative
 * complement between them (XOR).
 */
function relativeComplement$1(one, other) {
    var result = [];
    var i = 0, j = 0;
    while (i < one.length || j < other.length) {
        if (i >= one.length) {
            result.push(other[j++]);
        }
        else if (j >= other.length) {
            result.push(one[i++]);
        }
        else if (one[i] === other[j]) {
            i++;
            j++;
            continue;
        }
        else if (one[i] < other[j]) {
            result.push(one[i++]);
        }
        else {
            j++;
        }
    }
    return result;
}
var numericSort = function (a, b) { return a - b; };
var PipelineRenderer = /** @class */ (function () {
    function PipelineRenderer(_templateId, renderers) {
        this._templateId = _templateId;
        this.renderers = renderers;
    }
    Object.defineProperty(PipelineRenderer.prototype, "templateId", {
        get: function () {
            return this._templateId;
        },
        enumerable: true,
        configurable: true
    });
    PipelineRenderer.prototype.renderTemplate = function (container) {
        return this.renderers.map(function (r) { return r.renderTemplate(container); });
    };
    PipelineRenderer.prototype.renderElement = function (element, index$$1, templateData) {
        var i = 0;
        for (var _i = 0, _a = this.renderers; _i < _a.length; _i++) {
            var renderer = _a[_i];
            renderer.renderElement(element, index$$1, templateData[i++]);
        }
    };
    PipelineRenderer.prototype.disposeTemplate = function (templateData) {
        var i = 0;
        for (var _i = 0, _a = this.renderers; _i < _a.length; _i++) {
            var renderer = _a[_i];
            renderer.disposeTemplate(templateData[i++]);
        }
    };
    return PipelineRenderer;
}());
var List = /** @class */ (function () {
    function List(container, delegate, renderers, options) {
        if (options === void 0) { options = DefaultOptions$1; }
        var _this = this;
        this.idPrefix = "list_id_" + ++List.InstanceCount;
        this.eventBufferer = new EventBufferer();
        this.onContextMenu = Event.None;
        this._onOpen = new Emitter();
        this.onOpen = this._onOpen.event;
        this._onPin = new Emitter();
        this._onDidDispose = new Emitter();
        this.focus = new FocusTrait(function (i) { return _this.getElementDomId(i); });
        this.selection = new Trait('selected');
        mixin(options, defaultStyles, false);
        renderers = renderers.map(function (r) { return new PipelineRenderer(r.templateId, [_this.focus.renderer, _this.selection.renderer, r]); });
        this.view = new ListView(container, delegate, renderers, options);
        this.view.domNode.setAttribute('role', 'tree');
        addClass(this.view.domNode, this.idPrefix);
        this.view.domNode.tabIndex = 0;
        this.styleElement = createStyleSheet(this.view.domNode);
        this.styleController = options.styleController;
        if (!this.styleController) {
            this.styleController = new DefaultStyleController(this.styleElement, this.idPrefix);
        }
        this.spliceable = new CombinedSpliceable([
            new TraitSpliceable(this.focus, this.view, options.identityProvider),
            new TraitSpliceable(this.selection, this.view, options.identityProvider),
            this.view
        ]);
        this.disposables = [this.focus, this.selection, this.view, this._onDidDispose];
        this.onDidFocus = mapEvent(domEvent(this.view.domNode, 'focus', true), function () { return null; });
        this.onDidBlur = mapEvent(domEvent(this.view.domNode, 'blur', true), function () { return null; });
        this.disposables.push(new DOMFocusController(this, this.view));
        if (typeof options.keyboardSupport !== 'boolean' || options.keyboardSupport) {
            var controller = new KeyboardController(this, this.view, options);
            this.disposables.push(controller);
        }
        if (typeof options.mouseSupport !== 'boolean' || options.mouseSupport) {
            this.mouseController = new MouseController(this, this.view, options);
            this.disposables.push(this.mouseController);
            this.onContextMenu = this.mouseController.onContextMenu;
        }
        this.onFocusChange(this._onFocusChange, this, this.disposables);
        this.onSelectionChange(this._onSelectionChange, this, this.disposables);
        if (options.ariaLabel) {
            this.view.domNode.setAttribute('aria-label', options.ariaLabel);
        }
        this.style(options);
    }
    Object.defineProperty(List.prototype, "onFocusChange", {
        get: function () {
            var _this = this;
            return mapEvent(this.eventBufferer.wrapEvent(this.focus.onChange), function (e) { return _this.toListEvent(e); });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(List.prototype, "onSelectionChange", {
        get: function () {
            var _this = this;
            return mapEvent(this.eventBufferer.wrapEvent(this.selection.onChange), function (e) { return _this.toListEvent(e); });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(List.prototype, "onPin", {
        get: function () {
            var _this = this;
            return mapEvent(this._onPin.event, function (indexes) { return _this.toListEvent({ indexes: indexes }); });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(List.prototype, "onMouseClick", {
        get: function () { return this.view.onMouseClick; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(List.prototype, "onMouseDblClick", {
        get: function () { return this.view.onMouseDblClick; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(List.prototype, "onMouseUp", {
        get: function () { return this.view.onMouseUp; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(List.prototype, "onMouseDown", {
        get: function () { return this.view.onMouseDown; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(List.prototype, "onMouseOver", {
        get: function () { return this.view.onMouseOver; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(List.prototype, "onMouseMove", {
        get: function () { return this.view.onMouseMove; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(List.prototype, "onMouseOut", {
        get: function () { return this.view.onMouseOut; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(List.prototype, "onTouchStart", {
        get: function () { return this.view.onTouchStart; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(List.prototype, "onTap", {
        get: function () { return this.view.onTap; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(List.prototype, "onKeyDown", {
        get: function () { return domEvent(this.view.domNode, 'keydown'); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(List.prototype, "onKeyUp", {
        get: function () { return domEvent(this.view.domNode, 'keyup'); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(List.prototype, "onKeyPress", {
        get: function () { return domEvent(this.view.domNode, 'keypress'); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(List.prototype, "onDidDispose", {
        get: function () { return this._onDidDispose.event; },
        enumerable: true,
        configurable: true
    });
    List.prototype.splice = function (start, deleteCount, elements) {
        var _this = this;
        if (elements === void 0) { elements = []; }
        if (deleteCount === 0 && elements.length === 0) {
            return;
        }
        this.eventBufferer.bufferEvents(function () { return _this.spliceable.splice(start, deleteCount, elements); });
    };
    Object.defineProperty(List.prototype, "length", {
        get: function () {
            return this.view.length;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(List.prototype, "contentHeight", {
        get: function () {
            return this.view.getContentHeight();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(List.prototype, "scrollTop", {
        get: function () {
            return this.view.getScrollTop();
        },
        set: function (scrollTop) {
            this.view.setScrollTop(scrollTop);
        },
        enumerable: true,
        configurable: true
    });
    List.prototype.domFocus = function () {
        this.view.domNode.focus();
    };
    List.prototype.layout = function (height) {
        this.view.layout(height);
    };
    List.prototype.setSelection = function (indexes) {
        for (var _i = 0, indexes_1 = indexes; _i < indexes_1.length; _i++) {
            var index$$1 = indexes_1[_i];
            if (index$$1 < 0 || index$$1 >= this.length) {
                throw new Error("Invalid index " + index$$1);
            }
        }
        indexes = indexes.sort(numericSort);
        this.selection.set(indexes);
    };
    List.prototype.selectNext = function (n, loop) {
        if (n === void 0) { n = 1; }
        if (loop === void 0) { loop = false; }
        if (this.length === 0) {
            return;
        }
        var selection = this.selection.get();
        var index$$1 = selection.length > 0 ? selection[0] + n : 0;
        this.setSelection(loop ? [index$$1 % this.length] : [Math.min(index$$1, this.length - 1)]);
    };
    List.prototype.selectPrevious = function (n, loop) {
        if (n === void 0) { n = 1; }
        if (loop === void 0) { loop = false; }
        if (this.length === 0) {
            return;
        }
        var selection = this.selection.get();
        var index$$1 = selection.length > 0 ? selection[0] - n : 0;
        if (loop && index$$1 < 0) {
            index$$1 = this.length + (index$$1 % this.length);
        }
        this.setSelection([Math.max(index$$1, 0)]);
    };
    List.prototype.getSelection = function () {
        return this.selection.get();
    };
    List.prototype.getSelectedElements = function () {
        var _this = this;
        return this.getSelection().map(function (i) { return _this.view.element(i); });
    };
    List.prototype.setFocus = function (indexes) {
        for (var _i = 0, indexes_2 = indexes; _i < indexes_2.length; _i++) {
            var index$$1 = indexes_2[_i];
            if (index$$1 < 0 || index$$1 >= this.length) {
                throw new Error("Invalid index " + index$$1);
            }
        }
        indexes = indexes.sort(numericSort);
        this.focus.set(indexes);
    };
    List.prototype.focusNext = function (n, loop) {
        if (n === void 0) { n = 1; }
        if (loop === void 0) { loop = false; }
        if (this.length === 0) {
            return;
        }
        var focus = this.focus.get();
        var index$$1 = focus.length > 0 ? focus[0] + n : 0;
        this.setFocus(loop ? [index$$1 % this.length] : [Math.min(index$$1, this.length - 1)]);
    };
    List.prototype.focusPrevious = function (n, loop) {
        if (n === void 0) { n = 1; }
        if (loop === void 0) { loop = false; }
        if (this.length === 0) {
            return;
        }
        var focus = this.focus.get();
        var index$$1 = focus.length > 0 ? focus[0] - n : 0;
        if (loop && index$$1 < 0) {
            index$$1 = (this.length + (index$$1 % this.length)) % this.length;
        }
        this.setFocus([Math.max(index$$1, 0)]);
    };
    List.prototype.focusNextPage = function () {
        var _this = this;
        var lastPageIndex = this.view.indexAt(this.view.getScrollTop() + this.view.renderHeight);
        lastPageIndex = lastPageIndex === 0 ? 0 : lastPageIndex - 1;
        var lastPageElement = this.view.element(lastPageIndex);
        var currentlyFocusedElement = this.getFocusedElements()[0];
        if (currentlyFocusedElement !== lastPageElement) {
            this.setFocus([lastPageIndex]);
        }
        else {
            var previousScrollTop = this.view.getScrollTop();
            this.view.setScrollTop(previousScrollTop + this.view.renderHeight - this.view.elementHeight(lastPageIndex));
            if (this.view.getScrollTop() !== previousScrollTop) {
                // Let the scroll event listener run
                setTimeout(function () { return _this.focusNextPage(); }, 0);
            }
        }
    };
    List.prototype.focusPreviousPage = function () {
        var _this = this;
        var firstPageIndex;
        var scrollTop = this.view.getScrollTop();
        if (scrollTop === 0) {
            firstPageIndex = this.view.indexAt(scrollTop);
        }
        else {
            firstPageIndex = this.view.indexAfter(scrollTop - 1);
        }
        var firstPageElement = this.view.element(firstPageIndex);
        var currentlyFocusedElement = this.getFocusedElements()[0];
        if (currentlyFocusedElement !== firstPageElement) {
            this.setFocus([firstPageIndex]);
        }
        else {
            var previousScrollTop = scrollTop;
            this.view.setScrollTop(scrollTop - this.view.renderHeight);
            if (this.view.getScrollTop() !== previousScrollTop) {
                // Let the scroll event listener run
                setTimeout(function () { return _this.focusPreviousPage(); }, 0);
            }
        }
    };
    List.prototype.focusLast = function () {
        if (this.length === 0) {
            return;
        }
        this.setFocus([this.length - 1]);
    };
    List.prototype.focusFirst = function () {
        if (this.length === 0) {
            return;
        }
        this.setFocus([0]);
    };
    List.prototype.getFocus = function () {
        return this.focus.get();
    };
    List.prototype.getFocusedElements = function () {
        var _this = this;
        return this.getFocus().map(function (i) { return _this.view.element(i); });
    };
    List.prototype.reveal = function (index$$1, relativeTop) {
        if (index$$1 < 0 || index$$1 >= this.length) {
            throw new Error("Invalid index " + index$$1);
        }
        var scrollTop = this.view.getScrollTop();
        var elementTop = this.view.elementTop(index$$1);
        var elementHeight = this.view.elementHeight(index$$1);
        if (isNumber(relativeTop)) {
            // y = mx + b
            var m = elementHeight - this.view.renderHeight;
            this.view.setScrollTop(m * clamp$1(relativeTop, 0, 1) + elementTop);
        }
        else {
            var viewItemBottom = elementTop + elementHeight;
            var wrapperBottom = scrollTop + this.view.renderHeight;
            if (elementTop < scrollTop) {
                this.view.setScrollTop(elementTop);
            }
            else if (viewItemBottom >= wrapperBottom) {
                this.view.setScrollTop(viewItemBottom - this.view.renderHeight);
            }
        }
    };
    /**
     * Returns the relative position of an element rendered in the list.
     * Returns `null` if the element isn't *entirely* in the visible viewport.
     */
    List.prototype.getRelativeTop = function (index$$1) {
        if (index$$1 < 0 || index$$1 >= this.length) {
            throw new Error("Invalid index " + index$$1);
        }
        var scrollTop = this.view.getScrollTop();
        var elementTop = this.view.elementTop(index$$1);
        var elementHeight = this.view.elementHeight(index$$1);
        if (elementTop < scrollTop || elementTop + elementHeight > scrollTop + this.view.renderHeight) {
            return null;
        }
        // y = mx + b
        var m = elementHeight - this.view.renderHeight;
        return Math.abs((scrollTop - elementTop) / m);
    };
    List.prototype.getElementDomId = function (index$$1) {
        return this.idPrefix + "_" + index$$1;
    };
    List.prototype.isDOMFocused = function () {
        return this.view.domNode === document.activeElement;
    };
    List.prototype.getHTMLElement = function () {
        return this.view.domNode;
    };
    List.prototype.open = function (indexes, browserEvent) {
        var _this = this;
        for (var _i = 0, indexes_3 = indexes; _i < indexes_3.length; _i++) {
            var index$$1 = indexes_3[_i];
            if (index$$1 < 0 || index$$1 >= this.length) {
                throw new Error("Invalid index " + index$$1);
            }
        }
        this._onOpen.fire({ indexes: indexes, elements: indexes.map(function (i) { return _this.view.element(i); }), browserEvent: browserEvent });
    };
    List.prototype.pin = function (indexes) {
        for (var _i = 0, indexes_4 = indexes; _i < indexes_4.length; _i++) {
            var index$$1 = indexes_4[_i];
            if (index$$1 < 0 || index$$1 >= this.length) {
                throw new Error("Invalid index " + index$$1);
            }
        }
        this._onPin.fire(indexes);
    };
    List.prototype.style = function (styles) {
        this.styleController.style(styles);
    };
    List.prototype.toListEvent = function (_a) {
        var _this = this;
        var indexes = _a.indexes;
        return { indexes: indexes, elements: indexes.map(function (i) { return _this.view.element(i); }) };
    };
    List.prototype._onFocusChange = function () {
        var focus = this.focus.get();
        if (focus.length > 0) {
            this.view.domNode.setAttribute('aria-activedescendant', this.getElementDomId(focus[0]));
        }
        else {
            this.view.domNode.removeAttribute('aria-activedescendant');
        }
        this.view.domNode.setAttribute('role', 'tree');
        toggleClass(this.view.domNode, 'element-focused', focus.length > 0);
    };
    List.prototype._onSelectionChange = function () {
        var selection = this.selection.get();
        toggleClass(this.view.domNode, 'selection-none', selection.length === 0);
        toggleClass(this.view.domNode, 'selection-single', selection.length === 1);
        toggleClass(this.view.domNode, 'selection-multiple', selection.length > 1);
    };
    List.prototype.dispose = function () {
        this._onDidDispose.fire();
        this.disposables = dispose(this.disposables);
    };
    List.InstanceCount = 0;
    __decorate$6([
        memoize
    ], List.prototype, "onFocusChange", null);
    __decorate$6([
        memoize
    ], List.prototype, "onSelectionChange", null);
    __decorate$6([
        memoize
    ], List.prototype, "onPin", null);
    return List;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var $$2 = $;
var SELECT_OPTION_ENTRY_TEMPLATE_ID = 'selectOption.entry.template';
var SelectListRenderer = /** @class */ (function () {
    function SelectListRenderer() {
    }
    Object.defineProperty(SelectListRenderer.prototype, "templateId", {
        get: function () { return SELECT_OPTION_ENTRY_TEMPLATE_ID; },
        enumerable: true,
        configurable: true
    });
    SelectListRenderer.prototype.renderTemplate = function (container) {
        var data = Object.create(null);
        data.disposables = [];
        data.root = container;
        data.optionText = append(container, $$2('.option-text'));
        return data;
    };
    SelectListRenderer.prototype.renderElement = function (element, index$$1, templateData) {
        var data = templateData;
        var optionText = element.optionText;
        var optionDisabled = element.optionDisabled;
        data.optionText.textContent = optionText;
        data.root.setAttribute('aria-label', localize('selectAriaOption', "{0}", optionText));
        // pseudo-select disabled option
        if (optionDisabled) {
            addClass(data.root, 'option-disabled');
        }
        else {
            // Make sure we do class removal from prior template rendering
            removeClass(data.root, 'option-disabled');
        }
    };
    SelectListRenderer.prototype.disposeTemplate = function (templateData) {
        templateData.disposables = dispose(templateData.disposables);
    };
    return SelectListRenderer;
}());
var SelectBoxList = /** @class */ (function () {
    function SelectBoxList(options, selected, contextViewProvider, styles, selectBoxOptions) {
        this.toDispose = [];
        this._isVisible = false;
        this.selectBoxOptions = selectBoxOptions || Object.create(null);
        if (typeof this.selectBoxOptions.minBottomMargin !== 'number') {
            this.selectBoxOptions.minBottomMargin = SelectBoxList.DEFAULT_DROPDOWN_MINIMUM_BOTTOM_MARGIN;
        }
        else if (this.selectBoxOptions.minBottomMargin < 0) {
            this.selectBoxOptions.minBottomMargin = 0;
        }
        this.selectElement = document.createElement('select');
        this.selectElement.className = 'monaco-select-box';
        this._onDidSelect = new Emitter();
        this.styles = styles;
        this.registerListeners();
        this.constructSelectDropDown(contextViewProvider);
        this.setOptions(options, selected);
    }
    // IDelegate - List renderer
    SelectBoxList.prototype.getHeight = function () {
        return 18;
    };
    SelectBoxList.prototype.getTemplateId = function () {
        return SELECT_OPTION_ENTRY_TEMPLATE_ID;
    };
    SelectBoxList.prototype.constructSelectDropDown = function (contextViewProvider) {
        // SetUp ContextView container to hold select Dropdown
        this.contextViewProvider = contextViewProvider;
        this.selectDropDownContainer = $('.monaco-select-box-dropdown-container');
        // Setup list for drop-down select
        this.createSelectList(this.selectDropDownContainer);
        // Create span flex box item/div we can measure and control
        var widthControlOuterDiv = append(this.selectDropDownContainer, $$2('.select-box-dropdown-container-width-control'));
        var widthControlInnerDiv = append(widthControlOuterDiv, $$2('.width-control-div'));
        this.widthControlElement = document.createElement('span');
        this.widthControlElement.className = 'option-text-width-control';
        append(widthControlInnerDiv, this.widthControlElement);
        // Inline stylesheet for themes
        this.styleElement = createStyleSheet(this.selectDropDownContainer);
    };
    SelectBoxList.prototype.registerListeners = function () {
        // Parent native select keyboard listeners
        var _this = this;
        this.toDispose.push(addStandardDisposableListener(this.selectElement, 'change', function (e) {
            _this.selectElement.title = e.target.value;
            _this._onDidSelect.fire({
                index: e.target.selectedIndex,
                selected: e.target.value
            });
        }));
        // Have to implement both keyboard and mouse controllers to handle disabled options
        // Intercept mouse events to override normal select actions on parents
        this.toDispose.push(addDisposableListener(this.selectElement, EventType.CLICK, function (e) {
            EventHelper.stop(e);
            if (_this._isVisible) {
                _this.hideSelectDropDown(true);
            }
            else {
                _this.showSelectDropDown();
            }
        }));
        this.toDispose.push(addDisposableListener(this.selectElement, EventType.MOUSE_DOWN, function (e) {
            EventHelper.stop(e);
        }));
        // Intercept keyboard handling
        this.toDispose.push(addDisposableListener(this.selectElement, EventType.KEY_DOWN, function (e) {
            var event = new StandardKeyboardEvent(e);
            var showDropDown = false;
            // Create and drop down select list on keyboard select
            if (isMacintosh) {
                if (event.keyCode === 18 /* DownArrow */ || event.keyCode === 16 /* UpArrow */ || event.keyCode === 10 /* Space */ || event.keyCode === 3 /* Enter */) {
                    showDropDown = true;
                }
            }
            else {
                if (event.keyCode === 18 /* DownArrow */ && event.altKey || event.keyCode === 16 /* UpArrow */ && event.altKey || event.keyCode === 10 /* Space */ || event.keyCode === 3 /* Enter */) {
                    showDropDown = true;
                }
            }
            if (showDropDown) {
                _this.showSelectDropDown();
                EventHelper.stop(e);
            }
        }));
    };
    Object.defineProperty(SelectBoxList.prototype, "onDidSelect", {
        get: function () {
            return this._onDidSelect.event;
        },
        enumerable: true,
        configurable: true
    });
    SelectBoxList.prototype.setOptions = function (options, selected, disabled) {
        var _this = this;
        if (!this.options || !equals(this.options, options)) {
            this.options = options;
            this.selectElement.options.length = 0;
            var i_1 = 0;
            this.options.forEach(function (option) {
                _this.selectElement.add(_this.createOption(option, i_1, disabled === i_1++));
            });
            // Mirror options in drop-down
            // Populate select list for non-native select mode
            if (this.selectList && !!this.options) {
                var listEntries = void 0;
                listEntries = [];
                if (disabled !== undefined) {
                    this.disabledOptionIndex = disabled;
                }
                for (var index$$1 = 0; index$$1 < this.options.length; index$$1++) {
                    var element = this.options[index$$1];
                    var optionDisabled = void 0;
                    index$$1 === this.disabledOptionIndex ? optionDisabled = true : optionDisabled = false;
                    listEntries.push({ optionText: element, optionDisabled: optionDisabled });
                }
                this.selectList.splice(0, this.selectList.length, listEntries);
            }
        }
        if (selected !== undefined) {
            this.select(selected);
        }
    };
    SelectBoxList.prototype.select = function (index$$1) {
        if (index$$1 >= 0 && index$$1 < this.options.length) {
            this.selected = index$$1;
        }
        else if (index$$1 > this.options.length - 1) {
            // Adjust index to end of list
            // This could make client out of sync with the select
            this.select(this.options.length - 1);
        }
        else if (this.selected < 0) {
            this.selected = 0;
        }
        this.selectElement.selectedIndex = this.selected;
        this.selectElement.title = this.options[this.selected];
    };
    SelectBoxList.prototype.focus = function () {
        if (this.selectElement) {
            this.selectElement.focus();
        }
    };
    SelectBoxList.prototype.blur = function () {
        if (this.selectElement) {
            this.selectElement.blur();
        }
    };
    SelectBoxList.prototype.render = function (container) {
        addClass(container, 'select-container');
        container.appendChild(this.selectElement);
        this.setOptions(this.options, this.selected);
        this.applyStyles();
    };
    SelectBoxList.prototype.style = function (styles) {
        var content = [];
        this.styles = styles;
        // Style non-native select mode
        if (this.styles.listFocusBackground) {
            content.push(".monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row.focused { background-color: " + this.styles.listFocusBackground + " !important; }");
        }
        if (this.styles.listFocusForeground) {
            content.push(".monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row.focused:not(:hover) { color: " + this.styles.listFocusForeground + " !important; }");
        }
        // Hover foreground - ignore for disabled options
        if (this.styles.listHoverForeground) {
            content.push(".monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row:hover { color: " + this.styles.listHoverForeground + " !important; }");
            content.push(".monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row.option-disabled:hover { background-color: " + this.styles.listActiveSelectionForeground + " !important; }");
        }
        // Hover background - ignore for disabled options
        if (this.styles.listHoverBackground) {
            content.push(".monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row:not(.option-disabled):not(.focused):hover { background-color: " + this.styles.listHoverBackground + " !important; }");
            content.push(".monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row.option-disabled:hover { background-color: " + this.styles.selectBackground + " !important; }");
        }
        // Match quickOpen outline styles - ignore for disabled options
        if (this.styles.listFocusOutline) {
            content.push(".monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row.focused { outline: 1.6px dotted " + this.styles.listFocusOutline + " !important; outline-offset: -1.6px !important; }");
        }
        if (this.styles.listHoverOutline) {
            content.push(".monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row:hover:not(.focused) { outline: 1.6px dashed " + this.styles.listHoverOutline + " !important; outline-offset: -1.6px !important; }");
            content.push(".monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row.option-disabled:hover { outline: none !important; }");
        }
        this.styleElement.innerHTML = content.join('\n');
        this.applyStyles();
    };
    SelectBoxList.prototype.applyStyles = function () {
        // Style parent select
        var background = null;
        if (this.selectElement) {
            background = this.styles.selectBackground ? this.styles.selectBackground.toString() : null;
            var foreground = this.styles.selectForeground ? this.styles.selectForeground.toString() : null;
            var border = this.styles.selectBorder ? this.styles.selectBorder.toString() : null;
            this.selectElement.style.backgroundColor = background;
            this.selectElement.style.color = foreground;
            this.selectElement.style.borderColor = border;
        }
        // Style drop down select list (non-native mode only)
        if (this.selectList) {
            this.selectList.style({});
            var listBackground = this.styles.selectListBackground ? this.styles.selectListBackground.toString() : background;
            this.selectDropDownListContainer.style.backgroundColor = listBackground;
            var optionsBorder = this.styles.focusBorder ? this.styles.focusBorder.toString() : null;
            this.selectDropDownContainer.style.outlineColor = optionsBorder;
            this.selectDropDownContainer.style.outlineOffset = '-1px';
        }
    };
    SelectBoxList.prototype.createOption = function (value, index$$1, disabled) {
        var option = document.createElement('option');
        option.value = value;
        option.text = value;
        option.disabled = disabled;
        return option;
    };
    // Non-native select list handling
    // ContextView dropdown methods
    SelectBoxList.prototype.showSelectDropDown = function () {
        var _this = this;
        if (!this.contextViewProvider || this._isVisible) {
            return;
        }
        this._isVisible = true;
        this.cloneElementFont(this.selectElement, this.selectDropDownContainer);
        this.contextViewProvider.showContextView({
            getAnchor: function () { return _this.selectElement; },
            render: function (container) { return _this.renderSelectDropDown(container); },
            layout: function () { return _this.layoutSelectDropDown(); },
            onHide: function () {
                toggleClass(_this.selectDropDownContainer, 'visible', false);
                toggleClass(_this.selectElement, 'synthetic-focus', false);
            }
        });
        this._currentSelection = this.selected;
    };
    SelectBoxList.prototype.hideSelectDropDown = function (focusSelect) {
        if (!this.contextViewProvider || !this._isVisible) {
            return;
        }
        this._isVisible = false;
        if (focusSelect) {
            this.selectElement.focus();
        }
        this.contextViewProvider.hideContextView();
    };
    SelectBoxList.prototype.renderSelectDropDown = function (container) {
        var _this = this;
        container.appendChild(this.selectDropDownContainer);
        this.layoutSelectDropDown();
        return {
            dispose: function () { return container.removeChild(_this.selectDropDownContainer); } // remove to take out the CSS rules we add
        };
    };
    SelectBoxList.prototype.layoutSelectDropDown = function () {
        // Layout ContextView drop down select list and container
        // Have to manage our vertical overflow, sizing
        // Need to be visible to measure
        toggleClass(this.selectDropDownContainer, 'visible', true);
        var selectWidth = getTotalWidth(this.selectElement);
        var selectPosition = getDomNodePagePosition(this.selectElement);
        // Set container height to max from select bottom to margin (default/minBottomMargin)
        var maxSelectDropDownHeight = (window.innerHeight - selectPosition.top - selectPosition.height - this.selectBoxOptions.minBottomMargin);
        if (maxSelectDropDownHeight < 0) {
            maxSelectDropDownHeight = 0;
        }
        // SetUp list dimensions and layout - account for container padding
        if (this.selectList) {
            this.selectList.layout();
            var listHeight = this.selectList.contentHeight;
            var listContainerHeight = getTotalHeight(this.selectDropDownListContainer);
            var totalVerticalListPadding = listContainerHeight - listHeight;
            // Always show complete list items - never more than Max available vertical height
            if (listContainerHeight > maxSelectDropDownHeight) {
                listHeight = ((Math.floor((maxSelectDropDownHeight - totalVerticalListPadding) / this.getHeight())) * this.getHeight());
            }
            this.selectList.layout(listHeight);
            this.selectList.domFocus();
            // Finally set focus on selected item
            this.selectList.setFocus([this.selected]);
            this.selectList.reveal(this.selectList.getFocus()[0]);
            // Set final container height after adjustments
            this.selectDropDownContainer.style.height = (listHeight + totalVerticalListPadding) + 'px';
            // Determine optimal width - min(longest option), opt(parent select), max(ContextView controlled)
            var selectMinWidth = this.setWidthControlElement(this.widthControlElement);
            var selectOptimalWidth = Math.max(selectMinWidth, Math.round(selectWidth)).toString() + 'px';
            this.selectDropDownContainer.style.minWidth = selectOptimalWidth;
            // Maintain focus outline on parent select as well as list container - tabindex for focus
            this.selectDropDownListContainer.setAttribute('tabindex', '0');
            toggleClass(this.selectElement, 'synthetic-focus', true);
            toggleClass(this.selectDropDownContainer, 'synthetic-focus', true);
        }
    };
    SelectBoxList.prototype.setWidthControlElement = function (container) {
        var elementWidth = 0;
        if (container && !!this.options) {
            var longest = 0;
            for (var index$$1 = 0; index$$1 < this.options.length; index$$1++) {
                if (this.options[index$$1].length > this.options[longest].length) {
                    longest = index$$1;
                }
            }
            container.innerHTML = this.options[longest];
            elementWidth = getTotalWidth(container);
        }
        return elementWidth;
    };
    SelectBoxList.prototype.cloneElementFont = function (source, target) {
        var fontSize = window.getComputedStyle(source, null).getPropertyValue('font-size');
        var fontFamily = window.getComputedStyle(source, null).getPropertyValue('font-family');
        target.style.fontFamily = fontFamily;
        target.style.fontSize = fontSize;
    };
    SelectBoxList.prototype.createSelectList = function (parent) {
        var _this = this;
        // SetUp container for list
        this.selectDropDownListContainer = append(parent, $$2('.select-box-dropdown-list-container'));
        this.listRenderer = new SelectListRenderer();
        this.selectList = new List(this.selectDropDownListContainer, this, [this.listRenderer], {
            useShadows: false,
            selectOnMouseDown: false,
            verticalScrollMode: ScrollbarVisibility.Visible,
            keyboardSupport: false,
            mouseSupport: false
        });
        // SetUp list keyboard controller - control navigation, disabled items, focus
        var onSelectDropDownKeyDown = chain(domEvent(this.selectDropDownListContainer, 'keydown'))
            .filter(function () { return _this.selectList.length > 0; })
            .map(function (e) { return new StandardKeyboardEvent(e); });
        onSelectDropDownKeyDown.filter(function (e) { return e.keyCode === 3 /* Enter */; }).on(function (e) { return _this.onEnter(e); }, this, this.toDispose);
        onSelectDropDownKeyDown.filter(function (e) { return e.keyCode === 9 /* Escape */; }).on(function (e) { return _this.onEscape(e); }, this, this.toDispose);
        onSelectDropDownKeyDown.filter(function (e) { return e.keyCode === 16 /* UpArrow */; }).on(this.onUpArrow, this, this.toDispose);
        onSelectDropDownKeyDown.filter(function (e) { return e.keyCode === 18 /* DownArrow */; }).on(this.onDownArrow, this, this.toDispose);
        onSelectDropDownKeyDown.filter(function (e) { return e.keyCode === 12 /* PageDown */; }).on(this.onPageDown, this, this.toDispose);
        onSelectDropDownKeyDown.filter(function (e) { return e.keyCode === 11 /* PageUp */; }).on(this.onPageUp, this, this.toDispose);
        onSelectDropDownKeyDown.filter(function (e) { return e.keyCode === 14 /* Home */; }).on(this.onHome, this, this.toDispose);
        onSelectDropDownKeyDown.filter(function (e) { return e.keyCode === 13 /* End */; }).on(this.onEnd, this, this.toDispose);
        onSelectDropDownKeyDown.filter(function (e) { return (e.keyCode >= 21 /* KEY_0 */ && e.keyCode <= 56 /* KEY_Z */) || (e.keyCode >= 80 /* US_SEMICOLON */ && e.keyCode <= 108 /* NUMPAD_DIVIDE */); }).on(this.onCharacter, this, this.toDispose);
        // SetUp list mouse controller - control navigation, disabled items, focus
        chain(domEvent(this.selectList.getHTMLElement(), 'mouseup'))
            .filter(function () { return _this.selectList.length > 0; })
            .on(function (e) { return _this.onMouseUp(e); }, this, this.toDispose);
        this.toDispose.push(this.selectList.onDidBlur(function (e) { return _this.onListBlur(); }));
    };
    // List methods
    // List mouse controller - active exit, select option, fire onDidSelect, return focus to parent select
    SelectBoxList.prototype.onMouseUp = function (e) {
        // Check our mouse event is on an option (not scrollbar)
        if (!e.toElement.classList.contains('option-text')) {
            return;
        }
        var listRowElement = e.toElement.parentElement;
        var index$$1 = Number(listRowElement.getAttribute('data-index'));
        var disabled = listRowElement.classList.contains('option-disabled');
        // Ignore mouse selection of disabled options
        if (index$$1 >= 0 && index$$1 < this.options.length && !disabled) {
            this.selected = index$$1;
            this.select(this.selected);
            this.selectList.setFocus([this.selected]);
            this.selectList.reveal(this.selectList.getFocus()[0]);
            this._onDidSelect.fire({
                index: this.selectElement.selectedIndex,
                selected: this.selectElement.title
            });
            // Reset Selection Handler
            this._currentSelection = -1;
            this.hideSelectDropDown(true);
        }
        EventHelper.stop(e);
    };
    // List Exit - passive - hide drop-down, fire onDidSelect
    SelectBoxList.prototype.onListBlur = function () {
        if (this._currentSelection >= 0) {
            this.select(this._currentSelection);
        }
        this._onDidSelect.fire({
            index: this.selectElement.selectedIndex,
            selected: this.selectElement.title
        });
        this.hideSelectDropDown(false);
    };
    // List keyboard controller
    // List exit - active - hide ContextView dropdown, return focus to parent select, fire onDidSelect
    SelectBoxList.prototype.onEscape = function (e) {
        EventHelper.stop(e);
        this.select(this._currentSelection);
        this.hideSelectDropDown(true);
        this._onDidSelect.fire({
            index: this.selectElement.selectedIndex,
            selected: this.selectElement.title
        });
    };
    // List exit - active - hide ContextView dropdown, return focus to parent select, fire onDidSelect
    SelectBoxList.prototype.onEnter = function (e) {
        EventHelper.stop(e);
        // Reset current selection
        this._currentSelection = -1;
        this.hideSelectDropDown(true);
        this._onDidSelect.fire({
            index: this.selectElement.selectedIndex,
            selected: this.selectElement.title
        });
    };
    // List navigation - have to handle a disabled option (jump over)
    SelectBoxList.prototype.onDownArrow = function () {
        if (this.selected < this.options.length - 1) {
            // Skip disabled options
            if ((this.selected + 1) === this.disabledOptionIndex && this.options.length > this.selected + 2) {
                this.selected += 2;
            }
            else {
                this.selected++;
            }
            // Set focus/selection - only fire event when closing drop-down or on blur
            this.select(this.selected);
            this.selectList.setFocus([this.selected]);
            this.selectList.reveal(this.selectList.getFocus()[0]);
        }
    };
    SelectBoxList.prototype.onUpArrow = function () {
        if (this.selected > 0) {
            // Skip disabled options
            if ((this.selected - 1) === this.disabledOptionIndex && this.selected > 1) {
                this.selected -= 2;
            }
            else {
                this.selected--;
            }
            // Set focus/selection - only fire event when closing drop-down or on blur
            this.select(this.selected);
            this.selectList.setFocus([this.selected]);
            this.selectList.reveal(this.selectList.getFocus()[0]);
        }
    };
    SelectBoxList.prototype.onPageUp = function (e) {
        var _this = this;
        EventHelper.stop(e);
        this.selectList.focusPreviousPage();
        // Allow scrolling to settle
        setTimeout(function () {
            _this.selected = _this.selectList.getFocus()[0];
            // Shift selection down if we land on a disabled option
            if (_this.selected === _this.disabledOptionIndex && _this.selected < _this.options.length - 1) {
                _this.selected++;
                _this.selectList.setFocus([_this.selected]);
            }
            _this.selectList.reveal(_this.selected);
            _this.select(_this.selected);
        }, 1);
    };
    SelectBoxList.prototype.onPageDown = function (e) {
        var _this = this;
        EventHelper.stop(e);
        this.selectList.focusNextPage();
        // Allow scrolling to settle
        setTimeout(function () {
            _this.selected = _this.selectList.getFocus()[0];
            // Shift selection up if we land on a disabled option
            if (_this.selected === _this.disabledOptionIndex && _this.selected > 0) {
                _this.selected--;
                _this.selectList.setFocus([_this.selected]);
            }
            _this.selectList.reveal(_this.selected);
            _this.select(_this.selected);
        }, 1);
    };
    SelectBoxList.prototype.onHome = function (e) {
        EventHelper.stop(e);
        if (this.options.length < 2) {
            return;
        }
        this.selected = 0;
        if (this.selected === this.disabledOptionIndex && this.selected > 1) {
            this.selected++;
        }
        this.selectList.setFocus([this.selected]);
        this.selectList.reveal(this.selected);
        this.select(this.selected);
    };
    SelectBoxList.prototype.onEnd = function (e) {
        EventHelper.stop(e);
        if (this.options.length < 2) {
            return;
        }
        this.selected = this.options.length - 1;
        if (this.selected === this.disabledOptionIndex && this.selected > 1) {
            this.selected--;
        }
        this.selectList.setFocus([this.selected]);
        this.selectList.reveal(this.selected);
        this.select(this.selected);
    };
    // Mimic option first character navigation of native select
    SelectBoxList.prototype.onCharacter = function (e) {
        var ch = KeyCodeUtils.toString(e.keyCode);
        var optionIndex = -1;
        for (var i = 0; i < this.options.length - 1; i++) {
            optionIndex = (i + this.selected + 1) % this.options.length;
            if (this.options[optionIndex].charAt(0).toUpperCase() === ch) {
                this.select(optionIndex);
                this.selectList.setFocus([optionIndex]);
                this.selectList.reveal(this.selectList.getFocus()[0]);
                EventHelper.stop(e);
                break;
            }
        }
    };
    SelectBoxList.prototype.dispose = function () {
        this.hideSelectDropDown(false);
        this.toDispose = dispose(this.toDispose);
    };
    SelectBoxList.DEFAULT_DROPDOWN_MINIMUM_BOTTOM_MARGIN = 32;
    return SelectBoxList;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$18 = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var defaultStyles$1 = {
    selectBackground: Color.fromHex('#3C3C3C'),
    selectForeground: Color.fromHex('#F0F0F0'),
    selectBorder: Color.fromHex('#3C3C3C')
};
var SelectBox = /** @class */ (function (_super) {
    __extends$18(SelectBox, _super);
    function SelectBox(options, selected, contextViewProvider, styles, selectBoxOptions) {
        if (styles === void 0) { styles = deepClone(defaultStyles$1); }
        var _this = _super.call(this) || this;
        _this.toDispose = [];
        mixin(_this.styles, defaultStyles$1, false);
        // Instantiate select implementation based on platform
        if (isMacintosh) {
            _this.selectBoxDelegate = new SelectBoxNative(options, selected, styles);
        }
        else {
            _this.selectBoxDelegate = new SelectBoxList(options, selected, contextViewProvider, styles, selectBoxOptions);
        }
        _this.toDispose.push(_this.selectBoxDelegate);
        return _this;
    }
    Object.defineProperty(SelectBox.prototype, "onDidSelect", {
        // Public SelectBox Methods - routed through delegate interface
        get: function () {
            return this.selectBoxDelegate.onDidSelect;
        },
        enumerable: true,
        configurable: true
    });
    SelectBox.prototype.setOptions = function (options, selected, disabled) {
        this.selectBoxDelegate.setOptions(options, selected, disabled);
    };
    SelectBox.prototype.select = function (index) {
        this.selectBoxDelegate.select(index);
    };
    SelectBox.prototype.focus = function () {
        this.selectBoxDelegate.focus();
    };
    SelectBox.prototype.blur = function () {
        this.selectBoxDelegate.blur();
    };
    // Public Widget Methods - routed through delegate interface
    SelectBox.prototype.render = function (container) {
        this.selectBoxDelegate.render(container);
    };
    SelectBox.prototype.style = function (styles) {
        this.selectBoxDelegate.style(styles);
    };
    SelectBox.prototype.applyStyles = function () {
        this.selectBoxDelegate.applyStyles();
    };
    SelectBox.prototype.dispose = function () {
        this.toDispose = dispose(this.toDispose);
        _super.prototype.dispose.call(this);
    };
    return SelectBox;
}(Widget$1));

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$19 = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var BaseActionItem = /** @class */ (function () {
    function BaseActionItem(context, action, options) {
        var _this = this;
        this.options = options;
        this._callOnDispose = [];
        this._context = context || this;
        this._action = action;
        if (action instanceof Action) {
            this._callOnDispose.push(action.onDidChange(function (event) {
                if (!_this.builder) {
                    // we have not been rendered yet, so there
                    // is no point in updating the UI
                    return;
                }
                _this._handleActionChangeEvent(event);
            }));
        }
    }
    BaseActionItem.prototype._handleActionChangeEvent = function (event) {
        if (event.enabled !== void 0) {
            this._updateEnabled();
        }
        if (event.checked !== void 0) {
            this._updateChecked();
        }
        if (event.class !== void 0) {
            this._updateClass();
        }
        if (event.label !== void 0) {
            this._updateLabel();
            this._updateTooltip();
        }
        if (event.tooltip !== void 0) {
            this._updateTooltip();
        }
    };
    Object.defineProperty(BaseActionItem.prototype, "callOnDispose", {
        get: function () {
            return this._callOnDispose;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BaseActionItem.prototype, "actionRunner", {
        get: function () {
            return this._actionRunner;
        },
        set: function (actionRunner) {
            this._actionRunner = actionRunner;
        },
        enumerable: true,
        configurable: true
    });
    BaseActionItem.prototype.getAction = function () {
        return this._action;
    };
    BaseActionItem.prototype.isEnabled = function () {
        return this._action.enabled;
    };
    BaseActionItem.prototype.setActionContext = function (newContext) {
        this._context = newContext;
    };
    BaseActionItem.prototype.render = function (container) {
        var _this = this;
        this.builder = $$1(container);
        Gesture.addTarget(container);
        var enableDragging = this.options && this.options.draggable;
        if (enableDragging) {
            container.draggable = true;
        }
        this.builder.on(EventType$1.Tap, function (e) { return _this.onClick(e); });
        this.builder.on(EventType.MOUSE_DOWN, function (e) {
            if (!enableDragging) {
                EventHelper.stop(e, true); // do not run when dragging is on because that would disable it
            }
            var mouseEvent = e;
            if (_this._action.enabled && mouseEvent.button === 0) {
                _this.builder.addClass('active');
            }
        });
        this.builder.on(EventType.CLICK, function (e) {
            EventHelper.stop(e, true);
            // See https://developer.mozilla.org/en-US/Add-ons/WebExtensions/Interact_with_the_clipboard
            // > Writing to the clipboard
            // > You can use the "cut" and "copy" commands without any special
            // permission if you are using them in a short-lived event handler
            // for a user action (for example, a click handler).
            // => to get the Copy and Paste context menu actions working on Firefox,
            // there should be no timeout here
            if (_this.options && _this.options.isMenu) {
                _this.onClick(e);
            }
            else {
                setImmediate(function () { return _this.onClick(e); });
            }
        });
        this.builder.on([EventType.MOUSE_UP, EventType.MOUSE_OUT], function (e) {
            EventHelper.stop(e);
            _this.builder.removeClass('active');
        });
    };
    BaseActionItem.prototype.onClick = function (event) {
        EventHelper.stop(event, true);
        var context;
        if (isUndefinedOrNull(this._context)) {
            context = event;
        }
        else {
            context = this._context;
            context.event = event;
        }
        this._actionRunner.run(this._action, context);
    };
    BaseActionItem.prototype.focus = function () {
        if (this.builder) {
            this.builder.domFocus();
        }
    };
    BaseActionItem.prototype.blur = function () {
        if (this.builder) {
            this.builder.domBlur();
        }
    };
    BaseActionItem.prototype._updateEnabled = function () {
        // implement in subclass
    };
    BaseActionItem.prototype._updateLabel = function () {
        // implement in subclass
    };
    BaseActionItem.prototype._updateTooltip = function () {
        // implement in subclass
    };
    BaseActionItem.prototype._updateClass = function () {
        // implement in subclass
    };
    BaseActionItem.prototype._updateChecked = function () {
        // implement in subclass
    };
    BaseActionItem.prototype.dispose = function () {
        if (this.builder) {
            this.builder.destroy();
            this.builder = null;
        }
        this._callOnDispose = dispose(this._callOnDispose);
    };
    return BaseActionItem;
}());
var Separator = /** @class */ (function (_super) {
    __extends$19(Separator, _super);
    function Separator(label, order) {
        var _this = _super.call(this, Separator.ID, label, label ? 'separator text' : 'separator') || this;
        _this.checked = false;
        _this.radio = false;
        _this.enabled = false;
        _this.order = order;
        return _this;
    }
    Separator.ID = 'vs.actions.separator';
    return Separator;
}(Action));
var ActionItem = /** @class */ (function (_super) {
    __extends$19(ActionItem, _super);
    function ActionItem(context, action, options) {
        if (options === void 0) { options = {}; }
        var _this = _super.call(this, context, action, options) || this;
        _this.options = options;
        _this.options.icon = options.icon !== undefined ? options.icon : false;
        _this.options.label = options.label !== undefined ? options.label : true;
        _this.cssClass = '';
        return _this;
    }
    ActionItem.prototype.render = function (container) {
        _super.prototype.render.call(this, container);
        this.$e = $$1('a.action-label').appendTo(this.builder);
        if (this._action.id === Separator.ID) {
            // A separator is a presentation item
            this.$e.attr({ role: 'presentation' });
        }
        else {
            if (this.options.isMenu) {
                this.$e.attr({ role: 'menuitem' });
            }
            else {
                this.$e.attr({ role: 'button' });
            }
        }
        if (this.options.label && this.options.keybinding) {
            $$1('span.keybinding').text(this.options.keybinding).appendTo(this.builder);
        }
        this._updateClass();
        this._updateLabel();
        this._updateTooltip();
        this._updateEnabled();
        this._updateChecked();
    };
    ActionItem.prototype.focus = function () {
        _super.prototype.focus.call(this);
        this.$e.domFocus();
    };
    ActionItem.prototype._updateLabel = function () {
        if (this.options.label) {
            this.$e.text(this.getAction().label);
        }
    };
    ActionItem.prototype._updateTooltip = function () {
        var title = null;
        if (this.getAction().tooltip) {
            title = this.getAction().tooltip;
        }
        else if (!this.options.label && this.getAction().label && this.options.icon) {
            title = this.getAction().label;
            if (this.options.keybinding) {
                title = localize({ key: 'titleLabel', comment: ['action title', 'action keybinding'] }, "{0} ({1})", title, this.options.keybinding);
            }
        }
        if (title) {
            this.$e.attr({ title: title });
        }
    };
    ActionItem.prototype._updateClass = function () {
        if (this.cssClass) {
            this.$e.removeClass(this.cssClass);
        }
        if (this.options.icon) {
            this.cssClass = this.getAction().class;
            this.$e.addClass('icon');
            if (this.cssClass) {
                this.$e.addClass(this.cssClass);
            }
            this._updateEnabled();
        }
        else {
            this.$e.removeClass('icon');
        }
    };
    ActionItem.prototype._updateEnabled = function () {
        if (this.getAction().enabled) {
            this.builder.removeClass('disabled');
            this.$e.removeClass('disabled');
            this.$e.attr({ tabindex: 0 });
        }
        else {
            this.builder.addClass('disabled');
            this.$e.addClass('disabled');
            removeTabIndexAndUpdateFocus(this.$e.getHTMLElement());
        }
    };
    ActionItem.prototype._updateChecked = function () {
        if (this.getAction().checked) {
            this.$e.addClass('checked');
        }
        else {
            this.$e.removeClass('checked');
        }
    };
    return ActionItem;
}(BaseActionItem));
var ActionsOrientation;
(function (ActionsOrientation) {
    ActionsOrientation[ActionsOrientation["HORIZONTAL"] = 0] = "HORIZONTAL";
    ActionsOrientation[ActionsOrientation["HORIZONTAL_REVERSE"] = 1] = "HORIZONTAL_REVERSE";
    ActionsOrientation[ActionsOrientation["VERTICAL"] = 2] = "VERTICAL";
    ActionsOrientation[ActionsOrientation["VERTICAL_REVERSE"] = 3] = "VERTICAL_REVERSE";
})(ActionsOrientation || (ActionsOrientation = {}));
var defaultOptions = {
    orientation: ActionsOrientation.HORIZONTAL,
    context: null
};
var ActionBar = /** @class */ (function () {
    function ActionBar(container, options) {
        if (options === void 0) { options = defaultOptions; }
        var _this = this;
        this._onDidBlur = new Emitter();
        this._onDidCancel = new Emitter();
        this._onDidRun = new Emitter();
        this._onDidBeforeRun = new Emitter();
        this.options = options;
        this._context = options.context;
        this.toDispose = [];
        this._actionRunner = this.options.actionRunner;
        if (!this._actionRunner) {
            this._actionRunner = new ActionRunner();
            this.toDispose.push(this._actionRunner);
        }
        this.toDispose.push(this._actionRunner.onDidRun(function (e) { return _this._onDidRun.fire(e); }));
        this.toDispose.push(this._actionRunner.onDidBeforeRun(function (e) { return _this._onDidBeforeRun.fire(e); }));
        this.items = [];
        this.focusedItem = undefined;
        this.domNode = document.createElement('div');
        this.domNode.className = 'monaco-action-bar';
        if (options.animated !== false) {
            addClass(this.domNode, 'animated');
        }
        var previousKey;
        var nextKey;
        switch (this.options.orientation) {
            case ActionsOrientation.HORIZONTAL:
                previousKey = 15 /* LeftArrow */;
                nextKey = 17 /* RightArrow */;
                break;
            case ActionsOrientation.HORIZONTAL_REVERSE:
                previousKey = 17 /* RightArrow */;
                nextKey = 15 /* LeftArrow */;
                this.domNode.className += ' reverse';
                break;
            case ActionsOrientation.VERTICAL:
                previousKey = 16 /* UpArrow */;
                nextKey = 18 /* DownArrow */;
                this.domNode.className += ' vertical';
                break;
            case ActionsOrientation.VERTICAL_REVERSE:
                previousKey = 18 /* DownArrow */;
                nextKey = 16 /* UpArrow */;
                this.domNode.className += ' vertical reverse';
                break;
        }
        $$1(this.domNode).on(EventType.KEY_DOWN, function (e) {
            var event = new StandardKeyboardEvent(e);
            var eventHandled = true;
            if (event.equals(previousKey)) {
                _this.focusPrevious();
            }
            else if (event.equals(nextKey)) {
                _this.focusNext();
            }
            else if (event.equals(9 /* Escape */)) {
                _this.cancel();
            }
            else if (event.equals(3 /* Enter */) || event.equals(10 /* Space */)) ;
            else {
                eventHandled = false;
            }
            if (eventHandled) {
                event.preventDefault();
                event.stopPropagation();
            }
        });
        $$1(this.domNode).on(EventType.KEY_UP, function (e) {
            var event = new StandardKeyboardEvent(e);
            // Run action on Enter/Space
            if (event.equals(3 /* Enter */) || event.equals(10 /* Space */)) {
                _this.doTrigger(event);
                event.preventDefault();
                event.stopPropagation();
            }
            // Recompute focused item
            else if (event.equals(2 /* Tab */) || event.equals(1024 /* Shift */ | 2 /* Tab */)) {
                _this.updateFocusedItem();
            }
        });
        this.focusTracker = trackFocus(this.domNode);
        this.toDispose.push(this.focusTracker.onDidBlur(function () {
            if (document.activeElement === _this.domNode || !isAncestor(document.activeElement, _this.domNode)) {
                _this._onDidBlur.fire();
                _this.focusedItem = undefined;
            }
        }));
        this.toDispose.push(this.focusTracker.onDidFocus(function () { return _this.updateFocusedItem(); }));
        this.actionsList = document.createElement('ul');
        this.actionsList.className = 'actions-container';
        if (this.options.isMenu) {
            this.actionsList.setAttribute('role', 'menubar');
        }
        else {
            this.actionsList.setAttribute('role', 'toolbar');
        }
        if (this.options.ariaLabel) {
            this.actionsList.setAttribute('aria-label', this.options.ariaLabel);
        }
        this.domNode.appendChild(this.actionsList);
        container.appendChild(this.domNode);
    }
    Object.defineProperty(ActionBar.prototype, "onDidBlur", {
        get: function () {
            return this._onDidBlur.event;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ActionBar.prototype, "onDidCancel", {
        get: function () {
            return this._onDidCancel.event;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ActionBar.prototype, "onDidRun", {
        get: function () {
            return this._onDidRun.event;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ActionBar.prototype, "onDidBeforeRun", {
        get: function () {
            return this._onDidBeforeRun.event;
        },
        enumerable: true,
        configurable: true
    });
    ActionBar.prototype.setAriaLabel = function (label) {
        if (label) {
            this.actionsList.setAttribute('aria-label', label);
        }
        else {
            this.actionsList.removeAttribute('aria-label');
        }
    };
    ActionBar.prototype.updateFocusedItem = function () {
        for (var i = 0; i < this.actionsList.children.length; i++) {
            var elem = this.actionsList.children[i];
            if (isAncestor(document.activeElement, elem)) {
                this.focusedItem = i;
                break;
            }
        }
    };
    Object.defineProperty(ActionBar.prototype, "context", {
        get: function () {
            return this._context;
        },
        set: function (context) {
            this._context = context;
            this.items.forEach(function (i) { return i.setActionContext(context); });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ActionBar.prototype, "actionRunner", {
        get: function () {
            return this._actionRunner;
        },
        set: function (actionRunner) {
            if (actionRunner) {
                this._actionRunner = actionRunner;
                this.items.forEach(function (item) { return item.actionRunner = actionRunner; });
            }
        },
        enumerable: true,
        configurable: true
    });
    ActionBar.prototype.getContainer = function () {
        return this.domNode;
    };
    ActionBar.prototype.push = function (arg, options) {
        var _this = this;
        if (options === void 0) { options = {}; }
        var actions = !Array.isArray(arg) ? [arg] : arg;
        var index = isNumber(options.index) ? options.index : null;
        actions.forEach(function (action) {
            var actionItemElement = document.createElement('li');
            actionItemElement.className = 'action-item';
            actionItemElement.setAttribute('role', 'presentation');
            // Prevent native context menu on actions
            $$1(actionItemElement).on(EventType.CONTEXT_MENU, function (e) {
                e.preventDefault();
                e.stopPropagation();
            });
            var item = null;
            if (_this.options.actionItemProvider) {
                item = _this.options.actionItemProvider(action);
            }
            if (!item) {
                item = new ActionItem(_this.context, action, options);
            }
            item.actionRunner = _this._actionRunner;
            item.setActionContext(_this.context);
            item.render(actionItemElement);
            if (index === null || index < 0 || index >= _this.actionsList.children.length) {
                _this.actionsList.appendChild(actionItemElement);
            }
            else {
                _this.actionsList.insertBefore(actionItemElement, _this.actionsList.children[index++]);
            }
            _this.items.push(item);
        });
    };
    ActionBar.prototype.getWidth = function (index) {
        if (index >= 0 && index < this.actionsList.children.length) {
            return this.actionsList.children.item(index).clientWidth;
        }
        return 0;
    };
    ActionBar.prototype.getHeight = function (index) {
        if (index >= 0 && index < this.actionsList.children.length) {
            return this.actionsList.children.item(index).clientHeight;
        }
        return 0;
    };
    ActionBar.prototype.pull = function (index) {
        if (index >= 0 && index < this.items.length) {
            this.items.splice(index, 1);
            this.actionsList.removeChild(this.actionsList.childNodes[index]);
        }
    };
    ActionBar.prototype.clear = function () {
        this.items = dispose(this.items);
        $$1(this.actionsList).empty();
    };
    ActionBar.prototype.length = function () {
        return this.items.length;
    };
    ActionBar.prototype.isEmpty = function () {
        return this.items.length === 0;
    };
    ActionBar.prototype.focus = function (selectFirst) {
        if (selectFirst && typeof this.focusedItem === 'undefined') {
            this.focusedItem = 0;
        }
        this.updateFocus();
    };
    ActionBar.prototype.focusNext = function () {
        if (typeof this.focusedItem === 'undefined') {
            this.focusedItem = this.items.length - 1;
        }
        var startIndex = this.focusedItem;
        var item;
        do {
            this.focusedItem = (this.focusedItem + 1) % this.items.length;
            item = this.items[this.focusedItem];
        } while (this.focusedItem !== startIndex && !item.isEnabled());
        if (this.focusedItem === startIndex && !item.isEnabled()) {
            this.focusedItem = undefined;
        }
        this.updateFocus();
    };
    ActionBar.prototype.focusPrevious = function () {
        if (typeof this.focusedItem === 'undefined') {
            this.focusedItem = 0;
        }
        var startIndex = this.focusedItem;
        var item;
        do {
            this.focusedItem = this.focusedItem - 1;
            if (this.focusedItem < 0) {
                this.focusedItem = this.items.length - 1;
            }
            item = this.items[this.focusedItem];
        } while (this.focusedItem !== startIndex && !item.isEnabled());
        if (this.focusedItem === startIndex && !item.isEnabled()) {
            this.focusedItem = undefined;
        }
        this.updateFocus(true);
    };
    ActionBar.prototype.updateFocus = function (fromRight) {
        if (typeof this.focusedItem === 'undefined') {
            this.domNode.focus();
            return;
        }
        for (var i = 0; i < this.items.length; i++) {
            var item = this.items[i];
            var actionItem = item;
            if (i === this.focusedItem) {
                if (isFunction(actionItem.focus)) {
                    actionItem.focus(fromRight);
                }
            }
            else {
                if (isFunction(actionItem.blur)) {
                    actionItem.blur();
                }
            }
        }
    };
    ActionBar.prototype.doTrigger = function (event) {
        if (typeof this.focusedItem === 'undefined') {
            return; //nothing to focus
        }
        // trigger action
        var actionItem = this.items[this.focusedItem];
        if (actionItem instanceof BaseActionItem) {
            var context = (actionItem._context === null || actionItem._context === undefined) ? event : actionItem._context;
            this.run(actionItem._action, context).done();
        }
    };
    ActionBar.prototype.cancel = function () {
        if (document.activeElement instanceof HTMLElement) {
            document.activeElement.blur(); // remove focus from focused action
        }
        this._onDidCancel.fire();
    };
    ActionBar.prototype.run = function (action, context) {
        return this._actionRunner.run(action, context);
    };
    ActionBar.prototype.dispose = function () {
        if (this.items !== null) {
            dispose(this.items);
        }
        this.items = null;
        if (this.focusTracker) {
            this.focusTracker.dispose();
            this.focusTracker = null;
        }
        this.toDispose = dispose(this.toDispose);
        $$1(this.getContainer()).destroy();
    };
    return ActionBar;
}());
var SelectActionItem = /** @class */ (function (_super) {
    __extends$19(SelectActionItem, _super);
    function SelectActionItem(ctx, action, options, selected, contextViewProvider) {
        var _this = _super.call(this, ctx, action) || this;
        _this.selectBox = new SelectBox(options, selected, contextViewProvider);
        _this.toDispose = [];
        _this.toDispose.push(_this.selectBox);
        _this.registerListeners();
        return _this;
    }
    SelectActionItem.prototype.setOptions = function (options, selected, disabled) {
        this.selectBox.setOptions(options, selected, disabled);
    };
    SelectActionItem.prototype.select = function (index) {
        this.selectBox.select(index);
    };
    SelectActionItem.prototype.registerListeners = function () {
        var _this = this;
        this.toDispose.push(this.selectBox.onDidSelect(function (e) {
            _this.actionRunner.run(_this._action, _this.getActionContext(e.selected)).done();
        }));
    };
    SelectActionItem.prototype.getActionContext = function (option) {
        return option;
    };
    SelectActionItem.prototype.focus = function () {
        if (this.selectBox) {
            this.selectBox.focus();
        }
    };
    SelectActionItem.prototype.blur = function () {
        if (this.selectBox) {
            this.selectBox.blur();
        }
    };
    SelectActionItem.prototype.render = function (container) {
        this.selectBox.render(container);
    };
    SelectActionItem.prototype.dispose = function () {
        this.toDispose = dispose(this.toDispose);
        _super.prototype.dispose.call(this);
    };
    return SelectActionItem;
}(BaseActionItem));

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$1a = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var DIFF_LINES_PADDING = 3;
var DiffEntry = /** @class */ (function () {
    function DiffEntry(originalLineStart, originalLineEnd, modifiedLineStart, modifiedLineEnd) {
        this.originalLineStart = originalLineStart;
        this.originalLineEnd = originalLineEnd;
        this.modifiedLineStart = modifiedLineStart;
        this.modifiedLineEnd = modifiedLineEnd;
    }
    DiffEntry.prototype.getType = function () {
        if (this.originalLineStart === 0) {
            return 1 /* Insert */;
        }
        if (this.modifiedLineStart === 0) {
            return 2 /* Delete */;
        }
        return 0 /* Equal */;
    };
    return DiffEntry;
}());
var Diff = /** @class */ (function () {
    function Diff(entries) {
        this.entries = entries;
    }
    return Diff;
}());
var DiffReview = /** @class */ (function (_super) {
    __extends$1a(DiffReview, _super);
    function DiffReview(diffEditor) {
        var _this = _super.call(this) || this;
        _this._width = 0;
        _this._diffEditor = diffEditor;
        _this._isVisible = false;
        _this.shadow = createFastDomNode(document.createElement('div'));
        _this.shadow.setClassName('diff-review-shadow');
        _this.actionBarContainer = createFastDomNode(document.createElement('div'));
        _this.actionBarContainer.setClassName('diff-review-actions');
        _this._actionBar = _this._register(new ActionBar(_this.actionBarContainer.domNode));
        _this._actionBar.push(new Action('diffreview.close', localize('label.close', "Close"), 'close-diff-review', true, function () {
            _this.hide();
            return null;
        }), { label: false, icon: true });
        _this.domNode = createFastDomNode(document.createElement('div'));
        _this.domNode.setClassName('diff-review monaco-editor-background');
        _this._content = createFastDomNode(document.createElement('div'));
        _this._content.setClassName('diff-review-content');
        _this.scrollbar = _this._register(new DomScrollableElement(_this._content.domNode, {}));
        _this.domNode.domNode.appendChild(_this.scrollbar.getDomNode());
        _this._register(diffEditor.onDidUpdateDiff(function () {
            if (!_this._isVisible) {
                return;
            }
            _this._diffs = _this._compute();
            _this._render();
        }));
        _this._register(diffEditor.getModifiedEditor().onDidChangeCursorPosition(function () {
            if (!_this._isVisible) {
                return;
            }
            _this._render();
        }));
        _this._register(diffEditor.getOriginalEditor().onDidFocusEditor(function () {
            if (_this._isVisible) {
                _this.hide();
            }
        }));
        _this._register(diffEditor.getModifiedEditor().onDidFocusEditor(function () {
            if (_this._isVisible) {
                _this.hide();
            }
        }));
        _this._register(addStandardDisposableListener(_this.domNode.domNode, 'click', function (e) {
            e.preventDefault();
            var row = findParentWithClass(e.target, 'diff-review-row');
            if (row) {
                _this._goToRow(row);
            }
        }));
        _this._register(addStandardDisposableListener(_this.domNode.domNode, 'keydown', function (e) {
            if (e.equals(18 /* DownArrow */)
                || e.equals(2048 /* CtrlCmd */ | 18 /* DownArrow */)
                || e.equals(512 /* Alt */ | 18 /* DownArrow */)) {
                e.preventDefault();
                _this._goToRow(_this._getNextRow());
            }
            if (e.equals(16 /* UpArrow */)
                || e.equals(2048 /* CtrlCmd */ | 16 /* UpArrow */)
                || e.equals(512 /* Alt */ | 16 /* UpArrow */)) {
                e.preventDefault();
                _this._goToRow(_this._getPrevRow());
            }
            if (e.equals(9 /* Escape */)
                || e.equals(2048 /* CtrlCmd */ | 9 /* Escape */)
                || e.equals(512 /* Alt */ | 9 /* Escape */)
                || e.equals(1024 /* Shift */ | 9 /* Escape */)) {
                e.preventDefault();
                _this.hide();
            }
            if (e.equals(10 /* Space */)
                || e.equals(3 /* Enter */)) {
                e.preventDefault();
                _this.accept();
            }
        }));
        _this._diffs = [];
        _this._currentDiff = null;
        return _this;
    }
    DiffReview.prototype.prev = function () {
        var index = 0;
        if (!this._isVisible) {
            this._diffs = this._compute();
        }
        if (this._isVisible) {
            var currentIndex = -1;
            for (var i = 0, len = this._diffs.length; i < len; i++) {
                if (this._diffs[i] === this._currentDiff) {
                    currentIndex = i;
                    break;
                }
            }
            index = (this._diffs.length + currentIndex - 1);
        }
        else {
            index = this._findDiffIndex(this._diffEditor.getPosition());
        }
        if (this._diffs.length === 0) {
            // Nothing to do
            return;
        }
        index = index % this._diffs.length;
        this._diffEditor.setPosition(new Position(this._diffs[index].entries[0].modifiedLineStart, 1));
        this._isVisible = true;
        this._diffEditor.doLayout();
        this._render();
        this._goToRow(this._getNextRow());
    };
    DiffReview.prototype.next = function () {
        var index = 0;
        if (!this._isVisible) {
            this._diffs = this._compute();
        }
        if (this._isVisible) {
            var currentIndex = -1;
            for (var i = 0, len = this._diffs.length; i < len; i++) {
                if (this._diffs[i] === this._currentDiff) {
                    currentIndex = i;
                    break;
                }
            }
            index = (currentIndex + 1);
        }
        else {
            index = this._findDiffIndex(this._diffEditor.getPosition());
        }
        if (this._diffs.length === 0) {
            // Nothing to do
            return;
        }
        index = index % this._diffs.length;
        this._diffEditor.setPosition(new Position(this._diffs[index].entries[0].modifiedLineStart, 1));
        this._isVisible = true;
        this._diffEditor.doLayout();
        this._render();
        this._goToRow(this._getNextRow());
    };
    DiffReview.prototype.accept = function () {
        var jumpToLineNumber = -1;
        var current = this._getCurrentFocusedRow();
        if (current) {
            var lineNumber = parseInt(current.getAttribute('data-line'), 10);
            if (!isNaN(lineNumber)) {
                jumpToLineNumber = lineNumber;
            }
        }
        this.hide();
        if (jumpToLineNumber !== -1) {
            this._diffEditor.setPosition(new Position(jumpToLineNumber, 1));
            this._diffEditor.revealPosition(new Position(jumpToLineNumber, 1), 1 /* Immediate */);
        }
    };
    DiffReview.prototype.hide = function () {
        this._isVisible = false;
        this._diffEditor.focus();
        this._diffEditor.doLayout();
        this._render();
    };
    DiffReview.prototype._getPrevRow = function () {
        var current = this._getCurrentFocusedRow();
        if (!current) {
            return this._getFirstRow();
        }
        if (current.previousElementSibling) {
            return current.previousElementSibling;
        }
        return current;
    };
    DiffReview.prototype._getNextRow = function () {
        var current = this._getCurrentFocusedRow();
        if (!current) {
            return this._getFirstRow();
        }
        if (current.nextElementSibling) {
            return current.nextElementSibling;
        }
        return current;
    };
    DiffReview.prototype._getFirstRow = function () {
        return this.domNode.domNode.querySelector('.diff-review-row');
    };
    DiffReview.prototype._getCurrentFocusedRow = function () {
        var result = document.activeElement;
        if (result && /diff-review-row/.test(result.className)) {
            return result;
        }
        return null;
    };
    DiffReview.prototype._goToRow = function (row) {
        var prev = this._getCurrentFocusedRow();
        row.tabIndex = 0;
        row.focus();
        if (prev && prev !== row) {
            prev.tabIndex = -1;
        }
        this.scrollbar.scanDomNode();
    };
    DiffReview.prototype.isVisible = function () {
        return this._isVisible;
    };
    DiffReview.prototype.layout = function (top, width, height) {
        this._width = width;
        this.shadow.setTop(top - 6);
        this.shadow.setWidth(width);
        this.shadow.setHeight(this._isVisible ? 6 : 0);
        this.domNode.setTop(top);
        this.domNode.setWidth(width);
        this.domNode.setHeight(height);
        this._content.setHeight(height);
        this._content.setWidth(width);
        if (this._isVisible) {
            this.actionBarContainer.setAttribute('aria-hidden', 'false');
            this.actionBarContainer.setDisplay('block');
        }
        else {
            this.actionBarContainer.setAttribute('aria-hidden', 'true');
            this.actionBarContainer.setDisplay('none');
        }
    };
    DiffReview.prototype._compute = function () {
        var lineChanges = this._diffEditor.getLineChanges();
        if (!lineChanges || lineChanges.length === 0) {
            return [];
        }
        var originalModel = this._diffEditor.getOriginalEditor().getModel();
        var modifiedModel = this._diffEditor.getModifiedEditor().getModel();
        if (!originalModel || !modifiedModel) {
            return [];
        }
        return DiffReview._mergeAdjacent(lineChanges, originalModel.getLineCount(), modifiedModel.getLineCount());
    };
    DiffReview._mergeAdjacent = function (lineChanges, originalLineCount, modifiedLineCount) {
        if (!lineChanges || lineChanges.length === 0) {
            return [];
        }
        var diffs = [], diffsLength = 0;
        for (var i = 0, len = lineChanges.length; i < len; i++) {
            var lineChange = lineChanges[i];
            var originalStart = lineChange.originalStartLineNumber;
            var originalEnd = lineChange.originalEndLineNumber;
            var modifiedStart = lineChange.modifiedStartLineNumber;
            var modifiedEnd = lineChange.modifiedEndLineNumber;
            var r_1 = [], rLength_1 = 0;
            // Emit before anchors
            {
                var originalEqualAbove = (originalEnd === 0 ? originalStart : originalStart - 1);
                var modifiedEqualAbove = (modifiedEnd === 0 ? modifiedStart : modifiedStart - 1);
                // Make sure we don't step into the previous diff
                var minOriginal = 1;
                var minModified = 1;
                if (i > 0) {
                    var prevLineChange = lineChanges[i - 1];
                    if (prevLineChange.originalEndLineNumber === 0) {
                        minOriginal = prevLineChange.originalStartLineNumber + 1;
                    }
                    else {
                        minOriginal = prevLineChange.originalEndLineNumber + 1;
                    }
                    if (prevLineChange.modifiedEndLineNumber === 0) {
                        minModified = prevLineChange.modifiedStartLineNumber + 1;
                    }
                    else {
                        minModified = prevLineChange.modifiedEndLineNumber + 1;
                    }
                }
                var fromOriginal = originalEqualAbove - DIFF_LINES_PADDING + 1;
                var fromModified = modifiedEqualAbove - DIFF_LINES_PADDING + 1;
                if (fromOriginal < minOriginal) {
                    var delta = minOriginal - fromOriginal;
                    fromOriginal = fromOriginal + delta;
                    fromModified = fromModified + delta;
                }
                if (fromModified < minModified) {
                    var delta = minModified - fromModified;
                    fromOriginal = fromOriginal + delta;
                    fromModified = fromModified + delta;
                }
                r_1[rLength_1++] = new DiffEntry(fromOriginal, originalEqualAbove, fromModified, modifiedEqualAbove);
            }
            // Emit deleted lines
            {
                if (originalEnd !== 0) {
                    r_1[rLength_1++] = new DiffEntry(originalStart, originalEnd, 0, 0);
                }
            }
            // Emit inserted lines
            {
                if (modifiedEnd !== 0) {
                    r_1[rLength_1++] = new DiffEntry(0, 0, modifiedStart, modifiedEnd);
                }
            }
            // Emit after anchors
            {
                var originalEqualBelow = (originalEnd === 0 ? originalStart + 1 : originalEnd + 1);
                var modifiedEqualBelow = (modifiedEnd === 0 ? modifiedStart + 1 : modifiedEnd + 1);
                // Make sure we don't step into the next diff
                var maxOriginal = originalLineCount;
                var maxModified = modifiedLineCount;
                if (i + 1 < len) {
                    var nextLineChange = lineChanges[i + 1];
                    if (nextLineChange.originalEndLineNumber === 0) {
                        maxOriginal = nextLineChange.originalStartLineNumber;
                    }
                    else {
                        maxOriginal = nextLineChange.originalStartLineNumber - 1;
                    }
                    if (nextLineChange.modifiedEndLineNumber === 0) {
                        maxModified = nextLineChange.modifiedStartLineNumber;
                    }
                    else {
                        maxModified = nextLineChange.modifiedStartLineNumber - 1;
                    }
                }
                var toOriginal = originalEqualBelow + DIFF_LINES_PADDING - 1;
                var toModified = modifiedEqualBelow + DIFF_LINES_PADDING - 1;
                if (toOriginal > maxOriginal) {
                    var delta = maxOriginal - toOriginal;
                    toOriginal = toOriginal + delta;
                    toModified = toModified + delta;
                }
                if (toModified > maxModified) {
                    var delta = maxModified - toModified;
                    toOriginal = toOriginal + delta;
                    toModified = toModified + delta;
                }
                r_1[rLength_1++] = new DiffEntry(originalEqualBelow, toOriginal, modifiedEqualBelow, toModified);
            }
            diffs[diffsLength++] = new Diff(r_1);
        }
        // Merge adjacent diffs
        var curr = diffs[0].entries;
        var r = [], rLength = 0;
        for (var i = 1, len = diffs.length; i < len; i++) {
            var thisDiff = diffs[i].entries;
            var currLast = curr[curr.length - 1];
            var thisFirst = thisDiff[0];
            if (currLast.getType() === 0 /* Equal */
                && thisFirst.getType() === 0 /* Equal */
                && thisFirst.originalLineStart <= currLast.originalLineEnd) {
                // We are dealing with equal lines that overlap
                curr[curr.length - 1] = new DiffEntry(currLast.originalLineStart, thisFirst.originalLineEnd, currLast.modifiedLineStart, thisFirst.modifiedLineEnd);
                curr = curr.concat(thisDiff.slice(1));
                continue;
            }
            r[rLength++] = new Diff(curr);
            curr = thisDiff;
        }
        r[rLength++] = new Diff(curr);
        return r;
    };
    DiffReview.prototype._findDiffIndex = function (pos) {
        var lineNumber = pos.lineNumber;
        for (var i = 0, len = this._diffs.length; i < len; i++) {
            var diff = this._diffs[i].entries;
            var lastModifiedLine = diff[diff.length - 1].modifiedLineEnd;
            if (lineNumber <= lastModifiedLine) {
                return i;
            }
        }
        return 0;
    };
    DiffReview.prototype._render = function () {
        var originalOpts = this._diffEditor.getOriginalEditor().getConfiguration();
        var modifiedOpts = this._diffEditor.getModifiedEditor().getConfiguration();
        var originalModel = this._diffEditor.getOriginalEditor().getModel();
        var modifiedModel = this._diffEditor.getModifiedEditor().getModel();
        var originalModelOpts = originalModel.getOptions();
        var modifiedModelOpts = modifiedModel.getOptions();
        if (!this._isVisible || !originalModel || !modifiedModel) {
            clearNode(this._content.domNode);
            this._currentDiff = null;
            this.scrollbar.scanDomNode();
            return;
        }
        var pos = this._diffEditor.getPosition();
        var diffIndex = this._findDiffIndex(pos);
        if (this._diffs[diffIndex] === this._currentDiff) {
            return;
        }
        this._currentDiff = this._diffs[diffIndex];
        var diffs = this._diffs[diffIndex].entries;
        var container = document.createElement('div');
        container.className = 'diff-review-table';
        container.setAttribute('role', 'list');
        Configuration$1.applyFontInfoSlow(container, modifiedOpts.fontInfo);
        var minOriginalLine = 0;
        var maxOriginalLine = 0;
        var minModifiedLine = 0;
        var maxModifiedLine = 0;
        for (var i = 0, len = diffs.length; i < len; i++) {
            var diffEntry = diffs[i];
            var originalLineStart = diffEntry.originalLineStart;
            var originalLineEnd = diffEntry.originalLineEnd;
            var modifiedLineStart = diffEntry.modifiedLineStart;
            var modifiedLineEnd = diffEntry.modifiedLineEnd;
            if (originalLineStart !== 0 && ((minOriginalLine === 0 || originalLineStart < minOriginalLine))) {
                minOriginalLine = originalLineStart;
            }
            if (originalLineEnd !== 0 && ((maxOriginalLine === 0 || originalLineEnd > maxOriginalLine))) {
                maxOriginalLine = originalLineEnd;
            }
            if (modifiedLineStart !== 0 && ((minModifiedLine === 0 || modifiedLineStart < minModifiedLine))) {
                minModifiedLine = modifiedLineStart;
            }
            if (modifiedLineEnd !== 0 && ((maxModifiedLine === 0 || modifiedLineEnd > maxModifiedLine))) {
                maxModifiedLine = modifiedLineEnd;
            }
        }
        var header = document.createElement('div');
        header.className = 'diff-review-row';
        var cell = document.createElement('div');
        cell.className = 'diff-review-cell diff-review-summary';
        var originalChangedLinesCnt = maxOriginalLine - minOriginalLine + 1;
        var modifiedChangedLinesCnt = maxModifiedLine - minModifiedLine + 1;
        cell.appendChild(document.createTextNode(diffIndex + 1 + "/" + this._diffs.length + ": @@ -" + minOriginalLine + "," + originalChangedLinesCnt + " +" + minModifiedLine + "," + modifiedChangedLinesCnt + " @@"));
        header.setAttribute('data-line', String(minModifiedLine));
        var getAriaLines = function (lines) {
            if (lines === 0) {
                return localize('no_lines', "no lines");
            }
            else if (lines === 1) {
                return localize('one_line', "1 line");
            }
            else {
                return localize('more_lines', "{0} lines", lines);
            }
        };
        var originalChangedLinesCntAria = getAriaLines(originalChangedLinesCnt);
        var modifiedChangedLinesCntAria = getAriaLines(modifiedChangedLinesCnt);
        header.setAttribute('aria-label', localize({
            key: 'header',
            comment: [
                'This is the ARIA label for a git diff header.',
                'A git diff header looks like this: @@ -154,12 +159,39 @@.',
                'That encodes that at original line 154 (which is now line 159), 12 lines were removed/changed with 39 lines.',
                'Variables 0 and 1 refer to the diff index out of total number of diffs.',
                'Variables 2 and 4 will be numbers (a line number).',
                'Variables 3 and 5 will be "no lines", "1 line" or "X lines", localized separately.'
            ]
        }, "Difference {0} of {1}: original {2}, {3}, modified {4}, {5}", (diffIndex + 1), this._diffs.length, minOriginalLine, originalChangedLinesCntAria, minModifiedLine, modifiedChangedLinesCntAria));
        header.appendChild(cell);
        // @@ -504,7 +517,7 @@
        header.setAttribute('role', 'listitem');
        container.appendChild(header);
        var modLine = minModifiedLine;
        for (var i = 0, len = diffs.length; i < len; i++) {
            var diffEntry = diffs[i];
            DiffReview._renderSection(container, diffEntry, modLine, this._width, originalOpts, originalModel, originalModelOpts, modifiedOpts, modifiedModel, modifiedModelOpts);
            if (diffEntry.modifiedLineStart !== 0) {
                modLine = diffEntry.modifiedLineEnd;
            }
        }
        clearNode(this._content.domNode);
        this._content.domNode.appendChild(container);
        this.scrollbar.scanDomNode();
    };
    DiffReview._renderSection = function (dest, diffEntry, modLine, width, originalOpts, originalModel, originalModelOpts, modifiedOpts, modifiedModel, modifiedModelOpts) {
        var type = diffEntry.getType();
        var rowClassName = 'diff-review-row';
        var lineNumbersExtraClassName = '';
        var spacerClassName = 'diff-review-spacer';
        switch (type) {
            case 1 /* Insert */:
                rowClassName = 'diff-review-row line-insert';
                lineNumbersExtraClassName = ' char-insert';
                spacerClassName = 'diff-review-spacer insert-sign';
                break;
            case 2 /* Delete */:
                rowClassName = 'diff-review-row line-delete';
                lineNumbersExtraClassName = ' char-delete';
                spacerClassName = 'diff-review-spacer delete-sign';
                break;
        }
        var originalLineStart = diffEntry.originalLineStart;
        var originalLineEnd = diffEntry.originalLineEnd;
        var modifiedLineStart = diffEntry.modifiedLineStart;
        var modifiedLineEnd = diffEntry.modifiedLineEnd;
        var cnt = Math.max(modifiedLineEnd - modifiedLineStart, originalLineEnd - originalLineStart);
        var originalLineNumbersWidth = originalOpts.layoutInfo.glyphMarginWidth + originalOpts.layoutInfo.lineNumbersWidth;
        var modifiedLineNumbersWidth = 10 + modifiedOpts.layoutInfo.glyphMarginWidth + modifiedOpts.layoutInfo.lineNumbersWidth;
        for (var i = 0; i <= cnt; i++) {
            var originalLine = (originalLineStart === 0 ? 0 : originalLineStart + i);
            var modifiedLine = (modifiedLineStart === 0 ? 0 : modifiedLineStart + i);
            var row = document.createElement('div');
            row.style.minWidth = width + 'px';
            row.className = rowClassName;
            row.setAttribute('role', 'listitem');
            if (modifiedLine !== 0) {
                modLine = modifiedLine;
            }
            row.setAttribute('data-line', String(modLine));
            var cell = document.createElement('div');
            cell.className = 'diff-review-cell';
            row.appendChild(cell);
            var originalLineNumber = document.createElement('span');
            originalLineNumber.style.width = (originalLineNumbersWidth + 'px');
            originalLineNumber.style.minWidth = (originalLineNumbersWidth + 'px');
            originalLineNumber.className = 'diff-review-line-number' + lineNumbersExtraClassName;
            if (originalLine !== 0) {
                originalLineNumber.appendChild(document.createTextNode(String(originalLine)));
            }
            else {
                originalLineNumber.innerHTML = '&nbsp;';
            }
            cell.appendChild(originalLineNumber);
            var modifiedLineNumber = document.createElement('span');
            modifiedLineNumber.style.width = (modifiedLineNumbersWidth + 'px');
            modifiedLineNumber.style.minWidth = (modifiedLineNumbersWidth + 'px');
            modifiedLineNumber.style.paddingRight = '10px';
            modifiedLineNumber.className = 'diff-review-line-number' + lineNumbersExtraClassName;
            if (modifiedLine !== 0) {
                modifiedLineNumber.appendChild(document.createTextNode(String(modifiedLine)));
            }
            else {
                modifiedLineNumber.innerHTML = '&nbsp;';
            }
            cell.appendChild(modifiedLineNumber);
            var spacer = document.createElement('span');
            spacer.className = spacerClassName;
            spacer.innerHTML = '&nbsp;&nbsp;';
            cell.appendChild(spacer);
            var lineContent = void 0;
            if (modifiedLine !== 0) {
                cell.insertAdjacentHTML('beforeend', this._renderLine(modifiedModel, modifiedOpts, modifiedModelOpts.tabSize, modifiedLine));
                lineContent = modifiedModel.getLineContent(modifiedLine);
            }
            else {
                cell.insertAdjacentHTML('beforeend', this._renderLine(originalModel, originalOpts, originalModelOpts.tabSize, originalLine));
                lineContent = originalModel.getLineContent(originalLine);
            }
            if (lineContent.length === 0) {
                lineContent = localize('blankLine', "blank");
            }
            var ariaLabel = void 0;
            switch (type) {
                case 0 /* Equal */:
                    ariaLabel = localize('equalLine', "original {0}, modified {1}: {2}", originalLine, modifiedLine, lineContent);
                    break;
                case 1 /* Insert */:
                    ariaLabel = localize('insertLine', "+ modified {0}: {1}", modifiedLine, lineContent);
                    break;
                case 2 /* Delete */:
                    ariaLabel = localize('deleteLine', "- original {0}: {1}", originalLine, lineContent);
                    break;
            }
            row.setAttribute('aria-label', ariaLabel);
            dest.appendChild(row);
        }
    };
    DiffReview._renderLine = function (model, config, tabSize, lineNumber) {
        var lineContent = model.getLineContent(lineNumber);
        var defaultMetadata = ((0 /* None */ << 11 /* FONT_STYLE_OFFSET */)
            | (1 /* DefaultForeground */ << 14 /* FOREGROUND_OFFSET */)
            | (2 /* DefaultBackground */ << 23 /* BACKGROUND_OFFSET */)) >>> 0;
        var tokens = new Uint32Array(2);
        tokens[0] = lineContent.length;
        tokens[1] = defaultMetadata;
        var lineTokens = new LineTokens(tokens, lineContent);
        var isBasicASCII$$1 = ViewLineRenderingData.isBasicASCII(lineContent, model.mightContainNonBasicASCII());
        var containsRTL$$1 = ViewLineRenderingData.containsRTL(lineContent, isBasicASCII$$1, model.mightContainRTL());
        var r = renderViewLine2(new RenderLineInput((config.fontInfo.isMonospace && !config.viewInfo.disableMonospaceOptimizations), lineContent, isBasicASCII$$1, containsRTL$$1, 0, lineTokens, [], tabSize, config.fontInfo.spaceWidth, config.viewInfo.stopRenderingLineAfter, config.viewInfo.renderWhitespace, config.viewInfo.renderControlCharacters, config.viewInfo.fontLigatures));
        return r.html;
    };
    return DiffReview;
}(Disposable));
// theming
registerThemingParticipant(function (theme, collector) {
    var lineNumbers = theme.getColor(editorLineNumbers);
    if (lineNumbers) {
        collector.addRule(".monaco-diff-editor .diff-review-line-number { color: " + lineNumbers + "; }");
    }
    var shadow = theme.getColor(scrollbarShadow);
    if (shadow) {
        collector.addRule(".monaco-diff-editor .diff-review-shadow { box-shadow: " + shadow + " 0 -6px 6px -6px inset; }");
    }
});
var DiffReviewNext = /** @class */ (function (_super) {
    __extends$1a(DiffReviewNext, _super);
    function DiffReviewNext() {
        return _super.call(this, {
            id: 'editor.action.diffReview.next',
            label: localize('editor.action.diffReview.next', "Go to Next Difference"),
            alias: 'Go to Next Difference',
            precondition: ContextKeyExpr.has('isInDiffEditor'),
            kbOpts: {
                kbExpr: null,
                primary: 65 /* F7 */
            }
        }) || this;
    }
    DiffReviewNext.prototype.run = function (accessor, editor) {
        var diffEditor = findFocusedDiffEditor(accessor);
        if (diffEditor) {
            diffEditor.diffReviewNext();
        }
    };
    return DiffReviewNext;
}(EditorAction));
var DiffReviewPrev = /** @class */ (function (_super) {
    __extends$1a(DiffReviewPrev, _super);
    function DiffReviewPrev() {
        return _super.call(this, {
            id: 'editor.action.diffReview.prev',
            label: localize('editor.action.diffReview.prev', "Go to Previous Difference"),
            alias: 'Go to Previous Difference',
            precondition: ContextKeyExpr.has('isInDiffEditor'),
            kbOpts: {
                kbExpr: null,
                primary: 1024 /* Shift */ | 65 /* F7 */
            }
        }) || this;
    }
    DiffReviewPrev.prototype.run = function (accessor, editor) {
        var diffEditor = findFocusedDiffEditor(accessor);
        if (diffEditor) {
            diffEditor.diffReviewPrev();
        }
    };
    return DiffReviewPrev;
}(EditorAction));
function findFocusedDiffEditor(accessor) {
    var codeEditorService = accessor.get(ICodeEditorService);
    var diffEditors = codeEditorService.listDiffEditors();
    for (var i = 0, len = diffEditors.length; i < len; i++) {
        var diffEditor = diffEditors[i];
        if (diffEditor.hasWidgetFocus()) {
            return diffEditor;
        }
    }
    return null;
}
registerEditorAction(DiffReviewNext);
registerEditorAction(DiffReviewPrev);

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var EditorState = /** @class */ (function () {
    function EditorState(editor, flags) {
        this.flags = flags;
        if ((this.flags & 1 /* Value */) !== 0) {
            var model = editor.getModel();
            this.modelVersionId = model ? format('{0}#{1}', model.uri.toString(), model.getVersionId()) : null;
        }
        if ((this.flags & 4 /* Position */) !== 0) {
            this.position = editor.getPosition();
        }
        if ((this.flags & 2 /* Selection */) !== 0) {
            this.selection = editor.getSelection();
        }
        if ((this.flags & 8 /* Scroll */) !== 0) {
            this.scrollLeft = editor.getScrollLeft();
            this.scrollTop = editor.getScrollTop();
        }
    }
    EditorState.prototype._equals = function (other) {
        if (!(other instanceof EditorState)) {
            return false;
        }
        var state = other;
        if (this.modelVersionId !== state.modelVersionId) {
            return false;
        }
        if (this.scrollLeft !== state.scrollLeft || this.scrollTop !== state.scrollTop) {
            return false;
        }
        if (!this.position && state.position || this.position && !state.position || this.position && state.position && !this.position.equals(state.position)) {
            return false;
        }
        if (!this.selection && state.selection || this.selection && !state.selection || this.selection && state.selection && !this.selection.equalsRange(state.selection)) {
            return false;
        }
        return true;
    };
    EditorState.prototype.validate = function (editor) {
        return this._equals(new EditorState(editor, this.flags));
    };
    return EditorState;
}());
var StableEditorScrollState = /** @class */ (function () {
    function StableEditorScrollState(_visiblePosition, _visiblePositionScrollDelta) {
        this._visiblePosition = _visiblePosition;
        this._visiblePositionScrollDelta = _visiblePositionScrollDelta;
    }
    StableEditorScrollState.capture = function (editor) {
        var visiblePosition = null;
        var visiblePositionScrollDelta = 0;
        if (editor.getScrollTop() !== 0) {
            var visibleRanges = editor.getVisibleRanges();
            if (visibleRanges.length > 0) {
                visiblePosition = visibleRanges[0].getStartPosition();
                var visiblePositionScrollTop = editor.getTopForPosition(visiblePosition.lineNumber, visiblePosition.column);
                visiblePositionScrollDelta = editor.getScrollTop() - visiblePositionScrollTop;
            }
        }
        return new StableEditorScrollState(visiblePosition, visiblePositionScrollDelta);
    };
    StableEditorScrollState.prototype.restore = function (editor) {
        if (this._visiblePosition) {
            var visiblePositionScrollTop = editor.getTopForPosition(this._visiblePosition.lineNumber, this._visiblePosition.column);
            editor.setScrollTop(visiblePositionScrollTop + this._visiblePositionScrollDelta);
        }
    };
    return StableEditorScrollState;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$1b = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate$7 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$4 = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var VisualEditorState = /** @class */ (function () {
    function VisualEditorState() {
        this._zones = [];
        this._zonesMap = {};
        this._decorations = [];
    }
    VisualEditorState.prototype.getForeignViewZones = function (allViewZones) {
        var _this = this;
        return allViewZones.filter(function (z) { return !_this._zonesMap[String(z.id)]; });
    };
    VisualEditorState.prototype.clean = function (editor) {
        var _this = this;
        // (1) View zones
        if (this._zones.length > 0) {
            editor.changeViewZones(function (viewChangeAccessor) {
                for (var i = 0, length_1 = _this._zones.length; i < length_1; i++) {
                    viewChangeAccessor.removeZone(_this._zones[i]);
                }
            });
        }
        this._zones = [];
        this._zonesMap = {};
        // (2) Model decorations
        this._decorations = editor.deltaDecorations(this._decorations, []);
    };
    VisualEditorState.prototype.apply = function (editor, overviewRuler, newDecorations, restoreScrollState) {
        var _this = this;
        var scrollState = restoreScrollState ? StableEditorScrollState.capture(editor) : null;
        // view zones
        editor.changeViewZones(function (viewChangeAccessor) {
            for (var i = 0, length_2 = _this._zones.length; i < length_2; i++) {
                viewChangeAccessor.removeZone(_this._zones[i]);
            }
            _this._zones = [];
            _this._zonesMap = {};
            for (var i = 0, length_3 = newDecorations.zones.length; i < length_3; i++) {
                newDecorations.zones[i].suppressMouseDown = true;
                var zoneId = viewChangeAccessor.addZone(newDecorations.zones[i]);
                _this._zones.push(zoneId);
                _this._zonesMap[String(zoneId)] = true;
            }
        });
        if (scrollState) {
            scrollState.restore(editor);
        }
        // decorations
        this._decorations = editor.deltaDecorations(this._decorations, newDecorations.decorations);
        // overview ruler
        if (overviewRuler) {
            overviewRuler.setZones(newDecorations.overviewZones);
        }
    };
    return VisualEditorState;
}());
var DIFF_EDITOR_ID = 0;
var DiffEditorWidget = /** @class */ (function (_super) {
    __extends$1b(DiffEditorWidget, _super);
    function DiffEditorWidget(domElement, options, editorWorkerService, contextKeyService, instantiationService, codeEditorService, themeService, notificationService) {
        var _this = _super.call(this) || this;
        _this._onDidDispose = _this._register(new Emitter());
        _this.onDidDispose = _this._onDidDispose.event;
        _this._onDidUpdateDiff = _this._register(new Emitter());
        _this.onDidUpdateDiff = _this._onDidUpdateDiff.event;
        _this._lastOriginalWarning = null;
        _this._lastModifiedWarning = null;
        _this._editorWorkerService = editorWorkerService;
        _this._codeEditorService = codeEditorService;
        _this._contextKeyService = _this._register(contextKeyService.createScoped(domElement));
        _this._contextKeyService.createKey('isInDiffEditor', true);
        _this._themeService = themeService;
        _this._notificationService = notificationService;
        _this.id = (++DIFF_EDITOR_ID);
        _this._domElement = domElement;
        options = options || {};
        // renderSideBySide
        _this._renderSideBySide = true;
        if (typeof options.renderSideBySide !== 'undefined') {
            _this._renderSideBySide = options.renderSideBySide;
        }
        // ignoreTrimWhitespace
        _this._ignoreTrimWhitespace = true;
        if (typeof options.ignoreTrimWhitespace !== 'undefined') {
            _this._ignoreTrimWhitespace = options.ignoreTrimWhitespace;
        }
        // renderIndicators
        _this._renderIndicators = true;
        if (typeof options.renderIndicators !== 'undefined') {
            _this._renderIndicators = options.renderIndicators;
        }
        _this._originalIsEditable = false;
        if (typeof options.originalEditable !== 'undefined') {
            _this._originalIsEditable = Boolean(options.originalEditable);
        }
        _this._updateDecorationsRunner = _this._register(new RunOnceScheduler(function () { return _this._updateDecorations(); }, 0));
        _this._containerDomElement = document.createElement('div');
        _this._containerDomElement.className = DiffEditorWidget._getClassName(_this._themeService.getTheme(), _this._renderSideBySide);
        _this._containerDomElement.style.position = 'relative';
        _this._containerDomElement.style.height = '100%';
        _this._domElement.appendChild(_this._containerDomElement);
        _this._overviewViewportDomElement = createFastDomNode(document.createElement('div'));
        _this._overviewViewportDomElement.setClassName('diffViewport');
        _this._overviewViewportDomElement.setPosition('absolute');
        _this._overviewDomElement = document.createElement('div');
        _this._overviewDomElement.className = 'diffOverview';
        _this._overviewDomElement.style.position = 'absolute';
        _this._overviewDomElement.appendChild(_this._overviewViewportDomElement.domNode);
        _this._register(addStandardDisposableListener(_this._overviewDomElement, 'mousedown', function (e) {
            _this.modifiedEditor.delegateVerticalScrollbarMouseDown(e);
        }));
        _this._containerDomElement.appendChild(_this._overviewDomElement);
        _this._createLeftHandSide();
        _this._createRightHandSide();
        _this._beginUpdateDecorationsTimeout = -1;
        _this._currentlyChangingViewZones = false;
        _this._diffComputationToken = 0;
        _this._originalEditorState = new VisualEditorState();
        _this._modifiedEditorState = new VisualEditorState();
        _this._isVisible = true;
        _this._isHandlingScrollEvent = false;
        _this._width = 0;
        _this._height = 0;
        _this._reviewHeight = 0;
        _this._lineChanges = null;
        var leftContextKeyService = _this._contextKeyService.createScoped();
        leftContextKeyService.createKey('isInDiffLeftEditor', true);
        var leftServices = new ServiceCollection();
        leftServices.set(IContextKeyService, leftContextKeyService);
        var leftScopedInstantiationService = instantiationService.createChild(leftServices);
        var rightContextKeyService = _this._contextKeyService.createScoped();
        rightContextKeyService.createKey('isInDiffRightEditor', true);
        var rightServices = new ServiceCollection();
        rightServices.set(IContextKeyService, rightContextKeyService);
        var rightScopedInstantiationService = instantiationService.createChild(rightServices);
        _this._createLeftHandSideEditor(options, leftScopedInstantiationService);
        _this._createRightHandSideEditor(options, rightScopedInstantiationService);
        _this._reviewPane = new DiffReview(_this);
        _this._containerDomElement.appendChild(_this._reviewPane.domNode.domNode);
        _this._containerDomElement.appendChild(_this._reviewPane.shadow.domNode);
        _this._containerDomElement.appendChild(_this._reviewPane.actionBarContainer.domNode);
        if (options.automaticLayout) {
            _this._measureDomElementToken = window.setInterval(function () { return _this._measureDomElement(false); }, 100);
        }
        // enableSplitViewResizing
        _this._enableSplitViewResizing = true;
        if (typeof options.enableSplitViewResizing !== 'undefined') {
            _this._enableSplitViewResizing = options.enableSplitViewResizing;
        }
        if (_this._renderSideBySide) {
            _this._setStrategy(new DiffEdtorWidgetSideBySide(_this._createDataSource(), _this._enableSplitViewResizing));
        }
        else {
            _this._setStrategy(new DiffEdtorWidgetInline(_this._createDataSource(), _this._enableSplitViewResizing));
        }
        _this._register(themeService.onThemeChange(function (t) {
            if (_this._strategy && _this._strategy.applyColors(t)) {
                _this._updateDecorationsRunner.schedule();
            }
            _this._containerDomElement.className = DiffEditorWidget._getClassName(_this._themeService.getTheme(), _this._renderSideBySide);
        }));
        _this._codeEditorService.addDiffEditor(_this);
        return _this;
    }
    Object.defineProperty(DiffEditorWidget.prototype, "ignoreTrimWhitespace", {
        get: function () {
            return this._ignoreTrimWhitespace;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DiffEditorWidget.prototype, "renderSideBySide", {
        get: function () {
            return this._renderSideBySide;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DiffEditorWidget.prototype, "renderIndicators", {
        get: function () {
            return this._renderIndicators;
        },
        enumerable: true,
        configurable: true
    });
    DiffEditorWidget.prototype.hasWidgetFocus = function () {
        return isAncestor(document.activeElement, this._domElement);
    };
    DiffEditorWidget.prototype.diffReviewNext = function () {
        this._reviewPane.next();
    };
    DiffEditorWidget.prototype.diffReviewPrev = function () {
        this._reviewPane.prev();
    };
    DiffEditorWidget._getClassName = function (theme, renderSideBySide) {
        var result = 'monaco-diff-editor monaco-editor-background ';
        if (renderSideBySide) {
            result += 'side-by-side ';
        }
        result += getThemeTypeSelector(theme.type);
        return result;
    };
    DiffEditorWidget.prototype._recreateOverviewRulers = function () {
        if (this._originalOverviewRuler) {
            this._overviewDomElement.removeChild(this._originalOverviewRuler.getDomNode());
            this._originalOverviewRuler.dispose();
        }
        this._originalOverviewRuler = this.originalEditor.createOverviewRuler('original diffOverviewRuler');
        this._overviewDomElement.appendChild(this._originalOverviewRuler.getDomNode());
        if (this._modifiedOverviewRuler) {
            this._overviewDomElement.removeChild(this._modifiedOverviewRuler.getDomNode());
            this._modifiedOverviewRuler.dispose();
        }
        this._modifiedOverviewRuler = this.modifiedEditor.createOverviewRuler('modified diffOverviewRuler');
        this._overviewDomElement.appendChild(this._modifiedOverviewRuler.getDomNode());
        this._layoutOverviewRulers();
    };
    DiffEditorWidget.prototype._createLeftHandSide = function () {
        this._originalDomNode = document.createElement('div');
        this._originalDomNode.className = 'editor original';
        this._originalDomNode.style.position = 'absolute';
        this._originalDomNode.style.height = '100%';
        this._containerDomElement.appendChild(this._originalDomNode);
    };
    DiffEditorWidget.prototype._createRightHandSide = function () {
        this._modifiedDomNode = document.createElement('div');
        this._modifiedDomNode.className = 'editor modified';
        this._modifiedDomNode.style.position = 'absolute';
        this._modifiedDomNode.style.height = '100%';
        this._containerDomElement.appendChild(this._modifiedDomNode);
    };
    DiffEditorWidget.prototype._createLeftHandSideEditor = function (options, instantiationService) {
        var _this = this;
        this.originalEditor = this._createInnerEditor(instantiationService, this._originalDomNode, this._adjustOptionsForLeftHandSide(options, this._originalIsEditable));
        this._register(this.originalEditor.onDidScrollChange(function (e) {
            if (_this._isHandlingScrollEvent) {
                return;
            }
            if (!e.scrollTopChanged && !e.scrollLeftChanged && !e.scrollHeightChanged) {
                return;
            }
            _this._isHandlingScrollEvent = true;
            _this.modifiedEditor.setScrollPosition({
                scrollLeft: e.scrollLeft,
                scrollTop: e.scrollTop
            });
            _this._isHandlingScrollEvent = false;
            _this._layoutOverviewViewport();
        }));
        this._register(this.originalEditor.onDidChangeViewZones(function () {
            _this._onViewZonesChanged();
        }));
        this._register(this.originalEditor.onDidChangeModelContent(function () {
            if (_this._isVisible) {
                _this._beginUpdateDecorationsSoon();
            }
        }));
    };
    DiffEditorWidget.prototype._createRightHandSideEditor = function (options, instantiationService) {
        var _this = this;
        this.modifiedEditor = this._createInnerEditor(instantiationService, this._modifiedDomNode, this._adjustOptionsForRightHandSide(options));
        this._register(this.modifiedEditor.onDidScrollChange(function (e) {
            if (_this._isHandlingScrollEvent) {
                return;
            }
            if (!e.scrollTopChanged && !e.scrollLeftChanged && !e.scrollHeightChanged) {
                return;
            }
            _this._isHandlingScrollEvent = true;
            _this.originalEditor.setScrollPosition({
                scrollLeft: e.scrollLeft,
                scrollTop: e.scrollTop
            });
            _this._isHandlingScrollEvent = false;
            _this._layoutOverviewViewport();
        }));
        this._register(this.modifiedEditor.onDidChangeViewZones(function () {
            _this._onViewZonesChanged();
        }));
        this._register(this.modifiedEditor.onDidChangeConfiguration(function (e) {
            if (e.fontInfo && _this.modifiedEditor.getModel()) {
                _this._onViewZonesChanged();
            }
        }));
        this._register(this.modifiedEditor.onDidChangeModelContent(function () {
            if (_this._isVisible) {
                _this._beginUpdateDecorationsSoon();
            }
        }));
    };
    DiffEditorWidget.prototype._createInnerEditor = function (instantiationService, container, options) {
        return instantiationService.createInstance(CodeEditor, container, options);
    };
    DiffEditorWidget.prototype.dispose = function () {
        this._codeEditorService.removeDiffEditor(this);
        if (this._beginUpdateDecorationsTimeout !== -1) {
            window.clearTimeout(this._beginUpdateDecorationsTimeout);
            this._beginUpdateDecorationsTimeout = -1;
        }
        window.clearInterval(this._measureDomElementToken);
        this._cleanViewZonesAndDecorations();
        this._overviewDomElement.removeChild(this._originalOverviewRuler.getDomNode());
        this._originalOverviewRuler.dispose();
        this._overviewDomElement.removeChild(this._modifiedOverviewRuler.getDomNode());
        this._modifiedOverviewRuler.dispose();
        this._overviewDomElement.removeChild(this._overviewViewportDomElement.domNode);
        this._containerDomElement.removeChild(this._overviewDomElement);
        this._containerDomElement.removeChild(this._originalDomNode);
        this.originalEditor.dispose();
        this._containerDomElement.removeChild(this._modifiedDomNode);
        this.modifiedEditor.dispose();
        this._strategy.dispose();
        this._containerDomElement.removeChild(this._reviewPane.domNode.domNode);
        this._containerDomElement.removeChild(this._reviewPane.shadow.domNode);
        this._containerDomElement.removeChild(this._reviewPane.actionBarContainer.domNode);
        this._reviewPane.dispose();
        this._domElement.removeChild(this._containerDomElement);
        this._onDidDispose.fire();
        _super.prototype.dispose.call(this);
    };
    //------------ begin IDiffEditor methods
    DiffEditorWidget.prototype.getId = function () {
        return this.getEditorType() + ':' + this.id;
    };
    DiffEditorWidget.prototype.getEditorType = function () {
        return EditorType.IDiffEditor;
    };
    DiffEditorWidget.prototype.getLineChanges = function () {
        return this._lineChanges;
    };
    DiffEditorWidget.prototype.getOriginalEditor = function () {
        return this.originalEditor;
    };
    DiffEditorWidget.prototype.getModifiedEditor = function () {
        return this.modifiedEditor;
    };
    DiffEditorWidget.prototype.updateOptions = function (newOptions) {
        // Handle side by side
        var renderSideBySideChanged = false;
        if (typeof newOptions.renderSideBySide !== 'undefined') {
            if (this._renderSideBySide !== newOptions.renderSideBySide) {
                this._renderSideBySide = newOptions.renderSideBySide;
                renderSideBySideChanged = true;
            }
        }
        var beginUpdateDecorations = false;
        if (typeof newOptions.ignoreTrimWhitespace !== 'undefined') {
            if (this._ignoreTrimWhitespace !== newOptions.ignoreTrimWhitespace) {
                this._ignoreTrimWhitespace = newOptions.ignoreTrimWhitespace;
                // Begin comparing
                beginUpdateDecorations = true;
            }
        }
        if (typeof newOptions.renderIndicators !== 'undefined') {
            if (this._renderIndicators !== newOptions.renderIndicators) {
                this._renderIndicators = newOptions.renderIndicators;
                beginUpdateDecorations = true;
            }
        }
        if (beginUpdateDecorations) {
            this._beginUpdateDecorations();
        }
        if (typeof newOptions.originalEditable !== 'undefined') {
            this._originalIsEditable = Boolean(newOptions.originalEditable);
        }
        this.modifiedEditor.updateOptions(this._adjustOptionsForRightHandSide(newOptions));
        this.originalEditor.updateOptions(this._adjustOptionsForLeftHandSide(newOptions, this._originalIsEditable));
        // enableSplitViewResizing
        if (typeof newOptions.enableSplitViewResizing !== 'undefined') {
            this._enableSplitViewResizing = newOptions.enableSplitViewResizing;
        }
        this._strategy.setEnableSplitViewResizing(this._enableSplitViewResizing);
        // renderSideBySide
        if (renderSideBySideChanged) {
            if (this._renderSideBySide) {
                this._setStrategy(new DiffEdtorWidgetSideBySide(this._createDataSource(), this._enableSplitViewResizing));
            }
            else {
                this._setStrategy(new DiffEdtorWidgetInline(this._createDataSource(), this._enableSplitViewResizing));
            }
            // Update class name
            this._containerDomElement.className = DiffEditorWidget._getClassName(this._themeService.getTheme(), this._renderSideBySide);
        }
    };
    DiffEditorWidget.prototype.getModel = function () {
        return {
            original: this.originalEditor.getModel(),
            modified: this.modifiedEditor.getModel()
        };
    };
    DiffEditorWidget.prototype.setModel = function (model) {
        // Guard us against partial null model
        if (model && (!model.original || !model.modified)) {
            throw new Error(!model.original ? 'DiffEditorWidget.setModel: Original model is null' : 'DiffEditorWidget.setModel: Modified model is null');
        }
        // Remove all view zones & decorations
        this._cleanViewZonesAndDecorations();
        // Update code editor models
        this.originalEditor.setModel(model ? model.original : null);
        this.modifiedEditor.setModel(model ? model.modified : null);
        this._updateDecorationsRunner.cancel();
        if (model) {
            this.originalEditor.setScrollTop(0);
            this.modifiedEditor.setScrollTop(0);
        }
        // Disable any diff computations that will come in
        this._lineChanges = null;
        this._diffComputationToken++;
        if (model) {
            this._recreateOverviewRulers();
            // Begin comparing
            this._beginUpdateDecorations();
        }
        else {
            this._lineChanges = null;
        }
        this._layoutOverviewViewport();
    };
    DiffEditorWidget.prototype.getDomNode = function () {
        return this._domElement;
    };
    DiffEditorWidget.prototype.getVisibleColumnFromPosition = function (position$$1) {
        return this.modifiedEditor.getVisibleColumnFromPosition(position$$1);
    };
    DiffEditorWidget.prototype.getPosition = function () {
        return this.modifiedEditor.getPosition();
    };
    DiffEditorWidget.prototype.setPosition = function (position$$1) {
        this.modifiedEditor.setPosition(position$$1);
    };
    DiffEditorWidget.prototype.revealLine = function (lineNumber, scrollType) {
        if (scrollType === void 0) { scrollType = 0 /* Smooth */; }
        this.modifiedEditor.revealLine(lineNumber, scrollType);
    };
    DiffEditorWidget.prototype.revealLineInCenter = function (lineNumber, scrollType) {
        if (scrollType === void 0) { scrollType = 0 /* Smooth */; }
        this.modifiedEditor.revealLineInCenter(lineNumber, scrollType);
    };
    DiffEditorWidget.prototype.revealLineInCenterIfOutsideViewport = function (lineNumber, scrollType) {
        if (scrollType === void 0) { scrollType = 0 /* Smooth */; }
        this.modifiedEditor.revealLineInCenterIfOutsideViewport(lineNumber, scrollType);
    };
    DiffEditorWidget.prototype.revealPosition = function (position$$1, scrollType) {
        if (scrollType === void 0) { scrollType = 0 /* Smooth */; }
        this.modifiedEditor.revealPosition(position$$1, scrollType);
    };
    DiffEditorWidget.prototype.revealPositionInCenter = function (position$$1, scrollType) {
        if (scrollType === void 0) { scrollType = 0 /* Smooth */; }
        this.modifiedEditor.revealPositionInCenter(position$$1, scrollType);
    };
    DiffEditorWidget.prototype.revealPositionInCenterIfOutsideViewport = function (position$$1, scrollType) {
        if (scrollType === void 0) { scrollType = 0 /* Smooth */; }
        this.modifiedEditor.revealPositionInCenterIfOutsideViewport(position$$1, scrollType);
    };
    DiffEditorWidget.prototype.getSelection = function () {
        return this.modifiedEditor.getSelection();
    };
    DiffEditorWidget.prototype.getSelections = function () {
        return this.modifiedEditor.getSelections();
    };
    DiffEditorWidget.prototype.setSelection = function (something) {
        this.modifiedEditor.setSelection(something);
    };
    DiffEditorWidget.prototype.setSelections = function (ranges) {
        this.modifiedEditor.setSelections(ranges);
    };
    DiffEditorWidget.prototype.revealLines = function (startLineNumber, endLineNumber, scrollType) {
        if (scrollType === void 0) { scrollType = 0 /* Smooth */; }
        this.modifiedEditor.revealLines(startLineNumber, endLineNumber, scrollType);
    };
    DiffEditorWidget.prototype.revealLinesInCenter = function (startLineNumber, endLineNumber, scrollType) {
        if (scrollType === void 0) { scrollType = 0 /* Smooth */; }
        this.modifiedEditor.revealLinesInCenter(startLineNumber, endLineNumber, scrollType);
    };
    DiffEditorWidget.prototype.revealLinesInCenterIfOutsideViewport = function (startLineNumber, endLineNumber, scrollType) {
        if (scrollType === void 0) { scrollType = 0 /* Smooth */; }
        this.modifiedEditor.revealLinesInCenterIfOutsideViewport(startLineNumber, endLineNumber, scrollType);
    };
    DiffEditorWidget.prototype.revealRange = function (range, scrollType, revealVerticalInCenter, revealHorizontal) {
        if (scrollType === void 0) { scrollType = 0 /* Smooth */; }
        if (revealVerticalInCenter === void 0) { revealVerticalInCenter = false; }
        if (revealHorizontal === void 0) { revealHorizontal = true; }
        this.modifiedEditor.revealRange(range, scrollType, revealVerticalInCenter, revealHorizontal);
    };
    DiffEditorWidget.prototype.revealRangeInCenter = function (range, scrollType) {
        if (scrollType === void 0) { scrollType = 0 /* Smooth */; }
        this.modifiedEditor.revealRangeInCenter(range, scrollType);
    };
    DiffEditorWidget.prototype.revealRangeInCenterIfOutsideViewport = function (range, scrollType) {
        if (scrollType === void 0) { scrollType = 0 /* Smooth */; }
        this.modifiedEditor.revealRangeInCenterIfOutsideViewport(range, scrollType);
    };
    DiffEditorWidget.prototype.revealRangeAtTop = function (range, scrollType) {
        if (scrollType === void 0) { scrollType = 0 /* Smooth */; }
        this.modifiedEditor.revealRangeAtTop(range, scrollType);
    };
    DiffEditorWidget.prototype.getSupportedActions = function () {
        return this.modifiedEditor.getSupportedActions();
    };
    DiffEditorWidget.prototype.saveViewState = function () {
        var originalViewState = this.originalEditor.saveViewState();
        var modifiedViewState = this.modifiedEditor.saveViewState();
        return {
            original: originalViewState,
            modified: modifiedViewState
        };
    };
    DiffEditorWidget.prototype.restoreViewState = function (s) {
        if (s.original && s.original) {
            var diffEditorState = s;
            this.originalEditor.restoreViewState(diffEditorState.original);
            this.modifiedEditor.restoreViewState(diffEditorState.modified);
        }
    };
    DiffEditorWidget.prototype.layout = function (dimension) {
        this._measureDomElement(false, dimension);
    };
    DiffEditorWidget.prototype.focus = function () {
        this.modifiedEditor.focus();
    };
    DiffEditorWidget.prototype.isFocused = function () {
        return this.originalEditor.isFocused() || this.modifiedEditor.isFocused();
    };
    DiffEditorWidget.prototype.onVisible = function () {
        this._isVisible = true;
        this.originalEditor.onVisible();
        this.modifiedEditor.onVisible();
        // Begin comparing
        this._beginUpdateDecorations();
    };
    DiffEditorWidget.prototype.onHide = function () {
        this._isVisible = false;
        this.originalEditor.onHide();
        this.modifiedEditor.onHide();
        // Remove all view zones & decorations
        this._cleanViewZonesAndDecorations();
    };
    DiffEditorWidget.prototype.trigger = function (source, handlerId, payload) {
        this.modifiedEditor.trigger(source, handlerId, payload);
    };
    DiffEditorWidget.prototype.changeDecorations = function (callback) {
        return this.modifiedEditor.changeDecorations(callback);
    };
    //------------ end IDiffEditor methods
    //------------ begin layouting methods
    DiffEditorWidget.prototype._measureDomElement = function (forceDoLayoutCall, dimensions) {
        dimensions = dimensions || {
            width: this._containerDomElement.clientWidth,
            height: this._containerDomElement.clientHeight
        };
        if (dimensions.width <= 0) {
            this._width = 0;
            this._height = 0;
            this._reviewHeight = 0;
            return;
        }
        if (!forceDoLayoutCall && dimensions.width === this._width && dimensions.height === this._height) {
            // Nothing has changed
            return;
        }
        this._width = dimensions.width;
        this._height = dimensions.height;
        this._reviewHeight = this._reviewPane.isVisible() ? this._height : 0;
        this._doLayout();
    };
    DiffEditorWidget.prototype._layoutOverviewRulers = function () {
        var freeSpace = DiffEditorWidget.ENTIRE_DIFF_OVERVIEW_WIDTH - 2 * DiffEditorWidget.ONE_OVERVIEW_WIDTH;
        var layoutInfo = this.modifiedEditor.getLayoutInfo();
        if (layoutInfo) {
            this._originalOverviewRuler.setLayout({
                top: 0,
                width: DiffEditorWidget.ONE_OVERVIEW_WIDTH,
                right: freeSpace + DiffEditorWidget.ONE_OVERVIEW_WIDTH,
                height: (this._height - this._reviewHeight)
            });
            this._modifiedOverviewRuler.setLayout({
                top: 0,
                right: 0,
                width: DiffEditorWidget.ONE_OVERVIEW_WIDTH,
                height: (this._height - this._reviewHeight)
            });
        }
    };
    //------------ end layouting methods
    DiffEditorWidget.prototype._onViewZonesChanged = function () {
        if (this._currentlyChangingViewZones) {
            return;
        }
        this._updateDecorationsRunner.schedule();
    };
    DiffEditorWidget.prototype._beginUpdateDecorationsSoon = function () {
        var _this = this;
        // Clear previous timeout if necessary
        if (this._beginUpdateDecorationsTimeout !== -1) {
            window.clearTimeout(this._beginUpdateDecorationsTimeout);
            this._beginUpdateDecorationsTimeout = -1;
        }
        this._beginUpdateDecorationsTimeout = window.setTimeout(function () { return _this._beginUpdateDecorations(); }, DiffEditorWidget.UPDATE_DIFF_DECORATIONS_DELAY);
    };
    DiffEditorWidget._equals = function (a, b) {
        if (!a && !b) {
            return true;
        }
        if (!a || !b) {
            return false;
        }
        return (a.toString() === b.toString());
    };
    DiffEditorWidget.prototype._beginUpdateDecorations = function () {
        var _this = this;
        this._beginUpdateDecorationsTimeout = -1;
        var currentOriginalModel = this.originalEditor.getModel();
        var currentModifiedModel = this.modifiedEditor.getModel();
        if (!currentOriginalModel || !currentModifiedModel) {
            return;
        }
        // Prevent old diff requests to come if a new request has been initiated
        // The best method would be to call cancel on the Promise, but this is not
        // yet supported, so using tokens for now.
        this._diffComputationToken++;
        var currentToken = this._diffComputationToken;
        if (!this._editorWorkerService.canComputeDiff(currentOriginalModel.uri, currentModifiedModel.uri)) {
            if (!DiffEditorWidget._equals(currentOriginalModel.uri, this._lastOriginalWarning)
                || !DiffEditorWidget._equals(currentModifiedModel.uri, this._lastModifiedWarning)) {
                this._lastOriginalWarning = currentOriginalModel.uri;
                this._lastModifiedWarning = currentModifiedModel.uri;
                this._notificationService.warn(localize("diff.tooLarge", "Cannot compare files because one file is too large."));
            }
            return;
        }
        this._editorWorkerService.computeDiff(currentOriginalModel.uri, currentModifiedModel.uri, this._ignoreTrimWhitespace).then(function (result) {
            if (currentToken === _this._diffComputationToken
                && currentOriginalModel === _this.originalEditor.getModel()
                && currentModifiedModel === _this.modifiedEditor.getModel()) {
                _this._lineChanges = result;
                _this._updateDecorationsRunner.schedule();
                _this._onDidUpdateDiff.fire();
            }
        }, function (error) {
            if (currentToken === _this._diffComputationToken
                && currentOriginalModel === _this.originalEditor.getModel()
                && currentModifiedModel === _this.modifiedEditor.getModel()) {
                _this._lineChanges = null;
                _this._updateDecorationsRunner.schedule();
            }
        });
    };
    DiffEditorWidget.prototype._cleanViewZonesAndDecorations = function () {
        this._originalEditorState.clean(this.originalEditor);
        this._modifiedEditorState.clean(this.modifiedEditor);
    };
    DiffEditorWidget.prototype._updateDecorations = function () {
        if (!this.originalEditor.getModel() || !this.modifiedEditor.getModel()) {
            return;
        }
        var lineChanges = this._lineChanges || [];
        var foreignOriginal = this._originalEditorState.getForeignViewZones(this.originalEditor.getWhitespaces());
        var foreignModified = this._modifiedEditorState.getForeignViewZones(this.modifiedEditor.getWhitespaces());
        var diffDecorations = this._strategy.getEditorsDiffDecorations(lineChanges, this._ignoreTrimWhitespace, this._renderIndicators, foreignOriginal, foreignModified, this.originalEditor, this.modifiedEditor);
        try {
            this._currentlyChangingViewZones = true;
            this._originalEditorState.apply(this.originalEditor, this._originalOverviewRuler, diffDecorations.original, false);
            this._modifiedEditorState.apply(this.modifiedEditor, this._modifiedOverviewRuler, diffDecorations.modified, true);
        }
        finally {
            this._currentlyChangingViewZones = false;
        }
    };
    DiffEditorWidget.prototype._adjustOptionsForSubEditor = function (options) {
        var clonedOptions = deepClone(options || {});
        clonedOptions.inDiffEditor = true;
        clonedOptions.wordWrap = 'off';
        clonedOptions.wordWrapMinified = false;
        clonedOptions.automaticLayout = false;
        clonedOptions.scrollbar = clonedOptions.scrollbar || {};
        clonedOptions.scrollbar.vertical = 'visible';
        clonedOptions.folding = false;
        clonedOptions.codeLens = false;
        clonedOptions.fixedOverflowWidgets = true;
        clonedOptions.lineDecorationsWidth = '2ch';
        if (!clonedOptions.minimap) {
            clonedOptions.minimap = {};
        }
        clonedOptions.minimap.enabled = false;
        return clonedOptions;
    };
    DiffEditorWidget.prototype._adjustOptionsForLeftHandSide = function (options, isEditable) {
        var result = this._adjustOptionsForSubEditor(options);
        result.readOnly = !isEditable;
        result.overviewRulerLanes = 1;
        result.extraEditorClassName = 'original-in-monaco-diff-editor';
        return result;
    };
    DiffEditorWidget.prototype._adjustOptionsForRightHandSide = function (options) {
        var result = this._adjustOptionsForSubEditor(options);
        result.revealHorizontalRightPadding = EDITOR_DEFAULTS.viewInfo.revealHorizontalRightPadding + DiffEditorWidget.ENTIRE_DIFF_OVERVIEW_WIDTH;
        result.scrollbar.verticalHasArrows = false;
        result.extraEditorClassName = 'modified-in-monaco-diff-editor';
        return result;
    };
    DiffEditorWidget.prototype.doLayout = function () {
        this._measureDomElement(true);
    };
    DiffEditorWidget.prototype._doLayout = function () {
        var splitPoint = this._strategy.layout();
        this._originalDomNode.style.width = splitPoint + 'px';
        this._originalDomNode.style.left = '0px';
        this._modifiedDomNode.style.width = (this._width - splitPoint) + 'px';
        this._modifiedDomNode.style.left = splitPoint + 'px';
        this._overviewDomElement.style.top = '0px';
        this._overviewDomElement.style.height = (this._height - this._reviewHeight) + 'px';
        this._overviewDomElement.style.width = DiffEditorWidget.ENTIRE_DIFF_OVERVIEW_WIDTH + 'px';
        this._overviewDomElement.style.left = (this._width - DiffEditorWidget.ENTIRE_DIFF_OVERVIEW_WIDTH) + 'px';
        this._overviewViewportDomElement.setWidth(DiffEditorWidget.ENTIRE_DIFF_OVERVIEW_WIDTH);
        this._overviewViewportDomElement.setHeight(30);
        this.originalEditor.layout({ width: splitPoint, height: (this._height - this._reviewHeight) });
        this.modifiedEditor.layout({ width: this._width - splitPoint - DiffEditorWidget.ENTIRE_DIFF_OVERVIEW_WIDTH, height: (this._height - this._reviewHeight) });
        if (this._originalOverviewRuler || this._modifiedOverviewRuler) {
            this._layoutOverviewRulers();
        }
        this._reviewPane.layout(this._height - this._reviewHeight, this._width, this._reviewHeight);
        this._layoutOverviewViewport();
    };
    DiffEditorWidget.prototype._layoutOverviewViewport = function () {
        var layout = this._computeOverviewViewport();
        if (!layout) {
            this._overviewViewportDomElement.setTop(0);
            this._overviewViewportDomElement.setHeight(0);
        }
        else {
            this._overviewViewportDomElement.setTop(layout.top);
            this._overviewViewportDomElement.setHeight(layout.height);
        }
    };
    DiffEditorWidget.prototype._computeOverviewViewport = function () {
        var layoutInfo = this.modifiedEditor.getLayoutInfo();
        if (!layoutInfo) {
            return null;
        }
        var scrollTop = this.modifiedEditor.getScrollTop();
        var scrollHeight = this.modifiedEditor.getScrollHeight();
        var computedAvailableSize = Math.max(0, layoutInfo.contentHeight);
        var computedRepresentableSize = Math.max(0, computedAvailableSize - 2 * 0);
        var computedRatio = scrollHeight > 0 ? (computedRepresentableSize / scrollHeight) : 0;
        var computedSliderSize = Math.max(0, Math.floor(layoutInfo.contentHeight * computedRatio));
        var computedSliderPosition = Math.floor(scrollTop * computedRatio);
        return {
            height: computedSliderSize,
            top: computedSliderPosition
        };
    };
    DiffEditorWidget.prototype._createDataSource = function () {
        var _this = this;
        return {
            getWidth: function () {
                return _this._width;
            },
            getHeight: function () {
                return (_this._height - _this._reviewHeight);
            },
            getContainerDomNode: function () {
                return _this._containerDomElement;
            },
            relayoutEditors: function () {
                _this._doLayout();
            },
            getOriginalEditor: function () {
                return _this.originalEditor;
            },
            getModifiedEditor: function () {
                return _this.modifiedEditor;
            }
        };
    };
    DiffEditorWidget.prototype._setStrategy = function (newStrategy) {
        if (this._strategy) {
            this._strategy.dispose();
        }
        this._strategy = newStrategy;
        newStrategy.applyColors(this._themeService.getTheme());
        if (this._lineChanges) {
            this._updateDecorations();
        }
        // Just do a layout, the strategy might need it
        this._measureDomElement(true);
    };
    DiffEditorWidget.prototype._getLineChangeAtOrBeforeLineNumber = function (lineNumber, startLineNumberExtractor) {
        if (this._lineChanges.length === 0 || lineNumber < startLineNumberExtractor(this._lineChanges[0])) {
            // There are no changes or `lineNumber` is before the first change
            return null;
        }
        var min = 0, max = this._lineChanges.length - 1;
        while (min < max) {
            var mid = Math.floor((min + max) / 2);
            var midStart = startLineNumberExtractor(this._lineChanges[mid]);
            var midEnd = (mid + 1 <= max ? startLineNumberExtractor(this._lineChanges[mid + 1]) : Number.MAX_VALUE);
            if (lineNumber < midStart) {
                max = mid - 1;
            }
            else if (lineNumber >= midEnd) {
                min = mid + 1;
            }
            else {
                // HIT!
                min = mid;
                max = mid;
            }
        }
        return this._lineChanges[min];
    };
    DiffEditorWidget.prototype._getEquivalentLineForOriginalLineNumber = function (lineNumber) {
        var lineChange = this._getLineChangeAtOrBeforeLineNumber(lineNumber, function (lineChange) { return lineChange.originalStartLineNumber; });
        if (!lineChange) {
            return lineNumber;
        }
        var originalEquivalentLineNumber = lineChange.originalStartLineNumber + (lineChange.originalEndLineNumber > 0 ? -1 : 0);
        var modifiedEquivalentLineNumber = lineChange.modifiedStartLineNumber + (lineChange.modifiedEndLineNumber > 0 ? -1 : 0);
        var lineChangeOriginalLength = (lineChange.originalEndLineNumber > 0 ? (lineChange.originalEndLineNumber - lineChange.originalStartLineNumber + 1) : 0);
        var lineChangeModifiedLength = (lineChange.modifiedEndLineNumber > 0 ? (lineChange.modifiedEndLineNumber - lineChange.modifiedStartLineNumber + 1) : 0);
        var delta = lineNumber - originalEquivalentLineNumber;
        if (delta <= lineChangeOriginalLength) {
            return modifiedEquivalentLineNumber + Math.min(delta, lineChangeModifiedLength);
        }
        return modifiedEquivalentLineNumber + lineChangeModifiedLength - lineChangeOriginalLength + delta;
    };
    DiffEditorWidget.prototype._getEquivalentLineForModifiedLineNumber = function (lineNumber) {
        var lineChange = this._getLineChangeAtOrBeforeLineNumber(lineNumber, function (lineChange) { return lineChange.modifiedStartLineNumber; });
        if (!lineChange) {
            return lineNumber;
        }
        var originalEquivalentLineNumber = lineChange.originalStartLineNumber + (lineChange.originalEndLineNumber > 0 ? -1 : 0);
        var modifiedEquivalentLineNumber = lineChange.modifiedStartLineNumber + (lineChange.modifiedEndLineNumber > 0 ? -1 : 0);
        var lineChangeOriginalLength = (lineChange.originalEndLineNumber > 0 ? (lineChange.originalEndLineNumber - lineChange.originalStartLineNumber + 1) : 0);
        var lineChangeModifiedLength = (lineChange.modifiedEndLineNumber > 0 ? (lineChange.modifiedEndLineNumber - lineChange.modifiedStartLineNumber + 1) : 0);
        var delta = lineNumber - modifiedEquivalentLineNumber;
        if (delta <= lineChangeModifiedLength) {
            return originalEquivalentLineNumber + Math.min(delta, lineChangeOriginalLength);
        }
        return originalEquivalentLineNumber + lineChangeOriginalLength - lineChangeModifiedLength + delta;
    };
    DiffEditorWidget.prototype.getDiffLineInformationForOriginal = function (lineNumber) {
        if (!this._lineChanges) {
            // Cannot answer that which I don't know
            return null;
        }
        return {
            equivalentLineNumber: this._getEquivalentLineForOriginalLineNumber(lineNumber)
        };
    };
    DiffEditorWidget.prototype.getDiffLineInformationForModified = function (lineNumber) {
        if (!this._lineChanges) {
            // Cannot answer that which I don't know
            return null;
        }
        return {
            equivalentLineNumber: this._getEquivalentLineForModifiedLineNumber(lineNumber)
        };
    };
    DiffEditorWidget.ONE_OVERVIEW_WIDTH = 15;
    DiffEditorWidget.ENTIRE_DIFF_OVERVIEW_WIDTH = 30;
    DiffEditorWidget.UPDATE_DIFF_DECORATIONS_DELAY = 200; // ms
    DiffEditorWidget = __decorate$7([
        __param$4(2, IEditorWorkerService),
        __param$4(3, IContextKeyService),
        __param$4(4, IInstantiationService),
        __param$4(5, ICodeEditorService),
        __param$4(6, IThemeService),
        __param$4(7, INotificationService)
    ], DiffEditorWidget);
    return DiffEditorWidget;
}(Disposable));
var DiffEditorWidgetStyle = /** @class */ (function (_super) {
    __extends$1b(DiffEditorWidgetStyle, _super);
    function DiffEditorWidgetStyle(dataSource) {
        var _this = _super.call(this) || this;
        _this._dataSource = dataSource;
        return _this;
    }
    DiffEditorWidgetStyle.prototype.applyColors = function (theme) {
        var newInsertColor = (theme.getColor(diffInserted) || defaultInsertColor).transparent(2);
        var newRemoveColor = (theme.getColor(diffRemoved) || defaultRemoveColor).transparent(2);
        var hasChanges = !newInsertColor.equals(this._insertColor) || !newRemoveColor.equals(this._removeColor);
        this._insertColor = newInsertColor;
        this._removeColor = newRemoveColor;
        return hasChanges;
    };
    DiffEditorWidgetStyle.prototype.getEditorsDiffDecorations = function (lineChanges, ignoreTrimWhitespace, renderIndicators, originalWhitespaces, modifiedWhitespaces, originalEditor, modifiedEditor) {
        // Get view zones
        modifiedWhitespaces = modifiedWhitespaces.sort(function (a, b) {
            return a.afterLineNumber - b.afterLineNumber;
        });
        originalWhitespaces = originalWhitespaces.sort(function (a, b) {
            return a.afterLineNumber - b.afterLineNumber;
        });
        var zones = this._getViewZones(lineChanges, originalWhitespaces, modifiedWhitespaces, originalEditor, modifiedEditor, renderIndicators);
        // Get decorations & overview ruler zones
        var originalDecorations = this._getOriginalEditorDecorations(lineChanges, ignoreTrimWhitespace, renderIndicators, originalEditor, modifiedEditor);
        var modifiedDecorations = this._getModifiedEditorDecorations(lineChanges, ignoreTrimWhitespace, renderIndicators, originalEditor, modifiedEditor);
        return {
            original: {
                decorations: originalDecorations.decorations,
                overviewZones: originalDecorations.overviewZones,
                zones: zones.original
            },
            modified: {
                decorations: modifiedDecorations.decorations,
                overviewZones: modifiedDecorations.overviewZones,
                zones: zones.modified
            }
        };
    };
    DiffEditorWidgetStyle.prototype._getViewZones = function (lineChanges, originalForeignVZ, modifiedForeignVZ, originalEditor, modifiedEditor, renderIndicators) {
        return null;
    };
    DiffEditorWidgetStyle.prototype._getOriginalEditorDecorations = function (lineChanges, ignoreTrimWhitespace, renderIndicators, originalEditor, modifiedEditor) {
        return null;
    };
    DiffEditorWidgetStyle.prototype._getModifiedEditorDecorations = function (lineChanges, ignoreTrimWhitespace, renderIndicators, originalEditor, modifiedEditor) {
        return null;
    };
    return DiffEditorWidgetStyle;
}(Disposable));
var ForeignViewZonesIterator = /** @class */ (function () {
    function ForeignViewZonesIterator(source) {
        this._source = source;
        this._index = -1;
        this.advance();
    }
    ForeignViewZonesIterator.prototype.advance = function () {
        this._index++;
        if (this._index < this._source.length) {
            this.current = this._source[this._index];
        }
        else {
            this.current = null;
        }
    };
    return ForeignViewZonesIterator;
}());
var ViewZonesComputer = /** @class */ (function () {
    function ViewZonesComputer(lineChanges, originalForeignVZ, modifiedForeignVZ) {
        this.lineChanges = lineChanges;
        this.originalForeignVZ = originalForeignVZ;
        this.modifiedForeignVZ = modifiedForeignVZ;
    }
    ViewZonesComputer.prototype.getViewZones = function () {
        var result = {
            original: [],
            modified: []
        };
        var lineChangeModifiedLength = 0;
        var lineChangeOriginalLength = 0;
        var originalEquivalentLineNumber = 0;
        var modifiedEquivalentLineNumber = 0;
        var originalEndEquivalentLineNumber = 0;
        var modifiedEndEquivalentLineNumber = 0;
        var sortMyViewZones = function (a, b) {
            return a.afterLineNumber - b.afterLineNumber;
        };
        var addAndCombineIfPossible = function (destination, item) {
            if (item.domNode === null && destination.length > 0) {
                var lastItem = destination[destination.length - 1];
                if (lastItem.afterLineNumber === item.afterLineNumber && lastItem.domNode === null) {
                    lastItem.heightInLines += item.heightInLines;
                    return;
                }
            }
            destination.push(item);
        };
        var modifiedForeignVZ = new ForeignViewZonesIterator(this.modifiedForeignVZ);
        var originalForeignVZ = new ForeignViewZonesIterator(this.originalForeignVZ);
        // In order to include foreign view zones after the last line change, the for loop will iterate once more after the end of the `lineChanges` array
        for (var i = 0, length_4 = this.lineChanges.length; i <= length_4; i++) {
            var lineChange = (i < length_4 ? this.lineChanges[i] : null);
            if (lineChange !== null) {
                originalEquivalentLineNumber = lineChange.originalStartLineNumber + (lineChange.originalEndLineNumber > 0 ? -1 : 0);
                modifiedEquivalentLineNumber = lineChange.modifiedStartLineNumber + (lineChange.modifiedEndLineNumber > 0 ? -1 : 0);
                lineChangeOriginalLength = (lineChange.originalEndLineNumber > 0 ? (lineChange.originalEndLineNumber - lineChange.originalStartLineNumber + 1) : 0);
                lineChangeModifiedLength = (lineChange.modifiedEndLineNumber > 0 ? (lineChange.modifiedEndLineNumber - lineChange.modifiedStartLineNumber + 1) : 0);
                originalEndEquivalentLineNumber = Math.max(lineChange.originalStartLineNumber, lineChange.originalEndLineNumber);
                modifiedEndEquivalentLineNumber = Math.max(lineChange.modifiedStartLineNumber, lineChange.modifiedEndLineNumber);
            }
            else {
                // Increase to very large value to get the producing tests of foreign view zones running
                originalEquivalentLineNumber += 10000000 + lineChangeOriginalLength;
                modifiedEquivalentLineNumber += 10000000 + lineChangeModifiedLength;
                originalEndEquivalentLineNumber = originalEquivalentLineNumber;
                modifiedEndEquivalentLineNumber = modifiedEquivalentLineNumber;
            }
            // Each step produces view zones, and after producing them, we try to cancel them out, to avoid empty-empty view zone cases
            var stepOriginal = [];
            var stepModified = [];
            // ---------------------------- PRODUCE VIEW ZONES
            // [PRODUCE] View zone(s) in original-side due to foreign view zone(s) in modified-side
            while (modifiedForeignVZ.current && modifiedForeignVZ.current.afterLineNumber <= modifiedEndEquivalentLineNumber) {
                var viewZoneLineNumber = void 0;
                if (modifiedForeignVZ.current.afterLineNumber <= modifiedEquivalentLineNumber) {
                    viewZoneLineNumber = originalEquivalentLineNumber - modifiedEquivalentLineNumber + modifiedForeignVZ.current.afterLineNumber;
                }
                else {
                    viewZoneLineNumber = originalEndEquivalentLineNumber;
                }
                stepOriginal.push({
                    afterLineNumber: viewZoneLineNumber,
                    heightInLines: modifiedForeignVZ.current.heightInLines,
                    domNode: null
                });
                modifiedForeignVZ.advance();
            }
            // [PRODUCE] View zone(s) in modified-side due to foreign view zone(s) in original-side
            while (originalForeignVZ.current && originalForeignVZ.current.afterLineNumber <= originalEndEquivalentLineNumber) {
                var viewZoneLineNumber = void 0;
                if (originalForeignVZ.current.afterLineNumber <= originalEquivalentLineNumber) {
                    viewZoneLineNumber = modifiedEquivalentLineNumber - originalEquivalentLineNumber + originalForeignVZ.current.afterLineNumber;
                }
                else {
                    viewZoneLineNumber = modifiedEndEquivalentLineNumber;
                }
                stepModified.push({
                    afterLineNumber: viewZoneLineNumber,
                    heightInLines: originalForeignVZ.current.heightInLines,
                    domNode: null
                });
                originalForeignVZ.advance();
            }
            if (lineChange !== null && isChangeOrInsert(lineChange)) {
                var r = this._produceOriginalFromDiff(lineChange, lineChangeOriginalLength, lineChangeModifiedLength);
                if (r) {
                    stepOriginal.push(r);
                }
            }
            if (lineChange !== null && isChangeOrDelete(lineChange)) {
                var r = this._produceModifiedFromDiff(lineChange, lineChangeOriginalLength, lineChangeModifiedLength);
                if (r) {
                    stepModified.push(r);
                }
            }
            // ---------------------------- END PRODUCE VIEW ZONES
            // ---------------------------- EMIT MINIMAL VIEW ZONES
            // [CANCEL & EMIT] Try to cancel view zones out
            var stepOriginalIndex = 0;
            var stepModifiedIndex = 0;
            stepOriginal = stepOriginal.sort(sortMyViewZones);
            stepModified = stepModified.sort(sortMyViewZones);
            while (stepOriginalIndex < stepOriginal.length && stepModifiedIndex < stepModified.length) {
                var original = stepOriginal[stepOriginalIndex];
                var modified = stepModified[stepModifiedIndex];
                var originalDelta = original.afterLineNumber - originalEquivalentLineNumber;
                var modifiedDelta = modified.afterLineNumber - modifiedEquivalentLineNumber;
                if (originalDelta < modifiedDelta) {
                    addAndCombineIfPossible(result.original, original);
                    stepOriginalIndex++;
                }
                else if (modifiedDelta < originalDelta) {
                    addAndCombineIfPossible(result.modified, modified);
                    stepModifiedIndex++;
                }
                else if (original.shouldNotShrink) {
                    addAndCombineIfPossible(result.original, original);
                    stepOriginalIndex++;
                }
                else if (modified.shouldNotShrink) {
                    addAndCombineIfPossible(result.modified, modified);
                    stepModifiedIndex++;
                }
                else {
                    if (original.heightInLines >= modified.heightInLines) {
                        // modified view zone gets removed
                        original.heightInLines -= modified.heightInLines;
                        stepModifiedIndex++;
                    }
                    else {
                        // original view zone gets removed
                        modified.heightInLines -= original.heightInLines;
                        stepOriginalIndex++;
                    }
                }
            }
            // [EMIT] Remaining original view zones
            while (stepOriginalIndex < stepOriginal.length) {
                addAndCombineIfPossible(result.original, stepOriginal[stepOriginalIndex]);
                stepOriginalIndex++;
            }
            // [EMIT] Remaining modified view zones
            while (stepModifiedIndex < stepModified.length) {
                addAndCombineIfPossible(result.modified, stepModified[stepModifiedIndex]);
                stepModifiedIndex++;
            }
            // ---------------------------- END EMIT MINIMAL VIEW ZONES
        }
        var ensureDomNode = function (z) {
            if (!z.domNode) {
                z.domNode = createFakeLinesDiv();
            }
        };
        result.original.forEach(ensureDomNode);
        result.modified.forEach(ensureDomNode);
        return result;
    };
    return ViewZonesComputer;
}());
function createDecoration(startLineNumber, startColumn, endLineNumber, endColumn, options) {
    return {
        range: new Range(startLineNumber, startColumn, endLineNumber, endColumn),
        options: options
    };
}
var DECORATIONS = {
    charDelete: ModelDecorationOptions.register({
        className: 'char-delete'
    }),
    charDeleteWholeLine: ModelDecorationOptions.register({
        className: 'char-delete',
        isWholeLine: true
    }),
    charInsert: ModelDecorationOptions.register({
        className: 'char-insert'
    }),
    charInsertWholeLine: ModelDecorationOptions.register({
        className: 'char-insert',
        isWholeLine: true
    }),
    lineInsert: ModelDecorationOptions.register({
        className: 'line-insert',
        marginClassName: 'line-insert',
        isWholeLine: true
    }),
    lineInsertWithSign: ModelDecorationOptions.register({
        className: 'line-insert',
        linesDecorationsClassName: 'insert-sign',
        marginClassName: 'line-insert',
        isWholeLine: true
    }),
    lineDelete: ModelDecorationOptions.register({
        className: 'line-delete',
        marginClassName: 'line-delete',
        isWholeLine: true
    }),
    lineDeleteWithSign: ModelDecorationOptions.register({
        className: 'line-delete',
        linesDecorationsClassName: 'delete-sign',
        marginClassName: 'line-delete',
        isWholeLine: true
    }),
    lineDeleteMargin: ModelDecorationOptions.register({
        marginClassName: 'line-delete',
    })
};
var DiffEdtorWidgetSideBySide = /** @class */ (function (_super) {
    __extends$1b(DiffEdtorWidgetSideBySide, _super);
    function DiffEdtorWidgetSideBySide(dataSource, enableSplitViewResizing) {
        var _this = _super.call(this, dataSource) || this;
        _this._disableSash = (enableSplitViewResizing === false);
        _this._sashRatio = null;
        _this._sashPosition = null;
        _this._sash = _this._register(new Sash(_this._dataSource.getContainerDomNode(), _this));
        if (_this._disableSash) {
            _this._sash.disable();
        }
        _this._sash.onDidStart(function () { return _this.onSashDragStart(); });
        _this._sash.onDidChange(function (e) { return _this.onSashDrag(e); });
        _this._sash.onDidEnd(function () { return _this.onSashDragEnd(); });
        _this._sash.onDidReset(function () { return _this.onSashReset(); });
        return _this;
    }
    DiffEdtorWidgetSideBySide.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
    };
    DiffEdtorWidgetSideBySide.prototype.setEnableSplitViewResizing = function (enableSplitViewResizing) {
        var newDisableSash = (enableSplitViewResizing === false);
        if (this._disableSash !== newDisableSash) {
            this._disableSash = newDisableSash;
            if (this._disableSash) {
                this._sash.disable();
            }
            else {
                this._sash.enable();
            }
        }
    };
    DiffEdtorWidgetSideBySide.prototype.layout = function (sashRatio) {
        if (sashRatio === void 0) { sashRatio = this._sashRatio; }
        var w = this._dataSource.getWidth();
        var contentWidth = w - DiffEditorWidget.ENTIRE_DIFF_OVERVIEW_WIDTH;
        var sashPosition = Math.floor((sashRatio || 0.5) * contentWidth);
        var midPoint = Math.floor(0.5 * contentWidth);
        sashPosition = this._disableSash ? midPoint : sashPosition || midPoint;
        if (contentWidth > DiffEdtorWidgetSideBySide.MINIMUM_EDITOR_WIDTH * 2) {
            if (sashPosition < DiffEdtorWidgetSideBySide.MINIMUM_EDITOR_WIDTH) {
                sashPosition = DiffEdtorWidgetSideBySide.MINIMUM_EDITOR_WIDTH;
            }
            if (sashPosition > contentWidth - DiffEdtorWidgetSideBySide.MINIMUM_EDITOR_WIDTH) {
                sashPosition = contentWidth - DiffEdtorWidgetSideBySide.MINIMUM_EDITOR_WIDTH;
            }
        }
        else {
            sashPosition = midPoint;
        }
        if (this._sashPosition !== sashPosition) {
            this._sashPosition = sashPosition;
            this._sash.layout();
        }
        return this._sashPosition;
    };
    DiffEdtorWidgetSideBySide.prototype.onSashDragStart = function () {
        this._startSashPosition = this._sashPosition;
    };
    DiffEdtorWidgetSideBySide.prototype.onSashDrag = function (e) {
        var w = this._dataSource.getWidth();
        var contentWidth = w - DiffEditorWidget.ENTIRE_DIFF_OVERVIEW_WIDTH;
        var sashPosition = this.layout((this._startSashPosition + (e.currentX - e.startX)) / contentWidth);
        this._sashRatio = sashPosition / contentWidth;
        this._dataSource.relayoutEditors();
    };
    DiffEdtorWidgetSideBySide.prototype.onSashDragEnd = function () {
        this._sash.layout();
    };
    DiffEdtorWidgetSideBySide.prototype.onSashReset = function () {
        this._sashRatio = 0.5;
        this._dataSource.relayoutEditors();
        this._sash.layout();
    };
    DiffEdtorWidgetSideBySide.prototype.getVerticalSashTop = function (sash) {
        return 0;
    };
    DiffEdtorWidgetSideBySide.prototype.getVerticalSashLeft = function (sash) {
        return this._sashPosition;
    };
    DiffEdtorWidgetSideBySide.prototype.getVerticalSashHeight = function (sash) {
        return this._dataSource.getHeight();
    };
    DiffEdtorWidgetSideBySide.prototype._getViewZones = function (lineChanges, originalForeignVZ, modifiedForeignVZ, originalEditor, modifiedEditor) {
        var c = new SideBySideViewZonesComputer(lineChanges, originalForeignVZ, modifiedForeignVZ);
        return c.getViewZones();
    };
    DiffEdtorWidgetSideBySide.prototype._getOriginalEditorDecorations = function (lineChanges, ignoreTrimWhitespace, renderIndicators, originalEditor, modifiedEditor) {
        var overviewZoneColor = this._removeColor.toString();
        var result = {
            decorations: [],
            overviewZones: []
        };
        var originalModel = originalEditor.getModel();
        for (var i = 0, length_5 = lineChanges.length; i < length_5; i++) {
            var lineChange = lineChanges[i];
            if (isChangeOrDelete(lineChange)) {
                result.decorations.push({
                    range: new Range(lineChange.originalStartLineNumber, 1, lineChange.originalEndLineNumber, Number.MAX_VALUE),
                    options: (renderIndicators ? DECORATIONS.lineDeleteWithSign : DECORATIONS.lineDelete)
                });
                if (!isChangeOrInsert(lineChange) || !lineChange.charChanges) {
                    result.decorations.push(createDecoration(lineChange.originalStartLineNumber, 1, lineChange.originalEndLineNumber, Number.MAX_VALUE, DECORATIONS.charDeleteWholeLine));
                }
                result.overviewZones.push(new OverviewRulerZone(lineChange.originalStartLineNumber, lineChange.originalEndLineNumber, overviewZoneColor));
                if (lineChange.charChanges) {
                    for (var j = 0, lengthJ = lineChange.charChanges.length; j < lengthJ; j++) {
                        var charChange = lineChange.charChanges[j];
                        if (isChangeOrDelete(charChange)) {
                            if (ignoreTrimWhitespace) {
                                for (var lineNumber = charChange.originalStartLineNumber; lineNumber <= charChange.originalEndLineNumber; lineNumber++) {
                                    var startColumn = void 0;
                                    var endColumn = void 0;
                                    if (lineNumber === charChange.originalStartLineNumber) {
                                        startColumn = charChange.originalStartColumn;
                                    }
                                    else {
                                        startColumn = originalModel.getLineFirstNonWhitespaceColumn(lineNumber);
                                    }
                                    if (lineNumber === charChange.originalEndLineNumber) {
                                        endColumn = charChange.originalEndColumn;
                                    }
                                    else {
                                        endColumn = originalModel.getLineLastNonWhitespaceColumn(lineNumber);
                                    }
                                    result.decorations.push(createDecoration(lineNumber, startColumn, lineNumber, endColumn, DECORATIONS.charDelete));
                                }
                            }
                            else {
                                result.decorations.push(createDecoration(charChange.originalStartLineNumber, charChange.originalStartColumn, charChange.originalEndLineNumber, charChange.originalEndColumn, DECORATIONS.charDelete));
                            }
                        }
                    }
                }
            }
        }
        return result;
    };
    DiffEdtorWidgetSideBySide.prototype._getModifiedEditorDecorations = function (lineChanges, ignoreTrimWhitespace, renderIndicators, originalEditor, modifiedEditor) {
        var overviewZoneColor = this._insertColor.toString();
        var result = {
            decorations: [],
            overviewZones: []
        };
        var modifiedModel = modifiedEditor.getModel();
        for (var i = 0, length_6 = lineChanges.length; i < length_6; i++) {
            var lineChange = lineChanges[i];
            if (isChangeOrInsert(lineChange)) {
                result.decorations.push({
                    range: new Range(lineChange.modifiedStartLineNumber, 1, lineChange.modifiedEndLineNumber, Number.MAX_VALUE),
                    options: (renderIndicators ? DECORATIONS.lineInsertWithSign : DECORATIONS.lineInsert)
                });
                if (!isChangeOrDelete(lineChange) || !lineChange.charChanges) {
                    result.decorations.push(createDecoration(lineChange.modifiedStartLineNumber, 1, lineChange.modifiedEndLineNumber, Number.MAX_VALUE, DECORATIONS.charInsertWholeLine));
                }
                result.overviewZones.push(new OverviewRulerZone(lineChange.modifiedStartLineNumber, lineChange.modifiedEndLineNumber, overviewZoneColor));
                if (lineChange.charChanges) {
                    for (var j = 0, lengthJ = lineChange.charChanges.length; j < lengthJ; j++) {
                        var charChange = lineChange.charChanges[j];
                        if (isChangeOrInsert(charChange)) {
                            if (ignoreTrimWhitespace) {
                                for (var lineNumber = charChange.modifiedStartLineNumber; lineNumber <= charChange.modifiedEndLineNumber; lineNumber++) {
                                    var startColumn = void 0;
                                    var endColumn = void 0;
                                    if (lineNumber === charChange.modifiedStartLineNumber) {
                                        startColumn = charChange.modifiedStartColumn;
                                    }
                                    else {
                                        startColumn = modifiedModel.getLineFirstNonWhitespaceColumn(lineNumber);
                                    }
                                    if (lineNumber === charChange.modifiedEndLineNumber) {
                                        endColumn = charChange.modifiedEndColumn;
                                    }
                                    else {
                                        endColumn = modifiedModel.getLineLastNonWhitespaceColumn(lineNumber);
                                    }
                                    result.decorations.push(createDecoration(lineNumber, startColumn, lineNumber, endColumn, DECORATIONS.charInsert));
                                }
                            }
                            else {
                                result.decorations.push(createDecoration(charChange.modifiedStartLineNumber, charChange.modifiedStartColumn, charChange.modifiedEndLineNumber, charChange.modifiedEndColumn, DECORATIONS.charInsert));
                            }
                        }
                    }
                }
            }
        }
        return result;
    };
    DiffEdtorWidgetSideBySide.MINIMUM_EDITOR_WIDTH = 100;
    return DiffEdtorWidgetSideBySide;
}(DiffEditorWidgetStyle));
var SideBySideViewZonesComputer = /** @class */ (function (_super) {
    __extends$1b(SideBySideViewZonesComputer, _super);
    function SideBySideViewZonesComputer(lineChanges, originalForeignVZ, modifiedForeignVZ) {
        return _super.call(this, lineChanges, originalForeignVZ, modifiedForeignVZ) || this;
    }
    SideBySideViewZonesComputer.prototype._produceOriginalFromDiff = function (lineChange, lineChangeOriginalLength, lineChangeModifiedLength) {
        if (lineChangeModifiedLength > lineChangeOriginalLength) {
            return {
                afterLineNumber: Math.max(lineChange.originalStartLineNumber, lineChange.originalEndLineNumber),
                heightInLines: (lineChangeModifiedLength - lineChangeOriginalLength),
                domNode: null
            };
        }
        return null;
    };
    SideBySideViewZonesComputer.prototype._produceModifiedFromDiff = function (lineChange, lineChangeOriginalLength, lineChangeModifiedLength) {
        if (lineChangeOriginalLength > lineChangeModifiedLength) {
            return {
                afterLineNumber: Math.max(lineChange.modifiedStartLineNumber, lineChange.modifiedEndLineNumber),
                heightInLines: (lineChangeOriginalLength - lineChangeModifiedLength),
                domNode: null
            };
        }
        return null;
    };
    return SideBySideViewZonesComputer;
}(ViewZonesComputer));
var DiffEdtorWidgetInline = /** @class */ (function (_super) {
    __extends$1b(DiffEdtorWidgetInline, _super);
    function DiffEdtorWidgetInline(dataSource, enableSplitViewResizing) {
        var _this = _super.call(this, dataSource) || this;
        _this.decorationsLeft = dataSource.getOriginalEditor().getLayoutInfo().decorationsLeft;
        _this._register(dataSource.getOriginalEditor().onDidLayoutChange(function (layoutInfo) {
            if (_this.decorationsLeft !== layoutInfo.decorationsLeft) {
                _this.decorationsLeft = layoutInfo.decorationsLeft;
                dataSource.relayoutEditors();
            }
        }));
        return _this;
    }
    DiffEdtorWidgetInline.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
    };
    DiffEdtorWidgetInline.prototype.setEnableSplitViewResizing = function (enableSplitViewResizing) {
        // Nothing to do..
    };
    DiffEdtorWidgetInline.prototype._getViewZones = function (lineChanges, originalForeignVZ, modifiedForeignVZ, originalEditor, modifiedEditor, renderIndicators) {
        var computer = new InlineViewZonesComputer(lineChanges, originalForeignVZ, modifiedForeignVZ, originalEditor, modifiedEditor, renderIndicators);
        return computer.getViewZones();
    };
    DiffEdtorWidgetInline.prototype._getOriginalEditorDecorations = function (lineChanges, ignoreTrimWhitespace, renderIndicators, originalEditor, modifiedEditor) {
        var overviewZoneColor = this._removeColor.toString();
        var result = {
            decorations: [],
            overviewZones: []
        };
        for (var i = 0, length_7 = lineChanges.length; i < length_7; i++) {
            var lineChange = lineChanges[i];
            // Add overview zones in the overview ruler
            if (isChangeOrDelete(lineChange)) {
                result.decorations.push({
                    range: new Range(lineChange.originalStartLineNumber, 1, lineChange.originalEndLineNumber, Number.MAX_VALUE),
                    options: DECORATIONS.lineDeleteMargin
                });
                result.overviewZones.push(new OverviewRulerZone(lineChange.originalStartLineNumber, lineChange.originalEndLineNumber, overviewZoneColor));
            }
        }
        return result;
    };
    DiffEdtorWidgetInline.prototype._getModifiedEditorDecorations = function (lineChanges, ignoreTrimWhitespace, renderIndicators, originalEditor, modifiedEditor) {
        var overviewZoneColor = this._insertColor.toString();
        var result = {
            decorations: [],
            overviewZones: []
        };
        var modifiedModel = modifiedEditor.getModel();
        for (var i = 0, length_8 = lineChanges.length; i < length_8; i++) {
            var lineChange = lineChanges[i];
            // Add decorations & overview zones
            if (isChangeOrInsert(lineChange)) {
                result.decorations.push({
                    range: new Range(lineChange.modifiedStartLineNumber, 1, lineChange.modifiedEndLineNumber, Number.MAX_VALUE),
                    options: (renderIndicators ? DECORATIONS.lineInsertWithSign : DECORATIONS.lineInsert)
                });
                result.overviewZones.push(new OverviewRulerZone(lineChange.modifiedStartLineNumber, lineChange.modifiedEndLineNumber, overviewZoneColor));
                if (lineChange.charChanges) {
                    for (var j = 0, lengthJ = lineChange.charChanges.length; j < lengthJ; j++) {
                        var charChange = lineChange.charChanges[j];
                        if (isChangeOrInsert(charChange)) {
                            if (ignoreTrimWhitespace) {
                                for (var lineNumber = charChange.modifiedStartLineNumber; lineNumber <= charChange.modifiedEndLineNumber; lineNumber++) {
                                    var startColumn = void 0;
                                    var endColumn = void 0;
                                    if (lineNumber === charChange.modifiedStartLineNumber) {
                                        startColumn = charChange.modifiedStartColumn;
                                    }
                                    else {
                                        startColumn = modifiedModel.getLineFirstNonWhitespaceColumn(lineNumber);
                                    }
                                    if (lineNumber === charChange.modifiedEndLineNumber) {
                                        endColumn = charChange.modifiedEndColumn;
                                    }
                                    else {
                                        endColumn = modifiedModel.getLineLastNonWhitespaceColumn(lineNumber);
                                    }
                                    result.decorations.push(createDecoration(lineNumber, startColumn, lineNumber, endColumn, DECORATIONS.charInsert));
                                }
                            }
                            else {
                                result.decorations.push(createDecoration(charChange.modifiedStartLineNumber, charChange.modifiedStartColumn, charChange.modifiedEndLineNumber, charChange.modifiedEndColumn, DECORATIONS.charInsert));
                            }
                        }
                    }
                }
                else {
                    result.decorations.push(createDecoration(lineChange.modifiedStartLineNumber, 1, lineChange.modifiedEndLineNumber, Number.MAX_VALUE, DECORATIONS.charInsertWholeLine));
                }
            }
        }
        return result;
    };
    DiffEdtorWidgetInline.prototype.layout = function () {
        // An editor should not be smaller than 5px
        return Math.max(5, this.decorationsLeft);
    };
    return DiffEdtorWidgetInline;
}(DiffEditorWidgetStyle));
var InlineViewZonesComputer = /** @class */ (function (_super) {
    __extends$1b(InlineViewZonesComputer, _super);
    function InlineViewZonesComputer(lineChanges, originalForeignVZ, modifiedForeignVZ, originalEditor, modifiedEditor, renderIndicators) {
        var _this = _super.call(this, lineChanges, originalForeignVZ, modifiedForeignVZ) || this;
        _this.originalModel = originalEditor.getModel();
        _this.modifiedEditorConfiguration = modifiedEditor.getConfiguration();
        _this.modifiedEditorTabSize = modifiedEditor.getModel().getOptions().tabSize;
        _this.renderIndicators = renderIndicators;
        return _this;
    }
    InlineViewZonesComputer.prototype._produceOriginalFromDiff = function (lineChange, lineChangeOriginalLength, lineChangeModifiedLength) {
        var marginDomNode = document.createElement('div');
        marginDomNode.className = 'inline-added-margin-view-zone';
        Configuration$1.applyFontInfoSlow(marginDomNode, this.modifiedEditorConfiguration.fontInfo);
        return {
            afterLineNumber: Math.max(lineChange.originalStartLineNumber, lineChange.originalEndLineNumber),
            heightInLines: lineChangeModifiedLength,
            domNode: document.createElement('div'),
            marginDomNode: marginDomNode
        };
    };
    InlineViewZonesComputer.prototype._produceModifiedFromDiff = function (lineChange, lineChangeOriginalLength, lineChangeModifiedLength) {
        var decorations = [];
        if (lineChange.charChanges) {
            for (var j = 0, lengthJ = lineChange.charChanges.length; j < lengthJ; j++) {
                var charChange = lineChange.charChanges[j];
                if (isChangeOrDelete(charChange)) {
                    decorations.push(new InlineDecoration(new Range(charChange.originalStartLineNumber, charChange.originalStartColumn, charChange.originalEndLineNumber, charChange.originalEndColumn), 'char-delete', 0 /* Regular */));
                }
            }
        }
        var sb = createStringBuilder(10000);
        var marginHTML = [];
        var lineDecorationsWidth = this.modifiedEditorConfiguration.layoutInfo.decorationsWidth;
        var lineHeight = this.modifiedEditorConfiguration.lineHeight;
        for (var lineNumber = lineChange.originalStartLineNumber; lineNumber <= lineChange.originalEndLineNumber; lineNumber++) {
            this.renderOriginalLine(lineNumber - lineChange.originalStartLineNumber, this.originalModel, this.modifiedEditorConfiguration, this.modifiedEditorTabSize, lineNumber, decorations, sb);
            if (this.renderIndicators) {
                var index = lineNumber - lineChange.originalStartLineNumber;
                marginHTML = marginHTML.concat([
                    "<div class=\"delete-sign\" style=\"position:absolute;top:" + index * lineHeight + "px;width:" + lineDecorationsWidth + "px;height:" + lineHeight + "px;right:0;\"></div>"
                ]);
            }
        }
        var domNode = document.createElement('div');
        domNode.className = 'view-lines line-delete';
        domNode.innerHTML = sb.build();
        Configuration$1.applyFontInfoSlow(domNode, this.modifiedEditorConfiguration.fontInfo);
        var marginDomNode = document.createElement('div');
        marginDomNode.className = 'inline-deleted-margin-view-zone';
        marginDomNode.innerHTML = marginHTML.join('');
        Configuration$1.applyFontInfoSlow(marginDomNode, this.modifiedEditorConfiguration.fontInfo);
        return {
            shouldNotShrink: true,
            afterLineNumber: (lineChange.modifiedEndLineNumber === 0 ? lineChange.modifiedStartLineNumber : lineChange.modifiedStartLineNumber - 1),
            heightInLines: lineChangeOriginalLength,
            domNode: domNode,
            marginDomNode: marginDomNode
        };
    };
    InlineViewZonesComputer.prototype.renderOriginalLine = function (count, originalModel, config, tabSize, lineNumber, decorations, sb) {
        var lineContent = originalModel.getLineContent(lineNumber);
        var actualDecorations = LineDecoration.filter(decorations, lineNumber, 1, lineContent.length + 1);
        var defaultMetadata = ((0 /* None */ << 11 /* FONT_STYLE_OFFSET */)
            | (1 /* DefaultForeground */ << 14 /* FOREGROUND_OFFSET */)
            | (2 /* DefaultBackground */ << 23 /* BACKGROUND_OFFSET */)) >>> 0;
        var tokens = new Uint32Array(2);
        tokens[0] = lineContent.length;
        tokens[1] = defaultMetadata;
        var lineTokens = new LineTokens(tokens, lineContent);
        sb.appendASCIIString('<div class="view-line');
        if (decorations.length === 0) {
            // No char changes
            sb.appendASCIIString(' char-delete');
        }
        sb.appendASCIIString('" style="top:');
        sb.appendASCIIString(String(count * config.lineHeight));
        sb.appendASCIIString('px;width:1000000px;">');
        var isBasicASCII$$1 = ViewLineRenderingData.isBasicASCII(lineContent, originalModel.mightContainNonBasicASCII());
        var containsRTL$$1 = ViewLineRenderingData.containsRTL(lineContent, isBasicASCII$$1, originalModel.mightContainRTL());
        renderViewLine(new RenderLineInput((config.fontInfo.isMonospace && !config.viewInfo.disableMonospaceOptimizations), lineContent, isBasicASCII$$1, containsRTL$$1, 0, lineTokens, actualDecorations, tabSize, config.fontInfo.spaceWidth, config.viewInfo.stopRenderingLineAfter, config.viewInfo.renderWhitespace, config.viewInfo.renderControlCharacters, config.viewInfo.fontLigatures), sb);
        sb.appendASCIIString('</div>');
    };
    return InlineViewZonesComputer;
}(ViewZonesComputer));
function isChangeOrInsert(lineChange) {
    return lineChange.modifiedEndLineNumber > 0;
}
function isChangeOrDelete(lineChange) {
    return lineChange.originalEndLineNumber > 0;
}
function createFakeLinesDiv() {
    var r = document.createElement('div');
    r.className = 'diagonal-fill';
    return r;
}
registerThemingParticipant(function (theme, collector) {
    var added = theme.getColor(diffInserted);
    if (added) {
        collector.addRule(".monaco-editor .line-insert, .monaco-editor .char-insert { background-color: " + added + "; }");
        collector.addRule(".monaco-diff-editor .line-insert, .monaco-diff-editor .char-insert { background-color: " + added + "; }");
        collector.addRule(".monaco-editor .inline-added-margin-view-zone { background-color: " + added + "; }");
    }
    var removed = theme.getColor(diffRemoved);
    if (removed) {
        collector.addRule(".monaco-editor .line-delete, .monaco-editor .char-delete { background-color: " + removed + "; }");
        collector.addRule(".monaco-diff-editor .line-delete, .monaco-diff-editor .char-delete { background-color: " + removed + "; }");
        collector.addRule(".monaco-editor .inline-deleted-margin-view-zone { background-color: " + removed + "; }");
    }
    var addedOutline = theme.getColor(diffInsertedOutline);
    if (addedOutline) {
        collector.addRule(".monaco-editor .line-insert, .monaco-editor .char-insert { border: 1px " + (theme.type === 'hc' ? 'dashed' : 'solid') + " " + addedOutline + "; }");
    }
    var removedOutline = theme.getColor(diffRemovedOutline);
    if (removedOutline) {
        collector.addRule(".monaco-editor .line-delete, .monaco-editor .char-delete { border: 1px " + (theme.type === 'hc' ? 'dashed' : 'solid') + " " + removedOutline + "; }");
    }
    var shadow = theme.getColor(scrollbarShadow);
    if (shadow) {
        collector.addRule(".monaco-diff-editor.side-by-side .editor.modified { box-shadow: -6px 0 5px -5px " + shadow + "; }");
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var IStandaloneThemeService = createDecorator('themeService');

const css$s = "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n.monaco-aria-container {\n\tposition: absolute; /* try to hide from window but not from screen readers */\n\tleft:-999em;\n}";
  const element$s = ((css, src) => {
if (typeof document !== 'object')
console.info(`Skipped loading "${src}"`);
try {
const id = src
  .replace(/\.css.*$/, '')
  .replace(/[\\:]/g, '/')
  .replace(/[^\w\/]+/g, '');
return (
  document.querySelector(`style[id="${id}"]`) ||
  document.head.appendChild(
    Object.assign(document.createElement('style'), {
      id,
      textContent: `${css}\n\n /* sourceURL=${src} */`,
    }),
  )
);
} catch (exception) {
console.warn(`Failed load "${src}"`, exception);
}
})(css$s, "…monaco-editor/esm/vs/base/browser/ui/aria/aria.css");
  //@ sourceURL=/Users/daflair/Projects/packages/monaco-es/node_modules/monaco-editor/esm/vs/base/browser/ui/aria/aria.css

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var ariaContainer;
var alertContainer;
var statusContainer;
function setARIAContainer(parent) {
    ariaContainer = document.createElement('div');
    ariaContainer.className = 'monaco-aria-container';
    alertContainer = document.createElement('div');
    alertContainer.className = 'monaco-alert';
    alertContainer.setAttribute('role', 'alert');
    alertContainer.setAttribute('aria-atomic', 'true');
    ariaContainer.appendChild(alertContainer);
    statusContainer = document.createElement('div');
    statusContainer.className = 'monaco-status';
    statusContainer.setAttribute('role', 'status');
    statusContainer.setAttribute('aria-atomic', 'true');
    ariaContainer.appendChild(statusContainer);
    parent.appendChild(ariaContainer);
}
/**
 * Given the provided message, will make sure that it is read as alert to screen readers.
 */
function alert(msg) {
    insertMessage(alertContainer, msg);
}
function insertMessage(target, msg) {
    if (!ariaContainer) {
        // console.warn('ARIA support needs a container. Call setARIAContainer() first.');
        return;
    }
    if (target.textContent === msg) {
        msg = localize('repeated', "{0} (occurred again)", msg);
    }
    clearNode(target);
    target.textContent = msg;
    // See https://www.paciellogroup.com/blog/2012/06/html5-accessibility-chops-aria-rolealert-browser-support/
    target.style.visibility = 'hidden';
    target.style.visibility = 'visible';
}

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$1c = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate$8 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$5 = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var LAST_GENERATED_COMMAND_ID = 0;
var ariaDomNodeCreated = false;
function createAriaDomNode() {
    if (ariaDomNodeCreated) {
        return;
    }
    ariaDomNodeCreated = true;
    setARIAContainer(document.body);
}
/**
 * A code editor to be used both by the standalone editor and the standalone diff editor.
 */
var StandaloneCodeEditor = /** @class */ (function (_super) {
    __extends$1c(StandaloneCodeEditor, _super);
    function StandaloneCodeEditor(domElement, options, instantiationService, codeEditorService, commandService, contextKeyService, keybindingService, themeService, notificationService) {
        var _this = this;
        options = options || {};
        options.ariaLabel = options.ariaLabel || localize('editorViewAccessibleLabel', "Editor content");
        options.ariaLabel = options.ariaLabel + ';' + (isIE
            ? localize('accessibilityHelpMessageIE', "Press Ctrl+F1 for Accessibility Options.")
            : localize('accessibilityHelpMessage', "Press Alt+F1 for Accessibility Options."));
        _this = _super.call(this, domElement, options, instantiationService, codeEditorService, commandService, contextKeyService, themeService, notificationService) || this;
        if (keybindingService instanceof StandaloneKeybindingService) {
            _this._standaloneKeybindingService = keybindingService;
        }
        // Create the ARIA dom node as soon as the first editor is instantiated
        createAriaDomNode();
        return _this;
    }
    StandaloneCodeEditor.prototype.addCommand = function (keybinding, handler, context) {
        if (!this._standaloneKeybindingService) {
            console.warn('Cannot add command because the editor is configured with an unrecognized KeybindingService');
            return null;
        }
        var commandId = 'DYNAMIC_' + (++LAST_GENERATED_COMMAND_ID);
        var whenExpression = ContextKeyExpr.deserialize(context);
        this._standaloneKeybindingService.addDynamicKeybinding(commandId, keybinding, handler, whenExpression);
        return commandId;
    };
    StandaloneCodeEditor.prototype.createContextKey = function (key, defaultValue) {
        return this._contextKeyService.createKey(key, defaultValue);
    };
    StandaloneCodeEditor.prototype.addAction = function (_descriptor) {
        var _this = this;
        if ((typeof _descriptor.id !== 'string') || (typeof _descriptor.label !== 'string') || (typeof _descriptor.run !== 'function')) {
            throw new Error('Invalid action descriptor, `id`, `label` and `run` are required properties!');
        }
        if (!this._standaloneKeybindingService) {
            console.warn('Cannot add keybinding because the editor is configured with an unrecognized KeybindingService');
            return empty$1;
        }
        // Read descriptor options
        var id = _descriptor.id;
        var label = _descriptor.label;
        var precondition = ContextKeyExpr.and(ContextKeyExpr.equals('editorId', this.getId()), ContextKeyExpr.deserialize(_descriptor.precondition));
        var keybindings = _descriptor.keybindings;
        var keybindingsWhen = ContextKeyExpr.and(precondition, ContextKeyExpr.deserialize(_descriptor.keybindingContext));
        var contextMenuGroupId = _descriptor.contextMenuGroupId || null;
        var contextMenuOrder = _descriptor.contextMenuOrder || 0;
        var run = function () {
            var r = _descriptor.run(_this);
            return r ? r : TPromise.as(void 0);
        };
        var toDispose = [];
        // Generate a unique id to allow the same descriptor.id across multiple editor instances
        var uniqueId = this.getId() + ':' + id;
        // Register the command
        toDispose.push(CommandsRegistry.registerCommand(uniqueId, run));
        // Register the context menu item
        if (contextMenuGroupId) {
            var menuItem = {
                command: {
                    id: uniqueId,
                    title: label
                },
                when: precondition,
                group: contextMenuGroupId,
                order: contextMenuOrder
            };
            toDispose.push(MenuRegistry.appendMenuItem(MenuId.EditorContext, menuItem));
        }
        // Register the keybindings
        if (Array.isArray(keybindings)) {
            toDispose = toDispose.concat(keybindings.map(function (kb) {
                return _this._standaloneKeybindingService.addDynamicKeybinding(uniqueId, kb, run, keybindingsWhen);
            }));
        }
        // Finally, register an internal editor action
        var internalAction = new InternalEditorAction(uniqueId, label, label, precondition, run, this._contextKeyService);
        // Store it under the original id, such that trigger with the original id will work
        this._actions[id] = internalAction;
        toDispose.push({
            dispose: function () {
                delete _this._actions[id];
            }
        });
        return combinedDisposable(toDispose);
    };
    StandaloneCodeEditor = __decorate$8([
        __param$5(2, IInstantiationService),
        __param$5(3, ICodeEditorService),
        __param$5(4, ICommandService),
        __param$5(5, IContextKeyService),
        __param$5(6, IKeybindingService),
        __param$5(7, IThemeService),
        __param$5(8, INotificationService)
    ], StandaloneCodeEditor);
    return StandaloneCodeEditor;
}(CodeEditor));
var StandaloneEditor = /** @class */ (function (_super) {
    __extends$1c(StandaloneEditor, _super);
    function StandaloneEditor(domElement, options, toDispose, instantiationService, codeEditorService, commandService, contextKeyService, keybindingService, contextViewService, themeService, notificationService) {
        var _this = this;
        options = options || {};
        if (typeof options.theme === 'string') {
            themeService.setTheme(options.theme);
        }
        var model = options.model;
        delete options.model;
        _this = _super.call(this, domElement, options, instantiationService, codeEditorService, commandService, contextKeyService, keybindingService, themeService, notificationService) || this;
        _this._contextViewService = contextViewService;
        _this._register(toDispose);
        if (typeof model === 'undefined') {
            model = self.monaco.editor.createModel(options.value || '', options.language || 'text/plain');
            _this._ownsModel = true;
        }
        else {
            _this._ownsModel = false;
        }
        _this._attachModel(model);
        if (model) {
            var e = {
                oldModelUrl: null,
                newModelUrl: model.uri
            };
            _this._onDidChangeModel.fire(e);
        }
        return _this;
    }
    StandaloneEditor.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
    };
    StandaloneEditor.prototype._attachModel = function (model) {
        _super.prototype._attachModel.call(this, model);
        if (this._view) {
            this._contextViewService.setContainer(this._view.domNode.domNode);
        }
    };
    StandaloneEditor.prototype._postDetachModelCleanup = function (detachedModel) {
        _super.prototype._postDetachModelCleanup.call(this, detachedModel);
        if (detachedModel && this._ownsModel) {
            detachedModel.dispose();
            this._ownsModel = false;
        }
    };
    StandaloneEditor = __decorate$8([
        __param$5(3, IInstantiationService),
        __param$5(4, ICodeEditorService),
        __param$5(5, ICommandService),
        __param$5(6, IContextKeyService),
        __param$5(7, IKeybindingService),
        __param$5(8, IContextViewService),
        __param$5(9, IStandaloneThemeService),
        __param$5(10, INotificationService)
    ], StandaloneEditor);
    return StandaloneEditor;
}(StandaloneCodeEditor));
var StandaloneDiffEditor = /** @class */ (function (_super) {
    __extends$1c(StandaloneDiffEditor, _super);
    function StandaloneDiffEditor(domElement, options, toDispose, instantiationService, contextKeyService, keybindingService, contextViewService, editorWorkerService, codeEditorService, themeService, notificationService) {
        var _this = this;
        options = options || {};
        if (typeof options.theme === 'string') {
            options.theme = themeService.setTheme(options.theme);
        }
        _this = _super.call(this, domElement, options, editorWorkerService, contextKeyService, instantiationService, codeEditorService, themeService, notificationService) || this;
        _this._contextViewService = contextViewService;
        _this._register(toDispose);
        _this._contextViewService.setContainer(_this._containerDomElement);
        return _this;
    }
    StandaloneDiffEditor.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
    };
    StandaloneDiffEditor.prototype._createInnerEditor = function (instantiationService, container, options) {
        return instantiationService.createInstance(StandaloneCodeEditor, container, options);
    };
    StandaloneDiffEditor.prototype.getOriginalEditor = function () {
        return _super.prototype.getOriginalEditor.call(this);
    };
    StandaloneDiffEditor.prototype.getModifiedEditor = function () {
        return _super.prototype.getModifiedEditor.call(this);
    };
    StandaloneDiffEditor.prototype.addCommand = function (keybinding, handler, context) {
        return this.getModifiedEditor().addCommand(keybinding, handler, context);
    };
    StandaloneDiffEditor.prototype.createContextKey = function (key, defaultValue) {
        return this.getModifiedEditor().createContextKey(key, defaultValue);
    };
    StandaloneDiffEditor.prototype.addAction = function (descriptor) {
        return this.getModifiedEditor().addAction(descriptor);
    };
    StandaloneDiffEditor = __decorate$8([
        __param$5(3, IInstantiationService),
        __param$5(4, IContextKeyService),
        __param$5(5, IKeybindingService),
        __param$5(6, IContextViewService),
        __param$5(7, IEditorWorkerService),
        __param$5(8, ICodeEditorService),
        __param$5(9, IStandaloneThemeService),
        __param$5(10, INotificationService)
    ], StandaloneDiffEditor);
    return StandaloneDiffEditor;
}(DiffEditorWidget));

const css$t = "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n.context-view .monaco-menu {\n\tmin-width: 130px;\n}\n";
  const element$t = ((css, src) => {
if (typeof document !== 'object')
console.info(`Skipped loading "${src}"`);
try {
const id = src
  .replace(/\.css.*$/, '')
  .replace(/[\\:]/g, '/')
  .replace(/[^\w\/]+/g, '');
return (
  document.querySelector(`style[id="${id}"]`) ||
  document.head.appendChild(
    Object.assign(document.createElement('style'), {
      id,
      textContent: `${css}\n\n /* sourceURL=${src} */`,
    }),
  )
);
} catch (exception) {
console.warn(`Failed load "${src}"`, exception);
}
})(css$t, "…monaco-editor/esm/vs/platform/contextview/browser/contextMenuHandler.css");
  //@ sourceURL=/Users/daflair/Projects/packages/monaco-es/node_modules/monaco-editor/esm/vs/platform/contextview/browser/contextMenuHandler.css

const css$u = "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n.monaco-menu .monaco-action-bar.vertical {\n\tmargin-left: 0;\n}\n\n.monaco-menu .monaco-action-bar.vertical .actions-container {\n\tdisplay: block;\n}\n\n.monaco-menu .monaco-action-bar.vertical .action-item {\n\tpadding: 0;\n\t-ms-transform: none;\n\t-webkit-transform: none;\n\t-moz-transform: none;\n\t-o-transform: none;\n\ttransform: none;\n\tdisplay: -ms-flexbox;\n\tdisplay: flex;\n}\n\n.monaco-menu .monaco-action-bar.vertical .action-item.active {\n\t-ms-transform: none;\n\t-webkit-transform: none;\n\t-moz-transform: none;\n\t-o-transform: none;\n\ttransform: none;\n}\n\n.monaco-menu .monaco-action-bar.vertical .action-item.focused {\n\tbackground-color: #E4E4E4;\n}\n\n.monaco-menu .monaco-action-bar.vertical .action-item:hover:not(.disabled) {\n\tbackground-color: #EEE;\n}\n\n.monaco-menu .monaco-action-bar.vertical .action-label {\n\t-ms-flex: 1 1 auto;\n\tflex: 1 1 auto;\n\ttext-decoration: none;\n\tpadding: 0.8em 1em;\n\tline-height: 1.1em;\n\tbackground: none;\n}\n\n.monaco-menu .monaco-action-bar.vertical .keybinding {\n\tdisplay: inline-block;\n\t-ms-flex: 2 1 auto;\n\tflex: 2 1 auto;\n\tpadding: 0.8em 1em;\n\tline-height: 1.1em;\n\tfont-size: 12px;\n\ttext-align: right;\n}\n\n.monaco-menu .monaco-action-bar.vertical .action-item.disabled .keybinding {\n\topacity: 0.4;\n}\n\n.monaco-menu .monaco-action-bar.vertical .action-label:not(.separator) {\n\tdisplay: inline-block;\n\t-webkit-box-sizing:\tborder-box;\n\t-o-box-sizing:\t\tborder-box;\n\t-moz-box-sizing:\tborder-box;\n\t-ms-box-sizing:\t\tborder-box;\n\tbox-sizing:\t\t\tborder-box;\n\tmargin: 0;\n}\n\n.monaco-menu .monaco-action-bar.vertical .action-label.separator {\n\tpadding: 0.5em 0 0 0;\n\tmargin-bottom: 0.5em;\n\twidth: 100%;\n}\n\n.monaco-menu .monaco-action-bar.vertical .action-label.separator.text {\n\tpadding: 0.7em 1em 0.1em 1em;\n\tfont-weight: bold;\n\topacity: 1;\n}\n\n.monaco-menu .monaco-action-bar.vertical .action-label:hover {\n\tcolor: inherit;\n}\n\n/* Context Menu */\n\n.context-view.monaco-menu-container {\n\tfont-family: \"Segoe WPC\", \"Segoe UI\", \".SFNSDisplay-Light\", \"SFUIText-Light\", \"HelveticaNeue-Light\", sans-serif, \"Droid Sans Fallback\";\n\toutline: 0;\n\tbox-shadow: 0 2px 8px #A8A8A8;\n\tborder: none;\n\tcolor: #646465;\n\tbackground-color: white;\n\t-webkit-animation: fadeIn 0.083s linear;\n\t-o-animation: fadeIn 0.083s linear;\n\t-moz-animation: fadeIn 0.083s linear;\n\t-ms-animation: fadeIn 0.083s linear;\n\tanimation: fadeIn 0.083s linear;\n}\n\n.context-view.monaco-menu-container :focus {\n\toutline: 0;\n}\n\n/* Dark theme */\n.vs-dark .monaco-menu .monaco-action-bar.vertical .action-item.focused {\n\tbackground-color: #4B4C4D;\n}\n\n.vs-dark .monaco-menu .monaco-action-bar.vertical .action-item:hover:not(.disabled) {\n\tbackground-color: #3A3A3A;\n}\n\n.vs-dark .context-view.monaco-menu-container {\n\tbox-shadow: 0 2px 8px #000;\n\tcolor: #BBB;\n\tbackground-color: #2D2F31;\n}\n\n/* High Contrast Theming */\n.hc-black .context-view.monaco-menu-container {\n\tborder: 2px solid #6FC3DF;\n\tcolor: white;\n\tbackground-color: #0C141F;\n\tbox-shadow: none;\n}\n\n.hc-black .monaco-menu .monaco-action-bar.vertical .action-item.focused {\n\tbackground: none;\n\tborder: 1px dotted #f38518;\n}\n\n.hc-black .monaco-menu .monaco-action-bar.vertical .action-item:hover:not(.disabled) {\n\tbackground: none;\n\tborder: 1px dashed #f38518;\n}";
  const element$u = ((css, src) => {
if (typeof document !== 'object')
console.info(`Skipped loading "${src}"`);
try {
const id = src
  .replace(/\.css.*$/, '')
  .replace(/[\\:]/g, '/')
  .replace(/[^\w\/]+/g, '');
return (
  document.querySelector(`style[id="${id}"]`) ||
  document.head.appendChild(
    Object.assign(document.createElement('style'), {
      id,
      textContent: `${css}\n\n /* sourceURL=${src} */`,
    }),
  )
);
} catch (exception) {
console.warn(`Failed load "${src}"`, exception);
}
})(css$u, "…monaco-editor/esm/vs/base/browser/ui/menu/menu.css");
  //@ sourceURL=/Users/daflair/Projects/packages/monaco-es/node_modules/monaco-editor/esm/vs/base/browser/ui/menu/menu.css

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var Menu$1 = /** @class */ (function () {
    function Menu(container, actions, options) {
        if (options === void 0) { options = {}; }
        addClass(container, 'monaco-menu-container');
        var menuContainer = document.createElement('div');
        addClass(menuContainer, 'monaco-menu');
        container.appendChild(menuContainer);
        this.actionBar = new ActionBar(menuContainer, {
            orientation: ActionsOrientation.VERTICAL,
            actionItemProvider: options.actionItemProvider,
            context: options.context,
            actionRunner: options.actionRunner,
            isMenu: true
        });
        this.actionBar.push(actions, { icon: true, label: true });
    }
    Object.defineProperty(Menu.prototype, "onDidCancel", {
        get: function () {
            return this.actionBar.onDidCancel;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Menu.prototype, "onDidBlur", {
        get: function () {
            return this.actionBar.onDidBlur;
        },
        enumerable: true,
        configurable: true
    });
    Menu.prototype.focus = function () {
        this.actionBar.focus(true);
    };
    Menu.prototype.dispose = function () {
        if (this.actionBar) {
            this.actionBar.dispose();
            this.actionBar = null;
        }
        if (this.listener) {
            this.listener.dispose();
            this.listener = null;
        }
    };
    return Menu;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var ContextMenuHandler = /** @class */ (function () {
    function ContextMenuHandler(element, contextViewService, telemetryService, notificationService) {
        var _this = this;
        this.setContainer(element);
        this.contextViewService = contextViewService;
        this.telemetryService = telemetryService;
        this.notificationService = notificationService;
        this.actionRunner = new ActionRunner();
        this.menuContainerElement = null;
        this.toDispose = [];
        var hideViewOnRun = false;
        this.toDispose.push(this.actionRunner.onDidBeforeRun(function (e) {
            if (_this.telemetryService) {
                /* __GDPR__
                    "workbenchActionExecuted" : {
                        "id" : { "classification": "SystemMetaData", "purpose": "FeatureInsight" },
                        "from": { "classification": "SystemMetaData", "purpose": "FeatureInsight" }
                    }
                */
                _this.telemetryService.publicLog('workbenchActionExecuted', { id: e.action.id, from: 'contextMenu' });
            }
            hideViewOnRun = !!e.retainActionItem;
            if (!hideViewOnRun) {
                _this.contextViewService.hideContextView(false);
            }
        }));
        this.toDispose.push(this.actionRunner.onDidRun(function (e) {
            if (hideViewOnRun) {
                _this.contextViewService.hideContextView(false);
            }
            hideViewOnRun = false;
            if (e.error && _this.notificationService) {
                _this.notificationService.error(e.error);
            }
        }));
    }
    ContextMenuHandler.prototype.setContainer = function (container) {
        var _this = this;
        if (this.$el) {
            this.$el.off(['click', 'mousedown']);
            this.$el = null;
        }
        if (container) {
            this.$el = $$1(container);
            this.$el.on('mousedown', function (e) { return _this.onMouseDown(e); });
        }
    };
    ContextMenuHandler.prototype.showContextMenu = function (delegate) {
        var _this = this;
        delegate.getActions().done(function (actions) {
            _this.contextViewService.showContextView({
                getAnchor: function () { return delegate.getAnchor(); },
                canRelayout: false,
                render: function (container) {
                    _this.menuContainerElement = container;
                    var className = delegate.getMenuClassName ? delegate.getMenuClassName() : '';
                    if (className) {
                        container.className += ' ' + className;
                    }
                    var menu = new Menu$1(container, actions, {
                        actionItemProvider: delegate.getActionItem,
                        context: delegate.getActionsContext ? delegate.getActionsContext() : null,
                        actionRunner: _this.actionRunner
                    });
                    var listener1 = menu.onDidCancel(function () {
                        _this.contextViewService.hideContextView(true);
                    });
                    var listener2 = menu.onDidBlur(function () {
                        _this.contextViewService.hideContextView(true);
                    });
                    menu.focus();
                    return combinedDisposable([listener1, listener2, menu]);
                },
                onHide: function (didCancel) {
                    if (delegate.onHide) {
                        delegate.onHide(didCancel);
                    }
                    _this.menuContainerElement = null;
                }
            });
        });
    };
    ContextMenuHandler.prototype.onMouseDown = function (e) {
        if (!this.menuContainerElement) {
            return;
        }
        var event = new StandardMouseEvent(e);
        var element = event.target;
        while (element) {
            if (element === this.menuContainerElement) {
                return;
            }
            element = element.parentElement;
        }
        this.contextViewService.hideContextView();
    };
    ContextMenuHandler.prototype.dispose = function () {
        this.setContainer(null);
    };
    return ContextMenuHandler;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var ContextMenuService = /** @class */ (function () {
    function ContextMenuService(container, telemetryService, notificationService, contextViewService) {
        this._onDidContextMenu = new Emitter();
        this.contextMenuHandler = new ContextMenuHandler(container, contextViewService, telemetryService, notificationService);
    }
    ContextMenuService.prototype.dispose = function () {
        this.contextMenuHandler.dispose();
    };
    ContextMenuService.prototype.setContainer = function (container) {
        this.contextMenuHandler.setContainer(container);
    };
    // ContextMenu
    ContextMenuService.prototype.showContextMenu = function (delegate) {
        this.contextMenuHandler.showContextMenu(delegate);
        this._onDidContextMenu.fire();
    };
    Object.defineProperty(ContextMenuService.prototype, "onDidContextMenu", {
        get: function () {
            return this._onDidContextMenu.event;
        },
        enumerable: true,
        configurable: true
    });
    return ContextMenuService;
}());

const css$v = "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n.context-view {\n\tposition: absolute;\n\tz-index: 1000;\n}";
  const element$v = ((css, src) => {
if (typeof document !== 'object')
console.info(`Skipped loading "${src}"`);
try {
const id = src
  .replace(/\.css.*$/, '')
  .replace(/[\\:]/g, '/')
  .replace(/[^\w\/]+/g, '');
return (
  document.querySelector(`style[id="${id}"]`) ||
  document.head.appendChild(
    Object.assign(document.createElement('style'), {
      id,
      textContent: `${css}\n\n /* sourceURL=${src} */`,
    }),
  )
);
} catch (exception) {
console.warn(`Failed load "${src}"`, exception);
}
})(css$v, "…monaco-editor/esm/vs/base/browser/ui/contextview/contextview.css");
  //@ sourceURL=/Users/daflair/Projects/packages/monaco-es/node_modules/monaco-editor/esm/vs/base/browser/ui/contextview/contextview.css

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var AnchorAlignment;
(function (AnchorAlignment) {
    AnchorAlignment[AnchorAlignment["LEFT"] = 0] = "LEFT";
    AnchorAlignment[AnchorAlignment["RIGHT"] = 1] = "RIGHT";
})(AnchorAlignment || (AnchorAlignment = {}));
var AnchorPosition;
(function (AnchorPosition) {
    AnchorPosition[AnchorPosition["BELOW"] = 0] = "BELOW";
    AnchorPosition[AnchorPosition["ABOVE"] = 1] = "ABOVE";
})(AnchorPosition || (AnchorPosition = {}));
function layout(view, around, viewport, anchorPosition, anchorAlignment) {
    var chooseBiased = function (a, aIsGood, b, bIsGood) {
        if (aIsGood) {
            return a;
        }
        if (bIsGood) {
            return b;
        }
        return a;
    };
    var chooseOne = function (a, aIsGood, b, bIsGood, aIsPreferred) {
        if (aIsPreferred) {
            return chooseBiased(a, aIsGood, b, bIsGood);
        }
        else {
            return chooseBiased(b, bIsGood, a, aIsGood);
        }
    };
    var top = (function () {
        // Compute both options (putting the segment above and below)
        var posAbove = around.top - view.height;
        var posBelow = around.top + around.height;
        // Check for both options if they are good
        var aboveIsGood = (posAbove >= viewport.top && posAbove + view.height <= viewport.top + viewport.height);
        var belowIsGood = (posBelow >= viewport.top && posBelow + view.height <= viewport.top + viewport.height);
        return chooseOne(posAbove, aboveIsGood, posBelow, belowIsGood, anchorPosition === AnchorPosition.ABOVE);
    })();
    var left = (function () {
        // Compute both options (aligning left and right)
        var posLeft = around.left;
        var posRight = around.left + around.width - view.width;
        // Check for both options if they are good
        var leftIsGood = (posLeft >= viewport.left && posLeft + view.width <= viewport.left + viewport.width);
        var rightIsGood = (posRight >= viewport.left && posRight + view.width <= viewport.left + viewport.width);
        return chooseOne(posLeft, leftIsGood, posRight, rightIsGood, anchorAlignment === AnchorAlignment.LEFT);
    })();
    return { top: top, left: left };
}
var ContextView = /** @class */ (function () {
    function ContextView(container) {
        var _this = this;
        this.$view = $$1('.context-view').hide();
        this.setContainer(container);
        this.toDispose = [{
                dispose: function () {
                    _this.setContainer(null);
                }
            }];
        this.toDisposeOnClean = null;
    }
    ContextView.prototype.setContainer = function (container) {
        var _this = this;
        if (this.$container) {
            this.$container.getHTMLElement().removeChild(this.$view.getHTMLElement());
            this.$container.off(ContextView.BUBBLE_UP_EVENTS);
            this.$container.off(ContextView.BUBBLE_DOWN_EVENTS, true);
            this.$container = null;
        }
        if (container) {
            this.$container = $$1(container);
            this.$view.appendTo(this.$container);
            this.$container.on(ContextView.BUBBLE_UP_EVENTS, function (e) {
                _this.onDOMEvent(e, document.activeElement, false);
            });
            this.$container.on(ContextView.BUBBLE_DOWN_EVENTS, function (e) {
                _this.onDOMEvent(e, document.activeElement, true);
            }, null, true);
        }
    };
    ContextView.prototype.show = function (delegate) {
        if (this.isVisible()) {
            this.hide();
        }
        // Show static box
        this.$view.setClass('context-view').empty().style({ top: '0px', left: '0px' }).show();
        // Render content
        this.toDisposeOnClean = delegate.render(this.$view.getHTMLElement());
        // Set active delegate
        this.delegate = delegate;
        // Layout
        this.doLayout();
    };
    ContextView.prototype.layout = function () {
        if (!this.isVisible()) {
            return;
        }
        if (this.delegate.canRelayout === false) {
            this.hide();
            return;
        }
        if (this.delegate.layout) {
            this.delegate.layout();
        }
        this.doLayout();
    };
    ContextView.prototype.doLayout = function () {
        // Get anchor
        var anchor = this.delegate.getAnchor();
        // Compute around
        var around;
        // Get the element's position and size (to anchor the view)
        if (isHTMLElement(anchor)) {
            var elementPosition = getDomNodePagePosition(anchor);
            around = {
                top: elementPosition.top,
                left: elementPosition.left,
                width: elementPosition.width,
                height: elementPosition.height
            };
        }
        else {
            var realAnchor = anchor;
            around = {
                top: realAnchor.y,
                left: realAnchor.x,
                width: realAnchor.width || 0,
                height: realAnchor.height || 0
            };
        }
        var viewport = {
            top: StandardWindow.scrollY,
            left: StandardWindow.scrollX,
            height: window.innerHeight,
            width: window.innerWidth
        };
        // Get the view's size
        var viewSize = this.$view.getTotalSize();
        var view = { width: viewSize.width, height: viewSize.height };
        var anchorPosition = this.delegate.anchorPosition || AnchorPosition.BELOW;
        var anchorAlignment = this.delegate.anchorAlignment || AnchorAlignment.LEFT;
        var result = layout(view, around, viewport, anchorPosition, anchorAlignment);
        var containerPosition = getDomNodePagePosition(this.$container.getHTMLElement());
        result.top -= containerPosition.top;
        result.left -= containerPosition.left;
        this.$view.removeClass('top', 'bottom', 'left', 'right');
        this.$view.addClass(anchorPosition === AnchorPosition.BELOW ? 'bottom' : 'top');
        this.$view.addClass(anchorAlignment === AnchorAlignment.LEFT ? 'left' : 'right');
        this.$view.style({ top: result.top + 'px', left: result.left + 'px', width: 'initial' });
    };
    ContextView.prototype.hide = function (data) {
        if (this.delegate && this.delegate.onHide) {
            this.delegate.onHide(data);
        }
        this.delegate = null;
        if (this.toDisposeOnClean) {
            this.toDisposeOnClean.dispose();
            this.toDisposeOnClean = null;
        }
        this.$view.hide();
    };
    ContextView.prototype.isVisible = function () {
        return !!this.delegate;
    };
    ContextView.prototype.onDOMEvent = function (e, element, onCapture) {
        if (this.delegate) {
            if (this.delegate.onDOMEvent) {
                this.delegate.onDOMEvent(e, document.activeElement);
            }
            else if (onCapture && !isAncestor(e.target, this.$container.getHTMLElement())) {
                this.hide();
            }
        }
    };
    ContextView.prototype.dispose = function () {
        this.hide();
        this.toDispose = dispose(this.toDispose);
    };
    ContextView.BUBBLE_UP_EVENTS = ['click', 'keydown', 'focus', 'blur'];
    ContextView.BUBBLE_DOWN_EVENTS = ['click'];
    return ContextView;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$1d = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var ILogService = createDecorator('logService');
var LogLevel;
(function (LogLevel) {
    LogLevel[LogLevel["Trace"] = 0] = "Trace";
    LogLevel[LogLevel["Debug"] = 1] = "Debug";
    LogLevel[LogLevel["Info"] = 2] = "Info";
    LogLevel[LogLevel["Warning"] = 3] = "Warning";
    LogLevel[LogLevel["Error"] = 4] = "Error";
    LogLevel[LogLevel["Critical"] = 5] = "Critical";
    LogLevel[LogLevel["Off"] = 6] = "Off";
})(LogLevel || (LogLevel = {}));
var DEFAULT_LOG_LEVEL = LogLevel.Info;
var AbstractLogService = /** @class */ (function (_super) {
    __extends$1d(AbstractLogService, _super);
    function AbstractLogService() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.level = DEFAULT_LOG_LEVEL;
        _this._onDidChangeLogLevel = _this._register(new Emitter());
        _this.onDidChangeLogLevel = _this._onDidChangeLogLevel.event;
        return _this;
    }
    AbstractLogService.prototype.setLevel = function (level) {
        if (this.level !== level) {
            this.level = level;
            this._onDidChangeLogLevel.fire(this.level);
        }
    };
    AbstractLogService.prototype.getLevel = function () {
        return this.level;
    };
    return AbstractLogService;
}(Disposable));
var ConsoleLogMainService = /** @class */ (function (_super) {
    __extends$1d(ConsoleLogMainService, _super);
    function ConsoleLogMainService(logLevel) {
        if (logLevel === void 0) { logLevel = DEFAULT_LOG_LEVEL; }
        var _this = _super.call(this) || this;
        _this.setLevel(logLevel);
        _this.useColors = !isWindows;
        return _this;
    }
    ConsoleLogMainService.prototype.trace = function (message) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        if (this.getLevel() <= LogLevel.Trace) {
            if (this.useColors) {
                console.log.apply(console, ["\u001B[90m[main " + new Date().toLocaleTimeString() + "]\u001B[0m", message].concat(args));
            }
            else {
                console.log.apply(console, ["[main " + new Date().toLocaleTimeString() + "]", message].concat(args));
            }
        }
    };
    ConsoleLogMainService.prototype.debug = function (message) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        if (this.getLevel() <= LogLevel.Debug) {
            if (this.useColors) {
                console.log.apply(console, ["\u001B[90m[main " + new Date().toLocaleTimeString() + "]\u001B[0m", message].concat(args));
            }
            else {
                console.log.apply(console, ["[main " + new Date().toLocaleTimeString() + "]", message].concat(args));
            }
        }
    };
    ConsoleLogMainService.prototype.info = function (message) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        if (this.getLevel() <= LogLevel.Info) {
            if (this.useColors) {
                console.log.apply(console, ["\u001B[90m[main " + new Date().toLocaleTimeString() + "]\u001B[0m", message].concat(args));
            }
            else {
                console.log.apply(console, ["[main " + new Date().toLocaleTimeString() + "]", message].concat(args));
            }
        }
    };
    ConsoleLogMainService.prototype.warn = function (message) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        if (this.getLevel() <= LogLevel.Warning) {
            if (this.useColors) {
                console.warn.apply(console, ["\u001B[93m[main " + new Date().toLocaleTimeString() + "]\u001B[0m", message].concat(args));
            }
            else {
                console.warn.apply(console, ["[main " + new Date().toLocaleTimeString() + "]", message].concat(args));
            }
        }
    };
    ConsoleLogMainService.prototype.error = function (message) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        if (this.getLevel() <= LogLevel.Error) {
            if (this.useColors) {
                console.error.apply(console, ["\u001B[91m[main " + new Date().toLocaleTimeString() + "]\u001B[0m", message].concat(args));
            }
            else {
                console.error.apply(console, ["[main " + new Date().toLocaleTimeString() + "]", message].concat(args));
            }
        }
    };
    ConsoleLogMainService.prototype.critical = function (message) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        if (this.getLevel() <= LogLevel.Critical) {
            if (this.useColors) {
                console.error.apply(console, ["\u001B[90m[main " + new Date().toLocaleTimeString() + "]\u001B[0m", message].concat(args));
            }
            else {
                console.error.apply(console, ["[main " + new Date().toLocaleTimeString() + "]", message].concat(args));
            }
        }
    };
    ConsoleLogMainService.prototype.dispose = function () {
        // noop
    };
    return ConsoleLogMainService;
}(AbstractLogService));
var ConsoleLogService = /** @class */ (function (_super) {
    __extends$1d(ConsoleLogService, _super);
    function ConsoleLogService(logLevel) {
        if (logLevel === void 0) { logLevel = DEFAULT_LOG_LEVEL; }
        var _this = _super.call(this) || this;
        _this.setLevel(logLevel);
        return _this;
    }
    ConsoleLogService.prototype.trace = function (message) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        if (this.getLevel() <= LogLevel.Trace) {
            console.log.apply(console, ['%cTRACE', 'color: #888', message].concat(args));
        }
    };
    ConsoleLogService.prototype.debug = function (message) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        if (this.getLevel() <= LogLevel.Debug) {
            console.log.apply(console, ['%cDEBUG', 'background: #eee; color: #888', message].concat(args));
        }
    };
    ConsoleLogService.prototype.info = function (message) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        if (this.getLevel() <= LogLevel.Info) {
            console.log.apply(console, ['%c INFO', 'color: #33f', message].concat(args));
        }
    };
    ConsoleLogService.prototype.warn = function (message) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        if (this.getLevel() <= LogLevel.Warning) {
            console.log.apply(console, ['%c WARN', 'color: #993', message].concat(args));
        }
    };
    ConsoleLogService.prototype.error = function (message) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        if (this.getLevel() <= LogLevel.Error) {
            console.log.apply(console, ['%c  ERR', 'color: #f33', message].concat(args));
        }
    };
    ConsoleLogService.prototype.critical = function (message) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        if (this.getLevel() <= LogLevel.Critical) {
            console.log.apply(console, ['%cCRITI', 'background: #f33; color: white', message].concat(args));
        }
    };
    ConsoleLogService.prototype.dispose = function () { };
    return ConsoleLogService;
}(AbstractLogService));
var MultiplexLogService = /** @class */ (function (_super) {
    __extends$1d(MultiplexLogService, _super);
    function MultiplexLogService(logServices) {
        var _this = _super.call(this) || this;
        _this.logServices = logServices;
        if (logServices.length) {
            _this.setLevel(logServices[0].getLevel());
        }
        return _this;
    }
    MultiplexLogService.prototype.setLevel = function (level) {
        for (var _i = 0, _a = this.logServices; _i < _a.length; _i++) {
            var logService = _a[_i];
            logService.setLevel(level);
        }
        _super.prototype.setLevel.call(this, level);
    };
    MultiplexLogService.prototype.trace = function (message) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        for (var _a = 0, _b = this.logServices; _a < _b.length; _a++) {
            var logService = _b[_a];
            logService.trace.apply(logService, [message].concat(args));
        }
    };
    MultiplexLogService.prototype.debug = function (message) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        for (var _a = 0, _b = this.logServices; _a < _b.length; _a++) {
            var logService = _b[_a];
            logService.debug.apply(logService, [message].concat(args));
        }
    };
    MultiplexLogService.prototype.info = function (message) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        for (var _a = 0, _b = this.logServices; _a < _b.length; _a++) {
            var logService = _b[_a];
            logService.info.apply(logService, [message].concat(args));
        }
    };
    MultiplexLogService.prototype.warn = function (message) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        for (var _a = 0, _b = this.logServices; _a < _b.length; _a++) {
            var logService = _b[_a];
            logService.warn.apply(logService, [message].concat(args));
        }
    };
    MultiplexLogService.prototype.error = function (message) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        for (var _a = 0, _b = this.logServices; _a < _b.length; _a++) {
            var logService = _b[_a];
            logService.error.apply(logService, [message].concat(args));
        }
    };
    MultiplexLogService.prototype.critical = function (message) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        for (var _a = 0, _b = this.logServices; _a < _b.length; _a++) {
            var logService = _b[_a];
            logService.critical.apply(logService, [message].concat(args));
        }
    };
    MultiplexLogService.prototype.dispose = function () {
        for (var _i = 0, _a = this.logServices; _i < _a.length; _i++) {
            var logService = _a[_i];
            logService.dispose();
        }
    };
    return MultiplexLogService;
}(AbstractLogService));
var DelegatedLogService = /** @class */ (function (_super) {
    __extends$1d(DelegatedLogService, _super);
    function DelegatedLogService(logService) {
        var _this = _super.call(this) || this;
        _this.logService = logService;
        _this._register(logService);
        return _this;
    }
    Object.defineProperty(DelegatedLogService.prototype, "onDidChangeLogLevel", {
        get: function () {
            return this.logService.onDidChangeLogLevel;
        },
        enumerable: true,
        configurable: true
    });
    DelegatedLogService.prototype.setLevel = function (level) {
        this.logService.setLevel(level);
    };
    DelegatedLogService.prototype.getLevel = function () {
        return this.logService.getLevel();
    };
    DelegatedLogService.prototype.trace = function (message) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        (_a = this.logService).trace.apply(_a, [message].concat(args));
        var _a;
    };
    DelegatedLogService.prototype.debug = function (message) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        (_a = this.logService).debug.apply(_a, [message].concat(args));
        var _a;
    };
    DelegatedLogService.prototype.info = function (message) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        (_a = this.logService).info.apply(_a, [message].concat(args));
        var _a;
    };
    DelegatedLogService.prototype.warn = function (message) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        (_a = this.logService).warn.apply(_a, [message].concat(args));
        var _a;
    };
    DelegatedLogService.prototype.error = function (message) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        (_a = this.logService).error.apply(_a, [message].concat(args));
        var _a;
    };
    DelegatedLogService.prototype.critical = function (message) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        (_a = this.logService).critical.apply(_a, [message].concat(args));
        var _a;
    };
    return DelegatedLogService;
}(Disposable));
var NullLogService = /** @class */ (function () {
    function NullLogService() {
        this.onDidChangeLogLevel = new Emitter().event;
    }
    NullLogService.prototype.setLevel = function (level) { };
    NullLogService.prototype.getLevel = function () { return LogLevel.Info; };
    NullLogService.prototype.trace = function (message) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
    };
    NullLogService.prototype.debug = function (message) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
    };
    NullLogService.prototype.info = function (message) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
    };
    NullLogService.prototype.warn = function (message) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
    };
    NullLogService.prototype.error = function (message) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
    };
    NullLogService.prototype.critical = function (message) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
    };
    NullLogService.prototype.dispose = function () { };
    return NullLogService;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __decorate$9 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$6 = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var ContextViewService = /** @class */ (function () {
    function ContextViewService(container, telemetryService, logService) {
        this.logService = logService;
        this.contextView = new ContextView(container);
    }
    ContextViewService.prototype.dispose = function () {
        this.contextView.dispose();
    };
    // ContextView
    ContextViewService.prototype.setContainer = function (container) {
        this.logService.trace('ContextViewService#setContainer');
        this.contextView.setContainer(container);
    };
    ContextViewService.prototype.showContextView = function (delegate) {
        this.logService.trace('ContextViewService#showContextView');
        this.contextView.show(delegate);
    };
    ContextViewService.prototype.layout = function () {
        this.contextView.layout();
    };
    ContextViewService.prototype.hideContextView = function (data) {
        this.logService.trace('ContextViewService#hideContextView');
        this.contextView.hide(data);
    };
    ContextViewService = __decorate$9([
        __param$6(1, ITelemetryService),
        __param$6(2, ILogService)
    ], ContextViewService);
    return ContextViewService;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var hasOwnProperty$1 = Object.prototype.hasOwnProperty;
/**
 * Iterates over each entry in the provided set. The iterator allows
 * to remove elements and will stop when the callback returns {{false}}.
 */
function forEach(from, callback) {
    var _loop_1 = function (key) {
        if (hasOwnProperty$1.call(from, key)) {
            var result = callback({ key: key, value: from[key] }, function () {
                delete from[key];
            });
            if (result === false) {
                return { value: void 0 };
            }
        }
    };
    for (var key in from) {
        var state_1 = _loop_1(key);
        if (typeof state_1 === "object")
            return state_1.value;
    }
}

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
function newNode(data) {
    return {
        data: data,
        incoming: Object.create(null),
        outgoing: Object.create(null)
    };
}
var Graph = /** @class */ (function () {
    function Graph(_hashFn) {
        this._hashFn = _hashFn;
        this._nodes = Object.create(null);
        // empty
    }
    Graph.prototype.roots = function () {
        var ret = [];
        forEach(this._nodes, function (entry) {
            if (isEmptyObject(entry.value.outgoing)) {
                ret.push(entry.value);
            }
        });
        return ret;
    };
    Graph.prototype.traverse = function (start, inwards, callback) {
        var startNode = this.lookup(start);
        if (!startNode) {
            return;
        }
        this._traverse(startNode, inwards, Object.create(null), callback);
    };
    Graph.prototype._traverse = function (node, inwards, seen, callback) {
        var _this = this;
        var key = this._hashFn(node.data);
        if (seen[key]) {
            return;
        }
        seen[key] = true;
        callback(node.data);
        var nodes = inwards ? node.outgoing : node.incoming;
        forEach(nodes, function (entry) { return _this._traverse(entry.value, inwards, seen, callback); });
    };
    Graph.prototype.insertEdge = function (from, to) {
        var fromNode = this.lookupOrInsertNode(from), toNode = this.lookupOrInsertNode(to);
        fromNode.outgoing[this._hashFn(to)] = toNode;
        toNode.incoming[this._hashFn(from)] = fromNode;
    };
    Graph.prototype.removeNode = function (data) {
        var key = this._hashFn(data);
        delete this._nodes[key];
        forEach(this._nodes, function (entry) {
            delete entry.value.outgoing[key];
            delete entry.value.incoming[key];
        });
    };
    Graph.prototype.lookupOrInsertNode = function (data) {
        var key = this._hashFn(data);
        var node = this._nodes[key];
        if (!node) {
            node = newNode(data);
            this._nodes[key] = node;
        }
        return node;
    };
    Graph.prototype.lookup = function (data) {
        return this._nodes[this._hashFn(data)];
    };
    Object.defineProperty(Graph.prototype, "length", {
        get: function () {
            return Object.keys(this._nodes).length;
        },
        enumerable: true,
        configurable: true
    });
    Graph.prototype.toString = function () {
        var data = [];
        forEach(this._nodes, function (entry) {
            data.push(entry.key + ", (incoming)[" + Object.keys(entry.value.incoming).join(', ') + "], (outgoing)[" + Object.keys(entry.value.outgoing).join(',') + "]");
        });
        return data.join('\n');
    };
    return Graph;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var InstantiationService = /** @class */ (function () {
    function InstantiationService(services, strict) {
        if (services === void 0) { services = new ServiceCollection(); }
        if (strict === void 0) { strict = false; }
        this._services = services;
        this._strict = strict;
        this._services.set(IInstantiationService, this);
    }
    InstantiationService.prototype.createChild = function (services) {
        var _this = this;
        this._services.forEach(function (id, thing) {
            if (services.has(id)) {
                return;
            }
            // If we copy descriptors we might end up with
            // multiple instances of the same service
            if (thing instanceof SyncDescriptor) {
                thing = _this._createAndCacheServiceInstance(id, thing);
            }
            services.set(id, thing);
        });
        return new InstantiationService(services, this._strict);
    };
    InstantiationService.prototype.invokeFunction = function (signature) {
        var _this = this;
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        var accessor;
        try {
            accessor = {
                get: function (id, isOptional) {
                    var result = _this._getOrCreateServiceInstance(id);
                    if (!result && isOptional !== optional) {
                        throw new Error("[invokeFunction] unkown service '" + id + "'");
                    }
                    return result;
                }
            };
            return signature.apply(undefined, [accessor].concat(args));
        }
        finally {
            accessor.get = function () {
                throw illegalState('service accessor is only valid during the invocation of its target method');
            };
        }
    };
    InstantiationService.prototype.createInstance = function (param) {
        var rest = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            rest[_i - 1] = arguments[_i];
        }
        if (param instanceof SyncDescriptor) {
            // sync
            return this._createInstance(param, rest);
        }
        else {
            // sync, just ctor
            return this._createInstance(new SyncDescriptor(param), rest);
        }
    };
    InstantiationService.prototype._createInstance = function (desc, args) {
        // arguments given by createInstance-call and/or the descriptor
        var staticArgs = desc.staticArguments.concat(args);
        // arguments defined by service decorators
        var serviceDependencies = _util.getServiceDependencies(desc.ctor).sort(function (a, b) { return a.index - b.index; });
        var serviceArgs = [];
        for (var _i = 0, serviceDependencies_1 = serviceDependencies; _i < serviceDependencies_1.length; _i++) {
            var dependency = serviceDependencies_1[_i];
            var service = this._getOrCreateServiceInstance(dependency.id);
            if (!service && this._strict && !dependency.optional) {
                throw new Error("[createInstance] " + desc.ctor.name + " depends on UNKNOWN service " + dependency.id + ".");
            }
            serviceArgs.push(service);
        }
        var firstServiceArgPos = serviceDependencies.length > 0 ? serviceDependencies[0].index : staticArgs.length;
        // check for argument mismatches, adjust static args if needed
        if (staticArgs.length !== firstServiceArgPos) {
            console.warn("[createInstance] First service dependency of " + desc.ctor.name + " at position " + (firstServiceArgPos + 1) + " conflicts with " + staticArgs.length + " static arguments");
            var delta = firstServiceArgPos - staticArgs.length;
            if (delta > 0) {
                staticArgs = staticArgs.concat(new Array(delta));
            }
            else {
                staticArgs = staticArgs.slice(0, firstServiceArgPos);
            }
        }
        // // check for missing args
        // for (let i = 0; i < serviceArgs.length; i++) {
        // 	if (!serviceArgs[i]) {
        // 		console.warn(`${desc.ctor.name} MISSES service dependency ${serviceDependencies[i].id}`, new Error().stack);
        // 	}
        // }
        // now create the instance
        var argArray = [desc.ctor];
        argArray.push.apply(argArray, staticArgs);
        argArray.push.apply(argArray, serviceArgs);
        return create.apply(null, argArray);
    };
    InstantiationService.prototype._getOrCreateServiceInstance = function (id) {
        var thing = this._services.get(id);
        if (thing instanceof SyncDescriptor) {
            return this._createAndCacheServiceInstance(id, thing);
        }
        else {
            return thing;
        }
    };
    InstantiationService.prototype._createAndCacheServiceInstance = function (id, desc) {
        ok(this._services.get(id) instanceof SyncDescriptor);
        var graph = new Graph(function (data) { return data.id.toString(); });
        function throwCycleError() {
            var err = new Error('[createInstance] cyclic dependency between services');
            err.message = graph.toString();
            throw err;
        }
        var count = 0;
        var stack = [{ id: id, desc: desc }];
        while (stack.length) {
            var item = stack.pop();
            graph.lookupOrInsertNode(item);
            // TODO@joh use the graph to find a cycle
            // a weak heuristic for cycle checks
            if (count++ > 100) {
                throwCycleError();
            }
            // check all dependencies for existence and if the need to be created first
            var dependencies = _util.getServiceDependencies(item.desc.ctor);
            for (var _i = 0, dependencies_1 = dependencies; _i < dependencies_1.length; _i++) {
                var dependency = dependencies_1[_i];
                var instanceOrDesc = this._services.get(dependency.id);
                if (!instanceOrDesc) {
                    console.warn("[createInstance] " + id + " depends on " + dependency.id + " which is NOT registered.");
                }
                if (instanceOrDesc instanceof SyncDescriptor) {
                    var d = { id: dependency.id, desc: instanceOrDesc };
                    graph.insertEdge(item, d);
                    stack.push(d);
                }
            }
        }
        while (true) {
            var roots = graph.roots();
            // if there is no more roots but still
            // nodes in the graph we have a cycle
            if (roots.length === 0) {
                if (graph.length !== 0) {
                    throwCycleError();
                }
                break;
            }
            for (var _a = 0, roots_1 = roots; _a < roots_1.length; _a++) {
                var root = roots_1[_a];
                // create instance and overwrite the service collections
                var instance = this._createInstance(root.data.desc, []);
                this._services.set(root.data.id, instance);
                graph.removeNode(root.data);
            }
        }
        return this._services.get(id);
    };
    return InstantiationService;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var MarkerSeverity;
(function (MarkerSeverity) {
    MarkerSeverity[MarkerSeverity["Hint"] = 1] = "Hint";
    MarkerSeverity[MarkerSeverity["Info"] = 2] = "Info";
    MarkerSeverity[MarkerSeverity["Warning"] = 4] = "Warning";
    MarkerSeverity[MarkerSeverity["Error"] = 8] = "Error";
})(MarkerSeverity || (MarkerSeverity = {}));
(function (MarkerSeverity) {
    function compare$$1(a, b) {
        return b - a;
    }
    MarkerSeverity.compare = compare$$1;
    var _displayStrings = Object.create(null);
    _displayStrings[MarkerSeverity.Error] = localize('sev.error', "Error");
    _displayStrings[MarkerSeverity.Warning] = localize('sev.warning', "Warning");
    _displayStrings[MarkerSeverity.Info] = localize('sev.info', "Info");
    function toString(a) {
        return _displayStrings[a] || '';
    }
    MarkerSeverity.toString = toString;
    function fromSeverity(severity) {
        switch (severity) {
            case Severity$1.Error: return MarkerSeverity.Error;
            case Severity$1.Warning: return MarkerSeverity.Warning;
            case Severity$1.Info: return MarkerSeverity.Info;
            case Severity$1.Ignore: return MarkerSeverity.Hint;
        }
    }
    MarkerSeverity.fromSeverity = fromSeverity;
})(MarkerSeverity || (MarkerSeverity = {}));
var IMarkerData;
(function (IMarkerData) {
    var emptyString = '';
    function makeKey(markerData) {
        var result = [emptyString];
        if (markerData.source) {
            result.push(markerData.source.replace('¦', '\¦'));
        }
        else {
            result.push(emptyString);
        }
        if (markerData.code) {
            result.push(markerData.code.replace('¦', '\¦'));
        }
        else {
            result.push(emptyString);
        }
        if (markerData.severity !== void 0 && markerData.severity !== null) {
            result.push(MarkerSeverity.toString(markerData.severity));
        }
        else {
            result.push(emptyString);
        }
        if (markerData.message) {
            result.push(markerData.message.replace('¦', '\¦'));
        }
        else {
            result.push(emptyString);
        }
        if (markerData.startLineNumber !== void 0 && markerData.startLineNumber !== null) {
            result.push(markerData.startLineNumber.toString());
        }
        else {
            result.push(emptyString);
        }
        if (markerData.startColumn !== void 0 && markerData.startColumn !== null) {
            result.push(markerData.startColumn.toString());
        }
        else {
            result.push(emptyString);
        }
        if (markerData.endLineNumber !== void 0 && markerData.endLineNumber !== null) {
            result.push(markerData.endLineNumber.toString());
        }
        else {
            result.push(emptyString);
        }
        if (markerData.endColumn !== void 0 && markerData.endColumn !== null) {
            result.push(markerData.endColumn.toString());
        }
        else {
            result.push(emptyString);
        }
        result.push(emptyString);
        return result.join('¦');
    }
    IMarkerData.makeKey = makeKey;
})(IMarkerData || (IMarkerData = {}));
var IMarkerService = createDecorator('markerService');

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var MapMap;
(function (MapMap) {
    function get(map, key1, key2) {
        if (map[key1]) {
            return map[key1][key2];
        }
        return undefined;
    }
    MapMap.get = get;
    function set(map, key1, key2, value) {
        if (!map[key1]) {
            map[key1] = Object.create(null);
        }
        map[key1][key2] = value;
    }
    MapMap.set = set;
    function remove(map, key1, key2) {
        if (map[key1] && map[key1][key2]) {
            delete map[key1][key2];
            if (isEmptyObject(map[key1])) {
                delete map[key1];
            }
            return true;
        }
        return false;
    }
    MapMap.remove = remove;
})(MapMap || (MapMap = {}));
var MarkerStats = /** @class */ (function () {
    function MarkerStats(service) {
        this.errors = 0;
        this.infos = 0;
        this.warnings = 0;
        this.unknowns = 0;
        this._data = Object.create(null);
        this._service = service;
        this._subscription = service.onMarkerChanged(this._update, this);
    }
    MarkerStats.prototype.dispose = function () {
        this._subscription.dispose();
        this._data = undefined;
    };
    MarkerStats.prototype._update = function (resources) {
        for (var _i = 0, resources_1 = resources; _i < resources_1.length; _i++) {
            var resource = resources_1[_i];
            var key = resource.toString();
            var oldStats = this._data[key];
            if (oldStats) {
                this._substract(oldStats);
            }
            var newStats = this._resourceStats(resource);
            this._add(newStats);
            this._data[key] = newStats;
        }
    };
    MarkerStats.prototype._resourceStats = function (resource) {
        var result = { errors: 0, warnings: 0, infos: 0, unknowns: 0 };
        // TODO this is a hack
        if (resource.scheme === Schemas.inMemory || resource.scheme === Schemas.walkThrough || resource.scheme === Schemas.walkThroughSnippet) {
            return result;
        }
        for (var _i = 0, _a = this._service.read({ resource: resource }); _i < _a.length; _i++) {
            var severity = _a[_i].severity;
            if (severity === MarkerSeverity.Error) {
                result.errors += 1;
            }
            else if (severity === MarkerSeverity.Warning) {
                result.warnings += 1;
            }
            else if (severity === MarkerSeverity.Info) {
                result.infos += 1;
            }
            else {
                result.unknowns += 1;
            }
        }
        return result;
    };
    MarkerStats.prototype._substract = function (op) {
        this.errors -= op.errors;
        this.warnings -= op.warnings;
        this.infos -= op.infos;
        this.unknowns -= op.unknowns;
    };
    MarkerStats.prototype._add = function (op) {
        this.errors += op.errors;
        this.warnings += op.warnings;
        this.infos += op.infos;
        this.unknowns += op.unknowns;
    };
    return MarkerStats;
}());
var MarkerService = /** @class */ (function () {
    function MarkerService() {
        this._onMarkerChanged = new Emitter();
        this._onMarkerChangedEvent = debounceEvent(this._onMarkerChanged.event, MarkerService._debouncer, 0);
        this._byResource = Object.create(null);
        this._byOwner = Object.create(null);
        this._stats = new MarkerStats(this);
    }
    MarkerService.prototype.dispose = function () {
        this._stats.dispose();
    };
    Object.defineProperty(MarkerService.prototype, "onMarkerChanged", {
        get: function () {
            return this._onMarkerChangedEvent;
        },
        enumerable: true,
        configurable: true
    });
    MarkerService.prototype.getStatistics = function () {
        return this._stats;
    };
    MarkerService.prototype.remove = function (owner, resources) {
        if (!isFalsyOrEmpty(resources)) {
            for (var _i = 0, resources_2 = resources; _i < resources_2.length; _i++) {
                var resource = resources_2[_i];
                this.changeOne(owner, resource, undefined);
            }
        }
    };
    MarkerService.prototype.changeOne = function (owner, resource, markerData) {
        if (isFalsyOrEmpty(markerData)) {
            // remove marker for this (owner,resource)-tuple
            var a = MapMap.remove(this._byResource, resource.toString(), owner);
            var b = MapMap.remove(this._byOwner, owner, resource.toString());
            if (a !== b) {
                throw new Error('invalid marker service state');
            }
            if (a && b) {
                this._onMarkerChanged.fire([resource]);
            }
        }
        else {
            // insert marker for this (owner,resource)-tuple
            var markers = [];
            for (var _i = 0, markerData_1 = markerData; _i < markerData_1.length; _i++) {
                var data = markerData_1[_i];
                var marker = MarkerService._toMarker(owner, resource, data);
                if (marker) {
                    markers.push(marker);
                }
            }
            MapMap.set(this._byResource, resource.toString(), owner, markers);
            MapMap.set(this._byOwner, owner, resource.toString(), markers);
            this._onMarkerChanged.fire([resource]);
        }
    };
    MarkerService._toMarker = function (owner, resource, data) {
        var code = data.code, severity = data.severity, message = data.message, source = data.source, startLineNumber = data.startLineNumber, startColumn = data.startColumn, endLineNumber = data.endLineNumber, endColumn = data.endColumn, relatedInformation = data.relatedInformation;
        if (!message) {
            return undefined;
        }
        // santize data
        code = code || null;
        startLineNumber = startLineNumber > 0 ? startLineNumber : 1;
        startColumn = startColumn > 0 ? startColumn : 1;
        endLineNumber = endLineNumber >= startLineNumber ? endLineNumber : startLineNumber;
        endColumn = endColumn > 0 ? endColumn : startColumn;
        return {
            resource: resource,
            owner: owner,
            code: code,
            severity: severity,
            message: message,
            source: source,
            startLineNumber: startLineNumber,
            startColumn: startColumn,
            endLineNumber: endLineNumber,
            endColumn: endColumn,
            relatedInformation: relatedInformation
        };
    };
    MarkerService.prototype.changeAll = function (owner, data) {
        var changes = [];
        var map = this._byOwner[owner];
        // remove old marker
        if (map) {
            delete this._byOwner[owner];
            for (var resource in map) {
                // remeber what we remove
                var first$$1 = MapMap.get(this._byResource, resource, owner)[0];
                if (first$$1) {
                    changes.push(first$$1.resource);
                }
                // actual remove
                MapMap.remove(this._byResource, resource, owner);
            }
        }
        // add new markers
        if (!isFalsyOrEmpty(data)) {
            // group by resource
            var groups = Object.create(null);
            for (var _i = 0, data_1 = data; _i < data_1.length; _i++) {
                var _a = data_1[_i], resource = _a.resource, markerData = _a.marker;
                var marker = MarkerService._toMarker(owner, resource, markerData);
                if (!marker) {
                    // filter bad markers
                    continue;
                }
                var array = groups[resource.toString()];
                if (!array) {
                    groups[resource.toString()] = [marker];
                    changes.push(resource);
                }
                else {
                    array.push(marker);
                }
            }
            // insert all
            for (var resource in groups) {
                MapMap.set(this._byResource, resource, owner, groups[resource]);
                MapMap.set(this._byOwner, owner, resource, groups[resource]);
            }
        }
        if (changes.length > 0) {
            this._onMarkerChanged.fire(changes);
        }
    };
    MarkerService.prototype.read = function (filter) {
        if (filter === void 0) { filter = Object.create(null); }
        var owner = filter.owner, resource = filter.resource, severities = filter.severities, take = filter.take;
        if (!take || take < 0) {
            take = -1;
        }
        if (owner && resource) {
            // exactly one owner AND resource
            var data = MapMap.get(this._byResource, resource.toString(), owner);
            if (!data) {
                return [];
            }
            else {
                var result = [];
                for (var _i = 0, data_2 = data; _i < data_2.length; _i++) {
                    var marker = data_2[_i];
                    if (MarkerService._accept(marker, severities)) {
                        var newLen = result.push(marker);
                        if (take > 0 && newLen === take) {
                            break;
                        }
                    }
                }
                return result;
            }
        }
        else if (!owner && !resource) {
            // all
            var result = [];
            for (var key1 in this._byResource) {
                for (var key2 in this._byResource[key1]) {
                    for (var _a = 0, _b = this._byResource[key1][key2]; _a < _b.length; _a++) {
                        var data = _b[_a];
                        if (MarkerService._accept(data, severities)) {
                            var newLen = result.push(data);
                            if (take > 0 && newLen === take) {
                                return result;
                            }
                        }
                    }
                }
            }
            return result;
        }
        else {
            // of one resource OR owner
            var map = owner
                ? this._byOwner[owner]
                : this._byResource[resource.toString()];
            if (!map) {
                return [];
            }
            var result = [];
            for (var key in map) {
                for (var _c = 0, _d = map[key]; _c < _d.length; _c++) {
                    var data = _d[_c];
                    if (MarkerService._accept(data, severities)) {
                        var newLen = result.push(data);
                        if (take > 0 && newLen === take) {
                            return result;
                        }
                    }
                }
            }
            return result;
        }
    };
    MarkerService._accept = function (marker, severities) {
        return severities === void 0 || (severities & marker.severity) === marker.severity;
    };
    MarkerService._debouncer = function (last, event) {
        if (!last) {
            MarkerService._dedupeMap = Object.create(null);
            last = [];
        }
        for (var _i = 0, event_1 = event; _i < event_1.length; _i++) {
            var uri = event_1[_i];
            if (MarkerService._dedupeMap[uri.toString()] === void 0) {
                MarkerService._dedupeMap[uri.toString()] = true;
                last.push(uri);
            }
        }
        return last;
    };
    return MarkerService;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var IProgressService = createDecorator('progressService');
var emptyProgressRunner = Object.freeze({
    total: function () { },
    worked: function () { },
    done: function () { }
});
var emptyProgress = Object.freeze({ report: function () { } });
var Progress = /** @class */ (function () {
    function Progress(callback) {
        this._callback = callback;
    }
    Object.defineProperty(Progress.prototype, "value", {
        get: function () {
            return this._value;
        },
        enumerable: true,
        configurable: true
    });
    Progress.prototype.report = function (item) {
        this._value = item;
        this._callback(this._value);
    };
    return Progress;
}());
var ProgressLocation;
(function (ProgressLocation) {
    ProgressLocation[ProgressLocation["Explorer"] = 1] = "Explorer";
    ProgressLocation[ProgressLocation["Scm"] = 3] = "Scm";
    ProgressLocation[ProgressLocation["Extensions"] = 5] = "Extensions";
    ProgressLocation[ProgressLocation["Window"] = 10] = "Window";
    ProgressLocation[ProgressLocation["Notification"] = 15] = "Notification";
})(ProgressLocation || (ProgressLocation = {}));
var IProgressService2 = createDecorator('progressService2');

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
function getWorker(workerId, label) {
    // Option for hosts to overwrite the worker script (used in the standalone editor)
    if (globals.MonacoEnvironment) {
        if (typeof globals.MonacoEnvironment.getWorker === 'function') {
            return globals.MonacoEnvironment.getWorker(workerId, label);
        }
        if (typeof globals.MonacoEnvironment.getWorkerUrl === 'function') {
            return new Worker(globals.MonacoEnvironment.getWorkerUrl(workerId, label));
        }
    }
    // ESM-comment-begin
    // 	if (typeof require === 'function') {
    // 		return new Worker(require.toUrl('./' + workerId) + '#' + label);
    // 	}
    // ESM-comment-end
    throw new Error("You must define a function MonacoEnvironment.getWorkerUrl or MonacoEnvironment.getWorker");
}
/**
 * A worker that uses HTML5 web workers so that is has
 * its own global scope and its own thread.
 */
var WebWorker = /** @class */ (function () {
    function WebWorker(moduleId, id, label, onMessageCallback, onErrorCallback) {
        this.id = id;
        this.worker = getWorker('workerMain.js', label);
        this.postMessage(moduleId);
        this.worker.onmessage = function (ev) {
            onMessageCallback(ev.data);
        };
        if (typeof this.worker.addEventListener === 'function') {
            this.worker.addEventListener('error', onErrorCallback);
        }
    }
    WebWorker.prototype.getId = function () {
        return this.id;
    };
    WebWorker.prototype.postMessage = function (msg) {
        if (this.worker) {
            this.worker.postMessage(msg);
        }
    };
    WebWorker.prototype.dispose = function () {
        this.worker.terminate();
        this.worker = null;
    };
    return WebWorker;
}());
var DefaultWorkerFactory = /** @class */ (function () {
    function DefaultWorkerFactory(label) {
        this._label = label;
        this._webWorkerFailedBeforeError = false;
    }
    DefaultWorkerFactory.prototype.create = function (moduleId, onMessageCallback, onErrorCallback) {
        var _this = this;
        var workerId = (++DefaultWorkerFactory.LAST_WORKER_ID);
        if (this._webWorkerFailedBeforeError) {
            throw this._webWorkerFailedBeforeError;
        }
        return new WebWorker(moduleId, workerId, this._label || 'anonymous' + workerId, onMessageCallback, function (err) {
            logOnceWebWorkerWarning(err);
            _this._webWorkerFailedBeforeError = err;
            onErrorCallback(err);
        });
    };
    DefaultWorkerFactory.LAST_WORKER_ID = 0;
    return DefaultWorkerFactory;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var ITextResourceConfigurationService = createDecorator('textResourceConfigurationService');

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$1e = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate$a = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$7 = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
/**
 * Stop syncing a model to the worker if it was not needed for 1 min.
 */
var STOP_SYNC_MODEL_DELTA_TIME_MS = 60 * 1000;
/**
 * Stop the worker if it was not needed for 5 min.
 */
var STOP_WORKER_DELTA_TIME_MS = 5 * 60 * 1000;
function canSyncModel(modelService, resource) {
    var model = modelService.getModel(resource);
    if (!model) {
        return false;
    }
    if (model.isTooLargeForTokenization()) {
        return false;
    }
    return true;
}
var EditorWorkerServiceImpl = /** @class */ (function (_super) {
    __extends$1e(EditorWorkerServiceImpl, _super);
    function EditorWorkerServiceImpl(modelService, configurationService) {
        var _this = _super.call(this) || this;
        _this._modelService = modelService;
        _this._workerManager = _this._register(new WorkerManager(_this._modelService));
        // todo@joh make sure this happens only once
        _this._register(LinkProviderRegistry.register('*', {
            provideLinks: function (model, token) {
                if (!canSyncModel(_this._modelService, model.uri)) {
                    return TPromise.as([]); // File too large
                }
                return wireCancellationToken(token, _this._workerManager.withWorker().then(function (client) { return client.computeLinks(model.uri); }));
            }
        }));
        _this._register(SuggestRegistry.register('*', new WordBasedCompletionItemProvider(_this._workerManager, configurationService, _this._modelService)));
        return _this;
    }
    EditorWorkerServiceImpl.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
    };
    EditorWorkerServiceImpl.prototype.canComputeDiff = function (original, modified) {
        return (canSyncModel(this._modelService, original) && canSyncModel(this._modelService, modified));
    };
    EditorWorkerServiceImpl.prototype.computeDiff = function (original, modified, ignoreTrimWhitespace) {
        return this._workerManager.withWorker().then(function (client) { return client.computeDiff(original, modified, ignoreTrimWhitespace); });
    };
    EditorWorkerServiceImpl.prototype.canComputeDirtyDiff = function (original, modified) {
        return (canSyncModel(this._modelService, original) && canSyncModel(this._modelService, modified));
    };
    EditorWorkerServiceImpl.prototype.computeDirtyDiff = function (original, modified, ignoreTrimWhitespace) {
        return this._workerManager.withWorker().then(function (client) { return client.computeDirtyDiff(original, modified, ignoreTrimWhitespace); });
    };
    EditorWorkerServiceImpl.prototype.computeMoreMinimalEdits = function (resource, edits) {
        if (!Array.isArray(edits) || edits.length === 0) {
            return TPromise.as(edits);
        }
        else {
            if (!canSyncModel(this._modelService, resource)) {
                return TPromise.as(edits); // File too large
            }
            return this._workerManager.withWorker().then(function (client) { return client.computeMoreMinimalEdits(resource, edits); });
        }
    };
    EditorWorkerServiceImpl.prototype.canNavigateValueSet = function (resource) {
        return (canSyncModel(this._modelService, resource));
    };
    EditorWorkerServiceImpl.prototype.navigateValueSet = function (resource, range, up) {
        return this._workerManager.withWorker().then(function (client) { return client.navigateValueSet(resource, range, up); });
    };
    EditorWorkerServiceImpl = __decorate$a([
        __param$7(0, IModelService),
        __param$7(1, ITextResourceConfigurationService)
    ], EditorWorkerServiceImpl);
    return EditorWorkerServiceImpl;
}(Disposable));
var WordBasedCompletionItemProvider = /** @class */ (function () {
    function WordBasedCompletionItemProvider(workerManager, configurationService, modelService) {
        this._workerManager = workerManager;
        this._configurationService = configurationService;
        this._modelService = modelService;
    }
    WordBasedCompletionItemProvider.prototype.provideCompletionItems = function (model, position) {
        var wordBasedSuggestions = this._configurationService.getValue(model.uri, position, 'editor').wordBasedSuggestions;
        if (!wordBasedSuggestions) {
            return undefined;
        }
        if (!canSyncModel(this._modelService, model.uri)) {
            return undefined; // File too large
        }
        return this._workerManager.withWorker().then(function (client) { return client.textualSuggest(model.uri, position); });
    };
    return WordBasedCompletionItemProvider;
}());
var WorkerManager = /** @class */ (function (_super) {
    __extends$1e(WorkerManager, _super);
    function WorkerManager(modelService) {
        var _this = _super.call(this) || this;
        _this._modelService = modelService;
        _this._editorWorkerClient = null;
        var stopWorkerInterval = _this._register(new IntervalTimer());
        stopWorkerInterval.cancelAndSet(function () { return _this._checkStopIdleWorker(); }, Math.round(STOP_WORKER_DELTA_TIME_MS / 2));
        _this._register(_this._modelService.onModelRemoved(function (_) { return _this._checkStopEmptyWorker(); }));
        return _this;
    }
    WorkerManager.prototype.dispose = function () {
        if (this._editorWorkerClient) {
            this._editorWorkerClient.dispose();
            this._editorWorkerClient = null;
        }
        _super.prototype.dispose.call(this);
    };
    /**
     * Check if the model service has no more models and stop the worker if that is the case.
     */
    WorkerManager.prototype._checkStopEmptyWorker = function () {
        if (!this._editorWorkerClient) {
            return;
        }
        var models = this._modelService.getModels();
        if (models.length === 0) {
            // There are no more models => nothing possible for me to do
            this._editorWorkerClient.dispose();
            this._editorWorkerClient = null;
        }
    };
    /**
     * Check if the worker has been idle for a while and then stop it.
     */
    WorkerManager.prototype._checkStopIdleWorker = function () {
        if (!this._editorWorkerClient) {
            return;
        }
        var timeSinceLastWorkerUsedTime = (new Date()).getTime() - this._lastWorkerUsedTime;
        if (timeSinceLastWorkerUsedTime > STOP_WORKER_DELTA_TIME_MS) {
            this._editorWorkerClient.dispose();
            this._editorWorkerClient = null;
        }
    };
    WorkerManager.prototype.withWorker = function () {
        this._lastWorkerUsedTime = (new Date()).getTime();
        if (!this._editorWorkerClient) {
            this._editorWorkerClient = new EditorWorkerClient(this._modelService, 'editorWorkerService');
        }
        return TPromise.as(this._editorWorkerClient);
    };
    return WorkerManager;
}(Disposable));
var EditorModelManager = /** @class */ (function (_super) {
    __extends$1e(EditorModelManager, _super);
    function EditorModelManager(proxy, modelService, keepIdleModels) {
        var _this = _super.call(this) || this;
        _this._syncedModels = Object.create(null);
        _this._syncedModelsLastUsedTime = Object.create(null);
        _this._proxy = proxy;
        _this._modelService = modelService;
        if (!keepIdleModels) {
            var timer = new IntervalTimer();
            timer.cancelAndSet(function () { return _this._checkStopModelSync(); }, Math.round(STOP_SYNC_MODEL_DELTA_TIME_MS / 2));
            _this._register(timer);
        }
        return _this;
    }
    EditorModelManager.prototype.dispose = function () {
        for (var modelUrl in this._syncedModels) {
            dispose(this._syncedModels[modelUrl]);
        }
        this._syncedModels = Object.create(null);
        this._syncedModelsLastUsedTime = Object.create(null);
        _super.prototype.dispose.call(this);
    };
    EditorModelManager.prototype.esureSyncedResources = function (resources) {
        for (var i = 0; i < resources.length; i++) {
            var resource = resources[i];
            var resourceStr = resource.toString();
            if (!this._syncedModels[resourceStr]) {
                this._beginModelSync(resource);
            }
            if (this._syncedModels[resourceStr]) {
                this._syncedModelsLastUsedTime[resourceStr] = (new Date()).getTime();
            }
        }
    };
    EditorModelManager.prototype._checkStopModelSync = function () {
        var currentTime = (new Date()).getTime();
        var toRemove = [];
        for (var modelUrl in this._syncedModelsLastUsedTime) {
            var elapsedTime = currentTime - this._syncedModelsLastUsedTime[modelUrl];
            if (elapsedTime > STOP_SYNC_MODEL_DELTA_TIME_MS) {
                toRemove.push(modelUrl);
            }
        }
        for (var i = 0; i < toRemove.length; i++) {
            this._stopModelSync(toRemove[i]);
        }
    };
    EditorModelManager.prototype._beginModelSync = function (resource) {
        var _this = this;
        var model = this._modelService.getModel(resource);
        if (!model) {
            return;
        }
        if (model.isTooLargeForTokenization()) {
            return;
        }
        var modelUrl = resource.toString();
        this._proxy.acceptNewModel({
            url: model.uri.toString(),
            lines: model.getLinesContent(),
            EOL: model.getEOL(),
            versionId: model.getVersionId()
        });
        var toDispose = [];
        toDispose.push(model.onDidChangeContent(function (e) {
            _this._proxy.acceptModelChanged(modelUrl.toString(), e);
        }));
        toDispose.push(model.onWillDispose(function () {
            _this._stopModelSync(modelUrl);
        }));
        toDispose.push({
            dispose: function () {
                _this._proxy.acceptRemovedModel(modelUrl);
            }
        });
        this._syncedModels[modelUrl] = toDispose;
    };
    EditorModelManager.prototype._stopModelSync = function (modelUrl) {
        var toDispose = this._syncedModels[modelUrl];
        delete this._syncedModels[modelUrl];
        delete this._syncedModelsLastUsedTime[modelUrl];
        dispose(toDispose);
    };
    return EditorModelManager;
}(Disposable));
var SynchronousWorkerClient = /** @class */ (function () {
    function SynchronousWorkerClient(instance) {
        this._instance = instance;
        this._proxyObj = TPromise.as(this._instance);
    }
    SynchronousWorkerClient.prototype.dispose = function () {
        this._instance.dispose();
        this._instance = null;
        this._proxyObj = null;
    };
    SynchronousWorkerClient.prototype.getProxyObject = function () {
        return new ShallowCancelThenPromise(this._proxyObj);
    };
    return SynchronousWorkerClient;
}());
var EditorWorkerClient = /** @class */ (function (_super) {
    __extends$1e(EditorWorkerClient, _super);
    function EditorWorkerClient(modelService, label) {
        var _this = _super.call(this) || this;
        _this._modelService = modelService;
        _this._workerFactory = new DefaultWorkerFactory(label);
        _this._worker = null;
        _this._modelManager = null;
        return _this;
    }
    EditorWorkerClient.prototype._getOrCreateWorker = function () {
        if (!this._worker) {
            try {
                this._worker = this._register(new SimpleWorkerClient(this._workerFactory, 'vs/editor/common/services/editorSimpleWorker'));
            }
            catch (err) {
                logOnceWebWorkerWarning(err);
                this._worker = new SynchronousWorkerClient(new EditorSimpleWorkerImpl(null));
            }
        }
        return this._worker;
    };
    EditorWorkerClient.prototype._getProxy = function () {
        var _this = this;
        return new ShallowCancelThenPromise(this._getOrCreateWorker().getProxyObject().then(null, function (err) {
            logOnceWebWorkerWarning(err);
            _this._worker = new SynchronousWorkerClient(new EditorSimpleWorkerImpl(null));
            return _this._getOrCreateWorker().getProxyObject();
        }));
    };
    EditorWorkerClient.prototype._getOrCreateModelManager = function (proxy) {
        if (!this._modelManager) {
            this._modelManager = this._register(new EditorModelManager(proxy, this._modelService, false));
        }
        return this._modelManager;
    };
    EditorWorkerClient.prototype._withSyncedResources = function (resources) {
        var _this = this;
        return this._getProxy().then(function (proxy) {
            _this._getOrCreateModelManager(proxy).esureSyncedResources(resources);
            return proxy;
        });
    };
    EditorWorkerClient.prototype.computeDiff = function (original, modified, ignoreTrimWhitespace) {
        return this._withSyncedResources([original, modified]).then(function (proxy) {
            return proxy.computeDiff(original.toString(), modified.toString(), ignoreTrimWhitespace);
        });
    };
    EditorWorkerClient.prototype.computeDirtyDiff = function (original, modified, ignoreTrimWhitespace) {
        return this._withSyncedResources([original, modified]).then(function (proxy) {
            return proxy.computeDirtyDiff(original.toString(), modified.toString(), ignoreTrimWhitespace);
        });
    };
    EditorWorkerClient.prototype.computeMoreMinimalEdits = function (resource, edits) {
        return this._withSyncedResources([resource]).then(function (proxy) {
            return proxy.computeMoreMinimalEdits(resource.toString(), edits);
        });
    };
    EditorWorkerClient.prototype.computeLinks = function (resource) {
        return this._withSyncedResources([resource]).then(function (proxy) {
            return proxy.computeLinks(resource.toString());
        });
    };
    EditorWorkerClient.prototype.textualSuggest = function (resource, position) {
        var _this = this;
        return this._withSyncedResources([resource]).then(function (proxy) {
            var model = _this._modelService.getModel(resource);
            if (!model) {
                return null;
            }
            var wordDefRegExp = LanguageConfigurationRegistry.getWordDefinition(model.getLanguageIdentifier().id);
            var wordDef = wordDefRegExp.source;
            var wordDefFlags = (wordDefRegExp.global ? 'g' : '') + (wordDefRegExp.ignoreCase ? 'i' : '') + (wordDefRegExp.multiline ? 'm' : '');
            return proxy.textualSuggest(resource.toString(), position, wordDef, wordDefFlags);
        });
    };
    EditorWorkerClient.prototype.navigateValueSet = function (resource, range, up) {
        var _this = this;
        return this._withSyncedResources([resource]).then(function (proxy) {
            var model = _this._modelService.getModel(resource);
            if (!model) {
                return null;
            }
            var wordDefRegExp = LanguageConfigurationRegistry.getWordDefinition(model.getLanguageIdentifier().id);
            var wordDef = wordDefRegExp.source;
            var wordDefFlags = (wordDefRegExp.global ? 'g' : '') + (wordDefRegExp.ignoreCase ? 'i' : '') + (wordDefRegExp.multiline ? 'm' : '');
            return proxy.navigateValueSet(resource.toString(), range, up, wordDef, wordDefFlags);
        });
    };
    return EditorWorkerClient;
}(Disposable));

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var IModeService = createDecorator('modeService');

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var FrankensteinMode = /** @class */ (function () {
    function FrankensteinMode(languageIdentifier) {
        this._languageIdentifier = languageIdentifier;
    }
    FrankensteinMode.prototype.getId = function () {
        return this._languageIdentifier.language;
    };
    FrankensteinMode.prototype.getLanguageIdentifier = function () {
        return this._languageIdentifier;
    };
    return FrankensteinMode;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var MIME_TEXT = 'text/plain';
var MIME_UNKNOWN = 'application/unknown';
var registeredAssociations = [];
var nonUserRegisteredAssociations = [];
var userRegisteredAssociations = [];
/**
 * Associate a text mime to the registry.
 */
function registerTextMime(association, warnOnOverwrite) {
    if (warnOnOverwrite === void 0) { warnOnOverwrite = false; }
    // Register
    var associationItem = toTextMimeAssociationItem(association);
    registeredAssociations.push(associationItem);
    if (!associationItem.userConfigured) {
        nonUserRegisteredAssociations.push(associationItem);
    }
    else {
        userRegisteredAssociations.push(associationItem);
    }
    // Check for conflicts unless this is a user configured association
    if (warnOnOverwrite && !associationItem.userConfigured) {
        registeredAssociations.forEach(function (a) {
            if (a.mime === associationItem.mime || a.userConfigured) {
                return; // same mime or userConfigured is ok
            }
            if (associationItem.extension && a.extension === associationItem.extension) {
                console.warn("Overwriting extension <<" + associationItem.extension + ">> to now point to mime <<" + associationItem.mime + ">>");
            }
            if (associationItem.filename && a.filename === associationItem.filename) {
                console.warn("Overwriting filename <<" + associationItem.filename + ">> to now point to mime <<" + associationItem.mime + ">>");
            }
            if (associationItem.filepattern && a.filepattern === associationItem.filepattern) {
                console.warn("Overwriting filepattern <<" + associationItem.filepattern + ">> to now point to mime <<" + associationItem.mime + ">>");
            }
            if (associationItem.firstline && a.firstline === associationItem.firstline) {
                console.warn("Overwriting firstline <<" + associationItem.firstline + ">> to now point to mime <<" + associationItem.mime + ">>");
            }
        });
    }
}
function toTextMimeAssociationItem(association) {
    return {
        id: association.id,
        mime: association.mime,
        filename: association.filename,
        extension: association.extension,
        filepattern: association.filepattern,
        firstline: association.firstline,
        userConfigured: association.userConfigured,
        filenameLowercase: association.filename ? association.filename.toLowerCase() : void 0,
        extensionLowercase: association.extension ? association.extension.toLowerCase() : void 0,
        filepatternLowercase: association.filepattern ? association.filepattern.toLowerCase() : void 0,
        filepatternOnPath: association.filepattern ? association.filepattern.indexOf(sep) >= 0 : false
    };
}
/**
 * Given a file, return the best matching mime type for it
 */
function guessMimeTypes(path, firstLine) {
    if (!path) {
        return [MIME_UNKNOWN];
    }
    path = path.toLowerCase();
    var filename = basename(path);
    // 1.) User configured mappings have highest priority
    var configuredMime = guessMimeTypeByPath(path, filename, userRegisteredAssociations);
    if (configuredMime) {
        return [configuredMime, MIME_TEXT];
    }
    // 2.) Registered mappings have middle priority
    var registeredMime = guessMimeTypeByPath(path, filename, nonUserRegisteredAssociations);
    if (registeredMime) {
        return [registeredMime, MIME_TEXT];
    }
    // 3.) Firstline has lowest priority
    if (firstLine) {
        var firstlineMime = guessMimeTypeByFirstline(firstLine);
        if (firstlineMime) {
            return [firstlineMime, MIME_TEXT];
        }
    }
    return [MIME_UNKNOWN];
}
function guessMimeTypeByPath(path, filename, associations) {
    var filenameMatch;
    var patternMatch;
    var extensionMatch;
    // We want to prioritize associations based on the order they are registered so that the last registered
    // association wins over all other. This is for https://github.com/Microsoft/vscode/issues/20074
    for (var i = associations.length - 1; i >= 0; i--) {
        var association = associations[i];
        // First exact name match
        if (filename === association.filenameLowercase) {
            filenameMatch = association;
            break; // take it!
        }
        // Longest pattern match
        if (association.filepattern) {
            if (!patternMatch || association.filepattern.length > patternMatch.filepattern.length) {
                var target = association.filepatternOnPath ? path : filename; // match on full path if pattern contains path separator
                if (match(association.filepatternLowercase, target)) {
                    patternMatch = association;
                }
            }
        }
        // Longest extension match
        if (association.extension) {
            if (!extensionMatch || association.extension.length > extensionMatch.extension.length) {
                if (endsWith(filename, association.extensionLowercase)) {
                    extensionMatch = association;
                }
            }
        }
    }
    // 1.) Exact name match has second highest prio
    if (filenameMatch) {
        return filenameMatch.mime;
    }
    // 2.) Match on pattern
    if (patternMatch) {
        return patternMatch.mime;
    }
    // 3.) Match on extension comes next
    if (extensionMatch) {
        return extensionMatch.mime;
    }
    return null;
}
function guessMimeTypeByFirstline(firstLine) {
    if (startsWithUTF8BOM(firstLine)) {
        firstLine = firstLine.substr(1);
    }
    if (firstLine.length > 0) {
        for (var i = 0; i < registeredAssociations.length; ++i) {
            var association = registeredAssociations[i];
            if (!association.firstline) {
                continue;
            }
            var matches = firstLine.match(association.firstline);
            if (matches && matches.length > 0) {
                return association.mime;
            }
        }
    }
    return null;
}

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// Define extension point ids
var Extensions$6 = {
    ModesRegistry: 'editor.modesRegistry'
};
var EditorModesRegistry = /** @class */ (function () {
    function EditorModesRegistry() {
        this._onDidAddLanguages = new Emitter();
        this.onDidAddLanguages = this._onDidAddLanguages.event;
        this._languages = [];
    }
    // --- languages
    EditorModesRegistry.prototype.registerLanguage = function (def) {
        this._languages.push(def);
        this._onDidAddLanguages.fire([def]);
    };
    EditorModesRegistry.prototype.registerLanguages = function (def) {
        this._languages = this._languages.concat(def);
        this._onDidAddLanguages.fire(def);
    };
    EditorModesRegistry.prototype.getLanguages = function () {
        return this._languages.slice(0);
    };
    return EditorModesRegistry;
}());
var ModesRegistry = new EditorModesRegistry();
Registry.add(Extensions$6.ModesRegistry, ModesRegistry);
var PLAINTEXT_MODE_ID = 'plaintext';
var PLAINTEXT_LANGUAGE_IDENTIFIER = new LanguageIdentifier(PLAINTEXT_MODE_ID, 1 /* PlainText */);
ModesRegistry.registerLanguage({
    id: PLAINTEXT_MODE_ID,
    extensions: ['.txt', '.gitignore'],
    aliases: [localize('plainText.alias', "Plain Text"), 'text'],
    mimetypes: ['text/plain']
});
LanguageConfigurationRegistry.register(PLAINTEXT_LANGUAGE_IDENTIFIER, {
    brackets: [
        ['(', ')'],
        ['[', ']'],
        ['{', '}'],
    ]
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var hasOwnProperty$2 = Object.prototype.hasOwnProperty;
var LanguagesRegistry = /** @class */ (function () {
    function LanguagesRegistry(useModesRegistry, warnOnOverwrite) {
        if (useModesRegistry === void 0) { useModesRegistry = true; }
        if (warnOnOverwrite === void 0) { warnOnOverwrite = false; }
        var _this = this;
        this._nextLanguageId = 1;
        this._languages = {};
        this._mimeTypesMap = {};
        this._nameMap = {};
        this._lowercaseNameMap = {};
        this._languageIds = [];
        this._warnOnOverwrite = warnOnOverwrite;
        if (useModesRegistry) {
            this._registerLanguages(ModesRegistry.getLanguages());
            ModesRegistry.onDidAddLanguages(function (m) { return _this._registerLanguages(m); });
        }
    }
    LanguagesRegistry.prototype._registerLanguages = function (desc) {
        var _this = this;
        if (desc.length === 0) {
            return;
        }
        for (var i = 0; i < desc.length; i++) {
            this._registerLanguage(desc[i]);
        }
        // Rebuild fast path maps
        this._mimeTypesMap = {};
        this._nameMap = {};
        this._lowercaseNameMap = {};
        Object.keys(this._languages).forEach(function (langId) {
            var language = _this._languages[langId];
            if (language.name) {
                _this._nameMap[language.name] = language.identifier;
            }
            language.aliases.forEach(function (alias) {
                _this._lowercaseNameMap[alias.toLowerCase()] = language.identifier;
            });
            language.mimetypes.forEach(function (mimetype) {
                _this._mimeTypesMap[mimetype] = language.identifier;
            });
        });
        Registry.as(Extensions$1.Configuration).registerOverrideIdentifiers(ModesRegistry.getLanguages().map(function (language) { return language.id; }));
    };
    LanguagesRegistry.prototype._registerLanguage = function (lang) {
        var langId = lang.id;
        var resolvedLanguage = null;
        if (hasOwnProperty$2.call(this._languages, langId)) {
            resolvedLanguage = this._languages[langId];
        }
        else {
            var languageId = this._nextLanguageId++;
            resolvedLanguage = {
                identifier: new LanguageIdentifier(langId, languageId),
                name: null,
                mimetypes: [],
                aliases: [],
                extensions: [],
                filenames: [],
                configurationFiles: []
            };
            this._languageIds[languageId] = langId;
            this._languages[langId] = resolvedLanguage;
        }
        this._mergeLanguage(resolvedLanguage, lang);
    };
    LanguagesRegistry.prototype._mergeLanguage = function (resolvedLanguage, lang) {
        var langId = lang.id;
        var primaryMime = null;
        if (Array.isArray(lang.mimetypes) && lang.mimetypes.length > 0) {
            (_a = resolvedLanguage.mimetypes).push.apply(_a, lang.mimetypes);
            primaryMime = lang.mimetypes[0];
        }
        if (!primaryMime) {
            primaryMime = "text/x-" + langId;
            resolvedLanguage.mimetypes.push(primaryMime);
        }
        if (Array.isArray(lang.extensions)) {
            for (var _i = 0, _b = lang.extensions; _i < _b.length; _i++) {
                var extension = _b[_i];
                registerTextMime({ id: langId, mime: primaryMime, extension: extension }, this._warnOnOverwrite);
                resolvedLanguage.extensions.push(extension);
            }
        }
        if (Array.isArray(lang.filenames)) {
            for (var _c = 0, _d = lang.filenames; _c < _d.length; _c++) {
                var filename = _d[_c];
                registerTextMime({ id: langId, mime: primaryMime, filename: filename }, this._warnOnOverwrite);
                resolvedLanguage.filenames.push(filename);
            }
        }
        if (Array.isArray(lang.filenamePatterns)) {
            for (var _e = 0, _f = lang.filenamePatterns; _e < _f.length; _e++) {
                var filenamePattern = _f[_e];
                registerTextMime({ id: langId, mime: primaryMime, filepattern: filenamePattern }, this._warnOnOverwrite);
            }
        }
        if (typeof lang.firstLine === 'string' && lang.firstLine.length > 0) {
            var firstLineRegexStr = lang.firstLine;
            if (firstLineRegexStr.charAt(0) !== '^') {
                firstLineRegexStr = '^' + firstLineRegexStr;
            }
            try {
                var firstLineRegex = new RegExp(firstLineRegexStr);
                if (!regExpLeadsToEndlessLoop(firstLineRegex)) {
                    registerTextMime({ id: langId, mime: primaryMime, firstline: firstLineRegex }, this._warnOnOverwrite);
                }
            }
            catch (err) {
                // Most likely, the regex was bad
                onUnexpectedError(err);
            }
        }
        resolvedLanguage.aliases.push(langId);
        var langAliases = null;
        if (typeof lang.aliases !== 'undefined' && Array.isArray(lang.aliases)) {
            if (lang.aliases.length === 0) {
                // signal that this language should not get a name
                langAliases = [null];
            }
            else {
                langAliases = lang.aliases;
            }
        }
        if (langAliases !== null) {
            for (var i = 0; i < langAliases.length; i++) {
                if (!langAliases[i] || langAliases[i].length === 0) {
                    continue;
                }
                resolvedLanguage.aliases.push(langAliases[i]);
            }
        }
        var containsAliases = (langAliases !== null && langAliases.length > 0);
        if (containsAliases && langAliases[0] === null) ;
        else {
            var bestName = (containsAliases ? langAliases[0] : null) || langId;
            if (containsAliases || !resolvedLanguage.name) {
                resolvedLanguage.name = bestName;
            }
        }
        if (typeof lang.configuration === 'string') {
            resolvedLanguage.configurationFiles.push(lang.configuration);
        }
        var _a;
    };
    LanguagesRegistry.prototype.isRegisteredMode = function (mimetypeOrModeId) {
        // Is this a known mime type ?
        if (hasOwnProperty$2.call(this._mimeTypesMap, mimetypeOrModeId)) {
            return true;
        }
        // Is this a known mode id ?
        return hasOwnProperty$2.call(this._languages, mimetypeOrModeId);
    };
    LanguagesRegistry.prototype.getRegisteredModes = function () {
        return Object.keys(this._languages);
    };
    LanguagesRegistry.prototype.getRegisteredLanguageNames = function () {
        return Object.keys(this._nameMap);
    };
    LanguagesRegistry.prototype.getLanguageName = function (modeId) {
        if (!hasOwnProperty$2.call(this._languages, modeId)) {
            return null;
        }
        return this._languages[modeId].name;
    };
    LanguagesRegistry.prototype.getModeIdForLanguageNameLowercase = function (languageNameLower) {
        if (!hasOwnProperty$2.call(this._lowercaseNameMap, languageNameLower)) {
            return null;
        }
        return this._lowercaseNameMap[languageNameLower].language;
    };
    LanguagesRegistry.prototype.getConfigurationFiles = function (modeId) {
        if (!hasOwnProperty$2.call(this._languages, modeId)) {
            return [];
        }
        return this._languages[modeId].configurationFiles || [];
    };
    LanguagesRegistry.prototype.getMimeForMode = function (modeId) {
        if (!hasOwnProperty$2.call(this._languages, modeId)) {
            return null;
        }
        var language = this._languages[modeId];
        return (language.mimetypes[0] || null);
    };
    LanguagesRegistry.prototype.extractModeIds = function (commaSeparatedMimetypesOrCommaSeparatedIds) {
        var _this = this;
        if (!commaSeparatedMimetypesOrCommaSeparatedIds) {
            return [];
        }
        return (commaSeparatedMimetypesOrCommaSeparatedIds.
            split(',').
            map(function (mimeTypeOrId) { return mimeTypeOrId.trim(); }).
            map(function (mimeTypeOrId) {
            if (hasOwnProperty$2.call(_this._mimeTypesMap, mimeTypeOrId)) {
                return _this._mimeTypesMap[mimeTypeOrId].language;
            }
            return mimeTypeOrId;
        }).
            filter(function (modeId) {
            return hasOwnProperty$2.call(_this._languages, modeId);
        }));
    };
    LanguagesRegistry.prototype.getLanguageIdentifier = function (_modeId) {
        if (_modeId === NULL_MODE_ID || _modeId === 0 /* Null */) {
            return NULL_LANGUAGE_IDENTIFIER;
        }
        var modeId;
        if (typeof _modeId === 'string') {
            modeId = _modeId;
        }
        else {
            modeId = this._languageIds[_modeId];
            if (!modeId) {
                return null;
            }
        }
        if (!hasOwnProperty$2.call(this._languages, modeId)) {
            return null;
        }
        return this._languages[modeId].identifier;
    };
    LanguagesRegistry.prototype.getModeIdsFromLanguageName = function (languageName) {
        if (!languageName) {
            return [];
        }
        if (hasOwnProperty$2.call(this._nameMap, languageName)) {
            return [this._nameMap[languageName].language];
        }
        return [];
    };
    LanguagesRegistry.prototype.getModeIdsFromFilenameOrFirstLine = function (filename, firstLine) {
        if (!filename && !firstLine) {
            return [];
        }
        var mimeTypes = guessMimeTypes(filename, firstLine);
        return this.extractModeIds(mimeTypes.join(','));
    };
    LanguagesRegistry.prototype.getExtensions = function (languageName) {
        if (!hasOwnProperty$2.call(this._nameMap, languageName)) {
            return [];
        }
        var languageId = this._nameMap[languageName];
        return this._languages[languageId.language].extensions;
    };
    LanguagesRegistry.prototype.getFilenames = function (languageName) {
        if (!hasOwnProperty$2.call(this._nameMap, languageName)) {
            return [];
        }
        var languageId = this._nameMap[languageName];
        return this._languages[languageId.language].filenames;
    };
    return LanguagesRegistry;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var ModeServiceImpl = /** @class */ (function () {
    function ModeServiceImpl(warnOnOverwrite) {
        if (warnOnOverwrite === void 0) { warnOnOverwrite = false; }
        this._onDidCreateMode = new Emitter();
        this.onDidCreateMode = this._onDidCreateMode.event;
        this._instantiatedModes = {};
        this._registry = new LanguagesRegistry(true, warnOnOverwrite);
    }
    ModeServiceImpl.prototype._onReady = function () {
        return TPromise.as(true);
    };
    ModeServiceImpl.prototype.isRegisteredMode = function (mimetypeOrModeId) {
        return this._registry.isRegisteredMode(mimetypeOrModeId);
    };
    ModeServiceImpl.prototype.getRegisteredModes = function () {
        return this._registry.getRegisteredModes();
    };
    ModeServiceImpl.prototype.getRegisteredLanguageNames = function () {
        return this._registry.getRegisteredLanguageNames();
    };
    ModeServiceImpl.prototype.getExtensions = function (alias) {
        return this._registry.getExtensions(alias);
    };
    ModeServiceImpl.prototype.getFilenames = function (alias) {
        return this._registry.getFilenames(alias);
    };
    ModeServiceImpl.prototype.getMimeForMode = function (modeId) {
        return this._registry.getMimeForMode(modeId);
    };
    ModeServiceImpl.prototype.getLanguageName = function (modeId) {
        return this._registry.getLanguageName(modeId);
    };
    ModeServiceImpl.prototype.getModeIdForLanguageName = function (alias) {
        return this._registry.getModeIdForLanguageNameLowercase(alias);
    };
    ModeServiceImpl.prototype.getModeIdByFilenameOrFirstLine = function (filename, firstLine) {
        var modeIds = this._registry.getModeIdsFromFilenameOrFirstLine(filename, firstLine);
        if (modeIds.length > 0) {
            return modeIds[0];
        }
        return null;
    };
    ModeServiceImpl.prototype.getModeId = function (commaSeparatedMimetypesOrCommaSeparatedIds) {
        var modeIds = this._registry.extractModeIds(commaSeparatedMimetypesOrCommaSeparatedIds);
        if (modeIds.length > 0) {
            return modeIds[0];
        }
        return null;
    };
    ModeServiceImpl.prototype.getLanguageIdentifier = function (modeId) {
        return this._registry.getLanguageIdentifier(modeId);
    };
    ModeServiceImpl.prototype.getConfigurationFiles = function (modeId) {
        return this._registry.getConfigurationFiles(modeId);
    };
    // --- instantiation
    ModeServiceImpl.prototype.getMode = function (commaSeparatedMimetypesOrCommaSeparatedIds) {
        var modeIds = this._registry.extractModeIds(commaSeparatedMimetypesOrCommaSeparatedIds);
        var isPlainText = false;
        for (var i = 0; i < modeIds.length; i++) {
            if (this._instantiatedModes.hasOwnProperty(modeIds[i])) {
                return this._instantiatedModes[modeIds[i]];
            }
            isPlainText = isPlainText || (modeIds[i] === 'plaintext');
        }
        if (isPlainText) {
            // Try to do it synchronously
            var r_1 = null;
            this.getOrCreateMode(commaSeparatedMimetypesOrCommaSeparatedIds).then(function (mode) {
                r_1 = mode;
            }).done(null, onUnexpectedError);
            return r_1;
        }
        return null;
    };
    ModeServiceImpl.prototype.getOrCreateMode = function (commaSeparatedMimetypesOrCommaSeparatedIds) {
        var _this = this;
        return this._onReady().then(function () {
            var modeId = _this.getModeId(commaSeparatedMimetypesOrCommaSeparatedIds);
            // Fall back to plain text if no mode was found
            return _this._getOrCreateMode(modeId || 'plaintext');
        });
    };
    ModeServiceImpl.prototype.getOrCreateModeByLanguageName = function (languageName) {
        var _this = this;
        return this._onReady().then(function () {
            var modeId = _this._getModeIdByLanguageName(languageName);
            // Fall back to plain text if no mode was found
            return _this._getOrCreateMode(modeId || 'plaintext');
        });
    };
    ModeServiceImpl.prototype._getModeIdByLanguageName = function (languageName) {
        var modeIds = this._registry.getModeIdsFromLanguageName(languageName);
        if (modeIds.length > 0) {
            return modeIds[0];
        }
        return null;
    };
    ModeServiceImpl.prototype.getOrCreateModeByFilenameOrFirstLine = function (filename, firstLine) {
        var _this = this;
        return this._onReady().then(function () {
            var modeId = _this.getModeIdByFilenameOrFirstLine(filename, firstLine);
            // Fall back to plain text if no mode was found
            return _this._getOrCreateMode(modeId || 'plaintext');
        });
    };
    ModeServiceImpl.prototype._getOrCreateMode = function (modeId) {
        if (!this._instantiatedModes.hasOwnProperty(modeId)) {
            var languageIdentifier = this.getLanguageIdentifier(modeId);
            this._instantiatedModes[modeId] = new FrankensteinMode(languageIdentifier);
            this._onDidCreateMode.fire(this._instantiatedModes[modeId]);
        }
        return this._instantiatedModes[modeId];
    };
    return ModeServiceImpl;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var MarkdownString = /** @class */ (function () {
    function MarkdownString(value) {
        if (value === void 0) { value = ''; }
        this.value = value;
    }
    MarkdownString.prototype.appendText = function (value) {
        // escape markdown syntax tokens: http://daringfireball.net/projects/markdown/syntax#backslash
        this.value += value.replace(/[\\`*_{}[\]()#+\-.!]/g, '\\$&');
        return this;
    };
    MarkdownString.prototype.appendMarkdown = function (value) {
        this.value += value;
        return this;
    };
    MarkdownString.prototype.appendCodeblock = function (langId, code) {
        this.value += '\n```';
        this.value += langId;
        this.value += '\n';
        this.value += code;
        this.value += '\n```\n';
        return this;
    };
    return MarkdownString;
}());
function isEmptyMarkdownString(oneOrMany) {
    if (isMarkdownString(oneOrMany)) {
        return !oneOrMany.value;
    }
    else if (Array.isArray(oneOrMany)) {
        return oneOrMany.every(isEmptyMarkdownString);
    }
    else {
        return true;
    }
}
function isMarkdownString(thing) {
    if (thing instanceof MarkdownString) {
        return true;
    }
    else if (thing && typeof thing === 'object') {
        return typeof thing.value === 'string'
            && (typeof thing.isTrusted === 'boolean' || thing.isTrusted === void 0);
    }
    return false;
}
function markedStringsEquals(a, b) {
    if (!a && !b) {
        return true;
    }
    else if (!a || !b) {
        return false;
    }
    else if (Array.isArray(a) && Array.isArray(b)) {
        return equals(a, b, markdownStringEqual);
    }
    else if (isMarkdownString(a) && isMarkdownString(b)) {
        return markdownStringEqual(a, b);
    }
    else {
        return false;
    }
}
function markdownStringEqual(a, b) {
    if (a === b) {
        return true;
    }
    else if (!a || !b) {
        return false;
    }
    else {
        return a.value === b.value && a.isTrusted === b.isTrusted;
    }
}
function removeMarkdownEscapes(text) {
    if (!text) {
        return text;
    }
    return text.replace(/\\([\\`*_{}[\]()#+\-.!])/g, '$1');
}

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var EditOperation = /** @class */ (function () {
    function EditOperation() {
    }
    EditOperation.insert = function (position, text) {
        return {
            range: new Range(position.lineNumber, position.column, position.lineNumber, position.column),
            text: text,
            forceMoveMarkers: true
        };
    };
    EditOperation.delete = function (range) {
        return {
            range: range,
            text: null
        };
    };
    EditOperation.replace = function (range, text) {
        return {
            range: range,
            text: text
        };
    };
    EditOperation.replaceMove = function (range, text) {
        return {
            range: range,
            text: text,
            forceMoveMarkers: true
        };
    };
    return EditOperation;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __decorate$b = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$8 = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
function MODEL_ID$1(resource) {
    return resource.toString();
}
var ModelData = /** @class */ (function () {
    function ModelData(model, onWillDispose, onDidChangeLanguage) {
        this.model = model;
        this._markerDecorations = [];
        this._modelEventListeners = [];
        this._modelEventListeners.push(model.onWillDispose(function () { return onWillDispose(model); }));
        this._modelEventListeners.push(model.onDidChangeLanguage(function (e) { return onDidChangeLanguage(model, e); }));
    }
    ModelData.prototype.dispose = function () {
        this._markerDecorations = this.model.deltaDecorations(this._markerDecorations, []);
        this._modelEventListeners = dispose(this._modelEventListeners);
        this.model = null;
    };
    ModelData.prototype.acceptMarkerDecorations = function (newDecorations) {
        this._markerDecorations = this.model.deltaDecorations(this._markerDecorations, newDecorations);
    };
    return ModelData;
}());
var ModelMarkerHandler = /** @class */ (function () {
    function ModelMarkerHandler() {
    }
    ModelMarkerHandler.setMarkers = function (modelData, markerService) {
        var _this = this;
        // Limit to the first 500 errors/warnings
        var markers = markerService.read({ resource: modelData.model.uri, take: 500 });
        var newModelDecorations = markers.map(function (marker) {
            return {
                range: _this._createDecorationRange(modelData.model, marker),
                options: _this._createDecorationOption(marker)
            };
        });
        modelData.acceptMarkerDecorations(newModelDecorations);
    };
    ModelMarkerHandler._createDecorationRange = function (model, rawMarker) {
        var ret = Range.lift(rawMarker);
        if (rawMarker.severity === MarkerSeverity.Hint && Range.spansMultipleLines(ret)) {
            // never render hints on multiple lines
            ret = ret.setEndPosition(ret.startLineNumber, ret.startColumn);
        }
        ret = model.validateRange(ret);
        if (ret.isEmpty()) {
            var word = model.getWordAtPosition(ret.getStartPosition());
            if (word) {
                ret = new Range(ret.startLineNumber, word.startColumn, ret.endLineNumber, word.endColumn);
            }
            else {
                var maxColumn = model.getLineLastNonWhitespaceColumn(ret.startLineNumber) ||
                    model.getLineMaxColumn(ret.startLineNumber);
                if (maxColumn === 1) ;
                else if (ret.endColumn >= maxColumn) {
                    // behind eol
                    ret = new Range(ret.startLineNumber, maxColumn - 1, ret.endLineNumber, maxColumn);
                }
                else {
                    // extend marker to width = 1
                    ret = new Range(ret.startLineNumber, ret.startColumn, ret.endLineNumber, ret.endColumn + 1);
                }
            }
        }
        else if (rawMarker.endColumn === Number.MAX_VALUE && rawMarker.startColumn === 1 && ret.startLineNumber === ret.endLineNumber) {
            var minColumn = model.getLineFirstNonWhitespaceColumn(rawMarker.startLineNumber);
            if (minColumn < ret.endColumn) {
                ret = new Range(ret.startLineNumber, minColumn, ret.endLineNumber, ret.endColumn);
                rawMarker.startColumn = minColumn;
            }
        }
        return ret;
    };
    ModelMarkerHandler._createDecorationOption = function (marker) {
        var className;
        var color;
        var darkColor;
        var zIndex;
        switch (marker.severity) {
            case MarkerSeverity.Hint:
                className = ClassName.EditorHintDecoration;
                zIndex = 0;
                break;
            case MarkerSeverity.Warning:
                className = ClassName.EditorWarningDecoration;
                color = themeColorFromId(overviewRulerWarning);
                darkColor = themeColorFromId(overviewRulerWarning);
                zIndex = 20;
                break;
            case MarkerSeverity.Info:
                className = ClassName.EditorInfoDecoration;
                color = themeColorFromId(overviewRulerInfo);
                darkColor = themeColorFromId(overviewRulerInfo);
                zIndex = 10;
                break;
            case MarkerSeverity.Error:
            default:
                className = ClassName.EditorErrorDecoration;
                color = themeColorFromId(overviewRulerError);
                darkColor = themeColorFromId(overviewRulerError);
                zIndex = 30;
                break;
        }
        var hoverMessage = null;
        var message = marker.message, source = marker.source, relatedInformation = marker.relatedInformation;
        if (typeof message === 'string') {
            message = message.trim();
            if (source) {
                if (/\n/g.test(message)) {
                    message = localize('diagAndSourceMultiline', "[{0}]\n{1}", source, message);
                }
                else {
                    message = localize('diagAndSource', "[{0}] {1}", source, message);
                }
            }
            hoverMessage = new MarkdownString().appendCodeblock('_', message);
            if (!isFalsyOrEmpty(relatedInformation)) {
                hoverMessage.appendMarkdown('\n');
                for (var _i = 0, relatedInformation_1 = relatedInformation; _i < relatedInformation_1.length; _i++) {
                    var _a = relatedInformation_1[_i], message_1 = _a.message, resource = _a.resource, startLineNumber = _a.startLineNumber, startColumn = _a.startColumn;
                    hoverMessage.appendMarkdown("* [" + basename(resource.path) + "(" + startLineNumber + ", " + startColumn + ")](" + resource.toString(false) + "#" + startLineNumber + "," + startColumn + "): `" + message_1 + "` \n");
                }
                hoverMessage.appendMarkdown('\n');
            }
        }
        return {
            stickiness: TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges,
            className: className,
            hoverMessage: hoverMessage,
            showIfCollapsed: true,
            overviewRuler: {
                color: color,
                darkColor: darkColor,
                position: OverviewRulerLane.Right
            },
            zIndex: zIndex
        };
    };
    return ModelMarkerHandler;
}());
var DEFAULT_EOL = (isLinux || isMacintosh) ? DefaultEndOfLine.LF : DefaultEndOfLine.CRLF;
var ModelServiceImpl = /** @class */ (function () {
    function ModelServiceImpl(markerService, configurationService) {
        var _this = this;
        this._markerService = markerService;
        this._configurationService = configurationService;
        this._models = {};
        this._modelCreationOptionsByLanguageAndResource = Object.create(null);
        this._onModelAdded = new Emitter();
        this._onModelRemoved = new Emitter();
        this._onModelModeChanged = new Emitter();
        if (this._markerService) {
            this._markerServiceSubscription = this._markerService.onMarkerChanged(this._handleMarkerChange, this);
        }
        this._configurationServiceSubscription = this._configurationService.onDidChangeConfiguration(function (e) { return _this._updateModelOptions(); });
        this._updateModelOptions();
    }
    ModelServiceImpl._readModelOptions = function (config, isForSimpleWidget) {
        var tabSize = EDITOR_MODEL_DEFAULTS.tabSize;
        if (config.editor && typeof config.editor.tabSize !== 'undefined') {
            var parsedTabSize = parseInt(config.editor.tabSize, 10);
            if (!isNaN(parsedTabSize)) {
                tabSize = parsedTabSize;
            }
        }
        var insertSpaces = EDITOR_MODEL_DEFAULTS.insertSpaces;
        if (config.editor && typeof config.editor.insertSpaces !== 'undefined') {
            insertSpaces = (config.editor.insertSpaces === 'false' ? false : Boolean(config.editor.insertSpaces));
        }
        var newDefaultEOL = DEFAULT_EOL;
        var eol = config.files && config.files.eol;
        if (eol === '\r\n') {
            newDefaultEOL = DefaultEndOfLine.CRLF;
        }
        else if (eol === '\n') {
            newDefaultEOL = DefaultEndOfLine.LF;
        }
        var trimAutoWhitespace = EDITOR_MODEL_DEFAULTS.trimAutoWhitespace;
        if (config.editor && typeof config.editor.trimAutoWhitespace !== 'undefined') {
            trimAutoWhitespace = (config.editor.trimAutoWhitespace === 'false' ? false : Boolean(config.editor.trimAutoWhitespace));
        }
        var detectIndentation = EDITOR_MODEL_DEFAULTS.detectIndentation;
        if (config.editor && typeof config.editor.detectIndentation !== 'undefined') {
            detectIndentation = (config.editor.detectIndentation === 'false' ? false : Boolean(config.editor.detectIndentation));
        }
        var largeFileOptimizations = EDITOR_MODEL_DEFAULTS.largeFileOptimizations;
        if (config.editor && typeof config.editor.largeFileOptimizations !== 'undefined') {
            largeFileOptimizations = (config.editor.largeFileOptimizations === 'false' ? false : Boolean(config.editor.largeFileOptimizations));
        }
        return {
            isForSimpleWidget: isForSimpleWidget,
            tabSize: tabSize,
            insertSpaces: insertSpaces,
            detectIndentation: detectIndentation,
            defaultEOL: newDefaultEOL,
            trimAutoWhitespace: trimAutoWhitespace,
            largeFileOptimizations: largeFileOptimizations
        };
    };
    ModelServiceImpl.prototype.getCreationOptions = function (language, resource, isForSimpleWidget) {
        var creationOptions = this._modelCreationOptionsByLanguageAndResource[language + resource];
        if (!creationOptions) {
            creationOptions = ModelServiceImpl._readModelOptions(this._configurationService.getValue({ overrideIdentifier: language, resource: resource }), isForSimpleWidget);
            this._modelCreationOptionsByLanguageAndResource[language + resource] = creationOptions;
        }
        return creationOptions;
    };
    ModelServiceImpl.prototype._updateModelOptions = function () {
        var oldOptionsByLanguageAndResource = this._modelCreationOptionsByLanguageAndResource;
        this._modelCreationOptionsByLanguageAndResource = Object.create(null);
        // Update options on all models
        var keys = Object.keys(this._models);
        for (var i = 0, len = keys.length; i < len; i++) {
            var modelId = keys[i];
            var modelData = this._models[modelId];
            var language = modelData.model.getLanguageIdentifier().language;
            var uri = modelData.model.uri;
            var oldOptions = oldOptionsByLanguageAndResource[language + uri];
            var newOptions = this.getCreationOptions(language, uri, modelData.model.isForSimpleWidget);
            ModelServiceImpl._setModelOptionsForModel(modelData.model, newOptions, oldOptions);
        }
    };
    ModelServiceImpl._setModelOptionsForModel = function (model, newOptions, currentOptions) {
        if (currentOptions
            && (currentOptions.detectIndentation === newOptions.detectIndentation)
            && (currentOptions.insertSpaces === newOptions.insertSpaces)
            && (currentOptions.tabSize === newOptions.tabSize)
            && (currentOptions.trimAutoWhitespace === newOptions.trimAutoWhitespace)) {
            // Same indent opts, no need to touch the model
            return;
        }
        if (newOptions.detectIndentation) {
            model.detectIndentation(newOptions.insertSpaces, newOptions.tabSize);
            model.updateOptions({
                trimAutoWhitespace: newOptions.trimAutoWhitespace
            });
        }
        else {
            model.updateOptions({
                insertSpaces: newOptions.insertSpaces,
                tabSize: newOptions.tabSize,
                trimAutoWhitespace: newOptions.trimAutoWhitespace
            });
        }
    };
    ModelServiceImpl.prototype.dispose = function () {
        if (this._markerServiceSubscription) {
            this._markerServiceSubscription.dispose();
        }
        this._configurationServiceSubscription.dispose();
    };
    ModelServiceImpl.prototype._handleMarkerChange = function (changedResources) {
        var _this = this;
        changedResources.forEach(function (resource) {
            var modelId = MODEL_ID$1(resource);
            var modelData = _this._models[modelId];
            if (!modelData) {
                return;
            }
            ModelMarkerHandler.setMarkers(modelData, _this._markerService);
        });
    };
    ModelServiceImpl.prototype._cleanUp = function (model) {
        var _this = this;
        // clean up markers for internal, transient models
        if (model.uri.scheme === Schemas.inMemory
            || model.uri.scheme === Schemas.internal
            || model.uri.scheme === Schemas.vscode) {
            if (this._markerService) {
                this._markerService.read({ resource: model.uri }).map(function (marker) { return marker.owner; }).forEach(function (owner) { return _this._markerService.remove(owner, [model.uri]); });
            }
        }
        // clean up cache
        delete this._modelCreationOptionsByLanguageAndResource[model.getLanguageIdentifier().language + model.uri];
    };
    // --- begin IModelService
    ModelServiceImpl.prototype._createModelData = function (value, languageIdentifier, resource, isForSimpleWidget) {
        var _this = this;
        // create & save the model
        var options = this.getCreationOptions(languageIdentifier.language, resource, isForSimpleWidget);
        var model = new TextModel(value, options, languageIdentifier, resource);
        var modelId = MODEL_ID$1(model.uri);
        if (this._models[modelId]) {
            // There already exists a model with this id => this is a programmer error
            throw new Error('ModelService: Cannot add model because it already exists!');
        }
        var modelData = new ModelData(model, function (model) { return _this._onWillDispose(model); }, function (model, e) { return _this._onDidChangeLanguage(model, e); });
        this._models[modelId] = modelData;
        return modelData;
    };
    ModelServiceImpl.prototype.updateModel = function (model, value) {
        var options = this.getCreationOptions(model.getLanguageIdentifier().language, model.uri, model.isForSimpleWidget);
        var textBuffer = createTextBuffer(value, options.defaultEOL);
        // Return early if the text is already set in that form
        if (model.equalsTextBuffer(textBuffer)) {
            return;
        }
        // Otherwise find a diff between the values and update model
        model.pushStackElement();
        model.setEOL(textBuffer.getEOL() === '\r\n' ? EndOfLineSequence.CRLF : EndOfLineSequence.LF);
        model.pushEditOperations([], ModelServiceImpl._computeEdits(model, textBuffer), function (inverseEditOperations) { return []; });
        model.pushStackElement();
    };
    ModelServiceImpl._commonPrefix = function (a, aLen, aDelta, b, bLen, bDelta) {
        var maxResult = Math.min(aLen, bLen);
        var result = 0;
        for (var i = 0; i < maxResult && a.getLineContent(aDelta + i) === b.getLineContent(bDelta + i); i++) {
            result++;
        }
        return result;
    };
    ModelServiceImpl._commonSuffix = function (a, aLen, aDelta, b, bLen, bDelta) {
        var maxResult = Math.min(aLen, bLen);
        var result = 0;
        for (var i = 0; i < maxResult && a.getLineContent(aDelta + aLen - i) === b.getLineContent(bDelta + bLen - i); i++) {
            result++;
        }
        return result;
    };
    /**
     * Compute edits to bring `model` to the state of `textSource`.
     */
    ModelServiceImpl._computeEdits = function (model, textBuffer) {
        var modelLineCount = model.getLineCount();
        var textBufferLineCount = textBuffer.getLineCount();
        var commonPrefix = this._commonPrefix(model, modelLineCount, 1, textBuffer, textBufferLineCount, 1);
        if (modelLineCount === textBufferLineCount && commonPrefix === modelLineCount) {
            // equality case
            return [];
        }
        var commonSuffix = this._commonSuffix(model, modelLineCount - commonPrefix, commonPrefix, textBuffer, textBufferLineCount - commonPrefix, commonPrefix);
        var oldRange, newRange;
        if (commonSuffix > 0) {
            oldRange = new Range(commonPrefix + 1, 1, modelLineCount - commonSuffix + 1, 1);
            newRange = new Range(commonPrefix + 1, 1, textBufferLineCount - commonSuffix + 1, 1);
        }
        else if (commonPrefix > 0) {
            oldRange = new Range(commonPrefix, model.getLineMaxColumn(commonPrefix), modelLineCount, model.getLineMaxColumn(modelLineCount));
            newRange = new Range(commonPrefix, 1 + textBuffer.getLineLength(commonPrefix), textBufferLineCount, 1 + textBuffer.getLineLength(textBufferLineCount));
        }
        else {
            oldRange = new Range(1, 1, modelLineCount, model.getLineMaxColumn(modelLineCount));
            newRange = new Range(1, 1, textBufferLineCount, 1 + textBuffer.getLineLength(textBufferLineCount));
        }
        return [EditOperation.replaceMove(oldRange, textBuffer.getValueInRange(newRange, EndOfLinePreference.TextDefined))];
    };
    ModelServiceImpl.prototype.createModel = function (value, modeOrPromise, resource, isForSimpleWidget) {
        if (isForSimpleWidget === void 0) { isForSimpleWidget = false; }
        var modelData;
        if (!modeOrPromise || TPromise.is(modeOrPromise)) {
            modelData = this._createModelData(value, PLAINTEXT_LANGUAGE_IDENTIFIER, resource, isForSimpleWidget);
            this.setMode(modelData.model, modeOrPromise);
        }
        else {
            modelData = this._createModelData(value, modeOrPromise.getLanguageIdentifier(), resource, isForSimpleWidget);
        }
        // handle markers (marker service => model)
        if (this._markerService) {
            ModelMarkerHandler.setMarkers(modelData, this._markerService);
        }
        this._onModelAdded.fire(modelData.model);
        return modelData.model;
    };
    ModelServiceImpl.prototype.setMode = function (model, modeOrPromise) {
        if (!modeOrPromise) {
            return;
        }
        if (TPromise.is(modeOrPromise)) {
            modeOrPromise.then(function (mode) {
                if (!model.isDisposed()) {
                    model.setMode(mode.getLanguageIdentifier());
                }
            });
        }
        else {
            model.setMode(modeOrPromise.getLanguageIdentifier());
        }
    };
    ModelServiceImpl.prototype.destroyModel = function (resource) {
        // We need to support that not all models get disposed through this service (i.e. model.dispose() should work!)
        var modelData = this._models[MODEL_ID$1(resource)];
        if (!modelData) {
            return;
        }
        modelData.model.dispose();
    };
    ModelServiceImpl.prototype.getModels = function () {
        var ret = [];
        var keys = Object.keys(this._models);
        for (var i = 0, len = keys.length; i < len; i++) {
            var modelId = keys[i];
            ret.push(this._models[modelId].model);
        }
        return ret;
    };
    ModelServiceImpl.prototype.getModel = function (resource) {
        var modelId = MODEL_ID$1(resource);
        var modelData = this._models[modelId];
        if (!modelData) {
            return null;
        }
        return modelData.model;
    };
    Object.defineProperty(ModelServiceImpl.prototype, "onModelAdded", {
        get: function () {
            return this._onModelAdded ? this._onModelAdded.event : null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ModelServiceImpl.prototype, "onModelRemoved", {
        get: function () {
            return this._onModelRemoved ? this._onModelRemoved.event : null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ModelServiceImpl.prototype, "onModelModeChanged", {
        get: function () {
            return this._onModelModeChanged ? this._onModelModeChanged.event : null;
        },
        enumerable: true,
        configurable: true
    });
    // --- end IModelService
    ModelServiceImpl.prototype._onWillDispose = function (model) {
        var modelId = MODEL_ID$1(model.uri);
        var modelData = this._models[modelId];
        delete this._models[modelId];
        modelData.dispose();
        this._cleanUp(model);
        this._onModelRemoved.fire(model);
    };
    ModelServiceImpl.prototype._onDidChangeLanguage = function (model, e) {
        var oldModeId = e.oldLanguage;
        var newModeId = model.getLanguageIdentifier().language;
        var oldOptions = this.getCreationOptions(oldModeId, model.uri, model.isForSimpleWidget);
        var newOptions = this.getCreationOptions(newModeId, model.uri, model.isForSimpleWidget);
        ModelServiceImpl._setModelOptionsForModel(model, newOptions, oldOptions);
        this._onModelModeChanged.fire({ model: model, oldModeId: oldModeId });
    };
    ModelServiceImpl = __decorate$b([
        __param$8(0, IMarkerService),
        __param$8(1, IConfigurationService)
    ], ModelServiceImpl);
    return ModelServiceImpl;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var AbstractCodeEditorService = /** @class */ (function () {
    function AbstractCodeEditorService() {
        this._transientWatchers = {};
        this._codeEditors = Object.create(null);
        this._diffEditors = Object.create(null);
        this._onCodeEditorAdd = new Emitter();
        this._onCodeEditorRemove = new Emitter();
        this._onDiffEditorAdd = new Emitter();
        this._onDiffEditorRemove = new Emitter();
    }
    AbstractCodeEditorService.prototype.addCodeEditor = function (editor) {
        this._codeEditors[editor.getId()] = editor;
        this._onCodeEditorAdd.fire(editor);
    };
    Object.defineProperty(AbstractCodeEditorService.prototype, "onCodeEditorAdd", {
        get: function () {
            return this._onCodeEditorAdd.event;
        },
        enumerable: true,
        configurable: true
    });
    AbstractCodeEditorService.prototype.removeCodeEditor = function (editor) {
        if (delete this._codeEditors[editor.getId()]) {
            this._onCodeEditorRemove.fire(editor);
        }
    };
    Object.defineProperty(AbstractCodeEditorService.prototype, "onCodeEditorRemove", {
        get: function () {
            return this._onCodeEditorRemove.event;
        },
        enumerable: true,
        configurable: true
    });
    AbstractCodeEditorService.prototype.listCodeEditors = function () {
        var _this = this;
        return Object.keys(this._codeEditors).map(function (id) { return _this._codeEditors[id]; });
    };
    AbstractCodeEditorService.prototype.addDiffEditor = function (editor) {
        this._diffEditors[editor.getId()] = editor;
        this._onDiffEditorAdd.fire(editor);
    };
    Object.defineProperty(AbstractCodeEditorService.prototype, "onDiffEditorAdd", {
        get: function () {
            return this._onDiffEditorAdd.event;
        },
        enumerable: true,
        configurable: true
    });
    AbstractCodeEditorService.prototype.removeDiffEditor = function (editor) {
        if (delete this._diffEditors[editor.getId()]) {
            this._onDiffEditorRemove.fire(editor);
        }
    };
    Object.defineProperty(AbstractCodeEditorService.prototype, "onDiffEditorRemove", {
        get: function () {
            return this._onDiffEditorRemove.event;
        },
        enumerable: true,
        configurable: true
    });
    AbstractCodeEditorService.prototype.listDiffEditors = function () {
        var _this = this;
        return Object.keys(this._diffEditors).map(function (id) { return _this._diffEditors[id]; });
    };
    AbstractCodeEditorService.prototype.getFocusedCodeEditor = function () {
        var editorWithWidgetFocus = null;
        var editors = this.listCodeEditors();
        for (var i = 0; i < editors.length; i++) {
            var editor = editors[i];
            if (editor.isFocused()) {
                // bingo!
                return editor;
            }
            if (editor.hasWidgetFocus()) {
                editorWithWidgetFocus = editor;
            }
        }
        return editorWithWidgetFocus;
    };
    AbstractCodeEditorService.prototype.setTransientModelProperty = function (model, key, value) {
        var uri = model.uri.toString();
        var w;
        if (this._transientWatchers.hasOwnProperty(uri)) {
            w = this._transientWatchers[uri];
        }
        else {
            w = new ModelTransientSettingWatcher(uri, model, this);
            this._transientWatchers[uri] = w;
        }
        w.set(key, value);
    };
    AbstractCodeEditorService.prototype.getTransientModelProperty = function (model, key) {
        var uri = model.uri.toString();
        if (!this._transientWatchers.hasOwnProperty(uri)) {
            return undefined;
        }
        return this._transientWatchers[uri].get(key);
    };
    AbstractCodeEditorService.prototype._removeWatcher = function (w) {
        delete this._transientWatchers[w.uri];
    };
    return AbstractCodeEditorService;
}());
var ModelTransientSettingWatcher = /** @class */ (function () {
    function ModelTransientSettingWatcher(uri, model, owner) {
        var _this = this;
        this.uri = uri;
        this._values = {};
        model.onWillDispose(function () { return owner._removeWatcher(_this); });
    }
    ModelTransientSettingWatcher.prototype.set = function (key, value) {
        this._values[key] = value;
    };
    ModelTransientSettingWatcher.prototype.get = function (key) {
        return this._values[key];
    };
    return ModelTransientSettingWatcher;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$1f = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate$c = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$9 = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var CodeEditorServiceImpl = /** @class */ (function (_super) {
    __extends$1f(CodeEditorServiceImpl, _super);
    function CodeEditorServiceImpl(themeService, styleSheet) {
        if (styleSheet === void 0) { styleSheet = createStyleSheet(); }
        var _this = _super.call(this) || this;
        _this._styleSheet = styleSheet;
        _this._decorationOptionProviders = Object.create(null);
        _this._themeService = themeService;
        return _this;
    }
    CodeEditorServiceImpl.prototype.registerDecorationType = function (key, options, parentTypeKey) {
        var provider = this._decorationOptionProviders[key];
        if (!provider) {
            var providerArgs = {
                styleSheet: this._styleSheet,
                key: key,
                parentTypeKey: parentTypeKey,
                options: options || Object.create(null)
            };
            if (!parentTypeKey) {
                provider = new DecorationTypeOptionsProvider(this._themeService, providerArgs);
            }
            else {
                provider = new DecorationSubTypeOptionsProvider(this._themeService, providerArgs);
            }
            this._decorationOptionProviders[key] = provider;
        }
        provider.refCount++;
    };
    CodeEditorServiceImpl.prototype.removeDecorationType = function (key) {
        var provider = this._decorationOptionProviders[key];
        if (provider) {
            provider.refCount--;
            if (provider.refCount <= 0) {
                delete this._decorationOptionProviders[key];
                provider.dispose();
                this.listCodeEditors().forEach(function (ed) { return ed.removeDecorations(key); });
            }
        }
    };
    CodeEditorServiceImpl.prototype.resolveDecorationOptions = function (decorationTypeKey, writable) {
        var provider = this._decorationOptionProviders[decorationTypeKey];
        if (!provider) {
            throw new Error('Unknown decoration type key: ' + decorationTypeKey);
        }
        return provider.getOptions(this, writable);
    };
    CodeEditorServiceImpl = __decorate$c([
        __param$9(0, IThemeService)
    ], CodeEditorServiceImpl);
    return CodeEditorServiceImpl;
}(AbstractCodeEditorService));
var DecorationSubTypeOptionsProvider = /** @class */ (function () {
    function DecorationSubTypeOptionsProvider(themeService, providerArgs) {
        this._parentTypeKey = providerArgs.parentTypeKey;
        this.refCount = 0;
        this._beforeContentRules = new DecorationCSSRules(3 /* BeforeContentClassName */, providerArgs, themeService);
        this._afterContentRules = new DecorationCSSRules(4 /* AfterContentClassName */, providerArgs, themeService);
    }
    DecorationSubTypeOptionsProvider.prototype.getOptions = function (codeEditorService, writable) {
        var options = codeEditorService.resolveDecorationOptions(this._parentTypeKey, true);
        if (this._beforeContentRules) {
            options.beforeContentClassName = this._beforeContentRules.className;
        }
        if (this._afterContentRules) {
            options.afterContentClassName = this._afterContentRules.className;
        }
        return options;
    };
    DecorationSubTypeOptionsProvider.prototype.dispose = function () {
        if (this._beforeContentRules) {
            this._beforeContentRules.dispose();
            this._beforeContentRules = null;
        }
        if (this._afterContentRules) {
            this._afterContentRules.dispose();
            this._afterContentRules = null;
        }
    };
    return DecorationSubTypeOptionsProvider;
}());
var DecorationTypeOptionsProvider = /** @class */ (function () {
    function DecorationTypeOptionsProvider(themeService, providerArgs) {
        var _this = this;
        this.refCount = 0;
        this._disposables = [];
        var createCSSRules = function (type) {
            var rules = new DecorationCSSRules(type, providerArgs, themeService);
            if (rules.hasContent) {
                _this._disposables.push(rules);
                return rules.className;
            }
            return void 0;
        };
        var createInlineCSSRules = function (type) {
            var rules = new DecorationCSSRules(type, providerArgs, themeService);
            if (rules.hasContent) {
                _this._disposables.push(rules);
                return { className: rules.className, hasLetterSpacing: rules.hasLetterSpacing };
            }
            return null;
        };
        this.className = createCSSRules(0 /* ClassName */);
        var inlineData = createInlineCSSRules(1 /* InlineClassName */);
        if (inlineData) {
            this.inlineClassName = inlineData.className;
            this.inlineClassNameAffectsLetterSpacing = inlineData.hasLetterSpacing;
        }
        this.beforeContentClassName = createCSSRules(3 /* BeforeContentClassName */);
        this.afterContentClassName = createCSSRules(4 /* AfterContentClassName */);
        this.glyphMarginClassName = createCSSRules(2 /* GlyphMarginClassName */);
        var options = providerArgs.options;
        this.isWholeLine = Boolean(options.isWholeLine);
        this.stickiness = options.rangeBehavior;
        var lightOverviewRulerColor = options.light && options.light.overviewRulerColor || options.overviewRulerColor;
        var darkOverviewRulerColor = options.dark && options.dark.overviewRulerColor || options.overviewRulerColor;
        if (typeof lightOverviewRulerColor !== 'undefined'
            || typeof darkOverviewRulerColor !== 'undefined') {
            this.overviewRuler = {
                color: lightOverviewRulerColor || darkOverviewRulerColor,
                darkColor: darkOverviewRulerColor || lightOverviewRulerColor,
                position: options.overviewRulerLane || OverviewRulerLane.Center
            };
        }
    }
    DecorationTypeOptionsProvider.prototype.getOptions = function (codeEditorService, writable) {
        if (!writable) {
            return this;
        }
        return {
            inlineClassName: this.inlineClassName,
            beforeContentClassName: this.beforeContentClassName,
            afterContentClassName: this.afterContentClassName,
            className: this.className,
            glyphMarginClassName: this.glyphMarginClassName,
            isWholeLine: this.isWholeLine,
            overviewRuler: this.overviewRuler,
            stickiness: this.stickiness
        };
    };
    DecorationTypeOptionsProvider.prototype.dispose = function () {
        this._disposables = dispose(this._disposables);
    };
    return DecorationTypeOptionsProvider;
}());
var _CSS_MAP = {
    color: 'color:{0} !important;',
    opacity: 'opacity:{0};',
    backgroundColor: 'background-color:{0};',
    outline: 'outline:{0};',
    outlineColor: 'outline-color:{0};',
    outlineStyle: 'outline-style:{0};',
    outlineWidth: 'outline-width:{0};',
    border: 'border:{0};',
    borderColor: 'border-color:{0};',
    borderRadius: 'border-radius:{0};',
    borderSpacing: 'border-spacing:{0};',
    borderStyle: 'border-style:{0};',
    borderWidth: 'border-width:{0};',
    fontStyle: 'font-style:{0};',
    fontWeight: 'font-weight:{0};',
    textDecoration: 'text-decoration:{0};',
    cursor: 'cursor:{0};',
    letterSpacing: 'letter-spacing:{0};',
    gutterIconPath: 'background:url(\'{0}\') center center no-repeat;',
    gutterIconSize: 'background-size:{0};',
    contentText: 'content:\'{0}\';',
    contentIconPath: 'content:url(\'{0}\');',
    margin: 'margin:{0};',
    width: 'width:{0};',
    height: 'height:{0};'
};
var DecorationCSSRules = /** @class */ (function () {
    function DecorationCSSRules(ruleType, providerArgs, themeService) {
        var _this = this;
        this._theme = themeService.getTheme();
        this._ruleType = ruleType;
        this._providerArgs = providerArgs;
        this._usesThemeColors = false;
        this._hasContent = false;
        this._hasLetterSpacing = false;
        var className = CSSNameHelper.getClassName(this._providerArgs.key, ruleType);
        if (this._providerArgs.parentTypeKey) {
            className = className + ' ' + CSSNameHelper.getClassName(this._providerArgs.parentTypeKey, ruleType);
        }
        this._className = className;
        this._unThemedSelector = CSSNameHelper.getSelector(this._providerArgs.key, this._providerArgs.parentTypeKey, ruleType);
        this._buildCSS();
        if (this._usesThemeColors) {
            this._themeListener = themeService.onThemeChange(function (theme) {
                _this._theme = themeService.getTheme();
                _this._removeCSS();
                _this._buildCSS();
            });
        }
    }
    DecorationCSSRules.prototype.dispose = function () {
        if (this._hasContent) {
            this._removeCSS();
            this._hasContent = false;
        }
        if (this._themeListener) {
            this._themeListener.dispose();
            this._themeListener = null;
        }
    };
    Object.defineProperty(DecorationCSSRules.prototype, "hasContent", {
        get: function () {
            return this._hasContent;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DecorationCSSRules.prototype, "hasLetterSpacing", {
        get: function () {
            return this._hasLetterSpacing;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DecorationCSSRules.prototype, "className", {
        get: function () {
            return this._className;
        },
        enumerable: true,
        configurable: true
    });
    DecorationCSSRules.prototype._buildCSS = function () {
        var options = this._providerArgs.options;
        var unthemedCSS, lightCSS, darkCSS;
        switch (this._ruleType) {
            case 0 /* ClassName */:
                unthemedCSS = this.getCSSTextForModelDecorationClassName(options);
                lightCSS = this.getCSSTextForModelDecorationClassName(options.light);
                darkCSS = this.getCSSTextForModelDecorationClassName(options.dark);
                break;
            case 1 /* InlineClassName */:
                unthemedCSS = this.getCSSTextForModelDecorationInlineClassName(options);
                lightCSS = this.getCSSTextForModelDecorationInlineClassName(options.light);
                darkCSS = this.getCSSTextForModelDecorationInlineClassName(options.dark);
                break;
            case 2 /* GlyphMarginClassName */:
                unthemedCSS = this.getCSSTextForModelDecorationGlyphMarginClassName(options);
                lightCSS = this.getCSSTextForModelDecorationGlyphMarginClassName(options.light);
                darkCSS = this.getCSSTextForModelDecorationGlyphMarginClassName(options.dark);
                break;
            case 3 /* BeforeContentClassName */:
                unthemedCSS = this.getCSSTextForModelDecorationContentClassName(options.before);
                lightCSS = this.getCSSTextForModelDecorationContentClassName(options.light && options.light.before);
                darkCSS = this.getCSSTextForModelDecorationContentClassName(options.dark && options.dark.before);
                break;
            case 4 /* AfterContentClassName */:
                unthemedCSS = this.getCSSTextForModelDecorationContentClassName(options.after);
                lightCSS = this.getCSSTextForModelDecorationContentClassName(options.light && options.light.after);
                darkCSS = this.getCSSTextForModelDecorationContentClassName(options.dark && options.dark.after);
                break;
            default:
                throw new Error('Unknown rule type: ' + this._ruleType);
        }
        var sheet = this._providerArgs.styleSheet.sheet;
        var hasContent = false;
        if (unthemedCSS.length > 0) {
            sheet.insertRule(this._unThemedSelector + " {" + unthemedCSS + "}", 0);
            hasContent = true;
        }
        if (lightCSS.length > 0) {
            sheet.insertRule(".vs" + this._unThemedSelector + " {" + lightCSS + "}", 0);
            hasContent = true;
        }
        if (darkCSS.length > 0) {
            sheet.insertRule(".vs-dark" + this._unThemedSelector + ", .hc-black" + this._unThemedSelector + " {" + darkCSS + "}", 0);
            hasContent = true;
        }
        this._hasContent = hasContent;
    };
    DecorationCSSRules.prototype._removeCSS = function () {
        removeCSSRulesContainingSelector(this._unThemedSelector, this._providerArgs.styleSheet);
    };
    /**
     * Build the CSS for decorations styled via `className`.
     */
    DecorationCSSRules.prototype.getCSSTextForModelDecorationClassName = function (opts) {
        if (!opts) {
            return '';
        }
        var cssTextArr = [];
        this.collectCSSText(opts, ['backgroundColor'], cssTextArr);
        this.collectCSSText(opts, ['outline', 'outlineColor', 'outlineStyle', 'outlineWidth'], cssTextArr);
        this.collectBorderSettingsCSSText(opts, cssTextArr);
        return cssTextArr.join('');
    };
    /**
     * Build the CSS for decorations styled via `inlineClassName`.
     */
    DecorationCSSRules.prototype.getCSSTextForModelDecorationInlineClassName = function (opts) {
        if (!opts) {
            return '';
        }
        var cssTextArr = [];
        this.collectCSSText(opts, ['fontStyle', 'fontWeight', 'textDecoration', 'cursor', 'color', 'opacity', 'letterSpacing'], cssTextArr);
        if (opts.letterSpacing) {
            this._hasLetterSpacing = true;
        }
        return cssTextArr.join('');
    };
    /**
     * Build the CSS for decorations styled before or after content.
     */
    DecorationCSSRules.prototype.getCSSTextForModelDecorationContentClassName = function (opts) {
        if (!opts) {
            return '';
        }
        var cssTextArr = [];
        if (typeof opts !== 'undefined') {
            this.collectBorderSettingsCSSText(opts, cssTextArr);
            if (typeof opts.contentIconPath !== 'undefined') {
                if (typeof opts.contentIconPath === 'string') {
                    cssTextArr.push(format(_CSS_MAP.contentIconPath, URI.file(opts.contentIconPath).toString().replace(/'/g, '%27')));
                }
                else {
                    cssTextArr.push(format(_CSS_MAP.contentIconPath, URI.revive(opts.contentIconPath).toString(true).replace(/'/g, '%27')));
                }
            }
            if (typeof opts.contentText === 'string') {
                var truncated = opts.contentText.match(/^.*$/m)[0]; // only take first line
                var escaped = truncated.replace(/['\\]/g, '\\$&');
                cssTextArr.push(format(_CSS_MAP.contentText, escaped));
            }
            this.collectCSSText(opts, ['fontStyle', 'fontWeight', 'textDecoration', 'color', 'opacity', 'backgroundColor', 'margin'], cssTextArr);
            if (this.collectCSSText(opts, ['width', 'height'], cssTextArr)) {
                cssTextArr.push('display:inline-block;');
            }
        }
        return cssTextArr.join('');
    };
    /**
     * Build the CSS for decorations styled via `glpyhMarginClassName`.
     */
    DecorationCSSRules.prototype.getCSSTextForModelDecorationGlyphMarginClassName = function (opts) {
        if (!opts) {
            return '';
        }
        var cssTextArr = [];
        if (typeof opts.gutterIconPath !== 'undefined') {
            if (typeof opts.gutterIconPath === 'string') {
                cssTextArr.push(format(_CSS_MAP.gutterIconPath, URI.file(opts.gutterIconPath).toString()));
            }
            else {
                cssTextArr.push(format(_CSS_MAP.gutterIconPath, URI.revive(opts.gutterIconPath).toString(true).replace(/'/g, '%27')));
            }
            if (typeof opts.gutterIconSize !== 'undefined') {
                cssTextArr.push(format(_CSS_MAP.gutterIconSize, opts.gutterIconSize));
            }
        }
        return cssTextArr.join('');
    };
    DecorationCSSRules.prototype.collectBorderSettingsCSSText = function (opts, cssTextArr) {
        if (this.collectCSSText(opts, ['border', 'borderColor', 'borderRadius', 'borderSpacing', 'borderStyle', 'borderWidth'], cssTextArr)) {
            cssTextArr.push(format('box-sizing: border-box;'));
            return true;
        }
        return false;
    };
    DecorationCSSRules.prototype.collectCSSText = function (opts, properties, cssTextArr) {
        var lenBefore = cssTextArr.length;
        for (var _i = 0, properties_1 = properties; _i < properties_1.length; _i++) {
            var property = properties_1[_i];
            var value = this.resolveValue(opts[property]);
            if (typeof value === 'string') {
                cssTextArr.push(format(_CSS_MAP[property], value));
            }
        }
        return cssTextArr.length !== lenBefore;
    };
    DecorationCSSRules.prototype.resolveValue = function (value) {
        if (isThemeColor(value)) {
            this._usesThemeColors = true;
            var color = this._theme.getColor(value.id);
            if (color) {
                return color.toString();
            }
            return 'transparent';
        }
        return value;
    };
    return DecorationCSSRules;
}());
var CSSNameHelper = /** @class */ (function () {
    function CSSNameHelper() {
    }
    CSSNameHelper.getClassName = function (key, type) {
        return 'ced-' + key + '-' + type;
    };
    CSSNameHelper.getSelector = function (key, parentKey, ruleType) {
        var selector = '.monaco-editor .' + this.getClassName(key, ruleType);
        if (parentKey) {
            selector = selector + '.' + this.getClassName(parentKey, ruleType);
        }
        if (ruleType === 3 /* BeforeContentClassName */) {
            selector += '::before';
        }
        else if (ruleType === 4 /* AfterContentClassName */) {
            selector += '::after';
        }
        return selector;
    };
    return CSSNameHelper;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$1g = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign$2 = (undefined && undefined.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
var __decorate$d = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$a = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var KEYBINDING_CONTEXT_ATTR = 'data-keybinding-context';
var Context = /** @class */ (function () {
    function Context(id, parent) {
        this._id = id;
        this._parent = parent;
        this._value = Object.create(null);
        this._value['_contextId'] = id;
    }
    Context.prototype.setValue = function (key, value) {
        // console.log('SET ' + key + ' = ' + value + ' ON ' + this._id);
        if (this._value[key] !== value) {
            this._value[key] = value;
            return true;
        }
        return false;
    };
    Context.prototype.removeValue = function (key) {
        // console.log('REMOVE ' + key + ' FROM ' + this._id);
        if (key in this._value) {
            delete this._value[key];
            return true;
        }
        return false;
    };
    Context.prototype.getValue = function (key) {
        var ret = this._value[key];
        if (typeof ret === 'undefined' && this._parent) {
            return this._parent.getValue(key);
        }
        return ret;
    };
    Context.prototype.collectAllValues = function () {
        var result = this._parent ? this._parent.collectAllValues() : Object.create(null);
        result = __assign$2({}, result, this._value);
        delete result['_contextId'];
        return result;
    };
    return Context;
}());
var ConfigAwareContextValuesContainer = /** @class */ (function (_super) {
    __extends$1g(ConfigAwareContextValuesContainer, _super);
    function ConfigAwareContextValuesContainer(id, configurationService, emitter) {
        var _this = _super.call(this, id, null) || this;
        _this._emitter = emitter;
        _this._configurationService = configurationService;
        _this._subscription = configurationService.onDidChangeConfiguration(_this._onConfigurationUpdated, _this);
        _this._initFromConfiguration();
        return _this;
    }
    ConfigAwareContextValuesContainer.prototype.dispose = function () {
        this._subscription.dispose();
    };
    ConfigAwareContextValuesContainer.prototype._onConfigurationUpdated = function (event) {
        if (event.source === ConfigurationTarget.DEFAULT) {
            // new setting, rebuild everything
            this._initFromConfiguration();
        }
        else {
            // update those that we know
            for (var _i = 0, _a = event.affectedKeys; _i < _a.length; _i++) {
                var configKey = _a[_i];
                var contextKey = "config." + configKey;
                if (contextKey in this._value) {
                    this._value[contextKey] = this._configurationService.getValue(configKey);
                    this._emitter.fire(configKey);
                }
            }
        }
    };
    ConfigAwareContextValuesContainer.prototype._initFromConfiguration = function () {
        var _this = this;
        var prefix = 'config.';
        var config = this._configurationService.getValue();
        var configKeys = Object.create(null);
        var configKeysChanged = [];
        // add new value from config
        var walk = function (obj, keys) {
            for (var key in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, key)) {
                    keys.push(key);
                    var value = obj[key];
                    if (typeof value === 'boolean') {
                        var configKey = keys.join('.');
                        var oldValue = _this._value[configKey];
                        _this._value[configKey] = value;
                        if (oldValue !== value) {
                            configKeysChanged.push(configKey);
                            configKeys[configKey] = true;
                        }
                        else {
                            configKeys[configKey] = false;
                        }
                    }
                    else if (typeof value === 'object') {
                        walk(value, keys);
                    }
                    keys.pop();
                }
            }
        };
        walk(config, ['config']);
        // remove unused keys
        for (var key in this._value) {
            if (key.indexOf(prefix) === 0 && configKeys[key] === undefined) {
                delete this._value[key];
                configKeys[key] = true;
                configKeysChanged.push(key);
            }
        }
        // send events
        this._emitter.fire(configKeysChanged);
    };
    return ConfigAwareContextValuesContainer;
}(Context));
var ContextKey = /** @class */ (function () {
    function ContextKey(parent, key, defaultValue) {
        this._parent = parent;
        this._key = key;
        this._defaultValue = defaultValue;
        this.reset();
    }
    ContextKey.prototype.set = function (value) {
        this._parent.setContext(this._key, value);
    };
    ContextKey.prototype.reset = function () {
        if (typeof this._defaultValue === 'undefined') {
            this._parent.removeContext(this._key);
        }
        else {
            this._parent.setContext(this._key, this._defaultValue);
        }
    };
    ContextKey.prototype.get = function () {
        return this._parent.getContextKeyValue(this._key);
    };
    return ContextKey;
}());
var ContextKeyChangeEvent = /** @class */ (function () {
    function ContextKeyChangeEvent() {
        this._keys = [];
    }
    ContextKeyChangeEvent.prototype.collect = function (oneOrManyKeys) {
        this._keys = this._keys.concat(oneOrManyKeys);
    };
    ContextKeyChangeEvent.prototype.affectsSome = function (keys) {
        for (var _i = 0, _a = this._keys; _i < _a.length; _i++) {
            var key = _a[_i];
            if (keys.has(key)) {
                return true;
            }
        }
        return false;
    };
    return ContextKeyChangeEvent;
}());
var AbstractContextKeyService = /** @class */ (function () {
    function AbstractContextKeyService(myContextId) {
        this._myContextId = myContextId;
        this._onDidChangeContextKey = new Emitter();
    }
    AbstractContextKeyService.prototype.createKey = function (key, defaultValue) {
        return new ContextKey(this, key, defaultValue);
    };
    Object.defineProperty(AbstractContextKeyService.prototype, "onDidChangeContext", {
        get: function () {
            if (!this._onDidChangeContext) {
                this._onDidChangeContext = debounceEvent(this._onDidChangeContextKey.event, function (prev, cur) {
                    if (!prev) {
                        prev = new ContextKeyChangeEvent();
                    }
                    prev.collect(cur);
                    return prev;
                }, 25);
            }
            return this._onDidChangeContext;
        },
        enumerable: true,
        configurable: true
    });
    AbstractContextKeyService.prototype.createScoped = function (domNode) {
        return new ScopedContextKeyService(this, this._onDidChangeContextKey, domNode);
    };
    AbstractContextKeyService.prototype.contextMatchesRules = function (rules) {
        var context = this.getContextValuesContainer(this._myContextId);
        var result = KeybindingResolver.contextMatchesRules(context, rules);
        // console.group(rules.serialize() + ' -> ' + result);
        // rules.keys().forEach(key => { console.log(key, ctx[key]); });
        // console.groupEnd();
        return result;
    };
    AbstractContextKeyService.prototype.getContextKeyValue = function (key) {
        return this.getContextValuesContainer(this._myContextId).getValue(key);
    };
    AbstractContextKeyService.prototype.setContext = function (key, value) {
        var myContext = this.getContextValuesContainer(this._myContextId);
        if (!myContext) {
            return;
        }
        if (myContext.setValue(key, value)) {
            this._onDidChangeContextKey.fire(key);
        }
    };
    AbstractContextKeyService.prototype.removeContext = function (key) {
        if (this.getContextValuesContainer(this._myContextId).removeValue(key)) {
            this._onDidChangeContextKey.fire(key);
        }
    };
    AbstractContextKeyService.prototype.getContext = function (target) {
        return this.getContextValuesContainer(findContextAttr(target));
    };
    return AbstractContextKeyService;
}());
var ContextKeyService = /** @class */ (function (_super) {
    __extends$1g(ContextKeyService, _super);
    function ContextKeyService(configurationService) {
        var _this = _super.call(this, 0) || this;
        _this._toDispose = [];
        _this._lastContextId = 0;
        _this._contexts = Object.create(null);
        var myContext = new ConfigAwareContextValuesContainer(_this._myContextId, configurationService, _this._onDidChangeContextKey);
        _this._contexts[String(_this._myContextId)] = myContext;
        _this._toDispose.push(myContext);
        return _this;
        // Uncomment this to see the contexts continuously logged
        // let lastLoggedValue: string = null;
        // setInterval(() => {
        // 	let values = Object.keys(this._contexts).map((key) => this._contexts[key]);
        // 	let logValue = values.map(v => JSON.stringify(v._value, null, '\t')).join('\n');
        // 	if (lastLoggedValue !== logValue) {
        // 		lastLoggedValue = logValue;
        // 		console.log(lastLoggedValue);
        // 	}
        // }, 2000);
    }
    ContextKeyService.prototype.dispose = function () {
        this._toDispose = dispose(this._toDispose);
    };
    ContextKeyService.prototype.getContextValuesContainer = function (contextId) {
        return this._contexts[String(contextId)];
    };
    ContextKeyService.prototype.createChildContext = function (parentContextId) {
        if (parentContextId === void 0) { parentContextId = this._myContextId; }
        var id = (++this._lastContextId);
        this._contexts[String(id)] = new Context(id, this.getContextValuesContainer(parentContextId));
        return id;
    };
    ContextKeyService.prototype.disposeContext = function (contextId) {
        delete this._contexts[String(contextId)];
    };
    ContextKeyService = __decorate$d([
        __param$a(0, IConfigurationService)
    ], ContextKeyService);
    return ContextKeyService;
}(AbstractContextKeyService));
var ScopedContextKeyService = /** @class */ (function (_super) {
    __extends$1g(ScopedContextKeyService, _super);
    function ScopedContextKeyService(parent, emitter, domNode) {
        var _this = _super.call(this, parent.createChildContext()) || this;
        _this._parent = parent;
        _this._onDidChangeContextKey = emitter;
        if (domNode) {
            _this._domNode = domNode;
            _this._domNode.setAttribute(KEYBINDING_CONTEXT_ATTR, String(_this._myContextId));
        }
        return _this;
    }
    ScopedContextKeyService.prototype.dispose = function () {
        this._parent.disposeContext(this._myContextId);
        if (this._domNode) {
            this._domNode.removeAttribute(KEYBINDING_CONTEXT_ATTR);
        }
    };
    Object.defineProperty(ScopedContextKeyService.prototype, "onDidChangeContext", {
        get: function () {
            return this._parent.onDidChangeContext;
        },
        enumerable: true,
        configurable: true
    });
    ScopedContextKeyService.prototype.getContextValuesContainer = function (contextId) {
        return this._parent.getContextValuesContainer(contextId);
    };
    ScopedContextKeyService.prototype.createChildContext = function (parentContextId) {
        if (parentContextId === void 0) { parentContextId = this._myContextId; }
        return this._parent.createChildContext(parentContextId);
    };
    ScopedContextKeyService.prototype.disposeContext = function (contextId) {
        this._parent.disposeContext(contextId);
    };
    return ScopedContextKeyService;
}(AbstractContextKeyService));
function findContextAttr(domNode) {
    while (domNode) {
        if (domNode.hasAttribute(KEYBINDING_CONTEXT_ATTR)) {
            return parseInt(domNode.getAttribute(KEYBINDING_CONTEXT_ATTR), 10);
        }
        domNode = domNode.parentElement;
    }
    return 0;
}
CommandsRegistry.registerCommand(SET_CONTEXT_COMMAND_ID, function (accessor, contextKey, contextValue) {
    accessor.get(IContextKeyService).createKey(String(contextKey), contextValue);
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var ParsedTokenThemeRule = /** @class */ (function () {
    function ParsedTokenThemeRule(token, index, fontStyle, foreground, background) {
        this.token = token;
        this.index = index;
        this.fontStyle = fontStyle;
        this.foreground = foreground;
        this.background = background;
    }
    return ParsedTokenThemeRule;
}());
/**
 * Parse a raw theme into rules.
 */
function parseTokenTheme(source) {
    if (!source || !Array.isArray(source)) {
        return [];
    }
    var result = [], resultLen = 0;
    for (var i = 0, len = source.length; i < len; i++) {
        var entry = source[i];
        var fontStyle = -1 /* NotSet */;
        if (typeof entry.fontStyle === 'string') {
            fontStyle = 0 /* None */;
            var segments = entry.fontStyle.split(' ');
            for (var j = 0, lenJ = segments.length; j < lenJ; j++) {
                var segment = segments[j];
                switch (segment) {
                    case 'italic':
                        fontStyle = fontStyle | 1 /* Italic */;
                        break;
                    case 'bold':
                        fontStyle = fontStyle | 2 /* Bold */;
                        break;
                    case 'underline':
                        fontStyle = fontStyle | 4 /* Underline */;
                        break;
                }
            }
        }
        var foreground = null;
        if (typeof entry.foreground === 'string') {
            foreground = entry.foreground;
        }
        var background = null;
        if (typeof entry.background === 'string') {
            background = entry.background;
        }
        result[resultLen++] = new ParsedTokenThemeRule(entry.token || '', i, fontStyle, foreground, background);
    }
    return result;
}
/**
 * Resolve rules (i.e. inheritance).
 */
function resolveParsedTokenThemeRules(parsedThemeRules) {
    // Sort rules lexicographically, and then by index if necessary
    parsedThemeRules.sort(function (a, b) {
        var r = strcmp(a.token, b.token);
        if (r !== 0) {
            return r;
        }
        return a.index - b.index;
    });
    // Determine defaults
    var defaultFontStyle = 0 /* None */;
    var defaultForeground = '000000';
    var defaultBackground = 'ffffff';
    while (parsedThemeRules.length >= 1 && parsedThemeRules[0].token === '') {
        var incomingDefaults = parsedThemeRules.shift();
        if (incomingDefaults.fontStyle !== -1 /* NotSet */) {
            defaultFontStyle = incomingDefaults.fontStyle;
        }
        if (incomingDefaults.foreground !== null) {
            defaultForeground = incomingDefaults.foreground;
        }
        if (incomingDefaults.background !== null) {
            defaultBackground = incomingDefaults.background;
        }
    }
    var colorMap = new ColorMap();
    // ensure default foreground gets id 1 and default background gets id 2
    var defaults = new ThemeTrieElementRule(defaultFontStyle, colorMap.getId(defaultForeground), colorMap.getId(defaultBackground));
    var root = new ThemeTrieElement(defaults);
    for (var i = 0, len = parsedThemeRules.length; i < len; i++) {
        var rule = parsedThemeRules[i];
        root.insert(rule.token, rule.fontStyle, colorMap.getId(rule.foreground), colorMap.getId(rule.background));
    }
    return new TokenTheme(colorMap, root);
}
var ColorMap = /** @class */ (function () {
    function ColorMap() {
        this._lastColorId = 0;
        this._id2color = [];
        this._color2id = new Map();
    }
    ColorMap.prototype.getId = function (color) {
        if (color === null) {
            return 0;
        }
        color = color.toUpperCase();
        if (!/^[0-9A-F]{6}$/.test(color)) {
            throw new Error('Illegal color name: ' + color);
        }
        var value = this._color2id.get(color);
        if (value) {
            return value;
        }
        value = ++this._lastColorId;
        this._color2id.set(color, value);
        this._id2color[value] = Color.fromHex('#' + color);
        return value;
    };
    ColorMap.prototype.getColorMap = function () {
        return this._id2color.slice(0);
    };
    return ColorMap;
}());
var TokenTheme = /** @class */ (function () {
    function TokenTheme(colorMap, root) {
        this._colorMap = colorMap;
        this._root = root;
        this._cache = new Map();
    }
    TokenTheme.createFromRawTokenTheme = function (source) {
        return this.createFromParsedTokenTheme(parseTokenTheme(source));
    };
    TokenTheme.createFromParsedTokenTheme = function (source) {
        return resolveParsedTokenThemeRules(source);
    };
    TokenTheme.prototype.getColorMap = function () {
        return this._colorMap.getColorMap();
    };
    /**
     * used for testing purposes
     */
    TokenTheme.prototype.getThemeTrieElement = function () {
        return this._root.toExternalThemeTrieElement();
    };
    TokenTheme.prototype._match = function (token) {
        return this._root.match(token);
    };
    TokenTheme.prototype.match = function (languageId, token) {
        // The cache contains the metadata without the language bits set.
        var result = this._cache.get(token);
        if (typeof result === 'undefined') {
            var rule = this._match(token);
            var standardToken = toStandardTokenType(token);
            result = (rule.metadata
                | (standardToken << 8 /* TOKEN_TYPE_OFFSET */)) >>> 0;
            this._cache.set(token, result);
        }
        return (result
            | (languageId << 0 /* LANGUAGEID_OFFSET */)) >>> 0;
    };
    return TokenTheme;
}());
var STANDARD_TOKEN_TYPE_REGEXP = /\b(comment|string|regex)\b/;
function toStandardTokenType(tokenType) {
    var m = tokenType.match(STANDARD_TOKEN_TYPE_REGEXP);
    if (!m) {
        return 0 /* Other */;
    }
    switch (m[1]) {
        case 'comment':
            return 1 /* Comment */;
        case 'string':
            return 2 /* String */;
        case 'regex':
            return 4 /* RegEx */;
    }
    throw new Error('Unexpected match for standard token type!');
}
function strcmp(a, b) {
    if (a < b) {
        return -1;
    }
    if (a > b) {
        return 1;
    }
    return 0;
}
var ThemeTrieElementRule = /** @class */ (function () {
    function ThemeTrieElementRule(fontStyle, foreground, background) {
        this._fontStyle = fontStyle;
        this._foreground = foreground;
        this._background = background;
        this.metadata = ((this._fontStyle << 11 /* FONT_STYLE_OFFSET */)
            | (this._foreground << 14 /* FOREGROUND_OFFSET */)
            | (this._background << 23 /* BACKGROUND_OFFSET */)) >>> 0;
    }
    ThemeTrieElementRule.prototype.clone = function () {
        return new ThemeTrieElementRule(this._fontStyle, this._foreground, this._background);
    };
    ThemeTrieElementRule.prototype.acceptOverwrite = function (fontStyle, foreground, background) {
        if (fontStyle !== -1 /* NotSet */) {
            this._fontStyle = fontStyle;
        }
        if (foreground !== 0 /* None */) {
            this._foreground = foreground;
        }
        if (background !== 0 /* None */) {
            this._background = background;
        }
        this.metadata = ((this._fontStyle << 11 /* FONT_STYLE_OFFSET */)
            | (this._foreground << 14 /* FOREGROUND_OFFSET */)
            | (this._background << 23 /* BACKGROUND_OFFSET */)) >>> 0;
    };
    return ThemeTrieElementRule;
}());
var ExternalThemeTrieElement = /** @class */ (function () {
    function ExternalThemeTrieElement(mainRule, children) {
        this.mainRule = mainRule;
        this.children = children || Object.create(null);
    }
    return ExternalThemeTrieElement;
}());
var ThemeTrieElement = /** @class */ (function () {
    function ThemeTrieElement(mainRule) {
        this._mainRule = mainRule;
        this._children = new Map();
    }
    /**
     * used for testing purposes
     */
    ThemeTrieElement.prototype.toExternalThemeTrieElement = function () {
        var children = Object.create(null);
        this._children.forEach(function (element, index) {
            children[index] = element.toExternalThemeTrieElement();
        });
        return new ExternalThemeTrieElement(this._mainRule, children);
    };
    ThemeTrieElement.prototype.match = function (token) {
        if (token === '') {
            return this._mainRule;
        }
        var dotIndex = token.indexOf('.');
        var head;
        var tail;
        if (dotIndex === -1) {
            head = token;
            tail = '';
        }
        else {
            head = token.substring(0, dotIndex);
            tail = token.substring(dotIndex + 1);
        }
        var child = this._children.get(head);
        if (typeof child !== 'undefined') {
            return child.match(tail);
        }
        return this._mainRule;
    };
    ThemeTrieElement.prototype.insert = function (token, fontStyle, foreground, background) {
        if (token === '') {
            // Merge into the main rule
            this._mainRule.acceptOverwrite(fontStyle, foreground, background);
            return;
        }
        var dotIndex = token.indexOf('.');
        var head;
        var tail;
        if (dotIndex === -1) {
            head = token;
            tail = '';
        }
        else {
            head = token.substring(0, dotIndex);
            tail = token.substring(dotIndex + 1);
        }
        var child = this._children.get(head);
        if (typeof child === 'undefined') {
            child = new ThemeTrieElement(this._mainRule.clone());
            this._children.set(head, child);
        }
        child.insert(tail, fontStyle, foreground, background);
    };
    return ThemeTrieElement;
}());
function generateTokensCSSForColorMap(colorMap) {
    var rules = [];
    for (var i = 1, len = colorMap.length; i < len; i++) {
        var color = colorMap[i];
        rules[i] = ".mtk" + i + " { color: " + color + "; }";
    }
    rules.push('.mtki { font-style: italic; }');
    rules.push('.mtkb { font-weight: bold; }');
    rules.push('.mtku { text-decoration: underline; }');
    return rules.join('\n');
}

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
/* -------------------------------- Begin vs theme -------------------------------- */
var vs = {
    base: 'vs',
    inherit: false,
    rules: [
        { token: '', foreground: '000000', background: 'fffffe' },
        { token: 'invalid', foreground: 'cd3131' },
        { token: 'emphasis', fontStyle: 'italic' },
        { token: 'strong', fontStyle: 'bold' },
        { token: 'variable', foreground: '001188' },
        { token: 'variable.predefined', foreground: '4864AA' },
        { token: 'constant', foreground: 'dd0000' },
        { token: 'comment', foreground: '008000' },
        { token: 'number', foreground: '09885A' },
        { token: 'number.hex', foreground: '3030c0' },
        { token: 'regexp', foreground: '800000' },
        { token: 'annotation', foreground: '808080' },
        { token: 'type', foreground: '008080' },
        { token: 'delimiter', foreground: '000000' },
        { token: 'delimiter.html', foreground: '383838' },
        { token: 'delimiter.xml', foreground: '0000FF' },
        { token: 'tag', foreground: '800000' },
        { token: 'tag.id.jade', foreground: '4F76AC' },
        { token: 'tag.class.jade', foreground: '4F76AC' },
        { token: 'meta.scss', foreground: '800000' },
        { token: 'metatag', foreground: 'e00000' },
        { token: 'metatag.content.html', foreground: 'FF0000' },
        { token: 'metatag.html', foreground: '808080' },
        { token: 'metatag.xml', foreground: '808080' },
        { token: 'metatag.php', fontStyle: 'bold' },
        { token: 'key', foreground: '863B00' },
        { token: 'string.key.json', foreground: 'A31515' },
        { token: 'string.value.json', foreground: '0451A5' },
        { token: 'attribute.name', foreground: 'FF0000' },
        { token: 'attribute.value', foreground: '0451A5' },
        { token: 'attribute.value.number', foreground: '09885A' },
        { token: 'attribute.value.unit', foreground: '09885A' },
        { token: 'attribute.value.html', foreground: '0000FF' },
        { token: 'attribute.value.xml', foreground: '0000FF' },
        { token: 'string', foreground: 'A31515' },
        { token: 'string.html', foreground: '0000FF' },
        { token: 'string.sql', foreground: 'FF0000' },
        { token: 'string.yaml', foreground: '0451A5' },
        { token: 'keyword', foreground: '0000FF' },
        { token: 'keyword.json', foreground: '0451A5' },
        { token: 'keyword.flow', foreground: 'AF00DB' },
        { token: 'keyword.flow.scss', foreground: '0000FF' },
        { token: 'operator.scss', foreground: '666666' },
        { token: 'operator.sql', foreground: '778899' },
        { token: 'operator.swift', foreground: '666666' },
        { token: 'predefined.sql', foreground: 'FF00FF' },
    ],
    colors: (_a = {},
        _a[editorBackground] = '#FFFFFE',
        _a[editorForeground] = '#000000',
        _a[editorInactiveSelection] = '#E5EBF1',
        _a[editorIndentGuides] = '#D3D3D3',
        _a[editorActiveIndentGuides] = '#939393',
        _a[editorSelectionHighlight] = '#ADD6FF4D',
        _a)
};
/* -------------------------------- End vs theme -------------------------------- */
/* -------------------------------- Begin vs-dark theme -------------------------------- */
var vs_dark = {
    base: 'vs-dark',
    inherit: false,
    rules: [
        { token: '', foreground: 'D4D4D4', background: '1E1E1E' },
        { token: 'invalid', foreground: 'f44747' },
        { token: 'emphasis', fontStyle: 'italic' },
        { token: 'strong', fontStyle: 'bold' },
        { token: 'variable', foreground: '74B0DF' },
        { token: 'variable.predefined', foreground: '4864AA' },
        { token: 'variable.parameter', foreground: '9CDCFE' },
        { token: 'constant', foreground: '569CD6' },
        { token: 'comment', foreground: '608B4E' },
        { token: 'number', foreground: 'B5CEA8' },
        { token: 'number.hex', foreground: '5BB498' },
        { token: 'regexp', foreground: 'B46695' },
        { token: 'annotation', foreground: 'cc6666' },
        { token: 'type', foreground: '3DC9B0' },
        { token: 'delimiter', foreground: 'DCDCDC' },
        { token: 'delimiter.html', foreground: '808080' },
        { token: 'delimiter.xml', foreground: '808080' },
        { token: 'tag', foreground: '569CD6' },
        { token: 'tag.id.jade', foreground: '4F76AC' },
        { token: 'tag.class.jade', foreground: '4F76AC' },
        { token: 'meta.scss', foreground: 'A79873' },
        { token: 'meta.tag', foreground: 'CE9178' },
        { token: 'metatag', foreground: 'DD6A6F' },
        { token: 'metatag.content.html', foreground: '9CDCFE' },
        { token: 'metatag.html', foreground: '569CD6' },
        { token: 'metatag.xml', foreground: '569CD6' },
        { token: 'metatag.php', fontStyle: 'bold' },
        { token: 'key', foreground: '9CDCFE' },
        { token: 'string.key.json', foreground: '9CDCFE' },
        { token: 'string.value.json', foreground: 'CE9178' },
        { token: 'attribute.name', foreground: '9CDCFE' },
        { token: 'attribute.value', foreground: 'CE9178' },
        { token: 'attribute.value.number.css', foreground: 'B5CEA8' },
        { token: 'attribute.value.unit.css', foreground: 'B5CEA8' },
        { token: 'attribute.value.hex.css', foreground: 'D4D4D4' },
        { token: 'string', foreground: 'CE9178' },
        { token: 'string.sql', foreground: 'FF0000' },
        { token: 'keyword', foreground: '569CD6' },
        { token: 'keyword.flow', foreground: 'C586C0' },
        { token: 'keyword.json', foreground: 'CE9178' },
        { token: 'keyword.flow.scss', foreground: '569CD6' },
        { token: 'operator.scss', foreground: '909090' },
        { token: 'operator.sql', foreground: '778899' },
        { token: 'operator.swift', foreground: '909090' },
        { token: 'predefined.sql', foreground: 'FF00FF' },
    ],
    colors: (_b = {},
        _b[editorBackground] = '#1E1E1E',
        _b[editorForeground] = '#D4D4D4',
        _b[editorInactiveSelection] = '#3A3D41',
        _b[editorIndentGuides] = '#404040',
        _b[editorActiveIndentGuides] = '#707070',
        _b[editorSelectionHighlight] = '#ADD6FF26',
        _b)
};
/* -------------------------------- End vs-dark theme -------------------------------- */
/* -------------------------------- Begin hc-black theme -------------------------------- */
var hc_black = {
    base: 'hc-black',
    inherit: false,
    rules: [
        { token: '', foreground: 'FFFFFF', background: '000000' },
        { token: 'invalid', foreground: 'f44747' },
        { token: 'emphasis', fontStyle: 'italic' },
        { token: 'strong', fontStyle: 'bold' },
        { token: 'variable', foreground: '1AEBFF' },
        { token: 'variable.parameter', foreground: '9CDCFE' },
        { token: 'constant', foreground: '569CD6' },
        { token: 'comment', foreground: '608B4E' },
        { token: 'number', foreground: 'FFFFFF' },
        { token: 'regexp', foreground: 'C0C0C0' },
        { token: 'annotation', foreground: '569CD6' },
        { token: 'type', foreground: '3DC9B0' },
        { token: 'delimiter', foreground: 'FFFF00' },
        { token: 'delimiter.html', foreground: 'FFFF00' },
        { token: 'tag', foreground: '569CD6' },
        { token: 'tag.id.jade', foreground: '4F76AC' },
        { token: 'tag.class.jade', foreground: '4F76AC' },
        { token: 'meta', foreground: 'D4D4D4' },
        { token: 'meta.tag', foreground: 'CE9178' },
        { token: 'metatag', foreground: '569CD6' },
        { token: 'metatag.content.html', foreground: '1AEBFF' },
        { token: 'metatag.html', foreground: '569CD6' },
        { token: 'metatag.xml', foreground: '569CD6' },
        { token: 'metatag.php', fontStyle: 'bold' },
        { token: 'key', foreground: '9CDCFE' },
        { token: 'string.key', foreground: '9CDCFE' },
        { token: 'string.value', foreground: 'CE9178' },
        { token: 'attribute.name', foreground: '569CD6' },
        { token: 'attribute.value', foreground: '3FF23F' },
        { token: 'string', foreground: 'CE9178' },
        { token: 'string.sql', foreground: 'FF0000' },
        { token: 'keyword', foreground: '569CD6' },
        { token: 'keyword.flow', foreground: 'C586C0' },
        { token: 'operator.sql', foreground: '778899' },
        { token: 'operator.swift', foreground: '909090' },
        { token: 'predefined.sql', foreground: 'FF00FF' },
    ],
    colors: (_c = {},
        _c[editorBackground] = '#000000',
        _c[editorForeground] = '#FFFFFF',
        _c[editorIndentGuides] = '#FFFFFF',
        _c[editorActiveIndentGuides] = '#FFFFFF',
        _c)
};
var _a, _b, _c;

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var VS_THEME_NAME = 'vs';
var VS_DARK_THEME_NAME = 'vs-dark';
var HC_BLACK_THEME_NAME = 'hc-black';
var colorRegistry$1 = Registry.as(Extensions$4.ColorContribution);
var themingRegistry$1 = Registry.as(Extensions$5.ThemingContribution);
var StandaloneTheme = /** @class */ (function () {
    function StandaloneTheme(base, name, colors, rules) {
        if (name.length > 0) {
            this.id = base + ' ' + name;
            this.themeName = name;
        }
        else {
            this.id = base;
            this.themeName = base;
        }
        this.base = base;
        this.rules = rules;
        this.colors = {};
        for (var id in colors) {
            this.colors[id] = Color.fromHex(colors[id]);
        }
        this.defaultColors = {};
    }
    StandaloneTheme.prototype.getColor = function (colorId, useDefault) {
        if (this.colors.hasOwnProperty(colorId)) {
            return this.colors[colorId];
        }
        if (useDefault !== false) {
            return this.getDefault(colorId);
        }
        return null;
    };
    StandaloneTheme.prototype.getDefault = function (colorId) {
        if (this.defaultColors.hasOwnProperty(colorId)) {
            return this.defaultColors[colorId];
        }
        var color = colorRegistry$1.resolveDefaultColor(colorId, this);
        this.defaultColors[colorId] = color;
        return color;
    };
    StandaloneTheme.prototype.defines = function (colorId) {
        return this.colors.hasOwnProperty(colorId);
    };
    Object.defineProperty(StandaloneTheme.prototype, "type", {
        get: function () {
            switch (this.base) {
                case VS_THEME_NAME: return 'light';
                case HC_BLACK_THEME_NAME: return 'hc';
                default: return 'dark';
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StandaloneTheme.prototype, "tokenTheme", {
        get: function () {
            if (!this._tokenTheme) {
                this._tokenTheme = TokenTheme.createFromRawTokenTheme(this.rules);
            }
            return this._tokenTheme;
        },
        enumerable: true,
        configurable: true
    });
    return StandaloneTheme;
}());
function isBuiltinTheme(themeName) {
    return (themeName === VS_THEME_NAME
        || themeName === VS_DARK_THEME_NAME
        || themeName === HC_BLACK_THEME_NAME);
}
function getBuiltinRules(builtinTheme) {
    switch (builtinTheme) {
        case VS_THEME_NAME:
            return vs;
        case VS_DARK_THEME_NAME:
            return vs_dark;
        case HC_BLACK_THEME_NAME:
            return hc_black;
    }
}
function newBuiltInTheme(builtinTheme) {
    var themeData = getBuiltinRules(builtinTheme);
    return new StandaloneTheme(builtinTheme, '', themeData.colors, themeData.rules);
}
var StandaloneThemeServiceImpl = /** @class */ (function () {
    function StandaloneThemeServiceImpl() {
        this._onThemeChange = new Emitter();
        this._knownThemes = new Map();
        this._knownThemes.set(VS_THEME_NAME, newBuiltInTheme(VS_THEME_NAME));
        this._knownThemes.set(VS_DARK_THEME_NAME, newBuiltInTheme(VS_DARK_THEME_NAME));
        this._knownThemes.set(HC_BLACK_THEME_NAME, newBuiltInTheme(HC_BLACK_THEME_NAME));
        this._styleElement = createStyleSheet();
        this._styleElement.className = 'monaco-colors';
        this.setTheme(VS_THEME_NAME);
    }
    Object.defineProperty(StandaloneThemeServiceImpl.prototype, "onThemeChange", {
        get: function () {
            return this._onThemeChange.event;
        },
        enumerable: true,
        configurable: true
    });
    StandaloneThemeServiceImpl.prototype.defineTheme = function (themeName, themeData) {
        if (!/^[a-z0-9\-]+$/i.test(themeName) || isBuiltinTheme(themeName)) {
            throw new Error('Illegal theme name!');
        }
        if (!isBuiltinTheme(themeData.base)) {
            throw new Error('Illegal theme base!');
        }
        var rules = [];
        var colors = {};
        if (themeData.inherit) {
            var baseData = getBuiltinRules(themeData.base);
            rules = rules.concat(baseData.rules);
            for (var id in baseData.colors) {
                colors[id] = baseData.colors[id];
            }
        }
        rules = rules.concat(themeData.rules);
        for (var id in themeData.colors) {
            colors[id] = themeData.colors[id];
        }
        this._knownThemes.set(themeName, new StandaloneTheme(themeData.base, themeName, colors, rules));
    };
    StandaloneThemeServiceImpl.prototype.getTheme = function () {
        return this._theme;
    };
    StandaloneThemeServiceImpl.prototype.setTheme = function (themeName) {
        var theme;
        if (this._knownThemes.has(themeName)) {
            theme = this._knownThemes.get(themeName);
        }
        else {
            theme = this._knownThemes.get(VS_THEME_NAME);
        }
        this._theme = theme;
        var cssRules = [];
        var hasRule = {};
        var ruleCollector = {
            addRule: function (rule) {
                if (!hasRule[rule]) {
                    cssRules.push(rule);
                    hasRule[rule] = true;
                }
            }
        };
        themingRegistry$1.getThemingParticipants().forEach(function (p) { return p(theme, ruleCollector); });
        var tokenTheme = theme.tokenTheme;
        var colorMap = tokenTheme.getColorMap();
        ruleCollector.addRule(generateTokensCSSForColorMap(colorMap));
        this._styleElement.innerHTML = cssRules.join('\n');
        TokenizationRegistry.setColorMap(colorMap);
        this._onThemeChange.fire(theme);
        return theme.id;
    };
    return StandaloneThemeServiceImpl;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var IDialogService = createDecorator('dialogService');

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var PagedRenderer = /** @class */ (function () {
    function PagedRenderer(renderer, modelProvider) {
        this.renderer = renderer;
        this.modelProvider = modelProvider;
    }
    Object.defineProperty(PagedRenderer.prototype, "templateId", {
        get: function () { return this.renderer.templateId; },
        enumerable: true,
        configurable: true
    });
    PagedRenderer.prototype.renderTemplate = function (container) {
        var data = this.renderer.renderTemplate(container);
        return { data: data, disposable: { dispose: function () { } } };
    };
    PagedRenderer.prototype.renderElement = function (index$$1, _, data) {
        var _this = this;
        data.disposable.dispose();
        var model = this.modelProvider();
        if (model.isResolved(index$$1)) {
            return this.renderer.renderElement(model.get(index$$1), index$$1, data.data);
        }
        var promise = model.resolve(index$$1);
        data.disposable = { dispose: function () { return promise.cancel(); } };
        this.renderer.renderPlaceholder(index$$1, data.data);
        promise.done(function (entry) { return _this.renderer.renderElement(entry, index$$1, data.data); });
    };
    PagedRenderer.prototype.disposeTemplate = function (data) {
        data.disposable.dispose();
        data.disposable = null;
        this.renderer.disposeTemplate(data.data);
        data.data = null;
    };
    return PagedRenderer;
}());
var PagedList = /** @class */ (function () {
    function PagedList(container, delegate, renderers, options) {
        if (options === void 0) { options = {}; }
        var _this = this;
        var pagedRenderers = renderers.map(function (r) { return new PagedRenderer(r, function () { return _this.model; }); });
        this.list = new List(container, delegate, pagedRenderers, options);
    }
    PagedList.prototype.getHTMLElement = function () {
        return this.list.getHTMLElement();
    };
    PagedList.prototype.isDOMFocused = function () {
        return this.list.getHTMLElement() === document.activeElement;
    };
    PagedList.prototype.domFocus = function () {
        this.list.domFocus();
    };
    Object.defineProperty(PagedList.prototype, "onDidFocus", {
        get: function () {
            return this.list.onDidFocus;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PagedList.prototype, "onDidBlur", {
        get: function () {
            return this.list.onDidBlur;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PagedList.prototype, "widget", {
        get: function () {
            return this.list;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PagedList.prototype, "onDidDispose", {
        get: function () {
            return this.list.onDidDispose;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PagedList.prototype, "onFocusChange", {
        get: function () {
            var _this = this;
            return mapEvent(this.list.onFocusChange, function (_a) {
                var elements = _a.elements, indexes = _a.indexes;
                return ({ elements: elements.map(function (e) { return _this._model.get(e); }), indexes: indexes });
            });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PagedList.prototype, "onOpen", {
        get: function () {
            var _this = this;
            return mapEvent(this.list.onOpen, function (_a) {
                var elements = _a.elements, indexes = _a.indexes, browserEvent = _a.browserEvent;
                return ({ elements: elements.map(function (e) { return _this._model.get(e); }), indexes: indexes, browserEvent: browserEvent });
            });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PagedList.prototype, "onSelectionChange", {
        get: function () {
            var _this = this;
            return mapEvent(this.list.onSelectionChange, function (_a) {
                var elements = _a.elements, indexes = _a.indexes;
                return ({ elements: elements.map(function (e) { return _this._model.get(e); }), indexes: indexes });
            });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PagedList.prototype, "onPin", {
        get: function () {
            var _this = this;
            return mapEvent(this.list.onPin, function (_a) {
                var elements = _a.elements, indexes = _a.indexes;
                return ({ elements: elements.map(function (e) { return _this._model.get(e); }), indexes: indexes });
            });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PagedList.prototype, "model", {
        get: function () {
            return this._model;
        },
        set: function (model) {
            this._model = model;
            this.list.splice(0, this.list.length, range(model.length));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PagedList.prototype, "length", {
        get: function () {
            return this.list.length;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PagedList.prototype, "scrollTop", {
        get: function () {
            return this.list.scrollTop;
        },
        set: function (scrollTop) {
            this.list.scrollTop = scrollTop;
        },
        enumerable: true,
        configurable: true
    });
    PagedList.prototype.open = function (indexes, browserEvent) {
        this.list.open(indexes, browserEvent);
    };
    PagedList.prototype.setFocus = function (indexes) {
        this.list.setFocus(indexes);
    };
    PagedList.prototype.focusNext = function (n, loop) {
        this.list.focusNext(n, loop);
    };
    PagedList.prototype.focusPrevious = function (n, loop) {
        this.list.focusPrevious(n, loop);
    };
    PagedList.prototype.selectNext = function (n, loop) {
        this.list.selectNext(n, loop);
    };
    PagedList.prototype.selectPrevious = function (n, loop) {
        this.list.selectPrevious(n, loop);
    };
    PagedList.prototype.focusNextPage = function () {
        this.list.focusNextPage();
    };
    PagedList.prototype.focusPreviousPage = function () {
        this.list.focusPreviousPage();
    };
    PagedList.prototype.getFocus = function () {
        return this.list.getFocus();
    };
    PagedList.prototype.setSelection = function (indexes) {
        this.list.setSelection(indexes);
    };
    PagedList.prototype.getSelection = function () {
        return this.list.getSelection();
    };
    PagedList.prototype.layout = function (height) {
        this.list.layout(height);
    };
    PagedList.prototype.reveal = function (index$$1, relativeTop) {
        this.list.reveal(index$$1, relativeTop);
    };
    PagedList.prototype.style = function (styles) {
        this.list.style(styles);
    };
    PagedList.prototype.dispose = function () {
        this.list.dispose();
    };
    return PagedList;
}());

const css$w = "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n.monaco-tree {\n\theight: 100%;\n\twidth: 100%;\n\twhite-space: nowrap;\n\t-webkit-user-select: none;\n\t-khtml-user-select: none;\n\t-moz-user-select: -moz-none;\n\t-ms-user-select: none;\n\t-o-user-select: none;\n\tuser-select: none;\n\tposition: relative;\n}\n\n.monaco-tree > .monaco-scrollable-element {\n\theight: 100%;\n}\n\n.monaco-tree > .monaco-scrollable-element > .monaco-tree-wrapper {\n\theight: 100%;\n\twidth: 100%;\n\tposition: relative;\n}\n\n.monaco-tree .monaco-tree-rows {\n\tposition: absolute;\n\twidth: 100%;\n\theight: 100%;\n}\n\n.monaco-tree .monaco-tree-rows > .monaco-tree-row {\n\t-moz-box-sizing:\tborder-box;\n\t-o-box-sizing:\t\tborder-box;\n\t-ms-box-sizing:\t\tborder-box;\n\tbox-sizing:\t\t\tborder-box;\n\tcursor: pointer;\n\toverflow: hidden;\n\twidth: 100%;\n\ttouch-action: none;\n}\n\n.monaco-tree .monaco-tree-rows > .monaco-tree-row > .content {\n\tposition: relative;\n\theight: 100%;\n}\n\n.monaco-tree-drag-image {\n\tdisplay: inline-block;\n\tpadding: 1px 7px;\n\tborder-radius: 10px;\n\tfont-size: 12px;\n\tposition: absolute;\n}\n\n/* for OS X ballistic scrolling */\n.monaco-tree .monaco-tree-rows > .monaco-tree-row.scrolling {\n\tdisplay: none;\n}\n\n/* Expansion */\n\n.monaco-tree .monaco-tree-rows.show-twisties > .monaco-tree-row.has-children > .content:before {\n\tcontent: ' ';\n\tposition: absolute;\n\tdisplay: block;\n\tbackground: url(\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNiAxNiI+PHBhdGggZmlsbD0iIzY0NjQ2NSIgZD0iTTYgNHY4bDQtNC00LTR6bTEgMi40MTRMOC41ODYgOCA3IDkuNTg2VjYuNDE0eiIvPjwvc3ZnPg==\") 50% 50% no-repeat;\n\twidth: 16px;\n\theight: 100%;\n\ttop: 0;\n\tleft: -16px;\n}\n\n.monaco-tree .monaco-tree-rows.show-twisties > .monaco-tree-row.expanded > .content:before {\n\tbackground-image: url(\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNiAxNiI+PHBhdGggZmlsbD0iIzY0NjQ2NSIgZD0iTTExIDEwSDUuMzQ0TDExIDQuNDE0VjEweiIvPjwvc3ZnPg==\");\n}\n\n.monaco-tree .monaco-tree-rows > .monaco-tree-row.has-children.loading > .content:before {\n\tbackground-image: url(\"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBzdGFuZGFsb25lPSdubycgPz4KPHN2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHZlcnNpb249JzEuMScgd2lkdGg9JzEwcHgnIGhlaWdodD0nMTBweCc+Cgk8c3R5bGU+CiAgICBjaXJjbGUgewogICAgICBhbmltYXRpb246IGJhbGwgMC42cyBsaW5lYXIgaW5maW5pdGU7CiAgICB9CgogICAgY2lyY2xlOm50aC1jaGlsZCgyKSB7IGFuaW1hdGlvbi1kZWxheTogMC4wNzVzOyB9CiAgICBjaXJjbGU6bnRoLWNoaWxkKDMpIHsgYW5pbWF0aW9uLWRlbGF5OiAwLjE1czsgfQogICAgY2lyY2xlOm50aC1jaGlsZCg0KSB7IGFuaW1hdGlvbi1kZWxheTogMC4yMjVzOyB9CiAgICBjaXJjbGU6bnRoLWNoaWxkKDUpIHsgYW5pbWF0aW9uLWRlbGF5OiAwLjNzOyB9CiAgICBjaXJjbGU6bnRoLWNoaWxkKDYpIHsgYW5pbWF0aW9uLWRlbGF5OiAwLjM3NXM7IH0KICAgIGNpcmNsZTpudGgtY2hpbGQoNykgeyBhbmltYXRpb24tZGVsYXk6IDAuNDVzOyB9CiAgICBjaXJjbGU6bnRoLWNoaWxkKDgpIHsgYW5pbWF0aW9uLWRlbGF5OiAwLjUyNXM7IH0KCiAgICBAa2V5ZnJhbWVzIGJhbGwgewogICAgICBmcm9tIHsgb3BhY2l0eTogMTsgfQogICAgICB0byB7IG9wYWNpdHk6IDAuMzsgfQogICAgfQoJPC9zdHlsZT4KCTxnPgoJCTxjaXJjbGUgY3g9JzUnIGN5PScxJyByPScxJyBzdHlsZT0nb3BhY2l0eTowLjM7JyAvPgoJCTxjaXJjbGUgY3g9JzcuODI4NCcgY3k9JzIuMTcxNicgcj0nMScgc3R5bGU9J29wYWNpdHk6MC4zOycgLz4KCQk8Y2lyY2xlIGN4PSc5JyBjeT0nNScgcj0nMScgc3R5bGU9J29wYWNpdHk6MC4zOycgLz4KCQk8Y2lyY2xlIGN4PSc3LjgyODQnIGN5PSc3LjgyODQnIHI9JzEnIHN0eWxlPSdvcGFjaXR5OjAuMzsnIC8+CgkJPGNpcmNsZSBjeD0nNScgY3k9JzknIHI9JzEnIHN0eWxlPSdvcGFjaXR5OjAuMzsnIC8+CgkJPGNpcmNsZSBjeD0nMi4xNzE2JyBjeT0nNy44Mjg0JyByPScxJyBzdHlsZT0nb3BhY2l0eTowLjM7JyAvPgoJCTxjaXJjbGUgY3g9JzEnIGN5PSc1JyByPScxJyBzdHlsZT0nb3BhY2l0eTowLjM7JyAvPgoJCTxjaXJjbGUgY3g9JzIuMTcxNicgY3k9JzIuMTcxNicgcj0nMScgc3R5bGU9J29wYWNpdHk6MC4zOycgLz4KCTwvZz4KPC9zdmc+Cg==\");\n}\n\n/* Highlighted */\n\n.monaco-tree.highlighted .monaco-tree-rows > .monaco-tree-row:not(.highlighted) {\n\topacity: 0.3;\n}\n\n.vs-dark .monaco-tree .monaco-tree-rows.show-twisties > .monaco-tree-row.has-children > .content:before {\n\tbackground-image: url(\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNiAxNiI+PHBhdGggZmlsbD0iI0U4RThFOCIgZD0iTTYgNHY4bDQtNC00LTR6bTEgMi40MTRMOC41ODYgOCA3IDkuNTg2VjYuNDE0eiIvPjwvc3ZnPg==\");\n}\n\n.vs-dark .monaco-tree .monaco-tree-rows.show-twisties > .monaco-tree-row.expanded > .content:before {\n\tbackground-image: url(\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNiAxNiI+PHBhdGggZmlsbD0iI0U4RThFOCIgZD0iTTExIDEwSDUuMzQ0TDExIDQuNDE0VjEweiIvPjwvc3ZnPg==\");\n}\n\n.vs-dark .monaco-tree .monaco-tree-rows > .monaco-tree-row.has-children.loading > .content:before {\n\tbackground-image: url(\"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBzdGFuZGFsb25lPSdubycgPz4KPHN2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHZlcnNpb249JzEuMScgd2lkdGg9JzEwcHgnIGhlaWdodD0nMTBweCc+Cgk8c3R5bGU+CiAgICBjaXJjbGUgewogICAgICBhbmltYXRpb246IGJhbGwgMC42cyBsaW5lYXIgaW5maW5pdGU7CiAgICB9CgogICAgY2lyY2xlOm50aC1jaGlsZCgyKSB7IGFuaW1hdGlvbi1kZWxheTogMC4wNzVzOyB9CiAgICBjaXJjbGU6bnRoLWNoaWxkKDMpIHsgYW5pbWF0aW9uLWRlbGF5OiAwLjE1czsgfQogICAgY2lyY2xlOm50aC1jaGlsZCg0KSB7IGFuaW1hdGlvbi1kZWxheTogMC4yMjVzOyB9CiAgICBjaXJjbGU6bnRoLWNoaWxkKDUpIHsgYW5pbWF0aW9uLWRlbGF5OiAwLjNzOyB9CiAgICBjaXJjbGU6bnRoLWNoaWxkKDYpIHsgYW5pbWF0aW9uLWRlbGF5OiAwLjM3NXM7IH0KICAgIGNpcmNsZTpudGgtY2hpbGQoNykgeyBhbmltYXRpb24tZGVsYXk6IDAuNDVzOyB9CiAgICBjaXJjbGU6bnRoLWNoaWxkKDgpIHsgYW5pbWF0aW9uLWRlbGF5OiAwLjUyNXM7IH0KCiAgICBAa2V5ZnJhbWVzIGJhbGwgewogICAgICBmcm9tIHsgb3BhY2l0eTogMTsgfQogICAgICB0byB7IG9wYWNpdHk6IDAuMzsgfQogICAgfQoJPC9zdHlsZT4KCTxnIHN0eWxlPSJmaWxsOmdyZXk7Ij4KCQk8Y2lyY2xlIGN4PSc1JyBjeT0nMScgcj0nMScgc3R5bGU9J29wYWNpdHk6MC4zOycgLz4KCQk8Y2lyY2xlIGN4PSc3LjgyODQnIGN5PScyLjE3MTYnIHI9JzEnIHN0eWxlPSdvcGFjaXR5OjAuMzsnIC8+CgkJPGNpcmNsZSBjeD0nOScgY3k9JzUnIHI9JzEnIHN0eWxlPSdvcGFjaXR5OjAuMzsnIC8+CgkJPGNpcmNsZSBjeD0nNy44Mjg0JyBjeT0nNy44Mjg0JyByPScxJyBzdHlsZT0nb3BhY2l0eTowLjM7JyAvPgoJCTxjaXJjbGUgY3g9JzUnIGN5PSc5JyByPScxJyBzdHlsZT0nb3BhY2l0eTowLjM7JyAvPgoJCTxjaXJjbGUgY3g9JzIuMTcxNicgY3k9JzcuODI4NCcgcj0nMScgc3R5bGU9J29wYWNpdHk6MC4zOycgLz4KCQk8Y2lyY2xlIGN4PScxJyBjeT0nNScgcj0nMScgc3R5bGU9J29wYWNpdHk6MC4zOycgLz4KCQk8Y2lyY2xlIGN4PScyLjE3MTYnIGN5PScyLjE3MTYnIHI9JzEnIHN0eWxlPSdvcGFjaXR5OjAuMzsnIC8+Cgk8L2c+Cjwvc3ZnPgo=\");\n}\n\n.hc-black .monaco-tree .monaco-tree-rows.show-twisties > .monaco-tree-row.has-children > .content:before\t{\n\tbackground-image: url(\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgaGVpZ2h0PSIxNiI+PHBhdGggZmlsbD0iI2ZmZiIgZD0iTTYgNHY4bDQtNC00LTR6bTEgMi40MTRsMS41ODYgMS41ODYtMS41ODYgMS41ODZ2LTMuMTcyeiIvPjwvc3ZnPg==\");\n}\n\n.hc-black .monaco-tree .monaco-tree-rows.show-twisties > .monaco-tree-row.expanded > .content:before {\n\tbackground-image: url(\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgaGVpZ2h0PSIxNiI+PHBhdGggZmlsbD0iI2ZmZiIgZD0iTTExIDEwLjA3aC01LjY1Nmw1LjY1Ni01LjY1NnY1LjY1NnoiLz48L3N2Zz4=\");\n}\n\n.hc-black .monaco-tree .monaco-tree-rows > .monaco-tree-row.has-children.loading > .content:before {\n\tbackground-image: url(\"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBzdGFuZGFsb25lPSdubycgPz4KPHN2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHZlcnNpb249JzEuMScgd2lkdGg9JzEwcHgnIGhlaWdodD0nMTBweCc+Cgk8c3R5bGU+CiAgICBjaXJjbGUgewogICAgICBhbmltYXRpb246IGJhbGwgMC42cyBsaW5lYXIgaW5maW5pdGU7CiAgICB9CgogICAgY2lyY2xlOm50aC1jaGlsZCgyKSB7IGFuaW1hdGlvbi1kZWxheTogMC4wNzVzOyB9CiAgICBjaXJjbGU6bnRoLWNoaWxkKDMpIHsgYW5pbWF0aW9uLWRlbGF5OiAwLjE1czsgfQogICAgY2lyY2xlOm50aC1jaGlsZCg0KSB7IGFuaW1hdGlvbi1kZWxheTogMC4yMjVzOyB9CiAgICBjaXJjbGU6bnRoLWNoaWxkKDUpIHsgYW5pbWF0aW9uLWRlbGF5OiAwLjNzOyB9CiAgICBjaXJjbGU6bnRoLWNoaWxkKDYpIHsgYW5pbWF0aW9uLWRlbGF5OiAwLjM3NXM7IH0KICAgIGNpcmNsZTpudGgtY2hpbGQoNykgeyBhbmltYXRpb24tZGVsYXk6IDAuNDVzOyB9CiAgICBjaXJjbGU6bnRoLWNoaWxkKDgpIHsgYW5pbWF0aW9uLWRlbGF5OiAwLjUyNXM7IH0KCiAgICBAa2V5ZnJhbWVzIGJhbGwgewogICAgICBmcm9tIHsgb3BhY2l0eTogMTsgfQogICAgICB0byB7IG9wYWNpdHk6IDAuMzsgfQogICAgfQoJPC9zdHlsZT4KCTxnIHN0eWxlPSJmaWxsOndoaXRlOyI+CgkJPGNpcmNsZSBjeD0nNScgY3k9JzEnIHI9JzEnIHN0eWxlPSdvcGFjaXR5OjAuMzsnIC8+CgkJPGNpcmNsZSBjeD0nNy44Mjg0JyBjeT0nMi4xNzE2JyByPScxJyBzdHlsZT0nb3BhY2l0eTowLjM7JyAvPgoJCTxjaXJjbGUgY3g9JzknIGN5PSc1JyByPScxJyBzdHlsZT0nb3BhY2l0eTowLjM7JyAvPgoJCTxjaXJjbGUgY3g9JzcuODI4NCcgY3k9JzcuODI4NCcgcj0nMScgc3R5bGU9J29wYWNpdHk6MC4zOycgLz4KCQk8Y2lyY2xlIGN4PSc1JyBjeT0nOScgcj0nMScgc3R5bGU9J29wYWNpdHk6MC4zOycgLz4KCQk8Y2lyY2xlIGN4PScyLjE3MTYnIGN5PSc3LjgyODQnIHI9JzEnIHN0eWxlPSdvcGFjaXR5OjAuMzsnIC8+CgkJPGNpcmNsZSBjeD0nMScgY3k9JzUnIHI9JzEnIHN0eWxlPSdvcGFjaXR5OjAuMzsnIC8+CgkJPGNpcmNsZSBjeD0nMi4xNzE2JyBjeT0nMi4xNzE2JyByPScxJyBzdHlsZT0nb3BhY2l0eTowLjM7JyAvPgoJPC9nPgo8L3N2Zz4K\");\n}\n\n.monaco-tree-action.collapse-all {\n\tbackground: url(\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgaGVpZ2h0PSIxNiIgdmlld0JveD0iLTEgMCAxNiAxNiIgZW5hYmxlLWJhY2tncm91bmQ9Im5ldyAtMSAwIDE2IDE2Ij48cGF0aCBmaWxsPSIjNDI0MjQyIiBkPSJNMTQgMXY5aC0xdi04aC04di0xaDl6bS0xMSAydjFoOHY4aDF2LTloLTl6bTcgMnY5aC05di05aDl6bS0yIDJoLTV2NWg1di01eiIvPjxyZWN0IHg9IjQiIHk9IjkiIGZpbGw9IiMwMDUzOUMiIHdpZHRoPSIzIiBoZWlnaHQ9IjEiLz48L3N2Zz4=\") center center no-repeat;\n}\n\n.hc-black .monaco-tree-action.collapse-all,\n.vs-dark .monaco-tree-action.collapse-all {\n\tbackground: url(\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgaGVpZ2h0PSIxNiIgdmlld0JveD0iLTEgMCAxNiAxNiIgZW5hYmxlLWJhY2tncm91bmQ9Im5ldyAtMSAwIDE2IDE2Ij48cGF0aCBmaWxsPSIjQzVDNUM1IiBkPSJNMTQgMXY5aC0xdi04aC04di0xaDl6bS0xMSAydjFoOHY4aDF2LTloLTl6bTcgMnY5aC05di05aDl6bS0yIDJoLTV2NWg1di01eiIvPjxyZWN0IHg9IjQiIHk9IjkiIGZpbGw9IiM3NUJFRkYiIHdpZHRoPSIzIiBoZWlnaHQ9IjEiLz48L3N2Zz4=\") center center no-repeat;\n}\n";
  const element$w = ((css, src) => {
if (typeof document !== 'object')
console.info(`Skipped loading "${src}"`);
try {
const id = src
  .replace(/\.css.*$/, '')
  .replace(/[\\:]/g, '/')
  .replace(/[^\w\/]+/g, '');
return (
  document.querySelector(`style[id="${id}"]`) ||
  document.head.appendChild(
    Object.assign(document.createElement('style'), {
      id,
      textContent: `${css}\n\n /* sourceURL=${src} */`,
    }),
  )
);
} catch (exception) {
console.warn(`Failed load "${src}"`, exception);
}
})(css$w, "…monaco-editor/esm/vs/base/parts/tree/browser/tree.css");
  //@ sourceURL=/Users/daflair/Projects/packages/monaco-es/node_modules/monaco-editor/esm/vs/base/parts/tree/browser/tree.css

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$1h = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var ClickBehavior;
(function (ClickBehavior) {
    /**
     * Handle the click when the mouse button is pressed but not released yet.
     */
    ClickBehavior[ClickBehavior["ON_MOUSE_DOWN"] = 0] = "ON_MOUSE_DOWN";
    /**
     * Handle the click when the mouse button is released.
     */
    ClickBehavior[ClickBehavior["ON_MOUSE_UP"] = 1] = "ON_MOUSE_UP";
})(ClickBehavior || (ClickBehavior = {}));
var OpenMode;
(function (OpenMode) {
    OpenMode[OpenMode["SINGLE_CLICK"] = 0] = "SINGLE_CLICK";
    OpenMode[OpenMode["DOUBLE_CLICK"] = 1] = "DOUBLE_CLICK";
})(OpenMode || (OpenMode = {}));
var KeybindingDispatcher = /** @class */ (function () {
    function KeybindingDispatcher() {
        this._arr = [];
    }
    KeybindingDispatcher.prototype.set = function (keybinding, callback) {
        this._arr.push({
            keybinding: createKeybinding(keybinding, OS),
            callback: callback
        });
    };
    KeybindingDispatcher.prototype.dispatch = function (keybinding) {
        // Loop from the last to the first to handle overwrites
        for (var i = this._arr.length - 1; i >= 0; i--) {
            var item = this._arr[i];
            if (keybinding.equals(item.keybinding)) {
                return item.callback;
            }
        }
        return null;
    };
    return KeybindingDispatcher;
}());
var DefaultController = /** @class */ (function () {
    function DefaultController(options) {
        if (options === void 0) { options = { clickBehavior: ClickBehavior.ON_MOUSE_DOWN, keyboardSupport: true, openMode: OpenMode.SINGLE_CLICK }; }
        var _this = this;
        this.options = options;
        this.downKeyBindingDispatcher = new KeybindingDispatcher();
        this.upKeyBindingDispatcher = new KeybindingDispatcher();
        if (typeof options.keyboardSupport !== 'boolean' || options.keyboardSupport) {
            this.downKeyBindingDispatcher.set(16 /* UpArrow */, function (t, e) { return _this.onUp(t, e); });
            this.downKeyBindingDispatcher.set(18 /* DownArrow */, function (t, e) { return _this.onDown(t, e); });
            this.downKeyBindingDispatcher.set(15 /* LeftArrow */, function (t, e) { return _this.onLeft(t, e); });
            this.downKeyBindingDispatcher.set(17 /* RightArrow */, function (t, e) { return _this.onRight(t, e); });
            if (isMacintosh) {
                this.downKeyBindingDispatcher.set(2048 /* CtrlCmd */ | 16 /* UpArrow */, function (t, e) { return _this.onLeft(t, e); });
                this.downKeyBindingDispatcher.set(256 /* WinCtrl */ | 44 /* KEY_N */, function (t, e) { return _this.onDown(t, e); });
                this.downKeyBindingDispatcher.set(256 /* WinCtrl */ | 46 /* KEY_P */, function (t, e) { return _this.onUp(t, e); });
            }
            this.downKeyBindingDispatcher.set(11 /* PageUp */, function (t, e) { return _this.onPageUp(t, e); });
            this.downKeyBindingDispatcher.set(12 /* PageDown */, function (t, e) { return _this.onPageDown(t, e); });
            this.downKeyBindingDispatcher.set(14 /* Home */, function (t, e) { return _this.onHome(t, e); });
            this.downKeyBindingDispatcher.set(13 /* End */, function (t, e) { return _this.onEnd(t, e); });
            this.downKeyBindingDispatcher.set(10 /* Space */, function (t, e) { return _this.onSpace(t, e); });
            this.downKeyBindingDispatcher.set(9 /* Escape */, function (t, e) { return _this.onEscape(t, e); });
            this.upKeyBindingDispatcher.set(3 /* Enter */, this.onEnter.bind(this));
            this.upKeyBindingDispatcher.set(2048 /* CtrlCmd */ | 3 /* Enter */, this.onEnter.bind(this));
        }
    }
    DefaultController.prototype.onMouseDown = function (tree, element, event, origin) {
        if (origin === void 0) { origin = 'mouse'; }
        if (this.options.clickBehavior === ClickBehavior.ON_MOUSE_DOWN && (event.leftButton || event.middleButton)) {
            if (event.target) {
                if (event.target.tagName && event.target.tagName.toLowerCase() === 'input') {
                    return false; // Ignore event if target is a form input field (avoids browser specific issues)
                }
                if (findParentWithClass(event.target, 'monaco-action-bar', 'row')) { // TODO@Joao not very nice way of checking for the action bar (implicit knowledge)
                    return false; // Ignore event if target is over an action bar of the row
                }
            }
            // Propagate to onLeftClick now
            return this.onLeftClick(tree, element, event, origin);
        }
        return false;
    };
    DefaultController.prototype.onClick = function (tree, element, event) {
        var isMac = isMacintosh;
        // A Ctrl click on the Mac is a context menu event
        if (isMac && event.ctrlKey) {
            event.preventDefault();
            event.stopPropagation();
            return false;
        }
        if (event.target && event.target.tagName && event.target.tagName.toLowerCase() === 'input') {
            return false; // Ignore event if target is a form input field (avoids browser specific issues)
        }
        if (this.options.clickBehavior === ClickBehavior.ON_MOUSE_DOWN && (event.leftButton || event.middleButton)) {
            return false; // Already handled by onMouseDown
        }
        return this.onLeftClick(tree, element, event);
    };
    DefaultController.prototype.onLeftClick = function (tree, element, eventish, origin) {
        if (origin === void 0) { origin = 'mouse'; }
        var payload = { origin: origin, originalEvent: eventish };
        var event = eventish;
        var isDoubleClick = (origin === 'mouse' && event.detail === 2);
        if (tree.getInput() === element) {
            tree.clearFocus(payload);
            tree.clearSelection(payload);
        }
        else {
            var isMouseDown = eventish && event.browserEvent && event.browserEvent.type === 'mousedown';
            if (!isMouseDown) {
                eventish.preventDefault(); // we cannot preventDefault onMouseDown because this would break DND otherwise
            }
            eventish.stopPropagation();
            tree.domFocus();
            tree.setSelection([element], payload);
            tree.setFocus(element, payload);
            if (this.openOnSingleClick || isDoubleClick || this.isClickOnTwistie(event)) {
                if (tree.isExpanded(element)) {
                    tree.collapse(element).done(null, onUnexpectedError);
                }
                else {
                    tree.expand(element).done(null, onUnexpectedError);
                }
            }
        }
        return true;
    };
    DefaultController.prototype.setOpenMode = function (openMode) {
        this.options.openMode = openMode;
    };
    Object.defineProperty(DefaultController.prototype, "openOnSingleClick", {
        get: function () {
            return this.options.openMode === OpenMode.SINGLE_CLICK;
        },
        enumerable: true,
        configurable: true
    });
    DefaultController.prototype.isClickOnTwistie = function (event) {
        var target = event.target;
        // There is no way to find out if the ::before element is clicked where
        // the twistie is drawn, but the <div class="content"> element in the
        // tree item is the only thing we get back as target when the user clicks
        // on the twistie.
        return target && target.className === 'content' && hasClass(target.parentElement, 'monaco-tree-row');
    };
    DefaultController.prototype.onContextMenu = function (tree, element, event) {
        if (event.target && event.target.tagName && event.target.tagName.toLowerCase() === 'input') {
            return false; // allow context menu on input fields
        }
        // Prevent native context menu from showing up
        if (event) {
            event.preventDefault();
            event.stopPropagation();
        }
        return false;
    };
    DefaultController.prototype.onTap = function (tree, element, event) {
        var target = event.initialTarget;
        if (target && target.tagName && target.tagName.toLowerCase() === 'input') {
            return false; // Ignore event if target is a form input field (avoids browser specific issues)
        }
        return this.onLeftClick(tree, element, event, 'touch');
    };
    DefaultController.prototype.onKeyDown = function (tree, event) {
        return this.onKey(this.downKeyBindingDispatcher, tree, event);
    };
    DefaultController.prototype.onKeyUp = function (tree, event) {
        return this.onKey(this.upKeyBindingDispatcher, tree, event);
    };
    DefaultController.prototype.onKey = function (bindings, tree, event) {
        var handler = bindings.dispatch(event.toKeybinding());
        if (handler) {
            if (handler(tree, event)) {
                event.preventDefault();
                event.stopPropagation();
                return true;
            }
        }
        return false;
    };
    DefaultController.prototype.onUp = function (tree, event) {
        var payload = { origin: 'keyboard', originalEvent: event };
        if (tree.getHighlight()) {
            tree.clearHighlight(payload);
        }
        else {
            tree.focusPrevious(1, payload);
            tree.reveal(tree.getFocus()).done(null, onUnexpectedError);
        }
        return true;
    };
    DefaultController.prototype.onPageUp = function (tree, event) {
        var payload = { origin: 'keyboard', originalEvent: event };
        if (tree.getHighlight()) {
            tree.clearHighlight(payload);
        }
        else {
            tree.focusPreviousPage(payload);
            tree.reveal(tree.getFocus()).done(null, onUnexpectedError);
        }
        return true;
    };
    DefaultController.prototype.onDown = function (tree, event) {
        var payload = { origin: 'keyboard', originalEvent: event };
        if (tree.getHighlight()) {
            tree.clearHighlight(payload);
        }
        else {
            tree.focusNext(1, payload);
            tree.reveal(tree.getFocus()).done(null, onUnexpectedError);
        }
        return true;
    };
    DefaultController.prototype.onPageDown = function (tree, event) {
        var payload = { origin: 'keyboard', originalEvent: event };
        if (tree.getHighlight()) {
            tree.clearHighlight(payload);
        }
        else {
            tree.focusNextPage(payload);
            tree.reveal(tree.getFocus()).done(null, onUnexpectedError);
        }
        return true;
    };
    DefaultController.prototype.onHome = function (tree, event) {
        var payload = { origin: 'keyboard', originalEvent: event };
        if (tree.getHighlight()) {
            tree.clearHighlight(payload);
        }
        else {
            tree.focusFirst(payload);
            tree.reveal(tree.getFocus()).done(null, onUnexpectedError);
        }
        return true;
    };
    DefaultController.prototype.onEnd = function (tree, event) {
        var payload = { origin: 'keyboard', originalEvent: event };
        if (tree.getHighlight()) {
            tree.clearHighlight(payload);
        }
        else {
            tree.focusLast(payload);
            tree.reveal(tree.getFocus()).done(null, onUnexpectedError);
        }
        return true;
    };
    DefaultController.prototype.onLeft = function (tree, event) {
        var payload = { origin: 'keyboard', originalEvent: event };
        if (tree.getHighlight()) {
            tree.clearHighlight(payload);
        }
        else {
            var focus_1 = tree.getFocus();
            tree.collapse(focus_1).then(function (didCollapse) {
                if (focus_1 && !didCollapse) {
                    tree.focusParent(payload);
                    return tree.reveal(tree.getFocus());
                }
                return undefined;
            }).done(null, onUnexpectedError);
        }
        return true;
    };
    DefaultController.prototype.onRight = function (tree, event) {
        var payload = { origin: 'keyboard', originalEvent: event };
        if (tree.getHighlight()) {
            tree.clearHighlight(payload);
        }
        else {
            var focus_2 = tree.getFocus();
            tree.expand(focus_2).then(function (didExpand) {
                if (focus_2 && !didExpand) {
                    tree.focusFirstChild(payload);
                    return tree.reveal(tree.getFocus());
                }
                return undefined;
            }).done(null, onUnexpectedError);
        }
        return true;
    };
    DefaultController.prototype.onEnter = function (tree, event) {
        var payload = { origin: 'keyboard', originalEvent: event };
        if (tree.getHighlight()) {
            return false;
        }
        var focus = tree.getFocus();
        if (focus) {
            tree.setSelection([focus], payload);
        }
        return true;
    };
    DefaultController.prototype.onSpace = function (tree, event) {
        if (tree.getHighlight()) {
            return false;
        }
        var focus = tree.getFocus();
        if (focus) {
            tree.toggleExpansion(focus);
        }
        return true;
    };
    DefaultController.prototype.onEscape = function (tree, event) {
        var payload = { origin: 'keyboard', originalEvent: event };
        if (tree.getHighlight()) {
            tree.clearHighlight(payload);
            return true;
        }
        if (tree.getSelection().length) {
            tree.clearSelection(payload);
            return true;
        }
        if (tree.getFocus()) {
            tree.clearFocus(payload);
            return true;
        }
        return false;
    };
    return DefaultController;
}());
var DefaultDragAndDrop = /** @class */ (function () {
    function DefaultDragAndDrop() {
    }
    DefaultDragAndDrop.prototype.getDragURI = function (tree, element) {
        return null;
    };
    DefaultDragAndDrop.prototype.onDragStart = function (tree, data, originalEvent) {
        return;
    };
    DefaultDragAndDrop.prototype.onDragOver = function (tree, data, targetElement, originalEvent) {
        return null;
    };
    DefaultDragAndDrop.prototype.drop = function (tree, data, targetElement, originalEvent) {
        return;
    };
    return DefaultDragAndDrop;
}());
var DefaultFilter = /** @class */ (function () {
    function DefaultFilter() {
    }
    DefaultFilter.prototype.isVisible = function (tree, element) {
        return true;
    };
    return DefaultFilter;
}());
var DefaultAccessibilityProvider = /** @class */ (function () {
    function DefaultAccessibilityProvider() {
    }
    DefaultAccessibilityProvider.prototype.getAriaLabel = function (tree, element) {
        return null;
    };
    return DefaultAccessibilityProvider;
}());
var DefaultTreestyler = /** @class */ (function () {
    function DefaultTreestyler(styleElement, selectorSuffix) {
        this.styleElement = styleElement;
        this.selectorSuffix = selectorSuffix;
    }
    DefaultTreestyler.prototype.style = function (styles) {
        var suffix = this.selectorSuffix ? "." + this.selectorSuffix : '';
        var content = [];
        if (styles.listFocusBackground) {
            content.push(".monaco-tree" + suffix + ".focused .monaco-tree-rows > .monaco-tree-row.focused:not(.highlighted) { background-color: " + styles.listFocusBackground + "; }");
        }
        if (styles.listFocusForeground) {
            content.push(".monaco-tree" + suffix + ".focused .monaco-tree-rows > .monaco-tree-row.focused:not(.highlighted) { color: " + styles.listFocusForeground + "; }");
        }
        if (styles.listActiveSelectionBackground) {
            content.push(".monaco-tree" + suffix + ".focused .monaco-tree-rows > .monaco-tree-row.selected:not(.highlighted) { background-color: " + styles.listActiveSelectionBackground + "; }");
        }
        if (styles.listActiveSelectionForeground) {
            content.push(".monaco-tree" + suffix + ".focused .monaco-tree-rows > .monaco-tree-row.selected:not(.highlighted) { color: " + styles.listActiveSelectionForeground + "; }");
        }
        if (styles.listFocusAndSelectionBackground) {
            content.push("\n\t\t\t\t.monaco-tree-drag-image,\n\t\t\t\t.monaco-tree" + suffix + ".focused .monaco-tree-rows > .monaco-tree-row.focused.selected:not(.highlighted) { background-color: " + styles.listFocusAndSelectionBackground + "; }\n\t\t\t");
        }
        if (styles.listFocusAndSelectionForeground) {
            content.push("\n\t\t\t\t.monaco-tree-drag-image,\n\t\t\t\t.monaco-tree" + suffix + ".focused .monaco-tree-rows > .monaco-tree-row.focused.selected:not(.highlighted) { color: " + styles.listFocusAndSelectionForeground + "; }\n\t\t\t");
        }
        if (styles.listInactiveSelectionBackground) {
            content.push(".monaco-tree" + suffix + " .monaco-tree-rows > .monaco-tree-row.selected:not(.highlighted) { background-color: " + styles.listInactiveSelectionBackground + "; }");
        }
        if (styles.listInactiveSelectionForeground) {
            content.push(".monaco-tree" + suffix + " .monaco-tree-rows > .monaco-tree-row.selected:not(.highlighted) { color: " + styles.listInactiveSelectionForeground + "; }");
        }
        if (styles.listHoverBackground) {
            content.push(".monaco-tree" + suffix + " .monaco-tree-rows > .monaco-tree-row:hover:not(.highlighted):not(.selected):not(.focused) { background-color: " + styles.listHoverBackground + "; }");
        }
        if (styles.listHoverForeground) {
            content.push(".monaco-tree" + suffix + " .monaco-tree-rows > .monaco-tree-row:hover:not(.highlighted):not(.selected):not(.focused) { color: " + styles.listHoverForeground + "; }");
        }
        if (styles.listDropBackground) {
            content.push("\n\t\t\t\t.monaco-tree" + suffix + " .monaco-tree-wrapper.drop-target,\n\t\t\t\t.monaco-tree" + suffix + " .monaco-tree-rows > .monaco-tree-row.drop-target { background-color: " + styles.listDropBackground + " !important; color: inherit !important; }\n\t\t\t");
        }
        if (styles.listFocusOutline) {
            content.push("\n\t\t\t\t.monaco-tree-drag-image\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t{ border: 1px solid " + styles.listFocusOutline + "; background: #000; }\n\t\t\t\t.monaco-tree" + suffix + " .monaco-tree-rows > .monaco-tree-row \t\t\t\t\t\t\t\t\t\t\t\t\t\t{ border: 1px solid transparent; }\n\t\t\t\t.monaco-tree" + suffix + ".focused .monaco-tree-rows > .monaco-tree-row.focused:not(.highlighted) \t\t\t\t\t\t{ border: 1px dotted " + styles.listFocusOutline + "; }\n\t\t\t\t.monaco-tree" + suffix + ".focused .monaco-tree-rows > .monaco-tree-row.selected:not(.highlighted) \t\t\t\t\t\t{ border: 1px solid " + styles.listFocusOutline + "; }\n\t\t\t\t.monaco-tree" + suffix + " .monaco-tree-rows > .monaco-tree-row.selected:not(.highlighted)  \t\t\t\t\t\t\t{ border: 1px solid " + styles.listFocusOutline + "; }\n\t\t\t\t.monaco-tree" + suffix + " .monaco-tree-rows > .monaco-tree-row:hover:not(.highlighted):not(.selected):not(.focused)  \t{ border: 1px dashed " + styles.listFocusOutline + "; }\n\t\t\t\t.monaco-tree" + suffix + " .monaco-tree-wrapper.drop-target,\n\t\t\t\t.monaco-tree" + suffix + " .monaco-tree-rows > .monaco-tree-row.drop-target\t\t\t\t\t\t\t\t\t\t\t\t{ border: 1px dashed " + styles.listFocusOutline + "; }\n\t\t\t");
        }
        var newStyles = content.join('\n');
        if (newStyles !== this.styleElement.innerHTML) {
            this.styleElement.innerHTML = newStyles;
        }
    };
    return DefaultTreestyler;
}());
var CollapseAllAction = /** @class */ (function (_super) {
    __extends$1h(CollapseAllAction, _super);
    function CollapseAllAction(viewer, enabled) {
        var _this = _super.call(this, 'vs.tree.collapse', localize('collapse', "Collapse"), 'monaco-tree-action collapse-all', enabled) || this;
        _this.viewer = viewer;
        return _this;
    }
    CollapseAllAction.prototype.run = function (context) {
        if (this.viewer.getHighlight()) {
            return TPromise.as(null); // Global action disabled if user is in edit mode from another action
        }
        this.viewer.collapseAll();
        this.viewer.clearSelection();
        this.viewer.clearFocus();
        this.viewer.domFocus();
        this.viewer.focusFirst();
        return TPromise.as(null);
    };
    return CollapseAllAction;
}(Action));

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$1i = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var LockData = /** @class */ (function () {
    function LockData(item) {
        this._onDispose = new Emitter();
        this.onDispose = this._onDispose.event;
        this._item = item;
    }
    Object.defineProperty(LockData.prototype, "item", {
        get: function () {
            return this._item;
        },
        enumerable: true,
        configurable: true
    });
    LockData.prototype.dispose = function () {
        if (this._onDispose) {
            this._onDispose.fire();
            this._onDispose.dispose();
            this._onDispose = null;
        }
    };
    return LockData;
}());
var Lock = /** @class */ (function () {
    function Lock() {
        this.locks = Object.create({});
    }
    Lock.prototype.isLocked = function (item) {
        return !!this.locks[item.id];
    };
    Lock.prototype.run = function (item, fn) {
        var _this = this;
        var lock = this.getLock(item);
        if (lock) {
            var unbindListener;
            return new TPromise(function (c, e) {
                unbindListener = once(lock.onDispose)(function () {
                    return _this.run(item, fn).then(c, e);
                });
            }, function () { unbindListener.dispose(); });
        }
        var result;
        return new TPromise(function (c, e) {
            if (item.isDisposed()) {
                return e(new Error('Item is disposed.'));
            }
            var lock = _this.locks[item.id] = new LockData(item);
            result = fn().then(function (r) {
                delete _this.locks[item.id];
                lock.dispose();
                return r;
            }).then(c, e);
            return result;
        }, function () { return result.cancel(); });
    };
    Lock.prototype.getLock = function (item) {
        var key;
        for (key in this.locks) {
            var lock = this.locks[key];
            if (item.intersects(lock.item)) {
                return lock;
            }
        }
        return null;
    };
    return Lock;
}());
var ItemRegistry = /** @class */ (function () {
    function ItemRegistry() {
        this._isDisposed = false;
        this._onDidRevealItem = new EventMultiplexer();
        this.onDidRevealItem = this._onDidRevealItem.event;
        this._onExpandItem = new EventMultiplexer();
        this.onExpandItem = this._onExpandItem.event;
        this._onDidExpandItem = new EventMultiplexer();
        this.onDidExpandItem = this._onDidExpandItem.event;
        this._onCollapseItem = new EventMultiplexer();
        this.onCollapseItem = this._onCollapseItem.event;
        this._onDidCollapseItem = new EventMultiplexer();
        this.onDidCollapseItem = this._onDidCollapseItem.event;
        this._onDidAddTraitItem = new EventMultiplexer();
        this.onDidAddTraitItem = this._onDidAddTraitItem.event;
        this._onDidRemoveTraitItem = new EventMultiplexer();
        this.onDidRemoveTraitItem = this._onDidRemoveTraitItem.event;
        this._onDidRefreshItem = new EventMultiplexer();
        this.onDidRefreshItem = this._onDidRefreshItem.event;
        this._onRefreshItemChildren = new EventMultiplexer();
        this.onRefreshItemChildren = this._onRefreshItemChildren.event;
        this._onDidRefreshItemChildren = new EventMultiplexer();
        this.onDidRefreshItemChildren = this._onDidRefreshItemChildren.event;
        this._onDidDisposeItem = new EventMultiplexer();
        this.onDidDisposeItem = this._onDidDisposeItem.event;
        this.items = {};
    }
    ItemRegistry.prototype.register = function (item) {
        ok(!this.isRegistered(item.id), 'item already registered: ' + item.id);
        var disposable = combinedDisposable([
            this._onDidRevealItem.add(item.onDidReveal),
            this._onExpandItem.add(item.onExpand),
            this._onDidExpandItem.add(item.onDidExpand),
            this._onCollapseItem.add(item.onCollapse),
            this._onDidCollapseItem.add(item.onDidCollapse),
            this._onDidAddTraitItem.add(item.onDidAddTrait),
            this._onDidRemoveTraitItem.add(item.onDidRemoveTrait),
            this._onDidRefreshItem.add(item.onDidRefresh),
            this._onRefreshItemChildren.add(item.onRefreshChildren),
            this._onDidRefreshItemChildren.add(item.onDidRefreshChildren),
            this._onDidDisposeItem.add(item.onDidDispose)
        ]);
        this.items[item.id] = { item: item, disposable: disposable };
    };
    ItemRegistry.prototype.deregister = function (item) {
        ok(this.isRegistered(item.id), 'item not registered: ' + item.id);
        this.items[item.id].disposable.dispose();
        delete this.items[item.id];
    };
    ItemRegistry.prototype.isRegistered = function (id) {
        return this.items.hasOwnProperty(id);
    };
    ItemRegistry.prototype.getItem = function (id) {
        var result = this.items[id];
        return result ? result.item : null;
    };
    ItemRegistry.prototype.dispose = function () {
        this.items = null;
        this._onDidRevealItem.dispose();
        this._onExpandItem.dispose();
        this._onDidExpandItem.dispose();
        this._onCollapseItem.dispose();
        this._onDidCollapseItem.dispose();
        this._onDidAddTraitItem.dispose();
        this._onDidRemoveTraitItem.dispose();
        this._onDidRefreshItem.dispose();
        this._onRefreshItemChildren.dispose();
        this._onDidRefreshItemChildren.dispose();
        this._isDisposed = true;
    };
    ItemRegistry.prototype.isDisposed = function () {
        return this._isDisposed;
    };
    return ItemRegistry;
}());
var Item = /** @class */ (function () {
    function Item(id, registry, context, lock, element) {
        this._onDidCreate = new Emitter();
        this.onDidCreate = this._onDidCreate.event;
        this._onDidReveal = new Emitter();
        this.onDidReveal = this._onDidReveal.event;
        this._onExpand = new Emitter();
        this.onExpand = this._onExpand.event;
        this._onDidExpand = new Emitter();
        this.onDidExpand = this._onDidExpand.event;
        this._onCollapse = new Emitter();
        this.onCollapse = this._onCollapse.event;
        this._onDidCollapse = new Emitter();
        this.onDidCollapse = this._onDidCollapse.event;
        this._onDidAddTrait = new Emitter();
        this.onDidAddTrait = this._onDidAddTrait.event;
        this._onDidRemoveTrait = new Emitter();
        this.onDidRemoveTrait = this._onDidRemoveTrait.event;
        this._onDidRefresh = new Emitter();
        this.onDidRefresh = this._onDidRefresh.event;
        this._onRefreshChildren = new Emitter();
        this.onRefreshChildren = this._onRefreshChildren.event;
        this._onDidRefreshChildren = new Emitter();
        this.onDidRefreshChildren = this._onDidRefreshChildren.event;
        this._onDidDispose = new Emitter();
        this.onDidDispose = this._onDidDispose.event;
        this.registry = registry;
        this.context = context;
        this.lock = lock;
        this.element = element;
        this.id = id;
        this.registry.register(this);
        this.doesHaveChildren = this.context.dataSource.hasChildren(this.context.tree, this.element);
        this.needsChildrenRefresh = true;
        this.parent = null;
        this.previous = null;
        this.next = null;
        this.firstChild = null;
        this.lastChild = null;
        this.traits = {};
        this.depth = 0;
        this.expanded = this.context.dataSource.shouldAutoexpand && this.context.dataSource.shouldAutoexpand(this.context.tree, element);
        this._onDidCreate.fire(this);
        this.visible = this._isVisible();
        this.height = this._getHeight();
        this._isDisposed = false;
    }
    Item.prototype.getElement = function () {
        return this.element;
    };
    Item.prototype.hasChildren = function () {
        return this.doesHaveChildren;
    };
    Item.prototype.getDepth = function () {
        return this.depth;
    };
    Item.prototype.isVisible = function () {
        return this.visible;
    };
    Item.prototype.setVisible = function (value) {
        this.visible = value;
    };
    Item.prototype.isExpanded = function () {
        return this.expanded;
    };
    /* protected */ Item.prototype._setExpanded = function (value) {
        this.expanded = value;
    };
    Item.prototype.reveal = function (relativeTop) {
        if (relativeTop === void 0) { relativeTop = null; }
        var eventData = { item: this, relativeTop: relativeTop };
        this._onDidReveal.fire(eventData);
    };
    Item.prototype.expand = function () {
        var _this = this;
        if (this.isExpanded() || !this.doesHaveChildren || this.lock.isLocked(this)) {
            return TPromise.as(false);
        }
        var result = this.lock.run(this, function () {
            var eventData = { item: _this };
            var result;
            _this._onExpand.fire(eventData);
            if (_this.needsChildrenRefresh) {
                result = _this.refreshChildren(false, true, true);
            }
            else {
                result = TPromise.as(null);
            }
            return result.then(function () {
                _this._setExpanded(true);
                _this._onDidExpand.fire(eventData);
                return true;
            });
        });
        return result.then(function (r) {
            if (_this.isDisposed()) {
                return false;
            }
            // Auto expand single child folders
            if (_this.context.options.autoExpandSingleChildren && r && _this.firstChild !== null && _this.firstChild === _this.lastChild && _this.firstChild.isVisible()) {
                return _this.firstChild.expand().then(function () { return true; });
            }
            return r;
        });
    };
    Item.prototype.collapse = function (recursive) {
        var _this = this;
        if (recursive === void 0) { recursive = false; }
        if (recursive) {
            var collapseChildrenPromise = TPromise.as(null);
            this.forEachChild(function (child) {
                collapseChildrenPromise = collapseChildrenPromise.then(function () { return child.collapse(true); });
            });
            return collapseChildrenPromise.then(function () {
                return _this.collapse(false);
            });
        }
        else {
            if (!this.isExpanded() || this.lock.isLocked(this)) {
                return TPromise.as(false);
            }
            return this.lock.run(this, function () {
                var eventData = { item: _this };
                _this._onCollapse.fire(eventData);
                _this._setExpanded(false);
                _this._onDidCollapse.fire(eventData);
                return TPromise.as(true);
            });
        }
    };
    Item.prototype.addTrait = function (trait) {
        var eventData = { item: this, trait: trait };
        this.traits[trait] = true;
        this._onDidAddTrait.fire(eventData);
    };
    Item.prototype.removeTrait = function (trait) {
        var eventData = { item: this, trait: trait };
        delete this.traits[trait];
        this._onDidRemoveTrait.fire(eventData);
    };
    Item.prototype.hasTrait = function (trait) {
        return this.traits[trait] || false;
    };
    Item.prototype.getAllTraits = function () {
        var result = [];
        var trait;
        for (trait in this.traits) {
            if (this.traits.hasOwnProperty(trait) && this.traits[trait]) {
                result.push(trait);
            }
        }
        return result;
    };
    Item.prototype.getHeight = function () {
        return this.height;
    };
    Item.prototype.refreshChildren = function (recursive, safe, force) {
        var _this = this;
        if (safe === void 0) { safe = false; }
        if (force === void 0) { force = false; }
        if (!force && !this.isExpanded()) {
            this.needsChildrenRefresh = true;
            return TPromise.as(this);
        }
        this.needsChildrenRefresh = false;
        var doRefresh = function () {
            var eventData = { item: _this, isNested: safe };
            _this._onRefreshChildren.fire(eventData);
            var childrenPromise;
            if (_this.doesHaveChildren) {
                childrenPromise = _this.context.dataSource.getChildren(_this.context.tree, _this.element);
            }
            else {
                childrenPromise = TPromise.as([]);
            }
            var result = childrenPromise.then(function (elements) {
                if (_this.isDisposed() || _this.registry.isDisposed()) {
                    return TPromise.as(null);
                }
                if (!Array.isArray(elements)) {
                    return TPromise.wrapError(new Error('Please return an array of children.'));
                }
                elements = !elements ? [] : elements.slice(0);
                elements = _this.sort(elements);
                var staleItems = {};
                while (_this.firstChild !== null) {
                    staleItems[_this.firstChild.id] = _this.firstChild;
                    _this.removeChild(_this.firstChild);
                }
                for (var i = 0, len = elements.length; i < len; i++) {
                    var element = elements[i];
                    var id = _this.context.dataSource.getId(_this.context.tree, element);
                    var item = staleItems[id] || new Item(id, _this.registry, _this.context, _this.lock, element);
                    item.element = element;
                    if (recursive) {
                        item.needsChildrenRefresh = recursive;
                    }
                    delete staleItems[id];
                    _this.addChild(item);
                }
                for (var staleItemId in staleItems) {
                    if (staleItems.hasOwnProperty(staleItemId)) {
                        staleItems[staleItemId].dispose();
                    }
                }
                if (recursive) {
                    return Promise$1.join(_this.mapEachChild(function (child) {
                        return child.doRefresh(recursive, true);
                    }));
                }
                else {
                    return TPromise.as(null);
                }
            });
            return result
                .then(null, onUnexpectedError)
                .then(function () { return _this._onDidRefreshChildren.fire(eventData); });
        };
        return safe ? doRefresh() : this.lock.run(this, doRefresh);
    };
    Item.prototype.doRefresh = function (recursive, safe) {
        if (safe === void 0) { safe = false; }
        this.doesHaveChildren = this.context.dataSource.hasChildren(this.context.tree, this.element);
        this.height = this._getHeight();
        this.setVisible(this._isVisible());
        this._onDidRefresh.fire(this);
        return this.refreshChildren(recursive, safe);
    };
    Item.prototype.refresh = function (recursive) {
        return this.doRefresh(recursive);
    };
    Item.prototype.getNavigator = function () {
        return new TreeNavigator(this);
    };
    Item.prototype.intersects = function (other) {
        return this.isAncestorOf(other) || other.isAncestorOf(this);
    };
    Item.prototype.getHierarchy = function () {
        var result = [];
        var node = this;
        do {
            result.push(node);
            node = node.parent;
        } while (node);
        result.reverse();
        return result;
    };
    Item.prototype.getChildren = function () {
        var child = this.firstChild;
        var results = [];
        while (child) {
            results.push(child);
            child = child.next;
        }
        return results;
    };
    Item.prototype.isAncestorOf = function (item) {
        while (item) {
            if (item.id === this.id) {
                return true;
            }
            item = item.parent;
        }
        return false;
    };
    Item.prototype.addChild = function (item, afterItem) {
        if (afterItem === void 0) { afterItem = this.lastChild; }
        var isEmpty = this.firstChild === null;
        var atHead = afterItem === null;
        var atTail = afterItem === this.lastChild;
        if (isEmpty) {
            this.firstChild = this.lastChild = item;
            item.next = item.previous = null;
        }
        else if (atHead) {
            this.firstChild.previous = item;
            item.next = this.firstChild;
            item.previous = null;
            this.firstChild = item;
        }
        else if (atTail) {
            this.lastChild.next = item;
            item.next = null;
            item.previous = this.lastChild;
            this.lastChild = item;
        }
        else {
            item.previous = afterItem;
            item.next = afterItem.next;
            afterItem.next.previous = item;
            afterItem.next = item;
        }
        item.parent = this;
        item.depth = this.depth + 1;
    };
    Item.prototype.removeChild = function (item) {
        var isFirstChild = this.firstChild === item;
        var isLastChild = this.lastChild === item;
        if (isFirstChild && isLastChild) {
            this.firstChild = this.lastChild = null;
        }
        else if (isFirstChild) {
            item.next.previous = null;
            this.firstChild = item.next;
        }
        else if (isLastChild) {
            item.previous.next = null;
            this.lastChild = item.previous;
        }
        else {
            item.next.previous = item.previous;
            item.previous.next = item.next;
        }
        item.parent = null;
        item.depth = null;
    };
    Item.prototype.forEachChild = function (fn) {
        var child = this.firstChild, next;
        while (child) {
            next = child.next;
            fn(child);
            child = next;
        }
    };
    Item.prototype.mapEachChild = function (fn) {
        var result = [];
        this.forEachChild(function (child) {
            result.push(fn(child));
        });
        return result;
    };
    Item.prototype.sort = function (elements) {
        var _this = this;
        if (this.context.sorter) {
            return elements.sort(function (element, otherElement) {
                return _this.context.sorter.compare(_this.context.tree, element, otherElement);
            });
        }
        return elements;
    };
    /* protected */ Item.prototype._getHeight = function () {
        return this.context.renderer.getHeight(this.context.tree, this.element);
    };
    /* protected */ Item.prototype._isVisible = function () {
        return this.context.filter.isVisible(this.context.tree, this.element);
    };
    Item.prototype.isDisposed = function () {
        return this._isDisposed;
    };
    Item.prototype.dispose = function () {
        this.forEachChild(function (child) { return child.dispose(); });
        this.parent = null;
        this.previous = null;
        this.next = null;
        this.firstChild = null;
        this.lastChild = null;
        this._onDidDispose.fire(this);
        this.registry.deregister(this);
        this._onDidCreate.dispose();
        this._onDidReveal.dispose();
        this._onExpand.dispose();
        this._onDidExpand.dispose();
        this._onCollapse.dispose();
        this._onDidCollapse.dispose();
        this._onDidAddTrait.dispose();
        this._onDidRemoveTrait.dispose();
        this._onDidRefresh.dispose();
        this._onRefreshChildren.dispose();
        this._onDidRefreshChildren.dispose();
        this._onDidDispose.dispose();
        this._isDisposed = true;
    };
    return Item;
}());
var RootItem = /** @class */ (function (_super) {
    __extends$1i(RootItem, _super);
    function RootItem(id, registry, context, lock, element) {
        return _super.call(this, id, registry, context, lock, element) || this;
    }
    RootItem.prototype.isVisible = function () {
        return false;
    };
    RootItem.prototype.setVisible = function (value) {
        // no-op
    };
    RootItem.prototype.isExpanded = function () {
        return true;
    };
    /* protected */ RootItem.prototype._setExpanded = function (value) {
        // no-op
    };
    RootItem.prototype.render = function () {
        // no-op
    };
    /* protected */ RootItem.prototype._getHeight = function () {
        return 0;
    };
    /* protected */ RootItem.prototype._isVisible = function () {
        return false;
    };
    return RootItem;
}(Item));
var TreeNavigator = /** @class */ (function () {
    function TreeNavigator(item, subTreeOnly) {
        if (subTreeOnly === void 0) { subTreeOnly = true; }
        this.item = item;
        this.start = subTreeOnly ? item : null;
    }
    TreeNavigator.lastDescendantOf = function (item) {
        if (!item) {
            return null;
        }
        if (item instanceof RootItem) {
            return TreeNavigator.lastDescendantOf(item.lastChild);
        }
        if (!item.isVisible()) {
            return TreeNavigator.lastDescendantOf(item.previous);
        }
        if (!item.isExpanded() || item.lastChild === null) {
            return item;
        }
        return TreeNavigator.lastDescendantOf(item.lastChild);
    };
    TreeNavigator.prototype.current = function () {
        return this.item || null;
    };
    TreeNavigator.prototype.next = function () {
        if (this.item) {
            do {
                if ((this.item instanceof RootItem || (this.item.isVisible() && this.item.isExpanded())) && this.item.firstChild) {
                    this.item = this.item.firstChild;
                }
                else if (this.item === this.start) {
                    this.item = null;
                }
                else {
                    // select next brother, next uncle, next great-uncle, etc...
                    while (this.item && this.item !== this.start && !this.item.next) {
                        this.item = this.item.parent;
                    }
                    if (this.item === this.start) {
                        this.item = null;
                    }
                    this.item = !this.item ? null : this.item.next;
                }
            } while (this.item && !this.item.isVisible());
        }
        return this.item || null;
    };
    TreeNavigator.prototype.previous = function () {
        if (this.item) {
            do {
                var previous = TreeNavigator.lastDescendantOf(this.item.previous);
                if (previous) {
                    this.item = previous;
                }
                else if (this.item.parent && this.item.parent !== this.start && this.item.parent.isVisible()) {
                    this.item = this.item.parent;
                }
                else {
                    this.item = null;
                }
            } while (this.item && !this.item.isVisible());
        }
        return this.item || null;
    };
    TreeNavigator.prototype.parent = function () {
        if (this.item) {
            var parent = this.item.parent;
            if (parent && parent !== this.start && parent.isVisible()) {
                this.item = parent;
            }
            else {
                this.item = null;
            }
        }
        return this.item || null;
    };
    TreeNavigator.prototype.first = function () {
        this.item = this.start;
        this.next();
        return this.item || null;
    };
    TreeNavigator.prototype.last = function () {
        return TreeNavigator.lastDescendantOf(this.start);
    };
    return TreeNavigator;
}());
function getRange(one, other) {
    var oneHierarchy = one.getHierarchy();
    var otherHierarchy = other.getHierarchy();
    var length = commonPrefixLength$1(oneHierarchy, otherHierarchy);
    var item = oneHierarchy[length - 1];
    var nav = item.getNavigator();
    var oneIndex = null;
    var otherIndex = null;
    var index$$1 = 0;
    var result = [];
    while (item && (oneIndex === null || otherIndex === null)) {
        result.push(item);
        if (item === one) {
            oneIndex = index$$1;
        }
        if (item === other) {
            otherIndex = index$$1;
        }
        index$$1++;
        item = nav.next();
    }
    if (oneIndex === null || otherIndex === null) {
        return [];
    }
    var min = Math.min(oneIndex, otherIndex);
    var max = Math.max(oneIndex, otherIndex);
    return result.slice(min, max + 1);
}
var TreeModel = /** @class */ (function () {
    function TreeModel(context) {
        this._onSetInput = new Emitter();
        this.onSetInput = this._onSetInput.event;
        this._onDidSetInput = new Emitter();
        this.onDidSetInput = this._onDidSetInput.event;
        this._onRefresh = new Emitter();
        this.onRefresh = this._onRefresh.event;
        this._onDidRefresh = new Emitter();
        this.onDidRefresh = this._onDidRefresh.event;
        this._onDidHighlight = new Emitter();
        this.onDidHighlight = this._onDidHighlight.event;
        this._onDidSelect = new Emitter();
        this.onDidSelect = this._onDidSelect.event;
        this._onDidFocus = new Emitter();
        this.onDidFocus = this._onDidFocus.event;
        this._onDidRevealItem = new Relay();
        this.onDidRevealItem = this._onDidRevealItem.event;
        this._onExpandItem = new Relay();
        this.onExpandItem = this._onExpandItem.event;
        this._onDidExpandItem = new Relay();
        this.onDidExpandItem = this._onDidExpandItem.event;
        this._onCollapseItem = new Relay();
        this.onCollapseItem = this._onCollapseItem.event;
        this._onDidCollapseItem = new Relay();
        this.onDidCollapseItem = this._onDidCollapseItem.event;
        this._onDidAddTraitItem = new Relay();
        this.onDidAddTraitItem = this._onDidAddTraitItem.event;
        this._onDidRemoveTraitItem = new Relay();
        this.onDidRemoveTraitItem = this._onDidRemoveTraitItem.event;
        this._onDidRefreshItem = new Relay();
        this.onDidRefreshItem = this._onDidRefreshItem.event;
        this._onRefreshItemChildren = new Relay();
        this.onRefreshItemChildren = this._onRefreshItemChildren.event;
        this._onDidRefreshItemChildren = new Relay();
        this.onDidRefreshItemChildren = this._onDidRefreshItemChildren.event;
        this._onDidDisposeItem = new Relay();
        this.onDidDisposeItem = this._onDidDisposeItem.event;
        this.context = context;
        this.input = null;
        this.traitsToItems = {};
    }
    TreeModel.prototype.setInput = function (element) {
        var _this = this;
        var eventData = { item: this.input };
        this._onSetInput.fire(eventData);
        this.setSelection([]);
        this.setFocus();
        this.setHighlight();
        this.lock = new Lock();
        if (this.input) {
            this.input.dispose();
        }
        if (this.registry) {
            this.registry.dispose();
            this.registryDisposable.dispose();
        }
        this.registry = new ItemRegistry();
        this._onDidRevealItem.input = this.registry.onDidRevealItem;
        this._onExpandItem.input = this.registry.onExpandItem;
        this._onDidExpandItem.input = this.registry.onDidExpandItem;
        this._onCollapseItem.input = this.registry.onCollapseItem;
        this._onDidCollapseItem.input = this.registry.onDidCollapseItem;
        this._onDidAddTraitItem.input = this.registry.onDidAddTraitItem;
        this._onDidRemoveTraitItem.input = this.registry.onDidRemoveTraitItem;
        this._onDidRefreshItem.input = this.registry.onDidRefreshItem;
        this._onRefreshItemChildren.input = this.registry.onRefreshItemChildren;
        this._onDidRefreshItemChildren.input = this.registry.onDidRefreshItemChildren;
        this._onDidDisposeItem.input = this.registry.onDidDisposeItem;
        this.registryDisposable = this.registry
            .onDidDisposeItem(function (item) { return item.getAllTraits().forEach(function (trait) { return delete _this.traitsToItems[trait][item.id]; }); });
        var id = this.context.dataSource.getId(this.context.tree, element);
        this.input = new RootItem(id, this.registry, this.context, this.lock, element);
        eventData = { item: this.input };
        this._onDidSetInput.fire(eventData);
        return this.refresh(this.input);
    };
    TreeModel.prototype.getInput = function () {
        return this.input ? this.input.getElement() : null;
    };
    TreeModel.prototype.refresh = function (element, recursive) {
        var _this = this;
        if (element === void 0) { element = null; }
        if (recursive === void 0) { recursive = true; }
        var item = this.getItem(element);
        if (!item) {
            return TPromise.as(null);
        }
        var eventData = { item: item, recursive: recursive };
        this._onRefresh.fire(eventData);
        return item.refresh(recursive).then(function () {
            _this._onDidRefresh.fire(eventData);
        });
    };
    TreeModel.prototype.expand = function (element) {
        var item = this.getItem(element);
        if (!item) {
            return TPromise.as(false);
        }
        return item.expand();
    };
    TreeModel.prototype.expandAll = function (elements) {
        if (!elements) {
            elements = [];
            var item;
            var nav = this.getNavigator();
            while (item = nav.next()) {
                elements.push(item);
            }
        }
        var promises = [];
        for (var i = 0, len = elements.length; i < len; i++) {
            promises.push(this.expand(elements[i]));
        }
        return Promise$1.join(promises);
    };
    TreeModel.prototype.collapse = function (element, recursive) {
        if (recursive === void 0) { recursive = false; }
        var item = this.getItem(element);
        if (!item) {
            return TPromise.as(false);
        }
        return item.collapse(recursive);
    };
    TreeModel.prototype.collapseAll = function (elements, recursive) {
        if (elements === void 0) { elements = null; }
        if (recursive === void 0) { recursive = false; }
        if (!elements) {
            elements = [this.input];
            recursive = true;
        }
        var promises = [];
        for (var i = 0, len = elements.length; i < len; i++) {
            promises.push(this.collapse(elements[i], recursive));
        }
        return Promise$1.join(promises);
    };
    TreeModel.prototype.collapseDeepestExpandedLevel = function () {
        var _this = this;
        var levelToCollapse = this.findDeepestExpandedLevel(this.input, 0);
        var items = [this.input];
        for (var i = 0; i < levelToCollapse; i++) {
            items = flatten(items.map(function (node) { return node.getChildren(); }));
        }
        var promises = items.map(function (child) { return _this.collapse(child, false); });
        return Promise$1.join(promises);
    };
    TreeModel.prototype.findDeepestExpandedLevel = function (item, currentLevel) {
        var _this = this;
        var expandedChildren = item.getChildren().filter(function (child) { return child.isExpanded(); });
        if (!expandedChildren.length) {
            return currentLevel;
        }
        return Math.max.apply(Math, expandedChildren.map(function (child) { return _this.findDeepestExpandedLevel(child, currentLevel + 1); }));
    };
    TreeModel.prototype.toggleExpansion = function (element, recursive) {
        if (recursive === void 0) { recursive = false; }
        return this.isExpanded(element) ? this.collapse(element, recursive) : this.expand(element);
    };
    TreeModel.prototype.toggleExpansionAll = function (elements) {
        var promises = [];
        for (var i = 0, len = elements.length; i < len; i++) {
            promises.push(this.toggleExpansion(elements[i]));
        }
        return Promise$1.join(promises);
    };
    TreeModel.prototype.isExpanded = function (element) {
        var item = this.getItem(element);
        if (!item) {
            return false;
        }
        return item.isExpanded();
    };
    TreeModel.prototype.getExpandedElements = function () {
        var result = [];
        var item;
        var nav = this.getNavigator();
        while (item = nav.next()) {
            if (item.isExpanded()) {
                result.push(item.getElement());
            }
        }
        return result;
    };
    TreeModel.prototype.reveal = function (element, relativeTop) {
        var _this = this;
        if (relativeTop === void 0) { relativeTop = null; }
        return this.resolveUnknownParentChain(element).then(function (chain$$1) {
            var result = TPromise.as(null);
            chain$$1.forEach(function (e) {
                result = result.then(function () { return _this.expand(e); });
            });
            return result;
        }).then(function () {
            var item = _this.getItem(element);
            if (item) {
                return item.reveal(relativeTop);
            }
        });
    };
    TreeModel.prototype.resolveUnknownParentChain = function (element) {
        var _this = this;
        return this.context.dataSource.getParent(this.context.tree, element).then(function (parent) {
            if (!parent) {
                return TPromise.as([]);
            }
            return _this.resolveUnknownParentChain(parent).then(function (result) {
                result.push(parent);
                return result;
            });
        });
    };
    TreeModel.prototype.setHighlight = function (element, eventPayload) {
        this.setTraits('highlighted', element ? [element] : []);
        var eventData = { highlight: this.getHighlight(), payload: eventPayload };
        this._onDidHighlight.fire(eventData);
    };
    TreeModel.prototype.getHighlight = function (includeHidden) {
        var result = this.getElementsWithTrait('highlighted', includeHidden);
        return result.length === 0 ? null : result[0];
    };
    TreeModel.prototype.isHighlighted = function (element) {
        var item = this.getItem(element);
        if (!item) {
            return false;
        }
        return item.hasTrait('highlighted');
    };
    TreeModel.prototype.select = function (element, eventPayload) {
        this.selectAll([element], eventPayload);
    };
    TreeModel.prototype.selectRange = function (fromElement, toElement, eventPayload) {
        var fromItem = this.getItem(fromElement);
        var toItem = this.getItem(toElement);
        if (!fromItem || !toItem) {
            return;
        }
        this.selectAll(getRange(fromItem, toItem), eventPayload);
    };
    TreeModel.prototype.deselectRange = function (fromElement, toElement, eventPayload) {
        var fromItem = this.getItem(fromElement);
        var toItem = this.getItem(toElement);
        if (!fromItem || !toItem) {
            return;
        }
        this.deselectAll(getRange(fromItem, toItem), eventPayload);
    };
    TreeModel.prototype.selectAll = function (elements, eventPayload) {
        this.addTraits('selected', elements);
        var eventData = { selection: this.getSelection(), payload: eventPayload };
        this._onDidSelect.fire(eventData);
    };
    TreeModel.prototype.deselect = function (element, eventPayload) {
        this.deselectAll([element], eventPayload);
    };
    TreeModel.prototype.deselectAll = function (elements, eventPayload) {
        this.removeTraits('selected', elements);
        var eventData = { selection: this.getSelection(), payload: eventPayload };
        this._onDidSelect.fire(eventData);
    };
    TreeModel.prototype.setSelection = function (elements, eventPayload) {
        this.setTraits('selected', elements);
        var eventData = { selection: this.getSelection(), payload: eventPayload };
        this._onDidSelect.fire(eventData);
    };
    TreeModel.prototype.toggleSelection = function (element, eventPayload) {
        this.toggleTrait('selected', element);
        var eventData = { selection: this.getSelection(), payload: eventPayload };
        this._onDidSelect.fire(eventData);
    };
    TreeModel.prototype.isSelected = function (element) {
        var item = this.getItem(element);
        if (!item) {
            return false;
        }
        return item.hasTrait('selected');
    };
    TreeModel.prototype.getSelection = function (includeHidden) {
        return this.getElementsWithTrait('selected', includeHidden);
    };
    TreeModel.prototype.selectNext = function (count, clearSelection, eventPayload) {
        if (count === void 0) { count = 1; }
        if (clearSelection === void 0) { clearSelection = true; }
        var selection = this.getSelection();
        var item = selection.length > 0 ? selection[0] : this.input;
        var nextItem;
        var nav = this.getNavigator(item, false);
        for (var i = 0; i < count; i++) {
            nextItem = nav.next();
            if (!nextItem) {
                break;
            }
            item = nextItem;
        }
        if (clearSelection) {
            this.setSelection([item], eventPayload);
        }
        else {
            this.select(item, eventPayload);
        }
    };
    TreeModel.prototype.selectPrevious = function (count, clearSelection, eventPayload) {
        if (count === void 0) { count = 1; }
        if (clearSelection === void 0) { clearSelection = true; }
        var selection = this.getSelection(), item = null, previousItem = null;
        if (selection.length === 0) {
            var nav = this.getNavigator(this.input);
            while (item = nav.next()) {
                previousItem = item;
            }
            item = previousItem;
        }
        else {
            item = selection[0];
            var nav = this.getNavigator(item, false);
            for (var i = 0; i < count; i++) {
                previousItem = nav.previous();
                if (!previousItem) {
                    break;
                }
                item = previousItem;
            }
        }
        if (clearSelection) {
            this.setSelection([item], eventPayload);
        }
        else {
            this.select(item, eventPayload);
        }
    };
    TreeModel.prototype.selectParent = function (eventPayload, clearSelection) {
        if (clearSelection === void 0) { clearSelection = true; }
        var selection = this.getSelection();
        var item = selection.length > 0 ? selection[0] : this.input;
        var nav = this.getNavigator(item, false);
        var parent = nav.parent();
        if (parent) {
            if (clearSelection) {
                this.setSelection([parent], eventPayload);
            }
            else {
                this.select(parent, eventPayload);
            }
        }
    };
    TreeModel.prototype.setFocus = function (element, eventPayload) {
        this.setTraits('focused', element ? [element] : []);
        var eventData = { focus: this.getFocus(), payload: eventPayload };
        this._onDidFocus.fire(eventData);
    };
    TreeModel.prototype.isFocused = function (element) {
        var item = this.getItem(element);
        if (!item) {
            return false;
        }
        return item.hasTrait('focused');
    };
    TreeModel.prototype.getFocus = function (includeHidden) {
        var result = this.getElementsWithTrait('focused', includeHidden);
        return result.length === 0 ? null : result[0];
    };
    TreeModel.prototype.focusNext = function (count, eventPayload) {
        if (count === void 0) { count = 1; }
        var item = this.getFocus() || this.input;
        var nextItem;
        var nav = this.getNavigator(item, false);
        for (var i = 0; i < count; i++) {
            nextItem = nav.next();
            if (!nextItem) {
                break;
            }
            item = nextItem;
        }
        this.setFocus(item, eventPayload);
    };
    TreeModel.prototype.focusPrevious = function (count, eventPayload) {
        if (count === void 0) { count = 1; }
        var item = this.getFocus() || this.input;
        var previousItem;
        var nav = this.getNavigator(item, false);
        for (var i = 0; i < count; i++) {
            previousItem = nav.previous();
            if (!previousItem) {
                break;
            }
            item = previousItem;
        }
        this.setFocus(item, eventPayload);
    };
    TreeModel.prototype.focusParent = function (eventPayload) {
        var item = this.getFocus() || this.input;
        var nav = this.getNavigator(item, false);
        var parent = nav.parent();
        if (parent) {
            this.setFocus(parent, eventPayload);
        }
    };
    TreeModel.prototype.focusFirstChild = function (eventPayload) {
        var item = this.getItem(this.getFocus() || this.input);
        var nav = this.getNavigator(item, false);
        var next = nav.next();
        var parent = nav.parent();
        if (parent === item) {
            this.setFocus(next, eventPayload);
        }
    };
    TreeModel.prototype.focusFirst = function (eventPayload, from) {
        this.focusNth(0, eventPayload, from);
    };
    TreeModel.prototype.focusNth = function (index$$1, eventPayload, from) {
        var navItem = this.getParent(from);
        var nav = this.getNavigator(navItem);
        var item = nav.first();
        for (var i = 0; i < index$$1; i++) {
            item = nav.next();
        }
        if (item) {
            this.setFocus(item, eventPayload);
        }
    };
    TreeModel.prototype.focusLast = function (eventPayload, from) {
        var navItem = this.getParent(from);
        var item;
        if (from) {
            item = navItem.lastChild;
        }
        else {
            var nav = this.getNavigator(navItem);
            item = nav.last();
        }
        if (item) {
            this.setFocus(item, eventPayload);
        }
    };
    TreeModel.prototype.getParent = function (from) {
        if (from) {
            var fromItem = this.getItem(from);
            if (fromItem && fromItem.parent) {
                return fromItem.parent;
            }
        }
        return this.getItem(this.input);
    };
    TreeModel.prototype.getNavigator = function (element, subTreeOnly) {
        if (element === void 0) { element = null; }
        if (subTreeOnly === void 0) { subTreeOnly = true; }
        return new TreeNavigator(this.getItem(element), subTreeOnly);
    };
    TreeModel.prototype.getItem = function (element) {
        if (element === void 0) { element = null; }
        if (element === null) {
            return this.input;
        }
        else if (element instanceof Item) {
            return element;
        }
        else if (typeof element === 'string') {
            return this.registry.getItem(element);
        }
        else {
            return this.registry.getItem(this.context.dataSource.getId(this.context.tree, element));
        }
    };
    TreeModel.prototype.addTraits = function (trait, elements) {
        var items = this.traitsToItems[trait] || {};
        var item;
        for (var i = 0, len = elements.length; i < len; i++) {
            item = this.getItem(elements[i]);
            if (item) {
                item.addTrait(trait);
                items[item.id] = item;
            }
        }
        this.traitsToItems[trait] = items;
    };
    TreeModel.prototype.removeTraits = function (trait, elements) {
        var items = this.traitsToItems[trait] || {};
        var item;
        var id;
        if (elements.length === 0) {
            for (id in items) {
                if (items.hasOwnProperty(id)) {
                    item = items[id];
                    item.removeTrait(trait);
                }
            }
            delete this.traitsToItems[trait];
        }
        else {
            for (var i = 0, len = elements.length; i < len; i++) {
                item = this.getItem(elements[i]);
                if (item) {
                    item.removeTrait(trait);
                    delete items[item.id];
                }
            }
        }
    };
    TreeModel.prototype.hasTrait = function (trait, element) {
        var item = this.getItem(element);
        return item && item.hasTrait(trait);
    };
    TreeModel.prototype.toggleTrait = function (trait, element) {
        var item = this.getItem(element);
        if (!item) {
            return;
        }
        if (item.hasTrait(trait)) {
            this.removeTraits(trait, [element]);
        }
        else {
            this.addTraits(trait, [element]);
        }
    };
    TreeModel.prototype.setTraits = function (trait, elements) {
        if (elements.length === 0) {
            this.removeTraits(trait, elements);
        }
        else {
            var items = {};
            var item;
            for (var i = 0, len = elements.length; i < len; i++) {
                item = this.getItem(elements[i]);
                if (item) {
                    items[item.id] = item;
                }
            }
            var traitItems = this.traitsToItems[trait] || {};
            var itemsToRemoveTrait = [];
            var id;
            for (id in traitItems) {
                if (traitItems.hasOwnProperty(id)) {
                    if (items.hasOwnProperty(id)) {
                        delete items[id];
                    }
                    else {
                        itemsToRemoveTrait.push(traitItems[id]);
                    }
                }
            }
            for (var i = 0, len = itemsToRemoveTrait.length; i < len; i++) {
                item = itemsToRemoveTrait[i];
                item.removeTrait(trait);
                delete traitItems[item.id];
            }
            for (id in items) {
                if (items.hasOwnProperty(id)) {
                    item = items[id];
                    item.addTrait(trait);
                    traitItems[id] = item;
                }
            }
            this.traitsToItems[trait] = traitItems;
        }
    };
    TreeModel.prototype.getElementsWithTrait = function (trait, includeHidden) {
        var elements = [];
        var items = this.traitsToItems[trait] || {};
        var id;
        for (id in items) {
            if (items.hasOwnProperty(id) && (items[id].isVisible() || includeHidden)) {
                elements.push(items[id].getElement());
            }
        }
        return elements;
    };
    TreeModel.prototype.dispose = function () {
        if (this.registry) {
            this.registry.dispose();
            this.registry = null;
        }
        this._onSetInput.dispose();
        this._onDidSetInput.dispose();
        this._onRefresh.dispose();
        this._onDidRefresh.dispose();
        this._onDidHighlight.dispose();
        this._onDidSelect.dispose();
        this._onDidFocus.dispose();
        this._onDidRevealItem.dispose();
        this._onExpandItem.dispose();
        this._onDidExpandItem.dispose();
        this._onCollapseItem.dispose();
        this._onDidCollapseItem.dispose();
        this._onDidAddTraitItem.dispose();
        this._onDidRemoveTraitItem.dispose();
        this._onDidRefreshItem.dispose();
        this._onRefreshItemChildren.dispose();
        this._onDidRefreshItemChildren.dispose();
        this._onDidDisposeItem.dispose();
    };
    return TreeModel;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var ElementsDragAndDropData = /** @class */ (function () {
    function ElementsDragAndDropData(elements) {
        this.elements = elements;
    }
    ElementsDragAndDropData.prototype.update = function (event) {
        // no-op
    };
    ElementsDragAndDropData.prototype.getData = function () {
        return this.elements;
    };
    return ElementsDragAndDropData;
}());
var ExternalElementsDragAndDropData = /** @class */ (function () {
    function ExternalElementsDragAndDropData(elements) {
        this.elements = elements;
    }
    ExternalElementsDragAndDropData.prototype.update = function (event) {
        // no-op
    };
    ExternalElementsDragAndDropData.prototype.getData = function () {
        return this.elements;
    };
    return ExternalElementsDragAndDropData;
}());
var DesktopDragAndDropData = /** @class */ (function () {
    function DesktopDragAndDropData() {
        this.types = [];
        this.files = [];
    }
    DesktopDragAndDropData.prototype.update = function (event) {
        if (event.dataTransfer.types) {
            this.types = [];
            Array.prototype.push.apply(this.types, event.dataTransfer.types);
        }
        if (event.dataTransfer.files) {
            this.files = [];
            Array.prototype.push.apply(this.files, event.dataTransfer.files);
            this.files = this.files.filter(function (f) { return f.size || f.type; });
        }
    };
    DesktopDragAndDropData.prototype.getData = function () {
        return {
            types: this.types,
            files: this.files
        };
    };
    return DesktopDragAndDropData;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$1j = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var ArrayIterator = /** @class */ (function () {
    function ArrayIterator(items, start, end) {
        if (start === void 0) { start = 0; }
        if (end === void 0) { end = items.length; }
        this.items = items;
        this.start = start;
        this.end = end;
        this.index = start - 1;
    }
    ArrayIterator.prototype.first = function () {
        this.index = this.start;
        return this.current();
    };
    ArrayIterator.prototype.next = function () {
        this.index = Math.min(this.index + 1, this.end);
        return this.current();
    };
    ArrayIterator.prototype.current = function () {
        if (this.index === this.start - 1 || this.index === this.end) {
            return null;
        }
        return this.items[this.index];
    };
    return ArrayIterator;
}());
var ArrayNavigator = /** @class */ (function (_super) {
    __extends$1j(ArrayNavigator, _super);
    function ArrayNavigator(items, start, end) {
        if (start === void 0) { start = 0; }
        if (end === void 0) { end = items.length; }
        return _super.call(this, items, start, end) || this;
    }
    ArrayNavigator.prototype.current = function () {
        return _super.prototype.current.call(this);
    };
    ArrayNavigator.prototype.previous = function () {
        this.index = Math.max(this.index - 1, this.start - 1);
        return this.current();
    };
    ArrayNavigator.prototype.first = function () {
        this.index = this.start;
        return this.current();
    };
    ArrayNavigator.prototype.last = function () {
        this.index = this.end - 1;
        return this.current();
    };
    ArrayNavigator.prototype.parent = function () {
        return null;
    };
    return ArrayNavigator;
}(ArrayIterator));
var MappedIterator = /** @class */ (function () {
    function MappedIterator(iterator, fn) {
        this.iterator = iterator;
        this.fn = fn;
        // noop
    }
    MappedIterator.prototype.next = function () { return this.fn(this.iterator.next()); };
    return MappedIterator;
}());
var MappedNavigator = /** @class */ (function (_super) {
    __extends$1j(MappedNavigator, _super);
    function MappedNavigator(navigator, fn) {
        var _this = _super.call(this, navigator, fn) || this;
        _this.navigator = navigator;
        return _this;
    }
    MappedNavigator.prototype.current = function () { return this.fn(this.navigator.current()); };
    MappedNavigator.prototype.previous = function () { return this.fn(this.navigator.previous()); };
    MappedNavigator.prototype.parent = function () { return this.fn(this.navigator.parent()); };
    MappedNavigator.prototype.first = function () { return this.fn(this.navigator.first()); };
    MappedNavigator.prototype.last = function () { return this.fn(this.navigator.last()); };
    MappedNavigator.prototype.next = function () { return this.fn(this.navigator.next()); };
    return MappedNavigator;
}(MappedIterator));

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var HeightMap = /** @class */ (function () {
    function HeightMap() {
        this.heightMap = [];
        this.indexes = {};
    }
    HeightMap.prototype.getContentHeight = function () {
        var last = this.heightMap[this.heightMap.length - 1];
        return !last ? 0 : last.top + last.height;
    };
    HeightMap.prototype.onInsertItems = function (iterator, afterItemId) {
        if (afterItemId === void 0) { afterItemId = null; }
        var item;
        var viewItem;
        var i, j;
        var totalSize;
        var sizeDiff = 0;
        if (afterItemId === null) {
            i = 0;
            totalSize = 0;
        }
        else {
            i = this.indexes[afterItemId] + 1;
            viewItem = this.heightMap[i - 1];
            if (!viewItem) {
                console.error('view item doesnt exist');
                return undefined;
            }
            totalSize = viewItem.top + viewItem.height;
        }
        var boundSplice = this.heightMap.splice.bind(this.heightMap, i, 0);
        var itemsToInsert = [];
        while (item = iterator.next()) {
            viewItem = this.createViewItem(item);
            viewItem.top = totalSize + sizeDiff;
            this.indexes[item.id] = i++;
            itemsToInsert.push(viewItem);
            sizeDiff += viewItem.height;
        }
        boundSplice.apply(this.heightMap, itemsToInsert);
        for (j = i; j < this.heightMap.length; j++) {
            viewItem = this.heightMap[j];
            viewItem.top += sizeDiff;
            this.indexes[viewItem.model.id] = j;
        }
        for (j = itemsToInsert.length - 1; j >= 0; j--) {
            this.onInsertItem(itemsToInsert[j]);
        }
        for (j = this.heightMap.length - 1; j >= i; j--) {
            this.onRefreshItem(this.heightMap[j]);
        }
        return sizeDiff;
    };
    HeightMap.prototype.onInsertItem = function (item) {
        // noop
    };
    // Contiguous items
    HeightMap.prototype.onRemoveItems = function (iterator) {
        var itemId;
        var viewItem;
        var startIndex = null;
        var i;
        var sizeDiff = 0;
        while (itemId = iterator.next()) {
            i = this.indexes[itemId];
            viewItem = this.heightMap[i];
            if (!viewItem) {
                console.error('view item doesnt exist');
                return;
            }
            sizeDiff -= viewItem.height;
            delete this.indexes[itemId];
            this.onRemoveItem(viewItem);
            if (startIndex === null) {
                startIndex = i;
            }
        }
        if (sizeDiff === 0) {
            return;
        }
        this.heightMap.splice(startIndex, i - startIndex + 1);
        for (i = startIndex; i < this.heightMap.length; i++) {
            viewItem = this.heightMap[i];
            viewItem.top += sizeDiff;
            this.indexes[viewItem.model.id] = i;
            this.onRefreshItem(viewItem);
        }
    };
    HeightMap.prototype.onRemoveItem = function (item) {
        // noop
    };
    HeightMap.prototype.onRefreshItemSet = function (items) {
        var _this = this;
        var sortedItems = items.sort(function (a, b) { return _this.indexes[a.id] - _this.indexes[b.id]; });
        this.onRefreshItems(new ArrayIterator(sortedItems));
    };
    // Ordered, but not necessarily contiguous items
    HeightMap.prototype.onRefreshItems = function (iterator) {
        var item;
        var viewItem;
        var newHeight;
        var i, j = null;
        var cummDiff = 0;
        while (item = iterator.next()) {
            i = this.indexes[item.id];
            for (; cummDiff !== 0 && j !== null && j < i; j++) {
                viewItem = this.heightMap[j];
                viewItem.top += cummDiff;
                this.onRefreshItem(viewItem);
            }
            viewItem = this.heightMap[i];
            newHeight = item.getHeight();
            viewItem.top += cummDiff;
            cummDiff += newHeight - viewItem.height;
            viewItem.height = newHeight;
            this.onRefreshItem(viewItem, true);
            j = i + 1;
        }
        if (cummDiff !== 0 && j !== null) {
            for (; j < this.heightMap.length; j++) {
                viewItem = this.heightMap[j];
                viewItem.top += cummDiff;
                this.onRefreshItem(viewItem);
            }
        }
    };
    HeightMap.prototype.onRefreshItem = function (item, needsRender) {
        if (needsRender === void 0) { needsRender = false; }
        // noop
    };
    HeightMap.prototype.itemsCount = function () {
        return this.heightMap.length;
    };
    HeightMap.prototype.itemAt = function (position) {
        return this.heightMap[this.indexAt(position)].model.id;
    };
    HeightMap.prototype.withItemsInRange = function (start, end, fn) {
        start = this.indexAt(start);
        end = this.indexAt(end);
        for (var i = start; i <= end; i++) {
            fn(this.heightMap[i].model.id);
        }
    };
    HeightMap.prototype.indexAt = function (position) {
        var left = 0;
        var right = this.heightMap.length;
        var center;
        var item;
        // Binary search
        while (left < right) {
            center = Math.floor((left + right) / 2);
            item = this.heightMap[center];
            if (position < item.top) {
                right = center;
            }
            else if (position >= item.top + item.height) {
                if (left === center) {
                    break;
                }
                left = center;
            }
            else {
                return center;
            }
        }
        return this.heightMap.length;
    };
    HeightMap.prototype.indexAfter = function (position) {
        return Math.min(this.indexAt(position) + 1, this.heightMap.length);
    };
    HeightMap.prototype.itemAtIndex = function (index) {
        return this.heightMap[index];
    };
    HeightMap.prototype.itemAfter = function (item) {
        return this.heightMap[this.indexes[item.model.id] + 1] || null;
    };
    HeightMap.prototype.createViewItem = function (item) {
        throw new Error('not implemented');
    };
    HeightMap.prototype.dispose = function () {
        this.heightMap = null;
        this.indexes = null;
    };
    return HeightMap;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$1k = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var ContextMenuEvent = /** @class */ (function () {
    function ContextMenuEvent(posx, posy, target) {
        this._posx = posx;
        this._posy = posy;
        this._target = target;
    }
    ContextMenuEvent.prototype.preventDefault = function () {
        // no-op
    };
    ContextMenuEvent.prototype.stopPropagation = function () {
        // no-op
    };
    Object.defineProperty(ContextMenuEvent.prototype, "posx", {
        get: function () {
            return this._posx;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ContextMenuEvent.prototype, "posy", {
        get: function () {
            return this._posy;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ContextMenuEvent.prototype, "target", {
        get: function () {
            return this._target;
        },
        enumerable: true,
        configurable: true
    });
    return ContextMenuEvent;
}());
var MouseContextMenuEvent = /** @class */ (function (_super) {
    __extends$1k(MouseContextMenuEvent, _super);
    function MouseContextMenuEvent(originalEvent) {
        var _this = _super.call(this, originalEvent.posx, originalEvent.posy, originalEvent.target) || this;
        _this.originalEvent = originalEvent;
        return _this;
    }
    MouseContextMenuEvent.prototype.preventDefault = function () {
        this.originalEvent.preventDefault();
    };
    MouseContextMenuEvent.prototype.stopPropagation = function () {
        this.originalEvent.stopPropagation();
    };
    return MouseContextMenuEvent;
}(ContextMenuEvent));
var KeyboardContextMenuEvent = /** @class */ (function (_super) {
    __extends$1k(KeyboardContextMenuEvent, _super);
    function KeyboardContextMenuEvent(posx, posy, originalEvent) {
        var _this = _super.call(this, posx, posy, originalEvent.target) || this;
        _this.originalEvent = originalEvent;
        return _this;
    }
    KeyboardContextMenuEvent.prototype.preventDefault = function () {
        this.originalEvent.preventDefault();
    };
    KeyboardContextMenuEvent.prototype.stopPropagation = function () {
        this.originalEvent.stopPropagation();
    };
    return KeyboardContextMenuEvent;
}(ContextMenuEvent));
var DragOverEffect;
(function (DragOverEffect) {
    DragOverEffect[DragOverEffect["COPY"] = 0] = "COPY";
    DragOverEffect[DragOverEffect["MOVE"] = 1] = "MOVE";
})(DragOverEffect || (DragOverEffect = {}));
var DragOverBubble;
(function (DragOverBubble) {
    DragOverBubble[DragOverBubble["BUBBLE_DOWN"] = 0] = "BUBBLE_DOWN";
    DragOverBubble[DragOverBubble["BUBBLE_UP"] = 1] = "BUBBLE_UP";
})(DragOverBubble || (DragOverBubble = {}));
var DRAG_OVER_ACCEPT_BUBBLE_UP = { accept: true, bubble: DragOverBubble.BUBBLE_UP };
var DRAG_OVER_ACCEPT_BUBBLE_UP_COPY = { accept: true, bubble: DragOverBubble.BUBBLE_UP, effect: DragOverEffect.COPY };

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// Common data transfers
var DataTransfers = {
    /**
     * Application specific resource transfer type
     */
    RESOURCES: 'ResourceURLs',
    /**
     * Browser specific transfer type to download
     */
    DOWNLOAD_URL: 'DownloadURL',
    /**
     * Browser specific transfer type for files
     */
    FILES: 'Files',
    /**
     * Typicaly transfer type for copy/paste transfers.
     */
    TEXT: 'text/plain'
};

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$1l = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
function removeFromParent$1(element) {
    try {
        element.parentElement.removeChild(element);
    }
    catch (e) {
        // this will throw if this happens due to a blur event, nasty business
    }
}
var RowCache$1 = /** @class */ (function () {
    function RowCache(context) {
        this.context = context;
        this._cache = { '': [] };
    }
    RowCache.prototype.alloc = function (templateId) {
        var result = this.cache(templateId).pop();
        if (!result) {
            var content = document.createElement('div');
            content.className = 'content';
            var row = document.createElement('div');
            row.appendChild(content);
            result = {
                element: row,
                templateId: templateId,
                templateData: this.context.renderer.renderTemplate(this.context.tree, templateId, content)
            };
        }
        return result;
    };
    RowCache.prototype.release = function (templateId, row) {
        removeFromParent$1(row.element);
        this.cache(templateId).push(row);
    };
    RowCache.prototype.cache = function (templateId) {
        return this._cache[templateId] || (this._cache[templateId] = []);
    };
    RowCache.prototype.garbageCollect = function () {
        var _this = this;
        if (this._cache) {
            Object.keys(this._cache).forEach(function (templateId) {
                _this._cache[templateId].forEach(function (cachedRow) {
                    _this.context.renderer.disposeTemplate(_this.context.tree, templateId, cachedRow.templateData);
                    cachedRow.element = null;
                    cachedRow.templateData = null;
                });
                delete _this._cache[templateId];
            });
        }
    };
    RowCache.prototype.dispose = function () {
        this.garbageCollect();
        this._cache = null;
        this.context = null;
    };
    return RowCache;
}());
var ViewItem = /** @class */ (function () {
    function ViewItem(context, model) {
        var _this = this;
        this.width = 0;
        this.context = context;
        this.model = model;
        this.id = this.model.id;
        this.row = null;
        this.top = 0;
        this.height = model.getHeight();
        this._styles = {};
        model.getAllTraits().forEach(function (t) { return _this._styles[t] = true; });
        if (model.isExpanded()) {
            this.addClass('expanded');
        }
    }
    Object.defineProperty(ViewItem.prototype, "expanded", {
        set: function (value) {
            value ? this.addClass('expanded') : this.removeClass('expanded');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ViewItem.prototype, "loading", {
        set: function (value) {
            value ? this.addClass('loading') : this.removeClass('loading');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ViewItem.prototype, "draggable", {
        get: function () {
            return this._draggable;
        },
        set: function (value) {
            this._draggable = value;
            this.render(true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ViewItem.prototype, "dropTarget", {
        set: function (value) {
            value ? this.addClass('drop-target') : this.removeClass('drop-target');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ViewItem.prototype, "element", {
        get: function () {
            return this.row && this.row.element;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ViewItem.prototype, "templateId", {
        get: function () {
            return this._templateId || (this._templateId = (this.context.renderer.getTemplateId && this.context.renderer.getTemplateId(this.context.tree, this.model.getElement())));
        },
        enumerable: true,
        configurable: true
    });
    ViewItem.prototype.addClass = function (name) {
        this._styles[name] = true;
        this.render(true);
    };
    ViewItem.prototype.removeClass = function (name) {
        delete this._styles[name]; // is this slow?
        this.render(true);
    };
    ViewItem.prototype.render = function (skipUserRender) {
        var _this = this;
        if (skipUserRender === void 0) { skipUserRender = false; }
        if (!this.model || !this.element) {
            return;
        }
        var classes = ['monaco-tree-row'];
        classes.push.apply(classes, Object.keys(this._styles));
        if (this.model.hasChildren()) {
            classes.push('has-children');
        }
        this.element.className = classes.join(' ');
        this.element.draggable = this.draggable;
        this.element.style.height = this.height + 'px';
        // ARIA
        this.element.setAttribute('role', 'treeitem');
        var accessibility = this.context.accessibilityProvider;
        var ariaLabel = accessibility.getAriaLabel(this.context.tree, this.model.getElement());
        if (ariaLabel) {
            this.element.setAttribute('aria-label', ariaLabel);
        }
        if (accessibility.getPosInSet && accessibility.getSetSize) {
            this.element.setAttribute('aria-setsize', accessibility.getSetSize());
            this.element.setAttribute('aria-posinset', accessibility.getPosInSet(this.context.tree, this.model.getElement()));
        }
        if (this.model.hasTrait('focused')) {
            var base64Id = safeBtoa(this.model.id);
            this.element.setAttribute('aria-selected', 'true');
            this.element.setAttribute('id', base64Id);
        }
        else {
            this.element.setAttribute('aria-selected', 'false');
            this.element.removeAttribute('id');
        }
        if (this.model.hasChildren()) {
            this.element.setAttribute('aria-expanded', String(!!this.model.isExpanded()));
        }
        else {
            this.element.removeAttribute('aria-expanded');
        }
        this.element.setAttribute('aria-level', String(this.model.getDepth()));
        if (this.context.options.paddingOnRow) {
            this.element.style.paddingLeft = this.context.options.twistiePixels + ((this.model.getDepth() - 1) * this.context.options.indentPixels) + 'px';
        }
        else {
            this.element.style.paddingLeft = ((this.model.getDepth() - 1) * this.context.options.indentPixels) + 'px';
            this.row.element.firstElementChild.style.paddingLeft = this.context.options.twistiePixels + 'px';
        }
        var uri = this.context.dnd.getDragURI(this.context.tree, this.model.getElement());
        if (uri !== this.uri) {
            if (this.unbindDragStart) {
                this.unbindDragStart.dispose();
                this.unbindDragStart = null;
            }
            if (uri) {
                this.uri = uri;
                this.draggable = true;
                this.unbindDragStart = addDisposableListener(this.element, 'dragstart', function (e) {
                    _this.onDragStart(e);
                });
            }
            else {
                this.uri = null;
            }
        }
        if (!skipUserRender && this.element) {
            var style = window.getComputedStyle(this.element);
            var paddingLeft = parseFloat(style.paddingLeft);
            if (this.context.horizontalScrolling) {
                this.element.style.width = 'fit-content';
            }
            this.context.renderer.renderElement(this.context.tree, this.model.getElement(), this.templateId, this.row.templateData);
            if (this.context.horizontalScrolling) {
                this.width = getContentWidth(this.element) + paddingLeft;
                this.element.style.width = '';
            }
        }
    };
    ViewItem.prototype.updateWidth = function () {
        if (!this.context.horizontalScrolling || !this.element) {
            return;
        }
        var style = window.getComputedStyle(this.element);
        var paddingLeft = parseFloat(style.paddingLeft);
        this.element.style.width = 'fit-content';
        this.width = getContentWidth(this.element) + paddingLeft;
        this.element.style.width = '';
    };
    ViewItem.prototype.insertInDOM = function (container, afterElement) {
        if (!this.row) {
            this.row = this.context.cache.alloc(this.templateId);
            // used in reverse lookup from HTMLElement to Item
            this.element[TreeView.BINDING] = this;
        }
        if (this.element.parentElement) {
            return;
        }
        if (afterElement === null) {
            container.appendChild(this.element);
        }
        else {
            try {
                container.insertBefore(this.element, afterElement);
            }
            catch (e) {
                console.warn('Failed to locate previous tree element');
                container.appendChild(this.element);
            }
        }
        this.render();
    };
    ViewItem.prototype.removeFromDOM = function () {
        if (!this.row) {
            return;
        }
        if (this.unbindDragStart) {
            this.unbindDragStart.dispose();
            this.unbindDragStart = null;
        }
        this.uri = null;
        this.element[TreeView.BINDING] = null;
        this.context.cache.release(this.templateId, this.row);
        this.row = null;
    };
    ViewItem.prototype.dispose = function () {
        this.row = null;
        this.model = null;
    };
    return ViewItem;
}());
var RootViewItem = /** @class */ (function (_super) {
    __extends$1l(RootViewItem, _super);
    function RootViewItem(context, model, wrapper) {
        var _this = _super.call(this, context, model) || this;
        _this.row = {
            element: wrapper,
            templateData: null,
            templateId: null
        };
        return _this;
    }
    RootViewItem.prototype.render = function () {
        if (!this.model || !this.element) {
            return;
        }
        var classes = ['monaco-tree-wrapper'];
        classes.push.apply(classes, Object.keys(this._styles));
        if (this.model.hasChildren()) {
            classes.push('has-children');
        }
        this.element.className = classes.join(' ');
    };
    RootViewItem.prototype.insertInDOM = function (container, afterElement) {
        // noop
    };
    RootViewItem.prototype.removeFromDOM = function () {
        // noop
    };
    return RootViewItem;
}(ViewItem));
function reactionEquals(one, other) {
    if (!one && !other) {
        return true;
    }
    else if (!one || !other) {
        return false;
    }
    else if (one.accept !== other.accept) {
        return false;
    }
    else if (one.bubble !== other.bubble) {
        return false;
    }
    else if (one.effect !== other.effect) {
        return false;
    }
    else {
        return true;
    }
}
var TreeView = /** @class */ (function (_super) {
    __extends$1l(TreeView, _super);
    function TreeView(context, container) {
        var _this = _super.call(this) || this;
        _this.lastClickTimeStamp = 0;
        _this.contentWidthUpdateDelayer = new Delayer(50);
        _this.isRefreshing = false;
        _this.refreshingPreviousChildrenIds = {};
        _this._onDOMFocus = new Emitter();
        _this._onDOMBlur = new Emitter();
        TreeView.counter++;
        _this.instance = TreeView.counter;
        var horizontalScrollMode = typeof context.options.horizontalScrollMode === 'undefined' ? ScrollbarVisibility.Hidden : context.options.horizontalScrollMode;
        _this.horizontalScrolling = horizontalScrollMode !== ScrollbarVisibility.Hidden;
        _this.context = {
            dataSource: context.dataSource,
            renderer: context.renderer,
            controller: context.controller,
            dnd: context.dnd,
            filter: context.filter,
            sorter: context.sorter,
            tree: context.tree,
            accessibilityProvider: context.accessibilityProvider,
            options: context.options,
            cache: new RowCache$1(context),
            horizontalScrolling: _this.horizontalScrolling
        };
        _this.modelListeners = [];
        _this.viewListeners = [];
        _this.model = null;
        _this.items = {};
        _this.domNode = document.createElement('div');
        _this.domNode.className = "monaco-tree no-focused-item monaco-tree-instance-" + _this.instance;
        // to allow direct tabbing into the tree instead of first focusing the tree
        _this.domNode.tabIndex = context.options.preventRootFocus ? -1 : 0;
        _this.styleElement = createStyleSheet(_this.domNode);
        _this.treeStyler = context.styler;
        if (!_this.treeStyler) {
            _this.treeStyler = new DefaultTreestyler(_this.styleElement, "monaco-tree-instance-" + _this.instance);
        }
        // ARIA
        _this.domNode.setAttribute('role', 'tree');
        if (_this.context.options.ariaLabel) {
            _this.domNode.setAttribute('aria-label', _this.context.options.ariaLabel);
        }
        if (_this.context.options.alwaysFocused) {
            addClass(_this.domNode, 'focused');
        }
        if (!_this.context.options.paddingOnRow) {
            addClass(_this.domNode, 'no-row-padding');
        }
        _this.wrapper = document.createElement('div');
        _this.wrapper.className = 'monaco-tree-wrapper';
        _this.scrollableElement = new ScrollableElement(_this.wrapper, {
            alwaysConsumeMouseWheel: true,
            horizontal: horizontalScrollMode,
            vertical: (typeof context.options.verticalScrollMode !== 'undefined' ? context.options.verticalScrollMode : ScrollbarVisibility.Auto),
            useShadows: context.options.useShadows
        });
        _this.scrollableElement.onScroll(function (e) {
            _this.render(e.scrollTop, e.height, e.scrollLeft, e.width, e.scrollWidth);
        });
        if (isIE) {
            _this.wrapper.style.msTouchAction = 'none';
            _this.wrapper.style.msContentZooming = 'none';
        }
        else {
            Gesture.addTarget(_this.wrapper);
        }
        _this.rowsContainer = document.createElement('div');
        _this.rowsContainer.className = 'monaco-tree-rows';
        if (context.options.showTwistie) {
            _this.rowsContainer.className += ' show-twisties';
        }
        var focusTracker = trackFocus(_this.domNode);
        _this.viewListeners.push(focusTracker.onDidFocus(function () { return _this.onFocus(); }));
        _this.viewListeners.push(focusTracker.onDidBlur(function () { return _this.onBlur(); }));
        _this.viewListeners.push(focusTracker);
        _this.viewListeners.push(addDisposableListener(_this.domNode, 'keydown', function (e) { return _this.onKeyDown(e); }));
        _this.viewListeners.push(addDisposableListener(_this.domNode, 'keyup', function (e) { return _this.onKeyUp(e); }));
        _this.viewListeners.push(addDisposableListener(_this.domNode, 'mousedown', function (e) { return _this.onMouseDown(e); }));
        _this.viewListeners.push(addDisposableListener(_this.domNode, 'mouseup', function (e) { return _this.onMouseUp(e); }));
        _this.viewListeners.push(addDisposableListener(_this.wrapper, 'click', function (e) { return _this.onClick(e); }));
        _this.viewListeners.push(addDisposableListener(_this.wrapper, 'auxclick', function (e) { return _this.onClick(e); })); // >= Chrome 56
        _this.viewListeners.push(addDisposableListener(_this.domNode, 'contextmenu', function (e) { return _this.onContextMenu(e); }));
        _this.viewListeners.push(addDisposableListener(_this.wrapper, EventType$1.Tap, function (e) { return _this.onTap(e); }));
        _this.viewListeners.push(addDisposableListener(_this.wrapper, EventType$1.Change, function (e) { return _this.onTouchChange(e); }));
        if (isIE) {
            _this.viewListeners.push(addDisposableListener(_this.wrapper, 'MSPointerDown', function (e) { return _this.onMsPointerDown(e); }));
            _this.viewListeners.push(addDisposableListener(_this.wrapper, 'MSGestureTap', function (e) { return _this.onMsGestureTap(e); }));
            // these events come too fast, we throttle them
            _this.viewListeners.push(addDisposableThrottledListener(_this.wrapper, 'MSGestureChange', function (e) { return _this.onThrottledMsGestureChange(e); }, function (lastEvent, event) {
                event.stopPropagation();
                event.preventDefault();
                var result = { translationY: event.translationY, translationX: event.translationX };
                if (lastEvent) {
                    result.translationY += lastEvent.translationY;
                    result.translationX += lastEvent.translationX;
                }
                return result;
            }));
        }
        _this.viewListeners.push(addDisposableListener(window, 'dragover', function (e) { return _this.onDragOver(e); }));
        _this.viewListeners.push(addDisposableListener(_this.wrapper, 'drop', function (e) { return _this.onDrop(e); }));
        _this.viewListeners.push(addDisposableListener(window, 'dragend', function (e) { return _this.onDragEnd(e); }));
        _this.viewListeners.push(addDisposableListener(window, 'dragleave', function (e) { return _this.onDragOver(e); }));
        _this.wrapper.appendChild(_this.rowsContainer);
        _this.domNode.appendChild(_this.scrollableElement.getDomNode());
        container.appendChild(_this.domNode);
        _this.lastRenderTop = 0;
        _this.lastRenderHeight = 0;
        _this.didJustPressContextMenuKey = false;
        _this.currentDropTarget = null;
        _this.currentDropTargets = [];
        _this.shouldInvalidateDropReaction = false;
        _this.dragAndDropScrollInterval = null;
        _this.dragAndDropScrollTimeout = null;
        _this.onHiddenScrollTop = null;
        _this.onRowsChanged();
        _this.layout();
        _this.setupMSGesture();
        _this.applyStyles(context.options);
        return _this;
    }
    Object.defineProperty(TreeView.prototype, "onDOMFocus", {
        get: function () { return this._onDOMFocus.event; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TreeView.prototype, "onDOMBlur", {
        get: function () { return this._onDOMBlur.event; },
        enumerable: true,
        configurable: true
    });
    TreeView.prototype.applyStyles = function (styles) {
        this.treeStyler.style(styles);
    };
    TreeView.prototype.createViewItem = function (item) {
        return new ViewItem(this.context, item);
    };
    TreeView.prototype.getHTMLElement = function () {
        return this.domNode;
    };
    TreeView.prototype.focus = function () {
        this.domNode.focus();
    };
    TreeView.prototype.isFocused = function () {
        return document.activeElement === this.domNode;
    };
    TreeView.prototype.blur = function () {
        this.domNode.blur();
    };
    TreeView.prototype.onVisible = function () {
        this.scrollTop = this.onHiddenScrollTop;
        this.onHiddenScrollTop = null;
        this.setupMSGesture();
    };
    TreeView.prototype.setupMSGesture = function () {
        var _this = this;
        if (window.MSGesture) {
            this.msGesture = new MSGesture();
            setTimeout(function () { return _this.msGesture.target = _this.wrapper; }, 100); // TODO@joh, TODO@IETeam
        }
    };
    TreeView.prototype.onHidden = function () {
        this.onHiddenScrollTop = this.scrollTop;
    };
    TreeView.prototype.isTreeVisible = function () {
        return this.onHiddenScrollTop === null;
    };
    TreeView.prototype.layout = function (height, width) {
        if (!this.isTreeVisible()) {
            return;
        }
        this.viewHeight = height || getContentHeight(this.wrapper); // render
        this.scrollHeight = this.getContentHeight();
        if (this.horizontalScrolling) {
            this.viewWidth = width || getContentWidth(this.wrapper);
        }
    };
    TreeView.prototype.render = function (scrollTop, viewHeight, scrollLeft, viewWidth, scrollWidth) {
        var i;
        var stop;
        var renderTop = scrollTop;
        var renderBottom = scrollTop + viewHeight;
        var thisRenderBottom = this.lastRenderTop + this.lastRenderHeight;
        // when view scrolls down, start rendering from the renderBottom
        for (i = this.indexAfter(renderBottom) - 1, stop = this.indexAt(Math.max(thisRenderBottom, renderTop)); i >= stop; i--) {
            this.insertItemInDOM(this.itemAtIndex(i));
        }
        // when view scrolls up, start rendering from either this.renderTop or renderBottom
        for (i = Math.min(this.indexAt(this.lastRenderTop), this.indexAfter(renderBottom)) - 1, stop = this.indexAt(renderTop); i >= stop; i--) {
            this.insertItemInDOM(this.itemAtIndex(i));
        }
        // when view scrolls down, start unrendering from renderTop
        for (i = this.indexAt(this.lastRenderTop), stop = Math.min(this.indexAt(renderTop), this.indexAfter(thisRenderBottom)); i < stop; i++) {
            this.removeItemFromDOM(this.itemAtIndex(i));
        }
        // when view scrolls up, start unrendering from either renderBottom this.renderTop
        for (i = Math.max(this.indexAfter(renderBottom), this.indexAt(this.lastRenderTop)), stop = this.indexAfter(thisRenderBottom); i < stop; i++) {
            this.removeItemFromDOM(this.itemAtIndex(i));
        }
        var topItem = this.itemAtIndex(this.indexAt(renderTop));
        if (topItem) {
            this.rowsContainer.style.top = (topItem.top - renderTop) + 'px';
        }
        if (this.horizontalScrolling) {
            this.rowsContainer.style.left = -scrollLeft + 'px';
            this.rowsContainer.style.width = Math.max(scrollWidth, viewWidth) + "px";
        }
        this.lastRenderTop = renderTop;
        this.lastRenderHeight = renderBottom - renderTop;
    };
    TreeView.prototype.setModel = function (newModel) {
        this.releaseModel();
        this.model = newModel;
        this.model.onRefresh(this.onRefreshing, this, this.modelListeners);
        this.model.onDidRefresh(this.onRefreshed, this, this.modelListeners);
        this.model.onSetInput(this.onClearingInput, this, this.modelListeners);
        this.model.onDidSetInput(this.onSetInput, this, this.modelListeners);
        this.model.onDidFocus(this.onModelFocusChange, this, this.modelListeners);
        this.model.onRefreshItemChildren(this.onItemChildrenRefreshing, this, this.modelListeners);
        this.model.onDidRefreshItemChildren(this.onItemChildrenRefreshed, this, this.modelListeners);
        this.model.onDidRefreshItem(this.onItemRefresh, this, this.modelListeners);
        this.model.onExpandItem(this.onItemExpanding, this, this.modelListeners);
        this.model.onDidExpandItem(this.onItemExpanded, this, this.modelListeners);
        this.model.onCollapseItem(this.onItemCollapsing, this, this.modelListeners);
        this.model.onDidRevealItem(this.onItemReveal, this, this.modelListeners);
        this.model.onDidAddTraitItem(this.onItemAddTrait, this, this.modelListeners);
        this.model.onDidRemoveTraitItem(this.onItemRemoveTrait, this, this.modelListeners);
    };
    TreeView.prototype.onRefreshing = function () {
        this.isRefreshing = true;
    };
    TreeView.prototype.onRefreshed = function () {
        this.isRefreshing = false;
        this.onRowsChanged();
    };
    TreeView.prototype.onRowsChanged = function (scrollTop) {
        if (scrollTop === void 0) { scrollTop = this.scrollTop; }
        if (this.isRefreshing) {
            return;
        }
        this.scrollTop = scrollTop;
        this.updateScrollWidth();
    };
    TreeView.prototype.updateScrollWidth = function () {
        var _this = this;
        if (!this.horizontalScrolling) {
            return;
        }
        this.contentWidthUpdateDelayer.trigger(function () {
            var keys = Object.keys(_this.items);
            var scrollWidth = 0;
            for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
                var key = keys_1[_i];
                scrollWidth = Math.max(scrollWidth, _this.items[key].width);
            }
            _this.scrollWidth = scrollWidth + 10 /* scrollbar */;
        });
    };
    TreeView.prototype.focusNextPage = function (eventPayload) {
        var _this = this;
        var lastPageIndex = this.indexAt(this.scrollTop + this.viewHeight);
        lastPageIndex = lastPageIndex === 0 ? 0 : lastPageIndex - 1;
        var lastPageElement = this.itemAtIndex(lastPageIndex).model.getElement();
        var currentlyFocusedElement = this.model.getFocus();
        if (currentlyFocusedElement !== lastPageElement) {
            this.model.setFocus(lastPageElement, eventPayload);
        }
        else {
            var previousScrollTop = this.scrollTop;
            this.scrollTop += this.viewHeight;
            if (this.scrollTop !== previousScrollTop) {
                // Let the scroll event listener run
                setTimeout(function () {
                    _this.focusNextPage(eventPayload);
                }, 0);
            }
        }
    };
    TreeView.prototype.focusPreviousPage = function (eventPayload) {
        var _this = this;
        var firstPageIndex;
        if (this.scrollTop === 0) {
            firstPageIndex = this.indexAt(this.scrollTop);
        }
        else {
            firstPageIndex = this.indexAfter(this.scrollTop - 1);
        }
        var firstPageElement = this.itemAtIndex(firstPageIndex).model.getElement();
        var currentlyFocusedElement = this.model.getFocus();
        if (currentlyFocusedElement !== firstPageElement) {
            this.model.setFocus(firstPageElement, eventPayload);
        }
        else {
            var previousScrollTop = this.scrollTop;
            this.scrollTop -= this.viewHeight;
            if (this.scrollTop !== previousScrollTop) {
                // Let the scroll event listener run
                setTimeout(function () {
                    _this.focusPreviousPage(eventPayload);
                }, 0);
            }
        }
    };
    Object.defineProperty(TreeView.prototype, "viewHeight", {
        get: function () {
            var scrollDimensions = this.scrollableElement.getScrollDimensions();
            return scrollDimensions.height;
        },
        set: function (height) {
            this.scrollableElement.setScrollDimensions({ height: height });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TreeView.prototype, "scrollHeight", {
        set: function (scrollHeight) {
            this.scrollableElement.setScrollDimensions({ scrollHeight: scrollHeight });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TreeView.prototype, "viewWidth", {
        get: function () {
            var scrollDimensions = this.scrollableElement.getScrollDimensions();
            return scrollDimensions.width;
        },
        set: function (viewWidth) {
            this.scrollableElement.setScrollDimensions({ width: viewWidth });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TreeView.prototype, "scrollWidth", {
        set: function (scrollWidth) {
            this.scrollableElement.setScrollDimensions({ scrollWidth: scrollWidth });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TreeView.prototype, "scrollTop", {
        get: function () {
            var scrollPosition = this.scrollableElement.getScrollPosition();
            return scrollPosition.scrollTop;
        },
        set: function (scrollTop) {
            this.scrollableElement.setScrollDimensions({
                scrollHeight: this.getContentHeight()
            });
            this.scrollableElement.setScrollPosition({
                scrollTop: scrollTop
            });
        },
        enumerable: true,
        configurable: true
    });
    TreeView.prototype.getScrollPosition = function () {
        var height = this.getContentHeight() - this.viewHeight;
        return height <= 0 ? 1 : this.scrollTop / height;
    };
    TreeView.prototype.setScrollPosition = function (pos) {
        var height = this.getContentHeight() - this.viewHeight;
        this.scrollTop = height * pos;
    };
    // Events
    TreeView.prototype.onClearingInput = function (e) {
        var item = e.item;
        if (item) {
            this.onRemoveItems(new MappedIterator(item.getNavigator(), function (item) { return item && item.id; }));
            this.onRowsChanged();
        }
    };
    TreeView.prototype.onSetInput = function (e) {
        this.context.cache.garbageCollect();
        this.inputItem = new RootViewItem(this.context, e.item, this.wrapper);
    };
    TreeView.prototype.onItemChildrenRefreshing = function (e) {
        var item = e.item;
        var viewItem = this.items[item.id];
        if (viewItem) {
            viewItem.loadingTimer = setTimeout(function () {
                viewItem.loadingTimer = 0;
                viewItem.loading = true;
            }, TreeView.LOADING_DECORATION_DELAY);
        }
        if (!e.isNested) {
            var childrenIds = [];
            var navigator = item.getNavigator();
            var childItem;
            while (childItem = navigator.next()) {
                childrenIds.push(childItem.id);
            }
            this.refreshingPreviousChildrenIds[item.id] = childrenIds;
        }
    };
    TreeView.prototype.onItemChildrenRefreshed = function (e) {
        var _this = this;
        var item = e.item;
        var viewItem = this.items[item.id];
        if (viewItem) {
            if (viewItem.loadingTimer) {
                clearTimeout(viewItem.loadingTimer);
                viewItem.loadingTimer = 0;
            }
            viewItem.loading = false;
        }
        if (!e.isNested) {
            var previousChildrenIds = this.refreshingPreviousChildrenIds[item.id];
            var afterModelItems = [];
            var navigator = item.getNavigator();
            var childItem;
            while (childItem = navigator.next()) {
                afterModelItems.push(childItem);
            }
            var skipDiff = Math.abs(previousChildrenIds.length - afterModelItems.length) > 1000;
            var diff = void 0;
            var doToInsertItemsAlreadyExist = void 0;
            if (!skipDiff) {
                var lcs = new LcsDiff({
                    getLength: function () { return previousChildrenIds.length; },
                    getElementHash: function (i) { return previousChildrenIds[i]; }
                }, {
                    getLength: function () { return afterModelItems.length; },
                    getElementHash: function (i) { return afterModelItems[i].id; }
                }, null);
                diff = lcs.ComputeDiff(false);
                // this means that the result of the diff algorithm would result
                // in inserting items that were already registered. this can only
                // happen if the data provider returns bad ids OR if the sorting
                // of the elements has changed
                doToInsertItemsAlreadyExist = diff.some(function (d) {
                    if (d.modifiedLength > 0) {
                        for (var i = d.modifiedStart, len = d.modifiedStart + d.modifiedLength; i < len; i++) {
                            if (_this.items.hasOwnProperty(afterModelItems[i].id)) {
                                return true;
                            }
                        }
                    }
                    return false;
                });
            }
            // 50 is an optimization number, at some point we're better off
            // just replacing everything
            if (!skipDiff && !doToInsertItemsAlreadyExist && diff.length < 50) {
                for (var i = 0, len = diff.length; i < len; i++) {
                    var diffChange = diff[i];
                    if (diffChange.originalLength > 0) {
                        this.onRemoveItems(new ArrayIterator(previousChildrenIds, diffChange.originalStart, diffChange.originalStart + diffChange.originalLength));
                    }
                    if (diffChange.modifiedLength > 0) {
                        var beforeItem = afterModelItems[diffChange.modifiedStart - 1] || item;
                        beforeItem = beforeItem.getDepth() > 0 ? beforeItem : null;
                        this.onInsertItems(new ArrayIterator(afterModelItems, diffChange.modifiedStart, diffChange.modifiedStart + diffChange.modifiedLength), beforeItem ? beforeItem.id : null);
                    }
                }
            }
            else if (skipDiff || diff.length) {
                this.onRemoveItems(new ArrayIterator(previousChildrenIds));
                this.onInsertItems(new ArrayIterator(afterModelItems), item.getDepth() > 0 ? item.id : null);
            }
            if (skipDiff || diff.length) {
                this.onRowsChanged();
            }
        }
    };
    TreeView.prototype.onItemRefresh = function (item) {
        this.onItemsRefresh([item]);
    };
    TreeView.prototype.onItemsRefresh = function (items) {
        var _this = this;
        this.onRefreshItemSet(items.filter(function (item) { return _this.items.hasOwnProperty(item.id); }));
        this.onRowsChanged();
    };
    TreeView.prototype.onItemExpanding = function (e) {
        var viewItem = this.items[e.item.id];
        if (viewItem) {
            viewItem.expanded = true;
        }
    };
    TreeView.prototype.onItemExpanded = function (e) {
        var item = e.item;
        var viewItem = this.items[item.id];
        if (viewItem) {
            viewItem.expanded = true;
            var height = this.onInsertItems(item.getNavigator(), item.id);
            var scrollTop = this.scrollTop;
            if (viewItem.top + viewItem.height <= this.scrollTop) {
                scrollTop += height;
            }
            this.onRowsChanged(scrollTop);
        }
    };
    TreeView.prototype.onItemCollapsing = function (e) {
        var item = e.item;
        var viewItem = this.items[item.id];
        if (viewItem) {
            viewItem.expanded = false;
            this.onRemoveItems(new MappedIterator(item.getNavigator(), function (item) { return item && item.id; }));
            this.onRowsChanged();
        }
    };
    TreeView.prototype.updateWidth = function (item) {
        if (!item || !item.isVisible()) {
            return;
        }
        var viewItem = this.items[item.id];
        if (!viewItem) {
            return;
        }
        viewItem.updateWidth();
        this.updateScrollWidth();
    };
    TreeView.prototype.getRelativeTop = function (item) {
        if (item && item.isVisible()) {
            var viewItem = this.items[item.id];
            if (viewItem) {
                return (viewItem.top - this.scrollTop) / (this.viewHeight - viewItem.height);
            }
        }
        return -1;
    };
    TreeView.prototype.onItemReveal = function (e) {
        var item = e.item;
        var relativeTop = e.relativeTop;
        var viewItem = this.items[item.id];
        if (viewItem) {
            if (relativeTop !== null) {
                relativeTop = relativeTop < 0 ? 0 : relativeTop;
                relativeTop = relativeTop > 1 ? 1 : relativeTop;
                // y = mx + b
                var m = viewItem.height - this.viewHeight;
                this.scrollTop = m * relativeTop + viewItem.top;
            }
            else {
                var viewItemBottom = viewItem.top + viewItem.height;
                var wrapperBottom = this.scrollTop + this.viewHeight;
                if (viewItem.top < this.scrollTop) {
                    this.scrollTop = viewItem.top;
                }
                else if (viewItemBottom >= wrapperBottom) {
                    this.scrollTop = viewItemBottom - this.viewHeight;
                }
            }
        }
    };
    TreeView.prototype.onItemAddTrait = function (e) {
        var item = e.item;
        var trait = e.trait;
        var viewItem = this.items[item.id];
        if (viewItem) {
            viewItem.addClass(trait);
        }
        if (trait === 'highlighted') {
            addClass(this.domNode, trait);
            // Ugly Firefox fix: input fields can't be selected if parent nodes are draggable
            if (viewItem) {
                this.highlightedItemWasDraggable = !!viewItem.draggable;
                if (viewItem.draggable) {
                    viewItem.draggable = false;
                }
            }
        }
    };
    TreeView.prototype.onItemRemoveTrait = function (e) {
        var item = e.item;
        var trait = e.trait;
        var viewItem = this.items[item.id];
        if (viewItem) {
            viewItem.removeClass(trait);
        }
        if (trait === 'highlighted') {
            removeClass(this.domNode, trait);
            // Ugly Firefox fix: input fields can't be selected if parent nodes are draggable
            if (this.highlightedItemWasDraggable) {
                viewItem.draggable = true;
            }
            this.highlightedItemWasDraggable = false;
        }
    };
    TreeView.prototype.onModelFocusChange = function () {
        var focus = this.model && this.model.getFocus();
        toggleClass(this.domNode, 'no-focused-item', !focus);
        // ARIA
        if (focus) {
            this.domNode.setAttribute('aria-activedescendant', safeBtoa(this.context.dataSource.getId(this.context.tree, focus)));
        }
        else {
            this.domNode.removeAttribute('aria-activedescendant');
        }
    };
    // HeightMap "events"
    TreeView.prototype.onInsertItem = function (item) {
        var _this = this;
        item.onDragStart = function (e) { _this.onDragStart(item, e); };
        item.needsRender = true;
        this.refreshViewItem(item);
        this.items[item.id] = item;
    };
    TreeView.prototype.onRefreshItem = function (item, needsRender) {
        if (needsRender === void 0) { needsRender = false; }
        item.needsRender = item.needsRender || needsRender;
        this.refreshViewItem(item);
    };
    TreeView.prototype.onRemoveItem = function (item) {
        this.removeItemFromDOM(item);
        item.dispose();
        delete this.items[item.id];
    };
    // ViewItem refresh
    TreeView.prototype.refreshViewItem = function (item) {
        item.render();
        if (this.shouldBeRendered(item)) {
            this.insertItemInDOM(item);
        }
        else {
            this.removeItemFromDOM(item);
        }
    };
    // DOM Events
    TreeView.prototype.onClick = function (e) {
        if (this.lastPointerType && this.lastPointerType !== 'mouse') {
            return;
        }
        var event = new StandardMouseEvent(e);
        var item = this.getItemAround(event.target);
        if (!item) {
            return;
        }
        if (isIE && Date.now() - this.lastClickTimeStamp < 300) {
            // IE10+ doesn't set the detail property correctly. While IE10 simply
            // counts the number of clicks, IE11 reports always 1. To align with
            // other browser, we set the value to 2 if clicks events come in a 300ms
            // sequence.
            event.detail = 2;
        }
        this.lastClickTimeStamp = Date.now();
        this.context.controller.onClick(this.context.tree, item.model.getElement(), event);
    };
    TreeView.prototype.onMouseDown = function (e) {
        this.didJustPressContextMenuKey = false;
        if (!this.context.controller.onMouseDown) {
            return;
        }
        if (this.lastPointerType && this.lastPointerType !== 'mouse') {
            return;
        }
        var event = new StandardMouseEvent(e);
        if (event.ctrlKey && isNative && isMacintosh) {
            return;
        }
        var item = this.getItemAround(event.target);
        if (!item) {
            return;
        }
        this.context.controller.onMouseDown(this.context.tree, item.model.getElement(), event);
    };
    TreeView.prototype.onMouseUp = function (e) {
        if (!this.context.controller.onMouseUp) {
            return;
        }
        if (this.lastPointerType && this.lastPointerType !== 'mouse') {
            return;
        }
        var event = new StandardMouseEvent(e);
        if (event.ctrlKey && isNative && isMacintosh) {
            return;
        }
        var item = this.getItemAround(event.target);
        if (!item) {
            return;
        }
        this.context.controller.onMouseUp(this.context.tree, item.model.getElement(), event);
    };
    TreeView.prototype.onTap = function (e) {
        var item = this.getItemAround(e.initialTarget);
        if (!item) {
            return;
        }
        this.context.controller.onTap(this.context.tree, item.model.getElement(), e);
    };
    TreeView.prototype.onTouchChange = function (event) {
        event.preventDefault();
        event.stopPropagation();
        this.scrollTop -= event.translationY;
    };
    TreeView.prototype.onContextMenu = function (event) {
        var resultEvent;
        var element;
        if (event instanceof KeyboardEvent || this.didJustPressContextMenuKey) {
            this.didJustPressContextMenuKey = false;
            var keyboardEvent = new StandardKeyboardEvent(event);
            element = this.model.getFocus();
            var position$$1;
            if (!element) {
                element = this.model.getInput();
                position$$1 = getDomNodePagePosition(this.inputItem.element);
            }
            else {
                var id = this.context.dataSource.getId(this.context.tree, element);
                var viewItem = this.items[id];
                position$$1 = getDomNodePagePosition(viewItem.element);
            }
            resultEvent = new KeyboardContextMenuEvent(position$$1.left + position$$1.width, position$$1.top, keyboardEvent);
        }
        else {
            var mouseEvent = new StandardMouseEvent(event);
            var item = this.getItemAround(mouseEvent.target);
            if (!item) {
                return;
            }
            element = item.model.getElement();
            resultEvent = new MouseContextMenuEvent(mouseEvent);
        }
        this.context.controller.onContextMenu(this.context.tree, element, resultEvent);
    };
    TreeView.prototype.onKeyDown = function (e) {
        var event = new StandardKeyboardEvent(e);
        this.didJustPressContextMenuKey = event.keyCode === 58 /* ContextMenu */ || (event.shiftKey && event.keyCode === 68 /* F10 */);
        if (this.didJustPressContextMenuKey) {
            event.preventDefault();
            event.stopPropagation();
        }
        if (event.target && event.target.tagName && event.target.tagName.toLowerCase() === 'input') {
            return; // Ignore event if target is a form input field (avoids browser specific issues)
        }
        this.context.controller.onKeyDown(this.context.tree, event);
    };
    TreeView.prototype.onKeyUp = function (e) {
        if (this.didJustPressContextMenuKey) {
            this.onContextMenu(e);
        }
        this.didJustPressContextMenuKey = false;
        this.context.controller.onKeyUp(this.context.tree, new StandardKeyboardEvent(e));
    };
    TreeView.prototype.onDragStart = function (item, e) {
        if (this.model.getHighlight()) {
            return;
        }
        var element = item.model.getElement();
        var selection = this.model.getSelection();
        var elements;
        if (selection.indexOf(element) > -1) {
            elements = selection;
        }
        else {
            elements = [element];
        }
        e.dataTransfer.effectAllowed = 'copyMove';
        e.dataTransfer.setData(DataTransfers.RESOURCES, JSON.stringify([item.uri]));
        if (e.dataTransfer.setDragImage) {
            var label = void 0;
            if (this.context.dnd.getDragLabel) {
                label = this.context.dnd.getDragLabel(this.context.tree, elements);
            }
            else {
                label = String(elements.length);
            }
            var dragImage_1 = document.createElement('div');
            dragImage_1.className = 'monaco-tree-drag-image';
            dragImage_1.textContent = label;
            document.body.appendChild(dragImage_1);
            e.dataTransfer.setDragImage(dragImage_1, -10, -10);
            setTimeout(function () { return document.body.removeChild(dragImage_1); }, 0);
        }
        this.currentDragAndDropData = new ElementsDragAndDropData(elements);
        TreeView.currentExternalDragAndDropData = new ExternalElementsDragAndDropData(elements);
        this.context.dnd.onDragStart(this.context.tree, this.currentDragAndDropData, new DragMouseEvent(e));
    };
    TreeView.prototype.setupDragAndDropScrollInterval = function () {
        var _this = this;
        var viewTop = getTopLeftOffset(this.wrapper).top;
        if (!this.dragAndDropScrollInterval) {
            this.dragAndDropScrollInterval = window.setInterval(function () {
                if (_this.dragAndDropMouseY === undefined) {
                    return;
                }
                var diff = _this.dragAndDropMouseY - viewTop;
                var scrollDiff = 0;
                var upperLimit = _this.viewHeight - 35;
                if (diff < 35) {
                    scrollDiff = Math.max(-14, 0.2 * (diff - 35));
                }
                else if (diff > upperLimit) {
                    scrollDiff = Math.min(14, 0.2 * (diff - upperLimit));
                }
                _this.scrollTop += scrollDiff;
            }, 10);
            this.cancelDragAndDropScrollTimeout();
            this.dragAndDropScrollTimeout = window.setTimeout(function () {
                _this.cancelDragAndDropScrollInterval();
                _this.dragAndDropScrollTimeout = null;
            }, 1000);
        }
    };
    TreeView.prototype.cancelDragAndDropScrollInterval = function () {
        if (this.dragAndDropScrollInterval) {
            window.clearInterval(this.dragAndDropScrollInterval);
            this.dragAndDropScrollInterval = null;
        }
        this.cancelDragAndDropScrollTimeout();
    };
    TreeView.prototype.cancelDragAndDropScrollTimeout = function () {
        if (this.dragAndDropScrollTimeout) {
            window.clearTimeout(this.dragAndDropScrollTimeout);
            this.dragAndDropScrollTimeout = null;
        }
    };
    TreeView.prototype.onDragOver = function (e) {
        var _this = this;
        var event = new DragMouseEvent(e);
        var viewItem = this.getItemAround(event.target);
        if (!viewItem || (event.posx === 0 && event.posy === 0 && event.browserEvent.type === EventType.DRAG_LEAVE)) {
            // dragging outside of tree
            if (this.currentDropTarget) {
                // clear previously hovered element feedback
                this.currentDropTargets.forEach(function (i) { return i.dropTarget = false; });
                this.currentDropTargets = [];
                if (this.currentDropPromise) {
                    this.currentDropPromise.cancel();
                    this.currentDropPromise = null;
                }
            }
            this.cancelDragAndDropScrollInterval();
            this.currentDropTarget = null;
            this.currentDropElement = null;
            this.dragAndDropMouseY = null;
            return false;
        }
        // dragging inside the tree
        this.setupDragAndDropScrollInterval();
        this.dragAndDropMouseY = event.posy;
        if (!this.currentDragAndDropData) {
            // just started dragging
            if (TreeView.currentExternalDragAndDropData) {
                this.currentDragAndDropData = TreeView.currentExternalDragAndDropData;
            }
            else {
                if (!event.dataTransfer.types) {
                    return false;
                }
                this.currentDragAndDropData = new DesktopDragAndDropData();
            }
        }
        this.currentDragAndDropData.update(event);
        var element;
        var item = viewItem.model;
        var reaction;
        // check the bubble up behavior
        do {
            element = item ? item.getElement() : this.model.getInput();
            reaction = this.context.dnd.onDragOver(this.context.tree, this.currentDragAndDropData, element, event);
            if (!reaction || reaction.bubble !== DragOverBubble.BUBBLE_UP) {
                break;
            }
            item = item && item.parent;
        } while (item);
        if (!item) {
            this.currentDropElement = null;
            return false;
        }
        var canDrop = reaction && reaction.accept;
        if (canDrop) {
            this.currentDropElement = item.getElement();
            event.preventDefault();
            event.dataTransfer.dropEffect = reaction.effect === DragOverEffect.COPY ? 'copy' : 'move';
        }
        else {
            this.currentDropElement = null;
        }
        // item is the model item where drop() should be called
        // can be null
        var currentDropTarget = item.id === this.inputItem.id ? this.inputItem : this.items[item.id];
        if (this.shouldInvalidateDropReaction || this.currentDropTarget !== currentDropTarget || !reactionEquals(this.currentDropElementReaction, reaction)) {
            this.shouldInvalidateDropReaction = false;
            if (this.currentDropTarget) {
                this.currentDropTargets.forEach(function (i) { return i.dropTarget = false; });
                this.currentDropTargets = [];
                if (this.currentDropPromise) {
                    this.currentDropPromise.cancel();
                    this.currentDropPromise = null;
                }
            }
            this.currentDropTarget = currentDropTarget;
            this.currentDropElementReaction = reaction;
            if (canDrop) {
                // setup hover feedback for drop target
                if (this.currentDropTarget) {
                    this.currentDropTarget.dropTarget = true;
                    this.currentDropTargets.push(this.currentDropTarget);
                }
                if (reaction.bubble === DragOverBubble.BUBBLE_DOWN) {
                    var nav = item.getNavigator();
                    var child;
                    while (child = nav.next()) {
                        viewItem = this.items[child.id];
                        if (viewItem) {
                            viewItem.dropTarget = true;
                            this.currentDropTargets.push(viewItem);
                        }
                    }
                }
                if (reaction.autoExpand) {
                    this.currentDropPromise = TPromise.timeout(500)
                        .then(function () { return _this.context.tree.expand(_this.currentDropElement); })
                        .then(function () { return _this.shouldInvalidateDropReaction = true; });
                }
            }
        }
        return true;
    };
    TreeView.prototype.onDrop = function (e) {
        if (this.currentDropElement) {
            var event = new DragMouseEvent(e);
            event.preventDefault();
            this.currentDragAndDropData.update(event);
            this.context.dnd.drop(this.context.tree, this.currentDragAndDropData, this.currentDropElement, event);
            this.onDragEnd(e);
        }
        this.cancelDragAndDropScrollInterval();
    };
    TreeView.prototype.onDragEnd = function (e) {
        if (this.currentDropTarget) {
            this.currentDropTargets.forEach(function (i) { return i.dropTarget = false; });
            this.currentDropTargets = [];
        }
        if (this.currentDropPromise) {
            this.currentDropPromise.cancel();
            this.currentDropPromise = null;
        }
        this.cancelDragAndDropScrollInterval();
        this.currentDragAndDropData = null;
        TreeView.currentExternalDragAndDropData = null;
        this.currentDropElement = null;
        this.currentDropTarget = null;
        this.dragAndDropMouseY = null;
    };
    TreeView.prototype.onFocus = function () {
        if (!this.context.options.alwaysFocused) {
            addClass(this.domNode, 'focused');
        }
        this._onDOMFocus.fire();
    };
    TreeView.prototype.onBlur = function () {
        if (!this.context.options.alwaysFocused) {
            removeClass(this.domNode, 'focused');
        }
        this.domNode.removeAttribute('aria-activedescendant'); // ARIA
        this._onDOMBlur.fire();
    };
    // MS specific DOM Events
    TreeView.prototype.onMsPointerDown = function (event) {
        if (!this.msGesture) {
            return;
        }
        // Circumvent IE11 breaking change in e.pointerType & TypeScript's stale definitions
        var pointerType = event.pointerType;
        if (pointerType === (event.MSPOINTER_TYPE_MOUSE || 'mouse')) {
            this.lastPointerType = 'mouse';
            return;
        }
        else if (pointerType === (event.MSPOINTER_TYPE_TOUCH || 'touch')) {
            this.lastPointerType = 'touch';
        }
        else {
            return;
        }
        event.stopPropagation();
        event.preventDefault();
        this.msGesture.addPointer(event.pointerId);
    };
    TreeView.prototype.onThrottledMsGestureChange = function (event) {
        this.scrollTop -= event.translationY;
    };
    TreeView.prototype.onMsGestureTap = function (event) {
        event.initialTarget = document.elementFromPoint(event.clientX, event.clientY);
        this.onTap(event);
    };
    // DOM changes
    TreeView.prototype.insertItemInDOM = function (item) {
        var elementAfter = null;
        var itemAfter = this.itemAfter(item);
        if (itemAfter && itemAfter.element) {
            elementAfter = itemAfter.element;
        }
        item.insertInDOM(this.rowsContainer, elementAfter);
    };
    TreeView.prototype.removeItemFromDOM = function (item) {
        if (!item) {
            return;
        }
        item.removeFromDOM();
    };
    // Helpers
    TreeView.prototype.shouldBeRendered = function (item) {
        return item.top < this.lastRenderTop + this.lastRenderHeight && item.top + item.height > this.lastRenderTop;
    };
    TreeView.prototype.getItemAround = function (element) {
        var candidate = this.inputItem;
        do {
            if (element[TreeView.BINDING]) {
                candidate = element[TreeView.BINDING];
            }
            if (element === this.wrapper || element === this.domNode) {
                return candidate;
            }
            if (element === document.body) {
                return null;
            }
        } while (element = element.parentElement);
        return undefined;
    };
    // Cleanup
    TreeView.prototype.releaseModel = function () {
        if (this.model) {
            this.modelListeners = dispose(this.modelListeners);
            this.model = null;
        }
    };
    TreeView.prototype.dispose = function () {
        var _this = this;
        // TODO@joao: improve
        this.scrollableElement.dispose();
        this.releaseModel();
        this.modelListeners = null;
        this.viewListeners = dispose(this.viewListeners);
        this._onDOMFocus.dispose();
        this._onDOMBlur.dispose();
        if (this.domNode.parentNode) {
            this.domNode.parentNode.removeChild(this.domNode);
        }
        this.domNode = null;
        if (this.items) {
            Object.keys(this.items).forEach(function (key) { return _this.items[key].removeFromDOM(); });
            this.items = null;
        }
        if (this.context.cache) {
            this.context.cache.dispose();
            this.context.cache = null;
        }
        _super.prototype.dispose.call(this);
    };
    TreeView.BINDING = 'monaco-tree-row';
    TreeView.LOADING_DECORATION_DELAY = 800;
    TreeView.counter = 0;
    TreeView.currentExternalDragAndDropData = null;
    return TreeView;
}(HeightMap));

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var TreeContext = /** @class */ (function () {
    function TreeContext(tree, configuration, options) {
        if (options === void 0) { options = {}; }
        this.tree = tree;
        this.configuration = configuration;
        this.options = options;
        if (!configuration.dataSource) {
            throw new Error('You must provide a Data Source to the tree.');
        }
        this.dataSource = configuration.dataSource;
        this.renderer = configuration.renderer;
        this.controller = configuration.controller || new DefaultController({ clickBehavior: ClickBehavior.ON_MOUSE_UP, keyboardSupport: typeof options.keyboardSupport !== 'boolean' || options.keyboardSupport });
        this.dnd = configuration.dnd || new DefaultDragAndDrop();
        this.filter = configuration.filter || new DefaultFilter();
        this.sorter = configuration.sorter || null;
        this.accessibilityProvider = configuration.accessibilityProvider || new DefaultAccessibilityProvider();
        this.styler = configuration.styler || null;
    }
    return TreeContext;
}());
var defaultStyles$2 = {
    listFocusBackground: Color.fromHex('#073655'),
    listActiveSelectionBackground: Color.fromHex('#0E639C'),
    listActiveSelectionForeground: Color.fromHex('#FFFFFF'),
    listFocusAndSelectionBackground: Color.fromHex('#094771'),
    listFocusAndSelectionForeground: Color.fromHex('#FFFFFF'),
    listInactiveSelectionBackground: Color.fromHex('#3F3F46'),
    listHoverBackground: Color.fromHex('#2A2D2E'),
    listDropBackground: Color.fromHex('#383B3D')
};
var Tree = /** @class */ (function () {
    function Tree(container, configuration, options) {
        if (options === void 0) { options = {}; }
        this._onDidChangeFocus = new Relay();
        this.onDidChangeFocus = this._onDidChangeFocus.event;
        this._onDidChangeSelection = new Relay();
        this.onDidChangeSelection = this._onDidChangeSelection.event;
        this._onHighlightChange = new Relay();
        this.onDidChangeHighlight = this._onHighlightChange.event;
        this._onDidExpandItem = new Relay();
        this.onDidExpandItem = this._onDidExpandItem.event;
        this._onDidCollapseItem = new Relay();
        this.onDidCollapseItem = this._onDidCollapseItem.event;
        this._onDispose = new Emitter();
        this.onDidDispose = this._onDispose.event;
        this.container = container;
        mixin(options, defaultStyles$2, false);
        options.twistiePixels = typeof options.twistiePixels === 'number' ? options.twistiePixels : 32;
        options.showTwistie = options.showTwistie === false ? false : true;
        options.indentPixels = typeof options.indentPixels === 'number' ? options.indentPixels : 12;
        options.alwaysFocused = options.alwaysFocused === true ? true : false;
        options.useShadows = options.useShadows === false ? false : true;
        options.paddingOnRow = options.paddingOnRow === false ? false : true;
        this.context = new TreeContext(this, configuration, options);
        this.model = new TreeModel(this.context);
        this.view = new TreeView(this.context, this.container);
        this.view.setModel(this.model);
        this._onDidChangeFocus.input = this.model.onDidFocus;
        this._onDidChangeSelection.input = this.model.onDidSelect;
        this._onHighlightChange.input = this.model.onDidHighlight;
        this._onDidExpandItem.input = this.model.onDidExpandItem;
        this._onDidCollapseItem.input = this.model.onDidCollapseItem;
    }
    Tree.prototype.style = function (styles) {
        this.view.applyStyles(styles);
    };
    Object.defineProperty(Tree.prototype, "onDidFocus", {
        get: function () {
            return this.view && this.view.onDOMFocus;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Tree.prototype, "onDidBlur", {
        get: function () {
            return this.view && this.view.onDOMBlur;
        },
        enumerable: true,
        configurable: true
    });
    Tree.prototype.getHTMLElement = function () {
        return this.view.getHTMLElement();
    };
    Tree.prototype.layout = function (height, width) {
        this.view.layout(height, width);
    };
    Tree.prototype.domFocus = function () {
        this.view.focus();
    };
    Tree.prototype.isDOMFocused = function () {
        return this.view.isFocused();
    };
    Tree.prototype.domBlur = function () {
        this.view.blur();
    };
    Tree.prototype.onVisible = function () {
        this.view.onVisible();
    };
    Tree.prototype.onHidden = function () {
        this.view.onHidden();
    };
    Tree.prototype.setInput = function (element) {
        return this.model.setInput(element);
    };
    Tree.prototype.getInput = function () {
        return this.model.getInput();
    };
    Tree.prototype.refresh = function (element, recursive) {
        if (element === void 0) { element = null; }
        if (recursive === void 0) { recursive = true; }
        return this.model.refresh(element, recursive);
    };
    Tree.prototype.updateWidth = function (element) {
        var item = this.model.getItem(element);
        return this.view.updateWidth(item);
    };
    Tree.prototype.expand = function (element) {
        return this.model.expand(element);
    };
    Tree.prototype.expandAll = function (elements) {
        return this.model.expandAll(elements);
    };
    Tree.prototype.collapse = function (element, recursive) {
        if (recursive === void 0) { recursive = false; }
        return this.model.collapse(element, recursive);
    };
    Tree.prototype.collapseAll = function (elements, recursive) {
        if (elements === void 0) { elements = null; }
        if (recursive === void 0) { recursive = false; }
        return this.model.collapseAll(elements, recursive);
    };
    Tree.prototype.collapseDeepestExpandedLevel = function () {
        return this.model.collapseDeepestExpandedLevel();
    };
    Tree.prototype.toggleExpansion = function (element, recursive) {
        if (recursive === void 0) { recursive = false; }
        return this.model.toggleExpansion(element, recursive);
    };
    Tree.prototype.toggleExpansionAll = function (elements) {
        return this.model.toggleExpansionAll(elements);
    };
    Tree.prototype.isExpanded = function (element) {
        return this.model.isExpanded(element);
    };
    Tree.prototype.getExpandedElements = function () {
        return this.model.getExpandedElements();
    };
    Tree.prototype.reveal = function (element, relativeTop) {
        if (relativeTop === void 0) { relativeTop = null; }
        return this.model.reveal(element, relativeTop);
    };
    Tree.prototype.getRelativeTop = function (element) {
        var item = this.model.getItem(element);
        return this.view.getRelativeTop(item);
    };
    Tree.prototype.getScrollPosition = function () {
        return this.view.getScrollPosition();
    };
    Tree.prototype.setScrollPosition = function (pos) {
        this.view.setScrollPosition(pos);
    };
    Tree.prototype.getContentHeight = function () {
        return this.view.getContentHeight();
    };
    Tree.prototype.setHighlight = function (element, eventPayload) {
        this.model.setHighlight(element, eventPayload);
    };
    Tree.prototype.getHighlight = function () {
        return this.model.getHighlight();
    };
    Tree.prototype.isHighlighted = function (element) {
        return this.model.isFocused(element);
    };
    Tree.prototype.clearHighlight = function (eventPayload) {
        this.model.setHighlight(null, eventPayload);
    };
    Tree.prototype.select = function (element, eventPayload) {
        this.model.select(element, eventPayload);
    };
    Tree.prototype.selectRange = function (fromElement, toElement, eventPayload) {
        this.model.selectRange(fromElement, toElement, eventPayload);
    };
    Tree.prototype.deselectRange = function (fromElement, toElement, eventPayload) {
        this.model.deselectRange(fromElement, toElement, eventPayload);
    };
    Tree.prototype.selectAll = function (elements, eventPayload) {
        this.model.selectAll(elements, eventPayload);
    };
    Tree.prototype.deselect = function (element, eventPayload) {
        this.model.deselect(element, eventPayload);
    };
    Tree.prototype.deselectAll = function (elements, eventPayload) {
        this.model.deselectAll(elements, eventPayload);
    };
    Tree.prototype.setSelection = function (elements, eventPayload) {
        this.model.setSelection(elements, eventPayload);
    };
    Tree.prototype.toggleSelection = function (element, eventPayload) {
        this.model.toggleSelection(element, eventPayload);
    };
    Tree.prototype.isSelected = function (element) {
        return this.model.isSelected(element);
    };
    Tree.prototype.getSelection = function () {
        return this.model.getSelection();
    };
    Tree.prototype.clearSelection = function (eventPayload) {
        this.model.setSelection([], eventPayload);
    };
    Tree.prototype.selectNext = function (count, clearSelection, eventPayload) {
        this.model.selectNext(count, clearSelection, eventPayload);
    };
    Tree.prototype.selectPrevious = function (count, clearSelection, eventPayload) {
        this.model.selectPrevious(count, clearSelection, eventPayload);
    };
    Tree.prototype.selectParent = function (clearSelection, eventPayload) {
        this.model.selectParent(clearSelection, eventPayload);
    };
    Tree.prototype.setFocus = function (element, eventPayload) {
        this.model.setFocus(element, eventPayload);
    };
    Tree.prototype.isFocused = function (element) {
        return this.model.isFocused(element);
    };
    Tree.prototype.getFocus = function () {
        return this.model.getFocus();
    };
    Tree.prototype.focusNext = function (count, eventPayload) {
        this.model.focusNext(count, eventPayload);
    };
    Tree.prototype.focusPrevious = function (count, eventPayload) {
        this.model.focusPrevious(count, eventPayload);
    };
    Tree.prototype.focusParent = function (eventPayload) {
        this.model.focusParent(eventPayload);
    };
    Tree.prototype.focusFirstChild = function (eventPayload) {
        this.model.focusFirstChild(eventPayload);
    };
    Tree.prototype.focusFirst = function (eventPayload, from) {
        this.model.focusFirst(eventPayload, from);
    };
    Tree.prototype.focusNth = function (index, eventPayload) {
        this.model.focusNth(index, eventPayload);
    };
    Tree.prototype.focusLast = function (eventPayload, from) {
        this.model.focusLast(eventPayload, from);
    };
    Tree.prototype.focusNextPage = function (eventPayload) {
        this.view.focusNextPage(eventPayload);
    };
    Tree.prototype.focusPreviousPage = function (eventPayload) {
        this.view.focusPreviousPage(eventPayload);
    };
    Tree.prototype.clearFocus = function (eventPayload) {
        this.model.setFocus(null, eventPayload);
    };
    Tree.prototype.addTraits = function (trait, elements) {
        this.model.addTraits(trait, elements);
    };
    Tree.prototype.removeTraits = function (trait, elements) {
        this.model.removeTraits(trait, elements);
    };
    Tree.prototype.toggleTrait = function (trait, element) {
        this.model.hasTrait(trait, element) ? this.model.removeTraits(trait, [element])
            : this.model.addTraits(trait, [element]);
    };
    Tree.prototype.hasTrait = function (trait, element) {
        return this.model.hasTrait(trait, element);
    };
    Tree.prototype.getNavigator = function (fromElement, subTreeOnly) {
        return new MappedNavigator(this.model.getNavigator(fromElement, subTreeOnly), function (i) { return i && i.getElement(); });
    };
    Tree.prototype.dispose = function () {
        this._onDispose.fire();
        if (this.model !== null) {
            this.model.dispose();
            this.model = null;
        }
        if (this.view !== null) {
            this.view.dispose();
            this.view = null;
        }
        this._onDidChangeFocus.dispose();
        this._onDidChangeSelection.dispose();
        this._onHighlightChange.dispose();
        this._onDidExpandItem.dispose();
        this._onDidCollapseItem.dispose();
        this._onDispose.dispose();
    };
    return Tree;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
function computeStyles(theme, styleMap) {
    var styles = Object.create(null);
    for (var key in styleMap) {
        var value = styleMap[key];
        if (typeof value === 'string') {
            styles[key] = theme.getColor(value);
        }
        else if (typeof value === 'function') {
            styles[key] = value(theme);
        }
    }
    return styles;
}
function attachStyler(themeService, styleMap, widgetOrCallback) {
    function applyStyles(theme) {
        var styles = computeStyles(themeService.getTheme(), styleMap);
        if (typeof widgetOrCallback === 'function') {
            widgetOrCallback(styles);
        }
        else {
            widgetOrCallback.style(styles);
        }
    }
    applyStyles(themeService.getTheme());
    return themeService.onThemeChange(applyStyles);
}
function attachBadgeStyler(widget, themeService, style) {
    return attachStyler(themeService, {
        badgeBackground: (style && style.badgeBackground) || badgeBackground,
        badgeForeground: (style && style.badgeForeground) || badgeForeground,
        badgeBorder: contrastBorder
    }, widget);
}
function attachQuickOpenStyler(widget, themeService, style) {
    return attachStyler(themeService, {
        foreground: (style && style.foreground) || foreground,
        background: (style && style.background) || editorBackground,
        borderColor: style && style.borderColor || contrastBorder,
        widgetShadow: style && style.widgetShadow || widgetShadow,
        progressBarBackground: style && style.progressBarBackground || progressBarBackground,
        pickerGroupForeground: style && style.pickerGroupForeground || pickerGroupForeground,
        pickerGroupBorder: style && style.pickerGroupBorder || pickerGroupBorder,
        inputBackground: (style && style.inputBackground) || inputBackground,
        inputForeground: (style && style.inputForeground) || inputForeground,
        inputBorder: (style && style.inputBorder) || inputBorder,
        inputValidationInfoBorder: (style && style.inputValidationInfoBorder) || inputValidationInfoBorder,
        inputValidationInfoBackground: (style && style.inputValidationInfoBackground) || inputValidationInfoBackground,
        inputValidationWarningBorder: (style && style.inputValidationWarningBorder) || inputValidationWarningBorder,
        inputValidationWarningBackground: (style && style.inputValidationWarningBackground) || inputValidationWarningBackground,
        inputValidationErrorBorder: (style && style.inputValidationErrorBorder) || inputValidationErrorBorder,
        inputValidationErrorBackground: (style && style.inputValidationErrorBackground) || inputValidationErrorBackground,
        listFocusBackground: (style && style.listFocusBackground) || listFocusBackground,
        listFocusForeground: (style && style.listFocusForeground) || listFocusForeground,
        listActiveSelectionBackground: (style && style.listActiveSelectionBackground) || lighten(listActiveSelectionBackground, 0.1),
        listActiveSelectionForeground: (style && style.listActiveSelectionForeground) || listActiveSelectionForeground,
        listFocusAndSelectionBackground: style && style.listFocusAndSelectionBackground || listActiveSelectionBackground,
        listFocusAndSelectionForeground: (style && style.listFocusAndSelectionForeground) || listActiveSelectionForeground,
        listInactiveSelectionBackground: (style && style.listInactiveSelectionBackground) || listInactiveSelectionBackground,
        listInactiveSelectionForeground: (style && style.listInactiveSelectionForeground) || listInactiveSelectionForeground,
        listInactiveFocusBackground: (style && style.listInactiveFocusBackground) || listInactiveFocusBackground,
        listHoverBackground: (style && style.listHoverBackground) || listHoverBackground,
        listHoverForeground: (style && style.listHoverForeground) || listHoverForeground,
        listDropBackground: (style && style.listDropBackground) || listDropBackground,
        listFocusOutline: (style && style.listFocusOutline) || activeContrastBorder,
        listSelectionOutline: (style && style.listSelectionOutline) || activeContrastBorder,
        listHoverOutline: (style && style.listHoverOutline) || activeContrastBorder
    }, widget);
}
function attachListStyler(widget, themeService, overrides) {
    return attachStyler(themeService, mixin(overrides || Object.create(null), defaultListStyles, false), widget);
}
var defaultListStyles = {
    listFocusBackground: listFocusBackground,
    listFocusForeground: listFocusForeground,
    listActiveSelectionBackground: lighten(listActiveSelectionBackground, 0.1),
    listActiveSelectionForeground: listActiveSelectionForeground,
    listFocusAndSelectionBackground: listActiveSelectionBackground,
    listFocusAndSelectionForeground: listActiveSelectionForeground,
    listInactiveSelectionBackground: listInactiveSelectionBackground,
    listInactiveSelectionForeground: listInactiveSelectionForeground,
    listInactiveFocusBackground: listInactiveFocusBackground,
    listHoverBackground: listHoverBackground,
    listHoverForeground: listHoverForeground,
    listDropBackground: listDropBackground,
    listFocusOutline: activeContrastBorder,
    listSelectionOutline: activeContrastBorder,
    listHoverOutline: activeContrastBorder
};

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var InputFocusedContextKey = 'inputFocus';
var InputFocusedContext = new RawContextKey(InputFocusedContextKey, false);

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$1m = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign$3 = (undefined && undefined.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
var __decorate$e = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$b = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var IListService = createDecorator('listService');
var ListService = /** @class */ (function () {
    function ListService(contextKeyService) {
        this.lists = [];
        this._lastFocusedWidget = undefined;
    }
    Object.defineProperty(ListService.prototype, "lastFocusedList", {
        get: function () {
            return this._lastFocusedWidget;
        },
        enumerable: true,
        configurable: true
    });
    ListService.prototype.register = function (widget, extraContextKeys) {
        var _this = this;
        if (this.lists.some(function (l) { return l.widget === widget; })) {
            throw new Error('Cannot register the same widget multiple times');
        }
        // Keep in our lists list
        var registeredList = { widget: widget, extraContextKeys: extraContextKeys };
        this.lists.push(registeredList);
        // Check for currently being focused
        if (widget.isDOMFocused()) {
            this._lastFocusedWidget = widget;
        }
        var result = combinedDisposable([
            widget.onDidFocus(function () { return _this._lastFocusedWidget = widget; }),
            toDisposable(function () { return _this.lists.splice(_this.lists.indexOf(registeredList), 1); }),
            widget.onDidDispose(function () {
                _this.lists = _this.lists.filter(function (l) { return l !== registeredList; });
                if (_this._lastFocusedWidget === widget) {
                    _this._lastFocusedWidget = undefined;
                }
            })
        ]);
        return result;
    };
    ListService = __decorate$e([
        __param$b(0, IContextKeyService)
    ], ListService);
    return ListService;
}());
var RawWorkbenchListFocusContextKey = new RawContextKey('listFocus', true);
var WorkbenchListSupportsMultiSelectContextKey = new RawContextKey('listSupportsMultiselect', true);
var WorkbenchListFocusContextKey = ContextKeyExpr.and(RawWorkbenchListFocusContextKey, ContextKeyExpr.not(InputFocusedContextKey));
var WorkbenchListDoubleSelection = new RawContextKey('listDoubleSelection', false);
var WorkbenchListMultiSelection = new RawContextKey('listMultiSelection', false);
function createScopedContextKeyService(contextKeyService, widget) {
    var result = contextKeyService.createScoped(widget.getHTMLElement());
    if (widget instanceof List || widget instanceof PagedList) {
        WorkbenchListSupportsMultiSelectContextKey.bindTo(result);
    }
    RawWorkbenchListFocusContextKey.bindTo(result);
    return result;
}
var multiSelectModifierSettingKey = 'workbench.list.multiSelectModifier';
var openModeSettingKey = 'workbench.list.openMode';
var horizontalScrollingKey = 'workbench.tree.horizontalScrolling';
function useAltAsMultipleSelectionModifier(configurationService) {
    return configurationService.getValue(multiSelectModifierSettingKey) === 'alt';
}
function useSingleClickToOpen(configurationService) {
    return configurationService.getValue(openModeSettingKey) !== 'doubleClick';
}
var MultipleSelectionController = /** @class */ (function () {
    function MultipleSelectionController(configurationService) {
        this.configurationService = configurationService;
    }
    MultipleSelectionController.prototype.isSelectionSingleChangeEvent = function (event) {
        if (useAltAsMultipleSelectionModifier(this.configurationService)) {
            return event.browserEvent.altKey;
        }
        return isSelectionSingleChangeEvent(event);
    };
    MultipleSelectionController.prototype.isSelectionRangeChangeEvent = function (event) {
        return isSelectionRangeChangeEvent(event);
    };
    return MultipleSelectionController;
}());
var WorkbenchOpenController = /** @class */ (function () {
    function WorkbenchOpenController(configurationService, existingOpenController) {
        this.configurationService = configurationService;
        this.existingOpenController = existingOpenController;
    }
    WorkbenchOpenController.prototype.shouldOpen = function (event) {
        if (event instanceof MouseEvent) {
            var isDoubleClick = event.detail === 2;
            if (!useSingleClickToOpen(this.configurationService) && !isDoubleClick) {
                return false;
            }
            if (event.button === 0 /* left mouse button */ || event.button === 1 /* middle mouse button */) {
                return this.existingOpenController ? this.existingOpenController.shouldOpen(event) : true;
            }
            return false;
        }
        return this.existingOpenController ? this.existingOpenController.shouldOpen(event) : true;
    };
    return WorkbenchOpenController;
}());
function handleListControllers(options, configurationService) {
    if (options.multipleSelectionSupport !== false && !options.multipleSelectionController) {
        options.multipleSelectionController = new MultipleSelectionController(configurationService);
    }
    options.openController = new WorkbenchOpenController(configurationService, options.openController);
    return options;
}
var sharedListStyleSheet;
function getSharedListStyleSheet() {
    if (!sharedListStyleSheet) {
        sharedListStyleSheet = createStyleSheet();
    }
    return sharedListStyleSheet;
}
var sharedTreeStyleSheet;
function getSharedTreeStyleSheet() {
    if (!sharedTreeStyleSheet) {
        sharedTreeStyleSheet = createStyleSheet();
    }
    return sharedTreeStyleSheet;
}
function handleTreeController(configuration, instantiationService) {
    if (!configuration.controller) {
        configuration.controller = instantiationService.createInstance(WorkbenchTreeController, {});
    }
    if (!configuration.styler) {
        configuration.styler = new DefaultTreestyler(getSharedTreeStyleSheet());
    }
    return configuration;
}
var WorkbenchList = /** @class */ (function (_super) {
    __extends$1m(WorkbenchList, _super);
    function WorkbenchList(container, delegate, renderers, options, contextKeyService, listService, themeService, configurationService) {
        var _this = _super.call(this, container, delegate, renderers, __assign$3({ keyboardSupport: false, selectOnMouseDown: true, styleController: new DefaultStyleController(getSharedListStyleSheet()) }, computeStyles(themeService.getTheme(), defaultListStyles), handleListControllers(options, configurationService))) || this;
        _this.configurationService = configurationService;
        _this.contextKeyService = createScopedContextKeyService(contextKeyService, _this);
        _this.listDoubleSelection = WorkbenchListDoubleSelection.bindTo(_this.contextKeyService);
        _this.listMultiSelection = WorkbenchListMultiSelection.bindTo(_this.contextKeyService);
        _this._useAltAsMultipleSelectionModifier = useAltAsMultipleSelectionModifier(configurationService);
        _this.disposables.push(combinedDisposable([
            _this.contextKeyService,
            listService.register(_this),
            attachListStyler(_this, themeService),
            _this.onSelectionChange(function () {
                var selection = _this.getSelection();
                _this.listMultiSelection.set(selection.length > 1);
                _this.listDoubleSelection.set(selection.length === 2);
            })
        ]));
        _this.registerListeners();
        return _this;
    }
    WorkbenchList.prototype.registerListeners = function () {
        var _this = this;
        this.disposables.push(this.configurationService.onDidChangeConfiguration(function (e) {
            if (e.affectsConfiguration(multiSelectModifierSettingKey)) {
                _this._useAltAsMultipleSelectionModifier = useAltAsMultipleSelectionModifier(_this.configurationService);
            }
        }));
    };
    Object.defineProperty(WorkbenchList.prototype, "useAltAsMultipleSelectionModifier", {
        get: function () {
            return this._useAltAsMultipleSelectionModifier;
        },
        enumerable: true,
        configurable: true
    });
    WorkbenchList = __decorate$e([
        __param$b(4, IContextKeyService),
        __param$b(5, IListService),
        __param$b(6, IThemeService),
        __param$b(7, IConfigurationService)
    ], WorkbenchList);
    return WorkbenchList;
}(List));
var WorkbenchPagedList = /** @class */ (function (_super) {
    __extends$1m(WorkbenchPagedList, _super);
    function WorkbenchPagedList(container, delegate, renderers, options, contextKeyService, listService, themeService, configurationService) {
        var _this = _super.call(this, container, delegate, renderers, __assign$3({ keyboardSupport: false, selectOnMouseDown: true, styleController: new DefaultStyleController(getSharedListStyleSheet()) }, computeStyles(themeService.getTheme(), defaultListStyles), handleListControllers(options, configurationService))) || this;
        _this.configurationService = configurationService;
        _this.disposables = [];
        _this.contextKeyService = createScopedContextKeyService(contextKeyService, _this);
        _this._useAltAsMultipleSelectionModifier = useAltAsMultipleSelectionModifier(configurationService);
        _this.disposables.push(combinedDisposable([
            _this.contextKeyService,
            listService.register(_this),
            attachListStyler(_this, themeService)
        ]));
        _this.registerListeners();
        return _this;
    }
    WorkbenchPagedList.prototype.registerListeners = function () {
        var _this = this;
        this.disposables.push(this.configurationService.onDidChangeConfiguration(function (e) {
            if (e.affectsConfiguration(multiSelectModifierSettingKey)) {
                _this._useAltAsMultipleSelectionModifier = useAltAsMultipleSelectionModifier(_this.configurationService);
            }
        }));
    };
    Object.defineProperty(WorkbenchPagedList.prototype, "useAltAsMultipleSelectionModifier", {
        get: function () {
            return this._useAltAsMultipleSelectionModifier;
        },
        enumerable: true,
        configurable: true
    });
    WorkbenchPagedList.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
        this.disposables = dispose(this.disposables);
    };
    WorkbenchPagedList = __decorate$e([
        __param$b(4, IContextKeyService),
        __param$b(5, IListService),
        __param$b(6, IThemeService),
        __param$b(7, IConfigurationService)
    ], WorkbenchPagedList);
    return WorkbenchPagedList;
}(PagedList));
var WorkbenchTree = /** @class */ (function (_super) {
    __extends$1m(WorkbenchTree, _super);
    function WorkbenchTree(container, configuration, options, contextKeyService, listService, themeService, instantiationService, configurationService) {
        var _this = this;
        var config = handleTreeController(configuration, instantiationService);
        var horizontalScrollMode = configurationService.getValue(horizontalScrollingKey) ? ScrollbarVisibility.Auto : ScrollbarVisibility.Hidden;
        var opts = __assign$3({ horizontalScrollMode: horizontalScrollMode, keyboardSupport: false }, computeStyles(themeService.getTheme(), defaultListStyles), options);
        _this = _super.call(this, container, config, opts) || this;
        _this.disposables = [];
        _this.contextKeyService = createScopedContextKeyService(contextKeyService, _this);
        _this.listDoubleSelection = WorkbenchListDoubleSelection.bindTo(_this.contextKeyService);
        _this.listMultiSelection = WorkbenchListMultiSelection.bindTo(_this.contextKeyService);
        _this._openOnSingleClick = useSingleClickToOpen(configurationService);
        _this._useAltAsMultipleSelectionModifier = useAltAsMultipleSelectionModifier(configurationService);
        _this.disposables.push(_this.contextKeyService, listService.register(_this), attachListStyler(_this, themeService));
        _this.disposables.push(_this.onDidChangeSelection(function () {
            var selection = _this.getSelection();
            _this.listDoubleSelection.set(selection && selection.length === 2);
            _this.listMultiSelection.set(selection && selection.length > 1);
        }));
        _this.disposables.push(configurationService.onDidChangeConfiguration(function (e) {
            if (e.affectsConfiguration(openModeSettingKey)) {
                _this._openOnSingleClick = useSingleClickToOpen(configurationService);
            }
            if (e.affectsConfiguration(multiSelectModifierSettingKey)) {
                _this._useAltAsMultipleSelectionModifier = useAltAsMultipleSelectionModifier(configurationService);
            }
        }));
        return _this;
    }
    Object.defineProperty(WorkbenchTree.prototype, "openOnSingleClick", {
        get: function () {
            return this._openOnSingleClick;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WorkbenchTree.prototype, "useAltAsMultipleSelectionModifier", {
        get: function () {
            return this._useAltAsMultipleSelectionModifier;
        },
        enumerable: true,
        configurable: true
    });
    WorkbenchTree.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
        this.disposables = dispose(this.disposables);
    };
    WorkbenchTree = __decorate$e([
        __param$b(3, IContextKeyService),
        __param$b(4, IListService),
        __param$b(5, IThemeService),
        __param$b(6, IInstantiationService),
        __param$b(7, IConfigurationService)
    ], WorkbenchTree);
    return WorkbenchTree;
}(Tree));
function massageControllerOptions(options) {
    if (typeof options.keyboardSupport !== 'boolean') {
        options.keyboardSupport = false;
    }
    if (typeof options.clickBehavior !== 'number') {
        options.clickBehavior = ClickBehavior.ON_MOUSE_DOWN;
    }
    return options;
}
var WorkbenchTreeController = /** @class */ (function (_super) {
    __extends$1m(WorkbenchTreeController, _super);
    function WorkbenchTreeController(options, configurationService) {
        var _this = _super.call(this, massageControllerOptions(options)) || this;
        _this.configurationService = configurationService;
        _this.disposables = [];
        // if the open mode is not set, we configure it based on settings
        if (isUndefinedOrNull(options.openMode)) {
            _this.setOpenMode(_this.getOpenModeSetting());
            _this.registerListeners();
        }
        return _this;
    }
    WorkbenchTreeController.prototype.registerListeners = function () {
        var _this = this;
        this.disposables.push(this.configurationService.onDidChangeConfiguration(function (e) {
            if (e.affectsConfiguration(openModeSettingKey)) {
                _this.setOpenMode(_this.getOpenModeSetting());
            }
        }));
    };
    WorkbenchTreeController.prototype.getOpenModeSetting = function () {
        return useSingleClickToOpen(this.configurationService) ? OpenMode.SINGLE_CLICK : OpenMode.DOUBLE_CLICK;
    };
    WorkbenchTreeController.prototype.dispose = function () {
        this.disposables = dispose(this.disposables);
    };
    WorkbenchTreeController = __decorate$e([
        __param$b(1, IConfigurationService)
    ], WorkbenchTreeController);
    return WorkbenchTreeController;
}(DefaultController));
var TreeResourceNavigator = /** @class */ (function (_super) {
    __extends$1m(TreeResourceNavigator, _super);
    function TreeResourceNavigator(tree, options) {
        var _this = _super.call(this) || this;
        _this.tree = tree;
        _this.options = options;
        _this._openResource = new Emitter();
        _this.openResource = _this._openResource.event;
        _this.registerListeners();
        return _this;
    }
    TreeResourceNavigator.prototype.registerListeners = function () {
        var _this = this;
        if (this.options && this.options.openOnFocus) {
            this._register(this.tree.onDidChangeFocus(function (e) { return _this.onFocus(e); }));
        }
        this._register(this.tree.onDidChangeSelection(function (e) { return _this.onSelection(e); }));
    };
    TreeResourceNavigator.prototype.onFocus = function (_a) {
        var payload = _a.payload;
        var element = this.tree.getFocus();
        this.tree.setSelection([element], { fromFocus: true });
        var originalEvent = payload && payload.originalEvent;
        var isMouseEvent = payload && payload.origin === 'mouse';
        var isDoubleClick = isMouseEvent && originalEvent && originalEvent.detail === 2;
        var preventOpen = payload && payload.preventOpenOnFocus;
        if (!preventOpen && (!isMouseEvent || this.tree.openOnSingleClick || isDoubleClick)) {
            this._openResource.fire({
                editorOptions: {
                    preserveFocus: true,
                    pinned: false,
                    revealIfVisible: true
                },
                sideBySide: false,
                element: element,
                payload: payload
            });
        }
    };
    TreeResourceNavigator.prototype.onSelection = function (_a) {
        var payload = _a.payload;
        if (payload && payload.fromFocus) {
            return;
        }
        var originalEvent = payload && payload.originalEvent;
        var isMouseEvent = payload && payload.origin === 'mouse';
        var isDoubleClick = isMouseEvent && originalEvent && originalEvent.detail === 2;
        if (!isMouseEvent || this.tree.openOnSingleClick || isDoubleClick) {
            if (isDoubleClick && originalEvent) {
                originalEvent.preventDefault(); // focus moves to editor, we need to prevent default
            }
            var isFromKeyboard = payload && payload.origin === 'keyboard';
            var sideBySide = (originalEvent && (originalEvent.ctrlKey || originalEvent.metaKey || originalEvent.altKey));
            var preserveFocus = !((isFromKeyboard && (!payload || !payload.preserveFocus)) || isDoubleClick || (payload && payload.focusEditor));
            this._openResource.fire({
                editorOptions: {
                    preserveFocus: preserveFocus,
                    pinned: isDoubleClick,
                    revealIfVisible: true
                },
                sideBySide: sideBySide,
                element: this.tree.getSelection()[0],
                payload: payload
            });
        }
    };
    return TreeResourceNavigator;
}(Disposable));
var configurationRegistry$2 = Registry.as(Extensions$1.Configuration);
configurationRegistry$2.registerConfiguration({
    'id': 'workbench',
    'order': 7,
    'title': localize('workbenchConfigurationTitle', "Workbench"),
    'type': 'object',
    'properties': (_a$1 = {},
        _a$1[multiSelectModifierSettingKey] = {
            'type': 'string',
            'enum': ['ctrlCmd', 'alt'],
            'enumDescriptions': [
                localize('multiSelectModifier.ctrlCmd', "Maps to `Control` on Windows and Linux and to `Command` on macOS."),
                localize('multiSelectModifier.alt', "Maps to `Alt` on Windows and Linux and to `Option` on macOS.")
            ],
            'default': 'ctrlCmd',
            'description': localize({
                key: 'multiSelectModifier',
                comment: [
                    '- `ctrlCmd` refers to a value the setting can take and should not be localized.',
                    '- `Control` and `Command` refer to the modifier keys Ctrl or Cmd on the keyboard and can be localized.'
                ]
            }, "The modifier to be used to add an item in trees and lists to a multi-selection with the mouse (for example in the explorer, open editors and scm view). `ctrlCmd` maps to `Control` on Windows and Linux and to `Command` on macOS. The 'Open to Side' mouse gestures - if supported - will adapt such that they do not conflict with the multiselect modifier.")
        },
        _a$1[openModeSettingKey] = {
            'type': 'string',
            'enum': ['singleClick', 'doubleClick'],
            'enumDescriptions': [
                localize('openMode.singleClick', "Opens items on mouse single click."),
                localize('openMode.doubleClick', "Open items on mouse double click.")
            ],
            'default': 'singleClick',
            'description': localize({
                key: 'openModeModifier',
                comment: ['`singleClick` and `doubleClick` refers to a value the setting can take and should not be localized.']
            }, "Controls how to open items in trees and lists using the mouse (if supported). Set to `singleClick` to open items with a single mouse click and `doubleClick` to only open via mouse double click. For parents with children in trees, this setting will control if a single click expands the parent or a double click. Note that some trees and lists might choose to ignore this setting if it is not applicable. ")
        },
        _a$1[horizontalScrollingKey] = {
            'type': 'boolean',
            'default': false,
            'description': localize('horizontalScrolling setting', "Controls whether trees support horizontal scrolling in the workbench.")
        },
        _a$1)
});
var _a$1;

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$1n = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var StaticServices;
(function (StaticServices) {
    var _serviceCollection = new ServiceCollection();
    var LazyStaticService = /** @class */ (function () {
        function LazyStaticService(serviceId, factory) {
            this._serviceId = serviceId;
            this._factory = factory;
            this._value = null;
        }
        Object.defineProperty(LazyStaticService.prototype, "id", {
            get: function () { return this._serviceId; },
            enumerable: true,
            configurable: true
        });
        LazyStaticService.prototype.get = function (overrides) {
            if (!this._value) {
                if (overrides) {
                    this._value = overrides[this._serviceId.toString()];
                }
                if (!this._value) {
                    this._value = this._factory(overrides);
                }
                if (!this._value) {
                    throw new Error('Service ' + this._serviceId + ' is missing!');
                }
                _serviceCollection.set(this._serviceId, this._value);
            }
            return this._value;
        };
        return LazyStaticService;
    }());
    StaticServices.LazyStaticService = LazyStaticService;
    var _all = [];
    function define(serviceId, factory) {
        var r = new LazyStaticService(serviceId, factory);
        _all.push(r);
        return r;
    }
    function init(overrides) {
        // Create a fresh service collection
        var result = new ServiceCollection();
        // Initialize the service collection with the overrides
        for (var serviceId in overrides) {
            if (overrides.hasOwnProperty(serviceId)) {
                result.set(createDecorator(serviceId), overrides[serviceId]);
            }
        }
        // Make sure the same static services are present in all service collections
        _all.forEach(function (service) { return result.set(service.id, service.get(overrides)); });
        // Ensure the collection gets the correct instantiation service
        var instantiationService = new InstantiationService(result, true);
        result.set(IInstantiationService, instantiationService);
        return [result, instantiationService];
    }
    StaticServices.init = init;
    StaticServices.instantiationService = define(IInstantiationService, function () { return new InstantiationService(_serviceCollection, true); });
    var configurationServiceImpl = new SimpleConfigurationService();
    StaticServices.configurationService = define(IConfigurationService, function () { return configurationServiceImpl; });
    StaticServices.resourceConfigurationService = define(ITextResourceConfigurationService, function () { return new SimpleResourceConfigurationService(configurationServiceImpl); });
    StaticServices.contextService = define(IWorkspaceContextService, function () { return new SimpleWorkspaceContextService(); });
    StaticServices.telemetryService = define(ITelemetryService, function () { return new StandaloneTelemetryService(); });
    StaticServices.dialogService = define(IDialogService, function () { return new SimpleDialogService(); });
    StaticServices.notificationService = define(INotificationService, function () { return new SimpleNotificationService(); });
    StaticServices.markerService = define(IMarkerService, function () { return new MarkerService(); });
    StaticServices.modeService = define(IModeService, function (o) { return new ModeServiceImpl(); });
    StaticServices.modelService = define(IModelService, function (o) { return new ModelServiceImpl(StaticServices.markerService.get(o), StaticServices.configurationService.get(o)); });
    StaticServices.editorWorkerService = define(IEditorWorkerService, function (o) { return new EditorWorkerServiceImpl(StaticServices.modelService.get(o), StaticServices.resourceConfigurationService.get(o)); });
    StaticServices.standaloneThemeService = define(IStandaloneThemeService, function () { return new StandaloneThemeServiceImpl(); });
    StaticServices.codeEditorService = define(ICodeEditorService, function (o) { return new CodeEditorServiceImpl(StaticServices.standaloneThemeService.get(o)); });
    StaticServices.progressService = define(IProgressService, function () { return new SimpleProgressService(); });
    StaticServices.storageService = define(IStorageService, function () { return NullStorageService; });
    StaticServices.logService = define(ILogService, function () { return new NullLogService(); });
})(StaticServices || (StaticServices = {}));
var DynamicStandaloneServices = /** @class */ (function (_super) {
    __extends$1n(DynamicStandaloneServices, _super);
    function DynamicStandaloneServices(domElement, overrides) {
        var _this = _super.call(this) || this;
        var _a = StaticServices.init(overrides), _serviceCollection = _a[0], _instantiationService = _a[1];
        _this._serviceCollection = _serviceCollection;
        _this._instantiationService = _instantiationService;
        var configurationService = _this.get(IConfigurationService);
        var notificationService = _this.get(INotificationService);
        var telemetryService = _this.get(ITelemetryService);
        var ensure = function (serviceId, factory) {
            var value = null;
            if (overrides) {
                value = overrides[serviceId.toString()];
            }
            if (!value) {
                value = factory();
            }
            _this._serviceCollection.set(serviceId, value);
            return value;
        };
        var contextKeyService = ensure(IContextKeyService, function () { return _this._register(new ContextKeyService(configurationService)); });
        ensure(IListService, function () { return new ListService(contextKeyService); });
        var commandService = ensure(ICommandService, function () { return new StandaloneCommandService(_this._instantiationService); });
        ensure(IKeybindingService, function () { return _this._register(new StandaloneKeybindingService(contextKeyService, commandService, telemetryService, notificationService, domElement)); });
        var contextViewService = ensure(IContextViewService, function () { return _this._register(new ContextViewService(domElement, telemetryService, new NullLogService())); });
        ensure(IContextMenuService, function () { return _this._register(new ContextMenuService(domElement, telemetryService, notificationService, contextViewService)); });
        ensure(IMenuService, function () { return new SimpleMenuService(commandService); });
        return _this;
    }
    DynamicStandaloneServices.prototype.get = function (serviceId) {
        var r = this._serviceCollection.get(serviceId);
        if (!r) {
            throw new Error('Missing service ' + serviceId);
        }
        return r;
    };
    DynamicStandaloneServices.prototype.set = function (serviceId, instance) {
        this._serviceCollection.set(serviceId, instance);
    };
    DynamicStandaloneServices.prototype.has = function (serviceId) {
        return this._serviceCollection.has(serviceId);
    };
    return DynamicStandaloneServices;
}(Disposable));

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
function parse$2(text) {
    var data = JSON.parse(text);
    data = revive(data, 0);
    return data;
}
function revive(obj, depth) {
    if (!obj || depth > 200) {
        return obj;
    }
    if (typeof obj === 'object') {
        switch (obj.$mid) {
            case 1: return URI.revive(obj);
            case 2: return new RegExp(obj.source, obj.flags);
        }
        // walk object (or array)
        for (var key in obj) {
            if (Object.hasOwnProperty.call(obj, key)) {
                obj[key] = revive(obj[key], depth + 1);
            }
        }
    }
    return obj;
}

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var NullTelemetryService = new /** @class */ (function () {
    function class_1() {
    }
    class_1.prototype.publicLog = function (eventName, data) {
        return TPromise.wrap(null);
    };
    class_1.prototype.getTelemetryInfo = function () {
        return TPromise.wrap({
            instanceId: 'someValue.instanceId',
            sessionId: 'someValue.sessionId',
            machineId: 'someValue.machineId'
        });
    };
    return class_1;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __decorate$f = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$c = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var OpenerService = /** @class */ (function () {
    function OpenerService(_editorService, _commandService, _telemetryService) {
        if (_telemetryService === void 0) { _telemetryService = NullTelemetryService; }
        this._editorService = _editorService;
        this._commandService = _commandService;
        this._telemetryService = _telemetryService;
        //
    }
    OpenerService.prototype.open = function (resource, options) {
        /* __GDPR__
            "openerService" : {
                "scheme" : { "classification": "SystemMetaData", "purpose": "FeatureInsight" }
            }
        */
        this._telemetryService.publicLog('openerService', { scheme: resource.scheme });
        var scheme = resource.scheme, path = resource.path, query = resource.query, fragment = resource.fragment;
        var promise = TPromise.wrap(void 0);
        if (scheme === Schemas.http || scheme === Schemas.https || scheme === Schemas.mailto) {
            // open http or default mail application
            windowOpenNoOpener(resource.toString(true));
        }
        else if (scheme === 'command' && CommandsRegistry.getCommand(path)) {
            // execute as command
            var args = [];
            try {
                args = parse$2(query);
                if (!Array.isArray(args)) {
                    args = [args];
                }
            }
            catch (e) {
                //
            }
            promise = (_a = this._commandService).executeCommand.apply(_a, [path].concat(args));
        }
        else {
            var selection = void 0;
            var match = /^L?(\d+)(?:,(\d+))?/.exec(fragment);
            if (match) {
                // support file:///some/file.js#73,84
                // support file:///some/file.js#L73
                selection = {
                    startLineNumber: parseInt(match[1]),
                    startColumn: match[2] ? parseInt(match[2]) : 1
                };
                // remove fragment
                resource = resource.with({ fragment: '' });
            }
            if (!resource.scheme) {
                // we cannot handle those
                return TPromise.as(undefined);
            }
            else if (resource.scheme === Schemas.file) {
                resource = resource.with({ path: normalize(resource.path) }); // workaround for non-normalized paths (https://github.com/Microsoft/vscode/issues/12954)
            }
            promise = this._editorService.openEditor({ resource: resource, options: { selection: selection, } }, options && options.openToSide);
        }
        return promise;
        var _a;
    };
    OpenerService = __decorate$f([
        __param$c(0, IEditorService),
        __param$c(1, ICommandService),
        __param$c(2, optional(ITelemetryService))
    ], OpenerService);
    return OpenerService;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var IOpenerService = createDecorator('openerService');
var NullOpenerService = Object.freeze({
    _serviceBrand: undefined,
    open: function () { return TPromise.as(undefined); }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var Colorizer = /** @class */ (function () {
    function Colorizer() {
    }
    Colorizer.colorizeElement = function (themeService, modeService, domNode, options) {
        options = options || {};
        var theme = options.theme || 'vs';
        var mimeType = options.mimeType || domNode.getAttribute('lang') || domNode.getAttribute('data-lang');
        if (!mimeType) {
            console.error('Mode not detected');
            return undefined;
        }
        themeService.setTheme(theme);
        var text = domNode.firstChild.nodeValue;
        domNode.className += ' ' + theme;
        var render = function (str) {
            domNode.innerHTML = str;
        };
        return this.colorize(modeService, text, mimeType, options).then(render, function (err) { return console.error(err); }, render);
    };
    Colorizer._tokenizationSupportChangedPromise = function (language) {
        var listener = null;
        var stopListening = function () {
            if (listener) {
                listener.dispose();
                listener = null;
            }
        };
        return new TPromise(function (c, e, p) {
            listener = TokenizationRegistry.onDidChange(function (e) {
                if (e.changedLanguages.indexOf(language) >= 0) {
                    stopListening();
                    c(void 0);
                }
            });
        }, stopListening);
    };
    Colorizer.colorize = function (modeService, text, mimeType, options) {
        if (startsWithUTF8BOM(text)) {
            text = text.substr(1);
        }
        var lines = text.split(/\r\n|\r|\n/);
        var language = modeService.getModeId(mimeType);
        options = options || {};
        if (typeof options.tabSize === 'undefined') {
            options.tabSize = 4;
        }
        // Send out the event to create the mode
        modeService.getOrCreateMode(language);
        var tokenizationSupport = TokenizationRegistry.get(language);
        if (tokenizationSupport) {
            return TPromise.as(_colorize(lines, options.tabSize, tokenizationSupport));
        }
        // wait 500ms for mode to load, then give up
        return TPromise.any([this._tokenizationSupportChangedPromise(language), TPromise.timeout(500)]).then(function (_) {
            var tokenizationSupport = TokenizationRegistry.get(language);
            if (tokenizationSupport) {
                return _colorize(lines, options.tabSize, tokenizationSupport);
            }
            return _fakeColorize(lines, options.tabSize);
        });
    };
    Colorizer.colorizeLine = function (line, mightContainNonBasicASCII, mightContainRTL, tokens, tabSize) {
        if (tabSize === void 0) { tabSize = 4; }
        var isBasicASCII$$1 = ViewLineRenderingData.isBasicASCII(line, mightContainNonBasicASCII);
        var containsRTL$$1 = ViewLineRenderingData.containsRTL(line, isBasicASCII$$1, mightContainRTL);
        var renderResult = renderViewLine2(new RenderLineInput(false, line, isBasicASCII$$1, containsRTL$$1, 0, tokens, [], tabSize, 0, -1, 'none', false, false));
        return renderResult.html;
    };
    Colorizer.colorizeModelLine = function (model, lineNumber, tabSize) {
        if (tabSize === void 0) { tabSize = 4; }
        var content = model.getLineContent(lineNumber);
        model.forceTokenization(lineNumber);
        var tokens = model.getLineTokens(lineNumber);
        var inflatedTokens = tokens.inflate();
        return this.colorizeLine(content, model.mightContainNonBasicASCII(), model.mightContainRTL(), inflatedTokens, tabSize);
    };
    return Colorizer;
}());
function _colorize(lines, tabSize, tokenizationSupport) {
    return _actualColorize(lines, tabSize, tokenizationSupport);
}
function _fakeColorize(lines, tabSize) {
    var html = [];
    var defaultMetadata = ((0 /* None */ << 11 /* FONT_STYLE_OFFSET */)
        | (1 /* DefaultForeground */ << 14 /* FOREGROUND_OFFSET */)
        | (2 /* DefaultBackground */ << 23 /* BACKGROUND_OFFSET */)) >>> 0;
    var tokens = new Uint32Array(2);
    tokens[0] = 0;
    tokens[1] = defaultMetadata;
    for (var i = 0, length_1 = lines.length; i < length_1; i++) {
        var line = lines[i];
        tokens[0] = line.length;
        var lineTokens = new LineTokens(tokens, line);
        var isBasicASCII$$1 = ViewLineRenderingData.isBasicASCII(line, /* check for basic ASCII */ true);
        var containsRTL$$1 = ViewLineRenderingData.containsRTL(line, isBasicASCII$$1, /* check for RTL */ true);
        var renderResult = renderViewLine2(new RenderLineInput(false, line, isBasicASCII$$1, containsRTL$$1, 0, lineTokens, [], tabSize, 0, -1, 'none', false, false));
        html = html.concat(renderResult.html);
        html.push('<br/>');
    }
    return html.join('');
}
function _actualColorize(lines, tabSize, tokenizationSupport) {
    var html = [];
    var state = tokenizationSupport.getInitialState();
    for (var i = 0, length_2 = lines.length; i < length_2; i++) {
        var line = lines[i];
        var tokenizeResult = tokenizationSupport.tokenize2(line, state, 0);
        LineTokens.convertToEndOffset(tokenizeResult.tokens, line.length);
        var lineTokens = new LineTokens(tokenizeResult.tokens, line);
        var isBasicASCII$$1 = ViewLineRenderingData.isBasicASCII(line, /* check for basic ASCII */ true);
        var containsRTL$$1 = ViewLineRenderingData.containsRTL(line, isBasicASCII$$1, /* check for RTL */ true);
        var renderResult = renderViewLine2(new RenderLineInput(false, line, isBasicASCII$$1, containsRTL$$1, 0, lineTokens.inflate(), [], tabSize, 0, -1, 'none', false, false));
        html = html.concat(renderResult.html);
        html.push('<br/>');
        state = tokenizeResult.endState;
    }
    return html.join('');
}

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$1o = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * Create a new web worker that has model syncing capabilities built in.
 * Specify an AMD module to load that will `create` an object that will be proxied.
 */
function createWebWorker(modelService, opts) {
    return new MonacoWebWorkerImpl(modelService, opts);
}
var MonacoWebWorkerImpl = /** @class */ (function (_super) {
    __extends$1o(MonacoWebWorkerImpl, _super);
    function MonacoWebWorkerImpl(modelService, opts) {
        var _this = _super.call(this, modelService, opts.label) || this;
        _this._foreignModuleId = opts.moduleId;
        _this._foreignModuleCreateData = opts.createData || null;
        _this._foreignProxy = null;
        return _this;
    }
    MonacoWebWorkerImpl.prototype._getForeignProxy = function () {
        var _this = this;
        if (!this._foreignProxy) {
            this._foreignProxy = new ShallowCancelThenPromise(this._getProxy().then(function (proxy) {
                return proxy.loadForeignModule(_this._foreignModuleId, _this._foreignModuleCreateData).then(function (foreignMethods) {
                    _this._foreignModuleId = null;
                    _this._foreignModuleCreateData = null;
                    var proxyMethodRequest = function (method, args) {
                        return proxy.fmr(method, args);
                    };
                    var createProxyMethod = function (method, proxyMethodRequest) {
                        return function () {
                            var args = Array.prototype.slice.call(arguments, 0);
                            return proxyMethodRequest(method, args);
                        };
                    };
                    var foreignProxy = {};
                    for (var i = 0; i < foreignMethods.length; i++) {
                        foreignProxy[foreignMethods[i]] = createProxyMethod(foreignMethods[i], proxyMethodRequest);
                    }
                    return foreignProxy;
                });
            }));
        }
        return this._foreignProxy;
    };
    MonacoWebWorkerImpl.prototype.getProxy = function () {
        return this._getForeignProxy();
    };
    MonacoWebWorkerImpl.prototype.withSyncedResources = function (resources) {
        var _this = this;
        return this._withSyncedResources(resources).then(function (_) { return _this.getProxy(); });
    };
    return MonacoWebWorkerImpl;
}(EditorWorkerClient));

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var defaultOptions$1 = {
    followsCaret: true,
    ignoreCharChanges: true,
    alwaysRevealFirst: true
};
/**
 * Create a new diff navigator for the provided diff editor.
 */
var DiffNavigator = /** @class */ (function () {
    function DiffNavigator(editor, options) {
        if (options === void 0) { options = {}; }
        var _this = this;
        this._onDidUpdate = new Emitter();
        this.onDidUpdate = this._onDidUpdate.event;
        this._editor = editor;
        this._options = mixin(options, defaultOptions$1, false);
        this.disposed = false;
        this._disposables = [];
        this.nextIdx = -1;
        this.ranges = [];
        this.ignoreSelectionChange = false;
        this.revealFirst = this._options.alwaysRevealFirst;
        // hook up to diff editor for diff, disposal, and caret move
        this._disposables.push(this._editor.onDidDispose(function () { return _this.dispose(); }));
        this._disposables.push(this._editor.onDidUpdateDiff(function () { return _this._onDiffUpdated(); }));
        if (this._options.followsCaret) {
            this._disposables.push(this._editor.getModifiedEditor().onDidChangeCursorPosition(function (e) {
                if (_this.ignoreSelectionChange) {
                    return;
                }
                _this.nextIdx = -1;
            }));
        }
        if (this._options.alwaysRevealFirst) {
            this._disposables.push(this._editor.getModifiedEditor().onDidChangeModel(function (e) {
                _this.revealFirst = true;
            }));
        }
        // init things
        this._init();
    }
    DiffNavigator.prototype._init = function () {
        var changes = this._editor.getLineChanges();
        if (!changes) {
            return;
        }
    };
    DiffNavigator.prototype._onDiffUpdated = function () {
        this._init();
        this._compute(this._editor.getLineChanges());
        if (this.revealFirst) {
            // Only reveal first on first non-null changes
            if (this._editor.getLineChanges() !== null) {
                this.revealFirst = false;
                this.nextIdx = -1;
                this.next();
            }
        }
    };
    DiffNavigator.prototype._compute = function (lineChanges) {
        var _this = this;
        // new ranges
        this.ranges = [];
        if (lineChanges) {
            // create ranges from changes
            lineChanges.forEach(function (lineChange) {
                if (!_this._options.ignoreCharChanges && lineChange.charChanges) {
                    lineChange.charChanges.forEach(function (charChange) {
                        _this.ranges.push({
                            rhs: true,
                            range: new Range(charChange.modifiedStartLineNumber, charChange.modifiedStartColumn, charChange.modifiedEndLineNumber, charChange.modifiedEndColumn)
                        });
                    });
                }
                else {
                    _this.ranges.push({
                        rhs: true,
                        range: new Range(lineChange.modifiedStartLineNumber, 1, lineChange.modifiedStartLineNumber, 1)
                    });
                }
            });
        }
        // sort
        this.ranges.sort(function (left, right) {
            if (left.range.getStartPosition().isBeforeOrEqual(right.range.getStartPosition())) {
                return -1;
            }
            else if (right.range.getStartPosition().isBeforeOrEqual(left.range.getStartPosition())) {
                return 1;
            }
            else {
                return 0;
            }
        });
        this._onDidUpdate.fire(this);
    };
    DiffNavigator.prototype._initIdx = function (fwd) {
        var found = false;
        var position = this._editor.getPosition();
        for (var i = 0, len = this.ranges.length; i < len && !found; i++) {
            var range = this.ranges[i].range;
            if (position.isBeforeOrEqual(range.getStartPosition())) {
                this.nextIdx = i + (fwd ? 0 : -1);
                found = true;
            }
        }
        if (!found) {
            // after the last change
            this.nextIdx = fwd ? 0 : this.ranges.length - 1;
        }
        if (this.nextIdx < 0) {
            this.nextIdx = this.ranges.length - 1;
        }
    };
    DiffNavigator.prototype._move = function (fwd) {
        ok(!this.disposed, 'Illegal State - diff navigator has been disposed');
        if (!this.canNavigate()) {
            return;
        }
        if (this.nextIdx === -1) {
            this._initIdx(fwd);
        }
        else if (fwd) {
            this.nextIdx += 1;
            if (this.nextIdx >= this.ranges.length) {
                this.nextIdx = 0;
            }
        }
        else {
            this.nextIdx -= 1;
            if (this.nextIdx < 0) {
                this.nextIdx = this.ranges.length - 1;
            }
        }
        var info = this.ranges[this.nextIdx];
        this.ignoreSelectionChange = true;
        try {
            var pos = info.range.getStartPosition();
            this._editor.setPosition(pos);
            this._editor.revealPositionInCenter(pos, 0 /* Smooth */);
        }
        finally {
            this.ignoreSelectionChange = false;
        }
    };
    DiffNavigator.prototype.canNavigate = function () {
        return this.ranges && this.ranges.length > 0;
    };
    DiffNavigator.prototype.next = function () {
        this._move(true);
    };
    DiffNavigator.prototype.previous = function () {
        this._move(false);
    };
    DiffNavigator.prototype.dispose = function () {
        dispose(this._disposables);
        this._disposables.length = 0;
        this._onDidUpdate.dispose();
        this.ranges = null;
        this.disposed = true;
    };
    return DiffNavigator;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var ITextModelService = createDecorator('textModelService');

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
function withAllStandaloneServices(domElement, override, callback) {
    var services = new DynamicStandaloneServices(domElement, override);
    // The editorService is a lovely beast. It needs to point back to the code editor instance...
    var simpleEditorService = null;
    if (!services.has(IEditorService)) {
        simpleEditorService = new SimpleEditorService();
        services.set(IEditorService, simpleEditorService);
    }
    var simpleEditorModelResolverService = null;
    if (!services.has(ITextModelService)) {
        simpleEditorModelResolverService = new SimpleEditorModelResolverService();
        services.set(ITextModelService, simpleEditorModelResolverService);
    }
    if (!services.has(IOpenerService)) {
        services.set(IOpenerService, new OpenerService(services.get(IEditorService), services.get(ICommandService)));
    }
    var result = callback(services);
    if (simpleEditorService) {
        simpleEditorService.setEditor(result);
    }
    if (simpleEditorModelResolverService) {
        simpleEditorModelResolverService.setEditor(result);
    }
    return result;
}
/**
 * Create a new editor under `domElement`.
 * `domElement` should be empty (not contain other dom nodes).
 * The editor will read the size of `domElement`.
 */
function create$1(domElement, options, override) {
    return withAllStandaloneServices(domElement, override, function (services) {
        return new StandaloneEditor(domElement, options, services, services.get(IInstantiationService), services.get(ICodeEditorService), services.get(ICommandService), services.get(IContextKeyService), services.get(IKeybindingService), services.get(IContextViewService), services.get(IStandaloneThemeService), services.get(INotificationService));
    });
}
/**
 * Emitted when an editor is created.
 * Creating a diff editor might cause this listener to be invoked with the two editors.
 * @event
 */
function onDidCreateEditor(listener) {
    return StaticServices.codeEditorService.get().onCodeEditorAdd(function (editor) {
        listener(editor);
    });
}
/**
 * Create a new diff editor under `domElement`.
 * `domElement` should be empty (not contain other dom nodes).
 * The editor will read the size of `domElement`.
 */
function createDiffEditor(domElement, options, override) {
    return withAllStandaloneServices(domElement, override, function (services) {
        return new StandaloneDiffEditor(domElement, options, services, services.get(IInstantiationService), services.get(IContextKeyService), services.get(IKeybindingService), services.get(IContextViewService), services.get(IEditorWorkerService), services.get(ICodeEditorService), services.get(IStandaloneThemeService), services.get(INotificationService));
    });
}
function createDiffNavigator(diffEditor, opts) {
    return new DiffNavigator(diffEditor, opts);
}
function doCreateModel(value, mode, uri) {
    return StaticServices.modelService.get().createModel(value, mode, uri);
}
/**
 * Create a new editor model.
 * You can specify the language that should be set for this model or let the language be inferred from the `uri`.
 */
function createModel(value, language, uri) {
    value = value || '';
    if (!language) {
        var path = uri ? uri.path : null;
        var firstLF = value.indexOf('\n');
        var firstLine = value;
        if (firstLF !== -1) {
            firstLine = value.substring(0, firstLF);
        }
        return doCreateModel(value, StaticServices.modeService.get().getOrCreateModeByFilenameOrFirstLine(path, firstLine), uri);
    }
    return doCreateModel(value, StaticServices.modeService.get().getOrCreateMode(language), uri);
}
/**
 * Change the language for a model.
 */
function setModelLanguage(model, language) {
    StaticServices.modelService.get().setMode(model, StaticServices.modeService.get().getOrCreateMode(language));
}
/**
 * Set the markers for a model.
 */
function setModelMarkers(model, owner, markers) {
    if (model) {
        StaticServices.markerService.get().changeOne(owner, model.uri, markers);
    }
}
/**
 * Get markers for owner and/or resource
 * @returns {IMarker[]} list of markers
 * @param filter
 */
function getModelMarkers(filter) {
    return StaticServices.markerService.get().read(filter);
}
/**
 * Get the model that has `uri` if it exists.
 */
function getModel(uri) {
    return StaticServices.modelService.get().getModel(uri);
}
/**
 * Get all the created models.
 */
function getModels() {
    return StaticServices.modelService.get().getModels();
}
/**
 * Emitted when a model is created.
 * @event
 */
function onDidCreateModel(listener) {
    return StaticServices.modelService.get().onModelAdded(listener);
}
/**
 * Emitted right before a model is disposed.
 * @event
 */
function onWillDisposeModel(listener) {
    return StaticServices.modelService.get().onModelRemoved(listener);
}
/**
 * Emitted when a different language is set to a model.
 * @event
 */
function onDidChangeModelLanguage(listener) {
    return StaticServices.modelService.get().onModelModeChanged(function (e) {
        listener({
            model: e.model,
            oldLanguage: e.oldModeId
        });
    });
}
/**
 * Create a new web worker that has model syncing capabilities built in.
 * Specify an AMD module to load that will `create` an object that will be proxied.
 */
function createWebWorker$1(opts) {
    return createWebWorker(StaticServices.modelService.get(), opts);
}
/**
 * Colorize the contents of `domNode` using attribute `data-lang`.
 */
function colorizeElement(domNode, options) {
    return Colorizer.colorizeElement(StaticServices.standaloneThemeService.get(), StaticServices.modeService.get(), domNode, options);
}
/**
 * Colorize `text` using language `languageId`.
 */
function colorize(text, languageId, options) {
    return Colorizer.colorize(StaticServices.modeService.get(), text, languageId, options);
}
/**
 * Colorize a line in a model.
 */
function colorizeModelLine(model, lineNumber, tabSize) {
    if (tabSize === void 0) { tabSize = 4; }
    return Colorizer.colorizeModelLine(model, lineNumber, tabSize);
}
/**
 * @internal
 */
function getSafeTokenizationSupport(languageId) {
    var tokenizationSupport = TokenizationRegistry.get(languageId);
    if (tokenizationSupport) {
        return tokenizationSupport;
    }
    return {
        getInitialState: function () { return NULL_STATE; },
        tokenize: function (line, state, deltaOffset) { return nullTokenize(languageId, line, state, deltaOffset); },
        tokenize2: undefined,
    };
}
/**
 * Tokenize `text` using language `languageId`
 */
function tokenize(text, languageId) {
    var modeService = StaticServices.modeService.get();
    // Needed in order to get the mode registered for subsequent look-ups
    modeService.getOrCreateMode(languageId);
    var tokenizationSupport = getSafeTokenizationSupport(languageId);
    var lines = text.split(/\r\n|\r|\n/);
    var result = [];
    var state = tokenizationSupport.getInitialState();
    for (var i = 0, len = lines.length; i < len; i++) {
        var line = lines[i];
        var tokenizationResult = tokenizationSupport.tokenize(line, state, 0);
        result[i] = tokenizationResult.tokens;
        state = tokenizationResult.endState;
    }
    return result;
}
/**
 * Define a new theme.
 */
function defineTheme(themeName, themeData) {
    StaticServices.standaloneThemeService.get().defineTheme(themeName, themeData);
}
/**
 * Switches to a theme.
 */
function setTheme(themeName) {
    StaticServices.standaloneThemeService.get().setTheme(themeName);
}
/**
 * @internal
 * --------------------------------------------
 * This is repeated here so it can be exported
 * because TS inlines const enums
 * --------------------------------------------
 */
var ScrollType;
(function (ScrollType) {
    ScrollType[ScrollType["Smooth"] = 0] = "Smooth";
    ScrollType[ScrollType["Immediate"] = 1] = "Immediate";
})(ScrollType || (ScrollType = {}));
/**
 * @internal
 * --------------------------------------------
 * This is repeated here so it can be exported
 * because TS inlines const enums
 * --------------------------------------------
 */
var RenderLineNumbersType;
(function (RenderLineNumbersType) {
    RenderLineNumbersType[RenderLineNumbersType["Off"] = 0] = "Off";
    RenderLineNumbersType[RenderLineNumbersType["On"] = 1] = "On";
    RenderLineNumbersType[RenderLineNumbersType["Relative"] = 2] = "Relative";
    RenderLineNumbersType[RenderLineNumbersType["Interval"] = 3] = "Interval";
    RenderLineNumbersType[RenderLineNumbersType["Custom"] = 4] = "Custom";
})(RenderLineNumbersType || (RenderLineNumbersType = {}));
/**
 * @internal
 */
function createMonacoEditorAPI() {
    return {
        // methods
        create: create$1,
        onDidCreateEditor: onDidCreateEditor,
        createDiffEditor: createDiffEditor,
        createDiffNavigator: createDiffNavigator,
        createModel: createModel,
        setModelLanguage: setModelLanguage,
        setModelMarkers: setModelMarkers,
        getModelMarkers: getModelMarkers,
        getModels: getModels,
        getModel: getModel,
        onDidCreateModel: onDidCreateModel,
        onWillDisposeModel: onWillDisposeModel,
        onDidChangeModelLanguage: onDidChangeModelLanguage,
        createWebWorker: createWebWorker$1,
        colorizeElement: colorizeElement,
        colorize: colorize,
        colorizeModelLine: colorizeModelLine,
        tokenize: tokenize,
        defineTheme: defineTheme,
        setTheme: setTheme,
        // enums
        ScrollbarVisibility: ScrollbarVisibility,
        WrappingIndent: WrappingIndent,
        OverviewRulerLane: OverviewRulerLane,
        EndOfLinePreference: EndOfLinePreference,
        DefaultEndOfLine: DefaultEndOfLine,
        EndOfLineSequence: EndOfLineSequence,
        TrackedRangeStickiness: TrackedRangeStickiness,
        CursorChangeReason: CursorChangeReason,
        MouseTargetType: MouseTargetType,
        TextEditorCursorStyle: TextEditorCursorStyle,
        TextEditorCursorBlinkingStyle: TextEditorCursorBlinkingStyle,
        ContentWidgetPositionPreference: ContentWidgetPositionPreference,
        OverlayWidgetPositionPreference: OverlayWidgetPositionPreference,
        RenderMinimap: RenderMinimap,
        ScrollType: ScrollType,
        RenderLineNumbersType: RenderLineNumbersType,
        // classes
        InternalEditorOptions: InternalEditorOptions,
        BareFontInfo: BareFontInfo,
        FontInfo: FontInfo,
        TextModelResolvedOptions: TextModelResolvedOptions,
        FindMatch: FindMatch,
        // vars
        EditorType: EditorType
    };
}

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
function isFuzzyActionArr(what) {
    return (Array.isArray(what));
}
function isFuzzyAction(what) {
    return !isFuzzyActionArr(what);
}
function isString$1(what) {
    return (typeof what === 'string');
}
function isIAction(what) {
    return !isString$1(what);
}
// Small helper functions
/**
 * Is a string null, undefined, or empty?
 */
function empty$2(s) {
    return (s ? false : true);
}
/**
 * Puts a string to lower case if 'ignoreCase' is set.
 */
function fixCase(lexer, str) {
    return (lexer.ignoreCase && str ? str.toLowerCase() : str);
}
/**
 * Ensures there are no bad characters in a CSS token class.
 */
function sanitize(s) {
    return s.replace(/[&<>'"_]/g, '-'); // used on all output token CSS classes
}
// Logging
/**
 * Logs a message.
 */
function log(lexer, msg) {
    console.log(lexer.languageId + ": " + msg);
}
// Throwing errors
/**
 * Throws error. May actually just log the error and continue.
 */
function throwError(lexer, msg) {
    throw new Error(lexer.languageId + ": " + msg);
}
// Helper functions for rule finding and substitution
/**
 * substituteMatches is used on lexer strings and can substitutes predefined patterns:
 * 		$$  => $
 * 		$#  => id
 * 		$n  => matched entry n
 * 		@attr => contents of lexer[attr]
 *
 * See documentation for more info
 */
function substituteMatches(lexer, str, id, matches, state) {
    var re = /\$((\$)|(#)|(\d\d?)|[sS](\d\d?)|@(\w+))/g;
    var stateMatches = null;
    return str.replace(re, function (full, sub, dollar, hash, n, s, attr, ofs, total) {
        if (!empty$2(dollar)) {
            return '$'; // $$
        }
        if (!empty$2(hash)) {
            return fixCase(lexer, id); // default $#
        }
        if (!empty$2(n) && n < matches.length) {
            return fixCase(lexer, matches[n]); // $n
        }
        if (!empty$2(attr) && lexer && typeof (lexer[attr]) === 'string') {
            return lexer[attr]; //@attribute
        }
        if (stateMatches === null) { // split state on demand
            stateMatches = state.split('.');
            stateMatches.unshift(state);
        }
        if (!empty$2(s) && s < stateMatches.length) {
            return fixCase(lexer, stateMatches[s]); //$Sn
        }
        return '';
    });
}
/**
 * Find the tokenizer rules for a specific state (i.e. next action)
 */
function findRules(lexer, state) {
    while (state && state.length > 0) {
        var rules = lexer.tokenizer[state];
        if (rules) {
            return rules;
        }
        var idx = state.lastIndexOf('.');
        if (idx < 0) {
            state = null; // no further parent
        }
        else {
            state = state.substr(0, idx);
        }
    }
    return null;
}
/**
 * Is a certain state defined? In contrast to 'findRules' this works on a ILexerMin.
 * This is used during compilation where we may know the defined states
 * but not yet whether the corresponding rules are correct.
 */
function stateExists(lexer, state) {
    while (state && state.length > 0) {
        var exist = lexer.stateNames[state];
        if (exist) {
            return true;
        }
        var idx = state.lastIndexOf('.');
        if (idx < 0) {
            state = null; // no further parent
        }
        else {
            state = state.substr(0, idx);
        }
    }
    return false;
}

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
/*
 * Type helpers
 *
 * Note: this is just for sanity checks on the JSON description which is
 * helpful for the programmer. No checks are done anymore once the lexer is
 * already 'compiled and checked'.
 *
 */
function isArrayOf(elemType, obj) {
    if (!obj) {
        return false;
    }
    if (!(Array.isArray(obj))) {
        return false;
    }
    var idx;
    for (idx in obj) {
        if (obj.hasOwnProperty(idx)) {
            if (!(elemType(obj[idx]))) {
                return false;
            }
        }
    }
    return true;
}
function bool(prop, def, onerr) {
    if (typeof (prop) === 'boolean') {
        return prop;
    }
    if (onerr && (prop || def === undefined)) {
        onerr(); // type is wrong, or there is no default
    }
    return (def === undefined ? null : def);
}
function string(prop, def, onerr) {
    if (typeof (prop) === 'string') {
        return prop;
    }
    if (onerr && (prop || def === undefined)) {
        onerr(); // type is wrong, or there is no default
    }
    return (def === undefined ? null : def);
}
// Lexer helpers
/**
 * Compiles a regular expression string, adding the 'i' flag if 'ignoreCase' is set.
 * Also replaces @\w+ or sequences with the content of the specified attribute
 */
function compileRegExp(lexer, str) {
    if (typeof (str) !== 'string') {
        return null;
    }
    var n = 0;
    while (str.indexOf('@') >= 0 && n < 5) { // at most 5 expansions
        n++;
        str = str.replace(/@(\w+)/g, function (s, attr) {
            var sub = '';
            if (typeof (lexer[attr]) === 'string') {
                sub = lexer[attr];
            }
            else if (lexer[attr] && lexer[attr] instanceof RegExp) {
                sub = lexer[attr].source;
            }
            else {
                if (lexer[attr] === undefined) {
                    throwError(lexer, 'language definition does not contain attribute \'' + attr + '\', used at: ' + str);
                }
                else {
                    throwError(lexer, 'attribute reference \'' + attr + '\' must be a string, used at: ' + str);
                }
            }
            return (empty$2(sub) ? '' : '(?:' + sub + ')');
        });
    }
    return new RegExp(str, (lexer.ignoreCase ? 'i' : ''));
}
/**
 * Compiles guard functions for case matches.
 * This compiles 'cases' attributes into efficient match functions.
 *
 */
function selectScrutinee(id, matches, state, num) {
    if (num < 0) {
        return id;
    }
    if (num < matches.length) {
        return matches[num];
    }
    if (num >= 100) {
        num = num - 100;
        var parts = state.split('.');
        parts.unshift(state);
        if (num < parts.length) {
            return parts[num];
        }
    }
    return null;
}
function createGuard(lexer, ruleName, tkey, val) {
    // get the scrutinee and pattern
    var scrut = -1; // -1: $!, 0-99: $n, 100+n: $Sn
    var oppat = tkey;
    var matches = tkey.match(/^\$(([sS]?)(\d\d?)|#)(.*)$/);
    if (matches) {
        if (matches[3]) { // if digits
            scrut = parseInt(matches[3]);
            if (matches[2]) {
                scrut = scrut + 100; // if [sS] present
            }
        }
        oppat = matches[4];
    }
    // get operator
    var op = '~';
    var pat = oppat;
    if (!oppat || oppat.length === 0) {
        op = '!=';
        pat = '';
    }
    else if (/^\w*$/.test(pat)) { // just a word
        op = '==';
    }
    else {
        matches = oppat.match(/^(@|!@|~|!~|==|!=)(.*)$/);
        if (matches) {
            op = matches[1];
            pat = matches[2];
        }
    }
    // set the tester function
    var tester;
    // special case a regexp that matches just words
    if ((op === '~' || op === '!~') && /^(\w|\|)*$/.test(pat)) {
        var inWords_1 = createKeywordMatcher(pat.split('|'), lexer.ignoreCase);
        tester = function (s) { return (op === '~' ? inWords_1(s) : !inWords_1(s)); };
    }
    else if (op === '@' || op === '!@') {
        var words = lexer[pat];
        if (!words) {
            throwError(lexer, 'the @ match target \'' + pat + '\' is not defined, in rule: ' + ruleName);
        }
        if (!(isArrayOf(function (elem) { return (typeof (elem) === 'string'); }, words))) {
            throwError(lexer, 'the @ match target \'' + pat + '\' must be an array of strings, in rule: ' + ruleName);
        }
        var inWords_2 = createKeywordMatcher(words, lexer.ignoreCase);
        tester = function (s) { return (op === '@' ? inWords_2(s) : !inWords_2(s)); };
    }
    else if (op === '~' || op === '!~') {
        if (pat.indexOf('$') < 0) {
            // precompile regular expression
            var re = compileRegExp(lexer, '^' + pat + '$');
            tester = function (s) { return (op === '~' ? re.test(s) : !re.test(s)); };
        }
        else {
            tester = function (s, id, matches, state) {
                var re = compileRegExp(lexer, '^' + substituteMatches(lexer, pat, id, matches, state) + '$');
                return re.test(s);
            };
        }
    }
    else { // if (op==='==' || op==='!=') {
        if (pat.indexOf('$') < 0) {
            var patx = fixCase(lexer, pat);
            tester = function (s) { return (op === '==' ? s === patx : s !== patx); };
        }
        else {
            var patx_1 = fixCase(lexer, pat);
            tester = function (s, id, matches, state, eos) {
                var patexp = substituteMatches(lexer, patx_1, id, matches, state);
                return (op === '==' ? s === patexp : s !== patexp);
            };
        }
    }
    // return the branch object
    if (scrut === -1) {
        return {
            name: tkey, value: val, test: function (id, matches, state, eos) {
                return tester(id, id, matches, state, eos);
            }
        };
    }
    else {
        return {
            name: tkey, value: val, test: function (id, matches, state, eos) {
                var scrutinee = selectScrutinee(id, matches, state, scrut);
                return tester(!scrutinee ? '' : scrutinee, id, matches, state, eos);
            }
        };
    }
}
/**
 * Compiles an action: i.e. optimize regular expressions and case matches
 * and do many sanity checks.
 *
 * This is called only during compilation but if the lexer definition
 * contains user functions as actions (which is usually not allowed), then this
 * may be called during lexing. It is important therefore to compile common cases efficiently
 */
function compileAction(lexer, ruleName, action) {
    if (!action) {
        return { token: '' };
    }
    else if (typeof (action) === 'string') {
        return action; // { token: action };
    }
    else if (action.token || action.token === '') {
        if (typeof (action.token) !== 'string') {
            throwError(lexer, 'a \'token\' attribute must be of type string, in rule: ' + ruleName);
            return { token: '' };
        }
        else {
            // only copy specific typed fields (only happens once during compile Lexer)
            var newAction = { token: action.token };
            if (action.token.indexOf('$') >= 0) {
                newAction.tokenSubst = true;
            }
            if (typeof (action.bracket) === 'string') {
                if (action.bracket === '@open') {
                    newAction.bracket = 1 /* Open */;
                }
                else if (action.bracket === '@close') {
                    newAction.bracket = -1 /* Close */;
                }
                else {
                    throwError(lexer, 'a \'bracket\' attribute must be either \'@open\' or \'@close\', in rule: ' + ruleName);
                }
            }
            if (action.next) {
                if (typeof (action.next) !== 'string') {
                    throwError(lexer, 'the next state must be a string value in rule: ' + ruleName);
                }
                else {
                    var next = action.next;
                    if (!/^(@pop|@push|@popall)$/.test(next)) {
                        if (next[0] === '@') {
                            next = next.substr(1); // peel off starting @ sign
                        }
                        if (next.indexOf('$') < 0) { // no dollar substitution, we can check if the state exists
                            if (!stateExists(lexer, substituteMatches(lexer, next, '', [], ''))) {
                                throwError(lexer, 'the next state \'' + action.next + '\' is not defined in rule: ' + ruleName);
                            }
                        }
                    }
                    newAction.next = next;
                }
            }
            if (typeof (action.goBack) === 'number') {
                newAction.goBack = action.goBack;
            }
            if (typeof (action.switchTo) === 'string') {
                newAction.switchTo = action.switchTo;
            }
            if (typeof (action.log) === 'string') {
                newAction.log = action.log;
            }
            if (typeof (action.nextEmbedded) === 'string') {
                newAction.nextEmbedded = action.nextEmbedded;
                lexer.usesEmbedded = true;
            }
            return newAction;
        }
    }
    else if (Array.isArray(action)) {
        var results = [];
        var idx;
        for (idx in action) {
            if (action.hasOwnProperty(idx)) {
                results[idx] = compileAction(lexer, ruleName, action[idx]);
            }
        }
        return { group: results };
    }
    else if (action.cases) {
        // build an array of test cases
        var cases = [];
        // for each case, push a test function and result value
        var tkey;
        for (tkey in action.cases) {
            if (action.cases.hasOwnProperty(tkey)) {
                var val = compileAction(lexer, ruleName, action.cases[tkey]);
                // what kind of case
                if (tkey === '@default' || tkey === '@' || tkey === '') {
                    cases.push({ test: null, value: val, name: tkey });
                }
                else if (tkey === '@eos') {
                    cases.push({ test: function (id, matches, state, eos) { return eos; }, value: val, name: tkey });
                }
                else {
                    cases.push(createGuard(lexer, ruleName, tkey, val)); // call separate function to avoid local variable capture
                }
            }
        }
        // create a matching function
        var def = lexer.defaultToken;
        return {
            test: function (id, matches, state, eos) {
                var idx;
                for (idx in cases) {
                    if (cases.hasOwnProperty(idx)) {
                        var didmatch = (!cases[idx].test || cases[idx].test(id, matches, state, eos));
                        if (didmatch) {
                            return cases[idx].value;
                        }
                    }
                }
                return def;
            }
        };
    }
    else {
        throwError(lexer, 'an action must be a string, an object with a \'token\' or \'cases\' attribute, or an array of actions; in rule: ' + ruleName);
        return '';
    }
}
/**
 * Helper class for creating matching rules
 */
var Rule = /** @class */ (function () {
    function Rule(name) {
        this.regex = new RegExp('');
        this.action = { token: '' };
        this.matchOnlyAtLineStart = false;
        this.name = '';
        this.name = name;
    }
    Rule.prototype.setRegex = function (lexer, re) {
        var sregex;
        if (typeof (re) === 'string') {
            sregex = re;
        }
        else if (re instanceof RegExp) {
            sregex = re.source;
        }
        else {
            throwError(lexer, 'rules must start with a match string or regular expression: ' + this.name);
        }
        this.matchOnlyAtLineStart = (sregex.length > 0 && sregex[0] === '^');
        this.name = this.name + ': ' + sregex;
        this.regex = compileRegExp(lexer, '^(?:' + (this.matchOnlyAtLineStart ? sregex.substr(1) : sregex) + ')');
    };
    Rule.prototype.setAction = function (lexer, act) {
        this.action = compileAction(lexer, this.name, act);
    };
    return Rule;
}());
/**
 * Compiles a json description function into json where all regular expressions,
 * case matches etc, are compiled and all include rules are expanded.
 * We also compile the bracket definitions, supply defaults, and do many sanity checks.
 * If the 'jsonStrict' parameter is 'false', we allow at certain locations
 * regular expression objects and functions that get called during lexing.
 * (Currently we have no samples that need this so perhaps we should always have
 * jsonStrict to true).
 */
function compile(languageId, json) {
    if (!json || typeof (json) !== 'object') {
        throw new Error('Monarch: expecting a language definition object');
    }
    // Create our lexer
    var lexer = {};
    lexer.languageId = languageId;
    lexer.noThrow = false; // raise exceptions during compilation
    lexer.maxStack = 100;
    // Set standard fields: be defensive about types
    lexer.start = string(json.start);
    lexer.ignoreCase = bool(json.ignoreCase, false);
    lexer.tokenPostfix = string(json.tokenPostfix, '.' + lexer.languageId);
    lexer.defaultToken = string(json.defaultToken, 'source', function () { throwError(lexer, 'the \'defaultToken\' must be a string'); });
    lexer.usesEmbedded = false; // becomes true if we find a nextEmbedded action
    // For calling compileAction later on
    var lexerMin = json;
    lexerMin.languageId = languageId;
    lexerMin.ignoreCase = lexer.ignoreCase;
    lexerMin.noThrow = lexer.noThrow;
    lexerMin.usesEmbedded = lexer.usesEmbedded;
    lexerMin.stateNames = json.tokenizer;
    lexerMin.defaultToken = lexer.defaultToken;
    // Compile an array of rules into newrules where RegExp objects are created.
    function addRules(state, newrules, rules) {
        var idx;
        for (idx in rules) {
            if (rules.hasOwnProperty(idx)) {
                var rule = rules[idx];
                var include = rule.include;
                if (include) {
                    if (typeof (include) !== 'string') {
                        throwError(lexer, 'an \'include\' attribute must be a string at: ' + state);
                    }
                    if (include[0] === '@') {
                        include = include.substr(1); // peel off starting @
                    }
                    if (!json.tokenizer[include]) {
                        throwError(lexer, 'include target \'' + include + '\' is not defined at: ' + state);
                    }
                    addRules(state + '.' + include, newrules, json.tokenizer[include]);
                }
                else {
                    var newrule = new Rule(state);
                    // Set up new rule attributes
                    if (Array.isArray(rule) && rule.length >= 1 && rule.length <= 3) {
                        newrule.setRegex(lexerMin, rule[0]);
                        if (rule.length >= 3) {
                            if (typeof (rule[1]) === 'string') {
                                newrule.setAction(lexerMin, { token: rule[1], next: rule[2] });
                            }
                            else if (typeof (rule[1]) === 'object') {
                                var rule1 = rule[1];
                                rule1.next = rule[2];
                                newrule.setAction(lexerMin, rule1);
                            }
                            else {
                                throwError(lexer, 'a next state as the last element of a rule can only be given if the action is either an object or a string, at: ' + state);
                            }
                        }
                        else {
                            newrule.setAction(lexerMin, rule[1]);
                        }
                    }
                    else {
                        if (!rule.regex) {
                            throwError(lexer, 'a rule must either be an array, or an object with a \'regex\' or \'include\' field at: ' + state);
                        }
                        if (rule.name) {
                            newrule.name = string(rule.name);
                        }
                        if (rule.matchOnlyAtStart) {
                            newrule.matchOnlyAtLineStart = bool(rule.matchOnlyAtLineStart);
                        }
                        newrule.setRegex(lexerMin, rule.regex);
                        newrule.setAction(lexerMin, rule.action);
                    }
                    newrules.push(newrule);
                }
            }
        }
    }
    // compile the tokenizer rules
    if (!json.tokenizer || typeof (json.tokenizer) !== 'object') {
        throwError(lexer, 'a language definition must define the \'tokenizer\' attribute as an object');
    }
    lexer.tokenizer = [];
    var key;
    for (key in json.tokenizer) {
        if (json.tokenizer.hasOwnProperty(key)) {
            if (!lexer.start) {
                lexer.start = key;
            }
            var rules = json.tokenizer[key];
            lexer.tokenizer[key] = new Array();
            addRules('tokenizer.' + key, lexer.tokenizer[key], rules);
        }
    }
    lexer.usesEmbedded = lexerMin.usesEmbedded; // can be set during compileAction
    // Set simple brackets
    if (json.brackets) {
        if (!(Array.isArray(json.brackets))) {
            throwError(lexer, 'the \'brackets\' attribute must be defined as an array');
        }
    }
    else {
        json.brackets = [
            { open: '{', close: '}', token: 'delimiter.curly' },
            { open: '[', close: ']', token: 'delimiter.square' },
            { open: '(', close: ')', token: 'delimiter.parenthesis' },
            { open: '<', close: '>', token: 'delimiter.angle' }
        ];
    }
    var brackets = [];
    for (var bracketIdx in json.brackets) {
        if (json.brackets.hasOwnProperty(bracketIdx)) {
            var desc = json.brackets[bracketIdx];
            if (desc && Array.isArray(desc) && desc.length === 3) {
                desc = { token: desc[2], open: desc[0], close: desc[1] };
            }
            if (desc.open === desc.close) {
                throwError(lexer, 'open and close brackets in a \'brackets\' attribute must be different: ' + desc.open +
                    '\n hint: use the \'bracket\' attribute if matching on equal brackets is required.');
            }
            if (typeof (desc.open) === 'string' && typeof (desc.token) === 'string') {
                brackets.push({
                    token: string(desc.token) + lexer.tokenPostfix,
                    open: fixCase(lexer, string(desc.open)),
                    close: fixCase(lexer, string(desc.close))
                });
            }
            else {
                throwError(lexer, 'every element in the \'brackets\' array must be a \'{open,close,token}\' object or array');
            }
        }
    }
    lexer.brackets = brackets;
    // Disable throw so the syntax highlighter goes, no matter what
    lexer.noThrow = true;
    return lexer;
}

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var CACHE_STACK_DEPTH = 5;
/**
 * Reuse the same stack elements up to a certain depth.
 */
var MonarchStackElementFactory = /** @class */ (function () {
    function MonarchStackElementFactory(maxCacheDepth) {
        this._maxCacheDepth = maxCacheDepth;
        this._entries = Object.create(null);
    }
    MonarchStackElementFactory.create = function (parent, state) {
        return this._INSTANCE.create(parent, state);
    };
    MonarchStackElementFactory.prototype.create = function (parent, state) {
        if (parent !== null && parent.depth >= this._maxCacheDepth) {
            // no caching above a certain depth
            return new MonarchStackElement(parent, state);
        }
        var stackElementId = MonarchStackElement.getStackElementId(parent);
        if (stackElementId.length > 0) {
            stackElementId += '|';
        }
        stackElementId += state;
        var result = this._entries[stackElementId];
        if (result) {
            return result;
        }
        result = new MonarchStackElement(parent, state);
        this._entries[stackElementId] = result;
        return result;
    };
    MonarchStackElementFactory._INSTANCE = new MonarchStackElementFactory(CACHE_STACK_DEPTH);
    return MonarchStackElementFactory;
}());
var MonarchStackElement = /** @class */ (function () {
    function MonarchStackElement(parent, state) {
        this.parent = parent;
        this.state = state;
        this.depth = (this.parent ? this.parent.depth : 0) + 1;
    }
    MonarchStackElement.getStackElementId = function (element) {
        var result = '';
        while (element !== null) {
            if (result.length > 0) {
                result += '|';
            }
            result += element.state;
            element = element.parent;
        }
        return result;
    };
    MonarchStackElement._equals = function (a, b) {
        while (a !== null && b !== null) {
            if (a === b) {
                return true;
            }
            if (a.state !== b.state) {
                return false;
            }
            a = a.parent;
            b = b.parent;
        }
        if (a === null && b === null) {
            return true;
        }
        return false;
    };
    MonarchStackElement.prototype.equals = function (other) {
        return MonarchStackElement._equals(this, other);
    };
    MonarchStackElement.prototype.push = function (state) {
        return MonarchStackElementFactory.create(this, state);
    };
    MonarchStackElement.prototype.pop = function () {
        return this.parent;
    };
    MonarchStackElement.prototype.popall = function () {
        var result = this;
        while (result.parent) {
            result = result.parent;
        }
        return result;
    };
    MonarchStackElement.prototype.switchTo = function (state) {
        return MonarchStackElementFactory.create(this.parent, state);
    };
    return MonarchStackElement;
}());
var EmbeddedModeData = /** @class */ (function () {
    function EmbeddedModeData(modeId, state) {
        this.modeId = modeId;
        this.state = state;
    }
    EmbeddedModeData.prototype.equals = function (other) {
        return (this.modeId === other.modeId
            && this.state.equals(other.state));
    };
    EmbeddedModeData.prototype.clone = function () {
        var stateClone = this.state.clone();
        // save an object
        if (stateClone === this.state) {
            return this;
        }
        return new EmbeddedModeData(this.modeId, this.state);
    };
    return EmbeddedModeData;
}());
/**
 * Reuse the same line states up to a certain depth.
 */
var MonarchLineStateFactory = /** @class */ (function () {
    function MonarchLineStateFactory(maxCacheDepth) {
        this._maxCacheDepth = maxCacheDepth;
        this._entries = Object.create(null);
    }
    MonarchLineStateFactory.create = function (stack, embeddedModeData) {
        return this._INSTANCE.create(stack, embeddedModeData);
    };
    MonarchLineStateFactory.prototype.create = function (stack, embeddedModeData) {
        if (embeddedModeData !== null) {
            // no caching when embedding
            return new MonarchLineState(stack, embeddedModeData);
        }
        if (stack !== null && stack.depth >= this._maxCacheDepth) {
            // no caching above a certain depth
            return new MonarchLineState(stack, embeddedModeData);
        }
        var stackElementId = MonarchStackElement.getStackElementId(stack);
        var result = this._entries[stackElementId];
        if (result) {
            return result;
        }
        result = new MonarchLineState(stack, null);
        this._entries[stackElementId] = result;
        return result;
    };
    MonarchLineStateFactory._INSTANCE = new MonarchLineStateFactory(CACHE_STACK_DEPTH);
    return MonarchLineStateFactory;
}());
var MonarchLineState = /** @class */ (function () {
    function MonarchLineState(stack, embeddedModeData) {
        this.stack = stack;
        this.embeddedModeData = embeddedModeData;
    }
    MonarchLineState.prototype.clone = function () {
        var embeddedModeDataClone = this.embeddedModeData ? this.embeddedModeData.clone() : null;
        // save an object
        if (embeddedModeDataClone === this.embeddedModeData) {
            return this;
        }
        return MonarchLineStateFactory.create(this.stack, this.embeddedModeData);
    };
    MonarchLineState.prototype.equals = function (other) {
        if (!(other instanceof MonarchLineState)) {
            return false;
        }
        if (!this.stack.equals(other.stack)) {
            return false;
        }
        if (this.embeddedModeData === null && other.embeddedModeData === null) {
            return true;
        }
        if (this.embeddedModeData === null || other.embeddedModeData === null) {
            return false;
        }
        return this.embeddedModeData.equals(other.embeddedModeData);
    };
    return MonarchLineState;
}());
var hasOwnProperty$3 = Object.hasOwnProperty;
var MonarchClassicTokensCollector = /** @class */ (function () {
    function MonarchClassicTokensCollector() {
        this._tokens = [];
        this._language = null;
        this._lastTokenType = null;
        this._lastTokenLanguage = null;
    }
    MonarchClassicTokensCollector.prototype.enterMode = function (startOffset, modeId) {
        this._language = modeId;
    };
    MonarchClassicTokensCollector.prototype.emit = function (startOffset, type) {
        if (this._lastTokenType === type && this._lastTokenLanguage === this._language) {
            return;
        }
        this._lastTokenType = type;
        this._lastTokenLanguage = this._language;
        this._tokens.push(new Token(startOffset, type, this._language));
    };
    MonarchClassicTokensCollector.prototype.nestedModeTokenize = function (embeddedModeLine, embeddedModeData, offsetDelta) {
        var nestedModeId = embeddedModeData.modeId;
        var embeddedModeState = embeddedModeData.state;
        var nestedModeTokenizationSupport = TokenizationRegistry.get(nestedModeId);
        if (!nestedModeTokenizationSupport) {
            this.enterMode(offsetDelta, nestedModeId);
            this.emit(offsetDelta, '');
            return embeddedModeState;
        }
        var nestedResult = nestedModeTokenizationSupport.tokenize(embeddedModeLine, embeddedModeState, offsetDelta);
        this._tokens = this._tokens.concat(nestedResult.tokens);
        this._lastTokenType = null;
        this._lastTokenLanguage = null;
        this._language = null;
        return nestedResult.endState;
    };
    MonarchClassicTokensCollector.prototype.finalize = function (endState) {
        return new TokenizationResult(this._tokens, endState);
    };
    return MonarchClassicTokensCollector;
}());
var MonarchModernTokensCollector = /** @class */ (function () {
    function MonarchModernTokensCollector(modeService, theme) {
        this._modeService = modeService;
        this._theme = theme;
        this._prependTokens = null;
        this._tokens = [];
        this._currentLanguageId = 0 /* Null */;
        this._lastTokenMetadata = 0;
    }
    MonarchModernTokensCollector.prototype.enterMode = function (startOffset, modeId) {
        this._currentLanguageId = this._modeService.getLanguageIdentifier(modeId).id;
    };
    MonarchModernTokensCollector.prototype.emit = function (startOffset, type) {
        var metadata = this._theme.match(this._currentLanguageId, type);
        if (this._lastTokenMetadata === metadata) {
            return;
        }
        this._lastTokenMetadata = metadata;
        this._tokens.push(startOffset);
        this._tokens.push(metadata);
    };
    MonarchModernTokensCollector._merge = function (a, b, c) {
        var aLen = (a !== null ? a.length : 0);
        var bLen = b.length;
        var cLen = (c !== null ? c.length : 0);
        if (aLen === 0 && bLen === 0 && cLen === 0) {
            return new Uint32Array(0);
        }
        if (aLen === 0 && bLen === 0) {
            return c;
        }
        if (bLen === 0 && cLen === 0) {
            return a;
        }
        var result = new Uint32Array(aLen + bLen + cLen);
        if (a !== null) {
            result.set(a);
        }
        for (var i = 0; i < bLen; i++) {
            result[aLen + i] = b[i];
        }
        if (c !== null) {
            result.set(c, aLen + bLen);
        }
        return result;
    };
    MonarchModernTokensCollector.prototype.nestedModeTokenize = function (embeddedModeLine, embeddedModeData, offsetDelta) {
        var nestedModeId = embeddedModeData.modeId;
        var embeddedModeState = embeddedModeData.state;
        var nestedModeTokenizationSupport = TokenizationRegistry.get(nestedModeId);
        if (!nestedModeTokenizationSupport) {
            this.enterMode(offsetDelta, nestedModeId);
            this.emit(offsetDelta, '');
            return embeddedModeState;
        }
        var nestedResult = nestedModeTokenizationSupport.tokenize2(embeddedModeLine, embeddedModeState, offsetDelta);
        this._prependTokens = MonarchModernTokensCollector._merge(this._prependTokens, this._tokens, nestedResult.tokens);
        this._tokens = [];
        this._currentLanguageId = 0;
        this._lastTokenMetadata = 0;
        return nestedResult.endState;
    };
    MonarchModernTokensCollector.prototype.finalize = function (endState) {
        return new TokenizationResult2(MonarchModernTokensCollector._merge(this._prependTokens, this._tokens, null), endState);
    };
    return MonarchModernTokensCollector;
}());
var MonarchTokenizer = /** @class */ (function () {
    function MonarchTokenizer(modeService, standaloneThemeService, modeId, lexer) {
        var _this = this;
        this._modeService = modeService;
        this._standaloneThemeService = standaloneThemeService;
        this._modeId = modeId;
        this._lexer = lexer;
        this._embeddedModes = Object.create(null);
        // Set up listening for embedded modes
        var emitting = false;
        this._tokenizationRegistryListener = TokenizationRegistry.onDidChange(function (e) {
            if (emitting) {
                return;
            }
            var isOneOfMyEmbeddedModes = false;
            for (var i = 0, len = e.changedLanguages.length; i < len; i++) {
                var language = e.changedLanguages[i];
                if (_this._embeddedModes[language]) {
                    isOneOfMyEmbeddedModes = true;
                    break;
                }
            }
            if (isOneOfMyEmbeddedModes) {
                emitting = true;
                TokenizationRegistry.fire([_this._modeId]);
                emitting = false;
            }
        });
    }
    MonarchTokenizer.prototype.dispose = function () {
        this._tokenizationRegistryListener.dispose();
    };
    MonarchTokenizer.prototype.getInitialState = function () {
        var rootState = MonarchStackElementFactory.create(null, this._lexer.start);
        return MonarchLineStateFactory.create(rootState, null);
    };
    MonarchTokenizer.prototype.tokenize = function (line, lineState, offsetDelta) {
        var tokensCollector = new MonarchClassicTokensCollector();
        var endLineState = this._tokenize(line, lineState, offsetDelta, tokensCollector);
        return tokensCollector.finalize(endLineState);
    };
    MonarchTokenizer.prototype.tokenize2 = function (line, lineState, offsetDelta) {
        var tokensCollector = new MonarchModernTokensCollector(this._modeService, this._standaloneThemeService.getTheme().tokenTheme);
        var endLineState = this._tokenize(line, lineState, offsetDelta, tokensCollector);
        return tokensCollector.finalize(endLineState);
    };
    MonarchTokenizer.prototype._tokenize = function (line, lineState, offsetDelta, collector) {
        if (lineState.embeddedModeData) {
            return this._nestedTokenize(line, lineState, offsetDelta, collector);
        }
        else {
            return this._myTokenize(line, lineState, offsetDelta, collector);
        }
    };
    MonarchTokenizer.prototype._findLeavingNestedModeOffset = function (line, state) {
        var rules = this._lexer.tokenizer[state.stack.state];
        if (!rules) {
            rules = findRules(this._lexer, state.stack.state); // do parent matching
            if (!rules) {
                throwError(this._lexer, 'tokenizer state is not defined: ' + state.stack.state);
            }
        }
        var popOffset = -1;
        var hasEmbeddedPopRule = false;
        for (var idx in rules) {
            if (!hasOwnProperty$3.call(rules, idx)) {
                continue;
            }
            var rule = rules[idx];
            if (!isIAction(rule.action) || rule.action.nextEmbedded !== '@pop') {
                continue;
            }
            hasEmbeddedPopRule = true;
            var regex = rule.regex;
            var regexSource = rule.regex.source;
            if (regexSource.substr(0, 4) === '^(?:' && regexSource.substr(regexSource.length - 1, 1) === ')') {
                regex = new RegExp(regexSource.substr(4, regexSource.length - 5), regex.ignoreCase ? 'i' : '');
            }
            var result = line.search(regex);
            if (result === -1) {
                continue;
            }
            if (popOffset === -1 || result < popOffset) {
                popOffset = result;
            }
        }
        if (!hasEmbeddedPopRule) {
            throwError(this._lexer, 'no rule containing nextEmbedded: "@pop" in tokenizer embedded state: ' + state.stack.state);
        }
        return popOffset;
    };
    MonarchTokenizer.prototype._nestedTokenize = function (line, lineState, offsetDelta, tokensCollector) {
        var popOffset = this._findLeavingNestedModeOffset(line, lineState);
        if (popOffset === -1) {
            // tokenization will not leave nested mode
            var nestedEndState = tokensCollector.nestedModeTokenize(line, lineState.embeddedModeData, offsetDelta);
            return MonarchLineStateFactory.create(lineState.stack, new EmbeddedModeData(lineState.embeddedModeData.modeId, nestedEndState));
        }
        var nestedModeLine = line.substring(0, popOffset);
        if (nestedModeLine.length > 0) {
            // tokenize with the nested mode
            tokensCollector.nestedModeTokenize(nestedModeLine, lineState.embeddedModeData, offsetDelta);
        }
        var restOfTheLine = line.substring(popOffset);
        return this._myTokenize(restOfTheLine, lineState, offsetDelta + popOffset, tokensCollector);
    };
    MonarchTokenizer.prototype._myTokenize = function (line, lineState, offsetDelta, tokensCollector) {
        tokensCollector.enterMode(offsetDelta, this._modeId);
        var lineLength = line.length;
        var embeddedModeData = lineState.embeddedModeData;
        var stack = lineState.stack;
        var pos = 0;
        // regular expression group matching
        // these never need cloning or equality since they are only used within a line match
        var groupActions = null;
        var groupMatches = null;
        var groupMatched = null;
        var groupRule = null;
        while (pos < lineLength) {
            var pos0 = pos;
            var stackLen0 = stack.depth;
            var groupLen0 = groupActions ? groupActions.length : 0;
            var state = stack.state;
            var matches = null;
            var matched = null;
            var action = null;
            var rule = null;
            var enteringEmbeddedMode = null;
            // check if we need to process group matches first
            if (groupActions) {
                matches = groupMatches;
                matched = groupMatched.shift();
                action = groupActions.shift();
                rule = groupRule;
                // cleanup if necessary
                if (groupActions.length === 0) {
                    groupActions = null;
                    groupMatches = null;
                    groupMatched = null;
                    groupRule = null;
                }
            }
            else {
                // otherwise we match on the token stream
                if (pos >= lineLength) {
                    // nothing to do
                    break;
                }
                // get the rules for this state
                var rules = this._lexer.tokenizer[state];
                if (!rules) {
                    rules = findRules(this._lexer, state); // do parent matching
                    if (!rules) {
                        throwError(this._lexer, 'tokenizer state is not defined: ' + state);
                    }
                }
                // try each rule until we match
                var restOfLine = line.substr(pos);
                for (var idx in rules) {
                    if (hasOwnProperty$3.call(rules, idx)) {
                        var rule_1 = rules[idx];
                        if (pos === 0 || !rule_1.matchOnlyAtLineStart) {
                            matches = restOfLine.match(rule_1.regex);
                            if (matches) {
                                matched = matches[0];
                                action = rule_1.action;
                                break;
                            }
                        }
                    }
                }
            }
            // We matched 'rule' with 'matches' and 'action'
            if (!matches) {
                matches = [''];
                matched = '';
            }
            if (!action) {
                // bad: we didn't match anything, and there is no action to take
                // we need to advance the stream or we get progress trouble
                if (pos < lineLength) {
                    matches = [line.charAt(pos)];
                    matched = matches[0];
                }
                action = this._lexer.defaultToken;
            }
            // advance stream
            pos += matched.length;
            // maybe call action function (used for 'cases')
            while (isFuzzyAction(action) && isIAction(action) && action.test) {
                action = action.test(matched, matches, state, pos === lineLength);
            }
            var result = null;
            // set the result: either a string or an array of actions
            if (typeof action === 'string' || Array.isArray(action)) {
                result = action;
            }
            else if (action.group) {
                result = action.group;
            }
            else if (action.token !== null && action.token !== undefined) {
                // do $n replacements?
                if (action.tokenSubst) {
                    result = substituteMatches(this._lexer, action.token, matched, matches, state);
                }
                else {
                    result = action.token;
                }
                // enter embedded mode?
                if (action.nextEmbedded) {
                    if (action.nextEmbedded === '@pop') {
                        if (!embeddedModeData) {
                            throwError(this._lexer, 'cannot pop embedded mode if not inside one');
                        }
                        embeddedModeData = null;
                    }
                    else if (embeddedModeData) {
                        throwError(this._lexer, 'cannot enter embedded mode from within an embedded mode');
                    }
                    else {
                        enteringEmbeddedMode = substituteMatches(this._lexer, action.nextEmbedded, matched, matches, state);
                    }
                }
                // state transformations
                if (action.goBack) { // back up the stream..
                    pos = Math.max(0, pos - action.goBack);
                }
                if (action.switchTo && typeof action.switchTo === 'string') {
                    var nextState = substituteMatches(this._lexer, action.switchTo, matched, matches, state); // switch state without a push...
                    if (nextState[0] === '@') {
                        nextState = nextState.substr(1); // peel off starting '@'
                    }
                    if (!findRules(this._lexer, nextState)) {
                        throwError(this._lexer, 'trying to switch to a state \'' + nextState + '\' that is undefined in rule: ' + rule.name);
                    }
                    else {
                        stack = stack.switchTo(nextState);
                    }
                }
                else if (action.transform && typeof action.transform === 'function') {
                    throwError(this._lexer, 'action.transform not supported');
                }
                else if (action.next) {
                    if (action.next === '@push') {
                        if (stack.depth >= this._lexer.maxStack) {
                            throwError(this._lexer, 'maximum tokenizer stack size reached: [' +
                                stack.state + ',' + stack.parent.state + ',...]');
                        }
                        else {
                            stack = stack.push(state);
                        }
                    }
                    else if (action.next === '@pop') {
                        if (stack.depth <= 1) {
                            throwError(this._lexer, 'trying to pop an empty stack in rule: ' + rule.name);
                        }
                        else {
                            stack = stack.pop();
                        }
                    }
                    else if (action.next === '@popall') {
                        stack = stack.popall();
                    }
                    else {
                        var nextState = substituteMatches(this._lexer, action.next, matched, matches, state);
                        if (nextState[0] === '@') {
                            nextState = nextState.substr(1); // peel off starting '@'
                        }
                        if (!findRules(this._lexer, nextState)) {
                            throwError(this._lexer, 'trying to set a next state \'' + nextState + '\' that is undefined in rule: ' + rule.name);
                        }
                        else {
                            stack = stack.push(nextState);
                        }
                    }
                }
                if (action.log && typeof (action.log) === 'string') {
                    log(this._lexer, this._lexer.languageId + ': ' + substituteMatches(this._lexer, action.log, matched, matches, state));
                }
            }
            // check result
            if (result === null) {
                throwError(this._lexer, 'lexer rule has no well-defined action in rule: ' + rule.name);
            }
            // is the result a group match?
            if (Array.isArray(result)) {
                if (groupActions && groupActions.length > 0) {
                    throwError(this._lexer, 'groups cannot be nested: ' + rule.name);
                }
                if (matches.length !== result.length + 1) {
                    throwError(this._lexer, 'matched number of groups does not match the number of actions in rule: ' + rule.name);
                }
                var totalLen = 0;
                for (var i = 1; i < matches.length; i++) {
                    totalLen += matches[i].length;
                }
                if (totalLen !== matched.length) {
                    throwError(this._lexer, 'with groups, all characters should be matched in consecutive groups in rule: ' + rule.name);
                }
                groupMatches = matches;
                groupMatched = matches.slice(1);
                groupActions = result.slice(0);
                groupRule = rule;
                pos -= matched.length;
                // call recursively to initiate first result match
                continue;
            }
            else {
                // regular result
                // check for '@rematch'
                if (result === '@rematch') {
                    pos -= matched.length;
                    matched = ''; // better set the next state too..
                    matches = null;
                    result = '';
                }
                // check progress
                if (matched.length === 0) {
                    if (stackLen0 !== stack.depth || state !== stack.state || (!groupActions ? 0 : groupActions.length) !== groupLen0) {
                        continue;
                    }
                    else {
                        throwError(this._lexer, 'no progress in tokenizer in rule: ' + rule.name);
                        pos = lineLength; // must make progress or editor loops
                    }
                }
                // return the result (and check for brace matching)
                // todo: for efficiency we could pre-sanitize tokenPostfix and substitutions
                var tokenType = null;
                if (isString$1(result) && result.indexOf('@brackets') === 0) {
                    var rest = result.substr('@brackets'.length);
                    var bracket = findBracket(this._lexer, matched);
                    if (!bracket) {
                        throwError(this._lexer, '@brackets token returned but no bracket defined as: ' + matched);
                        bracket = { token: '', bracketType: 0 /* None */ };
                    }
                    tokenType = sanitize(bracket.token + rest);
                }
                else {
                    var token = (result === '' ? '' : result + this._lexer.tokenPostfix);
                    tokenType = sanitize(token);
                }
                tokensCollector.emit(pos0 + offsetDelta, tokenType);
            }
            if (enteringEmbeddedMode !== null) {
                // substitute language alias to known modes to support syntax highlighting
                var enteringEmbeddedModeId = this._modeService.getModeIdForLanguageName(enteringEmbeddedMode);
                if (enteringEmbeddedModeId) {
                    enteringEmbeddedMode = enteringEmbeddedModeId;
                }
                var embeddedModeData_1 = this._getNestedEmbeddedModeData(enteringEmbeddedMode);
                if (pos < lineLength) {
                    // there is content from the embedded mode on this line
                    var restOfLine = line.substr(pos);
                    return this._nestedTokenize(restOfLine, MonarchLineStateFactory.create(stack, embeddedModeData_1), offsetDelta + pos, tokensCollector);
                }
                else {
                    return MonarchLineStateFactory.create(stack, embeddedModeData_1);
                }
            }
        }
        return MonarchLineStateFactory.create(stack, embeddedModeData);
    };
    MonarchTokenizer.prototype._getNestedEmbeddedModeData = function (mimetypeOrModeId) {
        var nestedMode = this._locateMode(mimetypeOrModeId);
        if (nestedMode) {
            var tokenizationSupport = TokenizationRegistry.get(nestedMode.getId());
            if (tokenizationSupport) {
                return new EmbeddedModeData(nestedMode.getId(), tokenizationSupport.getInitialState());
            }
        }
        var nestedModeId = nestedMode ? nestedMode.getId() : NULL_MODE_ID;
        return new EmbeddedModeData(nestedModeId, NULL_STATE);
    };
    MonarchTokenizer.prototype._locateMode = function (mimetypeOrModeId) {
        if (!mimetypeOrModeId || !this._modeService.isRegisteredMode(mimetypeOrModeId)) {
            return null;
        }
        var modeId = this._modeService.getModeId(mimetypeOrModeId);
        // Fire mode loading event
        this._modeService.getOrCreateMode(modeId);
        var mode = this._modeService.getMode(modeId);
        if (mode) {
            // Re-emit tokenizationSupport change events from all modes that I ever embedded
            this._embeddedModes[modeId] = true;
            return mode;
        }
        this._embeddedModes[modeId] = true;
        return null;
    };
    return MonarchTokenizer;
}());
/**
 * Searches for a bracket in the 'brackets' attribute that matches the input.
 */
function findBracket(lexer, matched) {
    if (!matched) {
        return null;
    }
    matched = fixCase(lexer, matched);
    var brackets = lexer.brackets;
    for (var i = 0; i < brackets.length; i++) {
        var bracket = brackets[i];
        if (bracket.open === matched) {
            return { token: bracket.token, bracketType: 1 /* Open */ };
        }
        else if (bracket.close === matched) {
            return { token: bracket.token, bracketType: -1 /* Close */ };
        }
    }
    return null;
}
function createTokenizationSupport(modeService, standaloneThemeService, modeId, lexer) {
    return new MonarchTokenizer(modeService, standaloneThemeService, modeId, lexer);
}

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
/**
 * Register information about a new language.
 */
function register(language) {
    ModesRegistry.registerLanguage(language);
}
/**
 * Get the information of all the registered languages.
 */
function getLanguages() {
    var result = [];
    result = result.concat(ModesRegistry.getLanguages());
    return result;
}
/**
 * An event emitted when a language is first time needed (e.g. a model has it set).
 * @event
 */
function onLanguage(languageId, callback) {
    var disposable = StaticServices.modeService.get().onDidCreateMode(function (mode) {
        if (mode.getId() === languageId) {
            // stop listening
            disposable.dispose();
            // invoke actual listener
            callback();
        }
    });
    return disposable;
}
/**
 * Set the editing configuration for a language.
 */
function setLanguageConfiguration(languageId, configuration) {
    var languageIdentifier = StaticServices.modeService.get().getLanguageIdentifier(languageId);
    if (!languageIdentifier) {
        throw new Error("Cannot set configuration for unknown language " + languageId);
    }
    return LanguageConfigurationRegistry.register(languageIdentifier, configuration);
}
/**
 * @internal
 */
var TokenizationSupport2Adapter = /** @class */ (function () {
    function TokenizationSupport2Adapter(standaloneThemeService, languageIdentifier, actual) {
        this._standaloneThemeService = standaloneThemeService;
        this._languageIdentifier = languageIdentifier;
        this._actual = actual;
    }
    TokenizationSupport2Adapter.prototype.getInitialState = function () {
        return this._actual.getInitialState();
    };
    TokenizationSupport2Adapter.prototype._toClassicTokens = function (tokens, language, offsetDelta) {
        var result = [];
        var previousStartIndex = 0;
        for (var i = 0, len = tokens.length; i < len; i++) {
            var t = tokens[i];
            var startIndex = t.startIndex;
            // Prevent issues stemming from a buggy external tokenizer.
            if (i === 0) {
                // Force first token to start at first index!
                startIndex = 0;
            }
            else if (startIndex < previousStartIndex) {
                // Force tokens to be after one another!
                startIndex = previousStartIndex;
            }
            result[i] = new Token(startIndex + offsetDelta, t.scopes, language);
            previousStartIndex = startIndex;
        }
        return result;
    };
    TokenizationSupport2Adapter.prototype.tokenize = function (line, state, offsetDelta) {
        var actualResult = this._actual.tokenize(line, state);
        var tokens = this._toClassicTokens(actualResult.tokens, this._languageIdentifier.language, offsetDelta);
        var endState;
        // try to save an object if possible
        if (actualResult.endState.equals(state)) {
            endState = state;
        }
        else {
            endState = actualResult.endState;
        }
        return new TokenizationResult(tokens, endState);
    };
    TokenizationSupport2Adapter.prototype._toBinaryTokens = function (tokens, offsetDelta) {
        var languageId = this._languageIdentifier.id;
        var tokenTheme = this._standaloneThemeService.getTheme().tokenTheme;
        var result = [], resultLen = 0;
        var previousStartIndex = 0;
        for (var i = 0, len = tokens.length; i < len; i++) {
            var t = tokens[i];
            var metadata = tokenTheme.match(languageId, t.scopes);
            if (resultLen > 0 && result[resultLen - 1] === metadata) {
                // same metadata
                continue;
            }
            var startIndex = t.startIndex;
            // Prevent issues stemming from a buggy external tokenizer.
            if (i === 0) {
                // Force first token to start at first index!
                startIndex = 0;
            }
            else if (startIndex < previousStartIndex) {
                // Force tokens to be after one another!
                startIndex = previousStartIndex;
            }
            result[resultLen++] = startIndex + offsetDelta;
            result[resultLen++] = metadata;
            previousStartIndex = startIndex;
        }
        var actualResult = new Uint32Array(resultLen);
        for (var i = 0; i < resultLen; i++) {
            actualResult[i] = result[i];
        }
        return actualResult;
    };
    TokenizationSupport2Adapter.prototype.tokenize2 = function (line, state, offsetDelta) {
        var actualResult = this._actual.tokenize(line, state);
        var tokens = this._toBinaryTokens(actualResult.tokens, offsetDelta);
        var endState;
        // try to save an object if possible
        if (actualResult.endState.equals(state)) {
            endState = state;
        }
        else {
            endState = actualResult.endState;
        }
        return new TokenizationResult2(tokens, endState);
    };
    return TokenizationSupport2Adapter;
}());
/**
 * Set the tokens provider for a language (manual implementation).
 */
function setTokensProvider(languageId, provider) {
    var languageIdentifier = StaticServices.modeService.get().getLanguageIdentifier(languageId);
    if (!languageIdentifier) {
        throw new Error("Cannot set tokens provider for unknown language " + languageId);
    }
    var adapter = new TokenizationSupport2Adapter(StaticServices.standaloneThemeService.get(), languageIdentifier, provider);
    return TokenizationRegistry.register(languageId, adapter);
}
/**
 * Set the tokens provider for a language (monarch implementation).
 */
function setMonarchTokensProvider(languageId, languageDef) {
    var lexer = compile(languageId, languageDef);
    var adapter = createTokenizationSupport(StaticServices.modeService.get(), StaticServices.standaloneThemeService.get(), languageId, lexer);
    return TokenizationRegistry.register(languageId, adapter);
}
/**
 * Register a reference provider (used by e.g. reference search).
 */
function registerReferenceProvider(languageId, provider) {
    return ReferenceProviderRegistry.register(languageId, provider);
}
/**
 * Register a rename provider (used by e.g. rename symbol).
 */
function registerRenameProvider(languageId, provider) {
    return RenameProviderRegistry.register(languageId, provider);
}
/**
 * Register a signature help provider (used by e.g. paremeter hints).
 */
function registerSignatureHelpProvider(languageId, provider) {
    return SignatureHelpProviderRegistry.register(languageId, provider);
}
/**
 * Register a hover provider (used by e.g. editor hover).
 */
function registerHoverProvider(languageId, provider) {
    return HoverProviderRegistry.register(languageId, {
        provideHover: function (model, position, token) {
            var word = model.getWordAtPosition(position);
            return toPromiseLike(provider.provideHover(model, position, token)).then(function (value) {
                if (!value) {
                    return undefined;
                }
                if (!value.range && word) {
                    value.range = new Range(position.lineNumber, word.startColumn, position.lineNumber, word.endColumn);
                }
                if (!value.range) {
                    value.range = new Range(position.lineNumber, position.column, position.lineNumber, position.column);
                }
                return value;
            });
        }
    });
}
/**
 * Register a document symbol provider (used by e.g. outline).
 */
function registerDocumentSymbolProvider(languageId, provider) {
    return DocumentSymbolProviderRegistry.register(languageId, provider);
}
/**
 * Register a document highlight provider (used by e.g. highlight occurrences).
 */
function registerDocumentHighlightProvider(languageId, provider) {
    return DocumentHighlightProviderRegistry.register(languageId, provider);
}
/**
 * Register a definition provider (used by e.g. go to definition).
 */
function registerDefinitionProvider(languageId, provider) {
    return DefinitionProviderRegistry.register(languageId, provider);
}
/**
 * Register a implementation provider (used by e.g. go to implementation).
 */
function registerImplementationProvider(languageId, provider) {
    return ImplementationProviderRegistry.register(languageId, provider);
}
/**
 * Register a type definition provider (used by e.g. go to type definition).
 */
function registerTypeDefinitionProvider(languageId, provider) {
    return TypeDefinitionProviderRegistry.register(languageId, provider);
}
/**
 * Register a code lens provider (used by e.g. inline code lenses).
 */
function registerCodeLensProvider(languageId, provider) {
    return CodeLensProviderRegistry.register(languageId, provider);
}
/**
 * Register a code action provider (used by e.g. quick fix).
 */
function registerCodeActionProvider(languageId, provider) {
    return CodeActionProviderRegistry.register(languageId, {
        provideCodeActions: function (model, range, context, token) {
            var markers = StaticServices.markerService.get().read({ resource: model.uri }).filter(function (m) {
                return Range.areIntersectingOrTouching(m, range);
            });
            return provider.provideCodeActions(model, range, { markers: markers, only: context.only }, token);
        }
    });
}
/**
 * Register a formatter that can handle only entire models.
 */
function registerDocumentFormattingEditProvider(languageId, provider) {
    return DocumentFormattingEditProviderRegistry.register(languageId, provider);
}
/**
 * Register a formatter that can handle a range inside a model.
 */
function registerDocumentRangeFormattingEditProvider(languageId, provider) {
    return DocumentRangeFormattingEditProviderRegistry.register(languageId, provider);
}
/**
 * Register a formatter than can do formatting as the user types.
 */
function registerOnTypeFormattingEditProvider(languageId, provider) {
    return OnTypeFormattingEditProviderRegistry.register(languageId, provider);
}
/**
 * Register a link provider that can find links in text.
 */
function registerLinkProvider(languageId, provider) {
    return LinkProviderRegistry.register(languageId, provider);
}
/**
 * Register a completion item provider (use by e.g. suggestions).
 */
function registerCompletionItemProvider(languageId, provider) {
    var adapter = new SuggestAdapter(provider);
    return SuggestRegistry.register(languageId, {
        triggerCharacters: provider.triggerCharacters,
        provideCompletionItems: function (model, position, context, token) {
            return adapter.provideCompletionItems(model, position, context, token);
        },
        resolveCompletionItem: function (model, position, suggestion, token) {
            return adapter.resolveCompletionItem(model, position, suggestion, token);
        }
    });
}
/**
 * Register a document color provider (used by Color Picker, Color Decorator).
 */
function registerColorProvider(languageId, provider) {
    return ColorProviderRegistry.register(languageId, provider);
}
/**
 * Register a folding range provider
 */
function registerFoldingRangeProvider(languageId, provider) {
    return FoldingRangeProviderRegistry.register(languageId, provider);
}
/**
 * Completion item kinds.
 */
var CompletionItemKind;
(function (CompletionItemKind) {
    CompletionItemKind[CompletionItemKind["Text"] = 0] = "Text";
    CompletionItemKind[CompletionItemKind["Method"] = 1] = "Method";
    CompletionItemKind[CompletionItemKind["Function"] = 2] = "Function";
    CompletionItemKind[CompletionItemKind["Constructor"] = 3] = "Constructor";
    CompletionItemKind[CompletionItemKind["Field"] = 4] = "Field";
    CompletionItemKind[CompletionItemKind["Variable"] = 5] = "Variable";
    CompletionItemKind[CompletionItemKind["Class"] = 6] = "Class";
    CompletionItemKind[CompletionItemKind["Interface"] = 7] = "Interface";
    CompletionItemKind[CompletionItemKind["Module"] = 8] = "Module";
    CompletionItemKind[CompletionItemKind["Property"] = 9] = "Property";
    CompletionItemKind[CompletionItemKind["Unit"] = 10] = "Unit";
    CompletionItemKind[CompletionItemKind["Value"] = 11] = "Value";
    CompletionItemKind[CompletionItemKind["Enum"] = 12] = "Enum";
    CompletionItemKind[CompletionItemKind["Keyword"] = 13] = "Keyword";
    CompletionItemKind[CompletionItemKind["Snippet"] = 14] = "Snippet";
    CompletionItemKind[CompletionItemKind["Color"] = 15] = "Color";
    CompletionItemKind[CompletionItemKind["File"] = 16] = "File";
    CompletionItemKind[CompletionItemKind["Reference"] = 17] = "Reference";
    CompletionItemKind[CompletionItemKind["Folder"] = 18] = "Folder";
})(CompletionItemKind || (CompletionItemKind = {}));
function convertKind(kind) {
    switch (kind) {
        case CompletionItemKind.Method: return 'method';
        case CompletionItemKind.Function: return 'function';
        case CompletionItemKind.Constructor: return 'constructor';
        case CompletionItemKind.Field: return 'field';
        case CompletionItemKind.Variable: return 'variable';
        case CompletionItemKind.Class: return 'class';
        case CompletionItemKind.Interface: return 'interface';
        case CompletionItemKind.Module: return 'module';
        case CompletionItemKind.Property: return 'property';
        case CompletionItemKind.Unit: return 'unit';
        case CompletionItemKind.Value: return 'value';
        case CompletionItemKind.Enum: return 'enum';
        case CompletionItemKind.Keyword: return 'keyword';
        case CompletionItemKind.Snippet: return 'snippet';
        case CompletionItemKind.Text: return 'text';
        case CompletionItemKind.Color: return 'color';
        case CompletionItemKind.File: return 'file';
        case CompletionItemKind.Reference: return 'reference';
        case CompletionItemKind.Folder: return 'folder';
    }
    return 'property';
}
var SuggestAdapter = /** @class */ (function () {
    function SuggestAdapter(provider) {
        this._provider = provider;
    }
    SuggestAdapter.from = function (item, position, wordStartPos) {
        var suggestion = {
            _actual: item,
            label: item.label,
            insertText: item.label,
            type: convertKind(item.kind),
            detail: item.detail,
            documentation: item.documentation,
            command: item.command,
            sortText: item.sortText,
            filterText: item.filterText,
            snippetType: 'internal',
            additionalTextEdits: item.additionalTextEdits,
            commitCharacters: item.commitCharacters
        };
        var editRange = item.textEdit ? item.textEdit.range : item.range;
        if (editRange) {
            var isSingleLine = (editRange.startLineNumber === editRange.endLineNumber);
            // invalid text edit
            if (!isSingleLine || editRange.startLineNumber !== position.lineNumber) {
                console.warn('INVALID range, must be single line and on the same line');
                return null;
            }
            // insert the text of the edit and create a dedicated
            // suggestion-container with overwrite[Before|After]
            suggestion.overwriteBefore = position.column - editRange.startColumn;
            suggestion.overwriteAfter = editRange.endColumn - position.column;
        }
        else {
            suggestion.overwriteBefore = position.column - wordStartPos.column;
            suggestion.overwriteAfter = 0;
        }
        if (item.textEdit) {
            suggestion.insertText = item.textEdit.text;
        }
        else if (typeof item.insertText === 'object' && typeof item.insertText.value === 'string') {
            suggestion.insertText = item.insertText.value;
            suggestion.snippetType = 'textmate';
        }
        else if (typeof item.insertText === 'string') {
            suggestion.insertText = item.insertText;
        }
        return suggestion;
    };
    SuggestAdapter.prototype.provideCompletionItems = function (model, position, context, token) {
        var result = this._provider.provideCompletionItems(model, position, token, context);
        return toPromiseLike(result).then(function (value) {
            var result = {
                suggestions: []
            };
            // default text edit start
            var wordStartPos = position;
            var word = model.getWordUntilPosition(position);
            if (word) {
                wordStartPos = new Position(wordStartPos.lineNumber, word.startColumn);
            }
            var list;
            if (Array.isArray(value)) {
                list = {
                    items: value,
                    isIncomplete: false
                };
            }
            else if (typeof value === 'object' && Array.isArray(value.items)) {
                list = value;
                result.incomplete = list.isIncomplete;
            }
            else if (!value) {
                // undefined and null are valid results
                return undefined;
            }
            else {
                // warn about everything else
                console.warn('INVALID result from completion provider. expected CompletionItem-array or CompletionList but got:', value);
            }
            for (var i = 0; i < list.items.length; i++) {
                var item = list.items[i];
                var suggestion = SuggestAdapter.from(item, position, wordStartPos);
                if (suggestion) {
                    result.suggestions.push(suggestion);
                }
            }
            return result;
        });
    };
    SuggestAdapter.prototype.resolveCompletionItem = function (model, position, suggestion, token) {
        if (typeof this._provider.resolveCompletionItem !== 'function') {
            return TPromise.as(suggestion);
        }
        var item = suggestion._actual;
        if (!item) {
            return TPromise.as(suggestion);
        }
        return toPromiseLike(this._provider.resolveCompletionItem(item, token)).then(function (resolvedItem) {
            var wordStartPos = position;
            var word = model.getWordUntilPosition(position);
            if (word) {
                wordStartPos = new Position(wordStartPos.lineNumber, word.startColumn);
            }
            return SuggestAdapter.from(resolvedItem, position, wordStartPos);
        });
    };
    return SuggestAdapter;
}());
/**
 * @internal
 */
function createMonacoLanguagesAPI() {
    return {
        register: register,
        getLanguages: getLanguages,
        onLanguage: onLanguage,
        // provider methods
        setLanguageConfiguration: setLanguageConfiguration,
        setTokensProvider: setTokensProvider,
        setMonarchTokensProvider: setMonarchTokensProvider,
        registerReferenceProvider: registerReferenceProvider,
        registerRenameProvider: registerRenameProvider,
        registerCompletionItemProvider: registerCompletionItemProvider,
        registerSignatureHelpProvider: registerSignatureHelpProvider,
        registerHoverProvider: registerHoverProvider,
        registerDocumentSymbolProvider: registerDocumentSymbolProvider,
        registerDocumentHighlightProvider: registerDocumentHighlightProvider,
        registerDefinitionProvider: registerDefinitionProvider,
        registerImplementationProvider: registerImplementationProvider,
        registerTypeDefinitionProvider: registerTypeDefinitionProvider,
        registerCodeLensProvider: registerCodeLensProvider,
        registerCodeActionProvider: registerCodeActionProvider,
        registerDocumentFormattingEditProvider: registerDocumentFormattingEditProvider,
        registerDocumentRangeFormattingEditProvider: registerDocumentRangeFormattingEditProvider,
        registerOnTypeFormattingEditProvider: registerOnTypeFormattingEditProvider,
        registerLinkProvider: registerLinkProvider,
        registerColorProvider: registerColorProvider,
        registerFoldingRangeProvider: registerFoldingRangeProvider,
        // enums
        DocumentHighlightKind: DocumentHighlightKind,
        CompletionItemKind: CompletionItemKind,
        SymbolKind: SymbolKind,
        IndentAction: IndentAction,
        SuggestTriggerKind: SuggestTriggerKind,
        FoldingRangeKind: FoldingRangeKind
    };
}

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
/**
 * A polyfill for the native promises. The implementation is based on
 * WinJS promises but tries to gap differences between winjs promises
 * and native promises.
 */
var PolyfillPromise = /** @class */ (function () {
    function PolyfillPromise(initOrPromise) {
        if (Promise$1.is(initOrPromise)) {
            this._winjsPromise = initOrPromise;
        }
        else {
            this._winjsPromise = new Promise$1(function (resolve, reject) {
                var initializing = true;
                initOrPromise(function (value) {
                    if (!initializing) {
                        resolve(value);
                    }
                    else {
                        setImmediate(function () { return resolve(value); });
                    }
                }, function (err) {
                    if (!initializing) {
                        reject(err);
                    }
                    else {
                        setImmediate(function () { return reject(err); });
                    }
                });
                initializing = false;
            });
        }
    }
    PolyfillPromise.all = function (thenables) {
        return new PolyfillPromise(Promise$1.join(thenables).then(null, function (values) {
            // WinJSPromise returns a sparse array whereas
            // native promises return the *first* error
            for (var key in values) {
                if (values.hasOwnProperty(key)) {
                    return values[key];
                }
            }
        }));
    };
    PolyfillPromise.race = function (thenables) {
        // WinJSPromise returns `{ key: <index/key>, value: <promise> }`
        // from the `any` call and Promise.race just wants the value
        return new PolyfillPromise(Promise$1.any(thenables).then(function (entry) { return entry.value; }, function (err) { return err.value; }));
    };
    PolyfillPromise.resolve = function (value) {
        return new PolyfillPromise(Promise$1.wrap(value));
    };
    PolyfillPromise.reject = function (value) {
        return new PolyfillPromise(Promise$1.wrapError(value));
    };
    PolyfillPromise.prototype.then = function (onFulfilled, onRejected) {
        var sync = true;
        var promise = new PolyfillPromise(this._winjsPromise.then(onFulfilled && function (value) {
            if (!sync) {
                onFulfilled(value);
            }
            else {
                setImmediate(function () { return onFulfilled(value); });
            }
        }, onRejected && function (err) {
            if (!sync) {
                onRejected(err);
            }
            else {
                setImmediate(function () { return onRejected(err); });
            }
        }));
        sync = false;
        return promise;
    };
    PolyfillPromise.prototype.catch = function (onRejected) {
        return this.then(null, onRejected);
    };
    return PolyfillPromise;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var global$1 = self;
// When missing, polyfill the native promise
// with our winjs-based polyfill
if (typeof global$1.Promise === 'undefined') {
    global$1.Promise = PolyfillPromise;
}
// Set defaults for standalone editor
EDITOR_DEFAULTS.wrappingIndent = WrappingIndent.None;
EDITOR_DEFAULTS.viewInfo.glyphMargin = false;
EDITOR_DEFAULTS.autoIndent = false;
var api = createMonacoBaseAPI();
api.editor = createMonacoEditorAPI();
api.languages = createMonacoLanguagesAPI();
var CancellationTokenSource = api.CancellationTokenSource;
var Emitter$1 = api.Emitter;
var KeyCode = api.KeyCode;
var KeyMod = api.KeyMod;
var Position$2 = api.Position;
var Range$1 = api.Range;
var Selection$1 = api.Selection;
var SelectionDirection$1 = api.SelectionDirection;
var Severity$3 = api.Severity;
var MarkerSeverity$1 = api.MarkerSeverity;
var Promise$2 = api.Promise;
var Uri = api.Uri;
var Token$1 = api.Token;
var editor = api.editor;
var languages = api.languages;
global$1.monaco = api;
if (typeof global$1.require !== 'undefined' && typeof global$1.require.config === 'function') {
    global$1.require.config({
        ignoreDuplicateModules: [
            'vscode-languageserver-types',
            'vscode-languageserver-types/main',
            'vscode-nls',
            'vscode-nls/vscode-nls',
            'jsonc-parser',
            'jsonc-parser/main',
            'vscode-uri',
            'vscode-uri/index'
        ]
    });
}

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// Allow for running under nodejs/requirejs in tests
var _monaco = (typeof monaco === 'undefined' ? self.monaco : monaco);
var languageDefinitions = {};
function _loadLanguage(languageId) {
    var loader = languageDefinitions[languageId].loader;
    return loader().then(function (mod) {
        _monaco.languages.setMonarchTokensProvider(languageId, mod.language);
        _monaco.languages.setLanguageConfiguration(languageId, mod.conf);
    });
}
var languagePromises = {};
function loadLanguage(languageId) {
    if (!languagePromises[languageId]) {
        languagePromises[languageId] = _loadLanguage(languageId);
    }
    return languagePromises[languageId];
}
function registerLanguage(def) {
    var languageId = def.id;
    languageDefinitions[languageId] = def;
    _monaco.languages.register(def);
    _monaco.languages.onLanguage(languageId, function () {
        loadLanguage(languageId);
    });
}

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// Allow for running under nodejs/requirejs in tests
var _monaco$1 = (typeof monaco === 'undefined' ? self.monaco : monaco);
registerLanguage({
    id: 'bat',
    extensions: ['.bat', '.cmd'],
    aliases: ['Batch', 'bat'],
    loader: function () { return _monaco$1.Promise.wrap(import("../languages/bat.js")); }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// Allow for running under nodejs/requirejs in tests
var _monaco$2 = (typeof monaco === 'undefined' ? self.monaco : monaco);
registerLanguage({
    id: 'coffeescript',
    extensions: ['.coffee'],
    aliases: ['CoffeeScript', 'coffeescript', 'coffee'],
    mimetypes: ['text/x-coffeescript', 'text/coffeescript'],
    loader: function () { return _monaco$2.Promise.wrap(import("../languages/coffee.js")); }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// Allow for running under nodejs/requirejs in tests
var _monaco$3 = (typeof monaco === 'undefined' ? self.monaco : monaco);
registerLanguage({
    id: 'c',
    extensions: ['.c', '.h'],
    aliases: ['C', 'c'],
    loader: function () { return _monaco$3.Promise.wrap(import("../languages/cpp.js")); }
});
registerLanguage({
    id: 'cpp',
    extensions: ['.cpp', '.cc', '.cxx', '.hpp', '.hh', '.hxx'],
    aliases: ['C++', 'Cpp', 'cpp'],
    loader: function () { return _monaco$3.Promise.wrap(import("../languages/cpp.js")); }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// Allow for running under nodejs/requirejs in tests
var _monaco$4 = (typeof monaco === 'undefined' ? self.monaco : monaco);
registerLanguage({
    id: 'csharp',
    extensions: ['.cs', '.csx'],
    aliases: ['C#', 'csharp'],
    loader: function () { return _monaco$4.Promise.wrap(import("../languages/csharp.js")); }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// Allow for running under nodejs/requirejs in tests
var _monaco$5 = (typeof monaco === 'undefined' ? self.monaco : monaco);
registerLanguage({
    id: 'csp',
    extensions: [],
    aliases: ['CSP', 'csp'],
    loader: function () { return _monaco$5.Promise.wrap(import("../languages/csp.js")); }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// Allow for running under nodejs/requirejs in tests
var _monaco$6 = (typeof monaco === 'undefined' ? self.monaco : monaco);
registerLanguage({
    id: 'css',
    extensions: ['.css'],
    aliases: ['CSS', 'css'],
    mimetypes: ['text/css'],
    loader: function () { return _monaco$6.Promise.wrap(import("../languages/css.js")); }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// Allow for running under nodejs/requirejs in tests
var _monaco$7 = (typeof monaco === 'undefined' ? self.monaco : monaco);
registerLanguage({
    id: 'dockerfile',
    extensions: ['.dockerfile'],
    filenames: ['Dockerfile'],
    aliases: ['Dockerfile'],
    loader: function () { return _monaco$7.Promise.wrap(import("../languages/dockerfile.js")); }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// Allow for running under nodejs/requirejs in tests
var _monaco$8 = (typeof monaco === 'undefined' ? self.monaco : monaco);
registerLanguage({
    id: 'fsharp',
    extensions: ['.fs', '.fsi', '.ml', '.mli', '.fsx', '.fsscript'],
    aliases: ['F#', 'FSharp', 'fsharp'],
    loader: function () { return _monaco$8.Promise.wrap(import("../languages/fsharp.js")); }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// Allow for running under nodejs/requirejs in tests
var _monaco$9 = (typeof monaco === 'undefined' ? self.monaco : monaco);
registerLanguage({
    id: 'go',
    extensions: ['.go'],
    aliases: ['Go'],
    loader: function () { return _monaco$9.Promise.wrap(import("../languages/go.js")); }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// Allow for running under nodejs/requirejs in tests
var _monaco$a = (typeof monaco === 'undefined' ? self.monaco : monaco);
registerLanguage({
    id: 'handlebars',
    extensions: ['.handlebars', '.hbs'],
    aliases: ['Handlebars', 'handlebars'],
    mimetypes: ['text/x-handlebars-template'],
    loader: function () { return _monaco$a.Promise.wrap(import("../languages/handlebars.js")); }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// Allow for running under nodejs/requirejs in tests
var _monaco$b = (typeof monaco === 'undefined' ? self.monaco : monaco);
registerLanguage({
    id: 'html',
    extensions: ['.html', '.htm', '.shtml', '.xhtml', '.mdoc', '.jsp', '.asp', '.aspx', '.jshtm'],
    aliases: ['HTML', 'htm', 'html', 'xhtml'],
    mimetypes: ['text/html', 'text/x-jshtm', 'text/template', 'text/ng-template'],
    loader: function () { return _monaco$b.Promise.wrap(import("../languages/html.js")); }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// Allow for running under nodejs/requirejs in tests
var _monaco$c = (typeof monaco === 'undefined' ? self.monaco : monaco);
registerLanguage({
    id: 'ini',
    extensions: ['.ini', '.properties', '.gitconfig'],
    filenames: ['config', '.gitattributes', '.gitconfig', '.editorconfig'],
    aliases: ['Ini', 'ini'],
    loader: function () { return _monaco$c.Promise.wrap(import("../languages/ini.js")); }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// Allow for running under nodejs/requirejs in tests
var _monaco$d = (typeof monaco === 'undefined' ? self.monaco : monaco);
registerLanguage({
    id: 'java',
    extensions: ['.java', '.jav'],
    aliases: ['Java', 'java'],
    mimetypes: ['text/x-java-source', 'text/x-java'],
    loader: function () { return _monaco$d.Promise.wrap(import("../languages/java.js")); }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// Allow for running under nodejs/requirejs in tests
var _monaco$e = (typeof monaco === 'undefined' ? self.monaco : monaco);
registerLanguage({
    id: 'less',
    extensions: ['.less'],
    aliases: ['Less', 'less'],
    mimetypes: ['text/x-less', 'text/less'],
    loader: function () { return _monaco$e.Promise.wrap(import("../languages/less.js")); }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// Allow for running under nodejs/requirejs in tests
var _monaco$f = (typeof monaco === 'undefined' ? self.monaco : monaco);
registerLanguage({
    id: 'lua',
    extensions: ['.lua'],
    aliases: ['Lua', 'lua'],
    loader: function () { return _monaco$f.Promise.wrap(import("../languages/lua.js")); }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// Allow for running under nodejs/requirejs in tests
var _monaco$g = (typeof monaco === 'undefined' ? self.monaco : monaco);
registerLanguage({
    id: 'markdown',
    extensions: ['.md', '.markdown', '.mdown', '.mkdn', '.mkd', '.mdwn', '.mdtxt', '.mdtext'],
    aliases: ['Markdown', 'markdown'],
    loader: function () { return _monaco$g.Promise.wrap(import("../languages/markdown.js")); }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// Allow for running under nodejs/requirejs in tests
var _monaco$h = (typeof monaco === 'undefined' ? self.monaco : monaco);
registerLanguage({
    id: 'msdax',
    extensions: ['.dax', '.msdax'],
    aliases: ['DAX', 'MSDAX'],
    loader: function () { return _monaco$h.Promise.wrap(import("../languages/msdax.js")); }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// Allow for running under nodejs/requirejs in tests
var _monaco$i = (typeof monaco === 'undefined' ? self.monaco : monaco);
registerLanguage({
    id: 'mysql',
    extensions: [],
    aliases: ['MySQL', 'mysql'],
    loader: function () { return _monaco$i.Promise.wrap(import("../languages/mysql.js")); }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// Allow for running under nodejs/requirejs in tests
var _monaco$j = (typeof monaco === 'undefined' ? self.monaco : monaco);
registerLanguage({
    id: 'objective-c',
    extensions: ['.m'],
    aliases: ['Objective-C'],
    loader: function () { return _monaco$j.Promise.wrap(import("../languages/objective-c.js")); }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// Allow for running under nodejs/requirejs in tests
var _monaco$k = (typeof monaco === 'undefined' ? self.monaco : monaco);
registerLanguage({
    id: 'pgsql',
    extensions: [],
    aliases: ['PostgreSQL', 'postgres', 'pg', 'postgre'],
    loader: function () { return _monaco$k.Promise.wrap(import("../languages/pgsql.js")); }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// Allow for running under nodejs/requirejs in tests
var _monaco$l = (typeof monaco === 'undefined' ? self.monaco : monaco);
registerLanguage({
    id: 'php',
    extensions: ['.php', '.php4', '.php5', '.phtml', '.ctp'],
    aliases: ['PHP', 'php'],
    mimetypes: ['application/x-php'],
    loader: function () { return _monaco$l.Promise.wrap(import("../languages/php.js")); }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// Allow for running under nodejs/requirejs in tests
var _monaco$m = (typeof monaco === 'undefined' ? self.monaco : monaco);
registerLanguage({
    id: 'postiats',
    extensions: ['.dats', '.sats', '.hats'],
    aliases: ['ATS', 'ATS/Postiats'],
    loader: function () { return _monaco$m.Promise.wrap(import("../languages/postiats.js")); }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// Allow for running under nodejs/requirejs in tests
var _monaco$n = (typeof monaco === 'undefined' ? self.monaco : monaco);
registerLanguage({
    id: 'powershell',
    extensions: ['.ps1', '.psm1', '.psd1'],
    aliases: ['PowerShell', 'powershell', 'ps', 'ps1'],
    loader: function () { return _monaco$n.Promise.wrap(import("../languages/powershell.js")); }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// Allow for running under nodejs/requirejs in tests
var _monaco$o = (typeof monaco === 'undefined' ? self.monaco : monaco);
registerLanguage({
    id: 'pug',
    extensions: ['.jade', '.pug'],
    aliases: ['Pug', 'Jade', 'jade'],
    loader: function () { return _monaco$o.Promise.wrap(import("../languages/pug.js")); }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// Allow for running under nodejs/requirejs in tests
var _monaco$p = (typeof monaco === 'undefined' ? self.monaco : monaco);
registerLanguage({
    id: 'python',
    extensions: ['.py', '.rpy', '.pyw', '.cpy', '.gyp', '.gypi'],
    aliases: ['Python', 'py'],
    firstLine: '^#!/.*\\bpython[0-9.-]*\\b',
    loader: function () { return _monaco$p.Promise.wrap(import("../languages/python.js")); }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// Allow for running under nodejs/requirejs in tests
var _monaco$q = (typeof monaco === 'undefined' ? self.monaco : monaco);
registerLanguage({
    id: 'r',
    extensions: ['.r', '.rhistory', '.rprofile', '.rt'],
    aliases: ['R', 'r'],
    loader: function () { return _monaco$q.Promise.wrap(import("../languages/r.js")); }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// Allow for running under nodejs/requirejs in tests
var _monaco$r = (typeof monaco === 'undefined' ? self.monaco : monaco);
registerLanguage({
    id: 'razor',
    extensions: ['.cshtml'],
    aliases: ['Razor', 'razor'],
    mimetypes: ['text/x-cshtml'],
    loader: function () { return _monaco$r.Promise.wrap(import("../languages/razor.js")); }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// Allow for running under nodejs/requirejs in tests
var _monaco$s = (typeof monaco === 'undefined' ? self.monaco : monaco);
registerLanguage({
    id: 'redis',
    extensions: ['.redis'],
    aliases: ['redis'],
    loader: function () { return _monaco$s.Promise.wrap(import("../languages/redis.js")); }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// Allow for running under nodejs/requirejs in tests
var _monaco$t = (typeof monaco === 'undefined' ? self.monaco : monaco);
registerLanguage({
    id: 'redshift',
    extensions: [],
    aliases: ['Redshift', 'redshift'],
    loader: function () { return _monaco$t.Promise.wrap(import("../languages/redshift.js")); }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// Allow for running under nodejs/requirejs in tests
var _monaco$u = (typeof monaco === 'undefined' ? self.monaco : monaco);
registerLanguage({
    id: 'ruby',
    extensions: ['.rb', '.rbx', '.rjs', '.gemspec', '.pp'],
    filenames: ['rakefile'],
    aliases: ['Ruby', 'rb'],
    loader: function () { return _monaco$u.Promise.wrap(import("../languages/ruby.js")); }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// Allow for running under nodejs/requirejs in tests
var _monaco$v = (typeof monaco === 'undefined' ? self.monaco : monaco);
registerLanguage({
    id: 'rust',
    extensions: ['.rs', '.rlib'],
    aliases: ['Rust', 'rust'],
    loader: function () { return _monaco$v.Promise.wrap(import("../languages/rust.js")); }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// Allow for running under nodejs/requirejs in tests
var _monaco$w = (typeof monaco === 'undefined' ? self.monaco : monaco);
registerLanguage({
    id: 'sb',
    extensions: ['.sb'],
    aliases: ['Small Basic', 'sb'],
    loader: function () { return _monaco$w.Promise.wrap(import("../languages/sb.js")); }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// Allow for running under nodejs/requirejs in tests
var _monaco$x = (typeof monaco === 'undefined' ? self.monaco : monaco);
registerLanguage({
    id: 'scss',
    extensions: ['.scss'],
    aliases: ['Sass', 'sass', 'scss'],
    mimetypes: ['text/x-scss', 'text/scss'],
    loader: function () { return _monaco$x.Promise.wrap(import("../languages/scss.js")); }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// Allow for running under nodejs/requirejs in tests
var _monaco$y = (typeof monaco === 'undefined' ? self.monaco : monaco);
registerLanguage({
    id: 'sol',
    extensions: ['.sol'],
    aliases: ['sol', 'solidity', 'Solidity'],
    loader: function () { return _monaco$y.Promise.wrap(import("../languages/solidity.js")); }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// Allow for running under nodejs/requirejs in tests
var _monaco$z = (typeof monaco === 'undefined' ? self.monaco : monaco);
registerLanguage({
    id: 'sql',
    extensions: ['.sql'],
    aliases: ['SQL'],
    loader: function () { return _monaco$z.Promise.wrap(import("../languages/sql.js")); }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// Allow for running under nodejs/requirejs in tests
var _monaco$A = (typeof monaco === 'undefined' ? self.monaco : monaco);
registerLanguage({
    id: 'st',
    extensions: ['.st', '.iecst', '.iecplc', '.lc3lib'],
    aliases: ['StructuredText', 'scl', 'stl'],
    loader: function () { return _monaco$A.Promise.wrap(import("../languages/st.js")); }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// Allow for running under nodejs/requirejs in tests
var _monaco$B = (typeof monaco === 'undefined' ? self.monaco : monaco);
registerLanguage({
    id: 'swift',
    aliases: ['Swift', 'swift'],
    extensions: ['.swift'],
    mimetypes: ['text/swift'],
    loader: function () { return _monaco$B.Promise.wrap(import("../languages/swift.js")); }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// Allow for running under nodejs/requirejs in tests
var _monaco$C = (typeof monaco === 'undefined' ? self.monaco : monaco);
registerLanguage({
    id: 'vb',
    extensions: ['.vb'],
    aliases: ['Visual Basic', 'vb'],
    loader: function () { return _monaco$C.Promise.wrap(import("../languages/vb.js")); }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// Allow for running under nodejs/requirejs in tests
var _monaco$D = (typeof monaco === 'undefined' ? self.monaco : monaco);
registerLanguage({
    id: 'xml',
    extensions: ['.xml', '.dtd', '.ascx', '.csproj', '.config', '.wxi', '.wxl', '.wxs', '.xaml', '.svg', '.svgz'],
    firstLine: '(\\<\\?xml.*)|(\\<svg)|(\\<\\!doctype\\s+svg)',
    aliases: ['XML', 'xml'],
    mimetypes: ['text/xml', 'application/xml', 'application/xaml+xml', 'application/xml-dtd'],
    loader: function () { return _monaco$D.Promise.wrap(import("../languages/xml.js")); }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// Allow for running under nodejs/requirejs in tests
var _monaco$E = (typeof monaco === 'undefined' ? self.monaco : monaco);
registerLanguage({
    id: 'yaml',
    extensions: ['.yaml', '.yml'],
    aliases: ['YAML', 'yaml', 'YML', 'yml'],
    mimetypes: ['application/x-yaml'],
    loader: function () { return _monaco$E.Promise.wrap(import("../languages/yaml.js")); }
});

export { isThemeColor as a, EditorType as b, Handler as c, editorCommon as d, LanguageIdentifier as e, TokenMetadata as f, SuggestTriggerKind as g, DocumentHighlightKind as h, SymbolKind as i, symbolKindToCssClass as j, FoldingRangeKind as k, isResourceFileEdit as l, isResourceTextEdit as m, ReferenceProviderRegistry as n, RenameProviderRegistry as o, SuggestRegistry as p, SignatureHelpProviderRegistry as q, HoverProviderRegistry as r, DocumentSymbolProviderRegistry as s, DocumentHighlightProviderRegistry as t, DefinitionProviderRegistry as u, ImplementationProviderRegistry as v, TypeDefinitionProviderRegistry as w, CodeLensProviderRegistry as x, CodeActionProviderRegistry as y, DocumentFormattingEditProviderRegistry as z, DocumentRangeFormattingEditProviderRegistry as A, OnTypeFormattingEditProviderRegistry as B, LinkProviderRegistry as C, ColorProviderRegistry as D, FoldingRangeProviderRegistry as E, TokenizationRegistry as F, modes as G, RenderMinimap as H, WrappingIndent as I, TextEditorCursorBlinkingStyle as J, blinkingStyleToString as K, TextEditorCursorStyle as L, cursorStyleToString as M, InternalEditorOptions as N, EditorOptionsValidator as O, InternalEditorOptionsFactory as P, EditorLayoutProvider as Q, EDITOR_FONT_DEFAULTS as R, EDITOR_MODEL_DEFAULTS as S, EDITOR_DEFAULTS as T, editorOptions as U, localize as V, EditorAction as W, registerEditorAction as X, registerEditorContribution as Y, EditorContextKeys as Z, registerThemingParticipant as _, themeColorFromId as $, editorBracketMatchBackground as a0, editorBracketMatchBorder as a1, ModelDecorationOptions as a2, registerColor as a3, TrackedRangeStickiness as a4, OverviewRulerLane as a5, ReplaceCommand as a6, getZoomLevel as a7, getTimeSinceLastZoomLevelChanged as a8, onDidChangeZoomLevel as a9, getPixelRatio as aa, getAccessibilitySupport as ab, onDidChangeAccessibilitySupport as ac, isIE as ad, isEdge as ae, isEdgeOrIE as af, isOpera as ag, isFirefox as ah, isWebKit as ai, isChrome as aj, isSafari as ak, isIPad as al, isEdgeWebView as am, isChromev56 as an, hasClipboardSupport as ao, ICodeEditorService as ap, CopyOptions as aq, mergeSort as ar, registerLanguageCommand as as, IModelService as at, clearNode as au, isInDOM as av, hasClass as aw, addClass as ax, addClasses as ay, removeClass as az, removeClasses as aA, toggleClass as aB, addDisposableListener as aC, addStandardDisposableListener as aD, addDisposableNonBubblingMouseOutListener as aE, runAtThisOrScheduleAtNextAnimationFrame as aF, scheduleAtNextAnimationFrame as aG, addDisposableThrottledListener as aH, getComputedStyle as aI, getClientArea as aJ, Dimension as aK, getTopLeftOffset as aL, getDomNodePagePosition as aM, StandardWindow as aN, getTotalWidth as aO, getContentWidth as aP, getContentHeight as aQ, getTotalHeight as aR, isAncestor as aS, findParentWithClass as aT, createStyleSheet as aU, createCSSRule as aV, removeCSSRulesContainingSelector as aW, isHTMLElement as aX, EventType as aY, EventHelper as aZ, saveParentsScrollTop as a_, restoreParentsScrollTop as a$, trackFocus as b0, append as b1, prepend as b2, $ as b3, show as b4, hide as b5, removeTabIndexAndUpdateFocus as b6, getElementsByTagName as b7, computeScreenAwareSize as b8, windowOpenNoOpener as b9, ContentWidgetPositionPreference as ba, OverlayWidgetPositionPreference as bb, MouseTargetType as bc, isCodeEditor as bd, isDiffEditor as be, editorCodeLensForeground as bf, editorActiveLinkForeground as bg, ICommandService as bh, INotificationService as bi, StableEditorScrollState as bj, RGBA as bk, hash as bl, IConfigurationService as bm, EditOperation as bn, LanguageConfigurationRegistry as bo, ActionItem as bp, Separator as bq, IContextMenuService as br, IContextViewService as bs, IKeybindingService as bt, IContextKeyService as bu, IMenuService as bv, MenuId as bw, registerEditorCommand as bx, EditorCommand as by, ArrayNavigator as bz, overviewRulerFindMatchForeground as bA, ReplaceCommandThatPreservesSelection as bB, SearchParams as bC, CursorChangeReason as bD, RawContextKey as bE, EndOfLinePreference as bF, createDecorator as bG, removeMarkdownEscapes as bH, setARIAContainer as bI, alert as bJ, ActionBar as bK, AnchorAlignment as bL, Widget$1 as bM, Color as bN, mixin as bO, deepClone as bP, deepFreeze as bQ, assign as bR, equals$1 as bS, arrayToHash as bT, createKeywordMatcher as bU, getOrDefault as bV, Sash as bW, Orientation as bX, editorFindRangeHighlight as bY, editorFindMatch as bZ, editorFindMatchHighlight as b_, contrastBorder as b$, inputBackground as c0, editorWidgetBackground as c1, inputActiveOptionBorder as c2, widgetShadow as c3, inputForeground as c4, inputBorder as c5, inputValidationInfoBackground as c6, inputValidationInfoBorder as c7, inputValidationWarningBackground as c8, inputValidationWarningBorder as c9, inputValidationErrorBackground as ca, inputValidationErrorBorder as cb, errorForeground as cc, editorWidgetBorder as cd, editorFindMatchBorder as ce, editorFindMatchHighlightBorder as cf, editorFindRangeHighlightBorder as cg, ContextKeyExpr as ch, IStorageService as ci, StorageScope as cj, IThemeService as ck, KeybindingsRegistry as cl, optional as cm, findFirstInSorted as cn, TextModel as co, isArray as cp, isString as cq, isObject as cr, isNumber as cs, isBoolean as ct, isUndefined as cu, isUndefinedOrNull as cv, isEmptyObject as cw, isFunction as cx, validateConstraints as cy, validateConstraint as cz, create as cA, registerInstantiatedEditorAction as cB, isFalsyOrEmpty as cC, registerDefaultLanguageCommand as cD, CommandsRegistry as cE, IEditorWorkerService as cF, EditorState as cG, flatten as cH, sep as cI, nativeSep as cJ, dirname as cK, basename as cL, extname as cM, normalize as cN, getRoot as cO, join as cP, isEqualOrParent as cQ, getPathLabel as cR, getBaseLabel as cS, IInstantiationService as cT, CodeEditor as cU, DiffEditorWidget as cV, Action as cW, $$1 as cX, Schemas as cY, IWorkspaceContextService as cZ, ITextModelService as c_, activeContrastBorder as c$, attachBadgeStyler as d0, WorkbenchTree as d1, WorkbenchTreeController as d2, ClickBehavior as d3, IEditorService as d4, HIGH_CONTRAST as d5, IProgressService as d6, MarkdownString as d7, IModeService as d8, MarkerSeverity as d9, oneOf as da, editorErrorForeground as db, editorErrorBorder as dc, editorWarningForeground as dd, editorWarningBorder as de, editorInfoForeground as df, editorInfoBorder as dg, ScrollableElement as dh, ScrollbarVisibility as di, IMarkerService as dj, binarySearch as dk, coalesce as dl, DomScrollableElement as dm, GlobalMouseMoveMonitor as dn, standardMouseMoveMerger as do, HSVA as dp, editorHoverBackground as dq, isEmptyMarkdownString as dr, markedStringsEquals as ds, IOpenerService as dt, NullOpenerService as du, tokenizeToString as dv, editorHoverHighlight as dw, editorHoverBorder as dx, textLinkForeground as dy, textCodeBlockBackground as dz, ShiftCommand as dA, IndentAction as dB, TypeOperations as dC, CoreEditingCommands as dD, CursorMoveCommands as dE, overviewRulerSelectionHighlightForeground as dF, domEvent as dG, stop as dH, IListService as dI, IFileService as dJ, FileChangeType as dK, emptyProgressRunner as dL, ignoreBracketsInToken as dM, BracketsUtils as dN, tail as dO, equals as dP, groupBy as dQ, distinct as dR, firstIndex as dS, first as dT, commonPrefixLength$1 as dU, range as dV, arrayInsert as dW, ILogService as dX, List as dY, ITelemetryService as dZ, attachListStyler as d_, listFocusBackground as d$, listHighlightForeground as e0, editorForeground as e1, focusBorder as e2, TabFocus as e3, editorSelectionHighlight as e4, editorSelectionHighlightBorder as e5, WordOperations as e6, getMapForWordSeparators as e7, CursorState as e8, createFastDomNode as e9, IStandaloneThemeService as ea, NULL_STATE as eb, nullTokenize as ec, nullTokenize2 as ed, UILabelProvider as ee, ok as ef, Severity$1 as eg, Tree as eh, StandardKeyboardEvent as ei, DefaultController as ej, StandardMouseEvent as ek, attachQuickOpenStyler as el, foreground as em, ServiceCollection as en, StandaloneEditor as eo, StandaloneDiffEditor as ep, DynamicStandaloneServices as eq, StaticServices as er, OpenerService as es, Colorizer as et, SimpleEditorService as eu, SimpleEditorModelResolverService as ev, createWebWorker as ew, DiffNavigator as ex, FontInfo as ey, BareFontInfo as ez, DefaultEndOfLine as eA, EndOfLineSequence as eB, TextModelResolvedOptions as eC, FindMatch as eD, create$1 as eE, onDidCreateEditor as eF, createDiffEditor as eG, createDiffNavigator as eH, createModel as eI, setModelLanguage as eJ, setModelMarkers as eK, getModelMarkers as eL, getModel as eM, getModels as eN, onDidCreateModel as eO, onWillDisposeModel as eP, onDidChangeModelLanguage as eQ, createWebWorker$1 as eR, colorizeElement as eS, colorize as eT, colorizeModelLine as eU, tokenize as eV, defineTheme as eW, setTheme as eX, createMonacoEditorAPI as eY, CancellationTokenSource as eZ, Emitter$1 as e_, KeyCode as e$, KeyMod as f0, Position$2 as f1, Range$1 as f2, Selection$1 as f3, SelectionDirection$1 as f4, Severity$3 as f5, MarkerSeverity$1 as f6, Promise$2 as f7, Uri as f8, Token$1 as f9, editor as fa, languages as fb };
//# sourceMappingURL=basic-languages.js.map
