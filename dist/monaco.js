import { V as localize, W as EditorAction, X as registerEditorAction, Y as registerEditorContribution, Z as EditorContextKeys, _ as registerThemingParticipant, $ as themeColorFromId, a0 as editorBracketMatchBackground, a1 as editorBracketMatchBorder, a2 as ModelDecorationOptions, a3 as registerColor, a4 as TrackedRangeStickiness, a5 as OverviewRulerLane, a6 as ReplaceCommand, a7 as getZoomLevel, a8 as getTimeSinceLastZoomLevelChanged, a9 as onDidChangeZoomLevel, aa as getPixelRatio, ab as getAccessibilitySupport, ac as onDidChangeAccessibilitySupport, ad as isIE, ae as isEdge, af as isEdgeOrIE, ag as isOpera, ah as isFirefox, ai as isWebKit, aj as isChrome, ak as isSafari, al as isIPad, am as isEdgeWebView, an as isChromev56, ao as hasClipboardSupport, ap as ICodeEditorService, aq as CopyOptions, ar as mergeSort, as as registerLanguageCommand, x as CodeLensProviderRegistry, at as IModelService, au as clearNode, av as isInDOM, aw as hasClass, ax as addClass, ay as addClasses, az as removeClass, aA as removeClasses, aB as toggleClass, aC as addDisposableListener, aD as addStandardDisposableListener, aE as addDisposableNonBubblingMouseOutListener, aF as runAtThisOrScheduleAtNextAnimationFrame, aG as scheduleAtNextAnimationFrame, aH as addDisposableThrottledListener, aI as getComputedStyle, aJ as getClientArea, aK as Dimension, aL as getTopLeftOffset, aM as getDomNodePagePosition, aN as StandardWindow, aO as getTotalWidth, aP as getContentWidth, aQ as getContentHeight, aR as getTotalHeight, aS as isAncestor, aT as findParentWithClass, aU as createStyleSheet, aV as createCSSRule, aW as removeCSSRulesContainingSelector, aX as isHTMLElement, aY as EventType, aZ as EventHelper, a_ as saveParentsScrollTop, a$ as restoreParentsScrollTop, b0 as trackFocus, b1 as append, b2 as prepend, b3 as $, b4 as show, b5 as hide, b6 as removeTabIndexAndUpdateFocus, b7 as getElementsByTagName, b8 as computeScreenAwareSize, b9 as windowOpenNoOpener, ba as ContentWidgetPositionPreference, bb as OverlayWidgetPositionPreference, bc as MouseTargetType, bd as isCodeEditor, be as isDiffEditor, bf as editorCodeLensForeground, bg as editorActiveLinkForeground, bh as ICommandService, bi as INotificationService, bj as StableEditorScrollState, D as ColorProviderRegistry, bk as RGBA, bl as hash, bm as IConfigurationService, bn as EditOperation, bo as LanguageConfigurationRegistry, bp as ActionItem, bq as Separator, br as IContextMenuService, bs as IContextViewService, bt as IKeybindingService, bu as IContextKeyService, bv as IMenuService, bw as MenuId, bx as registerEditorCommand, by as EditorCommand, bz as ArrayNavigator, bA as overviewRulerFindMatchForeground, bB as ReplaceCommandThatPreservesSelection, bC as SearchParams, bD as CursorChangeReason, bE as RawContextKey, bF as EndOfLinePreference, bG as createDecorator, bH as removeMarkdownEscapes, bI as setARIAContainer, bJ as alert, bK as ActionBar, bL as AnchorAlignment, bM as Widget, bN as Color, bO as mixin, bP as deepClone, bQ as deepFreeze, bR as assign, bS as equals, bT as arrayToHash, bU as createKeywordMatcher, bV as getOrDefault, bW as Sash, bX as Orientation, bY as editorFindRangeHighlight, bZ as editorFindMatch, b_ as editorFindMatchHighlight, b$ as contrastBorder, c0 as inputBackground, c1 as editorWidgetBackground, c2 as inputActiveOptionBorder, c3 as widgetShadow, c4 as inputForeground, c5 as inputBorder, c6 as inputValidationInfoBackground, c7 as inputValidationInfoBorder, c8 as inputValidationWarningBackground, c9 as inputValidationWarningBorder, ca as inputValidationErrorBackground, cb as inputValidationErrorBorder, cc as errorForeground, cd as editorWidgetBorder, ce as editorFindMatchBorder, cf as editorFindMatchHighlightBorder, cg as editorFindRangeHighlightBorder, ch as ContextKeyExpr, ci as IStorageService, cj as StorageScope, ck as IThemeService, cl as KeybindingsRegistry, cm as optional, cn as findFirstInSorted, co as TextModel, cp as isArray, cq as isString, cr as isObject, cs as isNumber, ct as isBoolean, cu as isUndefined, cv as isUndefinedOrNull, cw as isEmptyObject, cx as isFunction, cy as validateConstraints, cz as validateConstraint, cA as create, cB as registerInstantiatedEditorAction, E as FoldingRangeProviderRegistry, k as FoldingRangeKind, cC as isFalsyOrEmpty, cD as registerDefaultLanguageCommand, z as DocumentFormattingEditProviderRegistry, A as DocumentRangeFormattingEditProviderRegistry, B as OnTypeFormattingEditProviderRegistry, cE as CommandsRegistry, cF as IEditorWorkerService, cG as EditorState, u as DefinitionProviderRegistry, v as ImplementationProviderRegistry, w as TypeDefinitionProviderRegistry, cH as flatten, cI as sep, cJ as nativeSep, cK as dirname, cL as basename, cM as extname, cN as normalize, cO as getRoot, cP as join, cQ as isEqualOrParent, cR as getPathLabel, cS as getBaseLabel, cT as IInstantiationService, cU as CodeEditor, cV as DiffEditorWidget, cW as Action, cX as $$1, cY as Schemas, cZ as IWorkspaceContextService, c_ as ITextModelService, c$ as activeContrastBorder, d0 as attachBadgeStyler, d1 as WorkbenchTree, d2 as WorkbenchTreeController, d3 as ClickBehavior, d4 as IEditorService, d5 as HIGH_CONTRAST, d6 as IProgressService, d7 as MarkdownString, d8 as IModeService, d9 as MarkerSeverity, da as oneOf, db as editorErrorForeground, dc as editorErrorBorder, dd as editorWarningForeground, de as editorWarningBorder, df as editorInfoForeground, dg as editorInfoBorder, dh as ScrollableElement, di as ScrollbarVisibility, dj as IMarkerService, dk as binarySearch, dl as coalesce, r as HoverProviderRegistry, dm as DomScrollableElement, dn as GlobalMouseMoveMonitor, do as standardMouseMoveMerger, dp as HSVA, dq as editorHoverBackground, dr as isEmptyMarkdownString, ds as markedStringsEquals, dt as IOpenerService, du as NullOpenerService, dv as tokenizeToString, dw as editorHoverHighlight, dx as editorHoverBorder, dy as textLinkForeground, dz as textCodeBlockBackground, dA as ShiftCommand, dB as IndentAction, dC as TypeOperations, dD as CoreEditingCommands, C as LinkProviderRegistry, dE as CursorMoveCommands, t as DocumentHighlightProviderRegistry, dF as overviewRulerSelectionHighlightForeground, q as SignatureHelpProviderRegistry, dG as domEvent, dH as stop, n as ReferenceProviderRegistry, dI as IListService, dJ as IFileService, dK as FileChangeType, dL as emptyProgressRunner, l as isResourceFileEdit, m as isResourceTextEdit, o as RenameProviderRegistry, dM as ignoreBracketsInToken, dN as BracketsUtils, dO as tail, dP as equals$1, dQ as groupBy, dR as distinct, dS as firstIndex, dT as first, dU as commonPrefixLength$1, dV as range, dW as arrayInsert, p as SuggestRegistry, g as SuggestTriggerKind, dX as ILogService, dY as List, dZ as ITelemetryService, d_ as attachListStyler, d$ as listFocusBackground, e0 as listHighlightForeground, e1 as editorForeground, e2 as focusBorder, e3 as TabFocus, h as DocumentHighlightKind, e4 as editorSelectionHighlight, e5 as editorSelectionHighlightBorder, e6 as WordOperations, e7 as getMapForWordSeparators, e8 as CursorState, e9 as createFastDomNode, F as TokenizationRegistry, f as TokenMetadata, ea as IStandaloneThemeService, eb as NULL_STATE, ec as nullTokenize, ed as nullTokenize2, ee as UILabelProvider, ef as ok, eg as Severity, eh as Tree, ei as StandardKeyboardEvent, ej as DefaultController, ek as StandardMouseEvent, el as attachQuickOpenStyler, em as foreground, s as DocumentSymbolProviderRegistry, j as symbolKindToCssClass, y as CodeActionProviderRegistry } from './monaco/basic-languages.js';
export { eZ as CancellationTokenSource, e_ as Emitter, e$ as KeyCode, f0 as KeyMod, f1 as Position, f2 as Range, f3 as Selection, f4 as SelectionDirection, f5 as Severity, f6 as MarkerSeverity, f7 as Promise, f8 as Uri, f9 as Token, fa as editor, fb as languages } from './monaco/basic-languages.js';
import { $ as Disposable, ay as RunOnceScheduler, F as isLowSurrogate, E as isHighSurrogate, ag as Platform, aa as isWindows, ac as isMacintosh, ab as isLinux, ah as isNative, a1 as isWeb, a3 as globals, ai as setImmediate, aj as OS, aw as illegalArgument, at as onUnexpectedExternalError, Z as URI, X as TPromise, aS as asWinJsPromise, aT as CancellationToken, a5 as dispose, e as format, f as escape, am as onUnexpectedError, b as empty, c as isFalsyOrWhitespace, d as pad, g as escapeRegExpCharacters, h as trim, i as ltrim, j as rtrim, k as convertSimple2RegExpPattern, l as stripWildcards, m as startsWith, n as endsWith, o as createRegExp, p as regExpLeadsToEndlessLoop, q as regExpContainsBackreference, r as canNormalize, s as normalizeNFC, t as normalizeNFD, u as firstNonWhitespaceIndex, v as getLeadingWhitespace, w as lastNonWhitespaceIndex, x as compare, y as compareIgnoreCase, z as equalsIgnoreCase, A as startsWithIgnoreCase, B as commonPrefixLength, C as commonSuffixLength, D as overlap, G as containsRTL, H as containsEmoji, I as isBasicASCII, J as containsFullWidthCharacter, K as isFullWidthCharacter, L as lcut, M as removeAnsiEscapeCodes, N as UTF8_BOM_CHARACTER, O as startsWithUTF8BOM, P as stripUTF8BOM, Q as safeBtoa, R as repeat, S as fuzzyContains, T as containsUppercaseCharacter, U as strings, W as KeyChord, al as TimeoutTimer, V as Emitter, aQ as Delayer, aR as toPromiseLike, aU as sequence, ap as combinedDisposable, aV as setDisposableTimeout, aW as Throttler, aE as empty$1, aC as chain, aq as LRUCache, aF as isDisposable, au as isPromiseCanceledError, aG as toDisposable, ad as TernarySearchTree, ar as ErrorHandler, as as errorHandler, _ as transformErrorForSerialization, av as canceled, ax as illegalState, aH as debounceEvent, aX as always, Y as CancellationTokenSource } from './monaco/base.js';
import { c as Position, p as Selection, a as Range, u as CharacterSet } from './monaco/editor.js';
import './monaco/workers.js';

const css = "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n.monaco-editor .bracket-match {\n\tbox-sizing: border-box;\n}\n";
  const element = ((css, src) => {
if (typeof document !== 'object')
console.info(`Skipped loading "${src}"`);
try {
const id = src
  .replace(/\.css.*$/, '')
  .replace(/[\\:]/g, '/')
  .replace(/[^\w\/]+/g, '');
return (
  document.querySelector(`style[id="${id}"]`) ||
  document.head.appendChild(
    Object.assign(document.createElement('style'), {
      id,
      textContent: `${css}\n\n /* sourceURL=${src} */`,
    }),
  )
);
} catch (exception) {
console.warn(`Failed load "${src}"`, exception);
}
})(css, "…monaco-editor/esm/vs/editor/contrib/bracketMatching/bracketMatching.css");
  //@ sourceURL=/Users/daflair/Projects/packages/monaco-es/node_modules/monaco-editor/esm/vs/editor/contrib/bracketMatching/bracketMatching.css

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var overviewRulerBracketMatchForeground = registerColor('editorOverviewRuler.bracketMatchForeground', { dark: '#A0A0A0', light: '#A0A0A0', hc: '#A0A0A0' }, localize('overviewRulerBracketMatchForeground', 'Overview ruler marker color for matching brackets.'));
var JumpToBracketAction = /** @class */ (function (_super) {
    __extends(JumpToBracketAction, _super);
    function JumpToBracketAction() {
        return _super.call(this, {
            id: 'editor.action.jumpToBracket',
            label: localize('smartSelect.jumpBracket', "Go to Bracket"),
            alias: 'Go to Bracket',
            precondition: null,
            kbOpts: {
                kbExpr: EditorContextKeys.editorTextFocus,
                primary: 2048 /* CtrlCmd */ | 1024 /* Shift */ | 88 /* US_BACKSLASH */
            }
        }) || this;
    }
    JumpToBracketAction.prototype.run = function (accessor, editor) {
        var controller = BracketMatchingController.get(editor);
        if (!controller) {
            return;
        }
        controller.jumpToBracket();
    };
    return JumpToBracketAction;
}(EditorAction));
var SelectToBracketAction = /** @class */ (function (_super) {
    __extends(SelectToBracketAction, _super);
    function SelectToBracketAction() {
        return _super.call(this, {
            id: 'editor.action.selectToBracket',
            label: localize('smartSelect.selectToBracket', "Select to Bracket"),
            alias: 'Select to Bracket',
            precondition: null
        }) || this;
    }
    SelectToBracketAction.prototype.run = function (accessor, editor) {
        var controller = BracketMatchingController.get(editor);
        if (!controller) {
            return;
        }
        controller.selectToBracket();
    };
    return SelectToBracketAction;
}(EditorAction));
var BracketsData = /** @class */ (function () {
    function BracketsData(position, brackets) {
        this.position = position;
        this.brackets = brackets;
    }
    return BracketsData;
}());
var BracketMatchingController = /** @class */ (function (_super) {
    __extends(BracketMatchingController, _super);
    function BracketMatchingController(editor) {
        var _this = _super.call(this) || this;
        _this._editor = editor;
        _this._lastBracketsData = [];
        _this._lastVersionId = 0;
        _this._decorations = [];
        _this._updateBracketsSoon = _this._register(new RunOnceScheduler(function () { return _this._updateBrackets(); }, 50));
        _this._matchBrackets = _this._editor.getConfiguration().contribInfo.matchBrackets;
        _this._updateBracketsSoon.schedule();
        _this._register(editor.onDidChangeCursorPosition(function (e) {
            if (!_this._matchBrackets) {
                // Early exit if nothing needs to be done!
                // Leave some form of early exit check here if you wish to continue being a cursor position change listener ;)
                return;
            }
            _this._updateBracketsSoon.schedule();
        }));
        _this._register(editor.onDidChangeModel(function (e) { _this._decorations = []; _this._updateBracketsSoon.schedule(); }));
        _this._register(editor.onDidChangeModelLanguageConfiguration(function (e) {
            _this._lastBracketsData = [];
            _this._updateBracketsSoon.schedule();
        }));
        _this._register(editor.onDidChangeConfiguration(function (e) {
            _this._matchBrackets = _this._editor.getConfiguration().contribInfo.matchBrackets;
            if (!_this._matchBrackets && _this._decorations.length > 0) {
                // Remove existing decorations if bracket matching is off
                _this._decorations = _this._editor.deltaDecorations(_this._decorations, []);
            }
            _this._updateBracketsSoon.schedule();
        }));
        return _this;
    }
    BracketMatchingController.get = function (editor) {
        return editor.getContribution(BracketMatchingController.ID);
    };
    BracketMatchingController.prototype.getId = function () {
        return BracketMatchingController.ID;
    };
    BracketMatchingController.prototype.jumpToBracket = function () {
        var model = this._editor.getModel();
        if (!model) {
            return;
        }
        var newSelections = this._editor.getSelections().map(function (selection) {
            var position = selection.getStartPosition();
            // find matching brackets if position is on a bracket
            var brackets = model.matchBracket(position);
            var newCursorPosition = null;
            if (brackets) {
                if (brackets[0].containsPosition(position)) {
                    newCursorPosition = brackets[1].getStartPosition();
                }
                else if (brackets[1].containsPosition(position)) {
                    newCursorPosition = brackets[0].getStartPosition();
                }
            }
            else {
                // find the next bracket if the position isn't on a matching bracket
                var nextBracket = model.findNextBracket(position);
                if (nextBracket && nextBracket.range) {
                    newCursorPosition = nextBracket.range.getStartPosition();
                }
            }
            if (newCursorPosition) {
                return new Selection(newCursorPosition.lineNumber, newCursorPosition.column, newCursorPosition.lineNumber, newCursorPosition.column);
            }
            return new Selection(position.lineNumber, position.column, position.lineNumber, position.column);
        });
        this._editor.setSelections(newSelections);
        this._editor.revealRange(newSelections[0]);
    };
    BracketMatchingController.prototype.selectToBracket = function () {
        var model = this._editor.getModel();
        if (!model) {
            return;
        }
        var newSelections = [];
        this._editor.getSelections().forEach(function (selection) {
            var position = selection.getStartPosition();
            var brackets = model.matchBracket(position);
            var openBracket = null;
            var closeBracket = null;
            if (!brackets) {
                var nextBracket = model.findNextBracket(position);
                if (nextBracket && nextBracket.range) {
                    brackets = model.matchBracket(nextBracket.range.getStartPosition());
                }
            }
            if (brackets) {
                if (brackets[0].startLineNumber === brackets[1].startLineNumber) {
                    openBracket = brackets[1].startColumn < brackets[0].startColumn ?
                        brackets[1].getStartPosition() : brackets[0].getStartPosition();
                    closeBracket = brackets[1].startColumn < brackets[0].startColumn ?
                        brackets[0].getEndPosition() : brackets[1].getEndPosition();
                }
                else {
                    openBracket = brackets[1].startLineNumber < brackets[0].startLineNumber ?
                        brackets[1].getStartPosition() : brackets[0].getStartPosition();
                    closeBracket = brackets[1].startLineNumber < brackets[0].startLineNumber ?
                        brackets[0].getEndPosition() : brackets[1].getEndPosition();
                }
            }
            if (openBracket && closeBracket) {
                newSelections.push(new Selection(openBracket.lineNumber, openBracket.column, closeBracket.lineNumber, closeBracket.column));
            }
        });
        if (newSelections.length > 0) {
            this._editor.setSelections(newSelections);
            this._editor.revealRange(newSelections[0]);
        }
    };
    BracketMatchingController.prototype._updateBrackets = function () {
        if (!this._matchBrackets) {
            return;
        }
        this._recomputeBrackets();
        var newDecorations = [], newDecorationsLen = 0;
        for (var i = 0, len = this._lastBracketsData.length; i < len; i++) {
            var brackets = this._lastBracketsData[i].brackets;
            if (brackets) {
                newDecorations[newDecorationsLen++] = { range: brackets[0], options: BracketMatchingController._DECORATION_OPTIONS };
                newDecorations[newDecorationsLen++] = { range: brackets[1], options: BracketMatchingController._DECORATION_OPTIONS };
            }
        }
        this._decorations = this._editor.deltaDecorations(this._decorations, newDecorations);
    };
    BracketMatchingController.prototype._recomputeBrackets = function () {
        var model = this._editor.getModel();
        if (!model) {
            // no model => no brackets!
            this._lastBracketsData = [];
            this._lastVersionId = 0;
            return;
        }
        var versionId = model.getVersionId();
        var previousData = [];
        if (this._lastVersionId === versionId) {
            // use the previous data only if the model is at the same version id
            previousData = this._lastBracketsData;
        }
        var selections = this._editor.getSelections();
        var positions = [], positionsLen = 0;
        for (var i = 0, len = selections.length; i < len; i++) {
            var selection = selections[i];
            if (selection.isEmpty()) {
                // will bracket match a cursor only if the selection is collapsed
                positions[positionsLen++] = selection.getStartPosition();
            }
        }
        // sort positions for `previousData` cache hits
        if (positions.length > 1) {
            positions.sort(Position.compare);
        }
        var newData = [], newDataLen = 0;
        var previousIndex = 0, previousLen = previousData.length;
        for (var i = 0, len = positions.length; i < len; i++) {
            var position = positions[i];
            while (previousIndex < previousLen && previousData[previousIndex].position.isBefore(position)) {
                previousIndex++;
            }
            if (previousIndex < previousLen && previousData[previousIndex].position.equals(position)) {
                newData[newDataLen++] = previousData[previousIndex];
            }
            else {
                var brackets = model.matchBracket(position);
                newData[newDataLen++] = new BracketsData(position, brackets);
            }
        }
        this._lastBracketsData = newData;
        this._lastVersionId = versionId;
    };
    BracketMatchingController.ID = 'editor.contrib.bracketMatchingController';
    BracketMatchingController._DECORATION_OPTIONS = ModelDecorationOptions.register({
        stickiness: TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges,
        className: 'bracket-match',
        overviewRuler: {
            color: themeColorFromId(overviewRulerBracketMatchForeground),
            darkColor: themeColorFromId(overviewRulerBracketMatchForeground),
            position: OverviewRulerLane.Center
        }
    });
    return BracketMatchingController;
}(Disposable));
registerEditorContribution(BracketMatchingController);
registerEditorAction(SelectToBracketAction);
registerEditorAction(JumpToBracketAction);
registerThemingParticipant(function (theme, collector) {
    var bracketMatchBackground = theme.getColor(editorBracketMatchBackground);
    if (bracketMatchBackground) {
        collector.addRule(".monaco-editor .bracket-match { background-color: " + bracketMatchBackground + "; }");
    }
    var bracketMatchBorder = theme.getColor(editorBracketMatchBorder);
    if (bracketMatchBorder) {
        collector.addRule(".monaco-editor .bracket-match { border: 1px solid " + bracketMatchBorder + "; }");
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var MoveCaretCommand = /** @class */ (function () {
    function MoveCaretCommand(selection, isMovingLeft) {
        this._selection = selection;
        this._isMovingLeft = isMovingLeft;
    }
    MoveCaretCommand.prototype.getEditOperations = function (model, builder) {
        var s = this._selection;
        this._selectionId = builder.trackSelection(s);
        if (s.startLineNumber !== s.endLineNumber) {
            return;
        }
        if (this._isMovingLeft && s.startColumn === 0) {
            return;
        }
        else if (!this._isMovingLeft && s.endColumn === model.getLineMaxColumn(s.startLineNumber)) {
            return;
        }
        var lineNumber = s.selectionStartLineNumber;
        var lineContent = model.getLineContent(lineNumber);
        var left;
        var middle;
        var right;
        if (this._isMovingLeft) {
            left = lineContent.substring(0, s.startColumn - 2);
            middle = lineContent.substring(s.startColumn - 1, s.endColumn - 1);
            right = lineContent.substring(s.startColumn - 2, s.startColumn - 1) + lineContent.substring(s.endColumn - 1);
        }
        else {
            left = lineContent.substring(0, s.startColumn - 1) + lineContent.substring(s.endColumn - 1, s.endColumn);
            middle = lineContent.substring(s.startColumn - 1, s.endColumn - 1);
            right = lineContent.substring(s.endColumn);
        }
        var newLineContent = left + middle + right;
        builder.addEditOperation(new Range(lineNumber, 1, lineNumber, model.getLineMaxColumn(lineNumber)), null);
        builder.addEditOperation(new Range(lineNumber, 1, lineNumber, 1), newLineContent);
        this._cutStartIndex = s.startColumn + (this._isMovingLeft ? -1 : 1);
        this._cutEndIndex = this._cutStartIndex + s.endColumn - s.startColumn;
        this._moved = true;
    };
    MoveCaretCommand.prototype.computeCursorState = function (model, helper) {
        var result = helper.getTrackedSelection(this._selectionId);
        if (this._moved) {
            result = result.setStartPosition(result.startLineNumber, this._cutStartIndex);
            result = result.setEndPosition(result.startLineNumber, this._cutEndIndex);
        }
        return result;
    };
    return MoveCaretCommand;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$1 = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var MoveCaretAction = /** @class */ (function (_super) {
    __extends$1(MoveCaretAction, _super);
    function MoveCaretAction(left, opts) {
        var _this = _super.call(this, opts) || this;
        _this.left = left;
        return _this;
    }
    MoveCaretAction.prototype.run = function (accessor, editor) {
        var commands = [];
        var selections = editor.getSelections();
        for (var i = 0; i < selections.length; i++) {
            commands.push(new MoveCaretCommand(selections[i], this.left));
        }
        editor.pushUndoStop();
        editor.executeCommands(this.id, commands);
        editor.pushUndoStop();
    };
    return MoveCaretAction;
}(EditorAction));
var MoveCaretLeftAction = /** @class */ (function (_super) {
    __extends$1(MoveCaretLeftAction, _super);
    function MoveCaretLeftAction() {
        return _super.call(this, true, {
            id: 'editor.action.moveCarretLeftAction',
            label: localize('caret.moveLeft', "Move Caret Left"),
            alias: 'Move Caret Left',
            precondition: EditorContextKeys.writable
        }) || this;
    }
    return MoveCaretLeftAction;
}(MoveCaretAction));
var MoveCaretRightAction = /** @class */ (function (_super) {
    __extends$1(MoveCaretRightAction, _super);
    function MoveCaretRightAction() {
        return _super.call(this, false, {
            id: 'editor.action.moveCarretRightAction',
            label: localize('caret.moveRight', "Move Caret Right"),
            alias: 'Move Caret Right',
            precondition: EditorContextKeys.writable
        }) || this;
    }
    return MoveCaretRightAction;
}(MoveCaretAction));
registerEditorAction(MoveCaretLeftAction);
registerEditorAction(MoveCaretRightAction);

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$2 = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var TransposeLettersAction = /** @class */ (function (_super) {
    __extends$2(TransposeLettersAction, _super);
    function TransposeLettersAction() {
        return _super.call(this, {
            id: 'editor.action.transposeLetters',
            label: localize('transposeLetters.label', "Transpose Letters"),
            alias: 'Transpose Letters',
            precondition: EditorContextKeys.writable,
            kbOpts: {
                kbExpr: EditorContextKeys.textInputFocus,
                primary: 0,
                mac: {
                    primary: 256 /* WinCtrl */ | 50 /* KEY_T */
                }
            }
        }) || this;
    }
    TransposeLettersAction.prototype.positionLeftOf = function (start, model) {
        var column = start.column;
        var lineNumber = start.lineNumber;
        if (column > model.getLineMinColumn(lineNumber)) {
            if (isLowSurrogate(model.getLineContent(lineNumber).charCodeAt(column - 2))) {
                // character before column is a low surrogate
                column = column - 2;
            }
            else {
                column = column - 1;
            }
        }
        else if (lineNumber > 1) {
            lineNumber = lineNumber - 1;
            column = model.getLineMaxColumn(lineNumber);
        }
        return new Position(lineNumber, column);
    };
    TransposeLettersAction.prototype.positionRightOf = function (start, model) {
        var column = start.column;
        var lineNumber = start.lineNumber;
        if (column < model.getLineMaxColumn(lineNumber)) {
            if (isHighSurrogate(model.getLineContent(lineNumber).charCodeAt(column - 1))) {
                // character after column is a high surrogate
                column = column + 2;
            }
            else {
                column = column + 1;
            }
        }
        else if (lineNumber < model.getLineCount()) {
            lineNumber = lineNumber + 1;
            column = 0;
        }
        return new Position(lineNumber, column);
    };
    TransposeLettersAction.prototype.run = function (accessor, editor) {
        var model = editor.getModel();
        var commands = [];
        var selections = editor.getSelections();
        for (var _i = 0, selections_1 = selections; _i < selections_1.length; _i++) {
            var selection = selections_1[_i];
            if (!selection.isEmpty()) {
                continue;
            }
            var lineNumber = selection.startLineNumber;
            var column = selection.startColumn;
            var lastColumn = model.getLineMaxColumn(lineNumber);
            if (lineNumber === 1 && (column === 1 || (column === 2 && lastColumn === 2))) {
                // at beginning of file, nothing to do
                continue;
            }
            // handle special case: when at end of line, transpose left two chars
            // otherwise, transpose left and right chars
            var endPosition = (column === lastColumn) ?
                selection.getPosition() :
                this.positionRightOf(selection.getPosition(), model);
            var middlePosition = this.positionLeftOf(endPosition, model);
            var beginPosition = this.positionLeftOf(middlePosition, model);
            var leftChar = model.getValueInRange(Range.fromPositions(beginPosition, middlePosition));
            var rightChar = model.getValueInRange(Range.fromPositions(middlePosition, endPosition));
            var replaceRange = Range.fromPositions(beginPosition, endPosition);
            commands.push(new ReplaceCommand(replaceRange, rightChar + leftChar));
        }
        if (commands.length > 0) {
            editor.pushUndoStop();
            editor.executeCommands(this.id, commands);
            editor.pushUndoStop();
        }
    };
    return TransposeLettersAction;
}(EditorAction));
registerEditorAction(TransposeLettersAction);

const css$1 = "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n.monaco-menu .monaco-action-bar.vertical .action-label.hover {\n\tbackground-color: #EEE;\n}";
  const element$1 = ((css, src) => {
if (typeof document !== 'object')
console.info(`Skipped loading "${src}"`);
try {
const id = src
  .replace(/\.css.*$/, '')
  .replace(/[\\:]/g, '/')
  .replace(/[^\w\/]+/g, '');
return (
  document.querySelector(`style[id="${id}"]`) ||
  document.head.appendChild(
    Object.assign(document.createElement('style'), {
      id,
      textContent: `${css}\n\n /* sourceURL=${src} */`,
    }),
  )
);
} catch (exception) {
console.warn(`Failed load "${src}"`, exception);
}
})(css$1, "…monaco-editor/esm/vs/editor/contrib/clipboard/clipboard.css");
  //@ sourceURL=/Users/daflair/Projects/packages/monaco-es/node_modules/monaco-editor/esm/vs/editor/contrib/clipboard/clipboard.css

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$3 = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var CLIPBOARD_CONTEXT_MENU_GROUP = '9_cutcopypaste';
var supportsCut = (isNative || document.queryCommandSupported('cut'));
var supportsCopy = (isNative || document.queryCommandSupported('copy'));
// IE and Edge have trouble with setting html content in clipboard
var supportsCopyWithSyntaxHighlighting = (supportsCopy && !isEdgeOrIE);
// Chrome incorrectly returns true for document.queryCommandSupported('paste')
// when the paste feature is available but the calling script has insufficient
// privileges to actually perform the action
var supportsPaste = (isNative || (!isChrome && document.queryCommandSupported('paste')));
var ExecCommandAction = /** @class */ (function (_super) {
    __extends$3(ExecCommandAction, _super);
    function ExecCommandAction(browserCommand, opts) {
        var _this = _super.call(this, opts) || this;
        _this.browserCommand = browserCommand;
        return _this;
    }
    ExecCommandAction.prototype.runCommand = function (accessor, args) {
        var focusedEditor = accessor.get(ICodeEditorService).getFocusedCodeEditor();
        // Only if editor text focus (i.e. not if editor has widget focus).
        if (focusedEditor && focusedEditor.isFocused()) {
            focusedEditor.trigger('keyboard', this.id, args);
            return;
        }
        document.execCommand(this.browserCommand);
    };
    ExecCommandAction.prototype.run = function (accessor, editor) {
        editor.focus();
        document.execCommand(this.browserCommand);
    };
    return ExecCommandAction;
}(EditorAction));
var ExecCommandCutAction = /** @class */ (function (_super) {
    __extends$3(ExecCommandCutAction, _super);
    function ExecCommandCutAction() {
        var _this = this;
        var kbOpts = {
            kbExpr: EditorContextKeys.textInputFocus,
            primary: 2048 /* CtrlCmd */ | 54 /* KEY_X */,
            win: { primary: 2048 /* CtrlCmd */ | 54 /* KEY_X */, secondary: [1024 /* Shift */ | 20 /* Delete */] }
        };
        // Do not bind cut keybindings in the browser,
        // since browsers do that for us and it avoids security prompts
        if (!isNative) {
            kbOpts = null;
        }
        _this = _super.call(this, 'cut', {
            id: 'editor.action.clipboardCutAction',
            label: localize('actions.clipboard.cutLabel', "Cut"),
            alias: 'Cut',
            precondition: EditorContextKeys.writable,
            kbOpts: kbOpts,
            menuOpts: {
                group: CLIPBOARD_CONTEXT_MENU_GROUP,
                order: 1
            }
        }) || this;
        return _this;
    }
    ExecCommandCutAction.prototype.run = function (accessor, editor) {
        var emptySelectionClipboard = editor.getConfiguration().emptySelectionClipboard;
        if (!emptySelectionClipboard && editor.getSelection().isEmpty()) {
            return;
        }
        _super.prototype.run.call(this, accessor, editor);
    };
    return ExecCommandCutAction;
}(ExecCommandAction));
var ExecCommandCopyAction = /** @class */ (function (_super) {
    __extends$3(ExecCommandCopyAction, _super);
    function ExecCommandCopyAction() {
        var _this = this;
        var kbOpts = {
            kbExpr: EditorContextKeys.textInputFocus,
            primary: 2048 /* CtrlCmd */ | 33 /* KEY_C */,
            win: { primary: 2048 /* CtrlCmd */ | 33 /* KEY_C */, secondary: [2048 /* CtrlCmd */ | 19 /* Insert */] }
        };
        // Do not bind copy keybindings in the browser,
        // since browsers do that for us and it avoids security prompts
        if (!isNative) {
            kbOpts = null;
        }
        _this = _super.call(this, 'copy', {
            id: 'editor.action.clipboardCopyAction',
            label: localize('actions.clipboard.copyLabel', "Copy"),
            alias: 'Copy',
            precondition: null,
            kbOpts: kbOpts,
            menuOpts: {
                group: CLIPBOARD_CONTEXT_MENU_GROUP,
                order: 2
            }
        }) || this;
        return _this;
    }
    ExecCommandCopyAction.prototype.run = function (accessor, editor) {
        var emptySelectionClipboard = editor.getConfiguration().emptySelectionClipboard;
        if (!emptySelectionClipboard && editor.getSelection().isEmpty()) {
            return;
        }
        _super.prototype.run.call(this, accessor, editor);
    };
    return ExecCommandCopyAction;
}(ExecCommandAction));
var ExecCommandPasteAction = /** @class */ (function (_super) {
    __extends$3(ExecCommandPasteAction, _super);
    function ExecCommandPasteAction() {
        var _this = this;
        var kbOpts = {
            kbExpr: EditorContextKeys.textInputFocus,
            primary: 2048 /* CtrlCmd */ | 52 /* KEY_V */,
            win: { primary: 2048 /* CtrlCmd */ | 52 /* KEY_V */, secondary: [1024 /* Shift */ | 19 /* Insert */] }
        };
        // Do not bind paste keybindings in the browser,
        // since browsers do that for us and it avoids security prompts
        if (!isNative) {
            kbOpts = null;
        }
        _this = _super.call(this, 'paste', {
            id: 'editor.action.clipboardPasteAction',
            label: localize('actions.clipboard.pasteLabel', "Paste"),
            alias: 'Paste',
            precondition: EditorContextKeys.writable,
            kbOpts: kbOpts,
            menuOpts: {
                group: CLIPBOARD_CONTEXT_MENU_GROUP,
                order: 3
            }
        }) || this;
        return _this;
    }
    return ExecCommandPasteAction;
}(ExecCommandAction));
var ExecCommandCopyWithSyntaxHighlightingAction = /** @class */ (function (_super) {
    __extends$3(ExecCommandCopyWithSyntaxHighlightingAction, _super);
    function ExecCommandCopyWithSyntaxHighlightingAction() {
        return _super.call(this, 'copy', {
            id: 'editor.action.clipboardCopyWithSyntaxHighlightingAction',
            label: localize('actions.clipboard.copyWithSyntaxHighlightingLabel', "Copy With Syntax Highlighting"),
            alias: 'Copy With Syntax Highlighting',
            precondition: null,
            kbOpts: {
                kbExpr: EditorContextKeys.textInputFocus,
                primary: null
            }
        }) || this;
    }
    ExecCommandCopyWithSyntaxHighlightingAction.prototype.run = function (accessor, editor) {
        var emptySelectionClipboard = editor.getConfiguration().emptySelectionClipboard;
        if (!emptySelectionClipboard && editor.getSelection().isEmpty()) {
            return;
        }
        CopyOptions.forceCopyWithSyntaxHighlighting = true;
        _super.prototype.run.call(this, accessor, editor);
        CopyOptions.forceCopyWithSyntaxHighlighting = false;
    };
    return ExecCommandCopyWithSyntaxHighlightingAction;
}(ExecCommandAction));
if (supportsCut) {
    registerEditorAction(ExecCommandCutAction);
}
if (supportsCopy) {
    registerEditorAction(ExecCommandCopyAction);
}
if (supportsPaste) {
    registerEditorAction(ExecCommandPasteAction);
}
if (supportsCopyWithSyntaxHighlighting) {
    registerEditorAction(ExecCommandCopyWithSyntaxHighlightingAction);
}

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
function getCodeLensData(model) {
    var symbols = [];
    var provider = CodeLensProviderRegistry.ordered(model);
    var promises = provider.map(function (provider) { return asWinJsPromise(function (token) { return provider.provideCodeLenses(model, token); }).then(function (result) {
        if (Array.isArray(result)) {
            for (var _i = 0, result_1 = result; _i < result_1.length; _i++) {
                var symbol = result_1[_i];
                symbols.push({ symbol: symbol, provider: provider });
            }
        }
    }, onUnexpectedExternalError); });
    return TPromise.join(promises).then(function () {
        return mergeSort(symbols, function (a, b) {
            // sort by lineNumber, provider-rank, and column
            if (a.symbol.range.startLineNumber < b.symbol.range.startLineNumber) {
                return -1;
            }
            else if (a.symbol.range.startLineNumber > b.symbol.range.startLineNumber) {
                return 1;
            }
            else if (provider.indexOf(a.provider) < provider.indexOf(b.provider)) {
                return -1;
            }
            else if (provider.indexOf(a.provider) > provider.indexOf(b.provider)) {
                return 1;
            }
            else if (a.symbol.range.startColumn < b.symbol.range.startColumn) {
                return -1;
            }
            else if (a.symbol.range.startColumn > b.symbol.range.startColumn) {
                return 1;
            }
            else {
                return 0;
            }
        });
    });
}
registerLanguageCommand('_executeCodeLensProvider', function (accessor, args) {
    var resource = args.resource, itemResolveCount = args.itemResolveCount;
    if (!(resource instanceof URI)) {
        throw illegalArgument();
    }
    var model = accessor.get(IModelService).getModel(resource);
    if (!model) {
        throw illegalArgument();
    }
    var result = [];
    return getCodeLensData(model).then(function (value) {
        var resolve = [];
        for (var _i = 0, value_1 = value; _i < value_1.length; _i++) {
            var item = value_1[_i];
            if (typeof itemResolveCount === 'undefined' || Boolean(item.symbol.command)) {
                result.push(item.symbol);
            }
            else if (itemResolveCount-- > 0) {
                resolve.push(Promise.resolve(item.provider.resolveCodeLens(model, item.symbol, CancellationToken.None)).then(function (symbol) { return result.push(symbol); }));
            }
        }
        return Promise.all(resolve);
    }).then(function () {
        return result;
    });
});

const css$2 = "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n.monaco-editor .codelens-decoration {\n\toverflow: hidden;\n\tdisplay: inline-block;\n\ttext-overflow: ellipsis;\n}\n\n.monaco-editor .codelens-decoration > span,\n.monaco-editor .codelens-decoration > a {\n\t-moz-user-select: none;\n\t-webkit-user-select: none;\n\t-ms-user-select: none;\n\tuser-select: none;\n\twhite-space: nowrap;\n\tvertical-align: sub;\n}\n\n.monaco-editor .codelens-decoration > a {\n\ttext-decoration: none;\n}\n\n.monaco-editor .codelens-decoration > a:hover {\n\ttext-decoration: underline;\n\tcursor: pointer;\n}\n\n.monaco-editor .codelens-decoration.invisible-cl {\n\topacity: 0;\n}\n\n@keyframes fadein { 0% { opacity:0; visibility:visible;} 100% { opacity:1; } }\n@-moz-keyframes fadein { 0% { opacity:0; visibility:visible;} 100% { opacity:1; } }\n@-o-keyframes fadein { 0% { opacity:0; visibility:visible;} 100% { opacity:1; } }\n@-webkit-keyframes fadein { 0% { opacity:0; visibility:visible;} 100% { opacity:1; } }\n\n.monaco-editor .codelens-decoration.fadein {\n\t-webkit-animation: fadein 0.5s linear;\n\t-moz-animation: fadein 0.5s linear;\n\t-o-animation: fadein 0.5s linear;\n\tanimation: fadein 0.5s linear;\n}\n";
  const element$2 = ((css, src) => {
if (typeof document !== 'object')
console.info(`Skipped loading "${src}"`);
try {
const id = src
  .replace(/\.css.*$/, '')
  .replace(/[\\:]/g, '/')
  .replace(/[^\w\/]+/g, '');
return (
  document.querySelector(`style[id="${id}"]`) ||
  document.head.appendChild(
    Object.assign(document.createElement('style'), {
      id,
      textContent: `${css}\n\n /* sourceURL=${src} */`,
    }),
  )
);
} catch (exception) {
console.warn(`Failed load "${src}"`, exception);
}
})(css$2, "…monaco-editor/esm/vs/editor/contrib/codelens/codelensWidget.css");
  //@ sourceURL=/Users/daflair/Projects/packages/monaco-es/node_modules/monaco-editor/esm/vs/editor/contrib/codelens/codelensWidget.css

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var CodeLensViewZone = /** @class */ (function () {
    function CodeLensViewZone(afterLineNumber, onHeight) {
        this.afterLineNumber = afterLineNumber;
        this._onHeight = onHeight;
        this.heightInLines = 1;
        this.suppressMouseDown = true;
        this.domNode = document.createElement('div');
    }
    CodeLensViewZone.prototype.onComputedHeight = function (height) {
        if (this._lastHeight === undefined) {
            this._lastHeight = height;
        }
        else if (this._lastHeight !== height) {
            this._lastHeight = height;
            this._onHeight();
        }
    };
    return CodeLensViewZone;
}());
var CodeLensContentWidget = /** @class */ (function () {
    function CodeLensContentWidget(editor, symbolRange, commandService, notificationService) {
        var _this = this;
        // Editor.IContentWidget.allowEditorOverflow
        this.allowEditorOverflow = false;
        this.suppressMouseDown = true;
        this._disposables = [];
        this._commands = Object.create(null);
        this._id = 'codeLensWidget' + (++CodeLensContentWidget._idPool);
        this._editor = editor;
        this.setSymbolRange(symbolRange);
        this._domNode = document.createElement('span');
        this._domNode.innerHTML = '&nbsp;';
        addClass(this._domNode, 'codelens-decoration');
        addClass(this._domNode, 'invisible-cl');
        this._updateHeight();
        this._disposables.push(this._editor.onDidChangeConfiguration(function (e) { return e.fontInfo && _this._updateHeight(); }));
        this._disposables.push(addDisposableListener(this._domNode, 'click', function (e) {
            var element = e.target;
            if (element.tagName === 'A' && element.id) {
                var command = _this._commands[element.id];
                if (command) {
                    editor.focus();
                    commandService.executeCommand.apply(commandService, [command.id].concat(command.arguments)).done(undefined, function (err) {
                        notificationService.error(err);
                    });
                }
            }
        }));
        this.updateVisibility();
    }
    CodeLensContentWidget.prototype.dispose = function () {
        dispose(this._disposables);
    };
    CodeLensContentWidget.prototype._updateHeight = function () {
        var _a = this._editor.getConfiguration(), fontInfo = _a.fontInfo, lineHeight = _a.lineHeight;
        this._domNode.style.height = Math.round(lineHeight * 1.1) + "px";
        this._domNode.style.lineHeight = lineHeight + "px";
        this._domNode.style.fontSize = Math.round(fontInfo.fontSize * .9) + "px";
        this._domNode.innerHTML = '&nbsp;';
    };
    CodeLensContentWidget.prototype.updateVisibility = function () {
        if (this.isVisible()) {
            removeClass(this._domNode, 'invisible-cl');
            addClass(this._domNode, 'fadein');
        }
    };
    CodeLensContentWidget.prototype.withCommands = function (symbols) {
        this._commands = Object.create(null);
        if (!symbols || !symbols.length) {
            this._domNode.innerHTML = 'no commands';
            return;
        }
        var html = [];
        for (var i = 0; i < symbols.length; i++) {
            var command = symbols[i].command;
            var title = escape(command.title);
            var part = void 0;
            if (command.id) {
                part = format('<a id={0}>{1}</a>', i, title);
                this._commands[i] = command;
            }
            else {
                part = format('<span>{0}</span>', title);
            }
            html.push(part);
        }
        this._domNode.innerHTML = html.join('<span>&nbsp;|&nbsp;</span>');
        this._editor.layoutContentWidget(this);
    };
    CodeLensContentWidget.prototype.getId = function () {
        return this._id;
    };
    CodeLensContentWidget.prototype.getDomNode = function () {
        return this._domNode;
    };
    CodeLensContentWidget.prototype.setSymbolRange = function (range$$1) {
        var lineNumber = range$$1.startLineNumber;
        var column = this._editor.getModel().getLineFirstNonWhitespaceColumn(lineNumber);
        this._widgetPosition = {
            position: { lineNumber: lineNumber, column: column },
            preference: [ContentWidgetPositionPreference.ABOVE]
        };
    };
    CodeLensContentWidget.prototype.getPosition = function () {
        return this._widgetPosition;
    };
    CodeLensContentWidget.prototype.isVisible = function () {
        return this._domNode.hasAttribute('monaco-visible-content-widget');
    };
    CodeLensContentWidget._idPool = 0;
    return CodeLensContentWidget;
}());
var CodeLensHelper = /** @class */ (function () {
    function CodeLensHelper() {
        this._removeDecorations = [];
        this._addDecorations = [];
        this._addDecorationsCallbacks = [];
    }
    CodeLensHelper.prototype.addDecoration = function (decoration, callback) {
        this._addDecorations.push(decoration);
        this._addDecorationsCallbacks.push(callback);
    };
    CodeLensHelper.prototype.removeDecoration = function (decorationId) {
        this._removeDecorations.push(decorationId);
    };
    CodeLensHelper.prototype.commit = function (changeAccessor) {
        var resultingDecorations = changeAccessor.deltaDecorations(this._removeDecorations, this._addDecorations);
        for (var i = 0, len = resultingDecorations.length; i < len; i++) {
            this._addDecorationsCallbacks[i](resultingDecorations[i]);
        }
    };
    return CodeLensHelper;
}());
var CodeLens = /** @class */ (function () {
    function CodeLens(data, editor, helper, viewZoneChangeAccessor, commandService, notificationService, updateCallabck) {
        var _this = this;
        this._editor = editor;
        this._data = data;
        this._decorationIds = new Array(this._data.length);
        var range$$1;
        this._data.forEach(function (codeLensData, i) {
            helper.addDecoration({
                range: codeLensData.symbol.range,
                options: ModelDecorationOptions.EMPTY
            }, function (id) { return _this._decorationIds[i] = id; });
            // the range contains all lenses on this line
            if (!range$$1) {
                range$$1 = Range.lift(codeLensData.symbol.range);
            }
            else {
                range$$1 = Range.plusRange(range$$1, codeLensData.symbol.range);
            }
        });
        this._contentWidget = new CodeLensContentWidget(editor, range$$1, commandService, notificationService);
        this._viewZone = new CodeLensViewZone(range$$1.startLineNumber - 1, updateCallabck);
        this._viewZoneId = viewZoneChangeAccessor.addZone(this._viewZone);
        this._editor.addContentWidget(this._contentWidget);
    }
    CodeLens.prototype.dispose = function (helper, viewZoneChangeAccessor) {
        while (this._decorationIds.length) {
            helper.removeDecoration(this._decorationIds.pop());
        }
        if (viewZoneChangeAccessor) {
            viewZoneChangeAccessor.removeZone(this._viewZoneId);
        }
        this._editor.removeContentWidget(this._contentWidget);
        this._contentWidget.dispose();
    };
    CodeLens.prototype.isValid = function () {
        var _this = this;
        return this._decorationIds.some(function (id, i) {
            var range$$1 = _this._editor.getModel().getDecorationRange(id);
            var symbol = _this._data[i].symbol;
            return range$$1 && Range.isEmpty(symbol.range) === range$$1.isEmpty();
        });
    };
    CodeLens.prototype.updateCodeLensSymbols = function (data, helper) {
        var _this = this;
        while (this._decorationIds.length) {
            helper.removeDecoration(this._decorationIds.pop());
        }
        this._data = data;
        this._decorationIds = new Array(this._data.length);
        this._data.forEach(function (codeLensData, i) {
            helper.addDecoration({
                range: codeLensData.symbol.range,
                options: ModelDecorationOptions.EMPTY
            }, function (id) { return _this._decorationIds[i] = id; });
        });
    };
    CodeLens.prototype.computeIfNecessary = function (model) {
        this._contentWidget.updateVisibility(); // trigger the fade in
        if (!this._contentWidget.isVisible()) {
            return null;
        }
        // Read editor current state
        for (var i = 0; i < this._decorationIds.length; i++) {
            this._data[i].symbol.range = model.getDecorationRange(this._decorationIds[i]);
        }
        return this._data;
    };
    CodeLens.prototype.updateCommands = function (symbols) {
        this._contentWidget.withCommands(symbols);
    };
    CodeLens.prototype.getLineNumber = function () {
        var range$$1 = this._editor.getModel().getDecorationRange(this._decorationIds[0]);
        if (range$$1) {
            return range$$1.startLineNumber;
        }
        return -1;
    };
    CodeLens.prototype.update = function (viewZoneChangeAccessor) {
        if (this.isValid()) {
            var range$$1 = this._editor.getModel().getDecorationRange(this._decorationIds[0]);
            this._viewZone.afterLineNumber = range$$1.startLineNumber - 1;
            viewZoneChangeAccessor.layoutZone(this._viewZoneId);
            this._contentWidget.setSymbolRange(range$$1);
            this._editor.layoutContentWidget(this._contentWidget);
        }
    };
    return CodeLens;
}());
registerThemingParticipant(function (theme, collector) {
    var codeLensForeground = theme.getColor(editorCodeLensForeground);
    if (codeLensForeground) {
        collector.addRule(".monaco-editor .codelens-decoration { color: " + codeLensForeground + "; }");
    }
    var activeLinkForeground = theme.getColor(editorActiveLinkForeground);
    if (activeLinkForeground) {
        collector.addRule(".monaco-editor .codelens-decoration > a:hover { color: " + activeLinkForeground + " !important; }");
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var CodeLensContribution = /** @class */ (function () {
    function CodeLensContribution(_editor, _commandService, _notificationService) {
        var _this = this;
        this._editor = _editor;
        this._commandService = _commandService;
        this._notificationService = _notificationService;
        this._isEnabled = this._editor.getConfiguration().contribInfo.codeLens;
        this._globalToDispose = [];
        this._localToDispose = [];
        this._lenses = [];
        this._currentFindCodeLensSymbolsPromise = null;
        this._modelChangeCounter = 0;
        this._globalToDispose.push(this._editor.onDidChangeModel(function () { return _this._onModelChange(); }));
        this._globalToDispose.push(this._editor.onDidChangeModelLanguage(function () { return _this._onModelChange(); }));
        this._globalToDispose.push(this._editor.onDidChangeConfiguration(function (e) {
            var prevIsEnabled = _this._isEnabled;
            _this._isEnabled = _this._editor.getConfiguration().contribInfo.codeLens;
            if (prevIsEnabled !== _this._isEnabled) {
                _this._onModelChange();
            }
        }));
        this._globalToDispose.push(CodeLensProviderRegistry.onDidChange(this._onModelChange, this));
        this._onModelChange();
    }
    CodeLensContribution.prototype.dispose = function () {
        this._localDispose();
        this._globalToDispose = dispose(this._globalToDispose);
    };
    CodeLensContribution.prototype._localDispose = function () {
        if (this._currentFindCodeLensSymbolsPromise) {
            this._currentFindCodeLensSymbolsPromise.cancel();
            this._currentFindCodeLensSymbolsPromise = null;
            this._modelChangeCounter++;
        }
        if (this._currentFindOccPromise) {
            this._currentFindOccPromise.cancel();
            this._currentFindOccPromise = null;
        }
        this._localToDispose = dispose(this._localToDispose);
    };
    CodeLensContribution.prototype.getId = function () {
        return CodeLensContribution.ID;
    };
    CodeLensContribution.prototype._onModelChange = function () {
        var _this = this;
        this._localDispose();
        var model = this._editor.getModel();
        if (!model) {
            return;
        }
        if (!this._isEnabled) {
            return;
        }
        if (!CodeLensProviderRegistry.has(model)) {
            return;
        }
        for (var _i = 0, _a = CodeLensProviderRegistry.all(model); _i < _a.length; _i++) {
            var provider = _a[_i];
            if (typeof provider.onDidChange === 'function') {
                var registration = provider.onDidChange(function () { return scheduler.schedule(); });
                this._localToDispose.push(registration);
            }
        }
        this._detectVisibleLenses = new RunOnceScheduler(function () {
            _this._onViewportChanged();
        }, 500);
        var scheduler = new RunOnceScheduler(function () {
            var counterValue = ++_this._modelChangeCounter;
            if (_this._currentFindCodeLensSymbolsPromise) {
                _this._currentFindCodeLensSymbolsPromise.cancel();
            }
            _this._currentFindCodeLensSymbolsPromise = getCodeLensData(model);
            _this._currentFindCodeLensSymbolsPromise.then(function (result) {
                if (counterValue === _this._modelChangeCounter) { // only the last one wins
                    _this._renderCodeLensSymbols(result);
                    _this._detectVisibleLenses.schedule();
                }
            }, onUnexpectedError);
        }, 250);
        this._localToDispose.push(scheduler);
        this._localToDispose.push(this._detectVisibleLenses);
        this._localToDispose.push(this._editor.onDidChangeModelContent(function (e) {
            _this._editor.changeDecorations(function (changeAccessor) {
                _this._editor.changeViewZones(function (viewAccessor) {
                    var toDispose = [];
                    var lastLensLineNumber = -1;
                    _this._lenses.forEach(function (lens) {
                        if (!lens.isValid() || lastLensLineNumber === lens.getLineNumber()) {
                            // invalid -> lens collapsed, attach range doesn't exist anymore
                            // line_number -> lenses should never be on the same line
                            toDispose.push(lens);
                        }
                        else {
                            lens.update(viewAccessor);
                            lastLensLineNumber = lens.getLineNumber();
                        }
                    });
                    var helper = new CodeLensHelper();
                    toDispose.forEach(function (l) {
                        l.dispose(helper, viewAccessor);
                        _this._lenses.splice(_this._lenses.indexOf(l), 1);
                    });
                    helper.commit(changeAccessor);
                });
            });
            // Compute new `visible` code lenses
            _this._detectVisibleLenses.schedule();
            // Ask for all references again
            scheduler.schedule();
        }));
        this._localToDispose.push(this._editor.onDidScrollChange(function (e) {
            if (e.scrollTopChanged && _this._lenses.length > 0) {
                _this._detectVisibleLenses.schedule();
            }
        }));
        this._localToDispose.push(this._editor.onDidLayoutChange(function (e) {
            _this._detectVisibleLenses.schedule();
        }));
        this._localToDispose.push({
            dispose: function () {
                if (_this._editor.getModel()) {
                    var scrollState = StableEditorScrollState.capture(_this._editor);
                    _this._editor.changeDecorations(function (changeAccessor) {
                        _this._editor.changeViewZones(function (accessor) {
                            _this._disposeAllLenses(changeAccessor, accessor);
                        });
                    });
                    scrollState.restore(_this._editor);
                }
                else {
                    // No accessors available
                    _this._disposeAllLenses(null, null);
                }
            }
        });
        scheduler.schedule();
    };
    CodeLensContribution.prototype._disposeAllLenses = function (decChangeAccessor, viewZoneChangeAccessor) {
        var helper = new CodeLensHelper();
        this._lenses.forEach(function (lens) { return lens.dispose(helper, viewZoneChangeAccessor); });
        if (decChangeAccessor) {
            helper.commit(decChangeAccessor);
        }
        this._lenses = [];
    };
    CodeLensContribution.prototype._renderCodeLensSymbols = function (symbols) {
        var _this = this;
        if (!this._editor.getModel()) {
            return;
        }
        var maxLineNumber = this._editor.getModel().getLineCount();
        var groups = [];
        var lastGroup;
        for (var _i = 0, symbols_1 = symbols; _i < symbols_1.length; _i++) {
            var symbol = symbols_1[_i];
            var line = symbol.symbol.range.startLineNumber;
            if (line < 1 || line > maxLineNumber) {
                // invalid code lens
                continue;
            }
            else if (lastGroup && lastGroup[lastGroup.length - 1].symbol.range.startLineNumber === line) {
                // on same line as previous
                lastGroup.push(symbol);
            }
            else {
                // on later line as previous
                lastGroup = [symbol];
                groups.push(lastGroup);
            }
        }
        var scrollState = StableEditorScrollState.capture(this._editor);
        this._editor.changeDecorations(function (changeAccessor) {
            _this._editor.changeViewZones(function (accessor) {
                var codeLensIndex = 0, groupsIndex = 0, helper = new CodeLensHelper();
                while (groupsIndex < groups.length && codeLensIndex < _this._lenses.length) {
                    var symbolsLineNumber = groups[groupsIndex][0].symbol.range.startLineNumber;
                    var codeLensLineNumber = _this._lenses[codeLensIndex].getLineNumber();
                    if (codeLensLineNumber < symbolsLineNumber) {
                        _this._lenses[codeLensIndex].dispose(helper, accessor);
                        _this._lenses.splice(codeLensIndex, 1);
                    }
                    else if (codeLensLineNumber === symbolsLineNumber) {
                        _this._lenses[codeLensIndex].updateCodeLensSymbols(groups[groupsIndex], helper);
                        groupsIndex++;
                        codeLensIndex++;
                    }
                    else {
                        _this._lenses.splice(codeLensIndex, 0, new CodeLens(groups[groupsIndex], _this._editor, helper, accessor, _this._commandService, _this._notificationService, function () { return _this._detectVisibleLenses.schedule(); }));
                        codeLensIndex++;
                        groupsIndex++;
                    }
                }
                // Delete extra code lenses
                while (codeLensIndex < _this._lenses.length) {
                    _this._lenses[codeLensIndex].dispose(helper, accessor);
                    _this._lenses.splice(codeLensIndex, 1);
                }
                // Create extra symbols
                while (groupsIndex < groups.length) {
                    _this._lenses.push(new CodeLens(groups[groupsIndex], _this._editor, helper, accessor, _this._commandService, _this._notificationService, function () { return _this._detectVisibleLenses.schedule(); }));
                    groupsIndex++;
                }
                helper.commit(changeAccessor);
            });
        });
        scrollState.restore(this._editor);
    };
    CodeLensContribution.prototype._onViewportChanged = function () {
        var _this = this;
        if (this._currentFindOccPromise) {
            this._currentFindOccPromise.cancel();
            this._currentFindOccPromise = null;
        }
        var model = this._editor.getModel();
        if (!model) {
            return;
        }
        var toResolve = [];
        var lenses = [];
        this._lenses.forEach(function (lens) {
            var request = lens.computeIfNecessary(model);
            if (request) {
                toResolve.push(request);
                lenses.push(lens);
            }
        });
        if (toResolve.length === 0) {
            return;
        }
        var promises = toResolve.map(function (request, i) {
            var resolvedSymbols = new Array(request.length);
            var promises = request.map(function (request, i) {
                if (typeof request.provider.resolveCodeLens === 'function') {
                    return asWinJsPromise(function (token) {
                        return request.provider.resolveCodeLens(model, request.symbol, token);
                    }).then(function (symbol) {
                        resolvedSymbols[i] = symbol;
                    });
                }
                resolvedSymbols[i] = request.symbol;
                return TPromise.as(void 0);
            });
            return TPromise.join(promises).then(function () {
                lenses[i].updateCommands(resolvedSymbols);
            });
        });
        this._currentFindOccPromise = TPromise.join(promises).then(function () {
            _this._currentFindOccPromise = null;
        });
    };
    CodeLensContribution.ID = 'css.editor.codeLens';
    CodeLensContribution = __decorate([
        __param(1, ICommandService),
        __param(2, INotificationService)
    ], CodeLensContribution);
    return CodeLensContribution;
}());
registerEditorContribution(CodeLensContribution);

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
function getColors(model) {
    var colors = [];
    var providers = ColorProviderRegistry.ordered(model).reverse();
    var promises = providers.map(function (provider) { return asWinJsPromise(function (token) { return provider.provideDocumentColors(model, token); }).then(function (result) {
        if (Array.isArray(result)) {
            for (var _i = 0, result_1 = result; _i < result_1.length; _i++) {
                var colorInfo = result_1[_i];
                colors.push({ colorInfo: colorInfo, provider: provider });
            }
        }
    }); });
    return TPromise.join(promises).then(function () { return colors; });
}
function getColorPresentations(model, colorInfo, provider) {
    return asWinJsPromise(function (token) { return provider.provideColorPresentations(model, colorInfo, token); });
}
registerLanguageCommand('_executeDocumentColorProvider', function (accessor, args) {
    var resource = args.resource;
    if (!(resource instanceof URI)) {
        throw illegalArgument();
    }
    var model = accessor.get(IModelService).getModel(resource);
    if (!model) {
        throw illegalArgument();
    }
    var rawCIs = [];
    var providers = ColorProviderRegistry.ordered(model).reverse();
    var promises = providers.map(function (provider) { return asWinJsPromise(function (token) { return provider.provideDocumentColors(model, token); }).then(function (result) {
        if (Array.isArray(result)) {
            for (var _i = 0, result_2 = result; _i < result_2.length; _i++) {
                var ci = result_2[_i];
                rawCIs.push({ range: ci.range, color: [ci.color.red, ci.color.green, ci.color.blue, ci.color.alpha] });
            }
        }
    }); });
    return TPromise.join(promises).then(function () { return rawCIs; });
});
registerLanguageCommand('_executeColorPresentationProvider', function (accessor, args) {
    var resource = args.resource, color = args.color, range$$1 = args.range;
    if (!(resource instanceof URI) || !Array.isArray(color) || color.length !== 4 || !Range.isIRange(range$$1)) {
        throw illegalArgument();
    }
    var red = color[0], green = color[1], blue = color[2], alpha = color[3];
    var model = accessor.get(IModelService).getModel(resource);
    if (!model) {
        throw illegalArgument();
    }
    var colorInfo = {
        range: range$$1,
        color: { red: red, green: green, blue: blue, alpha: alpha }
    };
    var presentations = [];
    var providers = ColorProviderRegistry.ordered(model).reverse();
    var promises = providers.map(function (provider) { return asWinJsPromise(function (token) { return provider.provideColorPresentations(model, colorInfo, token); }).then(function (result) {
        if (Array.isArray(result)) {
            presentations.push.apply(presentations, result);
        }
    }); });
    return TPromise.join(promises).then(function () { return presentations; });
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __decorate$1 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$1 = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var MAX_DECORATORS = 500;
var ColorDetector = /** @class */ (function () {
    function ColorDetector(_editor, _codeEditorService, _configurationService) {
        var _this = this;
        this._editor = _editor;
        this._codeEditorService = _codeEditorService;
        this._configurationService = _configurationService;
        this._globalToDispose = [];
        this._localToDispose = [];
        this._decorationsIds = [];
        this._colorDatas = new Map();
        this._colorDecoratorIds = [];
        this._decorationsTypes = {};
        this._globalToDispose.push(_editor.onDidChangeModel(function (e) {
            _this._isEnabled = _this.isEnabled();
            _this.onModelChanged();
        }));
        this._globalToDispose.push(_editor.onDidChangeModelLanguage(function (e) { return _this.onModelChanged(); }));
        this._globalToDispose.push(ColorProviderRegistry.onDidChange(function (e) { return _this.onModelChanged(); }));
        this._globalToDispose.push(_editor.onDidChangeConfiguration(function (e) {
            var prevIsEnabled = _this._isEnabled;
            _this._isEnabled = _this.isEnabled();
            if (prevIsEnabled !== _this._isEnabled) {
                if (_this._isEnabled) {
                    _this.onModelChanged();
                }
                else {
                    _this.removeAllDecorations();
                }
            }
        }));
        this._timeoutPromise = null;
        this._computePromise = null;
        this._isEnabled = this.isEnabled();
        this.onModelChanged();
    }
    ColorDetector.prototype.isEnabled = function () {
        var model = this._editor.getModel();
        if (!model) {
            return false;
        }
        var languageId = model.getLanguageIdentifier();
        // handle deprecated settings. [languageId].colorDecorators.enable
        var deprecatedConfig = this._configurationService.getValue(languageId.language);
        if (deprecatedConfig) {
            var colorDecorators = deprecatedConfig['colorDecorators']; // deprecatedConfig.valueOf('.colorDecorators.enable');
            if (colorDecorators && colorDecorators['enable'] !== undefined && !colorDecorators['enable']) {
                return colorDecorators['enable'];
            }
        }
        return this._editor.getConfiguration().contribInfo.colorDecorators;
    };
    ColorDetector.prototype.getId = function () {
        return ColorDetector.ID;
    };
    ColorDetector.get = function (editor) {
        return editor.getContribution(this.ID);
    };
    ColorDetector.prototype.dispose = function () {
        this.stop();
        this.removeAllDecorations();
        this._globalToDispose = dispose(this._globalToDispose);
    };
    ColorDetector.prototype.onModelChanged = function () {
        var _this = this;
        this.stop();
        if (!this._isEnabled) {
            return;
        }
        var model = this._editor.getModel();
        // if (!model) {
        // 	return;
        // }
        if (!ColorProviderRegistry.has(model)) {
            return;
        }
        this._localToDispose.push(this._editor.onDidChangeModelContent(function (e) {
            if (!_this._timeoutPromise) {
                _this._timeoutPromise = TPromise.timeout(ColorDetector.RECOMPUTE_TIME);
                _this._timeoutPromise.then(function () {
                    _this._timeoutPromise = null;
                    _this.beginCompute();
                });
            }
        }));
        this.beginCompute();
    };
    ColorDetector.prototype.beginCompute = function () {
        var _this = this;
        this._computePromise = getColors(this._editor.getModel()).then(function (colorInfos) {
            _this.updateDecorations(colorInfos);
            _this.updateColorDecorators(colorInfos);
            _this._computePromise = null;
        });
    };
    ColorDetector.prototype.stop = function () {
        if (this._timeoutPromise) {
            this._timeoutPromise.cancel();
            this._timeoutPromise = null;
        }
        if (this._computePromise) {
            this._computePromise.cancel();
            this._computePromise = null;
        }
        this._localToDispose = dispose(this._localToDispose);
    };
    ColorDetector.prototype.updateDecorations = function (colorDatas) {
        var _this = this;
        var decorations = colorDatas.map(function (c) { return ({
            range: {
                startLineNumber: c.colorInfo.range.startLineNumber,
                startColumn: c.colorInfo.range.startColumn,
                endLineNumber: c.colorInfo.range.endLineNumber,
                endColumn: c.colorInfo.range.endColumn
            },
            options: ModelDecorationOptions.EMPTY
        }); });
        this._decorationsIds = this._editor.deltaDecorations(this._decorationsIds, decorations);
        this._colorDatas = new Map();
        this._decorationsIds.forEach(function (id, i) { return _this._colorDatas.set(id, colorDatas[i]); });
    };
    ColorDetector.prototype.updateColorDecorators = function (colorData) {
        var decorations = [];
        var newDecorationsTypes = {};
        for (var i = 0; i < colorData.length && decorations.length < MAX_DECORATORS; i++) {
            var _a = colorData[i].colorInfo.color, red = _a.red, green = _a.green, blue = _a.blue, alpha = _a.alpha;
            var rgba = new RGBA(Math.round(red * 255), Math.round(green * 255), Math.round(blue * 255), alpha);
            var subKey = hash(rgba).toString(16);
            var color = "rgba(" + rgba.r + ", " + rgba.g + ", " + rgba.b + ", " + rgba.a + ")";
            var key = 'colorBox-' + subKey;
            if (!this._decorationsTypes[key] && !newDecorationsTypes[key]) {
                this._codeEditorService.registerDecorationType(key, {
                    before: {
                        contentText: ' ',
                        border: 'solid 0.1em #000',
                        margin: '0.1em 0.2em 0 0.2em',
                        width: '0.8em',
                        height: '0.8em',
                        backgroundColor: color
                    },
                    dark: {
                        before: {
                            border: 'solid 0.1em #eee'
                        }
                    }
                });
            }
            newDecorationsTypes[key] = true;
            decorations.push({
                range: {
                    startLineNumber: colorData[i].colorInfo.range.startLineNumber,
                    startColumn: colorData[i].colorInfo.range.startColumn,
                    endLineNumber: colorData[i].colorInfo.range.endLineNumber,
                    endColumn: colorData[i].colorInfo.range.endColumn
                },
                options: this._codeEditorService.resolveDecorationOptions(key, true)
            });
        }
        for (var subType in this._decorationsTypes) {
            if (!newDecorationsTypes[subType]) {
                this._codeEditorService.removeDecorationType(subType);
            }
        }
        this._colorDecoratorIds = this._editor.deltaDecorations(this._colorDecoratorIds, decorations);
    };
    ColorDetector.prototype.removeAllDecorations = function () {
        this._decorationsIds = this._editor.deltaDecorations(this._decorationsIds, []);
        this._colorDecoratorIds = this._editor.deltaDecorations(this._colorDecoratorIds, []);
        for (var subType in this._decorationsTypes) {
            this._codeEditorService.removeDecorationType(subType);
        }
    };
    ColorDetector.prototype.getColorData = function (position) {
        var _this = this;
        var decorations = this._editor.getModel()
            .getDecorationsInRange(Range.fromPositions(position, position))
            .filter(function (d) { return _this._colorDatas.has(d.id); });
        if (decorations.length === 0) {
            return null;
        }
        return this._colorDatas.get(decorations[0].id);
    };
    ColorDetector.ID = 'editor.contrib.colorDetector';
    ColorDetector.RECOMPUTE_TIME = 1000; // ms
    ColorDetector = __decorate$1([
        __param$1(1, ICodeEditorService),
        __param$1(2, IConfigurationService)
    ], ColorDetector);
    return ColorDetector;
}());
registerEditorContribution(ColorDetector);

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var BlockCommentCommand = /** @class */ (function () {
    function BlockCommentCommand(selection) {
        this._selection = selection;
        this._usedEndToken = null;
    }
    BlockCommentCommand._haystackHasNeedleAtOffset = function (haystack, needle, offset) {
        if (offset < 0) {
            return false;
        }
        var needleLength = needle.length;
        var haystackLength = haystack.length;
        if (offset + needleLength > haystackLength) {
            return false;
        }
        for (var i = 0; i < needleLength; i++) {
            var codeA = haystack.charCodeAt(offset + i);
            var codeB = needle.charCodeAt(i);
            if (codeA === codeB) {
                continue;
            }
            if (codeA >= 65 /* A */ && codeA <= 90 /* Z */ && codeA + 32 === codeB) {
                // codeA is upper-case variant of codeB
                continue;
            }
            if (codeB >= 65 /* A */ && codeB <= 90 /* Z */ && codeB + 32 === codeA) {
                // codeB is upper-case variant of codeA
                continue;
            }
            return false;
        }
        return true;
    };
    BlockCommentCommand.prototype._createOperationsForBlockComment = function (selection, config, model, builder) {
        var startLineNumber = selection.startLineNumber;
        var startColumn = selection.startColumn;
        var endLineNumber = selection.endLineNumber;
        var endColumn = selection.endColumn;
        var startLineText = model.getLineContent(startLineNumber);
        var endLineText = model.getLineContent(endLineNumber);
        var startToken = config.blockCommentStartToken;
        var endToken = config.blockCommentEndToken;
        var startTokenIndex = startLineText.lastIndexOf(startToken, startColumn - 1 + startToken.length);
        var endTokenIndex = endLineText.indexOf(endToken, endColumn - 1 - endToken.length);
        if (startTokenIndex !== -1 && endTokenIndex !== -1) {
            if (startLineNumber === endLineNumber) {
                var lineBetweenTokens = startLineText.substring(startTokenIndex + startToken.length, endTokenIndex);
                if (lineBetweenTokens.indexOf(endToken) >= 0) {
                    // force to add a block comment
                    startTokenIndex = -1;
                    endTokenIndex = -1;
                }
            }
            else {
                var startLineAfterStartToken = startLineText.substring(startTokenIndex + startToken.length);
                var endLineBeforeEndToken = endLineText.substring(0, endTokenIndex);
                if (startLineAfterStartToken.indexOf(endToken) >= 0 || endLineBeforeEndToken.indexOf(endToken) >= 0) {
                    // force to add a block comment
                    startTokenIndex = -1;
                    endTokenIndex = -1;
                }
            }
        }
        var ops;
        if (startTokenIndex !== -1 && endTokenIndex !== -1) {
            // Consider spaces as part of the comment tokens
            if (startTokenIndex + startToken.length < startLineText.length) {
                if (startLineText.charCodeAt(startTokenIndex + startToken.length) === 32 /* Space */) {
                    // Pretend the start token contains a trailing space
                    startToken = startToken + ' ';
                }
            }
            if (endTokenIndex > 0) {
                if (endLineText.charCodeAt(endTokenIndex - 1) === 32 /* Space */) {
                    // Pretend the end token contains a leading space
                    endToken = ' ' + endToken;
                    endTokenIndex -= 1;
                }
            }
            ops = BlockCommentCommand._createRemoveBlockCommentOperations(new Range(startLineNumber, startTokenIndex + startToken.length + 1, endLineNumber, endTokenIndex + 1), startToken, endToken);
        }
        else {
            ops = BlockCommentCommand._createAddBlockCommentOperations(selection, startToken, endToken);
            this._usedEndToken = ops.length === 1 ? endToken : null;
        }
        for (var i = 0; i < ops.length; i++) {
            builder.addTrackedEditOperation(ops[i].range, ops[i].text);
        }
    };
    BlockCommentCommand._createRemoveBlockCommentOperations = function (r, startToken, endToken) {
        var res = [];
        if (!Range.isEmpty(r)) {
            // Remove block comment start
            res.push(EditOperation.delete(new Range(r.startLineNumber, r.startColumn - startToken.length, r.startLineNumber, r.startColumn)));
            // Remove block comment end
            res.push(EditOperation.delete(new Range(r.endLineNumber, r.endColumn, r.endLineNumber, r.endColumn + endToken.length)));
        }
        else {
            // Remove both continuously
            res.push(EditOperation.delete(new Range(r.startLineNumber, r.startColumn - startToken.length, r.endLineNumber, r.endColumn + endToken.length)));
        }
        return res;
    };
    BlockCommentCommand._createAddBlockCommentOperations = function (r, startToken, endToken) {
        var res = [];
        if (!Range.isEmpty(r)) {
            // Insert block comment start
            res.push(EditOperation.insert(new Position(r.startLineNumber, r.startColumn), startToken + ' '));
            // Insert block comment end
            res.push(EditOperation.insert(new Position(r.endLineNumber, r.endColumn), ' ' + endToken));
        }
        else {
            // Insert both continuously
            res.push(EditOperation.replace(new Range(r.startLineNumber, r.startColumn, r.endLineNumber, r.endColumn), startToken + '  ' + endToken));
        }
        return res;
    };
    BlockCommentCommand.prototype.getEditOperations = function (model, builder) {
        var startLineNumber = this._selection.startLineNumber;
        var startColumn = this._selection.startColumn;
        model.tokenizeIfCheap(startLineNumber);
        var languageId = model.getLanguageIdAtPosition(startLineNumber, startColumn);
        var config = LanguageConfigurationRegistry.getComments(languageId);
        if (!config || !config.blockCommentStartToken || !config.blockCommentEndToken) {
            // Mode does not support block comments
            return;
        }
        this._createOperationsForBlockComment(this._selection, config, model, builder);
    };
    BlockCommentCommand.prototype.computeCursorState = function (model, helper) {
        var inverseEditOperations = helper.getInverseEditOperations();
        if (inverseEditOperations.length === 2) {
            var startTokenEditOperation = inverseEditOperations[0];
            var endTokenEditOperation = inverseEditOperations[1];
            return new Selection(startTokenEditOperation.range.endLineNumber, startTokenEditOperation.range.endColumn, endTokenEditOperation.range.startLineNumber, endTokenEditOperation.range.startColumn);
        }
        else {
            var srcRange = inverseEditOperations[0].range;
            var deltaColumn = this._usedEndToken ? -this._usedEndToken.length - 1 : 0; // minus 1 space before endToken
            return new Selection(srcRange.endLineNumber, srcRange.endColumn + deltaColumn, srcRange.endLineNumber, srcRange.endColumn + deltaColumn);
        }
    };
    return BlockCommentCommand;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var LineCommentCommand = /** @class */ (function () {
    function LineCommentCommand(selection, tabSize, type) {
        this._selection = selection;
        this._tabSize = tabSize;
        this._type = type;
        this._deltaColumn = 0;
    }
    /**
     * Do an initial pass over the lines and gather info about the line comment string.
     * Returns null if any of the lines doesn't support a line comment string.
     */
    LineCommentCommand._gatherPreflightCommentStrings = function (model, startLineNumber, endLineNumber) {
        model.tokenizeIfCheap(startLineNumber);
        var languageId = model.getLanguageIdAtPosition(startLineNumber, 1);
        var config = LanguageConfigurationRegistry.getComments(languageId);
        var commentStr = (config ? config.lineCommentToken : null);
        if (!commentStr) {
            // Mode does not support line comments
            return null;
        }
        var lines = [];
        for (var i = 0, lineCount = endLineNumber - startLineNumber + 1; i < lineCount; i++) {
            lines[i] = {
                ignore: false,
                commentStr: commentStr,
                commentStrOffset: 0,
                commentStrLength: commentStr.length
            };
        }
        return lines;
    };
    /**
     * Analyze lines and decide which lines are relevant and what the toggle should do.
     * Also, build up several offsets and lengths useful in the generation of editor operations.
     */
    LineCommentCommand._analyzeLines = function (type, model, lines, startLineNumber) {
        var lineData, lineContentStartOffset, commentStrEndOffset, i, lineCount, lineNumber, shouldRemoveComments, lineContent, onlyWhitespaceLines = true;
        if (type === 0 /* Toggle */) {
            shouldRemoveComments = true;
        }
        else if (type === 1 /* ForceAdd */) {
            shouldRemoveComments = false;
        }
        else {
            shouldRemoveComments = true;
        }
        for (i = 0, lineCount = lines.length; i < lineCount; i++) {
            lineData = lines[i];
            lineNumber = startLineNumber + i;
            lineContent = model.getLineContent(lineNumber);
            lineContentStartOffset = firstNonWhitespaceIndex(lineContent);
            if (lineContentStartOffset === -1) {
                // Empty or whitespace only line
                if (type === 0 /* Toggle */) {
                    lineData.ignore = true;
                }
                else if (type === 1 /* ForceAdd */) {
                    lineData.ignore = true;
                }
                else {
                    lineData.ignore = true;
                }
                lineData.commentStrOffset = lineContent.length;
                continue;
            }
            onlyWhitespaceLines = false;
            lineData.ignore = false;
            lineData.commentStrOffset = lineContentStartOffset;
            if (shouldRemoveComments && !BlockCommentCommand._haystackHasNeedleAtOffset(lineContent, lineData.commentStr, lineContentStartOffset)) {
                if (type === 0 /* Toggle */) {
                    // Every line so far has been a line comment, but this one is not
                    shouldRemoveComments = false;
                }
                else if (type === 1 /* ForceAdd */) ;
                else {
                    lineData.ignore = true;
                }
            }
            if (shouldRemoveComments) {
                commentStrEndOffset = lineContentStartOffset + lineData.commentStrLength;
                if (commentStrEndOffset < lineContent.length && lineContent.charCodeAt(commentStrEndOffset) === 32 /* Space */) {
                    lineData.commentStrLength += 1;
                }
            }
        }
        if (type === 0 /* Toggle */ && onlyWhitespaceLines) {
            // For only whitespace lines, we insert comments
            shouldRemoveComments = false;
            // Also, no longer ignore them
            for (i = 0, lineCount = lines.length; i < lineCount; i++) {
                lines[i].ignore = false;
            }
        }
        return {
            supported: true,
            shouldRemoveComments: shouldRemoveComments,
            lines: lines
        };
    };
    /**
     * Analyze all lines and decide exactly what to do => not supported | insert line comments | remove line comments
     */
    LineCommentCommand._gatherPreflightData = function (type, model, startLineNumber, endLineNumber) {
        var lines = LineCommentCommand._gatherPreflightCommentStrings(model, startLineNumber, endLineNumber);
        if (lines === null) {
            return {
                supported: false,
                shouldRemoveComments: false,
                lines: null
            };
        }
        return LineCommentCommand._analyzeLines(type, model, lines, startLineNumber);
    };
    /**
     * Given a successful analysis, execute either insert line comments, either remove line comments
     */
    LineCommentCommand.prototype._executeLineComments = function (model, builder, data, s) {
        var ops;
        if (data.shouldRemoveComments) {
            ops = LineCommentCommand._createRemoveLineCommentsOperations(data.lines, s.startLineNumber);
        }
        else {
            LineCommentCommand._normalizeInsertionPoint(model, data.lines, s.startLineNumber, this._tabSize);
            ops = LineCommentCommand._createAddLineCommentsOperations(data.lines, s.startLineNumber);
        }
        var cursorPosition = new Position(s.positionLineNumber, s.positionColumn);
        for (var i = 0, len = ops.length; i < len; i++) {
            builder.addEditOperation(ops[i].range, ops[i].text);
            if (ops[i].range.isEmpty() && ops[i].range.getStartPosition().equals(cursorPosition)) {
                var lineContent = model.getLineContent(cursorPosition.lineNumber);
                if (lineContent.length + 1 === cursorPosition.column) {
                    this._deltaColumn = ops[i].text.length;
                }
            }
        }
        this._selectionId = builder.trackSelection(s);
    };
    LineCommentCommand.prototype._attemptRemoveBlockComment = function (model, s, startToken, endToken) {
        var startLineNumber = s.startLineNumber;
        var endLineNumber = s.endLineNumber;
        var startTokenAllowedBeforeColumn = endToken.length + Math.max(model.getLineFirstNonWhitespaceColumn(s.startLineNumber), s.startColumn);
        var startTokenIndex = model.getLineContent(startLineNumber).lastIndexOf(startToken, startTokenAllowedBeforeColumn - 1);
        var endTokenIndex = model.getLineContent(endLineNumber).indexOf(endToken, s.endColumn - 1 - startToken.length);
        if (startTokenIndex !== -1 && endTokenIndex === -1) {
            endTokenIndex = model.getLineContent(startLineNumber).indexOf(endToken, startTokenIndex + startToken.length);
            endLineNumber = startLineNumber;
        }
        if (startTokenIndex === -1 && endTokenIndex !== -1) {
            startTokenIndex = model.getLineContent(endLineNumber).lastIndexOf(startToken, endTokenIndex);
            startLineNumber = endLineNumber;
        }
        if (s.isEmpty() && (startTokenIndex === -1 || endTokenIndex === -1)) {
            startTokenIndex = model.getLineContent(startLineNumber).indexOf(startToken);
            if (startTokenIndex !== -1) {
                endTokenIndex = model.getLineContent(startLineNumber).indexOf(endToken, startTokenIndex + startToken.length);
            }
        }
        // We have to adjust to possible inner white space.
        // For Space after startToken, add Space to startToken - range math will work out.
        if (startTokenIndex !== -1 && model.getLineContent(startLineNumber).charCodeAt(startTokenIndex + startToken.length) === 32 /* Space */) {
            startToken += ' ';
        }
        // For Space before endToken, add Space before endToken and shift index one left.
        if (endTokenIndex !== -1 && model.getLineContent(endLineNumber).charCodeAt(endTokenIndex - 1) === 32 /* Space */) {
            endToken = ' ' + endToken;
            endTokenIndex -= 1;
        }
        if (startTokenIndex !== -1 && endTokenIndex !== -1) {
            return BlockCommentCommand._createRemoveBlockCommentOperations(new Range(startLineNumber, startTokenIndex + startToken.length + 1, endLineNumber, endTokenIndex + 1), startToken, endToken);
        }
        return null;
    };
    /**
     * Given an unsuccessful analysis, delegate to the block comment command
     */
    LineCommentCommand.prototype._executeBlockComment = function (model, builder, s) {
        model.tokenizeIfCheap(s.startLineNumber);
        var languageId = model.getLanguageIdAtPosition(s.startLineNumber, 1);
        var config = LanguageConfigurationRegistry.getComments(languageId);
        if (!config || !config.blockCommentStartToken || !config.blockCommentEndToken) {
            // Mode does not support block comments
            return;
        }
        var startToken = config.blockCommentStartToken;
        var endToken = config.blockCommentEndToken;
        var ops = this._attemptRemoveBlockComment(model, s, startToken, endToken);
        if (!ops) {
            if (s.isEmpty()) {
                var lineContent = model.getLineContent(s.startLineNumber);
                var firstNonWhitespaceIndex$$1 = firstNonWhitespaceIndex(lineContent);
                if (firstNonWhitespaceIndex$$1 === -1) {
                    // Line is empty or contains only whitespace
                    firstNonWhitespaceIndex$$1 = lineContent.length;
                }
                ops = BlockCommentCommand._createAddBlockCommentOperations(new Range(s.startLineNumber, firstNonWhitespaceIndex$$1 + 1, s.startLineNumber, lineContent.length + 1), startToken, endToken);
            }
            else {
                ops = BlockCommentCommand._createAddBlockCommentOperations(new Range(s.startLineNumber, model.getLineFirstNonWhitespaceColumn(s.startLineNumber), s.endLineNumber, model.getLineMaxColumn(s.endLineNumber)), startToken, endToken);
            }
            if (ops.length === 1) {
                // Leave cursor after token and Space
                this._deltaColumn = startToken.length + 1;
            }
        }
        this._selectionId = builder.trackSelection(s);
        for (var i = 0; i < ops.length; i++) {
            builder.addEditOperation(ops[i].range, ops[i].text);
        }
    };
    LineCommentCommand.prototype.getEditOperations = function (model, builder) {
        var s = this._selection;
        this._moveEndPositionDown = false;
        if (s.startLineNumber < s.endLineNumber && s.endColumn === 1) {
            this._moveEndPositionDown = true;
            s = s.setEndPosition(s.endLineNumber - 1, model.getLineMaxColumn(s.endLineNumber - 1));
        }
        var data = LineCommentCommand._gatherPreflightData(this._type, model, s.startLineNumber, s.endLineNumber);
        if (data.supported) {
            return this._executeLineComments(model, builder, data, s);
        }
        return this._executeBlockComment(model, builder, s);
    };
    LineCommentCommand.prototype.computeCursorState = function (model, helper) {
        var result = helper.getTrackedSelection(this._selectionId);
        if (this._moveEndPositionDown) {
            result = result.setEndPosition(result.endLineNumber + 1, 1);
        }
        return new Selection(result.selectionStartLineNumber, result.selectionStartColumn + this._deltaColumn, result.positionLineNumber, result.positionColumn + this._deltaColumn);
    };
    /**
     * Generate edit operations in the remove line comment case
     */
    LineCommentCommand._createRemoveLineCommentsOperations = function (lines, startLineNumber) {
        var i, len, lineData, res = [];
        for (i = 0, len = lines.length; i < len; i++) {
            lineData = lines[i];
            if (lineData.ignore) {
                continue;
            }
            res.push(EditOperation.delete(new Range(startLineNumber + i, lineData.commentStrOffset + 1, startLineNumber + i, lineData.commentStrOffset + lineData.commentStrLength + 1)));
        }
        return res;
    };
    /**
     * Generate edit operations in the add line comment case
     */
    LineCommentCommand._createAddLineCommentsOperations = function (lines, startLineNumber) {
        var i, len, lineData, res = [];
        for (i = 0, len = lines.length; i < len; i++) {
            lineData = lines[i];
            if (lineData.ignore) {
                continue;
            }
            res.push(EditOperation.insert(new Position(startLineNumber + i, lineData.commentStrOffset + 1), lineData.commentStr + ' '));
        }
        return res;
    };
    // TODO@Alex -> duplicated in characterHardWrappingLineMapper
    LineCommentCommand.nextVisibleColumn = function (currentVisibleColumn, tabSize, isTab, columnSize) {
        if (isTab) {
            return currentVisibleColumn + (tabSize - (currentVisibleColumn % tabSize));
        }
        return currentVisibleColumn + columnSize;
    };
    /**
     * Adjust insertion points to have them vertically aligned in the add line comment case
     */
    LineCommentCommand._normalizeInsertionPoint = function (model, lines, startLineNumber, tabSize) {
        var minVisibleColumn = Number.MAX_VALUE, i, len, lineContent, j, lenJ, currentVisibleColumn;
        for (i = 0, len = lines.length; i < len; i++) {
            if (lines[i].ignore) {
                continue;
            }
            lineContent = model.getLineContent(startLineNumber + i);
            currentVisibleColumn = 0;
            for (j = 0, lenJ = lines[i].commentStrOffset; currentVisibleColumn < minVisibleColumn && j < lenJ; j++) {
                currentVisibleColumn = LineCommentCommand.nextVisibleColumn(currentVisibleColumn, tabSize, lineContent.charCodeAt(j) === 9 /* Tab */, 1);
            }
            if (currentVisibleColumn < minVisibleColumn) {
                minVisibleColumn = currentVisibleColumn;
            }
        }
        minVisibleColumn = Math.floor(minVisibleColumn / tabSize) * tabSize;
        for (i = 0, len = lines.length; i < len; i++) {
            if (lines[i].ignore) {
                continue;
            }
            lineContent = model.getLineContent(startLineNumber + i);
            currentVisibleColumn = 0;
            for (j = 0, lenJ = lines[i].commentStrOffset; currentVisibleColumn < minVisibleColumn && j < lenJ; j++) {
                currentVisibleColumn = LineCommentCommand.nextVisibleColumn(currentVisibleColumn, tabSize, lineContent.charCodeAt(j) === 9 /* Tab */, 1);
            }
            if (currentVisibleColumn > minVisibleColumn) {
                lines[i].commentStrOffset = j - 1;
            }
            else {
                lines[i].commentStrOffset = j;
            }
        }
    };
    return LineCommentCommand;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$4 = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var CommentLineAction = /** @class */ (function (_super) {
    __extends$4(CommentLineAction, _super);
    function CommentLineAction(type, opts) {
        var _this = _super.call(this, opts) || this;
        _this._type = type;
        return _this;
    }
    CommentLineAction.prototype.run = function (accessor, editor) {
        var model = editor.getModel();
        if (!model) {
            return;
        }
        var commands = [];
        var selections = editor.getSelections();
        var opts = model.getOptions();
        for (var i = 0; i < selections.length; i++) {
            commands.push(new LineCommentCommand(selections[i], opts.tabSize, this._type));
        }
        editor.pushUndoStop();
        editor.executeCommands(this.id, commands);
        editor.pushUndoStop();
    };
    return CommentLineAction;
}(EditorAction));
var ToggleCommentLineAction = /** @class */ (function (_super) {
    __extends$4(ToggleCommentLineAction, _super);
    function ToggleCommentLineAction() {
        return _super.call(this, 0 /* Toggle */, {
            id: 'editor.action.commentLine',
            label: localize('comment.line', "Toggle Line Comment"),
            alias: 'Toggle Line Comment',
            precondition: EditorContextKeys.writable,
            kbOpts: {
                kbExpr: EditorContextKeys.editorTextFocus,
                primary: 2048 /* CtrlCmd */ | 85 /* US_SLASH */
            }
        }) || this;
    }
    return ToggleCommentLineAction;
}(CommentLineAction));
var AddLineCommentAction = /** @class */ (function (_super) {
    __extends$4(AddLineCommentAction, _super);
    function AddLineCommentAction() {
        return _super.call(this, 1 /* ForceAdd */, {
            id: 'editor.action.addCommentLine',
            label: localize('comment.line.add', "Add Line Comment"),
            alias: 'Add Line Comment',
            precondition: EditorContextKeys.writable,
            kbOpts: {
                kbExpr: EditorContextKeys.editorTextFocus,
                primary: KeyChord(2048 /* CtrlCmd */ | 41 /* KEY_K */, 2048 /* CtrlCmd */ | 33 /* KEY_C */)
            }
        }) || this;
    }
    return AddLineCommentAction;
}(CommentLineAction));
var RemoveLineCommentAction = /** @class */ (function (_super) {
    __extends$4(RemoveLineCommentAction, _super);
    function RemoveLineCommentAction() {
        return _super.call(this, 2 /* ForceRemove */, {
            id: 'editor.action.removeCommentLine',
            label: localize('comment.line.remove', "Remove Line Comment"),
            alias: 'Remove Line Comment',
            precondition: EditorContextKeys.writable,
            kbOpts: {
                kbExpr: EditorContextKeys.editorTextFocus,
                primary: KeyChord(2048 /* CtrlCmd */ | 41 /* KEY_K */, 2048 /* CtrlCmd */ | 51 /* KEY_U */)
            }
        }) || this;
    }
    return RemoveLineCommentAction;
}(CommentLineAction));
var BlockCommentAction = /** @class */ (function (_super) {
    __extends$4(BlockCommentAction, _super);
    function BlockCommentAction() {
        return _super.call(this, {
            id: 'editor.action.blockComment',
            label: localize('comment.block', "Toggle Block Comment"),
            alias: 'Toggle Block Comment',
            precondition: EditorContextKeys.writable,
            kbOpts: {
                kbExpr: EditorContextKeys.editorTextFocus,
                primary: 1024 /* Shift */ | 512 /* Alt */ | 31 /* KEY_A */,
                linux: { primary: 2048 /* CtrlCmd */ | 1024 /* Shift */ | 31 /* KEY_A */ }
            }
        }) || this;
    }
    BlockCommentAction.prototype.run = function (accessor, editor) {
        var commands = [];
        var selections = editor.getSelections();
        for (var i = 0; i < selections.length; i++) {
            commands.push(new BlockCommentCommand(selections[i]));
        }
        editor.pushUndoStop();
        editor.executeCommands(this.id, commands);
        editor.pushUndoStop();
    };
    return BlockCommentAction;
}(EditorAction));
registerEditorAction(ToggleCommentLineAction);
registerEditorAction(AddLineCommentAction);
registerEditorAction(RemoveLineCommentAction);
registerEditorAction(BlockCommentAction);

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$5 = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate$2 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$2 = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var ContextMenuController = /** @class */ (function () {
    function ContextMenuController(editor, _contextMenuService, _contextViewService, _contextKeyService, _keybindingService, _menuService) {
        var _this = this;
        this._contextMenuService = _contextMenuService;
        this._contextViewService = _contextViewService;
        this._contextKeyService = _contextKeyService;
        this._keybindingService = _keybindingService;
        this._menuService = _menuService;
        this._toDispose = [];
        this._contextMenuIsBeingShownCount = 0;
        this._editor = editor;
        this._toDispose.push(this._editor.onContextMenu(function (e) { return _this._onContextMenu(e); }));
        this._toDispose.push(this._editor.onDidScrollChange(function (e) {
            if (_this._contextMenuIsBeingShownCount > 0) {
                _this._contextViewService.hideContextView();
            }
        }));
        this._toDispose.push(this._editor.onKeyDown(function (e) {
            if (e.keyCode === 58 /* ContextMenu */) {
                // Chrome is funny like that
                e.preventDefault();
                e.stopPropagation();
                _this.showContextMenu();
            }
        }));
    }
    ContextMenuController.get = function (editor) {
        return editor.getContribution(ContextMenuController.ID);
    };
    ContextMenuController.prototype._onContextMenu = function (e) {
        if (!this._editor.getConfiguration().contribInfo.contextmenu) {
            this._editor.focus();
            // Ensure the cursor is at the position of the mouse click
            if (e.target.position && !this._editor.getSelection().containsPosition(e.target.position)) {
                this._editor.setPosition(e.target.position);
            }
            return; // Context menu is turned off through configuration
        }
        if (e.target.type === MouseTargetType.OVERLAY_WIDGET) {
            return; // allow native menu on widgets to support right click on input field for example in find
        }
        e.event.preventDefault();
        if (e.target.type !== MouseTargetType.CONTENT_TEXT && e.target.type !== MouseTargetType.CONTENT_EMPTY && e.target.type !== MouseTargetType.TEXTAREA) {
            return; // only support mouse click into text or native context menu key for now
        }
        // Ensure the editor gets focus if it hasn't, so the right events are being sent to other contributions
        this._editor.focus();
        // Ensure the cursor is at the position of the mouse click
        if (e.target.position && !this._editor.getSelection().containsPosition(e.target.position)) {
            this._editor.setPosition(e.target.position);
        }
        // Unless the user triggerd the context menu through Shift+F10, use the mouse position as menu position
        var forcedPosition;
        if (e.target.type !== MouseTargetType.TEXTAREA) {
            forcedPosition = { x: e.event.posx, y: e.event.posy + 1 };
        }
        // Show the context menu
        this.showContextMenu(forcedPosition);
    };
    ContextMenuController.prototype.showContextMenu = function (forcedPosition) {
        if (!this._editor.getConfiguration().contribInfo.contextmenu) {
            return; // Context menu is turned off through configuration
        }
        if (!this._contextMenuService) {
            this._editor.focus();
            return; // We need the context menu service to function
        }
        // Find actions available for menu
        var menuActions = this._getMenuActions();
        // Show menu if we have actions to show
        if (menuActions.length > 0) {
            this._doShowContextMenu(menuActions, forcedPosition);
        }
    };
    ContextMenuController.prototype._getMenuActions = function () {
        var result = [];
        var contextMenu = this._menuService.createMenu(MenuId.EditorContext, this._contextKeyService);
        var groups = contextMenu.getActions({ arg: this._editor.getModel().uri });
        contextMenu.dispose();
        for (var _i = 0, groups_1 = groups; _i < groups_1.length; _i++) {
            var group = groups_1[_i];
            var actions = group[1];
            result.push.apply(result, actions);
            result.push(new Separator());
        }
        result.pop(); // remove last separator
        return result;
    };
    ContextMenuController.prototype._doShowContextMenu = function (actions, forcedPosition) {
        var _this = this;
        if (forcedPosition === void 0) { forcedPosition = null; }
        // Disable hover
        var oldHoverSetting = this._editor.getConfiguration().contribInfo.hover;
        this._editor.updateOptions({
            hover: false
        });
        var menuPosition = forcedPosition;
        if (!menuPosition) {
            // Ensure selection is visible
            this._editor.revealPosition(this._editor.getPosition(), 1 /* Immediate */);
            this._editor.render();
            var cursorCoords = this._editor.getScrolledVisiblePosition(this._editor.getPosition());
            // Translate to absolute editor position
            var editorCoords = getDomNodePagePosition(this._editor.getDomNode());
            var posx = editorCoords.left + cursorCoords.left;
            var posy = editorCoords.top + cursorCoords.top + cursorCoords.height;
            menuPosition = { x: posx, y: posy };
        }
        // Show menu
        this._contextMenuIsBeingShownCount++;
        this._contextMenuService.showContextMenu({
            getAnchor: function () { return menuPosition; },
            getActions: function () {
                return TPromise.as(actions);
            },
            getActionItem: function (action) {
                var keybinding = _this._keybindingFor(action);
                if (keybinding) {
                    return new ActionItem(action, action, { label: true, keybinding: keybinding.getLabel(), isMenu: true });
                }
                var customActionItem = action;
                if (typeof customActionItem.getActionItem === 'function') {
                    return customActionItem.getActionItem();
                }
                return new ActionItem(action, action, { icon: true, label: true, isMenu: true });
            },
            getKeyBinding: function (action) {
                return _this._keybindingFor(action);
            },
            onHide: function (wasCancelled) {
                _this._contextMenuIsBeingShownCount--;
                _this._editor.focus();
                _this._editor.updateOptions({
                    hover: oldHoverSetting
                });
            }
        });
    };
    ContextMenuController.prototype._keybindingFor = function (action) {
        return this._keybindingService.lookupKeybinding(action.id);
    };
    ContextMenuController.prototype.getId = function () {
        return ContextMenuController.ID;
    };
    ContextMenuController.prototype.dispose = function () {
        if (this._contextMenuIsBeingShownCount > 0) {
            this._contextViewService.hideContextView();
        }
        this._toDispose = dispose(this._toDispose);
    };
    ContextMenuController.ID = 'editor.contrib.contextmenu';
    ContextMenuController = __decorate$2([
        __param$2(1, IContextMenuService),
        __param$2(2, IContextViewService),
        __param$2(3, IContextKeyService),
        __param$2(4, IKeybindingService),
        __param$2(5, IMenuService)
    ], ContextMenuController);
    return ContextMenuController;
}());
var ShowContextMenu = /** @class */ (function (_super) {
    __extends$5(ShowContextMenu, _super);
    function ShowContextMenu() {
        return _super.call(this, {
            id: 'editor.action.showContextMenu',
            label: localize('action.showContextMenu.label', "Show Editor Context Menu"),
            alias: 'Show Editor Context Menu',
            precondition: null,
            kbOpts: {
                kbExpr: EditorContextKeys.textInputFocus,
                primary: 1024 /* Shift */ | 68 /* F10 */
            }
        }) || this;
    }
    ShowContextMenu.prototype.run = function (accessor, editor) {
        var contribution = ContextMenuController.get(editor);
        contribution.showContextMenu();
    };
    return ShowContextMenu;
}(EditorAction));
registerEditorContribution(ContextMenuController);
registerEditorAction(ShowContextMenu);

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$6 = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var CursorState$1 = /** @class */ (function () {
    function CursorState$$1(selections) {
        this.selections = selections;
    }
    CursorState$$1.prototype.equals = function (other) {
        var thisLen = this.selections.length;
        var otherLen = other.selections.length;
        if (thisLen !== otherLen) {
            return false;
        }
        for (var i = 0; i < thisLen; i++) {
            if (!this.selections[i].equalsSelection(other.selections[i])) {
                return false;
            }
        }
        return true;
    };
    return CursorState$$1;
}());
var CursorUndoController = /** @class */ (function (_super) {
    __extends$6(CursorUndoController, _super);
    function CursorUndoController(editor) {
        var _this = _super.call(this) || this;
        _this._editor = editor;
        _this._isCursorUndo = false;
        _this._undoStack = [];
        _this._prevState = _this._readState();
        _this._register(editor.onDidChangeModel(function (e) {
            _this._undoStack = [];
            _this._prevState = null;
        }));
        _this._register(editor.onDidChangeModelContent(function (e) {
            _this._undoStack = [];
            _this._prevState = null;
        }));
        _this._register(editor.onDidChangeCursorSelection(function (e) {
            if (!_this._isCursorUndo && _this._prevState) {
                _this._undoStack.push(_this._prevState);
                if (_this._undoStack.length > 50) {
                    // keep the cursor undo stack bounded
                    _this._undoStack.shift();
                }
            }
            _this._prevState = _this._readState();
        }));
        return _this;
    }
    CursorUndoController.get = function (editor) {
        return editor.getContribution(CursorUndoController.ID);
    };
    CursorUndoController.prototype._readState = function () {
        if (!this._editor.getModel()) {
            // no model => no state
            return null;
        }
        return new CursorState$1(this._editor.getSelections());
    };
    CursorUndoController.prototype.getId = function () {
        return CursorUndoController.ID;
    };
    CursorUndoController.prototype.cursorUndo = function () {
        var currState = new CursorState$1(this._editor.getSelections());
        while (this._undoStack.length > 0) {
            var prevState = this._undoStack.pop();
            if (!prevState.equals(currState)) {
                this._isCursorUndo = true;
                this._editor.setSelections(prevState.selections);
                this._editor.revealRangeInCenterIfOutsideViewport(prevState.selections[0], 0 /* Smooth */);
                this._isCursorUndo = false;
                return;
            }
        }
    };
    CursorUndoController.ID = 'editor.contrib.cursorUndoController';
    return CursorUndoController;
}(Disposable));
var CursorUndo = /** @class */ (function (_super) {
    __extends$6(CursorUndo, _super);
    function CursorUndo() {
        return _super.call(this, {
            id: 'cursorUndo',
            precondition: null,
            kbOpts: {
                kbExpr: EditorContextKeys.textInputFocus,
                primary: 2048 /* CtrlCmd */ | 51 /* KEY_U */
            }
        }) || this;
    }
    CursorUndo.prototype.runEditorCommand = function (accessor, editor, args) {
        CursorUndoController.get(editor).cursorUndo();
    };
    return CursorUndo;
}(EditorCommand));
registerEditorContribution(CursorUndoController);
registerEditorCommand(new CursorUndo());

const css$3 = "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n.monaco-editor.vs .dnd-target {\n\tborder-right: 2px dotted black;\n\tcolor: white; /* opposite of black */\n}\n.monaco-editor.vs-dark .dnd-target {\n\tborder-right: 2px dotted #AEAFAD;\n\tcolor: #51504f; /* opposite of #AEAFAD */\n}\n.monaco-editor.hc-black .dnd-target {\n\tborder-right: 2px dotted #fff;\n\tcolor: #000; /* opposite of #fff */\n}\n\n.monaco-editor.mouse-default .view-lines,\n.monaco-editor.vs-dark.mac.mouse-default .view-lines,\n.monaco-editor.hc-black.mac.mouse-default .view-lines {\n\tcursor: default;\n}\n.monaco-editor.mouse-copy .view-lines,\n.monaco-editor.vs-dark.mac.mouse-copy .view-lines,\n.monaco-editor.hc-black.mac.mouse-copy .view-lines {\n\tcursor: copy;\n}";
  const element$3 = ((css, src) => {
if (typeof document !== 'object')
console.info(`Skipped loading "${src}"`);
try {
const id = src
  .replace(/\.css.*$/, '')
  .replace(/[\\:]/g, '/')
  .replace(/[^\w\/]+/g, '');
return (
  document.querySelector(`style[id="${id}"]`) ||
  document.head.appendChild(
    Object.assign(document.createElement('style'), {
      id,
      textContent: `${css}\n\n /* sourceURL=${src} */`,
    }),
  )
);
} catch (exception) {
console.warn(`Failed load "${src}"`, exception);
}
})(css$3, "…monaco-editor/esm/vs/editor/contrib/dnd/dnd.css");
  //@ sourceURL=/Users/daflair/Projects/packages/monaco-es/node_modules/monaco-editor/esm/vs/editor/contrib/dnd/dnd.css

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var DragAndDropCommand = /** @class */ (function () {
    function DragAndDropCommand(selection, targetPosition, copy) {
        this.selection = selection;
        this.targetPosition = targetPosition;
        this.copy = copy;
    }
    DragAndDropCommand.prototype.getEditOperations = function (model, builder) {
        var text = model.getValueInRange(this.selection);
        if (!this.copy) {
            builder.addEditOperation(this.selection, null);
        }
        builder.addEditOperation(new Range(this.targetPosition.lineNumber, this.targetPosition.column, this.targetPosition.lineNumber, this.targetPosition.column), text);
        if (this.selection.containsPosition(this.targetPosition) && !(this.copy && (this.selection.getEndPosition().equals(this.targetPosition) || this.selection.getStartPosition().equals(this.targetPosition)) // we allow users to paste content beside the selection
        )) {
            this.targetSelection = this.selection;
            return;
        }
        if (this.copy) {
            this.targetSelection = new Selection(this.targetPosition.lineNumber, this.targetPosition.column, this.selection.endLineNumber - this.selection.startLineNumber + this.targetPosition.lineNumber, this.selection.startLineNumber === this.selection.endLineNumber ?
                this.targetPosition.column + this.selection.endColumn - this.selection.startColumn :
                this.selection.endColumn);
            return;
        }
        if (this.targetPosition.lineNumber > this.selection.endLineNumber) {
            // Drag the selection downwards
            this.targetSelection = new Selection(this.targetPosition.lineNumber - this.selection.endLineNumber + this.selection.startLineNumber, this.targetPosition.column, this.targetPosition.lineNumber, this.selection.startLineNumber === this.selection.endLineNumber ?
                this.targetPosition.column + this.selection.endColumn - this.selection.startColumn :
                this.selection.endColumn);
            return;
        }
        if (this.targetPosition.lineNumber < this.selection.endLineNumber) {
            // Drag the selection upwards
            this.targetSelection = new Selection(this.targetPosition.lineNumber, this.targetPosition.column, this.targetPosition.lineNumber + this.selection.endLineNumber - this.selection.startLineNumber, this.selection.startLineNumber === this.selection.endLineNumber ?
                this.targetPosition.column + this.selection.endColumn - this.selection.startColumn :
                this.selection.endColumn);
            return;
        }
        // The target position is at the same line as the selection's end position.
        if (this.selection.endColumn <= this.targetPosition.column) {
            // The target position is after the selection's end position
            this.targetSelection = new Selection(this.targetPosition.lineNumber - this.selection.endLineNumber + this.selection.startLineNumber, this.selection.startLineNumber === this.selection.endLineNumber ?
                this.targetPosition.column - this.selection.endColumn + this.selection.startColumn :
                this.targetPosition.column - this.selection.endColumn + this.selection.startColumn, this.targetPosition.lineNumber, this.selection.startLineNumber === this.selection.endLineNumber ?
                this.targetPosition.column :
                this.selection.endColumn);
        }
        else {
            // The target position is before the selection's end postion. Since the selection doesn't contain the target position, the selection is one-line and target position is before this selection.
            this.targetSelection = new Selection(this.targetPosition.lineNumber - this.selection.endLineNumber + this.selection.startLineNumber, this.targetPosition.column, this.targetPosition.lineNumber, this.targetPosition.column + this.selection.endColumn - this.selection.startColumn);
        }
    };
    DragAndDropCommand.prototype.computeCursorState = function (model, helper) {
        return this.targetSelection;
    };
    return DragAndDropCommand;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var DragAndDropController = /** @class */ (function () {
    function DragAndDropController(editor) {
        var _this = this;
        this._editor = editor;
        this._toUnhook = [];
        this._toUnhook.push(this._editor.onMouseDown(function (e) { return _this._onEditorMouseDown(e); }));
        this._toUnhook.push(this._editor.onMouseUp(function (e) { return _this._onEditorMouseUp(e); }));
        this._toUnhook.push(this._editor.onMouseDrag(function (e) { return _this._onEditorMouseDrag(e); }));
        this._toUnhook.push(this._editor.onMouseDrop(function (e) { return _this._onEditorMouseDrop(e); }));
        this._toUnhook.push(this._editor.onKeyDown(function (e) { return _this.onEditorKeyDown(e); }));
        this._toUnhook.push(this._editor.onKeyUp(function (e) { return _this.onEditorKeyUp(e); }));
        this._dndDecorationIds = [];
        this._mouseDown = false;
        this._modiferPressed = false;
        this._dragSelection = null;
    }
    DragAndDropController.get = function (editor) {
        return editor.getContribution(DragAndDropController.ID);
    };
    DragAndDropController.prototype.onEditorKeyDown = function (e) {
        if (!this._editor.getConfiguration().dragAndDrop) {
            return;
        }
        if (e[DragAndDropController.TRIGGER_MODIFIER]) {
            this._modiferPressed = true;
        }
        if (this._mouseDown && e[DragAndDropController.TRIGGER_MODIFIER]) {
            this._editor.updateOptions({
                mouseStyle: 'copy'
            });
        }
    };
    DragAndDropController.prototype.onEditorKeyUp = function (e) {
        if (!this._editor.getConfiguration().dragAndDrop) {
            return;
        }
        if (e[DragAndDropController.TRIGGER_MODIFIER]) {
            this._modiferPressed = false;
        }
        if (this._mouseDown && e.keyCode === DragAndDropController.TRIGGER_KEY_VALUE) {
            this._editor.updateOptions({
                mouseStyle: 'default'
            });
        }
    };
    DragAndDropController.prototype._onEditorMouseDown = function (mouseEvent) {
        this._mouseDown = true;
    };
    DragAndDropController.prototype._onEditorMouseUp = function (mouseEvent) {
        this._mouseDown = false;
        // Whenever users release the mouse, the drag and drop operation should finish and the cursor should revert to text.
        this._editor.updateOptions({
            mouseStyle: 'text'
        });
    };
    DragAndDropController.prototype._onEditorMouseDrag = function (mouseEvent) {
        var target = mouseEvent.target;
        if (this._dragSelection === null) {
            var possibleSelections = this._editor.getSelections().filter(function (selection) { return selection.containsPosition(target.position); });
            if (possibleSelections.length === 1) {
                this._dragSelection = possibleSelections[0];
            }
            else {
                return;
            }
        }
        if (mouseEvent.event[DragAndDropController.TRIGGER_MODIFIER]) {
            this._editor.updateOptions({
                mouseStyle: 'copy'
            });
        }
        else {
            this._editor.updateOptions({
                mouseStyle: 'default'
            });
        }
        if (this._dragSelection.containsPosition(target.position)) {
            this._removeDecoration();
        }
        else {
            this.showAt(target.position);
        }
    };
    DragAndDropController.prototype._onEditorMouseDrop = function (mouseEvent) {
        if (mouseEvent.target && (this._hitContent(mouseEvent.target) || this._hitMargin(mouseEvent.target)) && mouseEvent.target.position) {
            var newCursorPosition_1 = new Position(mouseEvent.target.position.lineNumber, mouseEvent.target.position.column);
            if (this._dragSelection === null) {
                if (mouseEvent.event.shiftKey) {
                    var primarySelection = this._editor.getSelection();
                    var startLineNumber = primarySelection.startLineNumber, startColumn = primarySelection.startColumn;
                    this._editor.setSelections([new Selection(startLineNumber, startColumn, newCursorPosition_1.lineNumber, newCursorPosition_1.column)]);
                }
                else {
                    var newSelections = this._editor.getSelections().map(function (selection) {
                        if (selection.containsPosition(newCursorPosition_1)) {
                            return new Selection(newCursorPosition_1.lineNumber, newCursorPosition_1.column, newCursorPosition_1.lineNumber, newCursorPosition_1.column);
                        }
                        else {
                            return selection;
                        }
                    });
                    this._editor.setSelections(newSelections);
                }
            }
            else if (!this._dragSelection.containsPosition(newCursorPosition_1) ||
                ((mouseEvent.event[DragAndDropController.TRIGGER_MODIFIER] ||
                    this._modiferPressed) && (this._dragSelection.getEndPosition().equals(newCursorPosition_1) || this._dragSelection.getStartPosition().equals(newCursorPosition_1)) // we allow users to paste content beside the selection
                )) {
                this._editor.pushUndoStop();
                this._editor.executeCommand(DragAndDropController.ID, new DragAndDropCommand(this._dragSelection, newCursorPosition_1, mouseEvent.event[DragAndDropController.TRIGGER_MODIFIER] || this._modiferPressed));
                this._editor.pushUndoStop();
            }
        }
        this._editor.updateOptions({
            mouseStyle: 'text'
        });
        this._removeDecoration();
        this._dragSelection = null;
        this._mouseDown = false;
    };
    DragAndDropController.prototype.showAt = function (position) {
        var newDecorations = [{
                range: new Range(position.lineNumber, position.column, position.lineNumber, position.column),
                options: DragAndDropController._DECORATION_OPTIONS
            }];
        this._dndDecorationIds = this._editor.deltaDecorations(this._dndDecorationIds, newDecorations);
        this._editor.revealPosition(position, 1 /* Immediate */);
    };
    DragAndDropController.prototype._removeDecoration = function () {
        this._dndDecorationIds = this._editor.deltaDecorations(this._dndDecorationIds, []);
    };
    DragAndDropController.prototype._hitContent = function (target) {
        return target.type === MouseTargetType.CONTENT_TEXT ||
            target.type === MouseTargetType.CONTENT_EMPTY;
    };
    DragAndDropController.prototype._hitMargin = function (target) {
        return target.type === MouseTargetType.GUTTER_GLYPH_MARGIN ||
            target.type === MouseTargetType.GUTTER_LINE_NUMBERS ||
            target.type === MouseTargetType.GUTTER_LINE_DECORATIONS;
    };
    DragAndDropController.prototype.getId = function () {
        return DragAndDropController.ID;
    };
    DragAndDropController.prototype.dispose = function () {
        this._removeDecoration();
        this._dragSelection = null;
        this._mouseDown = false;
        this._modiferPressed = false;
        this._toUnhook = dispose(this._toUnhook);
    };
    DragAndDropController.ID = 'editor.contrib.dragAndDrop';
    DragAndDropController.TRIGGER_MODIFIER = isMacintosh ? 'altKey' : 'ctrlKey';
    DragAndDropController.TRIGGER_KEY_VALUE = isMacintosh ? 6 /* Alt */ : 5 /* Ctrl */;
    DragAndDropController._DECORATION_OPTIONS = ModelDecorationOptions.register({
        className: 'dnd-target'
    });
    return DragAndDropController;
}());
registerEditorContribution(DragAndDropController);

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var HistoryNavigator = /** @class */ (function () {
    function HistoryNavigator(history, limit) {
        if (history === void 0) { history = []; }
        if (limit === void 0) { limit = 10; }
        this._initialize(history);
        this._limit = limit;
        this._onChange();
    }
    HistoryNavigator.prototype.getHistory = function () {
        return this._elements;
    };
    HistoryNavigator.prototype.add = function (t) {
        this._history.delete(t);
        this._history.add(t);
        this._onChange();
    };
    HistoryNavigator.prototype.addIfNotPresent = function (t) {
        if (!this._history.has(t)) {
            this.add(t);
        }
    };
    HistoryNavigator.prototype.next = function () {
        if (this._navigator.next()) {
            return this._navigator.current();
        }
        this.last();
        return null;
    };
    HistoryNavigator.prototype.previous = function () {
        if (this._navigator.previous()) {
            return this._navigator.current();
        }
        this.first();
        return null;
    };
    HistoryNavigator.prototype.current = function () {
        return this._navigator.current();
    };
    HistoryNavigator.prototype.parent = function () {
        return null;
    };
    HistoryNavigator.prototype.first = function () {
        return this._navigator.first();
    };
    HistoryNavigator.prototype.last = function () {
        return this._navigator.last();
    };
    HistoryNavigator.prototype.clear = function () {
        this._initialize([]);
        this._onChange();
    };
    HistoryNavigator.prototype._onChange = function () {
        this._reduceToLimit();
        this._navigator = new ArrayNavigator(this._elements);
        this._navigator.last();
    };
    HistoryNavigator.prototype._reduceToLimit = function () {
        var data = this._elements;
        if (data.length > this._limit) {
            this._initialize(data.slice(data.length - this._limit));
        }
    };
    HistoryNavigator.prototype._initialize = function (history) {
        this._history = new Set();
        for (var _i = 0, history_1 = history; _i < history_1.length; _i++) {
            var entry = history_1[_i];
            this._history.add(entry);
        }
    };
    Object.defineProperty(HistoryNavigator.prototype, "_elements", {
        get: function () {
            var elements = [];
            this._history.forEach(function (e) { return elements.push(e); });
            return elements;
        },
        enumerable: true,
        configurable: true
    });
    return HistoryNavigator;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var ReplacePattern = /** @class */ (function () {
    function ReplacePattern(pieces) {
        if (!pieces || pieces.length === 0) {
            this._staticValue = '';
            this._pieces = null;
        }
        else if (pieces.length === 1 && pieces[0].staticValue !== null) {
            this._staticValue = pieces[0].staticValue;
            this._pieces = null;
        }
        else {
            this._staticValue = null;
            this._pieces = pieces;
        }
    }
    ReplacePattern.fromStaticValue = function (value) {
        return new ReplacePattern([ReplacePiece.staticValue(value)]);
    };
    Object.defineProperty(ReplacePattern.prototype, "hasReplacementPatterns", {
        get: function () {
            return this._staticValue === null;
        },
        enumerable: true,
        configurable: true
    });
    ReplacePattern.prototype.buildReplaceString = function (matches) {
        if (this._staticValue !== null) {
            return this._staticValue;
        }
        var result = '';
        for (var i = 0, len = this._pieces.length; i < len; i++) {
            var piece = this._pieces[i];
            if (piece.staticValue !== null) {
                // static value ReplacePiece
                result += piece.staticValue;
                continue;
            }
            // match index ReplacePiece
            result += ReplacePattern._substitute(piece.matchIndex, matches);
        }
        return result;
    };
    ReplacePattern._substitute = function (matchIndex, matches) {
        if (matchIndex === 0) {
            return matches[0];
        }
        var remainder = '';
        while (matchIndex > 0) {
            if (matchIndex < matches.length) {
                // A match can be undefined
                var match = (matches[matchIndex] || '');
                return match + remainder;
            }
            remainder = String(matchIndex % 10) + remainder;
            matchIndex = Math.floor(matchIndex / 10);
        }
        return '$' + remainder;
    };
    return ReplacePattern;
}());
/**
 * A replace piece can either be a static string or an index to a specific match.
 */
var ReplacePiece = /** @class */ (function () {
    function ReplacePiece(staticValue, matchIndex) {
        this.staticValue = staticValue;
        this.matchIndex = matchIndex;
    }
    ReplacePiece.staticValue = function (value) {
        return new ReplacePiece(value, -1);
    };
    ReplacePiece.matchIndex = function (index) {
        return new ReplacePiece(null, index);
    };
    return ReplacePiece;
}());
var ReplacePieceBuilder = /** @class */ (function () {
    function ReplacePieceBuilder(source) {
        this._source = source;
        this._lastCharIndex = 0;
        this._result = [];
        this._resultLen = 0;
        this._currentStaticPiece = '';
    }
    ReplacePieceBuilder.prototype.emitUnchanged = function (toCharIndex) {
        this._emitStatic(this._source.substring(this._lastCharIndex, toCharIndex));
        this._lastCharIndex = toCharIndex;
    };
    ReplacePieceBuilder.prototype.emitStatic = function (value, toCharIndex) {
        this._emitStatic(value);
        this._lastCharIndex = toCharIndex;
    };
    ReplacePieceBuilder.prototype._emitStatic = function (value) {
        if (value.length === 0) {
            return;
        }
        this._currentStaticPiece += value;
    };
    ReplacePieceBuilder.prototype.emitMatchIndex = function (index, toCharIndex) {
        if (this._currentStaticPiece.length !== 0) {
            this._result[this._resultLen++] = ReplacePiece.staticValue(this._currentStaticPiece);
            this._currentStaticPiece = '';
        }
        this._result[this._resultLen++] = ReplacePiece.matchIndex(index);
        this._lastCharIndex = toCharIndex;
    };
    ReplacePieceBuilder.prototype.finalize = function () {
        this.emitUnchanged(this._source.length);
        if (this._currentStaticPiece.length !== 0) {
            this._result[this._resultLen++] = ReplacePiece.staticValue(this._currentStaticPiece);
            this._currentStaticPiece = '';
        }
        return new ReplacePattern(this._result);
    };
    return ReplacePieceBuilder;
}());
/**
 * \n			=> inserts a LF
 * \t			=> inserts a TAB
 * \\			=> inserts a "\".
 * $$			=> inserts a "$".
 * $& and $0	=> inserts the matched substring.
 * $n			=> Where n is a non-negative integer lesser than 100, inserts the nth parenthesized submatch string
 * everything else stays untouched
 *
 * Also see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#Specifying_a_string_as_a_parameter
 */
function parseReplaceString(replaceString) {
    if (!replaceString || replaceString.length === 0) {
        return new ReplacePattern(null);
    }
    var result = new ReplacePieceBuilder(replaceString);
    for (var i = 0, len = replaceString.length; i < len; i++) {
        var chCode = replaceString.charCodeAt(i);
        if (chCode === 92 /* Backslash */) {
            // move to next char
            i++;
            if (i >= len) {
                // string ends with a \
                break;
            }
            var nextChCode = replaceString.charCodeAt(i);
            // let replaceWithCharacter: string = null;
            switch (nextChCode) {
                case 92 /* Backslash */:
                    // \\ => inserts a "\"
                    result.emitUnchanged(i - 1);
                    result.emitStatic('\\', i + 1);
                    break;
                case 110 /* n */:
                    // \n => inserts a LF
                    result.emitUnchanged(i - 1);
                    result.emitStatic('\n', i + 1);
                    break;
                case 116 /* t */:
                    // \t => inserts a TAB
                    result.emitUnchanged(i - 1);
                    result.emitStatic('\t', i + 1);
                    break;
            }
            continue;
        }
        if (chCode === 36 /* DollarSign */) {
            // move to next char
            i++;
            if (i >= len) {
                // string ends with a $
                break;
            }
            var nextChCode = replaceString.charCodeAt(i);
            if (nextChCode === 36 /* DollarSign */) {
                // $$ => inserts a "$"
                result.emitUnchanged(i - 1);
                result.emitStatic('$', i + 1);
                continue;
            }
            if (nextChCode === 48 /* Digit0 */ || nextChCode === 38 /* Ampersand */) {
                // $& and $0 => inserts the matched substring.
                result.emitUnchanged(i - 1);
                result.emitMatchIndex(0, i + 1);
                continue;
            }
            if (49 /* Digit1 */ <= nextChCode && nextChCode <= 57 /* Digit9 */) {
                // $n
                var matchIndex = nextChCode - 48 /* Digit0 */;
                // peek next char to probe for $nn
                if (i + 1 < len) {
                    var nextNextChCode = replaceString.charCodeAt(i + 1);
                    if (48 /* Digit0 */ <= nextNextChCode && nextNextChCode <= 57 /* Digit9 */) {
                        // $nn
                        // move to next char
                        i++;
                        matchIndex = matchIndex * 10 + (nextNextChCode - 48 /* Digit0 */);
                        result.emitUnchanged(i - 2);
                        result.emitMatchIndex(matchIndex, i + 1);
                        continue;
                    }
                }
                result.emitUnchanged(i - 1);
                result.emitMatchIndex(matchIndex, i + 1);
                continue;
            }
        }
    }
    return result.finalize();
}

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var FindDecorations = /** @class */ (function () {
    function FindDecorations(editor) {
        this._editor = editor;
        this._decorations = [];
        this._overviewRulerApproximateDecorations = [];
        this._findScopeDecorationId = null;
        this._rangeHighlightDecorationId = null;
        this._highlightedDecorationId = null;
        this._startPosition = this._editor.getPosition();
    }
    FindDecorations.prototype.dispose = function () {
        this._editor.deltaDecorations(this._allDecorations(), []);
        this._editor = null;
        this._decorations = [];
        this._overviewRulerApproximateDecorations = [];
        this._findScopeDecorationId = null;
        this._rangeHighlightDecorationId = null;
        this._highlightedDecorationId = null;
        this._startPosition = null;
    };
    FindDecorations.prototype.reset = function () {
        this._decorations = [];
        this._overviewRulerApproximateDecorations = [];
        this._findScopeDecorationId = null;
        this._rangeHighlightDecorationId = null;
        this._highlightedDecorationId = null;
    };
    FindDecorations.prototype.getCount = function () {
        return this._decorations.length;
    };
    FindDecorations.prototype.getFindScope = function () {
        if (this._findScopeDecorationId) {
            return this._editor.getModel().getDecorationRange(this._findScopeDecorationId);
        }
        return null;
    };
    FindDecorations.prototype.getStartPosition = function () {
        return this._startPosition;
    };
    FindDecorations.prototype.setStartPosition = function (newStartPosition) {
        this._startPosition = newStartPosition;
        this.setCurrentFindMatch(null);
    };
    FindDecorations.prototype._getDecorationIndex = function (decorationId) {
        var index = this._decorations.indexOf(decorationId);
        if (index >= 0) {
            return index + 1;
        }
        return 1;
    };
    FindDecorations.prototype.getCurrentMatchesPosition = function (desiredRange) {
        var candidates = this._editor.getModel().getDecorationsInRange(desiredRange);
        for (var i = 0, len = candidates.length; i < len; i++) {
            var candidate = candidates[i];
            var candidateOpts = candidate.options;
            if (candidateOpts === FindDecorations._FIND_MATCH_DECORATION || candidateOpts === FindDecorations._CURRENT_FIND_MATCH_DECORATION) {
                return this._getDecorationIndex(candidate.id);
            }
        }
        return 1;
    };
    FindDecorations.prototype.setCurrentFindMatch = function (nextMatch) {
        var _this = this;
        var newCurrentDecorationId = null;
        var matchPosition = 0;
        if (nextMatch) {
            for (var i = 0, len = this._decorations.length; i < len; i++) {
                var range$$1 = this._editor.getModel().getDecorationRange(this._decorations[i]);
                if (nextMatch.equalsRange(range$$1)) {
                    newCurrentDecorationId = this._decorations[i];
                    matchPosition = (i + 1);
                    break;
                }
            }
        }
        if (this._highlightedDecorationId !== null || newCurrentDecorationId !== null) {
            this._editor.changeDecorations(function (changeAccessor) {
                if (_this._highlightedDecorationId !== null) {
                    changeAccessor.changeDecorationOptions(_this._highlightedDecorationId, FindDecorations._FIND_MATCH_DECORATION);
                    _this._highlightedDecorationId = null;
                }
                if (newCurrentDecorationId !== null) {
                    _this._highlightedDecorationId = newCurrentDecorationId;
                    changeAccessor.changeDecorationOptions(_this._highlightedDecorationId, FindDecorations._CURRENT_FIND_MATCH_DECORATION);
                }
                if (_this._rangeHighlightDecorationId !== null) {
                    changeAccessor.removeDecoration(_this._rangeHighlightDecorationId);
                    _this._rangeHighlightDecorationId = null;
                }
                if (newCurrentDecorationId !== null) {
                    var rng = _this._editor.getModel().getDecorationRange(newCurrentDecorationId);
                    if (rng.startLineNumber !== rng.endLineNumber && rng.endColumn === 1) {
                        var lineBeforeEnd = rng.endLineNumber - 1;
                        var lineBeforeEndMaxColumn = _this._editor.getModel().getLineMaxColumn(lineBeforeEnd);
                        rng = new Range(rng.startLineNumber, rng.startColumn, lineBeforeEnd, lineBeforeEndMaxColumn);
                    }
                    _this._rangeHighlightDecorationId = changeAccessor.addDecoration(rng, FindDecorations._RANGE_HIGHLIGHT_DECORATION);
                }
            });
        }
        return matchPosition;
    };
    FindDecorations.prototype.set = function (findMatches, findScope) {
        var _this = this;
        this._editor.changeDecorations(function (accessor) {
            var findMatchesOptions = FindDecorations._FIND_MATCH_DECORATION;
            var newOverviewRulerApproximateDecorations = [];
            if (findMatches.length > 1000) {
                // we go into a mode where the overview ruler gets "approximate" decorations
                // the reason is that the overview ruler paints all the decorations in the file and we don't want to cause freezes
                findMatchesOptions = FindDecorations._FIND_MATCH_NO_OVERVIEW_DECORATION;
                // approximate a distance in lines where matches should be merged
                var lineCount = _this._editor.getModel().getLineCount();
                var height = _this._editor.getLayoutInfo().height;
                var approxPixelsPerLine = height / lineCount;
                var mergeLinesDelta = Math.max(2, Math.ceil(3 / approxPixelsPerLine));
                // merge decorations as much as possible
                var prevStartLineNumber = findMatches[0].range.startLineNumber;
                var prevEndLineNumber = findMatches[0].range.endLineNumber;
                for (var i = 1, len = findMatches.length; i < len; i++) {
                    var range$$1 = findMatches[i].range;
                    if (prevEndLineNumber + mergeLinesDelta >= range$$1.startLineNumber) {
                        if (range$$1.endLineNumber > prevEndLineNumber) {
                            prevEndLineNumber = range$$1.endLineNumber;
                        }
                    }
                    else {
                        newOverviewRulerApproximateDecorations.push({
                            range: new Range(prevStartLineNumber, 1, prevEndLineNumber, 1),
                            options: FindDecorations._FIND_MATCH_ONLY_OVERVIEW_DECORATION
                        });
                        prevStartLineNumber = range$$1.startLineNumber;
                        prevEndLineNumber = range$$1.endLineNumber;
                    }
                }
                newOverviewRulerApproximateDecorations.push({
                    range: new Range(prevStartLineNumber, 1, prevEndLineNumber, 1),
                    options: FindDecorations._FIND_MATCH_ONLY_OVERVIEW_DECORATION
                });
            }
            // Find matches
            var newFindMatchesDecorations = new Array(findMatches.length);
            for (var i = 0, len = findMatches.length; i < len; i++) {
                newFindMatchesDecorations[i] = {
                    range: findMatches[i].range,
                    options: findMatchesOptions
                };
            }
            _this._decorations = accessor.deltaDecorations(_this._decorations, newFindMatchesDecorations);
            // Overview ruler approximate decorations
            _this._overviewRulerApproximateDecorations = accessor.deltaDecorations(_this._overviewRulerApproximateDecorations, newOverviewRulerApproximateDecorations);
            // Range highlight
            if (_this._rangeHighlightDecorationId) {
                accessor.removeDecoration(_this._rangeHighlightDecorationId);
                _this._rangeHighlightDecorationId = null;
            }
            // Find scope
            if (_this._findScopeDecorationId) {
                accessor.removeDecoration(_this._findScopeDecorationId);
                _this._findScopeDecorationId = null;
            }
            if (findScope) {
                _this._findScopeDecorationId = accessor.addDecoration(findScope, FindDecorations._FIND_SCOPE_DECORATION);
            }
        });
    };
    FindDecorations.prototype.matchBeforePosition = function (position) {
        if (this._decorations.length === 0) {
            return null;
        }
        for (var i = this._decorations.length - 1; i >= 0; i--) {
            var decorationId = this._decorations[i];
            var r = this._editor.getModel().getDecorationRange(decorationId);
            if (!r || r.endLineNumber > position.lineNumber) {
                continue;
            }
            if (r.endLineNumber < position.lineNumber) {
                return r;
            }
            if (r.endColumn > position.column) {
                continue;
            }
            return r;
        }
        return this._editor.getModel().getDecorationRange(this._decorations[this._decorations.length - 1]);
    };
    FindDecorations.prototype.matchAfterPosition = function (position) {
        if (this._decorations.length === 0) {
            return null;
        }
        for (var i = 0, len = this._decorations.length; i < len; i++) {
            var decorationId = this._decorations[i];
            var r = this._editor.getModel().getDecorationRange(decorationId);
            if (!r || r.startLineNumber < position.lineNumber) {
                continue;
            }
            if (r.startLineNumber > position.lineNumber) {
                return r;
            }
            if (r.startColumn < position.column) {
                continue;
            }
            return r;
        }
        return this._editor.getModel().getDecorationRange(this._decorations[0]);
    };
    FindDecorations.prototype._allDecorations = function () {
        var result = [];
        result = result.concat(this._decorations);
        result = result.concat(this._overviewRulerApproximateDecorations);
        if (this._findScopeDecorationId) {
            result.push(this._findScopeDecorationId);
        }
        if (this._rangeHighlightDecorationId) {
            result.push(this._rangeHighlightDecorationId);
        }
        return result;
    };
    FindDecorations._CURRENT_FIND_MATCH_DECORATION = ModelDecorationOptions.register({
        stickiness: TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges,
        zIndex: 13,
        className: 'currentFindMatch',
        showIfCollapsed: true,
        overviewRuler: {
            color: themeColorFromId(overviewRulerFindMatchForeground),
            darkColor: themeColorFromId(overviewRulerFindMatchForeground),
            position: OverviewRulerLane.Center
        }
    });
    FindDecorations._FIND_MATCH_DECORATION = ModelDecorationOptions.register({
        stickiness: TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges,
        className: 'findMatch',
        showIfCollapsed: true,
        overviewRuler: {
            color: themeColorFromId(overviewRulerFindMatchForeground),
            darkColor: themeColorFromId(overviewRulerFindMatchForeground),
            position: OverviewRulerLane.Center
        }
    });
    FindDecorations._FIND_MATCH_NO_OVERVIEW_DECORATION = ModelDecorationOptions.register({
        stickiness: TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges,
        className: 'findMatch',
        showIfCollapsed: true
    });
    FindDecorations._FIND_MATCH_ONLY_OVERVIEW_DECORATION = ModelDecorationOptions.register({
        stickiness: TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges,
        overviewRuler: {
            color: themeColorFromId(overviewRulerFindMatchForeground),
            darkColor: themeColorFromId(overviewRulerFindMatchForeground),
            position: OverviewRulerLane.Center
        }
    });
    FindDecorations._RANGE_HIGHLIGHT_DECORATION = ModelDecorationOptions.register({
        stickiness: TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges,
        className: 'rangeHighlight',
        isWholeLine: true
    });
    FindDecorations._FIND_SCOPE_DECORATION = ModelDecorationOptions.register({
        className: 'findScope',
        isWholeLine: true
    });
    return FindDecorations;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var ReplaceAllCommand = /** @class */ (function () {
    function ReplaceAllCommand(editorSelection, ranges, replaceStrings) {
        this._editorSelection = editorSelection;
        this._ranges = ranges;
        this._replaceStrings = replaceStrings;
    }
    ReplaceAllCommand.prototype.getEditOperations = function (model, builder) {
        if (this._ranges.length > 0) {
            // Collect all edit operations
            var ops = [];
            for (var i_1 = 0; i_1 < this._ranges.length; i_1++) {
                ops.push({
                    range: this._ranges[i_1],
                    text: this._replaceStrings[i_1]
                });
            }
            // Sort them in ascending order by range starts
            ops.sort(function (o1, o2) {
                return Range.compareRangesUsingStarts(o1.range, o2.range);
            });
            // Merge operations that touch each other
            var resultOps = [];
            var previousOp = ops[0];
            for (var i_2 = 1; i_2 < ops.length; i_2++) {
                if (previousOp.range.endLineNumber === ops[i_2].range.startLineNumber && previousOp.range.endColumn === ops[i_2].range.startColumn) {
                    // These operations are one after another and can be merged
                    previousOp.range = previousOp.range.plusRange(ops[i_2].range);
                    previousOp.text = previousOp.text + ops[i_2].text;
                }
                else {
                    resultOps.push(previousOp);
                    previousOp = ops[i_2];
                }
            }
            resultOps.push(previousOp);
            for (var i = 0; i < resultOps.length; i++) {
                builder.addEditOperation(resultOps[i].range, resultOps[i].text);
            }
        }
        this._trackedEditorSelectionId = builder.trackSelection(this._editorSelection);
    };
    ReplaceAllCommand.prototype.computeCursorState = function (model, helper) {
        return helper.getTrackedSelection(this._trackedEditorSelectionId);
    };
    return ReplaceAllCommand;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var CONTEXT_FIND_WIDGET_VISIBLE = new RawContextKey('findWidgetVisible', false);
var CONTEXT_FIND_WIDGET_NOT_VISIBLE = CONTEXT_FIND_WIDGET_VISIBLE.toNegated();
// Keep ContextKey use of 'Focussed' to not break when clauses
var CONTEXT_FIND_INPUT_FOCUSED = new RawContextKey('findInputFocussed', false);
var CONTEXT_REPLACE_INPUT_FOCUSED = new RawContextKey('replaceInputFocussed', false);
var ToggleCaseSensitiveKeybinding = {
    primary: 512 /* Alt */ | 33 /* KEY_C */,
    mac: { primary: 2048 /* CtrlCmd */ | 512 /* Alt */ | 33 /* KEY_C */ }
};
var ToggleWholeWordKeybinding = {
    primary: 512 /* Alt */ | 53 /* KEY_W */,
    mac: { primary: 2048 /* CtrlCmd */ | 512 /* Alt */ | 53 /* KEY_W */ }
};
var ToggleRegexKeybinding = {
    primary: 512 /* Alt */ | 48 /* KEY_R */,
    mac: { primary: 2048 /* CtrlCmd */ | 512 /* Alt */ | 48 /* KEY_R */ }
};
var ToggleSearchScopeKeybinding = {
    primary: 512 /* Alt */ | 42 /* KEY_L */,
    mac: { primary: 2048 /* CtrlCmd */ | 512 /* Alt */ | 42 /* KEY_L */ }
};
var ShowPreviousFindTermKeybinding = {
    primary: 512 /* Alt */ | 16 /* UpArrow */
};
var ShowNextFindTermKeybinding = {
    primary: 512 /* Alt */ | 18 /* DownArrow */
};
var FIND_IDS = {
    StartFindAction: 'actions.find',
    StartFindWithSelection: 'actions.findWithSelection',
    NextMatchFindAction: 'editor.action.nextMatchFindAction',
    PreviousMatchFindAction: 'editor.action.previousMatchFindAction',
    NextSelectionMatchFindAction: 'editor.action.nextSelectionMatchFindAction',
    PreviousSelectionMatchFindAction: 'editor.action.previousSelectionMatchFindAction',
    StartFindReplaceAction: 'editor.action.startFindReplaceAction',
    CloseFindWidgetCommand: 'closeFindWidget',
    ToggleCaseSensitiveCommand: 'toggleFindCaseSensitive',
    ToggleWholeWordCommand: 'toggleFindWholeWord',
    ToggleRegexCommand: 'toggleFindRegex',
    ToggleSearchScopeCommand: 'toggleFindInSelection',
    ReplaceOneAction: 'editor.action.replaceOne',
    ReplaceAllAction: 'editor.action.replaceAll',
    SelectAllMatchesAction: 'editor.action.selectAllMatches',
    ShowPreviousFindTermAction: 'find.history.showPrevious',
    ShowNextFindTermAction: 'find.history.showNext'
};
var MATCHES_LIMIT = 19999;
var RESEARCH_DELAY = 240;
var FindModelBoundToEditorModel = /** @class */ (function () {
    function FindModelBoundToEditorModel(editor, state) {
        var _this = this;
        this._editor = editor;
        this._state = state;
        this._toDispose = [];
        this._isDisposed = false;
        this._startSearchingTimer = new TimeoutTimer();
        this._decorations = new FindDecorations(editor);
        this._toDispose.push(this._decorations);
        this._updateDecorationsScheduler = new RunOnceScheduler(function () { return _this.research(false); }, 100);
        this._toDispose.push(this._updateDecorationsScheduler);
        this._toDispose.push(this._editor.onDidChangeCursorPosition(function (e) {
            if (e.reason === CursorChangeReason.Explicit
                || e.reason === CursorChangeReason.Undo
                || e.reason === CursorChangeReason.Redo) {
                _this._decorations.setStartPosition(_this._editor.getPosition());
            }
        }));
        this._ignoreModelContentChanged = false;
        this._toDispose.push(this._editor.onDidChangeModelContent(function (e) {
            if (_this._ignoreModelContentChanged) {
                return;
            }
            if (e.isFlush) {
                // a model.setValue() was called
                _this._decorations.reset();
            }
            _this._decorations.setStartPosition(_this._editor.getPosition());
            _this._updateDecorationsScheduler.schedule();
        }));
        this._toDispose.push(this._state.onFindReplaceStateChange(function (e) { return _this._onStateChanged(e); }));
        this.research(false, this._state.searchScope);
    }
    FindModelBoundToEditorModel.prototype.dispose = function () {
        this._isDisposed = true;
        dispose(this._startSearchingTimer);
        this._toDispose = dispose(this._toDispose);
    };
    FindModelBoundToEditorModel.prototype._onStateChanged = function (e) {
        var _this = this;
        if (this._isDisposed) {
            // The find model is disposed during a find state changed event
            return;
        }
        if (!this._editor.getModel()) {
            // The find model will be disposed momentarily
            return;
        }
        if (e.searchString || e.isReplaceRevealed || e.isRegex || e.wholeWord || e.matchCase || e.searchScope) {
            var model = this._editor.getModel();
            if (model.isTooLargeForSyncing()) {
                this._startSearchingTimer.cancel();
                this._startSearchingTimer.setIfNotSet(function () {
                    if (e.searchScope) {
                        _this.research(e.moveCursor, _this._state.searchScope);
                    }
                    else {
                        _this.research(e.moveCursor);
                    }
                }, RESEARCH_DELAY);
            }
            else {
                if (e.searchScope) {
                    this.research(e.moveCursor, this._state.searchScope);
                }
                else {
                    this.research(e.moveCursor);
                }
            }
        }
    };
    FindModelBoundToEditorModel._getSearchRange = function (model, findScope) {
        var searchRange = model.getFullModelRange();
        // If we have set now or before a find scope, use it for computing the search range
        if (findScope) {
            searchRange = searchRange.intersectRanges(findScope);
        }
        return searchRange;
    };
    FindModelBoundToEditorModel.prototype.research = function (moveCursor, newFindScope) {
        var findScope = null;
        if (typeof newFindScope !== 'undefined') {
            findScope = newFindScope;
        }
        else {
            findScope = this._decorations.getFindScope();
        }
        if (findScope !== null) {
            if (findScope.startLineNumber !== findScope.endLineNumber) {
                // multiline find scope => expand to line starts / ends
                findScope = new Range(findScope.startLineNumber, 1, findScope.endLineNumber, this._editor.getModel().getLineMaxColumn(findScope.endLineNumber));
            }
        }
        var findMatches = this._findMatches(findScope, false, MATCHES_LIMIT);
        this._decorations.set(findMatches, findScope);
        this._state.changeMatchInfo(this._decorations.getCurrentMatchesPosition(this._editor.getSelection()), this._decorations.getCount(), undefined);
        if (moveCursor) {
            this._moveToNextMatch(this._decorations.getStartPosition());
        }
    };
    FindModelBoundToEditorModel.prototype._hasMatches = function () {
        return (this._state.matchesCount > 0);
    };
    FindModelBoundToEditorModel.prototype._cannotFind = function () {
        if (!this._hasMatches()) {
            var findScope = this._decorations.getFindScope();
            if (findScope) {
                // Reveal the selection so user is reminded that 'selection find' is on.
                this._editor.revealRangeInCenterIfOutsideViewport(findScope, 0 /* Smooth */);
            }
            return true;
        }
        return false;
    };
    FindModelBoundToEditorModel.prototype._setCurrentFindMatch = function (match) {
        var matchesPosition = this._decorations.setCurrentFindMatch(match);
        this._state.changeMatchInfo(matchesPosition, this._decorations.getCount(), match);
        this._editor.setSelection(match);
        this._editor.revealRangeInCenterIfOutsideViewport(match, 0 /* Smooth */);
    };
    FindModelBoundToEditorModel.prototype._prevSearchPosition = function (before) {
        var isUsingLineStops = this._state.isRegex && (this._state.searchString.indexOf('^') >= 0
            || this._state.searchString.indexOf('$') >= 0);
        var lineNumber = before.lineNumber, column = before.column;
        var model = this._editor.getModel();
        if (isUsingLineStops || column === 1) {
            if (lineNumber === 1) {
                lineNumber = model.getLineCount();
            }
            else {
                lineNumber--;
            }
            column = model.getLineMaxColumn(lineNumber);
        }
        else {
            column--;
        }
        return new Position(lineNumber, column);
    };
    FindModelBoundToEditorModel.prototype._moveToPrevMatch = function (before, isRecursed) {
        if (isRecursed === void 0) { isRecursed = false; }
        if (this._decorations.getCount() < MATCHES_LIMIT) {
            var prevMatchRange = this._decorations.matchBeforePosition(before);
            if (prevMatchRange && prevMatchRange.isEmpty() && prevMatchRange.getStartPosition().equals(before)) {
                before = this._prevSearchPosition(before);
                prevMatchRange = this._decorations.matchBeforePosition(before);
            }
            if (prevMatchRange) {
                this._setCurrentFindMatch(prevMatchRange);
            }
            return;
        }
        if (this._cannotFind()) {
            return;
        }
        var findScope = this._decorations.getFindScope();
        var searchRange = FindModelBoundToEditorModel._getSearchRange(this._editor.getModel(), findScope);
        // ...(----)...|...
        if (searchRange.getEndPosition().isBefore(before)) {
            before = searchRange.getEndPosition();
        }
        // ...|...(----)...
        if (before.isBefore(searchRange.getStartPosition())) {
            before = searchRange.getEndPosition();
        }
        var lineNumber = before.lineNumber, column = before.column;
        var model = this._editor.getModel();
        var position = new Position(lineNumber, column);
        var prevMatch = model.findPreviousMatch(this._state.searchString, position, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getConfiguration().wordSeparators : null, false);
        if (prevMatch && prevMatch.range.isEmpty() && prevMatch.range.getStartPosition().equals(position)) {
            // Looks like we're stuck at this position, unacceptable!
            position = this._prevSearchPosition(position);
            prevMatch = model.findPreviousMatch(this._state.searchString, position, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getConfiguration().wordSeparators : null, false);
        }
        if (!prevMatch) {
            // there is precisely one match and selection is on top of it
            return null;
        }
        if (!isRecursed && !searchRange.containsRange(prevMatch.range)) {
            return this._moveToPrevMatch(prevMatch.range.getStartPosition(), true);
        }
        this._setCurrentFindMatch(prevMatch.range);
    };
    FindModelBoundToEditorModel.prototype.moveToPrevMatch = function () {
        this._moveToPrevMatch(this._editor.getSelection().getStartPosition());
    };
    FindModelBoundToEditorModel.prototype._nextSearchPosition = function (after) {
        var isUsingLineStops = this._state.isRegex && (this._state.searchString.indexOf('^') >= 0
            || this._state.searchString.indexOf('$') >= 0);
        var lineNumber = after.lineNumber, column = after.column;
        var model = this._editor.getModel();
        if (isUsingLineStops || column === model.getLineMaxColumn(lineNumber)) {
            if (lineNumber === model.getLineCount()) {
                lineNumber = 1;
            }
            else {
                lineNumber++;
            }
            column = 1;
        }
        else {
            column++;
        }
        return new Position(lineNumber, column);
    };
    FindModelBoundToEditorModel.prototype._moveToNextMatch = function (after) {
        if (this._decorations.getCount() < MATCHES_LIMIT) {
            var nextMatchRange = this._decorations.matchAfterPosition(after);
            if (nextMatchRange && nextMatchRange.isEmpty() && nextMatchRange.getStartPosition().equals(after)) {
                // Looks like we're stuck at this position, unacceptable!
                after = this._nextSearchPosition(after);
                nextMatchRange = this._decorations.matchAfterPosition(after);
            }
            if (nextMatchRange) {
                this._setCurrentFindMatch(nextMatchRange);
            }
            return;
        }
        var nextMatch = this._getNextMatch(after, false, true);
        if (nextMatch) {
            this._setCurrentFindMatch(nextMatch.range);
        }
    };
    FindModelBoundToEditorModel.prototype._getNextMatch = function (after, captureMatches, forceMove, isRecursed) {
        if (isRecursed === void 0) { isRecursed = false; }
        if (this._cannotFind()) {
            return null;
        }
        var findScope = this._decorations.getFindScope();
        var searchRange = FindModelBoundToEditorModel._getSearchRange(this._editor.getModel(), findScope);
        // ...(----)...|...
        if (searchRange.getEndPosition().isBefore(after)) {
            after = searchRange.getStartPosition();
        }
        // ...|...(----)...
        if (after.isBefore(searchRange.getStartPosition())) {
            after = searchRange.getStartPosition();
        }
        var lineNumber = after.lineNumber, column = after.column;
        var model = this._editor.getModel();
        var position = new Position(lineNumber, column);
        var nextMatch = model.findNextMatch(this._state.searchString, position, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getConfiguration().wordSeparators : null, captureMatches);
        if (forceMove && nextMatch && nextMatch.range.isEmpty() && nextMatch.range.getStartPosition().equals(position)) {
            // Looks like we're stuck at this position, unacceptable!
            position = this._nextSearchPosition(position);
            nextMatch = model.findNextMatch(this._state.searchString, position, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getConfiguration().wordSeparators : null, captureMatches);
        }
        if (!nextMatch) {
            // there is precisely one match and selection is on top of it
            return null;
        }
        if (!isRecursed && !searchRange.containsRange(nextMatch.range)) {
            return this._getNextMatch(nextMatch.range.getEndPosition(), captureMatches, forceMove, true);
        }
        return nextMatch;
    };
    FindModelBoundToEditorModel.prototype.moveToNextMatch = function () {
        this._moveToNextMatch(this._editor.getSelection().getEndPosition());
    };
    FindModelBoundToEditorModel.prototype._getReplacePattern = function () {
        if (this._state.isRegex) {
            return parseReplaceString(this._state.replaceString);
        }
        return ReplacePattern.fromStaticValue(this._state.replaceString);
    };
    FindModelBoundToEditorModel.prototype.replace = function () {
        if (!this._hasMatches()) {
            return;
        }
        var replacePattern = this._getReplacePattern();
        var selection = this._editor.getSelection();
        var nextMatch = this._getNextMatch(selection.getStartPosition(), replacePattern.hasReplacementPatterns, false);
        if (nextMatch) {
            if (selection.equalsRange(nextMatch.range)) {
                // selection sits on a find match => replace it!
                var replaceString = replacePattern.buildReplaceString(nextMatch.matches);
                var command = new ReplaceCommand(selection, replaceString);
                this._executeEditorCommand('replace', command);
                this._decorations.setStartPosition(new Position(selection.startLineNumber, selection.startColumn + replaceString.length));
                this.research(true);
            }
            else {
                this._decorations.setStartPosition(this._editor.getPosition());
                this._setCurrentFindMatch(nextMatch.range);
            }
        }
    };
    FindModelBoundToEditorModel.prototype._findMatches = function (findScope, captureMatches, limitResultCount) {
        var searchRange = FindModelBoundToEditorModel._getSearchRange(this._editor.getModel(), findScope);
        return this._editor.getModel().findMatches(this._state.searchString, searchRange, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getConfiguration().wordSeparators : null, captureMatches, limitResultCount);
    };
    FindModelBoundToEditorModel.prototype.replaceAll = function () {
        if (!this._hasMatches()) {
            return;
        }
        var findScope = this._decorations.getFindScope();
        if (findScope === null && this._state.matchesCount >= MATCHES_LIMIT) {
            // Doing a replace on the entire file that is over ${MATCHES_LIMIT} matches
            this._largeReplaceAll();
        }
        else {
            this._regularReplaceAll(findScope);
        }
        this.research(false);
    };
    FindModelBoundToEditorModel.prototype._largeReplaceAll = function () {
        var searchParams = new SearchParams(this._state.searchString, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getConfiguration().wordSeparators : null);
        var searchData = searchParams.parseSearchRequest();
        if (!searchData) {
            return;
        }
        var searchRegex = searchData.regex;
        if (!searchRegex.multiline) {
            var mod = 'm';
            if (searchRegex.ignoreCase) {
                mod += 'i';
            }
            if (searchRegex.global) {
                mod += 'g';
            }
            searchRegex = new RegExp(searchRegex.source, mod);
        }
        var model = this._editor.getModel();
        var modelText = model.getValue(EndOfLinePreference.LF);
        var fullModelRange = model.getFullModelRange();
        var replacePattern = this._getReplacePattern();
        var resultText;
        if (replacePattern.hasReplacementPatterns) {
            resultText = modelText.replace(searchRegex, function () {
                return replacePattern.buildReplaceString(arguments);
            });
        }
        else {
            resultText = modelText.replace(searchRegex, replacePattern.buildReplaceString(null));
        }
        var command = new ReplaceCommandThatPreservesSelection(fullModelRange, resultText, this._editor.getSelection());
        this._executeEditorCommand('replaceAll', command);
    };
    FindModelBoundToEditorModel.prototype._regularReplaceAll = function (findScope) {
        var replacePattern = this._getReplacePattern();
        // Get all the ranges (even more than the highlighted ones)
        var matches = this._findMatches(findScope, replacePattern.hasReplacementPatterns, 1073741824 /* MAX_SAFE_SMALL_INTEGER */);
        var replaceStrings = [];
        for (var i = 0, len = matches.length; i < len; i++) {
            replaceStrings[i] = replacePattern.buildReplaceString(matches[i].matches);
        }
        var command = new ReplaceAllCommand(this._editor.getSelection(), matches.map(function (m) { return m.range; }), replaceStrings);
        this._executeEditorCommand('replaceAll', command);
    };
    FindModelBoundToEditorModel.prototype.selectAllMatches = function () {
        if (!this._hasMatches()) {
            return;
        }
        var findScope = this._decorations.getFindScope();
        // Get all the ranges (even more than the highlighted ones)
        var matches = this._findMatches(findScope, false, 1073741824 /* MAX_SAFE_SMALL_INTEGER */);
        var selections = matches.map(function (m) { return new Selection(m.range.startLineNumber, m.range.startColumn, m.range.endLineNumber, m.range.endColumn); });
        // If one of the ranges is the editor selection, then maintain it as primary
        var editorSelection = this._editor.getSelection();
        for (var i = 0, len = selections.length; i < len; i++) {
            var sel = selections[i];
            if (sel.equalsRange(editorSelection)) {
                selections = [editorSelection].concat(selections.slice(0, i)).concat(selections.slice(i + 1));
                break;
            }
        }
        this._editor.setSelections(selections);
    };
    FindModelBoundToEditorModel.prototype._executeEditorCommand = function (source, command) {
        try {
            this._ignoreModelContentChanged = true;
            this._editor.pushUndoStop();
            this._editor.executeCommand(source, command);
            this._editor.pushUndoStop();
        }
        finally {
            this._ignoreModelContentChanged = false;
        }
    };
    return FindModelBoundToEditorModel;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
function effectiveOptionValue(override, value) {
    if (override === 1 /* True */) {
        return true;
    }
    if (override === 2 /* False */) {
        return false;
    }
    return value;
}
var FindReplaceState = /** @class */ (function () {
    function FindReplaceState() {
        this._searchString = '';
        this._replaceString = '';
        this._isRevealed = false;
        this._isReplaceRevealed = false;
        this._isRegex = false;
        this._isRegexOverride = 0 /* NotSet */;
        this._wholeWord = false;
        this._wholeWordOverride = 0 /* NotSet */;
        this._matchCase = false;
        this._matchCaseOverride = 0 /* NotSet */;
        this._searchScope = null;
        this._matchesPosition = 0;
        this._matchesCount = 0;
        this._currentMatch = null;
        this._onFindReplaceStateChange = new Emitter();
    }
    Object.defineProperty(FindReplaceState.prototype, "searchString", {
        get: function () { return this._searchString; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FindReplaceState.prototype, "replaceString", {
        get: function () { return this._replaceString; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FindReplaceState.prototype, "isRevealed", {
        get: function () { return this._isRevealed; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FindReplaceState.prototype, "isReplaceRevealed", {
        get: function () { return this._isReplaceRevealed; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FindReplaceState.prototype, "isRegex", {
        get: function () { return effectiveOptionValue(this._isRegexOverride, this._isRegex); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FindReplaceState.prototype, "wholeWord", {
        get: function () { return effectiveOptionValue(this._wholeWordOverride, this._wholeWord); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FindReplaceState.prototype, "matchCase", {
        get: function () { return effectiveOptionValue(this._matchCaseOverride, this._matchCase); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FindReplaceState.prototype, "actualIsRegex", {
        get: function () { return this._isRegex; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FindReplaceState.prototype, "actualWholeWord", {
        get: function () { return this._wholeWord; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FindReplaceState.prototype, "actualMatchCase", {
        get: function () { return this._matchCase; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FindReplaceState.prototype, "searchScope", {
        get: function () { return this._searchScope; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FindReplaceState.prototype, "matchesPosition", {
        get: function () { return this._matchesPosition; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FindReplaceState.prototype, "matchesCount", {
        get: function () { return this._matchesCount; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FindReplaceState.prototype, "currentMatch", {
        get: function () { return this._currentMatch; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FindReplaceState.prototype, "onFindReplaceStateChange", {
        get: function () { return this._onFindReplaceStateChange.event; },
        enumerable: true,
        configurable: true
    });
    FindReplaceState.prototype.dispose = function () {
    };
    FindReplaceState.prototype.changeMatchInfo = function (matchesPosition, matchesCount, currentMatch) {
        var changeEvent = {
            moveCursor: false,
            updateHistory: false,
            searchString: false,
            replaceString: false,
            isRevealed: false,
            isReplaceRevealed: false,
            isRegex: false,
            wholeWord: false,
            matchCase: false,
            searchScope: false,
            matchesPosition: false,
            matchesCount: false,
            currentMatch: false
        };
        var somethingChanged = false;
        if (matchesCount === 0) {
            matchesPosition = 0;
        }
        if (matchesPosition > matchesCount) {
            matchesPosition = matchesCount;
        }
        if (this._matchesPosition !== matchesPosition) {
            this._matchesPosition = matchesPosition;
            changeEvent.matchesPosition = true;
            somethingChanged = true;
        }
        if (this._matchesCount !== matchesCount) {
            this._matchesCount = matchesCount;
            changeEvent.matchesCount = true;
            somethingChanged = true;
        }
        if (typeof currentMatch !== 'undefined') {
            if (!Range.equalsRange(this._currentMatch, currentMatch)) {
                this._currentMatch = currentMatch;
                changeEvent.currentMatch = true;
                somethingChanged = true;
            }
        }
        if (somethingChanged) {
            this._onFindReplaceStateChange.fire(changeEvent);
        }
    };
    FindReplaceState.prototype.change = function (newState, moveCursor, updateHistory) {
        if (updateHistory === void 0) { updateHistory = true; }
        var changeEvent = {
            moveCursor: moveCursor,
            updateHistory: updateHistory,
            searchString: false,
            replaceString: false,
            isRevealed: false,
            isReplaceRevealed: false,
            isRegex: false,
            wholeWord: false,
            matchCase: false,
            searchScope: false,
            matchesPosition: false,
            matchesCount: false,
            currentMatch: false
        };
        var somethingChanged = false;
        var oldEffectiveIsRegex = this.isRegex;
        var oldEffectiveWholeWords = this.wholeWord;
        var oldEffectiveMatchCase = this.matchCase;
        if (typeof newState.searchString !== 'undefined') {
            if (this._searchString !== newState.searchString) {
                this._searchString = newState.searchString;
                changeEvent.searchString = true;
                somethingChanged = true;
            }
        }
        if (typeof newState.replaceString !== 'undefined') {
            if (this._replaceString !== newState.replaceString) {
                this._replaceString = newState.replaceString;
                changeEvent.replaceString = true;
                somethingChanged = true;
            }
        }
        if (typeof newState.isRevealed !== 'undefined') {
            if (this._isRevealed !== newState.isRevealed) {
                this._isRevealed = newState.isRevealed;
                changeEvent.isRevealed = true;
                somethingChanged = true;
            }
        }
        if (typeof newState.isReplaceRevealed !== 'undefined') {
            if (this._isReplaceRevealed !== newState.isReplaceRevealed) {
                this._isReplaceRevealed = newState.isReplaceRevealed;
                changeEvent.isReplaceRevealed = true;
                somethingChanged = true;
            }
        }
        if (typeof newState.isRegex !== 'undefined') {
            this._isRegex = newState.isRegex;
        }
        if (typeof newState.wholeWord !== 'undefined') {
            this._wholeWord = newState.wholeWord;
        }
        if (typeof newState.matchCase !== 'undefined') {
            this._matchCase = newState.matchCase;
        }
        if (typeof newState.searchScope !== 'undefined') {
            if (!Range.equalsRange(this._searchScope, newState.searchScope)) {
                this._searchScope = newState.searchScope;
                changeEvent.searchScope = true;
                somethingChanged = true;
            }
        }
        // Overrides get set when they explicitly come in and get reset anytime something else changes
        this._isRegexOverride = (typeof newState.isRegexOverride !== 'undefined' ? newState.isRegexOverride : 0 /* NotSet */);
        this._wholeWordOverride = (typeof newState.wholeWordOverride !== 'undefined' ? newState.wholeWordOverride : 0 /* NotSet */);
        this._matchCaseOverride = (typeof newState.matchCaseOverride !== 'undefined' ? newState.matchCaseOverride : 0 /* NotSet */);
        if (oldEffectiveIsRegex !== this.isRegex) {
            somethingChanged = true;
            changeEvent.isRegex = true;
        }
        if (oldEffectiveWholeWords !== this.wholeWord) {
            somethingChanged = true;
            changeEvent.wholeWord = true;
        }
        if (oldEffectiveMatchCase !== this.matchCase) {
            somethingChanged = true;
            changeEvent.matchCase = true;
        }
        if (somethingChanged) {
            this._onFindReplaceStateChange.fire(changeEvent);
        }
    };
    return FindReplaceState;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var IClipboardService = createDecorator('clipboardService');

const css$4 = "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n/* Checkbox */\n\n.monaco-checkbox .label {\n\twidth: 12px;\n\theight: 12px;\n\tborder: 1px solid black;\n\tbackground-color: transparent;\n\tdisplay: inline-block;\n}\n\n.monaco-checkbox .checkbox {\n\tposition: absolute;\n\toverflow: hidden;\n\tclip: rect(0 0 0 0);\n\theight: 1px;\n\twidth: 1px;\n\tmargin: -1px;\n\tpadding: 0;\n\tborder: 0;\n}\n\n.monaco-checkbox .checkbox:checked + .label {\n\tbackground-color: black;\n}\n\n/* Find widget */\n.monaco-editor .find-widget {\n\tposition: absolute;\n\tz-index: 10;\n\ttop: -44px; /* find input height + shadow (10px) */\n\theight: 34px; /* find input height */\n\toverflow: hidden;\n\tline-height: 19px;\n\n\t-webkit-transition: top 200ms linear;\n\t-o-transition: top 200ms linear;\n\t-moz-transition: top 200ms linear;\n\t-ms-transition: top 200ms linear;\n\ttransition: top 200ms linear;\n\n\tpadding: 0 4px;\n}\n/* Find widget when replace is toggled on */\n.monaco-editor .find-widget.replaceToggled {\n\ttop: -74px; /* find input height + replace input height + shadow (10px) */\n\theight: 64px; /* find input height + replace input height */\n}\n.monaco-editor .find-widget.replaceToggled > .replace-part {\n\tdisplay: flex;\n\tdisplay: -webkit-flex;\n\talign-items: center;\n}\n\n.monaco-editor .find-widget.visible,\n.monaco-editor .find-widget.replaceToggled.visible {\n\ttop: 0;\n}\n\n.monaco-editor .find-widget .monaco-inputbox .input {\n\tbackground-color: transparent;\n\t/* Style to compensate for //winjs */\n\tmin-height: 0;\n}\n\n.monaco-editor .find-widget .replace-input .input {\n\tfont-size: 13px;\n}\n\n.monaco-editor .find-widget > .find-part,\n.monaco-editor .find-widget > .replace-part {\n\tmargin: 4px 0 0 17px;\n\tfont-size: 12px;\n\tdisplay: flex;\n\tdisplay: -webkit-flex;\n\talign-items: center;\n}\n\n.monaco-editor .find-widget > .find-part .monaco-inputbox,\n.monaco-editor .find-widget > .replace-part .monaco-inputbox {\n\theight: 25px;\n}\n\n.monaco-editor .find-widget > .find-part .monaco-inputbox > .wrapper > .input {\n\twidth: 100% !important;\n\tpadding-right: 66px;\n}\n.monaco-editor .find-widget > .find-part .monaco-inputbox > .wrapper > .input,\n.monaco-editor .find-widget > .replace-part .monaco-inputbox > .wrapper > .input {\n\tpadding-top: 2px;\n\tpadding-bottom: 2px;\n}\n\n.monaco-editor .find-widget .monaco-findInput {\n\tvertical-align: middle;\n\tdisplay: flex;\n\tdisplay: -webkit-flex;\n\tflex:1;\n}\n\n.monaco-editor .find-widget .matchesCount {\n\tdisplay: flex;\n\tdisplay: -webkit-flex;\n\tflex: initial;\n\tmargin: 0 1px 0 3px;\n\tpadding: 2px 2px 0 2px;\n\theight: 25px;\n\tvertical-align: middle;\n\tbox-sizing: border-box;\n\ttext-align: center;\n\tline-height: 23px;\n}\n\n.monaco-editor .find-widget .button {\n\tmin-width: 20px;\n\twidth: 20px;\n\theight: 20px;\n\tdisplay: flex;\n\tdisplay: -webkit-flex;\n\tflex: initial;\n\tmargin-left: 3px;\n\tbackground-position: center center;\n\tbackground-repeat: no-repeat;\n\tcursor: pointer;\n}\n\n.monaco-editor .find-widget .button:not(.disabled):hover {\n\tbackground-color: rgba(0, 0, 0, 0.1);\n}\n\n.monaco-editor .find-widget .button.left {\n\tmargin-left: 0;\n\tmargin-right: 3px;\n}\n\n.monaco-editor .find-widget .button.wide {\n\twidth: auto;\n\tpadding: 1px 6px;\n\ttop: -1px;\n}\n\n.monaco-editor .find-widget .button.toggle {\n\tposition: absolute;\n\ttop: 0;\n\tleft: 0;\n\twidth: 18px;\n\theight: 100%;\n\t-webkit-box-sizing:\tborder-box;\n\t-o-box-sizing:\t\tborder-box;\n\t-moz-box-sizing:\tborder-box;\n\t-ms-box-sizing:\t\tborder-box;\n\tbox-sizing:\t\t\tborder-box;\n}\n\n.monaco-editor .find-widget .button.toggle.disabled {\n\tdisplay: none;\n}\n\n.monaco-editor .find-widget .previous {\n\tbackground-image: url(\"data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiCgkgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIKCSB4PSIwcHgiIHk9IjBweCIgd2lkdGg9IjE2cHgiIGhlaWdodD0iMTZweCIgdmlld0JveD0iLTEgLTMgMTYgMTYiIGVuYWJsZS1iYWNrZ3JvdW5kPSJuZXcgLTEgLTMgMTYgMTYiIHhtbDpzcGFjZT0icHJlc2VydmUiPgo8cG9seWdvbiBmaWxsPSIjNDI0MjQyIiBwb2ludHM9IjEzLDQgNiw0IDksMSA2LDEgMiw1IDYsOSA5LDkgNiw2IDEzLDYgIi8+Cjwvc3ZnPgo=\");\n}\n\n.monaco-editor .find-widget .next {\n\tbackground-image: url(\"data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiCgkgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIKCSB4PSIwcHgiIHk9IjBweCIgd2lkdGg9IjE2cHgiIGhlaWdodD0iMTZweCIgdmlld0JveD0iLTEgLTMgMTYgMTYiIGVuYWJsZS1iYWNrZ3JvdW5kPSJuZXcgLTEgLTMgMTYgMTYiIHhtbDpzcGFjZT0icHJlc2VydmUiPgo8cGF0aCBmaWxsPSIjNDI0MjQyIiBkPSJNMSw0aDdMNSwxaDNsNCw0TDgsOUg1bDMtM0gxVjR6Ii8+Cjwvc3ZnPgo=\");\n}\n\n.monaco-editor .find-widget .disabled {\n\topacity: 0.3;\n\tcursor: default;\n}\n\n.monaco-editor .find-widget .monaco-checkbox {\n\twidth: 20px;\n\theight: 20px;\n\tdisplay: inline-block;\n\tvertical-align: middle;\n\tmargin-left: 3px;\n}\n\n.monaco-editor .find-widget .monaco-checkbox .label {\n\tcontent: '';\n\tdisplay: inline-block;\n\tbackground-repeat: no-repeat;\n\tbackground-position: 0 0;\n\tbackground-image: url(\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCI+CjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDAsLTEwMzIuMzYyMikiPgogIDxyZWN0IHdpZHRoPSI5IiBoZWlnaHQ9IjIiIHg9IjIiIHk9IjEwNDYuMzYyMiIgc3R5bGU9ImZpbGw6IzQyNDI0MjtmaWxsLW9wYWNpdHk6MTtzdHJva2U6bm9uZSIgLz4KICA8cmVjdCB3aWR0aD0iMTMiIGhlaWdodD0iMiIgeD0iMiIgeT0iMTA0My4zNjIyIiBzdHlsZT0iZmlsbDojNDI0MjQyO2ZpbGwtb3BhY2l0eToxO3N0cm9rZTpub25lIiAvPgogIDxyZWN0IHdpZHRoPSI2IiBoZWlnaHQ9IjIiIHg9IjIiIHk9IjEwNDAuMzYyMiIgc3R5bGU9ImZpbGw6IzQyNDI0MjtmaWxsLW9wYWNpdHk6MTtzdHJva2U6bm9uZSIgLz4KICA8cmVjdCB3aWR0aD0iMTIiIGhlaWdodD0iMiIgeD0iMiIgeT0iMTAzNy4zNjIyIiBzdHlsZT0iZmlsbDojNDI0MjQyO2ZpbGwtb3BhY2l0eToxO3N0cm9rZTpub25lIiAvPgo8L2c+Cjwvc3ZnPg==\");\n\twidth: 20px;\n\theight: 20px;\n\tborder: none;\n}\n\n.monaco-editor .find-widget .monaco-checkbox .checkbox:disabled + .label {\n\topacity: 0.3;\n\tcursor: default;\n}\n\n.monaco-editor .find-widget .monaco-checkbox .checkbox:not(:disabled) + .label {\n\tcursor: pointer;\n}\n\n.monaco-editor .find-widget .monaco-checkbox .checkbox:not(:disabled):hover:before + .label {\n\tbackground-color: #DDD;\n}\n\n.monaco-editor .find-widget .monaco-checkbox .checkbox:checked + .label {\n\tbackground-color: rgba(100, 100, 100, 0.2);\n}\n\n.monaco-editor .find-widget .close-fw {\n\tbackground-image: url(\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgaGVpZ2h0PSIxNiIgdmlld0JveD0iMyAzIDE2IDE2IiBlbmFibGUtYmFja2dyb3VuZD0ibmV3IDMgMyAxNiAxNiI+PHBvbHlnb24gZmlsbD0iIzQyNDI0MiIgcG9pbnRzPSIxMi41OTcsMTEuMDQyIDE1LjQsMTMuODQ1IDEzLjg0NCwxNS40IDExLjA0MiwxMi41OTggOC4yMzksMTUuNCA2LjY4MywxMy44NDUgOS40ODUsMTEuMDQyIDYuNjgzLDguMjM5IDguMjM4LDYuNjgzIDExLjA0Miw5LjQ4NiAxMy44NDUsNi42ODMgMTUuNCw4LjIzOSIvPjwvc3ZnPg==\");\n}\n\n.monaco-editor .find-widget .expand {\n\tbackground-image: url(\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgaGVpZ2h0PSIxNiI+PHBhdGggZmlsbD0iIzY0NjQ2NSIgZD0iTTExIDEwLjA3aC01LjY1Nmw1LjY1Ni01LjY1NnY1LjY1NnoiLz48L3N2Zz4=\");\n}\n\n.monaco-editor .find-widget .collapse {\n\tbackground-image: url(\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgaGVpZ2h0PSIxNiI+PHBhdGggZmlsbD0iIzY0NjQ2NSIgZD0iTTYgNHY4bDQtNC00LTR6bTEgMi40MTRsMS41ODYgMS41ODYtMS41ODYgMS41ODZ2LTMuMTcyeiIvPjwvc3ZnPg==\");\n}\n\n.monaco-editor .find-widget .replace {\n\tbackground-image: url(\"data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IiB3aWR0aD0iMTZweCIKCSBoZWlnaHQ9IjE2cHgiIHZpZXdCb3g9IjAgMCAxNiAxNiIgZW5hYmxlLWJhY2tncm91bmQ9Im5ldyAwIDAgMTYgMTYiIHhtbDpzcGFjZT0icHJlc2VydmUiPgo8ZyBpZD0iaWNvbl94NUZfYmciPgoJPGc+CgkJPHBhdGggZmlsbD0iIzQyNDI0MiIgZD0iTTExLDNWMWgtMXY1djFoMWgyaDFWNFYzSDExeiBNMTMsNmgtMlY0aDJWNnoiLz4KCQk8cGF0aCBmaWxsPSIjNDI0MjQyIiBkPSJNMiwxNWg3VjlIMlYxNXogTTQsMTBoM3YxSDV2MmgydjFINFYxMHoiLz4KCTwvZz4KPC9nPgo8ZyBpZD0iY29sb3JfeDVGX2ltcG9ydGFuY2UiPgoJPHBhdGggZmlsbD0iIzAwNTM5QyIgZD0iTTMuOTc5LDMuNUw0LDZMMyw1djEuNUw0LjUsOEw2LDYuNVY1TDUsNkw0Ljk3OSwzLjVjMC0wLjI3NSwwLjIyNS0wLjUsMC41LTAuNUg5VjJINS40NzkKCQlDNC42NTEsMiwzLjk3OSwyLjY3MywzLjk3OSwzLjV6Ii8+CjwvZz4KPC9zdmc+Cg==\");\n}\n\n.monaco-editor .find-widget .replace-all {\n\tbackground-image: url(\"data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IiB3aWR0aD0iMTZweCIKCSBoZWlnaHQ9IjE2cHgiIHZpZXdCb3g9IjAgMCAxNiAxNiIgZW5hYmxlLWJhY2tncm91bmQ9Im5ldyAwIDAgMTYgMTYiIHhtbDpzcGFjZT0icHJlc2VydmUiPgo8ZyBpZD0iaWNvbl94NUZfYmciPgoJPHBhdGggZmlsbD0iIzQyNDI0MiIgZD0iTTExLDE1VjlIMXY2SDExeiBNMiwxNHYtMmgxdi0xSDJ2LTFoM3Y0SDJ6IE0xMCwxMUg4djJoMnYxSDd2LTRoM1YxMXogTTMsMTN2LTFoMXYxSDN6IE0xMyw3djZoLTFWOEg1VjcKCQlIMTN6IE0xMywyVjFoLTF2NWgzVjJIMTN6IE0xNCw1aC0xVjNoMVY1eiBNMTEsMnY0SDhWNGgxdjFoMVY0SDlWM0g4VjJIMTF6Ii8+CjwvZz4KPGcgaWQ9ImNvbG9yX3g1Rl9hY3Rpb24iPgoJPHBhdGggZmlsbD0iIzAwNTM5QyIgZD0iTTEuOTc5LDMuNUwyLDZMMSw1djEuNUwyLjUsOEw0LDYuNVY1TDMsNkwyLjk3OSwzLjVjMC0wLjI3NSwwLjIyNS0wLjUsMC41LTAuNUg3VjJIMy40NzkKCQlDMi42NTEsMiwxLjk3OSwyLjY3MywxLjk3OSwzLjV6Ii8+CjwvZz4KPC9zdmc+Cg==\");\n}\n\n.monaco-editor .find-widget > .replace-part {\n\tdisplay: none;\n}\n\n.monaco-editor .find-widget > .replace-part > .replace-input {\n\tdisplay: flex;\n\tdisplay: -webkit-flex;\n\tvertical-align: middle;\n\twidth: auto !important;\n}\n\n/* REDUCED */\n.monaco-editor .find-widget.reduced-find-widget .matchesCount,\n.monaco-editor .find-widget.reduced-find-widget .monaco-checkbox {\n\tdisplay:none;\n}\n\n/* NARROW (SMALLER THAN REDUCED) */\n.monaco-editor .find-widget.narrow-find-widget {\n\tmax-width: 257px !important;\n}\n\n/* COLLAPSED (SMALLER THAN NARROW) */\n.monaco-editor .find-widget.collapsed-find-widget {\n\tmax-width: 111px !important;\n}\n\n.monaco-editor .find-widget.collapsed-find-widget .button.previous,\n.monaco-editor .find-widget.collapsed-find-widget .button.next,\n.monaco-editor .find-widget.collapsed-find-widget .button.replace,\n.monaco-editor .find-widget.collapsed-find-widget .button.replace-all,\n.monaco-editor .find-widget.collapsed-find-widget > .find-part .monaco-findInput .controls {\n\tdisplay:none;\n}\n\n.monaco-editor .find-widget.collapsed-find-widget > .find-part .monaco-inputbox > .wrapper > .input {\n\tpadding-right: 0px;\n}\n\n.monaco-editor .findMatch {\n\t-webkit-animation-duration: 0;\n\t-webkit-animation-name: inherit !important;\n\t-moz-animation-duration: 0;\n\t-moz-animation-name: inherit !important;\n\t-ms-animation-duration: 0;\n\t-ms-animation-name: inherit !important;\n\tanimation-duration: 0;\n\tanimation-name: inherit !important;\n}\n\n.monaco-editor .find-widget .monaco-sash {\n\twidth: 2px !important;\n\tmargin-left: -4px;\n}\n\n.monaco-editor.hc-black .find-widget .previous,\n.monaco-editor.vs-dark .find-widget .previous {\n\tbackground-image: url(\"data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiCgkgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIKCSB4PSIwcHgiIHk9IjBweCIgd2lkdGg9IjE2cHgiIGhlaWdodD0iMTZweCIgdmlld0JveD0iLTEgLTMgMTYgMTYiIGVuYWJsZS1iYWNrZ3JvdW5kPSJuZXcgLTEgLTMgMTYgMTYiIHhtbDpzcGFjZT0icHJlc2VydmUiPgo8cG9seWdvbiBmaWxsPSIjQzVDNUM1IiBwb2ludHM9IjEzLDQgNiw0IDksMSA2LDEgMiw1IDYsOSA5LDkgNiw2IDEzLDYgIi8+Cjwvc3ZnPgo=\");\n}\n\n.monaco-editor.hc-black .find-widget .next,\n.monaco-editor.vs-dark .find-widget .next {\n\tbackground-image: url(\"data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiCgkgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIKCSB4PSIwcHgiIHk9IjBweCIgd2lkdGg9IjE2cHgiIGhlaWdodD0iMTZweCIgdmlld0JveD0iLTEgLTMgMTYgMTYiIGVuYWJsZS1iYWNrZ3JvdW5kPSJuZXcgLTEgLTMgMTYgMTYiIHhtbDpzcGFjZT0icHJlc2VydmUiPgo8cGF0aCBmaWxsPSIjQzVDNUM1IiBkPSJNMSw0aDdMNSwxaDNsNCw0TDgsOUg1bDMtM0gxVjR6Ii8+Cjwvc3ZnPgo=\");\n}\n\n.monaco-editor.hc-black .find-widget .monaco-checkbox .label,\n.monaco-editor.vs-dark .find-widget .monaco-checkbox .label {\n\tbackground-image: url(\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCI+CjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDAsLTEwMzIuMzYyMikiPgogIDxyZWN0IHdpZHRoPSI5IiBoZWlnaHQ9IjIiIHg9IjIiIHk9IjEwNDYuMzYyMiIgc3R5bGU9ImZpbGw6I0M1QzVDNTtmaWxsLW9wYWNpdHk6MTtzdHJva2U6bm9uZSIgLz4KICA8cmVjdCB3aWR0aD0iMTMiIGhlaWdodD0iMiIgeD0iMiIgeT0iMTA0My4zNjIyIiBzdHlsZT0iZmlsbDojQzVDNUM1O2ZpbGwtb3BhY2l0eToxO3N0cm9rZTpub25lIiAvPgogIDxyZWN0IHdpZHRoPSI2IiBoZWlnaHQ9IjIiIHg9IjIiIHk9IjEwNDAuMzYyMiIgc3R5bGU9ImZpbGw6I0M1QzVDNTtmaWxsLW9wYWNpdHk6MTtzdHJva2U6bm9uZSIgLz4KICA8cmVjdCB3aWR0aD0iMTIiIGhlaWdodD0iMiIgeD0iMiIgeT0iMTAzNy4zNjIyIiBzdHlsZT0iZmlsbDojQzVDNUM1O2ZpbGwtb3BhY2l0eToxO3N0cm9rZTpub25lIiAvPgo8L2c+Cjwvc3ZnPg==\");\n}\n\n.monaco-editor.vs-dark .find-widget .monaco-checkbox .checkbox:not(:disabled):hover:before + .label {\n\tbackground-color: rgba(255, 255, 255, 0.1);\n}\n\n.monaco-editor.vs-dark .find-widget .monaco-checkbox .checkbox:checked + .label {\n\tbackground-color: rgba(255, 255, 255, 0.1);\n}\n\n.monaco-editor.hc-black .find-widget .close-fw,\n.monaco-editor.vs-dark .find-widget .close-fw {\n\tbackground-image: url(\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgaGVpZ2h0PSIxNiIgdmlld0JveD0iMyAzIDE2IDE2IiBlbmFibGUtYmFja2dyb3VuZD0ibmV3IDMgMyAxNiAxNiI+PHBvbHlnb24gZmlsbD0iI2U4ZThlOCIgcG9pbnRzPSIxMi41OTcsMTEuMDQyIDE1LjQsMTMuODQ1IDEzLjg0NCwxNS40IDExLjA0MiwxMi41OTggOC4yMzksMTUuNCA2LjY4MywxMy44NDUgOS40ODUsMTEuMDQyIDYuNjgzLDguMjM5IDguMjM4LDYuNjgzIDExLjA0Miw5LjQ4NiAxMy44NDUsNi42ODMgMTUuNCw4LjIzOSIvPjwvc3ZnPg==\");\n}\n\n.monaco-editor.hc-black .find-widget .replace,\n.monaco-editor.vs-dark .find-widget .replace {\n\tbackground-image: url(\"data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IiB3aWR0aD0iMTZweCIKCSBoZWlnaHQ9IjE2cHgiIHZpZXdCb3g9IjAgMCAxNiAxNiIgZW5hYmxlLWJhY2tncm91bmQ9Im5ldyAwIDAgMTYgMTYiIHhtbDpzcGFjZT0icHJlc2VydmUiPgo8ZyBpZD0iaWNvbl94NUZfYmciPgoJPGc+CgkJPHBhdGggZmlsbD0iI0M1QzVDNSIgZD0iTTExLDNWMWgtMXY1djFoMWgyaDFWNFYzSDExeiBNMTMsNmgtMlY0aDJWNnoiLz4KCQk8cGF0aCBmaWxsPSIjQzVDNUM1IiBkPSJNMiwxNWg3VjlIMlYxNXogTTQsMTBoM3YxSDV2MmgydjFINFYxMHoiLz4KCTwvZz4KPC9nPgo8ZyBpZD0iY29sb3JfeDVGX2ltcG9ydGFuY2UiPgoJPHBhdGggZmlsbD0iIzc1QkVGRiIgZD0iTTMuOTc5LDMuNUw0LDZMMyw1djEuNUw0LjUsOEw2LDYuNVY1TDUsNkw0Ljk3OSwzLjVjMC0wLjI3NSwwLjIyNS0wLjUsMC41LTAuNUg5VjJINS40NzkKCQlDNC42NTEsMiwzLjk3OSwyLjY3MywzLjk3OSwzLjV6Ii8+CjwvZz4KPC9zdmc+Cg==\");\n}\n\n.monaco-editor.hc-black .find-widget .replace-all,\n.monaco-editor.vs-dark .find-widget .replace-all {\n\tbackground-image: url(\"data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IiB3aWR0aD0iMTZweCIKCSBoZWlnaHQ9IjE2cHgiIHZpZXdCb3g9IjAgMCAxNiAxNiIgZW5hYmxlLWJhY2tncm91bmQ9Im5ldyAwIDAgMTYgMTYiIHhtbDpzcGFjZT0icHJlc2VydmUiPgo8ZyBpZD0iaWNvbl94NUZfYmciPgoJPHBhdGggZmlsbD0iI0M1QzVDNSIgZD0iTTExLDE1VjlIMXY2SDExeiBNMiwxNHYtMmgxdi0xSDJ2LTFoM3Y0SDJ6IE0xMCwxMUg4djJoMnYxSDd2LTRoM1YxMXogTTMsMTN2LTFoMXYxSDN6IE0xMyw3djZoLTFWOEg1VjcKCQlIMTN6IE0xMywyVjFoLTF2NWgzVjJIMTN6IE0xNCw1aC0xVjNoMVY1eiBNMTEsMnY0SDhWNGgxdjFoMVY0SDlWM0g4VjJIMTF6Ii8+CjwvZz4KPGcgaWQ9ImNvbG9yX3g1Rl9hY3Rpb24iPgoJPHBhdGggZmlsbD0iIzc1QkVGRiIgZD0iTTEuOTc5LDMuNUwyLDZMMSw1djEuNUwyLjUsOEw0LDYuNVY1TDMsNkwyLjk3OSwzLjVjMC0wLjI3NSwwLjIyNS0wLjUsMC41LTAuNUg3VjJIMy40NzkKCQlDMi42NTEsMiwxLjk3OSwyLjY3MywxLjk3OSwzLjV6Ii8+CjwvZz4KPC9zdmc+Cg==\");\n}\n\n.monaco-editor.hc-black .find-widget .expand,\n.monaco-editor.vs-dark .find-widget .expand {\n\tbackground-image: url(\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgaGVpZ2h0PSIxNiI+PHBhdGggZmlsbD0iI2U4ZThlOCIgZD0iTTExIDEwLjA3aC01LjY1Nmw1LjY1Ni01LjY1NnY1LjY1NnoiLz48L3N2Zz4=\");\n}\n\n.monaco-editor.hc-black .find-widget .collapse,\n.monaco-editor.vs-dark .find-widget .collapse {\n\tbackground-image: url(\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgaGVpZ2h0PSIxNiI+PHBhdGggZmlsbD0iI2U4ZThlOCIgZD0iTTYgNHY4bDQtNC00LTR6bTEgMi40MTRsMS41ODYgMS41ODYtMS41ODYgMS41ODZ2LTMuMTcyeiIvPjwvc3ZnPg==\");\n}\n\n.monaco-editor.hc-black .find-widget .button:not(.disabled):hover,\n.monaco-editor.vs-dark .find-widget .button:not(.disabled):hover {\n\tbackground-color: rgba(255, 255, 255, 0.1);\n}\n\n.monaco-editor.hc-black .find-widget .button:before {\n\tposition: relative;\n\ttop: 1px;\n\tleft: 2px;\n}\n\n.monaco-editor.hc-black .find-widget .monaco-checkbox .checkbox:checked + .label {\n\tbackground-color: rgba(255, 255, 255, 0.1);\n}\n";
  const element$4 = ((css, src) => {
if (typeof document !== 'object')
console.info(`Skipped loading "${src}"`);
try {
const id = src
  .replace(/\.css.*$/, '')
  .replace(/[\\:]/g, '/')
  .replace(/[^\w\/]+/g, '');
return (
  document.querySelector(`style[id="${id}"]`) ||
  document.head.appendChild(
    Object.assign(document.createElement('style'), {
      id,
      textContent: `${css}\n\n /* sourceURL=${src} */`,
    }),
  )
);
} catch (exception) {
console.warn(`Failed load "${src}"`, exception);
}
})(css$4, "…monaco-editor/esm/vs/editor/contrib/find/findWidget.css");
  //@ sourceURL=/Users/daflair/Projects/packages/monaco-es/node_modules/monaco-editor/esm/vs/editor/contrib/find/findWidget.css

const css$5 = "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/* ---------- Find input ---------- */\n\n.monaco-findInput {\n\tposition: relative;\n}\n\n.monaco-findInput .monaco-inputbox {\n\tfont-size: 13px;\n\twidth: 100%;\n\theight: 25px;\n}\n\n.monaco-findInput > .controls {\n\tposition: absolute;\n\ttop: 3px;\n\tright: 2px;\n}\n\n.vs .monaco-findInput.disabled {\n\tbackground-color: #E1E1E1;\n}\n\n/* Theming */\n.vs-dark .monaco-findInput.disabled {\n\tbackground-color: #333;\n}\n\n/* Highlighting */\n.monaco-findInput.highlight-0 .controls {\n\tanimation: monaco-findInput-highlight-0 100ms linear 0s;\n}\n.monaco-findInput.highlight-1 .controls {\n\tanimation: monaco-findInput-highlight-1 100ms linear 0s;\n}\n.hc-black .monaco-findInput.highlight-0 .controls,\n.vs-dark  .monaco-findInput.highlight-0 .controls {\n\tanimation: monaco-findInput-highlight-dark-0 100ms linear 0s;\n}\n.hc-black .monaco-findInput.highlight-1 .controls,\n.vs-dark  .monaco-findInput.highlight-1 .controls {\n\tanimation: monaco-findInput-highlight-dark-1 100ms linear 0s;\n}\n\n@keyframes monaco-findInput-highlight-0 {\n\t0% { background: rgba(253, 255, 0, 0.8); }\n\t100% { background: transparent; }\n}\n@keyframes monaco-findInput-highlight-1 {\n\t0% { background: rgba(253, 255, 0, 0.8); }\n\t/* Made intentionally different such that the CSS minifier does not collapse the two animations into a single one*/\n\t99% { background: transparent; }\n}\n\n@keyframes monaco-findInput-highlight-dark-0 {\n\t0% { background: rgba(255, 255, 255, 0.44); }\n\t100% { background: transparent; }\n}\n@keyframes monaco-findInput-highlight-dark-1 {\n\t0% { background: rgba(255, 255, 255, 0.44); }\n\t/* Made intentionally different such that the CSS minifier does not collapse the two animations into a single one*/\n\t99% { background: transparent; }\n}";
  const element$5 = ((css, src) => {
if (typeof document !== 'object')
console.info(`Skipped loading "${src}"`);
try {
const id = src
  .replace(/\.css.*$/, '')
  .replace(/[\\:]/g, '/')
  .replace(/[^\w\/]+/g, '');
return (
  document.querySelector(`style[id="${id}"]`) ||
  document.head.appendChild(
    Object.assign(document.createElement('style'), {
      id,
      textContent: `${css}\n\n /* sourceURL=${src} */`,
    }),
  )
);
} catch (exception) {
console.warn(`Failed load "${src}"`, exception);
}
})(css$5, "…monaco-editor/esm/vs/base/browser/ui/findinput/findInput.css");
  //@ sourceURL=/Users/daflair/Projects/packages/monaco-es/node_modules/monaco-editor/esm/vs/base/browser/ui/findinput/findInput.css

const css$6 = "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n.monaco-inputbox {\n\tposition: relative;\n\tdisplay: block;\n\tpadding: 0;\n\t-webkit-box-sizing:\tborder-box;\n\t-o-box-sizing:\t\tborder-box;\n\t-moz-box-sizing:\tborder-box;\n\t-ms-box-sizing:\t\tborder-box;\n\tbox-sizing:\t\t\tborder-box;\n\tline-height: auto !important;\n\n\t/* Customizable */\n\tfont-size: inherit;\n}\n\n.monaco-inputbox.idle {\n\tborder: 1px solid transparent;\n}\n\n.monaco-inputbox > .wrapper > .input,\n.monaco-inputbox > .wrapper > .mirror {\n\n\t/* Customizable */\n\tpadding: 4px;\n}\n\n.monaco-inputbox > .wrapper {\n\tposition: relative;\n\twidth: 100%;\n\theight: 100%;\n}\n\n.monaco-inputbox > .wrapper > .input {\n\tdisplay: inline-block;\n\t-webkit-box-sizing:\tborder-box;\n\t-o-box-sizing:\t\tborder-box;\n\t-moz-box-sizing:\tborder-box;\n\t-ms-box-sizing:\t\tborder-box;\n\tbox-sizing:\t\t\tborder-box;\n\twidth: 100%;\n\theight: 100%;\n\tline-height: inherit;\n\tborder: none;\n\tfont-family: inherit;\n\tfont-size: inherit;\n\tresize: none;\n\tcolor: inherit;\n}\n\n.monaco-inputbox > .wrapper > input {\n\ttext-overflow: ellipsis;\n}\n\n.monaco-inputbox > .wrapper > textarea.input {\n\tdisplay: block;\n\toverflow: hidden;\n}\n\n.monaco-inputbox > .wrapper > .mirror {\n\tposition: absolute;\n\tdisplay: inline-block;\n\twidth: 100%;\n\ttop: 0;\n\tleft: 0;\n\t-webkit-box-sizing:\tborder-box;\n\t-o-box-sizing:\t\tborder-box;\n\t-moz-box-sizing:\tborder-box;\n\t-ms-box-sizing:\t\tborder-box;\n\tbox-sizing:\t\t\tborder-box;\n\twhite-space: pre-wrap;\n\tvisibility: hidden;\n\tmin-height: 26px;\n\tword-wrap: break-word;\n}\n\n/* Context view */\n\n.monaco-inputbox-container {\n\ttext-align: right;\n}\n\n.monaco-inputbox-container .monaco-inputbox-message {\n\tdisplay: inline-block;\n\toverflow: hidden;\n\ttext-align: left;\n\twidth: 100%;\n\t-webkit-box-sizing:\tborder-box;\n\t-o-box-sizing:\t\tborder-box;\n\t-moz-box-sizing:\tborder-box;\n\t-ms-box-sizing:\t\tborder-box;\n\tbox-sizing:\t\t\tborder-box;\n\tpadding: 0.4em;\n\tfont-size: 12px;\n\tline-height: 17px;\n\tmin-height: 34px;\n\tmargin-top: -1px;\n\tword-wrap: break-word;\n}\n\n/* Action bar support */\n.monaco-inputbox .monaco-action-bar {\n\tposition: absolute;\n\tright: 2px;\n\ttop: 4px;\n}\n\n.monaco-inputbox .monaco-action-bar .action-item {\n\tmargin-left: 2px;\n}\n\n.monaco-inputbox .monaco-action-bar .action-item .icon {\n\tbackground-repeat: no-repeat;\n\twidth: 16px;\n\theight: 16px;\n}";
  const element$6 = ((css, src) => {
if (typeof document !== 'object')
console.info(`Skipped loading "${src}"`);
try {
const id = src
  .replace(/\.css.*$/, '')
  .replace(/[\\:]/g, '/')
  .replace(/[^\w\/]+/g, '');
return (
  document.querySelector(`style[id="${id}"]`) ||
  document.head.appendChild(
    Object.assign(document.createElement('style'), {
      id,
      textContent: `${css}\n\n /* sourceURL=${src} */`,
    }),
  )
);
} catch (exception) {
console.warn(`Failed load "${src}"`, exception);
}
})(css$6, "…monaco-editor/esm/vs/base/browser/ui/inputbox/inputBox.css");
  //@ sourceURL=/Users/daflair/Projects/packages/monaco-es/node_modules/monaco-editor/esm/vs/base/browser/ui/inputbox/inputBox.css

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var IdGenerator = /** @class */ (function () {
    function IdGenerator(prefix) {
        this._prefix = prefix;
        this._lastId = 0;
    }
    IdGenerator.prototype.nextId = function () {
        return this._prefix + (++this._lastId);
    };
    return IdGenerator;
}());
var defaultGenerator = new IdGenerator('id#');

/**
 * marked - a markdown parser
 * Copyright (c) 2011-2014, Christopher Jeffrey. (MIT Licensed)
 * https://github.com/markedjs/marked
 */

var __marked_exports;
(function(root) {

/**
 * Block-Level Grammar
 */

var block = {
  newline: /^\n+/,
  code: /^( {4}[^\n]+\n*)+/,
  fences: noop,
  hr: /^ {0,3}((?:- *){3,}|(?:_ *){3,}|(?:\* *){3,})(?:\n+|$)/,
  heading: /^ *(#{1,6}) *([^\n]+?) *#* *(?:\n+|$)/,
  nptable: noop,
  blockquote: /^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/,
  list: /^( *)(bull) [\s\S]+?(?:hr|def|\n{2,}(?! )(?!\1bull )\n*|\s*$)/,
  html: /^ *(?:comment *(?:\n|\s*$)|closed *(?:\n{2,}|\s*$)|closing *(?:\n{2,}|\s*$))/,
  def: /^ {0,3}\[(label)\]: *\n? *<?([^\s>]+)>?(?:(?: +\n? *| *\n *)(title))? *(?:\n+|$)/,
  table: noop,
  lheading: /^([^\n]+)\n *(=|-){2,} *(?:\n+|$)/,
  paragraph: /^([^\n]+(?:\n?(?!hr|heading|lheading| {0,3}>|tag)[^\n]+)+)/,
  text: /^[^\n]+/
};

block._label = /(?:\\[\[\]]|[^\[\]])+/;
block._title = /(?:"(?:\\"|[^"]|"[^"\n]*")*"|'\n?(?:[^'\n]+\n?)*'|\([^()]*\))/;
block.def = edit(block.def)
  .replace('label', block._label)
  .replace('title', block._title)
  .getRegex();

block.bullet = /(?:[*+-]|\d+\.)/;
block.item = /^( *)(bull) [^\n]*(?:\n(?!\1bull )[^\n]*)*/;
block.item = edit(block.item, 'gm')
  .replace(/bull/g, block.bullet)
  .getRegex();

block.list = edit(block.list)
  .replace(/bull/g, block.bullet)
  .replace('hr', '\\n+(?=\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$))')
  .replace('def', '\\n+(?=' + block.def.source + ')')
  .getRegex();

block._tag = '(?!(?:'
  + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code'
  + '|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo'
  + '|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b';

block.html = edit(block.html)
  .replace('comment', /<!--[\s\S]*?-->/)
  .replace('closed', /<(tag)[\s\S]+?<\/\1>/)
  .replace('closing', /<tag(?:"[^"]*"|'[^']*'|\s[^'"\/>\s]*)*?\/?>/)
  .replace(/tag/g, block._tag)
  .getRegex();

block.paragraph = edit(block.paragraph)
  .replace('hr', block.hr)
  .replace('heading', block.heading)
  .replace('lheading', block.lheading)
  .replace('tag', '<' + block._tag)
  .getRegex();

block.blockquote = edit(block.blockquote)
  .replace('paragraph', block.paragraph)
  .getRegex();

/**
 * Normal Block Grammar
 */

block.normal = merge({}, block);

/**
 * GFM Block Grammar
 */

block.gfm = merge({}, block.normal, {
  fences: /^ *(`{3,}|~{3,})[ \.]*(\S+)? *\n([\s\S]*?)\n? *\1 *(?:\n+|$)/,
  paragraph: /^/,
  heading: /^ *(#{1,6}) +([^\n]+?) *#* *(?:\n+|$)/
});

block.gfm.paragraph = edit(block.paragraph)
  .replace('(?!', '(?!'
    + block.gfm.fences.source.replace('\\1', '\\2') + '|'
    + block.list.source.replace('\\1', '\\3') + '|')
  .getRegex();

/**
 * GFM + Tables Block Grammar
 */

block.tables = merge({}, block.gfm, {
  nptable: /^ *(\S.*\|.*)\n *([-:]+ *\|[-| :]*)\n((?:.*\|.*(?:\n|$))*)\n*/,
  table: /^ *\|(.+)\n *\|( *[-:]+[-| :]*)\n((?: *\|.*(?:\n|$))*)\n*/
});

/**
 * Block Lexer
 */

function Lexer(options) {
  this.tokens = [];
  this.tokens.links = {};
  this.options = options || marked.defaults;
  this.rules = block.normal;

  if (this.options.gfm) {
    if (this.options.tables) {
      this.rules = block.tables;
    } else {
      this.rules = block.gfm;
    }
  }
}

/**
 * Expose Block Rules
 */

Lexer.rules = block;

/**
 * Static Lex Method
 */

Lexer.lex = function(src, options) {
  var lexer = new Lexer(options);
  return lexer.lex(src);
};

/**
 * Preprocessing
 */

Lexer.prototype.lex = function(src) {
  src = src
    .replace(/\r\n|\r/g, '\n')
    .replace(/\t/g, '    ')
    .replace(/\u00a0/g, ' ')
    .replace(/\u2424/g, '\n');

  return this.token(src, true);
};

/**
 * Lexing
 */

Lexer.prototype.token = function(src, top) {
  src = src.replace(/^ +$/gm, '');
  var next,
      loose,
      cap,
      bull,
      b,
      item,
      space,
      i,
      tag,
      l,
      isordered;

  while (src) {
    // newline
    if (cap = this.rules.newline.exec(src)) {
      src = src.substring(cap[0].length);
      if (cap[0].length > 1) {
        this.tokens.push({
          type: 'space'
        });
      }
    }

    // code
    if (cap = this.rules.code.exec(src)) {
      src = src.substring(cap[0].length);
      cap = cap[0].replace(/^ {4}/gm, '');
      this.tokens.push({
        type: 'code',
        text: !this.options.pedantic
          ? cap.replace(/\n+$/, '')
          : cap
      });
      continue;
    }

    // fences (gfm)
    if (cap = this.rules.fences.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'code',
        lang: cap[2],
        text: cap[3] || ''
      });
      continue;
    }

    // heading
    if (cap = this.rules.heading.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'heading',
        depth: cap[1].length,
        text: cap[2]
      });
      continue;
    }

    // table no leading pipe (gfm)
    if (top && (cap = this.rules.nptable.exec(src))) {
      src = src.substring(cap[0].length);

      item = {
        type: 'table',
        header: cap[1].replace(/^ *| *\| *$/g, '').split(/ *\| */),
        align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
        cells: cap[3].replace(/\n$/, '').split('\n')
      };

      for (i = 0; i < item.align.length; i++) {
        if (/^ *-+: *$/.test(item.align[i])) {
          item.align[i] = 'right';
        } else if (/^ *:-+: *$/.test(item.align[i])) {
          item.align[i] = 'center';
        } else if (/^ *:-+ *$/.test(item.align[i])) {
          item.align[i] = 'left';
        } else {
          item.align[i] = null;
        }
      }

      for (i = 0; i < item.cells.length; i++) {
        item.cells[i] = item.cells[i].split(/ *\| */);
      }

      this.tokens.push(item);

      continue;
    }

    // hr
    if (cap = this.rules.hr.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'hr'
      });
      continue;
    }

    // blockquote
    if (cap = this.rules.blockquote.exec(src)) {
      src = src.substring(cap[0].length);

      this.tokens.push({
        type: 'blockquote_start'
      });

      cap = cap[0].replace(/^ *> ?/gm, '');

      // Pass `top` to keep the current
      // "toplevel" state. This is exactly
      // how markdown.pl works.
      this.token(cap, top);

      this.tokens.push({
        type: 'blockquote_end'
      });

      continue;
    }

    // list
    if (cap = this.rules.list.exec(src)) {
      src = src.substring(cap[0].length);
      bull = cap[2];
      isordered = bull.length > 1;

      this.tokens.push({
        type: 'list_start',
        ordered: isordered,
        start: isordered ? +bull : ''
      });

      // Get each top-level item.
      cap = cap[0].match(this.rules.item);

      next = false;
      l = cap.length;
      i = 0;

      for (; i < l; i++) {
        item = cap[i];

        // Remove the list item's bullet
        // so it is seen as the next token.
        space = item.length;
        item = item.replace(/^ *([*+-]|\d+\.) +/, '');

        // Outdent whatever the
        // list item contains. Hacky.
        if (~item.indexOf('\n ')) {
          space -= item.length;
          item = !this.options.pedantic
            ? item.replace(new RegExp('^ {1,' + space + '}', 'gm'), '')
            : item.replace(/^ {1,4}/gm, '');
        }

        // Determine whether the next list item belongs here.
        // Backpedal if it does not belong in this list.
        if (this.options.smartLists && i !== l - 1) {
          b = block.bullet.exec(cap[i + 1])[0];
          if (bull !== b && !(bull.length > 1 && b.length > 1)) {
            src = cap.slice(i + 1).join('\n') + src;
            i = l - 1;
          }
        }

        // Determine whether item is loose or not.
        // Use: /(^|\n)(?! )[^\n]+\n\n(?!\s*$)/
        // for discount behavior.
        loose = next || /\n\n(?!\s*$)/.test(item);
        if (i !== l - 1) {
          next = item.charAt(item.length - 1) === '\n';
          if (!loose) loose = next;
        }

        this.tokens.push({
          type: loose
            ? 'loose_item_start'
            : 'list_item_start'
        });

        // Recurse.
        this.token(item, false);

        this.tokens.push({
          type: 'list_item_end'
        });
      }

      this.tokens.push({
        type: 'list_end'
      });

      continue;
    }

    // html
    if (cap = this.rules.html.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: this.options.sanitize
          ? 'paragraph'
          : 'html',
        pre: !this.options.sanitizer
          && (cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style'),
        text: cap[0]
      });
      continue;
    }

    // def
    if (top && (cap = this.rules.def.exec(src))) {
      src = src.substring(cap[0].length);
      if (cap[3]) cap[3] = cap[3].substring(1, cap[3].length - 1);
      tag = cap[1].toLowerCase();
      if (!this.tokens.links[tag]) {
        this.tokens.links[tag] = {
          href: cap[2],
          title: cap[3]
        };
      }
      continue;
    }

    // table (gfm)
    if (top && (cap = this.rules.table.exec(src))) {
      src = src.substring(cap[0].length);

      item = {
        type: 'table',
        header: cap[1].replace(/^ *| *\| *$/g, '').split(/ *\| */),
        align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
        cells: cap[3].replace(/(?: *\| *)?\n$/, '').split('\n')
      };

      for (i = 0; i < item.align.length; i++) {
        if (/^ *-+: *$/.test(item.align[i])) {
          item.align[i] = 'right';
        } else if (/^ *:-+: *$/.test(item.align[i])) {
          item.align[i] = 'center';
        } else if (/^ *:-+ *$/.test(item.align[i])) {
          item.align[i] = 'left';
        } else {
          item.align[i] = null;
        }
      }

      for (i = 0; i < item.cells.length; i++) {
        item.cells[i] = item.cells[i]
          .replace(/^ *\| *| *\| *$/g, '')
          .split(/ *\| */);
      }

      this.tokens.push(item);

      continue;
    }

    // lheading
    if (cap = this.rules.lheading.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'heading',
        depth: cap[2] === '=' ? 1 : 2,
        text: cap[1]
      });
      continue;
    }

    // top-level paragraph
    if (top && (cap = this.rules.paragraph.exec(src))) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'paragraph',
        text: cap[1].charAt(cap[1].length - 1) === '\n'
          ? cap[1].slice(0, -1)
          : cap[1]
      });
      continue;
    }

    // text
    if (cap = this.rules.text.exec(src)) {
      // Top-level should never reach here.
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'text',
        text: cap[0]
      });
      continue;
    }

    if (src) {
      throw new Error('Infinite loop on byte: ' + src.charCodeAt(0));
    }
  }

  return this.tokens;
};

/**
 * Inline-Level Grammar
 */

var inline = {
  escape: /^\\([\\`*{}\[\]()#+\-.!_>])/,
  autolink: /^<(scheme:[^\s\x00-\x1f<>]*|email)>/,
  url: noop,
  tag: /^<!--[\s\S]*?-->|^<\/?[a-zA-Z0-9\-]+(?:"[^"]*"|'[^']*'|\s[^<'">\/\s]*)*?\/?>/,
  link: /^!?\[(inside)\]\(href\)/,
  reflink: /^!?\[(inside)\]\s*\[([^\]]*)\]/,
  nolink: /^!?\[((?:\[[^\[\]]*\]|\\[\[\]]|[^\[\]])*)\]/,
  strong: /^__([\s\S]+?)__(?!_)|^\*\*([\s\S]+?)\*\*(?!\*)/,
  em: /^_([^\s_](?:[^_]|__)+?[^\s_])_\b|^\*((?:\*\*|[^*])+?)\*(?!\*)/,
  code: /^(`+)\s*([\s\S]*?[^`]?)\s*\1(?!`)/,
  br: /^ {2,}\n(?!\s*$)/,
  del: noop,
  text: /^[\s\S]+?(?=[\\<!\[`*]|\b_| {2,}\n|$)/
};

inline._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/;
inline._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/;

inline.autolink = edit(inline.autolink)
  .replace('scheme', inline._scheme)
  .replace('email', inline._email)
  .getRegex();

inline._inside = /(?:\[[^\[\]]*\]|\\[\[\]]|[^\[\]]|\](?=[^\[]*\]))*/;
inline._href = /\s*<?([\s\S]*?)>?(?:\s+['"]([\s\S]*?)['"])?\s*/;

inline.link = edit(inline.link)
  .replace('inside', inline._inside)
  .replace('href', inline._href)
  .getRegex();

inline.reflink = edit(inline.reflink)
  .replace('inside', inline._inside)
  .getRegex();

/**
 * Normal Inline Grammar
 */

inline.normal = merge({}, inline);

/**
 * Pedantic Inline Grammar
 */

inline.pedantic = merge({}, inline.normal, {
  strong: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
  em: /^_(?=\S)([\s\S]*?\S)_(?!_)|^\*(?=\S)([\s\S]*?\S)\*(?!\*)/
});

/**
 * GFM Inline Grammar
 */

inline.gfm = merge({}, inline.normal, {
  escape: edit(inline.escape).replace('])', '~|])').getRegex(),
  url: edit(/^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/)
    .replace('email', inline._email)
    .getRegex(),
  _backpedal: /(?:[^?!.,:;*_~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_~)]+(?!$))+/,
  del: /^~~(?=\S)([\s\S]*?\S)~~/,
  text: edit(inline.text)
    .replace(']|', '~]|')
    .replace('|', '|https?://|ftp://|www\\.|[a-zA-Z0-9.!#$%&\'*+/=?^_`{\\|}~-]+@|')
    .getRegex()
});

/**
 * GFM + Line Breaks Inline Grammar
 */

inline.breaks = merge({}, inline.gfm, {
  br: edit(inline.br).replace('{2,}', '*').getRegex(),
  text: edit(inline.gfm.text).replace('{2,}', '*').getRegex()
});

/**
 * Inline Lexer & Compiler
 */

function InlineLexer(links, options) {
  this.options = options || marked.defaults;
  this.links = links;
  this.rules = inline.normal;
  this.renderer = this.options.renderer || new Renderer();
  this.renderer.options = this.options;

  if (!this.links) {
    throw new Error('Tokens array requires a `links` property.');
  }

  if (this.options.gfm) {
    if (this.options.breaks) {
      this.rules = inline.breaks;
    } else {
      this.rules = inline.gfm;
    }
  } else if (this.options.pedantic) {
    this.rules = inline.pedantic;
  }
}

/**
 * Expose Inline Rules
 */

InlineLexer.rules = inline;

/**
 * Static Lexing/Compiling Method
 */

InlineLexer.output = function(src, links, options) {
  var inline = new InlineLexer(links, options);
  return inline.output(src);
};

/**
 * Lexing/Compiling
 */

InlineLexer.prototype.output = function(src) {
  var out = '',
      link,
      text,
      href,
      cap;

  while (src) {
    // escape
    if (cap = this.rules.escape.exec(src)) {
      src = src.substring(cap[0].length);
      out += cap[1];
      continue;
    }

    // autolink
    if (cap = this.rules.autolink.exec(src)) {
      src = src.substring(cap[0].length);
      if (cap[2] === '@') {
        text = escape$$1(this.mangle(cap[1]));
        href = 'mailto:' + text;
      } else {
        text = escape$$1(cap[1]);
        href = text;
      }
      out += this.renderer.link(href, null, text);
      continue;
    }

    // url (gfm)
    if (!this.inLink && (cap = this.rules.url.exec(src))) {
      cap[0] = this.rules._backpedal.exec(cap[0])[0];
      src = src.substring(cap[0].length);
      if (cap[2] === '@') {
        text = escape$$1(cap[0]);
        href = 'mailto:' + text;
      } else {
        text = escape$$1(cap[0]);
        if (cap[1] === 'www.') {
          href = 'http://' + text;
        } else {
          href = text;
        }
      }
      out += this.renderer.link(href, null, text);
      continue;
    }

    // tag
    if (cap = this.rules.tag.exec(src)) {
      if (!this.inLink && /^<a /i.test(cap[0])) {
        this.inLink = true;
      } else if (this.inLink && /^<\/a>/i.test(cap[0])) {
        this.inLink = false;
      }
      src = src.substring(cap[0].length);
      out += this.options.sanitize
        ? this.options.sanitizer
          ? this.options.sanitizer(cap[0])
          : escape$$1(cap[0])
        : cap[0];
      continue;
    }

    // link
    if (cap = this.rules.link.exec(src)) {
      src = src.substring(cap[0].length);
      this.inLink = true;
      out += this.outputLink(cap, {
        href: cap[2],
        title: cap[3]
      });
      this.inLink = false;
      continue;
    }

    // reflink, nolink
    if ((cap = this.rules.reflink.exec(src))
        || (cap = this.rules.nolink.exec(src))) {
      src = src.substring(cap[0].length);
      link = (cap[2] || cap[1]).replace(/\s+/g, ' ');
      link = this.links[link.toLowerCase()];
      if (!link || !link.href) {
        out += cap[0].charAt(0);
        src = cap[0].substring(1) + src;
        continue;
      }
      this.inLink = true;
      out += this.outputLink(cap, link);
      this.inLink = false;
      continue;
    }

    // strong
    if (cap = this.rules.strong.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.strong(this.output(cap[2] || cap[1]));
      continue;
    }

    // em
    if (cap = this.rules.em.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.em(this.output(cap[2] || cap[1]));
      continue;
    }

    // code
    if (cap = this.rules.code.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.codespan(escape$$1(cap[2].trim(), true));
      continue;
    }

    // br
    if (cap = this.rules.br.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.br();
      continue;
    }

    // del (gfm)
    if (cap = this.rules.del.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.del(this.output(cap[1]));
      continue;
    }

    // text
    if (cap = this.rules.text.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.text(escape$$1(this.smartypants(cap[0])));
      continue;
    }

    if (src) {
      throw new Error('Infinite loop on byte: ' + src.charCodeAt(0));
    }
  }

  return out;
};

/**
 * Compile Link
 */

InlineLexer.prototype.outputLink = function(cap, link) {
  var href = escape$$1(link.href),
      title = link.title ? escape$$1(link.title) : null;

  return cap[0].charAt(0) !== '!'
    ? this.renderer.link(href, title, this.output(cap[1]))
    : this.renderer.image(href, title, escape$$1(cap[1]));
};

/**
 * Smartypants Transformations
 */

InlineLexer.prototype.smartypants = function(text) {
  if (!this.options.smartypants) return text;
  return text
    // em-dashes
    .replace(/---/g, '\u2014')
    // en-dashes
    .replace(/--/g, '\u2013')
    // opening singles
    .replace(/(^|[-\u2014/(\[{"\s])'/g, '$1\u2018')
    // closing singles & apostrophes
    .replace(/'/g, '\u2019')
    // opening doubles
    .replace(/(^|[-\u2014/(\[{\u2018\s])"/g, '$1\u201c')
    // closing doubles
    .replace(/"/g, '\u201d')
    // ellipses
    .replace(/\.{3}/g, '\u2026');
};

/**
 * Mangle Links
 */

InlineLexer.prototype.mangle = function(text) {
  if (!this.options.mangle) return text;
  var out = '',
      l = text.length,
      i = 0,
      ch;

  for (; i < l; i++) {
    ch = text.charCodeAt(i);
    if (Math.random() > 0.5) {
      ch = 'x' + ch.toString(16);
    }
    out += '&#' + ch + ';';
  }

  return out;
};

/**
 * Renderer
 */

function Renderer(options) {
  this.options = options || {};
}

Renderer.prototype.code = function(code, lang, escaped) {
  if (this.options.highlight) {
    var out = this.options.highlight(code, lang);
    if (out != null && out !== code) {
      escaped = true;
      code = out;
    }
  }

  if (!lang) {
    return '<pre><code>'
      + (escaped ? code : escape$$1(code, true))
      + '\n</code></pre>';
  }

  return '<pre><code class="'
    + this.options.langPrefix
    + escape$$1(lang, true)
    + '">'
    + (escaped ? code : escape$$1(code, true))
    + '\n</code></pre>\n';
};

Renderer.prototype.blockquote = function(quote) {
  return '<blockquote>\n' + quote + '</blockquote>\n';
};

Renderer.prototype.html = function(html) {
  return html;
};

Renderer.prototype.heading = function(text, level, raw) {
  return '<h'
    + level
    + ' id="'
    + this.options.headerPrefix
    + raw.toLowerCase().replace(/[^\w]+/g, '-')
    + '">'
    + text
    + '</h'
    + level
    + '>\n';
};

Renderer.prototype.hr = function() {
  return this.options.xhtml ? '<hr/>\n' : '<hr>\n';
};

Renderer.prototype.list = function(body, ordered, start) {
  var type = ordered ? 'ol' : 'ul',
      startatt = (ordered && start !== 1) ? (' start="' + start + '"') : '';
  return '<' + type + startatt + '>\n' + body + '</' + type + '>\n';
};

Renderer.prototype.listitem = function(text) {
  return '<li>' + text + '</li>\n';
};

Renderer.prototype.paragraph = function(text) {
  return '<p>' + text + '</p>\n';
};

Renderer.prototype.table = function(header, body) {
  return '<table>\n'
    + '<thead>\n'
    + header
    + '</thead>\n'
    + '<tbody>\n'
    + body
    + '</tbody>\n'
    + '</table>\n';
};

Renderer.prototype.tablerow = function(content) {
  return '<tr>\n' + content + '</tr>\n';
};

Renderer.prototype.tablecell = function(content, flags) {
  var type = flags.header ? 'th' : 'td';
  var tag = flags.align
    ? '<' + type + ' style="text-align:' + flags.align + '">'
    : '<' + type + '>';
  return tag + content + '</' + type + '>\n';
};

// span level renderer
Renderer.prototype.strong = function(text) {
  return '<strong>' + text + '</strong>';
};

Renderer.prototype.em = function(text) {
  return '<em>' + text + '</em>';
};

Renderer.prototype.codespan = function(text) {
  return '<code>' + text + '</code>';
};

Renderer.prototype.br = function() {
  return this.options.xhtml ? '<br/>' : '<br>';
};

Renderer.prototype.del = function(text) {
  return '<del>' + text + '</del>';
};

Renderer.prototype.link = function(href, title, text) {
  if (this.options.sanitize) {
    try {
      var prot = decodeURIComponent(unescape(href))
        .replace(/[^\w:]/g, '')
        .toLowerCase();
    } catch (e) {
      return text;
    }
    if (prot.indexOf('javascript:') === 0 || prot.indexOf('vbscript:') === 0 || prot.indexOf('data:') === 0) {
      return text;
    }
  }
  if (this.options.baseUrl && !originIndependentUrl.test(href)) {
    href = resolveUrl(this.options.baseUrl, href);
  }
  var out = '<a href="' + href + '"';
  if (title) {
    out += ' title="' + title + '"';
  }
  out += '>' + text + '</a>';
  return out;
};

Renderer.prototype.image = function(href, title, text) {
  if (this.options.baseUrl && !originIndependentUrl.test(href)) {
    href = resolveUrl(this.options.baseUrl, href);
  }
  var out = '<img src="' + href + '" alt="' + text + '"';
  if (title) {
    out += ' title="' + title + '"';
  }
  out += this.options.xhtml ? '/>' : '>';
  return out;
};

Renderer.prototype.text = function(text) {
  return text;
};

/**
 * TextRenderer
 * returns only the textual part of the token
 */

function TextRenderer() {}

// no need for block level renderers

TextRenderer.prototype.strong =
TextRenderer.prototype.em =
TextRenderer.prototype.codespan =
TextRenderer.prototype.del =
TextRenderer.prototype.text = function (text) {
  return text;
};

TextRenderer.prototype.link =
TextRenderer.prototype.image = function(href, title, text) {
  return '' + text;
};

TextRenderer.prototype.br = function() {
  return '';
};

/**
 * Parsing & Compiling
 */

function Parser(options) {
  this.tokens = [];
  this.token = null;
  this.options = options || marked.defaults;
  this.options.renderer = this.options.renderer || new Renderer();
  this.renderer = this.options.renderer;
  this.renderer.options = this.options;
}

/**
 * Static Parse Method
 */

Parser.parse = function(src, options) {
  var parser = new Parser(options);
  return parser.parse(src);
};

/**
 * Parse Loop
 */

Parser.prototype.parse = function(src) {
  this.inline = new InlineLexer(src.links, this.options);
  // use an InlineLexer with a TextRenderer to extract pure text
  this.inlineText = new InlineLexer(
    src.links,
    merge({}, this.options, {renderer: new TextRenderer()})
  );
  this.tokens = src.reverse();

  var out = '';
  while (this.next()) {
    out += this.tok();
  }

  return out;
};

/**
 * Next Token
 */

Parser.prototype.next = function() {
  return this.token = this.tokens.pop();
};

/**
 * Preview Next Token
 */

Parser.prototype.peek = function() {
  return this.tokens[this.tokens.length - 1] || 0;
};

/**
 * Parse Text Tokens
 */

Parser.prototype.parseText = function() {
  var body = this.token.text;

  while (this.peek().type === 'text') {
    body += '\n' + this.next().text;
  }

  return this.inline.output(body);
};

/**
 * Parse Current Token
 */

Parser.prototype.tok = function() {
  switch (this.token.type) {
    case 'space': {
      return '';
    }
    case 'hr': {
      return this.renderer.hr();
    }
    case 'heading': {
      return this.renderer.heading(
        this.inline.output(this.token.text),
        this.token.depth,
        unescape(this.inlineText.output(this.token.text)));
    }
    case 'code': {
      return this.renderer.code(this.token.text,
        this.token.lang,
        this.token.escaped);
    }
    case 'table': {
      var header = '',
          body = '',
          i,
          row,
          cell,
          j;

      // header
      cell = '';
      for (i = 0; i < this.token.header.length; i++) {
        cell += this.renderer.tablecell(
          this.inline.output(this.token.header[i]),
          { header: true, align: this.token.align[i] }
        );
      }
      header += this.renderer.tablerow(cell);

      for (i = 0; i < this.token.cells.length; i++) {
        row = this.token.cells[i];

        cell = '';
        for (j = 0; j < row.length; j++) {
          cell += this.renderer.tablecell(
            this.inline.output(row[j]),
            { header: false, align: this.token.align[j] }
          );
        }

        body += this.renderer.tablerow(cell);
      }
      return this.renderer.table(header, body);
    }
    case 'blockquote_start': {
      body = '';

      while (this.next().type !== 'blockquote_end') {
        body += this.tok();
      }

      return this.renderer.blockquote(body);
    }
    case 'list_start': {
      body = '';
      var ordered = this.token.ordered,
          start = this.token.start;

      while (this.next().type !== 'list_end') {
        body += this.tok();
      }

      return this.renderer.list(body, ordered, start);
    }
    case 'list_item_start': {
      body = '';

      while (this.next().type !== 'list_item_end') {
        body += this.token.type === 'text'
          ? this.parseText()
          : this.tok();
      }

      return this.renderer.listitem(body);
    }
    case 'loose_item_start': {
      body = '';

      while (this.next().type !== 'list_item_end') {
        body += this.tok();
      }

      return this.renderer.listitem(body);
    }
    case 'html': {
      var html = !this.token.pre && !this.options.pedantic
        ? this.inline.output(this.token.text)
        : this.token.text;
      return this.renderer.html(html);
    }
    case 'paragraph': {
      return this.renderer.paragraph(this.inline.output(this.token.text));
    }
    case 'text': {
      return this.renderer.paragraph(this.parseText());
    }
  }
};

/**
 * Helpers
 */

function escape$$1(html, encode) {
  return html
    .replace(!encode ? /&(?!#?\w+;)/g : /&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#39;');
}

function unescape(html) {
  // explicitly match decimal, hex, and named HTML entities
  return html.replace(/&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig, function(_, n) {
    n = n.toLowerCase();
    if (n === 'colon') return ':';
    if (n.charAt(0) === '#') {
      return n.charAt(1) === 'x'
        ? String.fromCharCode(parseInt(n.substring(2), 16))
        : String.fromCharCode(+n.substring(1));
    }
    return '';
  });
}

function edit(regex, opt) {
  regex = regex.source;
  opt = opt || '';
  return {
    replace: function(name, val) {
      val = val.source || val;
      val = val.replace(/(^|[^\[])\^/g, '$1');
      regex = regex.replace(name, val);
      return this;
    },
    getRegex: function() {
      return new RegExp(regex, opt);
    }
  };
}

function resolveUrl(base, href) {
  if (!baseUrls[' ' + base]) {
    // we can ignore everything in base after the last slash of its path component,
    // but we might need to add _that_
    // https://tools.ietf.org/html/rfc3986#section-3
    if (/^[^:]+:\/*[^/]*$/.test(base)) {
      baseUrls[' ' + base] = base + '/';
    } else {
      baseUrls[' ' + base] = base.replace(/[^/]*$/, '');
    }
  }
  base = baseUrls[' ' + base];

  if (href.slice(0, 2) === '//') {
    return base.replace(/:[\s\S]*/, ':') + href;
  } else if (href.charAt(0) === '/') {
    return base.replace(/(:\/*[^/]*)[\s\S]*/, '$1') + href;
  } else {
    return base + href;
  }
}
var baseUrls = {};
var originIndependentUrl = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;

function noop() {}
noop.exec = noop;

function merge(obj) {
  var i = 1,
      target,
      key;

  for (; i < arguments.length; i++) {
    target = arguments[i];
    for (key in target) {
      if (Object.prototype.hasOwnProperty.call(target, key)) {
        obj[key] = target[key];
      }
    }
  }

  return obj;
}

/**
 * Marked
 */

function marked(src, opt, callback) {
  // throw error in case of non string input
  if (typeof src === 'undefined' || src === null) {
    throw new Error('marked(): input parameter is undefined or null');
  }
  if (typeof src !== 'string') {
    throw new Error('marked(): input parameter is of type '
      + Object.prototype.toString.call(src) + ', string expected');
  }

  if (callback || typeof opt === 'function') {
    if (!callback) {
      callback = opt;
      opt = null;
    }

    opt = merge({}, marked.defaults, opt || {});

    var highlight = opt.highlight,
        tokens,
        pending,
        i = 0;

    try {
      tokens = Lexer.lex(src, opt);
    } catch (e) {
      return callback(e);
    }

    pending = tokens.length;

    var done = function(err) {
      if (err) {
        opt.highlight = highlight;
        return callback(err);
      }

      var out;

      try {
        out = Parser.parse(tokens, opt);
      } catch (e) {
        err = e;
      }

      opt.highlight = highlight;

      return err
        ? callback(err)
        : callback(null, out);
    };

    if (!highlight || highlight.length < 3) {
      return done();
    }

    delete opt.highlight;

    if (!pending) return done();

    for (; i < tokens.length; i++) {
      (function(token) {
        if (token.type !== 'code') {
          return --pending || done();
        }
        return highlight(token.text, token.lang, function(err, code) {
          if (err) return done(err);
          if (code == null || code === token.text) {
            return --pending || done();
          }
          token.text = code;
          token.escaped = true;
          --pending || done();
        });
      })(tokens[i]);
    }

    return;
  }
  try {
    if (opt) opt = merge({}, marked.defaults, opt);
    return Parser.parse(Lexer.lex(src, opt), opt);
  } catch (e) {
    e.message += '\nPlease report this to https://github.com/markedjs/marked.';
    if ((opt || marked.defaults).silent) {
      return '<p>An error occurred:</p><pre>'
        + escape$$1(e.message + '', true)
        + '</pre>';
    }
    throw e;
  }
}

/**
 * Options
 */

marked.options =
marked.setOptions = function(opt) {
  merge(marked.defaults, opt);
  return marked;
};

marked.defaults = {
  gfm: true,
  tables: true,
  breaks: false,
  pedantic: false,
  sanitize: false,
  sanitizer: null,
  mangle: true,
  smartLists: false,
  silent: false,
  highlight: null,
  langPrefix: 'lang-',
  smartypants: false,
  headerPrefix: '',
  renderer: new Renderer(),
  xhtml: false,
  baseUrl: null
};

/**
 * Expose
 */

marked.Parser = Parser;
marked.parser = Parser.parse;

marked.Renderer = Renderer;
marked.TextRenderer = TextRenderer;

marked.Lexer = Lexer;
marked.lexer = Lexer.lex;

marked.InlineLexer = InlineLexer;
marked.inlineLexer = InlineLexer.output;

marked.parse = marked;

__marked_exports = marked;

}).call(undefined);

// ESM-comment-begin
// define([], function() {
//   return {
//     marked: __marked_exports
//   };
// });
// ESM-comment-end

// ESM-uncomment-begin
var marked = __marked_exports;
var Parser = __marked_exports.Parser;
var parser = __marked_exports.parser;
var Renderer = __marked_exports.Renderer;
var TextRenderer = __marked_exports.TextRenderer;
var Lexer = __marked_exports.Lexer;
var lexer = __marked_exports.lexer;
var InlineLexer = __marked_exports.InlineLexer;
var inlineLexer = __marked_exports.inlineLexer;
var parse = __marked_exports.parse;
// ESM-uncomment-end

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
function createElement(options) {
    var tagName = options.inline ? 'span' : 'div';
    var element = document.createElement(tagName);
    if (options.className) {
        element.className = options.className;
    }
    return element;
}
function renderText(text, options) {
    if (options === void 0) { options = {}; }
    var element = createElement(options);
    element.textContent = text;
    return element;
}
function renderFormattedText(formattedText, options) {
    if (options === void 0) { options = {}; }
    var element = createElement(options);
    _renderFormattedText(element, parseFormattedText(formattedText), options.actionHandler);
    return element;
}
/**
 * Create html nodes for the given content element.
 */
function renderMarkdown(markdown, options) {
    if (options === void 0) { options = {}; }
    var element = createElement(options);
    // signal to code-block render that the
    // element has been created
    var signalInnerHTML;
    var withInnerHTML = new Promise(function (c) { return signalInnerHTML = c; });
    var renderer = new marked.Renderer();
    renderer.image = function (href, title, text) {
        var dimensions = [];
        if (href) {
            var splitted = href.split('|').map(function (s) { return s.trim(); });
            href = splitted[0];
            var parameters = splitted[1];
            if (parameters) {
                var heightFromParams = /height=(\d+)/.exec(parameters);
                var widthFromParams = /width=(\d+)/.exec(parameters);
                var height = (heightFromParams && heightFromParams[1]);
                var width = (widthFromParams && widthFromParams[1]);
                var widthIsFinite = isFinite(parseInt(width));
                var heightIsFinite = isFinite(parseInt(height));
                if (widthIsFinite) {
                    dimensions.push("width=\"" + width + "\"");
                }
                if (heightIsFinite) {
                    dimensions.push("height=\"" + height + "\"");
                }
            }
        }
        var attributes = [];
        if (href) {
            attributes.push("src=\"" + href + "\"");
        }
        if (text) {
            attributes.push("alt=\"" + text + "\"");
        }
        if (title) {
            attributes.push("title=\"" + title + "\"");
        }
        if (dimensions.length) {
            attributes = attributes.concat(dimensions);
        }
        return '<img ' + attributes.join(' ') + '>';
    };
    renderer.link = function (href, title, text) {
        // Remove markdown escapes. Workaround for https://github.com/chjj/marked/issues/829
        if (href === text) { // raw link case
            text = removeMarkdownEscapes(text);
        }
        title = removeMarkdownEscapes(title);
        href = removeMarkdownEscapes(href);
        if (!href
            || href.match(/^data:|javascript:/i)
            || (href.match(/^command:/i) && !markdown.isTrusted)) {
            // drop the link
            return text;
        }
        else {
            return "<a href=\"#\" data-href=\"" + href + "\" title=\"" + (title || href) + "\">" + text + "</a>";
        }
    };
    renderer.paragraph = function (text) {
        return "<p>" + text + "</p>";
    };
    if (options.codeBlockRenderer) {
        renderer.code = function (code, lang) {
            var value = options.codeBlockRenderer(lang, code);
            // when code-block rendering is async we return sync
            // but update the node with the real result later.
            var id = defaultGenerator.nextId();
            var promise = Promise.all([value, withInnerHTML]).then(function (values) {
                var strValue = values[0];
                var span = element.querySelector("div[data-code=\"" + id + "\"]");
                if (span) {
                    span.innerHTML = strValue;
                }
            }).catch(function (err) {
                // ignore
            });
            if (options.codeBlockRenderCallback) {
                promise.then(options.codeBlockRenderCallback);
            }
            return "<div class=\"code\" data-code=\"" + id + "\">" + escape(code) + "</div>";
        };
    }
    if (options.actionHandler) {
        options.actionHandler.disposeables.push(addStandardDisposableListener(element, 'click', function (event) {
            var target = event.target;
            if (target.tagName !== 'A') {
                target = target.parentElement;
                if (!target || target.tagName !== 'A') {
                    return;
                }
            }
            var href = target.dataset['href'];
            if (href) {
                options.actionHandler.callback(href, event);
            }
        }));
    }
    var markedOptions = {
        sanitize: true,
        renderer: renderer
    };
    element.innerHTML = marked(markdown.value, markedOptions);
    signalInnerHTML();
    return element;
}
// --- formatted string parsing
var StringStream = /** @class */ (function () {
    function StringStream(source) {
        this.source = source;
        this.index = 0;
    }
    StringStream.prototype.eos = function () {
        return this.index >= this.source.length;
    };
    StringStream.prototype.next = function () {
        var next = this.peek();
        this.advance();
        return next;
    };
    StringStream.prototype.peek = function () {
        return this.source[this.index];
    };
    StringStream.prototype.advance = function () {
        this.index++;
    };
    return StringStream;
}());
function _renderFormattedText(element, treeNode, actionHandler) {
    var child;
    if (treeNode.type === 2 /* Text */) {
        child = document.createTextNode(treeNode.content);
    }
    else if (treeNode.type === 3 /* Bold */) {
        child = document.createElement('b');
    }
    else if (treeNode.type === 4 /* Italics */) {
        child = document.createElement('i');
    }
    else if (treeNode.type === 5 /* Action */ && actionHandler) {
        var a = document.createElement('a');
        a.href = '#';
        actionHandler.disposeables.push(addStandardDisposableListener(a, 'click', function (event) {
            actionHandler.callback(String(treeNode.index), event);
        }));
        child = a;
    }
    else if (treeNode.type === 7 /* NewLine */) {
        child = document.createElement('br');
    }
    else if (treeNode.type === 1 /* Root */) {
        child = element;
    }
    if (element !== child) {
        element.appendChild(child);
    }
    if (Array.isArray(treeNode.children)) {
        treeNode.children.forEach(function (nodeChild) {
            _renderFormattedText(child, nodeChild, actionHandler);
        });
    }
}
function parseFormattedText(content) {
    var root = {
        type: 1 /* Root */,
        children: []
    };
    var actionItemIndex = 0;
    var current = root;
    var stack = [];
    var stream = new StringStream(content);
    while (!stream.eos()) {
        var next = stream.next();
        var isEscapedFormatType = (next === '\\' && formatTagType(stream.peek()) !== 0 /* Invalid */);
        if (isEscapedFormatType) {
            next = stream.next(); // unread the backslash if it escapes a format tag type
        }
        if (!isEscapedFormatType && isFormatTag(next) && next === stream.peek()) {
            stream.advance();
            if (current.type === 2 /* Text */) {
                current = stack.pop();
            }
            var type = formatTagType(next);
            if (current.type === type || (current.type === 5 /* Action */ && type === 6 /* ActionClose */)) {
                current = stack.pop();
            }
            else {
                var newCurrent = {
                    type: type,
                    children: []
                };
                if (type === 5 /* Action */) {
                    newCurrent.index = actionItemIndex;
                    actionItemIndex++;
                }
                current.children.push(newCurrent);
                stack.push(current);
                current = newCurrent;
            }
        }
        else if (next === '\n') {
            if (current.type === 2 /* Text */) {
                current = stack.pop();
            }
            current.children.push({
                type: 7 /* NewLine */
            });
        }
        else {
            if (current.type !== 2 /* Text */) {
                var textCurrent = {
                    type: 2 /* Text */,
                    content: next
                };
                current.children.push(textCurrent);
                stack.push(current);
                current = textCurrent;
            }
            else {
                current.content += next;
            }
        }
    }
    if (current.type === 2 /* Text */) {
        current = stack.pop();
    }
    return root;
}
function isFormatTag(char) {
    return formatTagType(char) !== 0 /* Invalid */;
}
function formatTagType(char) {
    switch (char) {
        case '*':
            return 3 /* Bold */;
        case '_':
            return 4 /* Italics */;
        case '[':
            return 5 /* Action */;
        case ']':
            return 6 /* ActionClose */;
        default:
            return 0 /* Invalid */;
    }
}

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$7 = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var $$2 = $;
var MessageType;
(function (MessageType) {
    MessageType[MessageType["INFO"] = 1] = "INFO";
    MessageType[MessageType["WARNING"] = 2] = "WARNING";
    MessageType[MessageType["ERROR"] = 3] = "ERROR";
})(MessageType || (MessageType = {}));
var defaultOpts = {
    inputBackground: Color.fromHex('#3C3C3C'),
    inputForeground: Color.fromHex('#CCCCCC'),
    inputValidationInfoBorder: Color.fromHex('#55AAFF'),
    inputValidationInfoBackground: Color.fromHex('#063B49'),
    inputValidationWarningBorder: Color.fromHex('#B89500'),
    inputValidationWarningBackground: Color.fromHex('#352A05'),
    inputValidationErrorBorder: Color.fromHex('#BE1100'),
    inputValidationErrorBackground: Color.fromHex('#5A1D1D')
};
var InputBox = /** @class */ (function (_super) {
    __extends$7(InputBox, _super);
    function InputBox(container, contextViewProvider, options) {
        var _this = _super.call(this) || this;
        _this.state = 'idle';
        _this._onDidChange = _this._register(new Emitter());
        _this.onDidChange = _this._onDidChange.event;
        _this._onDidHeightChange = _this._register(new Emitter());
        _this.onDidHeightChange = _this._onDidHeightChange.event;
        _this.contextViewProvider = contextViewProvider;
        _this.options = options || Object.create(null);
        mixin(_this.options, defaultOpts, false);
        _this.message = null;
        _this.cachedHeight = null;
        _this.placeholder = _this.options.placeholder || '';
        _this.ariaLabel = _this.options.ariaLabel || '';
        _this.inputBackground = _this.options.inputBackground;
        _this.inputForeground = _this.options.inputForeground;
        _this.inputBorder = _this.options.inputBorder;
        _this.inputValidationInfoBorder = _this.options.inputValidationInfoBorder;
        _this.inputValidationInfoBackground = _this.options.inputValidationInfoBackground;
        _this.inputValidationWarningBorder = _this.options.inputValidationWarningBorder;
        _this.inputValidationWarningBackground = _this.options.inputValidationWarningBackground;
        _this.inputValidationErrorBorder = _this.options.inputValidationErrorBorder;
        _this.inputValidationErrorBackground = _this.options.inputValidationErrorBackground;
        if (_this.options.validationOptions) {
            _this.validation = _this.options.validationOptions.validation;
        }
        _this.element = append(container, $$2('.monaco-inputbox.idle'));
        var tagName = _this.options.flexibleHeight ? 'textarea' : 'input';
        var wrapper = append(_this.element, $$2('.wrapper'));
        _this.input = append(wrapper, $$2(tagName + '.input'));
        _this.input.setAttribute('autocorrect', 'off');
        _this.input.setAttribute('autocapitalize', 'off');
        _this.input.setAttribute('spellcheck', 'false');
        _this.onfocus(_this.input, function () { return addClass(_this.element, 'synthetic-focus'); });
        _this.onblur(_this.input, function () { return removeClass(_this.element, 'synthetic-focus'); });
        if (_this.options.flexibleHeight) {
            _this.mirror = append(wrapper, $$2('div.mirror'));
        }
        else {
            _this.input.type = _this.options.type || 'text';
            _this.input.setAttribute('wrap', 'off');
        }
        if (_this.ariaLabel) {
            _this.input.setAttribute('aria-label', _this.ariaLabel);
        }
        if (_this.placeholder) {
            _this.setPlaceHolder(_this.placeholder);
        }
        _this.oninput(_this.input, function () { return _this.onValueChange(); });
        _this.onblur(_this.input, function () { return _this.onBlur(); });
        _this.onfocus(_this.input, function () { return _this.onFocus(); });
        // Add placeholder shim for IE because IE decides to hide the placeholder on focus (we dont want that!)
        if (_this.placeholder && isIE) {
            _this.onclick(_this.input, function (e) {
                EventHelper.stop(e, true);
                _this.input.focus();
            });
        }
        setTimeout(function () {
            if (!_this.input) {
                return;
            }
            _this.updateMirror();
        }, 0);
        // Support actions
        if (_this.options.actions) {
            _this.actionbar = _this._register(new ActionBar(_this.element));
            _this.actionbar.push(_this.options.actions, { icon: true, label: false });
        }
        _this.applyStyles();
        return _this;
    }
    InputBox.prototype.onBlur = function () {
        this._hideMessage();
    };
    InputBox.prototype.onFocus = function () {
        this._showMessage();
    };
    InputBox.prototype.setPlaceHolder = function (placeHolder) {
        if (this.input) {
            this.input.setAttribute('placeholder', placeHolder);
            this.input.title = placeHolder;
        }
    };
    InputBox.prototype.setAriaLabel = function (label) {
        this.ariaLabel = label;
        if (this.input) {
            if (label) {
                this.input.setAttribute('aria-label', this.ariaLabel);
            }
            else {
                this.input.removeAttribute('aria-label');
            }
        }
    };
    Object.defineProperty(InputBox.prototype, "inputElement", {
        get: function () {
            return this.input;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(InputBox.prototype, "value", {
        get: function () {
            return this.input.value;
        },
        set: function (newValue) {
            if (this.input.value !== newValue) {
                this.input.value = newValue;
                this.onValueChange();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(InputBox.prototype, "height", {
        get: function () {
            return this.cachedHeight === null ? getTotalHeight(this.element) : this.cachedHeight;
        },
        enumerable: true,
        configurable: true
    });
    InputBox.prototype.focus = function () {
        this.input.focus();
    };
    InputBox.prototype.blur = function () {
        this.input.blur();
    };
    InputBox.prototype.hasFocus = function () {
        return document.activeElement === this.input;
    };
    InputBox.prototype.select = function (range$$1) {
        if (range$$1 === void 0) { range$$1 = null; }
        this.input.select();
        if (range$$1) {
            this.input.setSelectionRange(range$$1.start, range$$1.end);
        }
    };
    InputBox.prototype.enable = function () {
        this.input.removeAttribute('disabled');
    };
    InputBox.prototype.disable = function () {
        this.input.disabled = true;
        this._hideMessage();
    };
    InputBox.prototype.setEnabled = function (enabled) {
        if (enabled) {
            this.enable();
        }
        else {
            this.disable();
        }
    };
    Object.defineProperty(InputBox.prototype, "width", {
        get: function () {
            return getTotalWidth(this.input);
        },
        set: function (width) {
            this.input.style.width = width + 'px';
        },
        enumerable: true,
        configurable: true
    });
    InputBox.prototype.showMessage = function (message, force) {
        this.message = message;
        removeClass(this.element, 'idle');
        removeClass(this.element, 'info');
        removeClass(this.element, 'warning');
        removeClass(this.element, 'error');
        addClass(this.element, this.classForType(message.type));
        var styles = this.stylesForType(this.message.type);
        this.element.style.border = styles.border ? "1px solid " + styles.border : null;
        // ARIA Support
        var alertText;
        if (message.type === MessageType.ERROR) {
            alertText = localize('alertErrorMessage', "Error: {0}", message.content);
        }
        else if (message.type === MessageType.WARNING) {
            alertText = localize('alertWarningMessage', "Warning: {0}", message.content);
        }
        else {
            alertText = localize('alertInfoMessage', "Info: {0}", message.content);
        }
        alert(alertText);
        if (this.hasFocus() || force) {
            this._showMessage();
        }
    };
    InputBox.prototype.hideMessage = function () {
        this.message = null;
        removeClass(this.element, 'info');
        removeClass(this.element, 'warning');
        removeClass(this.element, 'error');
        addClass(this.element, 'idle');
        this._hideMessage();
        this.applyStyles();
    };
    InputBox.prototype.isInputValid = function () {
        return !!this.validation && !this.validation(this.value);
    };
    InputBox.prototype.validate = function () {
        var errorMsg = null;
        if (this.validation) {
            errorMsg = this.validation(this.value);
            if (errorMsg) {
                this.inputElement.setAttribute('aria-invalid', 'true');
                this.showMessage(errorMsg);
            }
            else if (this.inputElement.hasAttribute('aria-invalid')) {
                this.inputElement.removeAttribute('aria-invalid');
                this.hideMessage();
            }
        }
        return !errorMsg;
    };
    InputBox.prototype.stylesForType = function (type) {
        switch (type) {
            case MessageType.INFO: return { border: this.inputValidationInfoBorder, background: this.inputValidationInfoBackground };
            case MessageType.WARNING: return { border: this.inputValidationWarningBorder, background: this.inputValidationWarningBackground };
            default: return { border: this.inputValidationErrorBorder, background: this.inputValidationErrorBackground };
        }
    };
    InputBox.prototype.classForType = function (type) {
        switch (type) {
            case MessageType.INFO: return 'info';
            case MessageType.WARNING: return 'warning';
            default: return 'error';
        }
    };
    InputBox.prototype._showMessage = function () {
        var _this = this;
        if (!this.contextViewProvider || !this.message) {
            return;
        }
        var div;
        var layout = function () { return div.style.width = getTotalWidth(_this.element) + 'px'; };
        this.state = 'open';
        this.contextViewProvider.showContextView({
            getAnchor: function () { return _this.element; },
            anchorAlignment: AnchorAlignment.RIGHT,
            render: function (container) {
                div = append(container, $$2('.monaco-inputbox-container'));
                layout();
                var renderOptions = {
                    inline: true,
                    className: 'monaco-inputbox-message'
                };
                var spanElement = (_this.message.formatContent
                    ? renderFormattedText(_this.message.content, renderOptions)
                    : renderText(_this.message.content, renderOptions));
                addClass(spanElement, _this.classForType(_this.message.type));
                var styles = _this.stylesForType(_this.message.type);
                spanElement.style.backgroundColor = styles.background ? styles.background.toString() : null;
                spanElement.style.border = styles.border ? "1px solid " + styles.border : null;
                append(div, spanElement);
                return null;
            },
            layout: layout
        });
    };
    InputBox.prototype._hideMessage = function () {
        if (!this.contextViewProvider || this.state !== 'open') {
            return;
        }
        this.state = 'idle';
        this.contextViewProvider.hideContextView();
    };
    InputBox.prototype.onValueChange = function () {
        this._onDidChange.fire(this.value);
        this.validate();
        this.updateMirror();
        if (this.state === 'open') {
            this.contextViewProvider.layout();
        }
    };
    InputBox.prototype.updateMirror = function () {
        if (!this.mirror) {
            return;
        }
        var value = this.value || this.placeholder;
        var lastCharCode = value.charCodeAt(value.length - 1);
        var suffix = lastCharCode === 10 ? ' ' : '';
        this.mirror.textContent = value + suffix;
        this.layout();
    };
    InputBox.prototype.style = function (styles) {
        this.inputBackground = styles.inputBackground;
        this.inputForeground = styles.inputForeground;
        this.inputBorder = styles.inputBorder;
        this.inputValidationInfoBackground = styles.inputValidationInfoBackground;
        this.inputValidationInfoBorder = styles.inputValidationInfoBorder;
        this.inputValidationWarningBackground = styles.inputValidationWarningBackground;
        this.inputValidationWarningBorder = styles.inputValidationWarningBorder;
        this.inputValidationErrorBackground = styles.inputValidationErrorBackground;
        this.inputValidationErrorBorder = styles.inputValidationErrorBorder;
        this.applyStyles();
    };
    InputBox.prototype.applyStyles = function () {
        if (this.element) {
            var background = this.inputBackground ? this.inputBackground.toString() : null;
            var foreground$$1 = this.inputForeground ? this.inputForeground.toString() : null;
            var border = this.inputBorder ? this.inputBorder.toString() : null;
            this.element.style.backgroundColor = background;
            this.element.style.color = foreground$$1;
            this.input.style.backgroundColor = background;
            this.input.style.color = foreground$$1;
            this.element.style.borderWidth = border ? '1px' : null;
            this.element.style.borderStyle = border ? 'solid' : null;
            this.element.style.borderColor = border;
        }
    };
    InputBox.prototype.layout = function () {
        if (!this.mirror) {
            return;
        }
        var previousHeight = this.cachedHeight;
        this.cachedHeight = getTotalHeight(this.mirror);
        if (previousHeight !== this.cachedHeight) {
            this.input.style.height = this.cachedHeight + 'px';
            this._onDidHeightChange.fire(this.cachedHeight);
        }
    };
    InputBox.prototype.dispose = function () {
        this._hideMessage();
        this.element = null;
        this.input = null;
        this.contextViewProvider = null;
        this.message = null;
        this.placeholder = null;
        this.ariaLabel = null;
        this.validation = null;
        this.state = null;
        this.actionbar = null;
        _super.prototype.dispose.call(this);
    };
    return InputBox;
}(Widget));

const css$7 = "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n.vs .monaco-custom-checkbox.monaco-case-sensitive {\n\tbackground: url(\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgaGVpZ2h0PSIxNiI+PHN0eWxlIHR5cGU9InRleHQvY3NzIj4uc3Qwe29wYWNpdHk6MDtmaWxsOiNGNkY2RjY7fSAuc3Qxe2ZpbGw6I0Y2RjZGNjt9IC5zdDJ7ZmlsbDojNDI0MjQyO308L3N0eWxlPjxnIGlkPSJvdXRsaW5lIj48cmVjdCBjbGFzcz0ic3QwIiB3aWR0aD0iMTYiIGhlaWdodD0iMTYiLz48cGF0aCBjbGFzcz0ic3QxIiBkPSJNMTQuMTc2IDUuNTkyYy0uNTU1LS42LTEuMzM2LS45MDQtMi4zMjItLjkwNC0uMjU4IDAtLjUyMS4wMjQtLjc4NC4wNzItLjI0Ni4wNDQtLjQ3OS4xMDEtLjcuMTY5LS4yMjguMDctLjQzMi4xNDctLjYxMy4yMjktLjIyLjA5OS0uMzg5LjE5Ni0uNTEyLjI4NGwtLjQxOS4yOTl2Mi43MDFjLS4wODYuMTA4LS4xNjIuMjIzLS4yMjkuMzQ0bC0yLjQ1LTYuMzU0aC0yLjM5NGwtMy43NTMgOS44MDR2LjU5OGgzLjAyNWwuODM4LTIuMzVoMi4xNjdsLjg5MSAyLjM1aDMuMjM3bC0uMDAxLS4wMDNjLjMwNS4wOTIuNjMzLjE1Ljk5My4xNS4zNDQgMCAuNjcxLS4wNDkuOTc4LS4xNDZoMi44NTN2LTQuOTAzYy0uMDAxLS45NzUtLjI3MS0xLjc2My0uODA1LTIuMzR6Ii8+PC9nPjxnIGlkPSJpY29uX3g1Rl9iZyI+PHBhdGggY2xhc3M9InN0MiIgZD0iTTcuNjExIDExLjgzNGwtLjg5MS0yLjM1aC0zLjU2MmwtLjgzOCAyLjM1aC0xLjA5NWwzLjIxNy04LjQwMmgxLjAybDMuMjQgOC40MDJoLTEuMDkxem0tMi41MzEtNi44MTRsLS4wNDQtLjEzNS0uMDM4LS4xNTYtLjAyOS0uMTUyLS4wMjQtLjEyNmgtLjAyM2wtLjAyMS4xMjYtLjAzMi4xNTItLjAzOC4xNTYtLjA0NC4xMzUtMS4zMDcgMy41NzRoMi45MThsLTEuMzE4LTMuNTc0eiIvPjxwYXRoIGNsYXNzPSJzdDIiIGQ9Ik0xMy4wMiAxMS44MzR2LS45MzhoLS4wMjNjLS4xOTkuMzUyLS40NTYuNjItLjc3MS44MDZzLS42NzMuMjc4LTEuMDc1LjI3OGMtLjMxMyAwLS41ODgtLjA0NS0uODI2LS4xMzVzLS40MzgtLjIxMi0uNTk4LS4zNjYtLjI4MS0uMzM4LS4zNjMtLjU1MS0uMTI0LS40NDItLjEyNC0uNjg4YzAtLjI2Mi4wMzktLjUwMi4xMTctLjcyMXMuMTk4LS40MTIuMzYtLjU4LjM2Ny0uMzA4LjYxNS0uNDE5LjU0NC0uMTkuODg4LS4yMzdsMS44MTEtLjI1MmMwLS4yNzMtLjAyOS0uNTA3LS4wODgtLjdzLS4xNDMtLjM1MS0uMjUyLS40NzItLjI0MS0uMjEtLjM5Ni0uMjY3LS4zMjUtLjA4NS0uNTEzLS4wODVjLS4zNjMgMC0uNzE0LjA2NC0xLjA1Mi4xOTNzLS42MzguMzEtLjkwNC41NHYtLjk4NGMuMDgyLS4wNTkuMTk2LS4xMjEuMzQzLS4xODhzLjMxMi0uMTI4LjQ5NS0uMTg1LjM3OC0uMTA0LjU4My0uMTQxLjQwNy0uMDU2LjYwNi0uMDU2Yy42OTkgMCAxLjIyOS4xOTQgMS41ODguNTgzcy41MzkuOTQyLjUzOSAxLjY2MXYzLjkwMmgtLjk2em0tMS40NTQtMi44M2MtLjI3My4wMzUtLjQ5OC4wODUtLjY3NC4xNDlzLS4zMTMuMTQ0LS40MS4yMzctLjE2NS4yMDUtLjIwMi4zMzQtLjA1NS4yNzYtLjA1NS40NGMwIC4xNDEuMDI1LjI3MS4wNzYuMzkzcy4xMjQuMjI3LjIyLjMxNi4yMTUuMTYuMzU3LjIxMS4zMDguMDc2LjQ5NS4wNzZjLjI0MiAwIC40NjUtLjA0NS42NjgtLjEzNXMuMzc4LS4yMTQuNTI0LS4zNzIuMjYxLS4zNDQuMzQzLS41NTcuMTIzLS40NDIuMTIzLS42ODh2LS42MDlsLTEuNDY1LjIwNXoiLz48L2c+PC9zdmc+\") center center no-repeat;\n}\n.hc-black .monaco-custom-checkbox.monaco-case-sensitive,\n.hc-black .monaco-custom-checkbox.monaco-case-sensitive:hover,\n.vs-dark .monaco-custom-checkbox.monaco-case-sensitive {\n\tbackground: url(\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgaGVpZ2h0PSIxNiI+PHN0eWxlIHR5cGU9InRleHQvY3NzIj4uc3Qwe29wYWNpdHk6MDtmaWxsOiMyNjI2MjY7fSAuc3Qxe2ZpbGw6IzI2MjYyNjt9IC5zdDJ7ZmlsbDojQzVDNUM1O308L3N0eWxlPjxnIGlkPSJvdXRsaW5lIj48cmVjdCBjbGFzcz0ic3QwIiB3aWR0aD0iMTYiIGhlaWdodD0iMTYiLz48cGF0aCBjbGFzcz0ic3QxIiBkPSJNMTQuMTc2IDUuNTkyYy0uNTU1LS42LTEuMzM2LS45MDQtMi4zMjItLjkwNC0uMjU4IDAtLjUyMS4wMjQtLjc4NC4wNzItLjI0Ni4wNDQtLjQ3OS4xMDEtLjcuMTY5LS4yMjguMDctLjQzMi4xNDctLjYxMy4yMjktLjIyLjA5OS0uMzg5LjE5Ni0uNTEyLjI4NGwtLjQxOS4yOTl2Mi43MDFjLS4wODYuMTA4LS4xNjIuMjIzLS4yMjkuMzQ0bC0yLjQ1LTYuMzU0aC0yLjM5NGwtMy43NTMgOS44MDR2LjU5OGgzLjAyNWwuODM4LTIuMzVoMi4xNjdsLjg5MSAyLjM1aDMuMjM3bC0uMDAxLS4wMDNjLjMwNS4wOTIuNjMzLjE1Ljk5My4xNS4zNDQgMCAuNjcxLS4wNDkuOTc4LS4xNDZoMi44NTN2LTQuOTAzYy0uMDAxLS45NzUtLjI3MS0xLjc2My0uODA1LTIuMzR6Ii8+PC9nPjxnIGlkPSJpY29uX3g1Rl9iZyI+PHBhdGggY2xhc3M9InN0MiIgZD0iTTcuNjExIDExLjgzNGwtLjg5MS0yLjM1aC0zLjU2MmwtLjgzOCAyLjM1aC0xLjA5NWwzLjIxNy04LjQwMmgxLjAybDMuMjQgOC40MDJoLTEuMDkxem0tMi41MzEtNi44MTRsLS4wNDQtLjEzNS0uMDM4LS4xNTYtLjAyOS0uMTUyLS4wMjQtLjEyNmgtLjAyM2wtLjAyMS4xMjYtLjAzMi4xNTItLjAzOC4xNTYtLjA0NC4xMzUtMS4zMDcgMy41NzRoMi45MThsLTEuMzE4LTMuNTc0eiIvPjxwYXRoIGNsYXNzPSJzdDIiIGQ9Ik0xMy4wMiAxMS44MzR2LS45MzhoLS4wMjNjLS4xOTkuMzUyLS40NTYuNjItLjc3MS44MDZzLS42NzMuMjc4LTEuMDc1LjI3OGMtLjMxMyAwLS41ODgtLjA0NS0uODI2LS4xMzVzLS40MzgtLjIxMi0uNTk4LS4zNjYtLjI4MS0uMzM4LS4zNjMtLjU1MS0uMTI0LS40NDItLjEyNC0uNjg4YzAtLjI2Mi4wMzktLjUwMi4xMTctLjcyMXMuMTk4LS40MTIuMzYtLjU4LjM2Ny0uMzA4LjYxNS0uNDE5LjU0NC0uMTkuODg4LS4yMzdsMS44MTEtLjI1MmMwLS4yNzMtLjAyOS0uNTA3LS4wODgtLjdzLS4xNDMtLjM1MS0uMjUyLS40NzItLjI0MS0uMjEtLjM5Ni0uMjY3LS4zMjUtLjA4NS0uNTEzLS4wODVjLS4zNjMgMC0uNzE0LjA2NC0xLjA1Mi4xOTNzLS42MzguMzEtLjkwNC41NHYtLjk4NGMuMDgyLS4wNTkuMTk2LS4xMjEuMzQzLS4xODhzLjMxMi0uMTI4LjQ5NS0uMTg1LjM3OC0uMTA0LjU4My0uMTQxLjQwNy0uMDU2LjYwNi0uMDU2Yy42OTkgMCAxLjIyOS4xOTQgMS41ODguNTgzcy41MzkuOTQyLjUzOSAxLjY2MXYzLjkwMmgtLjk2em0tMS40NTQtMi44M2MtLjI3My4wMzUtLjQ5OC4wODUtLjY3NC4xNDlzLS4zMTMuMTQ0LS40MS4yMzctLjE2NS4yMDUtLjIwMi4zMzQtLjA1NS4yNzYtLjA1NS40NGMwIC4xNDEuMDI1LjI3MS4wNzYuMzkzcy4xMjQuMjI3LjIyLjMxNi4yMTUuMTYuMzU3LjIxMS4zMDguMDc2LjQ5NS4wNzZjLjI0MiAwIC40NjUtLjA0NS42NjgtLjEzNXMuMzc4LS4yMTQuNTI0LS4zNzIuMjYxLS4zNDQuMzQzLS41NTcuMTIzLS40NDIuMTIzLS42ODh2LS42MDlsLTEuNDY1LjIwNXoiLz48L2c+PC9zdmc+\") center center no-repeat;\n}\n\n.vs .monaco-custom-checkbox.monaco-whole-word {\n\tbackground: url(\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgaGVpZ2h0PSIxNiI+PHN0eWxlIHR5cGU9InRleHQvY3NzIj4uc3Qwe29wYWNpdHk6MDtmaWxsOiNGNkY2RjY7fSAuc3Qxe2ZpbGw6I0Y2RjZGNjt9IC5zdDJ7ZmlsbDojNDI0MjQyO308L3N0eWxlPjxnIGlkPSJvdXRsaW5lIj48cmVjdCBjbGFzcz0ic3QwIiB3aWR0aD0iMTYiIGhlaWdodD0iMTYiLz48cGF0aCBjbGFzcz0ic3QxIiBkPSJNMTYgNC4wMjJ2LTMuMDIyaC0xNi4wMTR2My4wMjJoMy4wNDZsLTMuMDQzIDcuOTQ1aC0uMDA0di4wMWwuMDE1IDEuMDIzaC0uMDE0djEuOTkxaDE2LjAxNHYtMy4wMjNoLTF2LTcuOTQ2aDF6bS01LjkxNCA1LjMwMWMwIC4yMzMtLjAyMy40NDEtLjA2Ni41OTUtLjA0Ny4xNjQtLjA5OS4yNDctLjEyNy4yODRsLS4wNzguMDY5LS4xNTEuMDI2LS4xMTUtLjAxNy0uMTM5LS4xMzdjLS4wMzEtLjA3OC0uMTEyLS4zMzItLjExMi0uNTY2IDAtLjI1NC4wOTEtLjU2MS4xMjYtLjY1NmwuMDY5LS4xNDEuMTA5LS4wODIuMTc4LS4wMjdjLjA3NyAwIC4xMTcuMDE0LjE3Ny4wNTZsLjA4Ny4xNzkuMDUxLjIzNy0uMDA5LjE4em0tMy42OTUtNS4zMDF2Mi44OTNsLTEuMTE2LTIuODkzaDEuMTE2em0tMy4wMjYgNy4wMmgxLjU3M2wuMzUxLjkyNmgtMi4yNTRsLjMzLS45MjZ6bTguNjM1LTQuMzU0Yy0uMjA2LS4yLS40MzEtLjM4LS42OTUtLjUxMi0uMzk2LS4xOTgtLjg1My0uMjk4LTEuMzU1LS4yOTgtLjIxNSAwLS40MjMuMDItLjYyMS4wNTh2LTEuOTE0aDIuNjcxdjIuNjY2eiIvPjwvZz48ZyBpZD0iaWNvbl94NUZfYmciPjxyZWN0IHg9IjEzIiB5PSI0IiBjbGFzcz0ic3QyIiB3aWR0aD0iMSIgaGVpZ2h0PSI4Ii8+PHBhdGggY2xhc3M9InN0MiIgZD0iTTExLjIyNSA4LjM4N2MtLjA3OC0uMjk5LS4xOTktLjU2Mi0uMzYtLjc4NnMtLjM2NS0uNDAxLS42MDktLjUzLS41MzQtLjE5My0uODY2LS4xOTNjLS4xOTggMC0uMzguMDI0LS41NDcuMDczLS4xNjUuMDQ5LS4zMTYuMTE3LS40NTMuMjA1LS4xMzYuMDg4LS4yNTcuMTk0LS4zNjUuMzE4bC0uMTc5LjI1OHYtMy4xNTRoLS44OTN2Ny40MjJoLjg5M3YtLjU3NWwuMTI2LjE3NWMuMDg3LjEwMi4xODkuMTkuMzA0LjI2OS4xMTcuMDc4LjI0OS4xNC4zOTguMTg2LjE0OS4wNDYuMzE0LjA2OC40OTguMDY4LjM1MyAwIC42NjYtLjA3MS45MzctLjIxMi4yNzItLjE0My40OTktLjMzOC42ODItLjU4Ni4xODMtLjI1LjMyMS0uNTQzLjQxNC0uODc5LjA5My0uMzM4LjE0LS43MDMuMTQtMS4wOTctLjAwMS0uMzQyLS4wNC0uNjYzLS4xMi0uOTYyem0tMS40NzktLjYwN2MuMTUxLjA3MS4yODIuMTc2LjM5LjMxNC4xMDkuMTQuMTk0LjMxMy4yNTUuNTE3LjA1MS4xNzQuMDgyLjM3MS4wODkuNTg3bC0uMDA3LjEyNWMwIC4zMjctLjAzMy42Mi0uMS44NjktLjA2Ny4yNDYtLjE2MS40NTMtLjI3OC42MTQtLjExNy4xNjItLjI2LjI4NS0uNDIxLjM2Ni0uMzIyLjE2Mi0uNzYuMTY2LTEuMDY5LjAxNS0uMTUzLS4wNzUtLjI4Ni0uMTc1LS4zOTMtLjI5Ni0uMDg1LS4wOTYtLjE1Ni0uMjE2LS4yMTgtLjM2NyAwIDAtLjE3OS0uNDQ3LS4xNzktLjk0NyAwLS41LjE3OS0xLjAwMi4xNzktMS4wMDIuMDYyLS4xNzcuMTM2LS4zMTguMjI0LS40My4xMTQtLjE0My4yNTYtLjI1OS40MjQtLjM0NS4xNjgtLjA4Ni4zNjUtLjEyOS41ODctLjEyOS4xOSAwIC4zNjQuMDM3LjUxNy4xMDl6Ii8+PHJlY3QgeD0iLjk4NyIgeT0iMiIgY2xhc3M9InN0MiIgd2lkdGg9IjE0LjAxMyIgaGVpZ2h0PSIxLjAyMyIvPjxyZWN0IHg9Ii45ODciIHk9IjEyLjk2OCIgY2xhc3M9InN0MiIgd2lkdGg9IjE0LjAxMyIgaGVpZ2h0PSIxLjAyMyIvPjxwYXRoIGNsYXNzPSJzdDIiIGQ9Ik0xLjk5MSAxMi4wMzFsLjcyOC0yLjAzMWgyLjIxOWwuNzc4IDIuMDMxaDEuMDgybC0yLjQ4NS03LjE1OGgtLjk0MWwtMi40NDEgNy4wODYtLjAyNS4wNzJoMS4wODV6bTEuODI3LTUuNjA5aC4wMjJsLjkxNCAyLjc1M2gtMS44NDFsLjkwNS0yLjc1M3oiLz48L2c+PC9zdmc+\") center center no-repeat;\n}\n.hc-black .monaco-custom-checkbox.monaco-whole-word,\n.hc-black .monaco-custom-checkbox.monaco-whole-word:hover,\n.vs-dark .monaco-custom-checkbox.monaco-whole-word {\n\tbackground: url(\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgaGVpZ2h0PSIxNiI+PHN0eWxlIHR5cGU9InRleHQvY3NzIj4uc3Qwe29wYWNpdHk6MDtmaWxsOiMyNjI2MjY7fSAuc3Qxe2ZpbGw6IzI2MjYyNjt9IC5zdDJ7ZmlsbDojQzVDNUM1O308L3N0eWxlPjxnIGlkPSJvdXRsaW5lIj48cmVjdCBjbGFzcz0ic3QwIiB3aWR0aD0iMTYiIGhlaWdodD0iMTYiLz48cGF0aCBjbGFzcz0ic3QxIiBkPSJNMTYgNC4wMjJ2LTMuMDIyaC0xNi4wMTR2My4wMjJoMy4wNDZsLTMuMDQzIDcuOTQ1aC0uMDA0di4wMWwuMDE1IDEuMDIzaC0uMDE0djEuOTkxaDE2LjAxNHYtMy4wMjNoLTF2LTcuOTQ2aDF6bS01LjkxNCA1LjMwMWMwIC4yMzMtLjAyMy40NDEtLjA2Ni41OTUtLjA0Ny4xNjQtLjA5OS4yNDctLjEyNy4yODRsLS4wNzguMDY5LS4xNTEuMDI2LS4xMTUtLjAxNy0uMTM5LS4xMzdjLS4wMzEtLjA3OC0uMTEyLS4zMzItLjExMi0uNTY2IDAtLjI1NC4wOTEtLjU2MS4xMjYtLjY1NmwuMDY5LS4xNDEuMTA5LS4wODIuMTc4LS4wMjdjLjA3NyAwIC4xMTcuMDE0LjE3Ny4wNTZsLjA4Ny4xNzkuMDUxLjIzNy0uMDA5LjE4em0tMy42OTUtNS4zMDF2Mi44OTNsLTEuMTE2LTIuODkzaDEuMTE2em0tMy4wMjYgNy4wMmgxLjU3M2wuMzUxLjkyNmgtMi4yNTRsLjMzLS45MjZ6bTguNjM1LTQuMzU0Yy0uMjA2LS4yLS40MzEtLjM4LS42OTUtLjUxMi0uMzk2LS4xOTgtLjg1My0uMjk4LTEuMzU1LS4yOTgtLjIxNSAwLS40MjMuMDItLjYyMS4wNTh2LTEuOTE0aDIuNjcxdjIuNjY2eiIvPjwvZz48ZyBpZD0iaWNvbl94NUZfYmciPjxyZWN0IHg9IjEzIiB5PSI0IiBjbGFzcz0ic3QyIiB3aWR0aD0iMSIgaGVpZ2h0PSI4Ii8+PHBhdGggY2xhc3M9InN0MiIgZD0iTTExLjIyNSA4LjM4N2MtLjA3OC0uMjk5LS4xOTktLjU2Mi0uMzYtLjc4NnMtLjM2NS0uNDAxLS42MDktLjUzLS41MzQtLjE5My0uODY2LS4xOTNjLS4xOTggMC0uMzguMDI0LS41NDcuMDczLS4xNjUuMDQ5LS4zMTYuMTE3LS40NTMuMjA1LS4xMzYuMDg4LS4yNTcuMTk0LS4zNjUuMzE4bC0uMTc5LjI1OHYtMy4xNTRoLS44OTN2Ny40MjJoLjg5M3YtLjU3NWwuMTI2LjE3NWMuMDg3LjEwMi4xODkuMTkuMzA0LjI2OS4xMTcuMDc4LjI0OS4xNC4zOTguMTg2LjE0OS4wNDYuMzE0LjA2OC40OTguMDY4LjM1MyAwIC42NjYtLjA3MS45MzctLjIxMi4yNzItLjE0My40OTktLjMzOC42ODItLjU4Ni4xODMtLjI1LjMyMS0uNTQzLjQxNC0uODc5LjA5My0uMzM4LjE0LS43MDMuMTQtMS4wOTctLjAwMS0uMzQyLS4wNC0uNjYzLS4xMi0uOTYyem0tMS40NzktLjYwN2MuMTUxLjA3MS4yODIuMTc2LjM5LjMxNC4xMDkuMTQuMTk0LjMxMy4yNTUuNTE3LjA1MS4xNzQuMDgyLjM3MS4wODkuNTg3bC0uMDA3LjEyNWMwIC4zMjctLjAzMy42Mi0uMS44NjktLjA2Ny4yNDYtLjE2MS40NTMtLjI3OC42MTQtLjExNy4xNjItLjI2LjI4NS0uNDIxLjM2Ni0uMzIyLjE2Mi0uNzYuMTY2LTEuMDY5LjAxNS0uMTUzLS4wNzUtLjI4Ni0uMTc1LS4zOTMtLjI5Ni0uMDg1LS4wOTYtLjE1Ni0uMjE2LS4yMTgtLjM2NyAwIDAtLjE3OS0uNDQ3LS4xNzktLjk0NyAwLS41LjE3OS0xLjAwMi4xNzktMS4wMDIuMDYyLS4xNzcuMTM2LS4zMTguMjI0LS40My4xMTQtLjE0My4yNTYtLjI1OS40MjQtLjM0NS4xNjgtLjA4Ni4zNjUtLjEyOS41ODctLjEyOS4xOSAwIC4zNjQuMDM3LjUxNy4xMDl6Ii8+PHJlY3QgeD0iLjk4NyIgeT0iMiIgY2xhc3M9InN0MiIgd2lkdGg9IjE0LjAxMyIgaGVpZ2h0PSIxLjAyMyIvPjxyZWN0IHg9Ii45ODciIHk9IjEyLjk2OCIgY2xhc3M9InN0MiIgd2lkdGg9IjE0LjAxMyIgaGVpZ2h0PSIxLjAyMyIvPjxwYXRoIGNsYXNzPSJzdDIiIGQ9Ik0xLjk5MSAxMi4wMzFsLjcyOC0yLjAzMWgyLjIxOWwuNzc4IDIuMDMxaDEuMDgybC0yLjQ4NS03LjE1OGgtLjk0MWwtMi40NDEgNy4wODYtLjAyNS4wNzJoMS4wODV6bTEuODI3LTUuNjA5aC4wMjJsLjkxNCAyLjc1M2gtMS44NDFsLjkwNS0yLjc1M3oiLz48L2c+PC9zdmc+\") center center no-repeat;\n}\n\n.vs .monaco-custom-checkbox.monaco-regex {\n\tbackground: url(\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgaGVpZ2h0PSIxNiI+PHBvbHlnb24gZmlsbD0iI0Y2RjZGNiIgcG9pbnRzPSIxMy42NCw3LjM5NiAxMi4xNjksMi44OTggMTAuNzA2LDMuNzYxIDExLjA4NywyIDYuNTU3LDIgNi45MzYsMy43NjIgNS40NzMsMi44OTggNCw3LjM5NiA1LjY4Miw3LjU1NCA0LjUxMyw4LjU2MSA1LjAxMyw5IDIsOSAyLDE0IDcsMTQgNywxMC43NDcgNy45NzgsMTEuNjA2IDguODIsOS43MjUgOS42NjEsMTEuNjAyIDEzLjE0NCw4LjU2MiAxMS45NjgsNy41NTQiLz48ZyBmaWxsPSIjNDI0MjQyIj48cGF0aCBkPSJNMTIuMzAxIDYuNTE4bC0yLjc3Mi4yNjIgMi4wODYgMS43ODgtMS41OTQgMS4zOTItMS4yMDEtMi42ODItMS4yMDEgMi42ODItMS41ODMtMS4zOTIgMi4wNzUtMS43ODgtMi43NzEtLjI2Mi42OTYtMi4xMjYgMi4zNTggMS4zOTItLjU5OS0yLjc4NGgyLjA1M2wtLjYwMiAyLjc4MyAyLjM1OS0xLjM5Mi42OTYgMi4xMjd6Ii8+PHJlY3QgeD0iMyIgeT0iMTAiIHdpZHRoPSIzIiBoZWlnaHQ9IjMiLz48L2c+PC9zdmc+\") center center no-repeat;\n}\n.hc-black .monaco-custom-checkbox.monaco-regex,\n.hc-black .monaco-custom-checkbox.monaco-regex:hover,\n.vs-dark .monaco-custom-checkbox.monaco-regex {\n\tbackground: url(\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgaGVpZ2h0PSIxNiI+PHBvbHlnb24gZmlsbD0iIzJkMmQzMCIgcG9pbnRzPSIxMy42NCw3LjM5NiAxMi4xNjksMi44OTggMTAuNzA2LDMuNzYxIDExLjA4NywyIDYuNTU3LDIgNi45MzYsMy43NjIgNS40NzMsMi44OTggNCw3LjM5NiA1LjY4Miw3LjU1NCA0LjUxMyw4LjU2MSA1LjAxMyw5IDIsOSAyLDE0IDcsMTQgNywxMC43NDcgNy45NzgsMTEuNjA2IDguODIsOS43MjUgOS42NjEsMTEuNjAyIDEzLjE0NCw4LjU2MiAxMS45NjgsNy41NTQiLz48ZyBmaWxsPSIjQzVDNUM1Ij48cGF0aCBkPSJNMTIuMzAxIDYuNTE4bC0yLjc3Mi4yNjIgMi4wODYgMS43ODgtMS41OTQgMS4zOTItMS4yMDEtMi42ODItMS4yMDEgMi42ODItMS41ODMtMS4zOTIgMi4wNzUtMS43ODgtMi43NzEtLjI2Mi42OTYtMi4xMjYgMi4zNTggMS4zOTItLjU5OS0yLjc4NGgyLjA1M2wtLjYwMiAyLjc4MyAyLjM1OS0xLjM5Mi42OTYgMi4xMjd6Ii8+PHJlY3QgeD0iMyIgeT0iMTAiIHdpZHRoPSIzIiBoZWlnaHQ9IjMiLz48L2c+PC9zdmc+\") center center no-repeat;\n}\n";
  const element$7 = ((css, src) => {
if (typeof document !== 'object')
console.info(`Skipped loading "${src}"`);
try {
const id = src
  .replace(/\.css.*$/, '')
  .replace(/[\\:]/g, '/')
  .replace(/[^\w\/]+/g, '');
return (
  document.querySelector(`style[id="${id}"]`) ||
  document.head.appendChild(
    Object.assign(document.createElement('style'), {
      id,
      textContent: `${css}\n\n /* sourceURL=${src} */`,
    }),
  )
);
} catch (exception) {
console.warn(`Failed load "${src}"`, exception);
}
})(css$7, "…monaco-editor/esm/vs/base/browser/ui/findinput/findInputCheckboxes.css");
  //@ sourceURL=/Users/daflair/Projects/packages/monaco-es/node_modules/monaco-editor/esm/vs/base/browser/ui/findinput/findInputCheckboxes.css

const css$8 = "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n.monaco-custom-checkbox {\n\tmargin-left: 2px;\n\tfloat: left;\n\tcursor: pointer;\n\toverflow: hidden;\n\topacity: 0.7;\n\twidth: 20px;\n\theight: 20px;\n\tborder: 1px solid transparent;\n\tpadding: 1px;\n\n\t-webkit-box-sizing:\tborder-box;\n\t-o-box-sizing:\t\tborder-box;\n\t-moz-box-sizing:\tborder-box;\n\t-ms-box-sizing:\t\tborder-box;\n\tbox-sizing:\t\t\tborder-box;\n\n\t-webkit-user-select: none;\n\t-khtml-user-select: none;\n\t-moz-user-select: none;\n\t-o-user-select: none;\n\t-ms-user-select: none;\n\tuser-select: none;\n}\n\n.monaco-custom-checkbox:hover,\n.monaco-custom-checkbox.checked {\n\topacity: 1;\n}\n\n.hc-black .monaco-custom-checkbox {\n\tbackground: none;\n}\n\n.hc-black .monaco-custom-checkbox:hover {\n\tbackground: none;\n}";
  const element$8 = ((css, src) => {
if (typeof document !== 'object')
console.info(`Skipped loading "${src}"`);
try {
const id = src
  .replace(/\.css.*$/, '')
  .replace(/[\\:]/g, '/')
  .replace(/[^\w\/]+/g, '');
return (
  document.querySelector(`style[id="${id}"]`) ||
  document.head.appendChild(
    Object.assign(document.createElement('style'), {
      id,
      textContent: `${css}\n\n /* sourceURL=${src} */`,
    }),
  )
);
} catch (exception) {
console.warn(`Failed load "${src}"`, exception);
}
})(css$8, "…monaco-editor/esm/vs/base/browser/ui/checkbox/checkbox.css");
  //@ sourceURL=/Users/daflair/Projects/packages/monaco-es/node_modules/monaco-editor/esm/vs/base/browser/ui/checkbox/checkbox.css

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$8 = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var defaultOpts$1 = {
    inputActiveOptionBorder: Color.fromHex('#007ACC')
};
var Checkbox = /** @class */ (function (_super) {
    __extends$8(Checkbox, _super);
    function Checkbox(opts) {
        var _this = _super.call(this) || this;
        _this._opts = deepClone(opts);
        mixin(_this._opts, defaultOpts$1, false);
        _this._checked = _this._opts.isChecked;
        _this.domNode = document.createElement('div');
        _this.domNode.title = _this._opts.title;
        _this.domNode.className = 'monaco-custom-checkbox ' + _this._opts.actionClassName + ' ' + (_this._checked ? 'checked' : 'unchecked');
        _this.domNode.tabIndex = 0;
        _this.domNode.setAttribute('role', 'checkbox');
        _this.domNode.setAttribute('aria-checked', String(_this._checked));
        _this.domNode.setAttribute('aria-label', _this._opts.title);
        _this.applyStyles();
        _this.onclick(_this.domNode, function (ev) {
            _this.checked = !_this._checked;
            _this._opts.onChange(false);
            ev.preventDefault();
        });
        _this.onkeydown(_this.domNode, function (keyboardEvent) {
            if (keyboardEvent.keyCode === 10 /* Space */ || keyboardEvent.keyCode === 3 /* Enter */) {
                _this.checked = !_this._checked;
                _this._opts.onChange(true);
                keyboardEvent.preventDefault();
                return;
            }
            if (_this._opts.onKeyDown) {
                _this._opts.onKeyDown(keyboardEvent);
            }
        });
        return _this;
    }
    Object.defineProperty(Checkbox.prototype, "enabled", {
        get: function () {
            return this.domNode.getAttribute('aria-disabled') !== 'true';
        },
        enumerable: true,
        configurable: true
    });
    Checkbox.prototype.focus = function () {
        this.domNode.focus();
    };
    Object.defineProperty(Checkbox.prototype, "checked", {
        get: function () {
            return this._checked;
        },
        set: function (newIsChecked) {
            this._checked = newIsChecked;
            this.domNode.setAttribute('aria-checked', String(this._checked));
            if (this._checked) {
                this.domNode.classList.add('checked');
            }
            else {
                this.domNode.classList.remove('checked');
            }
            this.applyStyles();
        },
        enumerable: true,
        configurable: true
    });
    Checkbox.prototype.width = function () {
        return 2 /*marginleft*/ + 2 /*border*/ + 2 /*padding*/ + 16 /* icon width */;
    };
    Checkbox.prototype.style = function (styles) {
        if (styles.inputActiveOptionBorder) {
            this._opts.inputActiveOptionBorder = styles.inputActiveOptionBorder;
        }
        this.applyStyles();
    };
    Checkbox.prototype.applyStyles = function () {
        if (this.domNode) {
            this.domNode.style.borderColor = this._checked && this._opts.inputActiveOptionBorder ? this._opts.inputActiveOptionBorder.toString() : 'transparent';
        }
    };
    Checkbox.prototype.enable = function () {
        this.domNode.tabIndex = 0;
        this.domNode.setAttribute('aria-disabled', String(false));
    };
    Checkbox.prototype.disable = function () {
        removeTabIndexAndUpdateFocus(this.domNode);
        this.domNode.setAttribute('aria-disabled', String(true));
    };
    return Checkbox;
}(Widget));

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$9 = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var NLS_CASE_SENSITIVE_CHECKBOX_LABEL = localize('caseDescription', "Match Case");
var NLS_WHOLE_WORD_CHECKBOX_LABEL = localize('wordsDescription', "Match Whole Word");
var NLS_REGEX_CHECKBOX_LABEL = localize('regexDescription', "Use Regular Expression");
var CaseSensitiveCheckbox = /** @class */ (function (_super) {
    __extends$9(CaseSensitiveCheckbox, _super);
    function CaseSensitiveCheckbox(opts) {
        return _super.call(this, {
            actionClassName: 'monaco-case-sensitive',
            title: NLS_CASE_SENSITIVE_CHECKBOX_LABEL + opts.appendTitle,
            isChecked: opts.isChecked,
            onChange: opts.onChange,
            onKeyDown: opts.onKeyDown,
            inputActiveOptionBorder: opts.inputActiveOptionBorder
        }) || this;
    }
    return CaseSensitiveCheckbox;
}(Checkbox));
var WholeWordsCheckbox = /** @class */ (function (_super) {
    __extends$9(WholeWordsCheckbox, _super);
    function WholeWordsCheckbox(opts) {
        return _super.call(this, {
            actionClassName: 'monaco-whole-word',
            title: NLS_WHOLE_WORD_CHECKBOX_LABEL + opts.appendTitle,
            isChecked: opts.isChecked,
            onChange: opts.onChange,
            onKeyDown: opts.onKeyDown,
            inputActiveOptionBorder: opts.inputActiveOptionBorder
        }) || this;
    }
    return WholeWordsCheckbox;
}(Checkbox));
var RegexCheckbox = /** @class */ (function (_super) {
    __extends$9(RegexCheckbox, _super);
    function RegexCheckbox(opts) {
        return _super.call(this, {
            actionClassName: 'monaco-regex',
            title: NLS_REGEX_CHECKBOX_LABEL + opts.appendTitle,
            isChecked: opts.isChecked,
            onChange: opts.onChange,
            onKeyDown: opts.onKeyDown,
            inputActiveOptionBorder: opts.inputActiveOptionBorder
        }) || this;
    }
    return RegexCheckbox;
}(Checkbox));

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$a = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var NLS_DEFAULT_LABEL = localize('defaultLabel', "input");
var FindInput = /** @class */ (function (_super) {
    __extends$a(FindInput, _super);
    function FindInput(parent, contextViewProvider, options) {
        var _this = _super.call(this) || this;
        _this._onDidOptionChange = _this._register(new Emitter());
        _this.onDidOptionChange = _this._onDidOptionChange.event;
        _this._onKeyDown = _this._register(new Emitter());
        _this.onKeyDown = _this._onKeyDown.event;
        _this._onMouseDown = _this._register(new Emitter());
        _this.onMouseDown = _this._onMouseDown.event;
        _this._onInput = _this._register(new Emitter());
        _this.onInput = _this._onInput.event;
        _this._onKeyUp = _this._register(new Emitter());
        _this.onKeyUp = _this._onKeyUp.event;
        _this._onCaseSensitiveKeyDown = _this._register(new Emitter());
        _this.onCaseSensitiveKeyDown = _this._onCaseSensitiveKeyDown.event;
        _this._lastHighlightFindOptions = 0;
        _this.contextViewProvider = contextViewProvider;
        _this.width = options.width || 100;
        _this.placeholder = options.placeholder || '';
        _this.validation = options.validation;
        _this.label = options.label || NLS_DEFAULT_LABEL;
        _this.inputActiveOptionBorder = options.inputActiveOptionBorder;
        _this.inputBackground = options.inputBackground;
        _this.inputForeground = options.inputForeground;
        _this.inputBorder = options.inputBorder;
        _this.inputValidationInfoBorder = options.inputValidationInfoBorder;
        _this.inputValidationInfoBackground = options.inputValidationInfoBackground;
        _this.inputValidationWarningBorder = options.inputValidationWarningBorder;
        _this.inputValidationWarningBackground = options.inputValidationWarningBackground;
        _this.inputValidationErrorBorder = options.inputValidationErrorBorder;
        _this.inputValidationErrorBackground = options.inputValidationErrorBackground;
        _this.regex = null;
        _this.wholeWords = null;
        _this.caseSensitive = null;
        _this.domNode = null;
        _this.inputBox = null;
        _this.buildDomNode(options.appendCaseSensitiveLabel || '', options.appendWholeWordsLabel || '', options.appendRegexLabel || '');
        if (Boolean(parent)) {
            parent.appendChild(_this.domNode);
        }
        _this.onkeydown(_this.inputBox.inputElement, function (e) { return _this._onKeyDown.fire(e); });
        _this.onkeyup(_this.inputBox.inputElement, function (e) { return _this._onKeyUp.fire(e); });
        _this.oninput(_this.inputBox.inputElement, function (e) { return _this._onInput.fire(); });
        _this.onmousedown(_this.inputBox.inputElement, function (e) { return _this._onMouseDown.fire(e); });
        return _this;
    }
    FindInput.prototype.enable = function () {
        removeClass(this.domNode, 'disabled');
        this.inputBox.enable();
        this.regex.enable();
        this.wholeWords.enable();
        this.caseSensitive.enable();
    };
    FindInput.prototype.disable = function () {
        addClass(this.domNode, 'disabled');
        this.inputBox.disable();
        this.regex.disable();
        this.wholeWords.disable();
        this.caseSensitive.disable();
    };
    FindInput.prototype.setEnabled = function (enabled) {
        if (enabled) {
            this.enable();
        }
        else {
            this.disable();
        }
    };
    FindInput.prototype.clear = function () {
        this.clearValidation();
        this.setValue('');
        this.focus();
    };
    FindInput.prototype.setWidth = function (newWidth) {
        this.width = newWidth;
        this.domNode.style.width = this.width + 'px';
        this.contextViewProvider.layout();
        this.setInputWidth();
    };
    FindInput.prototype.getValue = function () {
        return this.inputBox.value;
    };
    FindInput.prototype.setValue = function (value) {
        if (this.inputBox.value !== value) {
            this.inputBox.value = value;
        }
    };
    FindInput.prototype.style = function (styles) {
        this.inputActiveOptionBorder = styles.inputActiveOptionBorder;
        this.inputBackground = styles.inputBackground;
        this.inputForeground = styles.inputForeground;
        this.inputBorder = styles.inputBorder;
        this.inputValidationInfoBackground = styles.inputValidationInfoBackground;
        this.inputValidationInfoBorder = styles.inputValidationInfoBorder;
        this.inputValidationWarningBackground = styles.inputValidationWarningBackground;
        this.inputValidationWarningBorder = styles.inputValidationWarningBorder;
        this.inputValidationErrorBackground = styles.inputValidationErrorBackground;
        this.inputValidationErrorBorder = styles.inputValidationErrorBorder;
        this.applyStyles();
    };
    FindInput.prototype.applyStyles = function () {
        if (this.domNode) {
            var checkBoxStyles = {
                inputActiveOptionBorder: this.inputActiveOptionBorder,
            };
            this.regex.style(checkBoxStyles);
            this.wholeWords.style(checkBoxStyles);
            this.caseSensitive.style(checkBoxStyles);
            var inputBoxStyles = {
                inputBackground: this.inputBackground,
                inputForeground: this.inputForeground,
                inputBorder: this.inputBorder,
                inputValidationInfoBackground: this.inputValidationInfoBackground,
                inputValidationInfoBorder: this.inputValidationInfoBorder,
                inputValidationWarningBackground: this.inputValidationWarningBackground,
                inputValidationWarningBorder: this.inputValidationWarningBorder,
                inputValidationErrorBackground: this.inputValidationErrorBackground,
                inputValidationErrorBorder: this.inputValidationErrorBorder
            };
            this.inputBox.style(inputBoxStyles);
        }
    };
    FindInput.prototype.select = function () {
        this.inputBox.select();
    };
    FindInput.prototype.focus = function () {
        this.inputBox.focus();
    };
    FindInput.prototype.getCaseSensitive = function () {
        return this.caseSensitive.checked;
    };
    FindInput.prototype.setCaseSensitive = function (value) {
        this.caseSensitive.checked = value;
        this.setInputWidth();
    };
    FindInput.prototype.getWholeWords = function () {
        return this.wholeWords.checked;
    };
    FindInput.prototype.setWholeWords = function (value) {
        this.wholeWords.checked = value;
        this.setInputWidth();
    };
    FindInput.prototype.getRegex = function () {
        return this.regex.checked;
    };
    FindInput.prototype.setRegex = function (value) {
        this.regex.checked = value;
        this.setInputWidth();
        this.validate();
    };
    FindInput.prototype.focusOnCaseSensitive = function () {
        this.caseSensitive.focus();
    };
    FindInput.prototype.highlightFindOptions = function () {
        removeClass(this.domNode, 'highlight-' + (this._lastHighlightFindOptions));
        this._lastHighlightFindOptions = 1 - this._lastHighlightFindOptions;
        addClass(this.domNode, 'highlight-' + (this._lastHighlightFindOptions));
    };
    FindInput.prototype.setInputWidth = function () {
        var w = this.width - this.caseSensitive.width() - this.wholeWords.width() - this.regex.width();
        this.inputBox.width = w;
    };
    FindInput.prototype.buildDomNode = function (appendCaseSensitiveLabel, appendWholeWordsLabel, appendRegexLabel) {
        var _this = this;
        this.domNode = document.createElement('div');
        this.domNode.style.width = this.width + 'px';
        addClass(this.domNode, 'monaco-findInput');
        this.inputBox = this._register(new InputBox(this.domNode, this.contextViewProvider, {
            placeholder: this.placeholder || '',
            ariaLabel: this.label || '',
            validationOptions: {
                validation: this.validation || null
            },
            inputBackground: this.inputBackground,
            inputForeground: this.inputForeground,
            inputBorder: this.inputBorder,
            inputValidationInfoBackground: this.inputValidationInfoBackground,
            inputValidationInfoBorder: this.inputValidationInfoBorder,
            inputValidationWarningBackground: this.inputValidationWarningBackground,
            inputValidationWarningBorder: this.inputValidationWarningBorder,
            inputValidationErrorBackground: this.inputValidationErrorBackground,
            inputValidationErrorBorder: this.inputValidationErrorBorder
        }));
        this.regex = this._register(new RegexCheckbox({
            appendTitle: appendRegexLabel,
            isChecked: false,
            onChange: function (viaKeyboard) {
                _this._onDidOptionChange.fire(viaKeyboard);
                if (!viaKeyboard) {
                    _this.inputBox.focus();
                }
                _this.setInputWidth();
                _this.validate();
            },
            inputActiveOptionBorder: this.inputActiveOptionBorder
        }));
        this.wholeWords = this._register(new WholeWordsCheckbox({
            appendTitle: appendWholeWordsLabel,
            isChecked: false,
            onChange: function (viaKeyboard) {
                _this._onDidOptionChange.fire(viaKeyboard);
                if (!viaKeyboard) {
                    _this.inputBox.focus();
                }
                _this.setInputWidth();
                _this.validate();
            },
            inputActiveOptionBorder: this.inputActiveOptionBorder
        }));
        this.caseSensitive = this._register(new CaseSensitiveCheckbox({
            appendTitle: appendCaseSensitiveLabel,
            isChecked: false,
            onChange: function (viaKeyboard) {
                _this._onDidOptionChange.fire(viaKeyboard);
                if (!viaKeyboard) {
                    _this.inputBox.focus();
                }
                _this.setInputWidth();
                _this.validate();
            },
            onKeyDown: function (e) {
                _this._onCaseSensitiveKeyDown.fire(e);
            },
            inputActiveOptionBorder: this.inputActiveOptionBorder
        }));
        // Arrow-Key support to navigate between options
        var indexes = [this.caseSensitive.domNode, this.wholeWords.domNode, this.regex.domNode];
        this.onkeydown(this.domNode, function (event) {
            if (event.equals(15 /* LeftArrow */) || event.equals(17 /* RightArrow */) || event.equals(9 /* Escape */)) {
                var index = indexes.indexOf(document.activeElement);
                if (index >= 0) {
                    var newIndex = void 0;
                    if (event.equals(17 /* RightArrow */)) {
                        newIndex = (index + 1) % indexes.length;
                    }
                    else if (event.equals(15 /* LeftArrow */)) {
                        if (index === 0) {
                            newIndex = indexes.length - 1;
                        }
                        else {
                            newIndex = index - 1;
                        }
                    }
                    if (event.equals(9 /* Escape */)) {
                        indexes[index].blur();
                    }
                    else if (newIndex >= 0) {
                        indexes[newIndex].focus();
                    }
                    EventHelper.stop(event, true);
                }
            }
        });
        this.setInputWidth();
        var controls = document.createElement('div');
        controls.className = 'controls';
        controls.appendChild(this.caseSensitive.domNode);
        controls.appendChild(this.wholeWords.domNode);
        controls.appendChild(this.regex.domNode);
        this.domNode.appendChild(controls);
    };
    FindInput.prototype.validate = function () {
        this.inputBox.validate();
    };
    FindInput.prototype.showMessage = function (message) {
        this.inputBox.showMessage(message);
    };
    FindInput.prototype.clearMessage = function () {
        this.inputBox.hideMessage();
    };
    FindInput.prototype.clearValidation = function () {
        this.inputBox.hideMessage();
    };
    FindInput.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
    };
    FindInput.OPTION_CHANGE = 'optionChange';
    return FindInput;
}(Widget));

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$b = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var NLS_FIND_INPUT_LABEL = localize('label.find', "Find");
var NLS_FIND_INPUT_PLACEHOLDER = localize('placeholder.find', "Find");
var NLS_PREVIOUS_MATCH_BTN_LABEL = localize('label.previousMatchButton', "Previous match");
var NLS_NEXT_MATCH_BTN_LABEL = localize('label.nextMatchButton', "Next match");
var NLS_TOGGLE_SELECTION_FIND_TITLE = localize('label.toggleSelectionFind', "Find in selection");
var NLS_CLOSE_BTN_LABEL = localize('label.closeButton', "Close");
var NLS_REPLACE_INPUT_LABEL = localize('label.replace', "Replace");
var NLS_REPLACE_INPUT_PLACEHOLDER = localize('placeholder.replace', "Replace");
var NLS_REPLACE_BTN_LABEL = localize('label.replaceButton', "Replace");
var NLS_REPLACE_ALL_BTN_LABEL = localize('label.replaceAllButton', "Replace All");
var NLS_TOGGLE_REPLACE_MODE_BTN_LABEL = localize('label.toggleReplaceButton', "Toggle Replace mode");
var NLS_MATCHES_COUNT_LIMIT_TITLE = localize('title.matchesCountLimit', "Only the first {0} results are highlighted, but all find operations work on the entire text.", MATCHES_LIMIT);
var NLS_MATCHES_LOCATION = localize('label.matchesLocation', "{0} of {1}");
var NLS_NO_RESULTS = localize('label.noResults', "No Results");
var FIND_WIDGET_INITIAL_WIDTH = 411;
var PART_WIDTH = 275;
var FIND_INPUT_AREA_WIDTH = PART_WIDTH - 54;
var REPLACE_INPUT_AREA_WIDTH = FIND_INPUT_AREA_WIDTH;
var MAX_MATCHES_COUNT_WIDTH = 69;
var FIND_ALL_CONTROLS_WIDTH = 17 /** Find Input margin-left */ + (MAX_MATCHES_COUNT_WIDTH + 3 + 1) /** Match Results */ + 23 /** Button */ * 4 + 2 /** sash */;
var FIND_INPUT_AREA_HEIGHT = 34; // The height of Find Widget when Replace Input is not visible.
var FIND_REPLACE_AREA_HEIGHT = 64; // The height of Find Widget when Replace Input is  visible.
var FindWidgetViewZone = /** @class */ (function () {
    function FindWidgetViewZone(afterLineNumber) {
        this.afterLineNumber = afterLineNumber;
        this.heightInPx = FIND_INPUT_AREA_HEIGHT;
        this.suppressMouseDown = false;
        this.domNode = document.createElement('div');
        this.domNode.className = 'dock-find-viewzone';
    }
    return FindWidgetViewZone;
}());
var FindWidget = /** @class */ (function (_super) {
    __extends$b(FindWidget, _super);
    function FindWidget(codeEditor, controller, state, contextViewProvider, keybindingService, contextKeyService, themeService) {
        var _this = _super.call(this) || this;
        _this._codeEditor = codeEditor;
        _this._controller = controller;
        _this._state = state;
        _this._contextViewProvider = contextViewProvider;
        _this._keybindingService = keybindingService;
        _this._isVisible = false;
        _this._isReplaceVisible = false;
        _this._register(_this._state.onFindReplaceStateChange(function (e) { return _this._onStateChanged(e); }));
        _this._buildDomNode();
        _this._updateButtons();
        _this._tryUpdateWidgetWidth();
        _this._register(_this._codeEditor.onDidChangeConfiguration(function (e) {
            if (e.readOnly) {
                if (_this._codeEditor.getConfiguration().readOnly) {
                    // Hide replace part if editor becomes read only
                    _this._state.change({ isReplaceRevealed: false }, false);
                }
                _this._updateButtons();
            }
            if (e.layoutInfo) {
                _this._tryUpdateWidgetWidth();
            }
        }));
        _this._register(_this._codeEditor.onDidChangeCursorSelection(function () {
            if (_this._isVisible) {
                _this._updateToggleSelectionFindButton();
            }
        }));
        _this._register(_this._codeEditor.onDidFocusEditor(function () {
            if (_this._isVisible) {
                var globalBufferTerm = _this._controller.getGlobalBufferTerm();
                if (globalBufferTerm && globalBufferTerm !== _this._state.searchString) {
                    _this._state.change({ searchString: globalBufferTerm }, true);
                    _this._findInput.select();
                }
            }
        }));
        _this._findInputFocused = CONTEXT_FIND_INPUT_FOCUSED.bindTo(contextKeyService);
        _this._findFocusTracker = _this._register(trackFocus(_this._findInput.inputBox.inputElement));
        _this._register(_this._findFocusTracker.onDidFocus(function () {
            _this._findInputFocused.set(true);
            _this._updateSearchScope();
        }));
        _this._register(_this._findFocusTracker.onDidBlur(function () {
            _this._findInputFocused.set(false);
        }));
        _this._replaceInputFocused = CONTEXT_REPLACE_INPUT_FOCUSED.bindTo(contextKeyService);
        _this._replaceFocusTracker = _this._register(trackFocus(_this._replaceInputBox.inputElement));
        _this._register(_this._replaceFocusTracker.onDidFocus(function () {
            _this._replaceInputFocused.set(true);
            _this._updateSearchScope();
        }));
        _this._register(_this._replaceFocusTracker.onDidBlur(function () {
            _this._replaceInputFocused.set(false);
        }));
        _this._codeEditor.addOverlayWidget(_this);
        _this._viewZone = new FindWidgetViewZone(0); // Put it before the first line then users can scroll beyond the first line.
        _this._applyTheme(themeService.getTheme());
        _this._register(themeService.onThemeChange(_this._applyTheme.bind(_this)));
        _this._register(_this._codeEditor.onDidChangeModel(function (e) {
            if (!_this._isVisible) {
                return;
            }
            if (_this._viewZoneId === undefined) {
                return;
            }
            _this._codeEditor.changeViewZones(function (accessor) {
                accessor.removeZone(_this._viewZoneId);
                _this._viewZoneId = undefined;
            });
        }));
        _this._register(_this._codeEditor.onDidScrollChange(function (e) {
            if (e.scrollTopChanged) {
                _this._layoutViewZone();
                return;
            }
            // for other scroll changes, layout the viewzone in next tick to avoid ruining current rendering.
            setTimeout(function () {
                _this._layoutViewZone();
            }, 0);
        }));
        return _this;
    }
    // ----- IOverlayWidget API
    FindWidget.prototype.getId = function () {
        return FindWidget.ID;
    };
    FindWidget.prototype.getDomNode = function () {
        return this._domNode;
    };
    FindWidget.prototype.getPosition = function () {
        if (this._isVisible) {
            return {
                preference: OverlayWidgetPositionPreference.TOP_RIGHT_CORNER
            };
        }
        return null;
    };
    // ----- React to state changes
    FindWidget.prototype._onStateChanged = function (e) {
        if (e.searchString) {
            this._findInput.setValue(this._state.searchString);
            this._updateButtons();
        }
        if (e.replaceString) {
            this._replaceInputBox.value = this._state.replaceString;
        }
        if (e.isRevealed) {
            if (this._state.isRevealed) {
                this._reveal(true);
            }
            else {
                this._hide(true);
            }
        }
        if (e.isReplaceRevealed) {
            if (this._state.isReplaceRevealed) {
                if (!this._codeEditor.getConfiguration().readOnly && !this._isReplaceVisible) {
                    this._isReplaceVisible = true;
                    this._replaceInputBox.width = this._findInput.inputBox.width;
                    this._updateButtons();
                }
            }
            else {
                if (this._isReplaceVisible) {
                    this._isReplaceVisible = false;
                    this._updateButtons();
                }
            }
        }
        if (e.isRegex) {
            this._findInput.setRegex(this._state.isRegex);
        }
        if (e.wholeWord) {
            this._findInput.setWholeWords(this._state.wholeWord);
        }
        if (e.matchCase) {
            this._findInput.setCaseSensitive(this._state.matchCase);
        }
        if (e.searchScope) {
            if (this._state.searchScope) {
                this._toggleSelectionFind.checked = true;
            }
            else {
                this._toggleSelectionFind.checked = false;
            }
            this._updateToggleSelectionFindButton();
        }
        if (e.searchString || e.matchesCount || e.matchesPosition) {
            var showRedOutline = (this._state.searchString.length > 0 && this._state.matchesCount === 0);
            toggleClass(this._domNode, 'no-results', showRedOutline);
            this._updateMatchesCount();
        }
        if (e.searchString || e.currentMatch) {
            this._layoutViewZone();
        }
    };
    FindWidget.prototype._updateMatchesCount = function () {
        this._matchesCount.style.minWidth = MAX_MATCHES_COUNT_WIDTH + 'px';
        if (this._state.matchesCount >= MATCHES_LIMIT) {
            this._matchesCount.title = NLS_MATCHES_COUNT_LIMIT_TITLE;
        }
        else {
            this._matchesCount.title = '';
        }
        // remove previous content
        if (this._matchesCount.firstChild) {
            this._matchesCount.removeChild(this._matchesCount.firstChild);
        }
        var label;
        if (this._state.matchesCount > 0) {
            var matchesCount = String(this._state.matchesCount);
            if (this._state.matchesCount >= MATCHES_LIMIT) {
                matchesCount += '+';
            }
            var matchesPosition = String(this._state.matchesPosition);
            if (matchesPosition === '0') {
                matchesPosition = '?';
            }
            label = format(NLS_MATCHES_LOCATION, matchesPosition, matchesCount);
        }
        else {
            label = NLS_NO_RESULTS;
        }
        this._matchesCount.appendChild(document.createTextNode(label));
        MAX_MATCHES_COUNT_WIDTH = Math.max(MAX_MATCHES_COUNT_WIDTH, this._matchesCount.clientWidth);
    };
    // ----- actions
    /**
     * If 'selection find' is ON we should not disable the button (its function is to cancel 'selection find').
     * If 'selection find' is OFF we enable the button only if there is a selection.
     */
    FindWidget.prototype._updateToggleSelectionFindButton = function () {
        var selection = this._codeEditor.getSelection();
        var isSelection = selection ? (selection.startLineNumber !== selection.endLineNumber || selection.startColumn !== selection.endColumn) : false;
        var isChecked = this._toggleSelectionFind.checked;
        this._toggleSelectionFind.setEnabled(this._isVisible && (isChecked || isSelection));
    };
    FindWidget.prototype._updateButtons = function () {
        this._findInput.setEnabled(this._isVisible);
        this._replaceInputBox.setEnabled(this._isVisible && this._isReplaceVisible);
        this._updateToggleSelectionFindButton();
        this._closeBtn.setEnabled(this._isVisible);
        var findInputIsNonEmpty = (this._state.searchString.length > 0);
        this._prevBtn.setEnabled(this._isVisible && findInputIsNonEmpty);
        this._nextBtn.setEnabled(this._isVisible && findInputIsNonEmpty);
        this._replaceBtn.setEnabled(this._isVisible && this._isReplaceVisible && findInputIsNonEmpty);
        this._replaceAllBtn.setEnabled(this._isVisible && this._isReplaceVisible && findInputIsNonEmpty);
        toggleClass(this._domNode, 'replaceToggled', this._isReplaceVisible);
        this._toggleReplaceBtn.toggleClass('collapse', !this._isReplaceVisible);
        this._toggleReplaceBtn.toggleClass('expand', this._isReplaceVisible);
        this._toggleReplaceBtn.setExpanded(this._isReplaceVisible);
        var canReplace = !this._codeEditor.getConfiguration().readOnly;
        this._toggleReplaceBtn.setEnabled(this._isVisible && canReplace);
    };
    FindWidget.prototype._reveal = function (animate) {
        var _this = this;
        if (!this._isVisible) {
            this._isVisible = true;
            var selection = this._codeEditor.getSelection();
            var isSelection = selection ? (selection.startLineNumber !== selection.endLineNumber || selection.startColumn !== selection.endColumn) : false;
            if (isSelection && this._codeEditor.getConfiguration().contribInfo.find.autoFindInSelection) {
                this._toggleSelectionFind.checked = true;
            }
            else {
                this._toggleSelectionFind.checked = false;
            }
            this._tryUpdateWidgetWidth();
            this._updateButtons();
            setTimeout(function () {
                addClass(_this._domNode, 'visible');
                _this._domNode.setAttribute('aria-hidden', 'false');
            }, 0);
            this._codeEditor.layoutOverlayWidget(this);
            var adjustEditorScrollTop = true;
            if (this._codeEditor.getConfiguration().contribInfo.find.seedSearchStringFromSelection && selection) {
                var editorCoords = getDomNodePagePosition(this._codeEditor.getDomNode());
                var startCoords = this._codeEditor.getScrolledVisiblePosition(selection.getStartPosition());
                var startLeft = editorCoords.left + startCoords.left;
                var startTop = startCoords.top;
                if (startTop < this._viewZone.heightInPx) {
                    if (selection.endLineNumber > selection.startLineNumber) {
                        adjustEditorScrollTop = false;
                    }
                    var leftOfFindWidget = getTopLeftOffset(this._domNode).left;
                    if (startLeft > leftOfFindWidget) {
                        adjustEditorScrollTop = false;
                    }
                    var endCoords = this._codeEditor.getScrolledVisiblePosition(selection.getEndPosition());
                    var endLeft = editorCoords.left + endCoords.left;
                    if (endLeft > leftOfFindWidget) {
                        adjustEditorScrollTop = false;
                    }
                }
            }
            this._showViewZone(adjustEditorScrollTop);
        }
    };
    FindWidget.prototype._hide = function (focusTheEditor) {
        var _this = this;
        if (this._isVisible) {
            this._isVisible = false;
            this._updateButtons();
            removeClass(this._domNode, 'visible');
            this._domNode.setAttribute('aria-hidden', 'true');
            if (focusTheEditor) {
                this._codeEditor.focus();
            }
            this._codeEditor.layoutOverlayWidget(this);
            this._codeEditor.changeViewZones(function (accessor) {
                if (_this._viewZoneId !== undefined) {
                    accessor.removeZone(_this._viewZoneId);
                    _this._viewZoneId = undefined;
                    _this._codeEditor.setScrollTop(_this._codeEditor.getScrollTop() - _this._viewZone.heightInPx);
                }
            });
        }
    };
    FindWidget.prototype._layoutViewZone = function () {
        var _this = this;
        if (!this._isVisible) {
            return;
        }
        if (this._viewZoneId !== undefined) {
            return;
        }
        this._codeEditor.changeViewZones(function (accessor) {
            if (_this._state.isReplaceRevealed) {
                _this._viewZone.heightInPx = FIND_REPLACE_AREA_HEIGHT;
            }
            else {
                _this._viewZone.heightInPx = FIND_INPUT_AREA_HEIGHT;
            }
            _this._viewZoneId = accessor.addZone(_this._viewZone);
            // scroll top adjust to make sure the editor doesn't scroll when adding viewzone at the beginning.
            _this._codeEditor.setScrollTop(_this._codeEditor.getScrollTop() + _this._viewZone.heightInPx);
        });
    };
    FindWidget.prototype._showViewZone = function (adjustScroll) {
        var _this = this;
        if (adjustScroll === void 0) { adjustScroll = true; }
        if (!this._isVisible) {
            return;
        }
        this._codeEditor.changeViewZones(function (accessor) {
            var scrollAdjustment = FIND_INPUT_AREA_HEIGHT;
            if (_this._viewZoneId !== undefined) {
                if (_this._state.isReplaceRevealed) {
                    _this._viewZone.heightInPx = FIND_REPLACE_AREA_HEIGHT;
                    scrollAdjustment = FIND_REPLACE_AREA_HEIGHT - FIND_INPUT_AREA_HEIGHT;
                }
                else {
                    _this._viewZone.heightInPx = FIND_INPUT_AREA_HEIGHT;
                    scrollAdjustment = FIND_INPUT_AREA_HEIGHT - FIND_REPLACE_AREA_HEIGHT;
                }
                accessor.removeZone(_this._viewZoneId);
            }
            else {
                _this._viewZone.heightInPx = FIND_INPUT_AREA_HEIGHT;
            }
            _this._viewZoneId = accessor.addZone(_this._viewZone);
            if (adjustScroll) {
                _this._codeEditor.setScrollTop(_this._codeEditor.getScrollTop() + scrollAdjustment);
            }
        });
    };
    FindWidget.prototype._applyTheme = function (theme) {
        var inputStyles = {
            inputActiveOptionBorder: theme.getColor(inputActiveOptionBorder),
            inputBackground: theme.getColor(inputBackground),
            inputForeground: theme.getColor(inputForeground),
            inputBorder: theme.getColor(inputBorder),
            inputValidationInfoBackground: theme.getColor(inputValidationInfoBackground),
            inputValidationInfoBorder: theme.getColor(inputValidationInfoBorder),
            inputValidationWarningBackground: theme.getColor(inputValidationWarningBackground),
            inputValidationWarningBorder: theme.getColor(inputValidationWarningBorder),
            inputValidationErrorBackground: theme.getColor(inputValidationErrorBackground),
            inputValidationErrorBorder: theme.getColor(inputValidationErrorBorder)
        };
        this._findInput.style(inputStyles);
        this._replaceInputBox.style(inputStyles);
    };
    FindWidget.prototype._tryUpdateWidgetWidth = function () {
        if (!this._isVisible) {
            return;
        }
        var editorWidth = this._codeEditor.getConfiguration().layoutInfo.width;
        var minimapWidth = this._codeEditor.getConfiguration().layoutInfo.minimapWidth;
        var collapsedFindWidget = false;
        var reducedFindWidget = false;
        var narrowFindWidget = false;
        if (this._resized) {
            var widgetWidth = getTotalWidth(this._domNode);
            if (widgetWidth > FIND_WIDGET_INITIAL_WIDTH) {
                // as the widget is resized by users, we may need to change the max width of the widget as the editor width changes.
                this._domNode.style.maxWidth = editorWidth - 28 - minimapWidth - 15 + "px";
                this._replaceInputBox.inputElement.style.width = getTotalWidth(this._findInput.inputBox.inputElement) + "px";
                return;
            }
        }
        if (FIND_WIDGET_INITIAL_WIDTH + 28 + minimapWidth >= editorWidth) {
            reducedFindWidget = true;
        }
        if (FIND_WIDGET_INITIAL_WIDTH + 28 + minimapWidth - MAX_MATCHES_COUNT_WIDTH >= editorWidth) {
            narrowFindWidget = true;
        }
        if (FIND_WIDGET_INITIAL_WIDTH + 28 + minimapWidth - MAX_MATCHES_COUNT_WIDTH >= editorWidth + 50) {
            collapsedFindWidget = true;
        }
        toggleClass(this._domNode, 'collapsed-find-widget', collapsedFindWidget);
        toggleClass(this._domNode, 'narrow-find-widget', narrowFindWidget);
        toggleClass(this._domNode, 'reduced-find-widget', reducedFindWidget);
        if (!narrowFindWidget && !collapsedFindWidget) {
            // the minimal left offset of findwidget is 15px.
            this._domNode.style.maxWidth = editorWidth - 28 - minimapWidth - 15 + "px";
        }
        if (this._resized) {
            var findInputWidth = getTotalWidth(this._findInput.inputBox.inputElement);
            if (findInputWidth > 0) {
                this._replaceInputBox.inputElement.style.width = findInputWidth + "px";
            }
        }
    };
    // ----- Public
    FindWidget.prototype.focusFindInput = function () {
        this._findInput.select();
        // Edge browser requires focus() in addition to select()
        this._findInput.focus();
    };
    FindWidget.prototype.focusReplaceInput = function () {
        this._replaceInputBox.select();
        // Edge browser requires focus() in addition to select()
        this._replaceInputBox.focus();
    };
    FindWidget.prototype.highlightFindOptions = function () {
        this._findInput.highlightFindOptions();
    };
    FindWidget.prototype._updateSearchScope = function () {
        if (this._toggleSelectionFind.checked) {
            var selection = this._codeEditor.getSelection();
            if (selection.endColumn === 1 && selection.endLineNumber > selection.startLineNumber) {
                selection = selection.setEndPosition(selection.endLineNumber - 1, 1);
            }
            var currentMatch = this._state.currentMatch;
            if (selection.startLineNumber !== selection.endLineNumber) {
                if (!Range.equalsRange(selection, currentMatch)) {
                    // Reseed find scope
                    this._state.change({ searchScope: selection }, true);
                }
            }
        }
    };
    FindWidget.prototype._onFindInputMouseDown = function (e) {
        // on linux, middle key does pasting.
        if (e.middleButton) {
            e.stopPropagation();
        }
    };
    FindWidget.prototype._onFindInputKeyDown = function (e) {
        if (e.equals(3 /* Enter */)) {
            this._codeEditor.getAction(FIND_IDS.NextMatchFindAction).run().done(null, onUnexpectedError);
            e.preventDefault();
            return;
        }
        if (e.equals(1024 /* Shift */ | 3 /* Enter */)) {
            this._codeEditor.getAction(FIND_IDS.PreviousMatchFindAction).run().done(null, onUnexpectedError);
            e.preventDefault();
            return;
        }
        if (e.equals(2 /* Tab */)) {
            if (this._isReplaceVisible) {
                this._replaceInputBox.focus();
            }
            else {
                this._findInput.focusOnCaseSensitive();
            }
            e.preventDefault();
            return;
        }
        if (e.equals(2048 /* CtrlCmd */ | 18 /* DownArrow */)) {
            this._codeEditor.focus();
            e.preventDefault();
            return;
        }
    };
    FindWidget.prototype._onReplaceInputKeyDown = function (e) {
        if (e.equals(3 /* Enter */)) {
            this._controller.replace();
            e.preventDefault();
            return;
        }
        if (e.equals(2048 /* CtrlCmd */ | 3 /* Enter */)) {
            this._controller.replaceAll();
            e.preventDefault();
            return;
        }
        if (e.equals(2 /* Tab */)) {
            this._findInput.focusOnCaseSensitive();
            e.preventDefault();
            return;
        }
        if (e.equals(1024 /* Shift */ | 2 /* Tab */)) {
            this._findInput.focus();
            e.preventDefault();
            return;
        }
        if (e.equals(2048 /* CtrlCmd */ | 18 /* DownArrow */)) {
            this._codeEditor.focus();
            e.preventDefault();
            return;
        }
    };
    // ----- sash
    FindWidget.prototype.getHorizontalSashTop = function (sash) {
        return 0;
    };
    FindWidget.prototype.getHorizontalSashLeft = function (sash) {
        return 0;
    };
    FindWidget.prototype.getHorizontalSashWidth = function (sash) {
        return 500;
    };
    // ----- initialization
    FindWidget.prototype._keybindingLabelFor = function (actionId) {
        var kb = this._keybindingService.lookupKeybinding(actionId);
        if (!kb) {
            return '';
        }
        return " (" + kb.getLabel() + ")";
    };
    FindWidget.prototype._buildFindPart = function () {
        var _this = this;
        // Find input
        this._findInput = this._register(new FindInput(null, this._contextViewProvider, {
            width: FIND_INPUT_AREA_WIDTH,
            label: NLS_FIND_INPUT_LABEL,
            placeholder: NLS_FIND_INPUT_PLACEHOLDER,
            appendCaseSensitiveLabel: this._keybindingLabelFor(FIND_IDS.ToggleCaseSensitiveCommand),
            appendWholeWordsLabel: this._keybindingLabelFor(FIND_IDS.ToggleWholeWordCommand),
            appendRegexLabel: this._keybindingLabelFor(FIND_IDS.ToggleRegexCommand),
            validation: function (value) {
                if (value.length === 0) {
                    return null;
                }
                if (!_this._findInput.getRegex()) {
                    return null;
                }
                try {
                    /* tslint:enable:no-unused-expression */
                    return null;
                }
                catch (e) {
                    return { content: e.message };
                }
            }
        }));
        this._findInput.setRegex(!!this._state.isRegex);
        this._findInput.setCaseSensitive(!!this._state.matchCase);
        this._findInput.setWholeWords(!!this._state.wholeWord);
        this._register(this._findInput.onKeyDown(function (e) { return _this._onFindInputKeyDown(e); }));
        this._register(this._findInput.onInput(function () {
            _this._state.change({ searchString: _this._findInput.getValue() }, true);
        }));
        this._register(this._findInput.onDidOptionChange(function () {
            _this._state.change({
                isRegex: _this._findInput.getRegex(),
                wholeWord: _this._findInput.getWholeWords(),
                matchCase: _this._findInput.getCaseSensitive()
            }, true);
        }));
        this._register(this._findInput.onCaseSensitiveKeyDown(function (e) {
            if (e.equals(1024 /* Shift */ | 2 /* Tab */)) {
                if (_this._isReplaceVisible) {
                    _this._replaceInputBox.focus();
                    e.preventDefault();
                }
            }
        }));
        if (isLinux) {
            this._register(this._findInput.onMouseDown(function (e) { return _this._onFindInputMouseDown(e); }));
        }
        this._matchesCount = document.createElement('div');
        this._matchesCount.className = 'matchesCount';
        this._updateMatchesCount();
        // Previous button
        this._prevBtn = this._register(new SimpleButton({
            label: NLS_PREVIOUS_MATCH_BTN_LABEL + this._keybindingLabelFor(FIND_IDS.PreviousMatchFindAction),
            className: 'previous',
            onTrigger: function () {
                _this._codeEditor.getAction(FIND_IDS.PreviousMatchFindAction).run().done(null, onUnexpectedError);
            }
        }));
        // Next button
        this._nextBtn = this._register(new SimpleButton({
            label: NLS_NEXT_MATCH_BTN_LABEL + this._keybindingLabelFor(FIND_IDS.NextMatchFindAction),
            className: 'next',
            onTrigger: function () {
                _this._codeEditor.getAction(FIND_IDS.NextMatchFindAction).run().done(null, onUnexpectedError);
            }
        }));
        var findPart = document.createElement('div');
        findPart.className = 'find-part';
        findPart.appendChild(this._findInput.domNode);
        findPart.appendChild(this._matchesCount);
        findPart.appendChild(this._prevBtn.domNode);
        findPart.appendChild(this._nextBtn.domNode);
        // Toggle selection button
        this._toggleSelectionFind = this._register(new SimpleCheckbox({
            parent: findPart,
            title: NLS_TOGGLE_SELECTION_FIND_TITLE + this._keybindingLabelFor(FIND_IDS.ToggleSearchScopeCommand),
            onChange: function () {
                if (_this._toggleSelectionFind.checked) {
                    var selection = _this._codeEditor.getSelection();
                    if (selection.endColumn === 1 && selection.endLineNumber > selection.startLineNumber) {
                        selection = selection.setEndPosition(selection.endLineNumber - 1, 1);
                    }
                    if (!selection.isEmpty()) {
                        _this._state.change({ searchScope: selection }, true);
                    }
                }
                else {
                    _this._state.change({ searchScope: null }, true);
                }
            }
        }));
        // Close button
        this._closeBtn = this._register(new SimpleButton({
            label: NLS_CLOSE_BTN_LABEL + this._keybindingLabelFor(FIND_IDS.CloseFindWidgetCommand),
            className: 'close-fw',
            onTrigger: function () {
                _this._state.change({ isRevealed: false, searchScope: null }, false);
            },
            onKeyDown: function (e) {
                if (e.equals(2 /* Tab */)) {
                    if (_this._isReplaceVisible) {
                        if (_this._replaceBtn.isEnabled()) {
                            _this._replaceBtn.focus();
                        }
                        else {
                            _this._codeEditor.focus();
                        }
                        e.preventDefault();
                    }
                }
            }
        }));
        findPart.appendChild(this._closeBtn.domNode);
        return findPart;
    };
    FindWidget.prototype._buildReplacePart = function () {
        var _this = this;
        // Replace input
        var replaceInput = document.createElement('div');
        replaceInput.className = 'replace-input';
        replaceInput.style.width = REPLACE_INPUT_AREA_WIDTH + 'px';
        this._replaceInputBox = this._register(new InputBox(replaceInput, null, {
            ariaLabel: NLS_REPLACE_INPUT_LABEL,
            placeholder: NLS_REPLACE_INPUT_PLACEHOLDER
        }));
        this._register(addStandardDisposableListener(this._replaceInputBox.inputElement, 'keydown', function (e) { return _this._onReplaceInputKeyDown(e); }));
        this._register(addStandardDisposableListener(this._replaceInputBox.inputElement, 'input', function (e) {
            _this._state.change({ replaceString: _this._replaceInputBox.value }, false);
        }));
        // Replace one button
        this._replaceBtn = this._register(new SimpleButton({
            label: NLS_REPLACE_BTN_LABEL + this._keybindingLabelFor(FIND_IDS.ReplaceOneAction),
            className: 'replace',
            onTrigger: function () {
                _this._controller.replace();
            },
            onKeyDown: function (e) {
                if (e.equals(1024 /* Shift */ | 2 /* Tab */)) {
                    _this._closeBtn.focus();
                    e.preventDefault();
                }
            }
        }));
        // Replace all button
        this._replaceAllBtn = this._register(new SimpleButton({
            label: NLS_REPLACE_ALL_BTN_LABEL + this._keybindingLabelFor(FIND_IDS.ReplaceAllAction),
            className: 'replace-all',
            onTrigger: function () {
                _this._controller.replaceAll();
            }
        }));
        var replacePart = document.createElement('div');
        replacePart.className = 'replace-part';
        replacePart.appendChild(replaceInput);
        replacePart.appendChild(this._replaceBtn.domNode);
        replacePart.appendChild(this._replaceAllBtn.domNode);
        return replacePart;
    };
    FindWidget.prototype._buildDomNode = function () {
        var _this = this;
        // Find part
        var findPart = this._buildFindPart();
        // Replace part
        var replacePart = this._buildReplacePart();
        // Toggle replace button
        this._toggleReplaceBtn = this._register(new SimpleButton({
            label: NLS_TOGGLE_REPLACE_MODE_BTN_LABEL,
            className: 'toggle left',
            onTrigger: function () {
                _this._state.change({ isReplaceRevealed: !_this._isReplaceVisible }, false);
                if (_this._isReplaceVisible) {
                    _this._replaceInputBox.width = _this._findInput.inputBox.width;
                }
                _this._showViewZone();
            }
        }));
        this._toggleReplaceBtn.toggleClass('expand', this._isReplaceVisible);
        this._toggleReplaceBtn.toggleClass('collapse', !this._isReplaceVisible);
        this._toggleReplaceBtn.setExpanded(this._isReplaceVisible);
        // Widget
        this._domNode = document.createElement('div');
        this._domNode.className = 'editor-widget find-widget';
        this._domNode.setAttribute('aria-hidden', 'true');
        // We need to set this explicitly, otherwise on IE11, the width inheritence of flex doesn't work.
        this._domNode.style.width = FIND_WIDGET_INITIAL_WIDTH + "px";
        this._domNode.appendChild(this._toggleReplaceBtn.domNode);
        this._domNode.appendChild(findPart);
        this._domNode.appendChild(replacePart);
        this._buildSash();
    };
    FindWidget.prototype._buildSash = function () {
        var _this = this;
        this._resizeSash = new Sash(this._domNode, this, { orientation: Orientation.VERTICAL });
        this._resized = false;
        var originalWidth = FIND_WIDGET_INITIAL_WIDTH;
        this._register(this._resizeSash.onDidStart(function (e) {
            originalWidth = getTotalWidth(_this._domNode);
        }));
        this._register(this._resizeSash.onDidChange(function (evt) {
            _this._resized = true;
            var width = originalWidth + evt.startX - evt.currentX;
            if (width < FIND_WIDGET_INITIAL_WIDTH) {
                // narrow down the find widget should be handled by CSS.
                return;
            }
            var inputBoxWidth = width - FIND_ALL_CONTROLS_WIDTH;
            var maxWidth = parseFloat(getComputedStyle(_this._domNode).maxWidth) || 0;
            if (width > maxWidth) {
                return;
            }
            _this._domNode.style.width = width + "px";
            if (_this._isReplaceVisible) {
                _this._replaceInputBox.width = inputBoxWidth;
            }
        }));
    };
    FindWidget.ID = 'editor.contrib.findWidget';
    return FindWidget;
}(Widget));
var SimpleCheckbox = /** @class */ (function (_super) {
    __extends$b(SimpleCheckbox, _super);
    function SimpleCheckbox(opts) {
        var _this = _super.call(this) || this;
        _this._opts = opts;
        _this._domNode = document.createElement('div');
        _this._domNode.className = 'monaco-checkbox';
        _this._domNode.title = _this._opts.title;
        _this._domNode.tabIndex = 0;
        _this._checkbox = document.createElement('input');
        _this._checkbox.type = 'checkbox';
        _this._checkbox.className = 'checkbox';
        _this._checkbox.id = 'checkbox-' + SimpleCheckbox._COUNTER++;
        _this._checkbox.tabIndex = -1;
        _this._label = document.createElement('label');
        _this._label.className = 'label';
        // Connect the label and the checkbox. Checkbox will get checked when the label receives a click.
        _this._label.htmlFor = _this._checkbox.id;
        _this._label.tabIndex = -1;
        _this._domNode.appendChild(_this._checkbox);
        _this._domNode.appendChild(_this._label);
        _this._opts.parent.appendChild(_this._domNode);
        _this.onchange(_this._checkbox, function (e) {
            _this._opts.onChange();
        });
        return _this;
    }
    Object.defineProperty(SimpleCheckbox.prototype, "domNode", {
        get: function () {
            return this._domNode;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SimpleCheckbox.prototype, "checked", {
        get: function () {
            return this._checkbox.checked;
        },
        set: function (newValue) {
            this._checkbox.checked = newValue;
        },
        enumerable: true,
        configurable: true
    });
    SimpleCheckbox.prototype.focus = function () {
        this._checkbox.focus();
    };
    SimpleCheckbox.prototype.enable = function () {
        this._checkbox.removeAttribute('disabled');
    };
    SimpleCheckbox.prototype.disable = function () {
        this._checkbox.disabled = true;
    };
    SimpleCheckbox.prototype.setEnabled = function (enabled) {
        if (enabled) {
            this.enable();
            this.domNode.tabIndex = 0;
        }
        else {
            this.disable();
            this.domNode.tabIndex = -1;
        }
    };
    SimpleCheckbox._COUNTER = 0;
    return SimpleCheckbox;
}(Widget));
var SimpleButton = /** @class */ (function (_super) {
    __extends$b(SimpleButton, _super);
    function SimpleButton(opts) {
        var _this = _super.call(this) || this;
        _this._opts = opts;
        _this._domNode = document.createElement('div');
        _this._domNode.title = _this._opts.label;
        _this._domNode.tabIndex = 0;
        _this._domNode.className = 'button ' + _this._opts.className;
        _this._domNode.setAttribute('role', 'button');
        _this._domNode.setAttribute('aria-label', _this._opts.label);
        _this.onclick(_this._domNode, function (e) {
            _this._opts.onTrigger();
            e.preventDefault();
        });
        _this.onkeydown(_this._domNode, function (e) {
            if (e.equals(10 /* Space */) || e.equals(3 /* Enter */)) {
                _this._opts.onTrigger();
                e.preventDefault();
                return;
            }
            if (_this._opts.onKeyDown) {
                _this._opts.onKeyDown(e);
            }
        });
        return _this;
    }
    Object.defineProperty(SimpleButton.prototype, "domNode", {
        get: function () {
            return this._domNode;
        },
        enumerable: true,
        configurable: true
    });
    SimpleButton.prototype.isEnabled = function () {
        return (this._domNode.tabIndex >= 0);
    };
    SimpleButton.prototype.focus = function () {
        this._domNode.focus();
    };
    SimpleButton.prototype.setEnabled = function (enabled) {
        toggleClass(this._domNode, 'disabled', !enabled);
        this._domNode.setAttribute('aria-disabled', String(!enabled));
        this._domNode.tabIndex = enabled ? 0 : -1;
    };
    SimpleButton.prototype.setExpanded = function (expanded) {
        this._domNode.setAttribute('aria-expanded', String(!!expanded));
    };
    SimpleButton.prototype.toggleClass = function (className, shouldHaveIt) {
        toggleClass(this._domNode, className, shouldHaveIt);
    };
    return SimpleButton;
}(Widget));
// theming
registerThemingParticipant(function (theme, collector) {
    var addBackgroundColorRule = function (selector, color) {
        if (color) {
            collector.addRule(".monaco-editor " + selector + " { background-color: " + color + "; }");
        }
    };
    addBackgroundColorRule('.findMatch', theme.getColor(editorFindMatchHighlight));
    addBackgroundColorRule('.currentFindMatch', theme.getColor(editorFindMatch));
    addBackgroundColorRule('.findScope', theme.getColor(editorFindRangeHighlight));
    var widgetBackground = theme.getColor(editorWidgetBackground);
    addBackgroundColorRule('.find-widget', widgetBackground);
    var widgetShadowColor = theme.getColor(widgetShadow);
    if (widgetShadowColor) {
        collector.addRule(".monaco-editor .find-widget { box-shadow: 0 2px 8px " + widgetShadowColor + "; }");
    }
    var findMatchHighlightBorder = theme.getColor(editorFindMatchHighlightBorder);
    if (findMatchHighlightBorder) {
        collector.addRule(".monaco-editor .findMatch { border: 1px " + (theme.type === 'hc' ? 'dotted' : 'solid') + " " + findMatchHighlightBorder + "; box-sizing: border-box; }");
    }
    var findMatchBorder = theme.getColor(editorFindMatchBorder);
    if (findMatchBorder) {
        collector.addRule(".monaco-editor .currentFindMatch { border: 2px solid " + findMatchBorder + "; padding: 1px; box-sizing: border-box; }");
    }
    var findRangeHighlightBorder = theme.getColor(editorFindRangeHighlightBorder);
    if (findRangeHighlightBorder) {
        collector.addRule(".monaco-editor .findScope { border: 1px " + (theme.type === 'hc' ? 'dashed' : 'solid') + " " + findRangeHighlightBorder + "; }");
    }
    var hcBorder = theme.getColor(contrastBorder);
    if (hcBorder) {
        collector.addRule(".monaco-editor .find-widget { border: 2px solid " + hcBorder + "; }");
    }
    var error = theme.getColor(errorForeground);
    if (error) {
        collector.addRule(".monaco-editor .find-widget.no-results .matchesCount { color: " + error + "; }");
    }
    var border = theme.getColor(editorWidgetBorder);
    if (border) {
        collector.addRule(".monaco-editor .find-widget .monaco-sash { background-color: " + border + "; width: 3px !important; margin-left: -4px;}");
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$c = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var FindOptionsWidget = /** @class */ (function (_super) {
    __extends$c(FindOptionsWidget, _super);
    function FindOptionsWidget(editor, state, keybindingService, themeService) {
        var _this = _super.call(this) || this;
        _this._hideSoon = _this._register(new RunOnceScheduler(function () { return _this._hide(); }, 2000));
        _this._isVisible = false;
        _this._editor = editor;
        _this._state = state;
        _this._keybindingService = keybindingService;
        _this._domNode = document.createElement('div');
        _this._domNode.className = 'findOptionsWidget';
        _this._domNode.style.display = 'none';
        _this._domNode.style.top = '10px';
        _this._domNode.setAttribute('role', 'presentation');
        _this._domNode.setAttribute('aria-hidden', 'true');
        var inputActiveOptionBorderColor = themeService.getTheme().getColor(inputActiveOptionBorder);
        _this.caseSensitive = _this._register(new CaseSensitiveCheckbox({
            appendTitle: _this._keybindingLabelFor(FIND_IDS.ToggleCaseSensitiveCommand),
            isChecked: _this._state.matchCase,
            onChange: function (viaKeyboard) {
                _this._state.change({
                    matchCase: _this.caseSensitive.checked
                }, false);
            },
            inputActiveOptionBorder: inputActiveOptionBorderColor
        }));
        _this._domNode.appendChild(_this.caseSensitive.domNode);
        _this.wholeWords = _this._register(new WholeWordsCheckbox({
            appendTitle: _this._keybindingLabelFor(FIND_IDS.ToggleWholeWordCommand),
            isChecked: _this._state.wholeWord,
            onChange: function (viaKeyboard) {
                _this._state.change({
                    wholeWord: _this.wholeWords.checked
                }, false);
            },
            inputActiveOptionBorder: inputActiveOptionBorderColor
        }));
        _this._domNode.appendChild(_this.wholeWords.domNode);
        _this.regex = _this._register(new RegexCheckbox({
            appendTitle: _this._keybindingLabelFor(FIND_IDS.ToggleRegexCommand),
            isChecked: _this._state.isRegex,
            onChange: function (viaKeyboard) {
                _this._state.change({
                    isRegex: _this.regex.checked
                }, false);
            },
            inputActiveOptionBorder: inputActiveOptionBorderColor
        }));
        _this._domNode.appendChild(_this.regex.domNode);
        _this._editor.addOverlayWidget(_this);
        _this._register(_this._state.onFindReplaceStateChange(function (e) {
            var somethingChanged = false;
            if (e.isRegex) {
                _this.regex.checked = _this._state.isRegex;
                somethingChanged = true;
            }
            if (e.wholeWord) {
                _this.wholeWords.checked = _this._state.wholeWord;
                somethingChanged = true;
            }
            if (e.matchCase) {
                _this.caseSensitive.checked = _this._state.matchCase;
                somethingChanged = true;
            }
            if (!_this._state.isRevealed && somethingChanged) {
                _this._revealTemporarily();
            }
        }));
        _this._register(addDisposableNonBubblingMouseOutListener(_this._domNode, function (e) { return _this._onMouseOut(); }));
        _this._register(addDisposableListener(_this._domNode, 'mouseover', function (e) { return _this._onMouseOver(); }));
        _this._applyTheme(themeService.getTheme());
        _this._register(themeService.onThemeChange(_this._applyTheme.bind(_this)));
        return _this;
    }
    FindOptionsWidget.prototype._keybindingLabelFor = function (actionId) {
        var kb = this._keybindingService.lookupKeybinding(actionId);
        if (!kb) {
            return '';
        }
        return " (" + kb.getLabel() + ")";
    };
    FindOptionsWidget.prototype.dispose = function () {
        this._editor.removeOverlayWidget(this);
        _super.prototype.dispose.call(this);
    };
    // ----- IOverlayWidget API
    FindOptionsWidget.prototype.getId = function () {
        return FindOptionsWidget.ID;
    };
    FindOptionsWidget.prototype.getDomNode = function () {
        return this._domNode;
    };
    FindOptionsWidget.prototype.getPosition = function () {
        return {
            preference: OverlayWidgetPositionPreference.TOP_RIGHT_CORNER
        };
    };
    FindOptionsWidget.prototype.highlightFindOptions = function () {
        this._revealTemporarily();
    };
    FindOptionsWidget.prototype._revealTemporarily = function () {
        this._show();
        this._hideSoon.schedule();
    };
    FindOptionsWidget.prototype._onMouseOut = function () {
        this._hideSoon.schedule();
    };
    FindOptionsWidget.prototype._onMouseOver = function () {
        this._hideSoon.cancel();
    };
    FindOptionsWidget.prototype._show = function () {
        if (this._isVisible) {
            return;
        }
        this._isVisible = true;
        this._domNode.style.display = 'block';
    };
    FindOptionsWidget.prototype._hide = function () {
        if (!this._isVisible) {
            return;
        }
        this._isVisible = false;
        this._domNode.style.display = 'none';
    };
    FindOptionsWidget.prototype._applyTheme = function (theme) {
        var inputStyles = { inputActiveOptionBorder: theme.getColor(inputActiveOptionBorder) };
        this.caseSensitive.style(inputStyles);
        this.wholeWords.style(inputStyles);
        this.regex.style(inputStyles);
    };
    FindOptionsWidget.ID = 'editor.contrib.findOptionsWidget';
    return FindOptionsWidget;
}(Widget));
registerThemingParticipant(function (theme, collector) {
    var widgetBackground = theme.getColor(editorWidgetBackground);
    if (widgetBackground) {
        collector.addRule(".monaco-editor .findOptionsWidget { background-color: " + widgetBackground + "; }");
    }
    var widgetShadowColor = theme.getColor(widgetShadow);
    if (widgetShadowColor) {
        collector.addRule(".monaco-editor .findOptionsWidget { box-shadow: 0 2px 8px " + widgetShadowColor + "; }");
    }
    var hcBorder = theme.getColor(contrastBorder);
    if (hcBorder) {
        collector.addRule(".monaco-editor .findOptionsWidget { border: 2px solid " + hcBorder + "; }");
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$d = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate$3 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$3 = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
function getSelectionSearchString(editor) {
    var selection = editor.getSelection();
    // if selection spans multiple lines, default search string to empty
    if (selection.startLineNumber === selection.endLineNumber) {
        if (selection.isEmpty()) {
            var wordAtPosition = editor.getModel().getWordAtPosition(selection.getStartPosition());
            if (wordAtPosition) {
                return wordAtPosition.word;
            }
        }
        else {
            return editor.getModel().getValueInRange(selection);
        }
    }
    return null;
}
var CommonFindController = /** @class */ (function (_super) {
    __extends$d(CommonFindController, _super);
    function CommonFindController(editor, contextKeyService, storageService, clipboardService) {
        var _this = _super.call(this) || this;
        _this._editor = editor;
        _this._findWidgetVisible = CONTEXT_FIND_WIDGET_VISIBLE.bindTo(contextKeyService);
        _this._storageService = storageService;
        _this._clipboardService = clipboardService;
        _this._updateHistoryDelayer = new Delayer(500);
        _this._currentHistoryNavigator = new HistoryNavigator();
        _this._state = _this._register(new FindReplaceState());
        _this.loadQueryState();
        _this._register(_this._state.onFindReplaceStateChange(function (e) { return _this._onStateChanged(e); }));
        _this._model = null;
        _this._register(_this._editor.onDidChangeModel(function () {
            var shouldRestartFind = (_this._editor.getModel() && _this._state.isRevealed);
            _this.disposeModel();
            _this._state.change({
                searchScope: null,
                matchCase: _this._storageService.getBoolean('editor.matchCase', StorageScope.WORKSPACE, false),
                wholeWord: _this._storageService.getBoolean('editor.wholeWord', StorageScope.WORKSPACE, false),
                isRegex: _this._storageService.getBoolean('editor.isRegex', StorageScope.WORKSPACE, false)
            }, false);
            if (shouldRestartFind) {
                _this._start({
                    forceRevealReplace: false,
                    seedSearchStringFromSelection: false && _this._editor.getConfiguration().contribInfo.find.seedSearchStringFromSelection,
                    seedSearchStringFromGlobalClipboard: false,
                    shouldFocus: 0 /* NoFocusChange */,
                    shouldAnimate: false,
                });
            }
        }));
        return _this;
    }
    CommonFindController.get = function (editor) {
        return editor.getContribution(CommonFindController.ID);
    };
    CommonFindController.prototype.dispose = function () {
        this.disposeModel();
        _super.prototype.dispose.call(this);
    };
    CommonFindController.prototype.disposeModel = function () {
        if (this._model) {
            this._model.dispose();
            this._model = null;
        }
    };
    CommonFindController.prototype.getId = function () {
        return CommonFindController.ID;
    };
    CommonFindController.prototype._onStateChanged = function (e) {
        this.saveQueryState(e);
        if (e.updateHistory && e.searchString) {
            this._delayedUpdateHistory();
        }
        if (e.isRevealed) {
            if (this._state.isRevealed) {
                this._findWidgetVisible.set(true);
            }
            else {
                this._findWidgetVisible.reset();
                this.disposeModel();
            }
        }
        if (e.searchString) {
            this.setGlobalBufferTerm(this._state.searchString);
        }
    };
    CommonFindController.prototype.saveQueryState = function (e) {
        if (e.isRegex) {
            this._storageService.store('editor.isRegex', this._state.actualIsRegex, StorageScope.WORKSPACE);
        }
        if (e.wholeWord) {
            this._storageService.store('editor.wholeWord', this._state.actualWholeWord, StorageScope.WORKSPACE);
        }
        if (e.matchCase) {
            this._storageService.store('editor.matchCase', this._state.actualMatchCase, StorageScope.WORKSPACE);
        }
    };
    CommonFindController.prototype.loadQueryState = function () {
        this._state.change({
            matchCase: this._storageService.getBoolean('editor.matchCase', StorageScope.WORKSPACE, this._state.matchCase),
            wholeWord: this._storageService.getBoolean('editor.wholeWord', StorageScope.WORKSPACE, this._state.wholeWord),
            isRegex: this._storageService.getBoolean('editor.isRegex', StorageScope.WORKSPACE, this._state.isRegex)
        }, false);
    };
    CommonFindController.prototype._delayedUpdateHistory = function () {
        this._updateHistoryDelayer.trigger(this._updateHistory.bind(this));
    };
    CommonFindController.prototype._updateHistory = function () {
        if (this._state.searchString) {
            this._currentHistoryNavigator.add(this._state.searchString);
        }
    };
    CommonFindController.prototype.getState = function () {
        return this._state;
    };
    CommonFindController.prototype.getHistory = function () {
        return this._currentHistoryNavigator;
    };
    CommonFindController.prototype.closeFindWidget = function () {
        this._state.change({
            isRevealed: false,
            searchScope: null
        }, false);
        this._editor.focus();
    };
    CommonFindController.prototype.toggleCaseSensitive = function () {
        this._state.change({ matchCase: !this._state.matchCase }, false);
    };
    CommonFindController.prototype.toggleWholeWords = function () {
        this._state.change({ wholeWord: !this._state.wholeWord }, false);
    };
    CommonFindController.prototype.toggleRegex = function () {
        this._state.change({ isRegex: !this._state.isRegex }, false);
    };
    CommonFindController.prototype.toggleSearchScope = function () {
        if (this._state.searchScope) {
            this._state.change({ searchScope: null }, true);
        }
        else {
            var selection = this._editor.getSelection();
            if (selection.endColumn === 1 && selection.endLineNumber > selection.startLineNumber) {
                selection = selection.setEndPosition(selection.endLineNumber - 1, 1);
            }
            if (!selection.isEmpty()) {
                this._state.change({ searchScope: selection }, true);
            }
        }
    };
    CommonFindController.prototype.setSearchString = function (searchString) {
        if (this._state.isRegex) {
            searchString = escapeRegExpCharacters(searchString);
        }
        this._state.change({ searchString: searchString }, false);
    };
    CommonFindController.prototype.highlightFindOptions = function () {
        // overwritten in subclass
    };
    CommonFindController.prototype._start = function (opts) {
        this.disposeModel();
        if (!this._editor.getModel()) {
            // cannot do anything with an editor that doesn't have a model...
            return;
        }
        var stateChanges = {
            isRevealed: true
        };
        if (opts.seedSearchStringFromSelection) {
            var selectionSearchString = getSelectionSearchString(this._editor);
            if (selectionSearchString) {
                if (this._state.isRegex) {
                    stateChanges.searchString = escapeRegExpCharacters(selectionSearchString);
                }
                else {
                    stateChanges.searchString = selectionSearchString;
                }
            }
        }
        if (!stateChanges.searchString && opts.seedSearchStringFromGlobalClipboard) {
            var selectionSearchString = this.getGlobalBufferTerm();
            if (selectionSearchString) {
                stateChanges.searchString = selectionSearchString;
            }
        }
        // Overwrite isReplaceRevealed
        if (opts.forceRevealReplace) {
            stateChanges.isReplaceRevealed = true;
        }
        else if (!this._findWidgetVisible.get()) {
            stateChanges.isReplaceRevealed = false;
        }
        this._state.change(stateChanges, false);
        if (!this._model) {
            this._model = new FindModelBoundToEditorModel(this._editor, this._state);
        }
    };
    CommonFindController.prototype.start = function (opts) {
        this._start(opts);
    };
    CommonFindController.prototype.moveToNextMatch = function () {
        if (this._model) {
            this._model.moveToNextMatch();
            return true;
        }
        return false;
    };
    CommonFindController.prototype.moveToPrevMatch = function () {
        if (this._model) {
            this._model.moveToPrevMatch();
            return true;
        }
        return false;
    };
    CommonFindController.prototype.replace = function () {
        if (this._model) {
            this._model.replace();
            return true;
        }
        return false;
    };
    CommonFindController.prototype.replaceAll = function () {
        if (this._model) {
            this._model.replaceAll();
            return true;
        }
        return false;
    };
    CommonFindController.prototype.selectAllMatches = function () {
        if (this._model) {
            this._model.selectAllMatches();
            this._editor.focus();
            return true;
        }
        return false;
    };
    CommonFindController.prototype.showPreviousFindTerm = function () {
        var previousTerm = this._currentHistoryNavigator.previous();
        if (previousTerm) {
            this._state.change({ searchString: previousTerm }, false, false);
        }
        return true;
    };
    CommonFindController.prototype.showNextFindTerm = function () {
        var nextTerm = this._currentHistoryNavigator.next();
        if (nextTerm) {
            this._state.change({ searchString: nextTerm }, false, false);
        }
        return true;
    };
    CommonFindController.prototype.getGlobalBufferTerm = function () {
        if (this._editor.getConfiguration().contribInfo.find.globalFindClipboard
            && this._clipboardService
            && !this._editor.getModel().isTooLargeForSyncing()) {
            return this._clipboardService.readFindText();
        }
        return '';
    };
    CommonFindController.prototype.setGlobalBufferTerm = function (text) {
        if (this._editor.getConfiguration().contribInfo.find.globalFindClipboard
            && this._clipboardService
            && !this._editor.getModel().isTooLargeForSyncing()) {
            this._clipboardService.writeFindText(text);
        }
    };
    CommonFindController.ID = 'editor.contrib.findController';
    CommonFindController = __decorate$3([
        __param$3(1, IContextKeyService),
        __param$3(2, IStorageService),
        __param$3(3, IClipboardService)
    ], CommonFindController);
    return CommonFindController;
}(Disposable));
var FindController = /** @class */ (function (_super) {
    __extends$d(FindController, _super);
    function FindController(editor, _contextViewService, _contextKeyService, _keybindingService, _themeService, storageService, clipboardService) {
        var _this = _super.call(this, editor, _contextKeyService, storageService, clipboardService) || this;
        _this._contextViewService = _contextViewService;
        _this._contextKeyService = _contextKeyService;
        _this._keybindingService = _keybindingService;
        _this._themeService = _themeService;
        return _this;
    }
    FindController.prototype._start = function (opts) {
        if (!this._widget) {
            this._createFindWidget();
        }
        _super.prototype._start.call(this, opts);
        if (opts.shouldFocus === 2 /* FocusReplaceInput */) {
            this._widget.focusReplaceInput();
        }
        else if (opts.shouldFocus === 1 /* FocusFindInput */) {
            this._widget.focusFindInput();
        }
    };
    FindController.prototype.highlightFindOptions = function () {
        if (!this._widget) {
            this._createFindWidget();
        }
        if (this._state.isRevealed) {
            this._widget.highlightFindOptions();
        }
        else {
            this._findOptionsWidget.highlightFindOptions();
        }
    };
    FindController.prototype._createFindWidget = function () {
        this._widget = this._register(new FindWidget(this._editor, this, this._state, this._contextViewService, this._keybindingService, this._contextKeyService, this._themeService));
        this._findOptionsWidget = this._register(new FindOptionsWidget(this._editor, this._state, this._keybindingService, this._themeService));
    };
    FindController = __decorate$3([
        __param$3(1, IContextViewService),
        __param$3(2, IContextKeyService),
        __param$3(3, IKeybindingService),
        __param$3(4, IThemeService),
        __param$3(5, IStorageService),
        __param$3(6, optional(IClipboardService))
    ], FindController);
    return FindController;
}(CommonFindController));
var StartFindAction = /** @class */ (function (_super) {
    __extends$d(StartFindAction, _super);
    function StartFindAction() {
        return _super.call(this, {
            id: FIND_IDS.StartFindAction,
            label: localize('startFindAction', "Find"),
            alias: 'Find',
            precondition: null,
            kbOpts: {
                kbExpr: null,
                primary: 2048 /* CtrlCmd */ | 36 /* KEY_F */
            }
        }) || this;
    }
    StartFindAction.prototype.run = function (accessor, editor) {
        var controller = CommonFindController.get(editor);
        if (controller) {
            controller.start({
                forceRevealReplace: false,
                seedSearchStringFromSelection: editor.getConfiguration().contribInfo.find.seedSearchStringFromSelection,
                seedSearchStringFromGlobalClipboard: editor.getConfiguration().contribInfo.find.globalFindClipboard,
                shouldFocus: 1 /* FocusFindInput */,
                shouldAnimate: true
            });
        }
    };
    return StartFindAction;
}(EditorAction));
var StartFindWithSelectionAction = /** @class */ (function (_super) {
    __extends$d(StartFindWithSelectionAction, _super);
    function StartFindWithSelectionAction() {
        return _super.call(this, {
            id: FIND_IDS.StartFindWithSelection,
            label: localize('startFindWithSelectionAction', "Find With Selection"),
            alias: 'Find With Selection',
            precondition: null,
            kbOpts: {
                kbExpr: null,
                primary: null,
                mac: {
                    primary: 2048 /* CtrlCmd */ | 35 /* KEY_E */,
                }
            }
        }) || this;
    }
    StartFindWithSelectionAction.prototype.run = function (accessor, editor) {
        var controller = CommonFindController.get(editor);
        if (controller) {
            controller.start({
                forceRevealReplace: false,
                seedSearchStringFromSelection: true,
                seedSearchStringFromGlobalClipboard: false,
                shouldFocus: 1 /* FocusFindInput */,
                shouldAnimate: true
            });
            controller.setGlobalBufferTerm(controller.getState().searchString);
        }
    };
    return StartFindWithSelectionAction;
}(EditorAction));
var MatchFindAction = /** @class */ (function (_super) {
    __extends$d(MatchFindAction, _super);
    function MatchFindAction() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    MatchFindAction.prototype.run = function (accessor, editor) {
        var controller = CommonFindController.get(editor);
        if (controller && !this._run(controller)) {
            controller.start({
                forceRevealReplace: false,
                seedSearchStringFromSelection: (controller.getState().searchString.length === 0) && editor.getConfiguration().contribInfo.find.seedSearchStringFromSelection,
                seedSearchStringFromGlobalClipboard: true,
                shouldFocus: 0 /* NoFocusChange */,
                shouldAnimate: true
            });
            this._run(controller);
        }
    };
    return MatchFindAction;
}(EditorAction));
var NextMatchFindAction = /** @class */ (function (_super) {
    __extends$d(NextMatchFindAction, _super);
    function NextMatchFindAction() {
        return _super.call(this, {
            id: FIND_IDS.NextMatchFindAction,
            label: localize('findNextMatchAction', "Find Next"),
            alias: 'Find Next',
            precondition: null,
            kbOpts: {
                kbExpr: EditorContextKeys.focus,
                primary: 61 /* F3 */,
                mac: { primary: 2048 /* CtrlCmd */ | 37 /* KEY_G */, secondary: [61 /* F3 */] }
            }
        }) || this;
    }
    NextMatchFindAction.prototype._run = function (controller) {
        return controller.moveToNextMatch();
    };
    return NextMatchFindAction;
}(MatchFindAction));
var PreviousMatchFindAction = /** @class */ (function (_super) {
    __extends$d(PreviousMatchFindAction, _super);
    function PreviousMatchFindAction() {
        return _super.call(this, {
            id: FIND_IDS.PreviousMatchFindAction,
            label: localize('findPreviousMatchAction', "Find Previous"),
            alias: 'Find Previous',
            precondition: null,
            kbOpts: {
                kbExpr: EditorContextKeys.focus,
                primary: 1024 /* Shift */ | 61 /* F3 */,
                mac: { primary: 2048 /* CtrlCmd */ | 1024 /* Shift */ | 37 /* KEY_G */, secondary: [1024 /* Shift */ | 61 /* F3 */] }
            }
        }) || this;
    }
    PreviousMatchFindAction.prototype._run = function (controller) {
        return controller.moveToPrevMatch();
    };
    return PreviousMatchFindAction;
}(MatchFindAction));
var SelectionMatchFindAction = /** @class */ (function (_super) {
    __extends$d(SelectionMatchFindAction, _super);
    function SelectionMatchFindAction() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    SelectionMatchFindAction.prototype.run = function (accessor, editor) {
        var controller = CommonFindController.get(editor);
        if (!controller) {
            return;
        }
        var selectionSearchString = getSelectionSearchString(editor);
        if (selectionSearchString) {
            controller.setSearchString(selectionSearchString);
        }
        if (!this._run(controller)) {
            controller.start({
                forceRevealReplace: false,
                seedSearchStringFromSelection: editor.getConfiguration().contribInfo.find.seedSearchStringFromSelection,
                seedSearchStringFromGlobalClipboard: false,
                shouldFocus: 0 /* NoFocusChange */,
                shouldAnimate: true
            });
            this._run(controller);
        }
    };
    return SelectionMatchFindAction;
}(EditorAction));
var NextSelectionMatchFindAction = /** @class */ (function (_super) {
    __extends$d(NextSelectionMatchFindAction, _super);
    function NextSelectionMatchFindAction() {
        return _super.call(this, {
            id: FIND_IDS.NextSelectionMatchFindAction,
            label: localize('nextSelectionMatchFindAction', "Find Next Selection"),
            alias: 'Find Next Selection',
            precondition: null,
            kbOpts: {
                kbExpr: EditorContextKeys.focus,
                primary: 2048 /* CtrlCmd */ | 61 /* F3 */
            }
        }) || this;
    }
    NextSelectionMatchFindAction.prototype._run = function (controller) {
        return controller.moveToNextMatch();
    };
    return NextSelectionMatchFindAction;
}(SelectionMatchFindAction));
var PreviousSelectionMatchFindAction = /** @class */ (function (_super) {
    __extends$d(PreviousSelectionMatchFindAction, _super);
    function PreviousSelectionMatchFindAction() {
        return _super.call(this, {
            id: FIND_IDS.PreviousSelectionMatchFindAction,
            label: localize('previousSelectionMatchFindAction', "Find Previous Selection"),
            alias: 'Find Previous Selection',
            precondition: null,
            kbOpts: {
                kbExpr: EditorContextKeys.focus,
                primary: 2048 /* CtrlCmd */ | 1024 /* Shift */ | 61 /* F3 */
            }
        }) || this;
    }
    PreviousSelectionMatchFindAction.prototype._run = function (controller) {
        return controller.moveToPrevMatch();
    };
    return PreviousSelectionMatchFindAction;
}(SelectionMatchFindAction));
var StartFindReplaceAction = /** @class */ (function (_super) {
    __extends$d(StartFindReplaceAction, _super);
    function StartFindReplaceAction() {
        return _super.call(this, {
            id: FIND_IDS.StartFindReplaceAction,
            label: localize('startReplace', "Replace"),
            alias: 'Replace',
            precondition: null,
            kbOpts: {
                kbExpr: null,
                primary: 2048 /* CtrlCmd */ | 38 /* KEY_H */,
                mac: { primary: 2048 /* CtrlCmd */ | 512 /* Alt */ | 36 /* KEY_F */ }
            }
        }) || this;
    }
    StartFindReplaceAction.prototype.run = function (accessor, editor) {
        if (editor.getConfiguration().readOnly) {
            return;
        }
        var controller = CommonFindController.get(editor);
        var currentSelection = editor.getSelection();
        // we only seed search string from selection when the current selection is single line and not empty.
        var seedSearchStringFromSelection = !currentSelection.isEmpty() &&
            currentSelection.startLineNumber === currentSelection.endLineNumber && editor.getConfiguration().contribInfo.find.seedSearchStringFromSelection;
        var oldSearchString = controller.getState().searchString;
        // if the existing search string in find widget is empty and we don't seed search string from selection, it means the Find Input
        // is still empty, so we should focus the Find Input instead of Replace Input.
        var shouldFocus = (!!oldSearchString || seedSearchStringFromSelection) ?
            2 /* FocusReplaceInput */ : 1 /* FocusFindInput */;
        if (controller) {
            controller.start({
                forceRevealReplace: true,
                seedSearchStringFromSelection: seedSearchStringFromSelection,
                seedSearchStringFromGlobalClipboard: editor.getConfiguration().contribInfo.find.seedSearchStringFromSelection,
                shouldFocus: shouldFocus,
                shouldAnimate: true
            });
        }
    };
    return StartFindReplaceAction;
}(EditorAction));
var ShowNextFindTermAction = /** @class */ (function (_super) {
    __extends$d(ShowNextFindTermAction, _super);
    function ShowNextFindTermAction() {
        return _super.call(this, {
            id: FIND_IDS.ShowNextFindTermAction,
            label: localize('showNextFindTermAction', "Show Next Find Term"),
            alias: 'Show Next Find Term',
            precondition: CONTEXT_FIND_WIDGET_VISIBLE,
            kbOpts: {
                weight: KeybindingsRegistry.WEIGHT.editorContrib(5),
                kbExpr: ContextKeyExpr.and(CONTEXT_FIND_INPUT_FOCUSED, EditorContextKeys.focus),
                primary: ShowNextFindTermKeybinding.primary,
                mac: ShowNextFindTermKeybinding.mac,
                win: ShowNextFindTermKeybinding.win,
                linux: ShowNextFindTermKeybinding.linux
            }
        }) || this;
    }
    ShowNextFindTermAction.prototype._run = function (controller) {
        return controller.showNextFindTerm();
    };
    return ShowNextFindTermAction;
}(MatchFindAction));
var ShowPreviousFindTermAction = /** @class */ (function (_super) {
    __extends$d(ShowPreviousFindTermAction, _super);
    function ShowPreviousFindTermAction() {
        return _super.call(this, {
            id: FIND_IDS.ShowPreviousFindTermAction,
            label: localize('showPreviousFindTermAction', "Show Previous Find Term"),
            alias: 'Find Show Previous Find Term',
            precondition: CONTEXT_FIND_WIDGET_VISIBLE,
            kbOpts: {
                weight: KeybindingsRegistry.WEIGHT.editorContrib(5),
                kbExpr: ContextKeyExpr.and(CONTEXT_FIND_INPUT_FOCUSED, EditorContextKeys.focus),
                primary: ShowPreviousFindTermKeybinding.primary,
                mac: ShowPreviousFindTermKeybinding.mac,
                win: ShowPreviousFindTermKeybinding.win,
                linux: ShowPreviousFindTermKeybinding.linux
            }
        }) || this;
    }
    ShowPreviousFindTermAction.prototype._run = function (controller) {
        return controller.showPreviousFindTerm();
    };
    return ShowPreviousFindTermAction;
}(MatchFindAction));
registerEditorContribution(FindController);
registerEditorAction(StartFindAction);
registerEditorAction(StartFindWithSelectionAction);
registerEditorAction(NextMatchFindAction);
registerEditorAction(PreviousMatchFindAction);
registerEditorAction(NextSelectionMatchFindAction);
registerEditorAction(PreviousSelectionMatchFindAction);
registerEditorAction(StartFindReplaceAction);
registerEditorAction(ShowNextFindTermAction);
registerEditorAction(ShowPreviousFindTermAction);
var FindCommand = EditorCommand.bindToContribution(CommonFindController.get);
registerEditorCommand(new FindCommand({
    id: FIND_IDS.CloseFindWidgetCommand,
    precondition: CONTEXT_FIND_WIDGET_VISIBLE,
    handler: function (x) { return x.closeFindWidget(); },
    kbOpts: {
        weight: KeybindingsRegistry.WEIGHT.editorContrib(5),
        kbExpr: EditorContextKeys.focus,
        primary: 9 /* Escape */,
        secondary: [1024 /* Shift */ | 9 /* Escape */]
    }
}));
registerEditorCommand(new FindCommand({
    id: FIND_IDS.ToggleCaseSensitiveCommand,
    precondition: null,
    handler: function (x) { return x.toggleCaseSensitive(); },
    kbOpts: {
        weight: KeybindingsRegistry.WEIGHT.editorContrib(5),
        kbExpr: EditorContextKeys.focus,
        primary: ToggleCaseSensitiveKeybinding.primary,
        mac: ToggleCaseSensitiveKeybinding.mac,
        win: ToggleCaseSensitiveKeybinding.win,
        linux: ToggleCaseSensitiveKeybinding.linux
    }
}));
registerEditorCommand(new FindCommand({
    id: FIND_IDS.ToggleWholeWordCommand,
    precondition: null,
    handler: function (x) { return x.toggleWholeWords(); },
    kbOpts: {
        weight: KeybindingsRegistry.WEIGHT.editorContrib(5),
        kbExpr: EditorContextKeys.focus,
        primary: ToggleWholeWordKeybinding.primary,
        mac: ToggleWholeWordKeybinding.mac,
        win: ToggleWholeWordKeybinding.win,
        linux: ToggleWholeWordKeybinding.linux
    }
}));
registerEditorCommand(new FindCommand({
    id: FIND_IDS.ToggleRegexCommand,
    precondition: null,
    handler: function (x) { return x.toggleRegex(); },
    kbOpts: {
        weight: KeybindingsRegistry.WEIGHT.editorContrib(5),
        kbExpr: EditorContextKeys.focus,
        primary: ToggleRegexKeybinding.primary,
        mac: ToggleRegexKeybinding.mac,
        win: ToggleRegexKeybinding.win,
        linux: ToggleRegexKeybinding.linux
    }
}));
registerEditorCommand(new FindCommand({
    id: FIND_IDS.ToggleSearchScopeCommand,
    precondition: null,
    handler: function (x) { return x.toggleSearchScope(); },
    kbOpts: {
        weight: KeybindingsRegistry.WEIGHT.editorContrib(5),
        kbExpr: EditorContextKeys.focus,
        primary: ToggleSearchScopeKeybinding.primary,
        mac: ToggleSearchScopeKeybinding.mac,
        win: ToggleSearchScopeKeybinding.win,
        linux: ToggleSearchScopeKeybinding.linux
    }
}));
registerEditorCommand(new FindCommand({
    id: FIND_IDS.ReplaceOneAction,
    precondition: CONTEXT_FIND_WIDGET_VISIBLE,
    handler: function (x) { return x.replace(); },
    kbOpts: {
        weight: KeybindingsRegistry.WEIGHT.editorContrib(5),
        kbExpr: EditorContextKeys.focus,
        primary: 2048 /* CtrlCmd */ | 1024 /* Shift */ | 22 /* KEY_1 */
    }
}));
registerEditorCommand(new FindCommand({
    id: FIND_IDS.ReplaceAllAction,
    precondition: CONTEXT_FIND_WIDGET_VISIBLE,
    handler: function (x) { return x.replaceAll(); },
    kbOpts: {
        weight: KeybindingsRegistry.WEIGHT.editorContrib(5),
        kbExpr: EditorContextKeys.focus,
        primary: 2048 /* CtrlCmd */ | 512 /* Alt */ | 3 /* Enter */
    }
}));
registerEditorCommand(new FindCommand({
    id: FIND_IDS.SelectAllMatchesAction,
    precondition: CONTEXT_FIND_WIDGET_VISIBLE,
    handler: function (x) { return x.selectAllMatches(); },
    kbOpts: {
        weight: KeybindingsRegistry.WEIGHT.editorContrib(5),
        kbExpr: EditorContextKeys.focus,
        primary: 512 /* Alt */ | 3 /* Enter */
    }
}));

const css$9 = "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n.monaco-editor .margin-view-overlays .folding {\n\tmargin-left: 5px;\n\tcursor: pointer;\n\tbackground-repeat: no-repeat;\n\tbackground-origin: border-box;\n\tbackground-position: 3px center;\n\tbackground-size: 15px;\n\topacity: 0;\n\ttransition: opacity 0.5s;\n}\n\n.monaco-editor .margin-view-overlays .folding {\n\tbackground-image: url(\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHg9IjBweCIgeT0iMHB4IiB2aWV3Qm94PSIwIDAgMTUgMTUiIHN0eWxlPSJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDE1IDE1OyI+CjxwYXRoIHN0eWxlPSJmaWxsOiNCNkI2QjYiIGQ9Ik0xMSw0djdINFY0SDExIE0xMiwzSDN2OWg5VjNMMTIsM3oiLz4KPGxpbmUgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6IzZCNkI2QjtzdHJva2UtbWl0ZXJsaW1pdDoxMCIgeDE9IjEwIiB5MT0iNy41IiB4Mj0iNSIgeTI9IjcuNSIvPgo8L3N2Zz4=\");\n}\n\n.monaco-editor.hc-black .margin-view-overlays .folding,\n.monaco-editor.vs-dark .margin-view-overlays .folding {\n\tbackground-image: url(\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHg9IjBweCIgeT0iMHB4IiB2aWV3Qm94PSIwIDAgMTUgMTUiIHN0eWxlPSJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDE1IDE1OyI+CjxwYXRoIHN0eWxlPSJmaWxsOiM1QTVBNUEiIGQ9Ik0xMSw0djdINFY0SDExIE0xMiwzSDN2OWg5VjNMMTIsM3oiLz4KPGxpbmUgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6I0M1QzVDNTtzdHJva2UtbWl0ZXJsaW1pdDoxMCIgeDE9IjEwIiB5MT0iNy41IiB4Mj0iNSIgeTI9IjcuNSIvPgo8L3N2Zz4=\");\n}\n\n.monaco-editor .margin-view-overlays:hover .folding,\n.monaco-editor .margin-view-overlays .folding.alwaysShowFoldIcons {\n\topacity: 1;\n}\n\n.monaco-editor .margin-view-overlays .folding.collapsed {\n\tbackground-image: url(\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHg9IjBweCIgeT0iMHB4IiB2aWV3Qm94PSIwIDAgMTUgMTUiIHN0eWxlPSJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDE1IDE1OyI+CjxyZWN0IHg9IjMiIHk9IjMiIHN0eWxlPSJmaWxsOiNFOEU4RTgiIHdpZHRoPSI5IiBoZWlnaHQ9IjkiLz4KPHBhdGggc3R5bGU9ImZpbGw6I0I2QjZCNiIgZD0iTTExLDR2N0g0VjRIMTEgTTEyLDNIM3Y5aDlWM0wxMiwzeiIvPgo8bGluZSBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojNkI2QjZCO3N0cm9rZS1taXRlcmxpbWl0OjEwIiB4MT0iMTAiIHkxPSI3LjUiIHgyPSI1IiB5Mj0iNy41Ii8+CjxsaW5lIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiM2QjZCNkI7c3Ryb2tlLW1pdGVybGltaXQ6MTAiIHgxPSI3LjUiIHkxPSI1IiB4Mj0iNy41IiB5Mj0iMTAiLz4KPC9zdmc+\");\n\topacity: 1;\n}\n\n.monaco-editor.hc-black .margin-view-overlays .folding.collapsed,\n.monaco-editor.vs-dark .margin-view-overlays .folding.collapsed {\n\tbackground-image: url(\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHg9IjBweCIgeT0iMHB4IiB2aWV3Qm94PSIwIDAgMTUgMTUiIHN0eWxlPSJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDE1IDE1OyI+CjxyZWN0IHg9IjMiIHk9IjMiIHN0eWxlPSJvcGFjaXR5OjAuMTtmaWxsOiNGRkZGRkYiIHdpZHRoPSI5IiBoZWlnaHQ9IjkiLz4KPHBhdGggc3R5bGU9ImZpbGw6IzVBNUE1QSIgZD0iTTExLDR2N0g0VjRIMTEgTTEyLDNIM3Y5aDlWM0wxMiwzeiIvPgo8bGluZSBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojQzVDNUM1O3N0cm9rZS1taXRlcmxpbWl0OjEwIiB4MT0iMTAiIHkxPSI3LjUiIHgyPSI1IiB5Mj0iNy41Ii8+CjxsaW5lIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiNDNUM1QzU7c3Ryb2tlLW1pdGVybGltaXQ6MTAiIHgxPSI3LjUiIHkxPSI1IiB4Mj0iNy41IiB5Mj0iMTAiLz4KPC9zdmc+\");\n}\n\n.monaco-editor .inline-folded:after {\n\tcolor: grey;\n\tmargin: 0.1em 0.2em 0 0.2em;\n\tcontent: \"⋯\";\n\tdisplay: inline;\n\tline-height: 1em;\n\tcursor: pointer;\n}\n\n";
  const element$9 = ((css, src) => {
if (typeof document !== 'object')
console.info(`Skipped loading "${src}"`);
try {
const id = src
  .replace(/\.css.*$/, '')
  .replace(/[\\:]/g, '/')
  .replace(/[^\w\/]+/g, '');
return (
  document.querySelector(`style[id="${id}"]`) ||
  document.head.appendChild(
    Object.assign(document.createElement('style'), {
      id,
      textContent: `${css}\n\n /* sourceURL=${src} */`,
    }),
  )
);
} catch (exception) {
console.warn(`Failed load "${src}"`, exception);
}
})(css$9, "…monaco-editor/esm/vs/editor/contrib/folding/folding.css");
  //@ sourceURL=/Users/daflair/Projects/packages/monaco-es/node_modules/monaco-editor/esm/vs/editor/contrib/folding/folding.css

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var MAX_FOLDING_REGIONS = 0xFFFF;
var MAX_LINE_NUMBER = 0xFFFFFF;
var MASK_INDENT = 0xFF000000;
var FoldingRegions = /** @class */ (function () {
    function FoldingRegions(startIndexes, endIndexes, types) {
        if (startIndexes.length !== endIndexes.length || startIndexes.length > MAX_FOLDING_REGIONS) {
            throw new Error('invalid startIndexes or endIndexes size');
        }
        this._startIndexes = startIndexes;
        this._endIndexes = endIndexes;
        this._collapseStates = new Uint32Array(Math.ceil(startIndexes.length / 32));
        this._types = types;
    }
    FoldingRegions.prototype.ensureParentIndices = function () {
        var _this = this;
        if (!this._parentsComputed) {
            this._parentsComputed = true;
            var parentIndexes_1 = [];
            var isInsideLast = function (startLineNumber, endLineNumber) {
                var index = parentIndexes_1[parentIndexes_1.length - 1];
                return _this.getStartLineNumber(index) <= startLineNumber && _this.getEndLineNumber(index) >= endLineNumber;
            };
            for (var i = 0, len = this._startIndexes.length; i < len; i++) {
                var startLineNumber = this._startIndexes[i];
                var endLineNumber = this._endIndexes[i];
                if (startLineNumber > MAX_LINE_NUMBER || endLineNumber > MAX_LINE_NUMBER) {
                    throw new Error('startLineNumber or endLineNumber must not exceed ' + MAX_LINE_NUMBER);
                }
                while (parentIndexes_1.length > 0 && !isInsideLast(startLineNumber, endLineNumber)) {
                    parentIndexes_1.pop();
                }
                var parentIndex = parentIndexes_1.length > 0 ? parentIndexes_1[parentIndexes_1.length - 1] : -1;
                parentIndexes_1.push(i);
                this._startIndexes[i] = startLineNumber + ((parentIndex & 0xFF) << 24);
                this._endIndexes[i] = endLineNumber + ((parentIndex & 0xFF00) << 16);
            }
        }
    };
    Object.defineProperty(FoldingRegions.prototype, "length", {
        get: function () {
            return this._startIndexes.length;
        },
        enumerable: true,
        configurable: true
    });
    FoldingRegions.prototype.getStartLineNumber = function (index) {
        return this._startIndexes[index] & MAX_LINE_NUMBER;
    };
    FoldingRegions.prototype.getEndLineNumber = function (index) {
        return this._endIndexes[index] & MAX_LINE_NUMBER;
    };
    FoldingRegions.prototype.getType = function (index) {
        return this._types ? this._types[index] : void 0;
    };
    FoldingRegions.prototype.hasTypes = function () {
        return !!this._types;
    };
    FoldingRegions.prototype.isCollapsed = function (index) {
        var arrayIndex = (index / 32) | 0;
        var bit = index % 32;
        return (this._collapseStates[arrayIndex] & (1 << bit)) !== 0;
    };
    FoldingRegions.prototype.setCollapsed = function (index, newState) {
        var arrayIndex = (index / 32) | 0;
        var bit = index % 32;
        var value = this._collapseStates[arrayIndex];
        if (newState) {
            this._collapseStates[arrayIndex] = value | (1 << bit);
        }
        else {
            this._collapseStates[arrayIndex] = value & ~(1 << bit);
        }
    };
    FoldingRegions.prototype.toRegion = function (index) {
        return new FoldingRegion(this, index);
    };
    FoldingRegions.prototype.getParentIndex = function (index) {
        this.ensureParentIndices();
        var parent = ((this._startIndexes[index] & MASK_INDENT) >>> 24) + ((this._endIndexes[index] & MASK_INDENT) >>> 16);
        if (parent === MAX_FOLDING_REGIONS) {
            return -1;
        }
        return parent;
    };
    FoldingRegions.prototype.contains = function (index, line) {
        return this.getStartLineNumber(index) <= line && this.getEndLineNumber(index) >= line;
    };
    FoldingRegions.prototype.findIndex = function (line) {
        var low = 0, high = this._startIndexes.length;
        if (high === 0) {
            return -1; // no children
        }
        while (low < high) {
            var mid = Math.floor((low + high) / 2);
            if (line < this.getStartLineNumber(mid)) {
                high = mid;
            }
            else {
                low = mid + 1;
            }
        }
        return low - 1;
    };
    FoldingRegions.prototype.findRange = function (line) {
        var index = this.findIndex(line);
        if (index >= 0) {
            var endLineNumber = this.getEndLineNumber(index);
            if (endLineNumber >= line) {
                return index;
            }
            index = this.getParentIndex(index);
            while (index !== -1) {
                if (this.contains(index, line)) {
                    return index;
                }
                index = this.getParentIndex(index);
            }
        }
        return -1;
    };
    FoldingRegions.prototype.toString = function () {
        var res = [];
        for (var i = 0; i < this.length; i++) {
            res[i] = "[" + (this.isCollapsed(i) ? '+' : '-') + "] " + this.getStartLineNumber(i) + "/" + this.getEndLineNumber(i);
        }
        return res.join(', ');
    };
    return FoldingRegions;
}());
var FoldingRegion = /** @class */ (function () {
    function FoldingRegion(ranges, index) {
        this.ranges = ranges;
        this.index = index;
    }
    Object.defineProperty(FoldingRegion.prototype, "startLineNumber", {
        get: function () {
            return this.ranges.getStartLineNumber(this.index);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FoldingRegion.prototype, "endLineNumber", {
        get: function () {
            return this.ranges.getEndLineNumber(this.index);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FoldingRegion.prototype, "regionIndex", {
        get: function () {
            return this.index;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FoldingRegion.prototype, "parentIndex", {
        get: function () {
            return this.ranges.getParentIndex(this.index);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FoldingRegion.prototype, "isCollapsed", {
        get: function () {
            return this.ranges.isCollapsed(this.index);
        },
        enumerable: true,
        configurable: true
    });
    FoldingRegion.prototype.containedBy = function (range$$1) {
        return range$$1.startLineNumber <= this.startLineNumber && range$$1.endLineNumber >= this.endLineNumber;
    };
    FoldingRegion.prototype.containsLine = function (lineNumber) {
        return this.startLineNumber <= lineNumber && lineNumber <= this.endLineNumber;
    };
    FoldingRegion.prototype.hidesLine = function (lineNumber) {
        return this.startLineNumber < lineNumber && lineNumber <= this.endLineNumber;
    };
    return FoldingRegion;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var FoldingModel = /** @class */ (function () {
    function FoldingModel(textModel, decorationProvider) {
        this._updateEventEmitter = new Emitter();
        this._textModel = textModel;
        this._decorationProvider = decorationProvider;
        this._regions = new FoldingRegions(new Uint32Array(0), new Uint32Array(0));
        this._editorDecorationIds = [];
        this._isInitialized = false;
    }
    Object.defineProperty(FoldingModel.prototype, "regions", {
        get: function () { return this._regions; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FoldingModel.prototype, "onDidChange", {
        get: function () { return this._updateEventEmitter.event; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FoldingModel.prototype, "textModel", {
        get: function () { return this._textModel; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FoldingModel.prototype, "isInitialized", {
        get: function () { return this._isInitialized; },
        enumerable: true,
        configurable: true
    });
    FoldingModel.prototype.toggleCollapseState = function (regions) {
        var _this = this;
        if (!regions.length) {
            return;
        }
        var processed = {};
        this._decorationProvider.changeDecorations(function (accessor) {
            for (var _i = 0, regions_1 = regions; _i < regions_1.length; _i++) {
                var region = regions_1[_i];
                var index = region.regionIndex;
                var editorDecorationId = _this._editorDecorationIds[index];
                if (editorDecorationId && !processed[editorDecorationId]) {
                    processed[editorDecorationId] = true;
                    var newCollapseState = !_this._regions.isCollapsed(index);
                    _this._regions.setCollapsed(index, newCollapseState);
                    accessor.changeDecorationOptions(editorDecorationId, _this._decorationProvider.getDecorationOption(newCollapseState));
                }
            }
        });
        this._updateEventEmitter.fire({ model: this, collapseStateChanged: regions });
    };
    FoldingModel.prototype.update = function (newRegions, blockedLineNumers) {
        var _this = this;
        if (blockedLineNumers === void 0) { blockedLineNumers = []; }
        var newEditorDecorations = [];
        var isBlocked = function (startLineNumber, endLineNumber) {
            for (var _i = 0, blockedLineNumers_1 = blockedLineNumers; _i < blockedLineNumers_1.length; _i++) {
                var blockedLineNumber = blockedLineNumers_1[_i];
                if (startLineNumber < blockedLineNumber && blockedLineNumber <= endLineNumber) { // first line is visible
                    return true;
                }
            }
            return false;
        };
        var initRange = function (index, isCollapsed) {
            var startLineNumber = newRegions.getStartLineNumber(index);
            if (isCollapsed && isBlocked(startLineNumber, newRegions.getEndLineNumber(index))) {
                isCollapsed = false;
            }
            newRegions.setCollapsed(index, isCollapsed);
            var maxColumn = _this._textModel.getLineMaxColumn(startLineNumber);
            var decorationRange = {
                startLineNumber: startLineNumber,
                startColumn: maxColumn,
                endLineNumber: startLineNumber,
                endColumn: maxColumn
            };
            newEditorDecorations.push({ range: decorationRange, options: _this._decorationProvider.getDecorationOption(isCollapsed) });
        };
        var i = 0;
        var nextCollapsed = function () {
            while (i < _this._regions.length) {
                var isCollapsed = _this._regions.isCollapsed(i);
                i++;
                if (isCollapsed) {
                    return i - 1;
                }
            }
            return -1;
        };
        var k = 0;
        var collapsedIndex = nextCollapsed();
        while (collapsedIndex !== -1 && k < newRegions.length) {
            // get the latest range
            var decRange = this._textModel.getDecorationRange(this._editorDecorationIds[collapsedIndex]);
            if (decRange) {
                var collapsedStartLineNumber = decRange.startLineNumber;
                if (this._textModel.getLineMaxColumn(collapsedStartLineNumber) === decRange.startColumn) { // test that the decoration is still at the end otherwise it got deleted
                    while (k < newRegions.length) {
                        var startLineNumber = newRegions.getStartLineNumber(k);
                        if (collapsedStartLineNumber >= startLineNumber) {
                            initRange(k, collapsedStartLineNumber === startLineNumber);
                            k++;
                        }
                        else {
                            break;
                        }
                    }
                }
            }
            collapsedIndex = nextCollapsed();
        }
        while (k < newRegions.length) {
            initRange(k, false);
            k++;
        }
        this._editorDecorationIds = this._decorationProvider.deltaDecorations(this._editorDecorationIds, newEditorDecorations);
        this._regions = newRegions;
        this._isInitialized = true;
        this._updateEventEmitter.fire({ model: this });
    };
    /**
     * Collapse state memento, for persistence only
     */
    FoldingModel.prototype.getMemento = function () {
        var collapsedRanges = [];
        for (var i = 0; i < this._regions.length; i++) {
            if (this._regions.isCollapsed(i)) {
                var range$$1 = this._textModel.getDecorationRange(this._editorDecorationIds[i]);
                if (range$$1) {
                    var startLineNumber = range$$1.startLineNumber;
                    var endLineNumber = range$$1.endLineNumber + this._regions.getEndLineNumber(i) - this._regions.getStartLineNumber(i);
                    collapsedRanges.push({ startLineNumber: startLineNumber, endLineNumber: endLineNumber });
                }
            }
        }
        if (collapsedRanges.length > 0) {
            return collapsedRanges;
        }
        return null;
    };
    /**
     * Apply persisted state, for persistence only
     */
    FoldingModel.prototype.applyMemento = function (state) {
        if (!Array.isArray(state)) {
            return;
        }
        var toToogle = [];
        for (var _i = 0, state_1 = state; _i < state_1.length; _i++) {
            var range$$1 = state_1[_i];
            var region = this.getRegionAtLine(range$$1.startLineNumber);
            if (region && !region.isCollapsed) {
                toToogle.push(region);
            }
        }
        this.toggleCollapseState(toToogle);
    };
    FoldingModel.prototype.dispose = function () {
        this._decorationProvider.deltaDecorations(this._editorDecorationIds, []);
    };
    FoldingModel.prototype.getAllRegionsAtLine = function (lineNumber, filter) {
        var result = [];
        if (this._regions) {
            var index = this._regions.findRange(lineNumber);
            var level = 1;
            while (index >= 0) {
                var current = this._regions.toRegion(index);
                if (!filter || filter(current, level)) {
                    result.push(current);
                }
                level++;
                index = current.parentIndex;
            }
        }
        return result;
    };
    FoldingModel.prototype.getRegionAtLine = function (lineNumber) {
        if (this._regions) {
            var index = this._regions.findRange(lineNumber);
            if (index >= 0) {
                return this._regions.toRegion(index);
            }
        }
        return null;
    };
    FoldingModel.prototype.getRegionsInside = function (region, filter) {
        var result = [];
        var trackLevel = filter && filter.length === 2;
        var levelStack = trackLevel ? [] : null;
        var index = region ? region.regionIndex + 1 : 0;
        var endLineNumber = region ? region.endLineNumber : Number.MAX_VALUE;
        for (var i = index, len = this._regions.length; i < len; i++) {
            var current = this._regions.toRegion(i);
            if (this._regions.getStartLineNumber(i) < endLineNumber) {
                if (trackLevel) {
                    while (levelStack.length > 0 && !current.containedBy(levelStack[levelStack.length - 1])) {
                        levelStack.pop();
                    }
                    levelStack.push(current);
                    if (filter(current, levelStack.length)) {
                        result.push(current);
                    }
                }
                else if (!filter || filter(current)) {
                    result.push(current);
                }
            }
            else {
                break;
            }
        }
        return result;
    };
    return FoldingModel;
}());
/**
 * Collapse or expand the regions at the given locations including all children.
 * @param doCollapse Wheter to collase or expand
 * @param levels The number of levels. Use 1 to only impact the regions at the location, use Number.MAX_VALUE for all levels.
 * @param lineNumbers the location of the regions to collapse or expand, or if not set, all regions in the model.
 */
function setCollapseStateLevelsDown(foldingModel, doCollapse, levels, lineNumbers) {
    if (levels === void 0) { levels = Number.MAX_VALUE; }
    var toToggle = [];
    if (lineNumbers && lineNumbers.length > 0) {
        for (var _i = 0, lineNumbers_1 = lineNumbers; _i < lineNumbers_1.length; _i++) {
            var lineNumber = lineNumbers_1[_i];
            var region = foldingModel.getRegionAtLine(lineNumber);
            if (region) {
                if (region.isCollapsed !== doCollapse) {
                    toToggle.push(region);
                }
                if (levels > 1) {
                    var regionsInside = foldingModel.getRegionsInside(region, function (r, level) { return r.isCollapsed !== doCollapse && level < levels; });
                    toToggle.push.apply(toToggle, regionsInside);
                }
            }
        }
    }
    else {
        var regionsInside = foldingModel.getRegionsInside(null, function (r, level) { return r.isCollapsed !== doCollapse && level < levels; });
        toToggle.push.apply(toToggle, regionsInside);
    }
    foldingModel.toggleCollapseState(toToggle);
}
/**
 * Collapse or expand the regions at the given locations including all parents.
 * @param doCollapse Wheter to collase or expand
 * @param levels The number of levels. Use 1 to only impact the regions at the location, use Number.MAX_VALUE for all levels.
 * @param lineNumbers the location of the regions to collapse or expand, or if not set, all regions in the model.
 */
function setCollapseStateLevelsUp(foldingModel, doCollapse, levels, lineNumbers) {
    var toToggle = [];
    for (var _i = 0, lineNumbers_2 = lineNumbers; _i < lineNumbers_2.length; _i++) {
        var lineNumber = lineNumbers_2[_i];
        var regions = foldingModel.getAllRegionsAtLine(lineNumber, function (region, level) { return region.isCollapsed !== doCollapse && level <= levels; });
        toToggle.push.apply(toToggle, regions);
    }
    foldingModel.toggleCollapseState(toToggle);
}
/**
 * Folds or unfolds all regions that have a given level, except if they contain one of the blocked lines.
 * @param foldLevel level. Level == 1 is the top level
 * @param doCollapse Wheter to collase or expand
* @param blockedLineNumbers
*/
function setCollapseStateAtLevel(foldingModel, foldLevel, doCollapse, blockedLineNumbers) {
    var filter = function (region, level) { return level === foldLevel && region.isCollapsed !== doCollapse && !blockedLineNumbers.some(function (line) { return region.containsLine(line); }); };
    var toToggle = foldingModel.getRegionsInside(null, filter);
    foldingModel.toggleCollapseState(toToggle);
}
/**
 * Folds all regions for which the lines start with a given regex
 * @param foldingModel the folding model
 */
function setCollapseStateForMatchingLines(foldingModel, regExp, doCollapse) {
    var editorModel = foldingModel.textModel;
    var regions = foldingModel.regions;
    var toToggle = [];
    for (var i = regions.length - 1; i >= 0; i--) {
        if (doCollapse !== regions.isCollapsed(i)) {
            var startLineNumber = regions.getStartLineNumber(i);
            if (regExp.test(editorModel.getLineContent(startLineNumber))) {
                toToggle.push(regions.toRegion(i));
            }
        }
    }
    foldingModel.toggleCollapseState(toToggle);
}
/**
 * Folds all regions of the given type
 * @param foldingModel the folding model
 */
function setCollapseStateForType(foldingModel, type, doCollapse) {
    var regions = foldingModel.regions;
    var toToggle = [];
    for (var i = regions.length - 1; i >= 0; i--) {
        if (doCollapse !== regions.isCollapsed(i) && type === regions.getType(i)) {
            toToggle.push(regions.toRegion(i));
        }
    }
    foldingModel.toggleCollapseState(toToggle);
}

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var FoldingDecorationProvider = /** @class */ (function () {
    function FoldingDecorationProvider(editor) {
        this.editor = editor;
        this.autoHideFoldingControls = true;
    }
    FoldingDecorationProvider.prototype.getDecorationOption = function (isCollapsed) {
        if (isCollapsed) {
            return FoldingDecorationProvider.COLLAPSED_VISUAL_DECORATION;
        }
        else if (this.autoHideFoldingControls) {
            return FoldingDecorationProvider.EXPANDED_AUTO_HIDE_VISUAL_DECORATION;
        }
        else {
            return FoldingDecorationProvider.EXPANDED_VISUAL_DECORATION;
        }
    };
    FoldingDecorationProvider.prototype.deltaDecorations = function (oldDecorations, newDecorations) {
        return this.editor.deltaDecorations(oldDecorations, newDecorations);
    };
    FoldingDecorationProvider.prototype.changeDecorations = function (callback) {
        return this.editor.changeDecorations(callback);
    };
    FoldingDecorationProvider.COLLAPSED_VISUAL_DECORATION = ModelDecorationOptions.register({
        stickiness: TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges,
        afterContentClassName: 'inline-folded',
        linesDecorationsClassName: 'folding collapsed'
    });
    FoldingDecorationProvider.EXPANDED_AUTO_HIDE_VISUAL_DECORATION = ModelDecorationOptions.register({
        stickiness: TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges,
        linesDecorationsClassName: 'folding'
    });
    FoldingDecorationProvider.EXPANDED_VISUAL_DECORATION = ModelDecorationOptions.register({
        stickiness: TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges,
        linesDecorationsClassName: 'folding alwaysShowFoldIcons'
    });
    return FoldingDecorationProvider;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var HiddenRangeModel = /** @class */ (function () {
    function HiddenRangeModel(model) {
        var _this = this;
        this._updateEventEmitter = new Emitter();
        this._foldingModel = model;
        this._foldingModelListener = model.onDidChange(function (_) { return _this.updateHiddenRanges(); });
        this._hiddenRanges = [];
        if (model.regions.length) {
            this.updateHiddenRanges();
        }
    }
    Object.defineProperty(HiddenRangeModel.prototype, "onDidChange", {
        get: function () { return this._updateEventEmitter.event; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HiddenRangeModel.prototype, "hiddenRanges", {
        get: function () { return this._hiddenRanges; },
        enumerable: true,
        configurable: true
    });
    HiddenRangeModel.prototype.updateHiddenRanges = function () {
        var updateHiddenAreas = false;
        var newHiddenAreas = [];
        var i = 0; // index into hidden
        var k = 0;
        var lastCollapsedStart = Number.MAX_VALUE;
        var lastCollapsedEnd = -1;
        var ranges = this._foldingModel.regions;
        for (; i < ranges.length; i++) {
            if (!ranges.isCollapsed(i)) {
                continue;
            }
            var startLineNumber = ranges.getStartLineNumber(i) + 1; // the first line is not hidden
            var endLineNumber = ranges.getEndLineNumber(i);
            if (lastCollapsedStart <= startLineNumber && endLineNumber <= lastCollapsedEnd) {
                // ignore ranges contained in collapsed regions
                continue;
            }
            if (!updateHiddenAreas && k < this._hiddenRanges.length && this._hiddenRanges[k].startLineNumber === startLineNumber && this._hiddenRanges[k].endLineNumber === endLineNumber) {
                // reuse the old ranges
                newHiddenAreas.push(this._hiddenRanges[k]);
                k++;
            }
            else {
                updateHiddenAreas = true;
                newHiddenAreas.push(new Range(startLineNumber, 1, endLineNumber, 1));
            }
            lastCollapsedStart = startLineNumber;
            lastCollapsedEnd = endLineNumber;
        }
        if (updateHiddenAreas || k < this._hiddenRanges.length) {
            this.applyHiddenRanges(newHiddenAreas);
        }
    };
    HiddenRangeModel.prototype.applyMemento = function (state) {
        if (!Array.isArray(state) || state.length === 0) {
            return false;
        }
        var hiddenRanges = [];
        for (var _i = 0, state_1 = state; _i < state_1.length; _i++) {
            var r = state_1[_i];
            if (!r.startLineNumber || !r.endLineNumber) {
                return false;
            }
            hiddenRanges.push(new Range(r.startLineNumber + 1, 1, r.endLineNumber, 1));
        }
        this.applyHiddenRanges(hiddenRanges);
        return true;
    };
    /**
     * Collapse state memento, for persistence only, only used if folding model is not yet initialized
     */
    HiddenRangeModel.prototype.getMemento = function () {
        return this._hiddenRanges.map(function (r) { return ({ startLineNumber: r.startLineNumber - 1, endLineNumber: r.endLineNumber }); });
    };
    HiddenRangeModel.prototype.applyHiddenRanges = function (newHiddenAreas) {
        this._hiddenRanges = newHiddenAreas;
        this._updateEventEmitter.fire(newHiddenAreas);
    };
    HiddenRangeModel.prototype.hasRanges = function () {
        return this._hiddenRanges.length > 0;
    };
    HiddenRangeModel.prototype.isHidden = function (line) {
        return findRange(this._hiddenRanges, line) !== null;
    };
    HiddenRangeModel.prototype.adjustSelections = function (selections) {
        var _this = this;
        var hasChanges = false;
        var editorModel = this._foldingModel.textModel;
        var lastRange = null;
        var adjustLine = function (line) {
            if (!lastRange || !isInside(line, lastRange)) {
                lastRange = findRange(_this._hiddenRanges, line);
            }
            if (lastRange) {
                return lastRange.startLineNumber - 1;
            }
            return null;
        };
        for (var i = 0, len = selections.length; i < len; i++) {
            var selection = selections[i];
            var adjustedStartLine = adjustLine(selection.startLineNumber);
            if (adjustedStartLine) {
                selection = selection.setStartPosition(adjustedStartLine, editorModel.getLineMaxColumn(adjustedStartLine));
                hasChanges = true;
            }
            var adjustedEndLine = adjustLine(selection.endLineNumber);
            if (adjustedEndLine) {
                selection = selection.setEndPosition(adjustedEndLine, editorModel.getLineMaxColumn(adjustedEndLine));
                hasChanges = true;
            }
            selections[i] = selection;
        }
        return hasChanges;
    };
    HiddenRangeModel.prototype.dispose = function () {
        if (this.hiddenRanges.length > 0) {
            this._hiddenRanges = [];
            this._updateEventEmitter.fire(this._hiddenRanges);
        }
        if (this._foldingModelListener) {
            this._foldingModelListener.dispose();
            this._foldingModelListener = null;
        }
    };
    return HiddenRangeModel;
}());
function isInside(line, range$$1) {
    return line >= range$$1.startLineNumber && line <= range$$1.endLineNumber;
}
function findRange(ranges, line) {
    var i = findFirstInSorted(ranges, function (r) { return line < r.startLineNumber; }) - 1;
    if (i >= 0 && ranges[i].endLineNumber >= line) {
        return ranges[i];
    }
    return null;
}

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var MAX_FOLDING_REGIONS_FOR_INDENT_LIMIT = 5000;
var IndentRangeProvider = /** @class */ (function () {
    function IndentRangeProvider() {
    }
    IndentRangeProvider.prototype.compute = function (editorModel, cancelationToken) {
        var foldingRules = LanguageConfigurationRegistry.getFoldingRules(editorModel.getLanguageIdentifier().id);
        var offSide = foldingRules && foldingRules.offSide;
        var markers = foldingRules && foldingRules.markers;
        return TPromise.as(computeRanges(editorModel, offSide, markers));
    };
    return IndentRangeProvider;
}());
// public only for testing
var RangesCollector = /** @class */ (function () {
    function RangesCollector(foldingRangesLimit) {
        this._startIndexes = [];
        this._endIndexes = [];
        this._indentOccurrences = [];
        this._length = 0;
        this._foldingRangesLimit = foldingRangesLimit;
    }
    RangesCollector.prototype.insertFirst = function (startLineNumber, endLineNumber, indent) {
        if (startLineNumber > MAX_LINE_NUMBER || endLineNumber > MAX_LINE_NUMBER) {
            return;
        }
        var index = this._length;
        this._startIndexes[index] = startLineNumber;
        this._endIndexes[index] = endLineNumber;
        this._length++;
        if (indent < 1000) {
            this._indentOccurrences[indent] = (this._indentOccurrences[indent] || 0) + 1;
        }
    };
    RangesCollector.prototype.toIndentRanges = function (model) {
        if (this._length <= this._foldingRangesLimit) {
            // reverse and create arrays of the exact length
            var startIndexes = new Uint32Array(this._length);
            var endIndexes = new Uint32Array(this._length);
            for (var i = this._length - 1, k = 0; i >= 0; i--, k++) {
                startIndexes[k] = this._startIndexes[i];
                endIndexes[k] = this._endIndexes[i];
            }
            return new FoldingRegions(startIndexes, endIndexes);
        }
        else {
            var entries = 0;
            var maxIndent = this._indentOccurrences.length;
            for (var i = 0; i < this._indentOccurrences.length; i++) {
                var n = this._indentOccurrences[i];
                if (n) {
                    if (n + entries > this._foldingRangesLimit) {
                        maxIndent = i;
                        break;
                    }
                    entries += n;
                }
            }
            var tabSize = model.getOptions().tabSize;
            // reverse and create arrays of the exact length
            var startIndexes = new Uint32Array(entries);
            var endIndexes = new Uint32Array(entries);
            for (var i = this._length - 1, k = 0; i >= 0; i--) {
                var startIndex = this._startIndexes[i];
                var lineContent = model.getLineContent(startIndex);
                var indent = TextModel.computeIndentLevel(lineContent, tabSize);
                if (indent < maxIndent) {
                    startIndexes[k] = startIndex;
                    endIndexes[k] = this._endIndexes[i];
                    k++;
                }
            }
            return new FoldingRegions(startIndexes, endIndexes);
        }
    };
    return RangesCollector;
}());
function computeRanges(model, offSide, markers, foldingRangesLimit) {
    if (foldingRangesLimit === void 0) { foldingRangesLimit = MAX_FOLDING_REGIONS_FOR_INDENT_LIMIT; }
    var tabSize = model.getOptions().tabSize;
    var result = new RangesCollector(foldingRangesLimit);
    var pattern = void 0;
    if (markers) {
        pattern = new RegExp("(" + markers.start.source + ")|(?:" + markers.end.source + ")");
    }
    var previousRegions = [];
    previousRegions.push({ indent: -1, line: model.getLineCount() + 1, marker: false }); // sentinel, to make sure there's at least one entry
    for (var line = model.getLineCount(); line > 0; line--) {
        var lineContent = model.getLineContent(line);
        var indent = TextModel.computeIndentLevel(lineContent, tabSize);
        var previous = previousRegions[previousRegions.length - 1];
        if (indent === -1) {
            if (offSide && !previous.marker) {
                // for offSide languages, empty lines are associated to the next block
                previous.line = line;
            }
            continue; // only whitespace
        }
        var m = void 0;
        if (pattern && (m = lineContent.match(pattern))) {
            // folding pattern match
            if (m[1]) { // start pattern match
                // discard all regions until the folding pattern
                var i = previousRegions.length - 1;
                while (i > 0 && !previousRegions[i].marker) {
                    i--;
                }
                if (i > 0) {
                    previousRegions.length = i + 1;
                    previous = previousRegions[i];
                    // new folding range from pattern, includes the end line
                    result.insertFirst(line, previous.line, indent);
                    previous.marker = false;
                    previous.indent = indent;
                    previous.line = line;
                    continue;
                }
            }
            else { // end pattern match
                previousRegions.push({ indent: -2, line: line, marker: true });
                continue;
            }
        }
        if (previous.indent > indent) {
            // discard all regions with larger indent
            do {
                previousRegions.pop();
                previous = previousRegions[previousRegions.length - 1];
            } while (previous.indent > indent);
            // new folding range
            var endLineNumber = previous.line - 1;
            if (endLineNumber - line >= 1) { // needs at east size 1
                result.insertFirst(line, endLineNumber, indent);
            }
        }
        if (previous.indent === indent) {
            previous.line = line;
        }
        else { // previous.indent < indent
            // new region with a bigger indent
            previousRegions.push({ indent: indent, line: line, marker: false });
        }
    }
    return result.toIndentRanges(model);
}

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var MAX_FOLDING_REGIONS_FOR_INDENT_LIMIT$1 = 5000;
var foldingContext = {
    maxRanges: MAX_FOLDING_REGIONS_FOR_INDENT_LIMIT$1
};
var SyntaxRangeProvider = /** @class */ (function () {
    function SyntaxRangeProvider(providers) {
        this.providers = providers;
    }
    SyntaxRangeProvider.prototype.compute = function (model, cancellationToken) {
        return collectSyntaxRanges(this.providers, model, cancellationToken).then(function (ranges) {
            if (ranges) {
                var res = sanitizeRanges(ranges);
                return res;
            }
            return null;
        });
    };
    return SyntaxRangeProvider;
}());
function collectSyntaxRanges(providers, model, cancellationToken) {
    var promises = providers.map(function (provider) { return toPromiseLike(provider.provideFoldingRanges(model, foldingContext, cancellationToken)); });
    return TPromise.join(promises).then(function (results) {
        var rangeData = null;
        if (cancellationToken.isCancellationRequested) {
            return null;
        }
        for (var i = 0; i < results.length; i++) {
            var ranges = results[i];
            if (Array.isArray(ranges)) {
                if (!Array.isArray(rangeData)) {
                    rangeData = [];
                }
                var nLines = model.getLineCount();
                for (var _i = 0, ranges_1 = ranges; _i < ranges_1.length; _i++) {
                    var r = ranges_1[_i];
                    if (r.start > 0 && r.end > r.start && r.end <= nLines) {
                        rangeData.push({ start: r.start, end: r.end, rank: i, kind: r.kind });
                    }
                }
            }
        }
        return rangeData;
    }, onUnexpectedExternalError);
}
var RangesCollector$1 = /** @class */ (function () {
    function RangesCollector(foldingRangesLimit) {
        this._startIndexes = [];
        this._endIndexes = [];
        this._nestingLevels = [];
        this._nestingLevelCounts = [];
        this._types = [];
        this._length = 0;
        this._foldingRangesLimit = foldingRangesLimit;
    }
    RangesCollector.prototype.add = function (startLineNumber, endLineNumber, type, nestingLevel) {
        if (startLineNumber > MAX_LINE_NUMBER || endLineNumber > MAX_LINE_NUMBER) {
            return;
        }
        var index = this._length;
        this._startIndexes[index] = startLineNumber;
        this._endIndexes[index] = endLineNumber;
        this._nestingLevels[index] = nestingLevel;
        this._types[index] = type;
        this._length++;
        if (nestingLevel < 30) {
            this._nestingLevelCounts[nestingLevel] = (this._nestingLevelCounts[nestingLevel] || 0) + 1;
        }
    };
    RangesCollector.prototype.toIndentRanges = function () {
        if (this._length <= this._foldingRangesLimit) {
            var startIndexes = new Uint32Array(this._length);
            var endIndexes = new Uint32Array(this._length);
            for (var i = 0; i < this._length; i++) {
                startIndexes[i] = this._startIndexes[i];
                endIndexes[i] = this._endIndexes[i];
            }
            return new FoldingRegions(startIndexes, endIndexes, this._types);
        }
        else {
            var entries = 0;
            var maxLevel = this._nestingLevelCounts.length;
            for (var i = 0; i < this._nestingLevelCounts.length; i++) {
                var n = this._nestingLevelCounts[i];
                if (n) {
                    if (n + entries > this._foldingRangesLimit) {
                        maxLevel = i;
                        break;
                    }
                    entries += n;
                }
            }
            var startIndexes = new Uint32Array(entries);
            var endIndexes = new Uint32Array(entries);
            var types = [];
            for (var i = 0, k = 0; i < this._length; i++) {
                var level = this._nestingLevels[i];
                if (level < maxLevel) {
                    startIndexes[k] = this._startIndexes[i];
                    endIndexes[k] = this._endIndexes[i];
                    types[k] = this._types[i];
                    k++;
                }
            }
            return new FoldingRegions(startIndexes, endIndexes, types);
        }
    };
    return RangesCollector;
}());
function sanitizeRanges(rangeData) {
    var sorted = rangeData.sort(function (d1, d2) {
        var diff = d1.start - d2.start;
        if (diff === 0) {
            diff = d1.rank - d2.rank;
        }
        return diff;
    });
    var collector = new RangesCollector$1(MAX_FOLDING_REGIONS_FOR_INDENT_LIMIT$1);
    var top = null;
    var previous = [];
    for (var _i = 0, sorted_1 = sorted; _i < sorted_1.length; _i++) {
        var entry = sorted_1[_i];
        if (!top) {
            top = entry;
            collector.add(entry.start, entry.end, entry.kind && entry.kind.value, previous.length);
        }
        else {
            if (entry.start > top.start) {
                if (entry.end <= top.end) {
                    previous.push(top);
                    top = entry;
                    collector.add(entry.start, entry.end, entry.kind && entry.kind.value, previous.length);
                }
                else if (entry.start > top.end) {
                    do {
                        top = previous.pop();
                    } while (top && entry.start > top.end);
                    previous.push(top);
                    top = entry;
                    collector.add(entry.start, entry.end, entry.kind && entry.kind.value, previous.length);
                }
            }
        }
    }
    return collector.toIndentRanges();
}

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$e = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var ID = 'editor.contrib.folding';
var FoldingController = /** @class */ (function () {
    function FoldingController(editor) {
        var _this = this;
        this.editor = editor;
        this._isEnabled = this.editor.getConfiguration().contribInfo.folding;
        this._autoHideFoldingControls = this.editor.getConfiguration().contribInfo.showFoldingControls === 'mouseover';
        this._useFoldingProviders = this.editor.getConfiguration().contribInfo.foldingStrategy !== 'indentation';
        this.globalToDispose = [];
        this.localToDispose = [];
        this.foldingDecorationProvider = new FoldingDecorationProvider(editor);
        this.foldingDecorationProvider.autoHideFoldingControls = this._autoHideFoldingControls;
        this.globalToDispose.push(this.editor.onDidChangeModel(function () { return _this.onModelChanged(); }));
        this.globalToDispose.push(FoldingRangeProviderRegistry.onDidChange(function () { return _this.onFoldingStrategyChanged(); }));
        this.globalToDispose.push(this.editor.onDidChangeConfiguration(function (e) {
            if (e.contribInfo) {
                var oldIsEnabled = _this._isEnabled;
                _this._isEnabled = _this.editor.getConfiguration().contribInfo.folding;
                if (oldIsEnabled !== _this._isEnabled) {
                    _this.onModelChanged();
                }
                var oldShowFoldingControls = _this._autoHideFoldingControls;
                _this._autoHideFoldingControls = _this.editor.getConfiguration().contribInfo.showFoldingControls === 'mouseover';
                if (oldShowFoldingControls !== _this._autoHideFoldingControls) {
                    _this.foldingDecorationProvider.autoHideFoldingControls = _this._autoHideFoldingControls;
                    _this.onModelContentChanged();
                }
                var oldUseFoldingProviders = _this._useFoldingProviders;
                _this._useFoldingProviders = _this.editor.getConfiguration().contribInfo.foldingStrategy !== 'indentation';
                if (oldUseFoldingProviders !== _this._useFoldingProviders) {
                    _this.onFoldingStrategyChanged();
                }
            }
        }));
        this.globalToDispose.push({ dispose: function () { return dispose(_this.localToDispose); } });
        this.onModelChanged();
    }
    FoldingController.get = function (editor) {
        return editor.getContribution(ID);
    };
    FoldingController.prototype.getId = function () {
        return ID;
    };
    FoldingController.prototype.dispose = function () {
        this.globalToDispose = dispose(this.globalToDispose);
    };
    /**
     * Store view state.
     */
    FoldingController.prototype.saveViewState = function () {
        var model = this.editor.getModel();
        if (!model || !this._isEnabled || model.isTooLargeForTokenization()) {
            return {};
        }
        if (this.foldingModel) { // disposed ?
            var collapsedRegions = this.foldingModel.isInitialized ? this.foldingModel.getMemento() : this.hiddenRangeModel.getMemento();
            return { collapsedRegions: collapsedRegions, lineCount: model.getLineCount() };
        }
        return void 0;
    };
    /**
     * Restore view state.
     */
    FoldingController.prototype.restoreViewState = function (state) {
        var model = this.editor.getModel();
        if (!model || !this._isEnabled || model.isTooLargeForTokenization()) {
            return;
        }
        if (!state || !state.collapsedRegions || state.lineCount !== model.getLineCount()) {
            return;
        }
        // set the hidden ranges right away, before waiting for the folding model.
        if (this.hiddenRangeModel.applyMemento(state.collapsedRegions)) {
            this.getFoldingModel().then(function (foldingModel) {
                if (foldingModel) {
                    foldingModel.applyMemento(state.collapsedRegions);
                }
            });
        }
    };
    FoldingController.prototype.onModelChanged = function () {
        var _this = this;
        this.localToDispose = dispose(this.localToDispose);
        var model = this.editor.getModel();
        if (!this._isEnabled || !model || model.isTooLargeForTokenization()) {
            // huge files get no view model, so they cannot support hidden areas
            return;
        }
        this.foldingModel = new FoldingModel(model, this.foldingDecorationProvider);
        this.localToDispose.push(this.foldingModel);
        this.hiddenRangeModel = new HiddenRangeModel(this.foldingModel);
        this.localToDispose.push(this.hiddenRangeModel);
        this.localToDispose.push(this.hiddenRangeModel.onDidChange(function (hr) { return _this.onHiddenRangesChanges(hr); }));
        this.updateScheduler = new Delayer(200);
        this.cursorChangedScheduler = new RunOnceScheduler(function () { return _this.revealCursor(); }, 200);
        this.localToDispose.push(this.cursorChangedScheduler);
        this.localToDispose.push(this.editor.onDidChangeModelLanguageConfiguration(function (e) { return _this.onModelContentChanged(); })); // covers model language changes as well
        this.localToDispose.push(this.editor.onDidChangeModelContent(function (e) { return _this.onModelContentChanged(); }));
        this.localToDispose.push(this.editor.onDidChangeCursorPosition(function (e) { return _this.onCursorPositionChanged(); }));
        this.localToDispose.push(this.editor.onMouseDown(function (e) { return _this.onEditorMouseDown(e); }));
        this.localToDispose.push(this.editor.onMouseUp(function (e) { return _this.onEditorMouseUp(e); }));
        this.localToDispose.push({
            dispose: function () {
                if (_this.foldingRegionPromise) {
                    _this.foldingRegionPromise.cancel();
                    _this.foldingRegionPromise = null;
                }
                _this.updateScheduler.cancel();
                _this.updateScheduler = null;
                _this.foldingModel = null;
                _this.foldingModelPromise = null;
                _this.hiddenRangeModel = null;
                _this.cursorChangedScheduler = null;
                _this.rangeProvider = null;
            }
        });
        this.onModelContentChanged();
    };
    FoldingController.prototype.onFoldingStrategyChanged = function () {
        this.rangeProvider = null;
        this.onModelContentChanged();
    };
    FoldingController.prototype.getRangeProvider = function () {
        if (!this.rangeProvider) {
            if (this._useFoldingProviders) {
                var foldingProviders = FoldingRangeProviderRegistry.ordered(this.foldingModel.textModel);
                this.rangeProvider = foldingProviders.length ? new SyntaxRangeProvider(foldingProviders) : new IndentRangeProvider();
            }
            else {
                this.rangeProvider = new IndentRangeProvider();
            }
        }
        return this.rangeProvider;
    };
    FoldingController.prototype.getFoldingModel = function () {
        return this.foldingModelPromise;
    };
    FoldingController.prototype.onModelContentChanged = function () {
        var _this = this;
        if (this.updateScheduler) {
            if (this.foldingRegionPromise) {
                this.foldingRegionPromise.cancel();
                this.foldingRegionPromise = null;
            }
            this.foldingModelPromise = this.updateScheduler.trigger(function () {
                if (!_this.foldingModel) { // null if editor has been disposed, or folding turned off
                    return null;
                }
                var foldingRegionPromise = _this.foldingRegionPromise = asWinJsPromise(function (token) { return _this.getRangeProvider().compute(_this.foldingModel.textModel, token); });
                return foldingRegionPromise.then(function (foldingRanges) {
                    if (foldingRanges && foldingRegionPromise === _this.foldingRegionPromise) { // new request or cancelled in the meantime?
                        // some cursors might have moved into hidden regions, make sure they are in expanded regions
                        var selections = _this.editor.getSelections();
                        var selectionLineNumbers = selections ? selections.map(function (s) { return s.startLineNumber; }) : [];
                        _this.foldingModel.update(foldingRanges, selectionLineNumbers);
                    }
                    return _this.foldingModel;
                });
            });
        }
    };
    FoldingController.prototype.onHiddenRangesChanges = function (hiddenRanges) {
        if (hiddenRanges.length) {
            var selections = this.editor.getSelections();
            if (selections) {
                if (this.hiddenRangeModel.adjustSelections(selections)) {
                    this.editor.setSelections(selections);
                }
            }
        }
        this.editor.setHiddenAreas(hiddenRanges);
    };
    FoldingController.prototype.onCursorPositionChanged = function () {
        if (this.hiddenRangeModel.hasRanges()) {
            this.cursorChangedScheduler.schedule();
        }
    };
    FoldingController.prototype.revealCursor = function () {
        var _this = this;
        this.getFoldingModel().then(function (foldingModel) {
            if (foldingModel) {
                var selections = _this.editor.getSelections();
                if (selections && selections.length > 0) {
                    var toToggle = [];
                    var _loop_1 = function (selection) {
                        var lineNumber = selection.selectionStartLineNumber;
                        if (_this.hiddenRangeModel.isHidden(lineNumber)) {
                            toToggle.push.apply(toToggle, foldingModel.getAllRegionsAtLine(lineNumber, function (r) { return r.isCollapsed && lineNumber > r.startLineNumber; }));
                        }
                    };
                    for (var _i = 0, selections_1 = selections; _i < selections_1.length; _i++) {
                        var selection = selections_1[_i];
                        _loop_1(selection);
                    }
                    if (toToggle.length) {
                        foldingModel.toggleCollapseState(toToggle);
                        _this.reveal(selections[0].getPosition());
                    }
                }
            }
        });
    };
    FoldingController.prototype.onEditorMouseDown = function (e) {
        this.mouseDownInfo = null;
        var range$$1 = e.target.range;
        if (!this.hiddenRangeModel || !range$$1) {
            return;
        }
        if (!e.event.leftButton && !e.event.middleButton) {
            return;
        }
        var iconClicked = false;
        switch (e.target.type) {
            case MouseTargetType.GUTTER_LINE_DECORATIONS:
                var data = e.target.detail;
                var gutterOffsetX = data.offsetX - data.glyphMarginWidth - data.lineNumbersWidth;
                // TODO@joao TODO@alex TODO@martin this is such that we don't collide with dirty diff
                if (gutterOffsetX <= 10) {
                    return;
                }
                iconClicked = true;
                break;
            case MouseTargetType.CONTENT_EMPTY: {
                if (this.hiddenRangeModel.hasRanges()) {
                    var data_1 = e.target.detail;
                    if (!data_1.isAfterLines) {
                        break;
                    }
                }
                return;
            }
            case MouseTargetType.CONTENT_TEXT: {
                if (this.hiddenRangeModel.hasRanges()) {
                    var model = this.editor.getModel();
                    if (model && range$$1.startColumn === model.getLineMaxColumn(range$$1.startLineNumber)) {
                        break;
                    }
                }
                return;
            }
            default:
                return;
        }
        this.mouseDownInfo = { lineNumber: range$$1.startLineNumber, iconClicked: iconClicked };
    };
    FoldingController.prototype.onEditorMouseUp = function (e) {
        var _this = this;
        if (!this.mouseDownInfo) {
            return;
        }
        var lineNumber = this.mouseDownInfo.lineNumber;
        var iconClicked = this.mouseDownInfo.iconClicked;
        var range$$1 = e.target.range;
        if (!range$$1 || range$$1.startLineNumber !== lineNumber) {
            return;
        }
        if (iconClicked) {
            if (e.target.type !== MouseTargetType.GUTTER_LINE_DECORATIONS) {
                return;
            }
        }
        else {
            var model = this.editor.getModel();
            if (range$$1.startColumn !== model.getLineMaxColumn(lineNumber)) {
                return;
            }
        }
        this.getFoldingModel().then(function (foldingModel) {
            if (foldingModel) {
                var region = foldingModel.getRegionAtLine(lineNumber);
                if (region && region.startLineNumber === lineNumber) {
                    var isCollapsed_1 = region.isCollapsed;
                    if (iconClicked || isCollapsed_1) {
                        var toToggle = [region];
                        if (e.event.middleButton || e.event.shiftKey) {
                            toToggle.push.apply(toToggle, foldingModel.getRegionsInside(region, function (r) { return r.isCollapsed === isCollapsed_1; }));
                        }
                        foldingModel.toggleCollapseState(toToggle);
                        _this.reveal({ lineNumber: lineNumber, column: 1 });
                    }
                }
            }
        });
    };
    FoldingController.prototype.reveal = function (position) {
        this.editor.revealPositionInCenterIfOutsideViewport(position, 0 /* Smooth */);
    };
    FoldingController.MAX_FOLDING_REGIONS = 5000;
    return FoldingController;
}());
var FoldingAction = /** @class */ (function (_super) {
    __extends$e(FoldingAction, _super);
    function FoldingAction() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    FoldingAction.prototype.runEditorCommand = function (accessor, editor, args) {
        var _this = this;
        var foldingController = FoldingController.get(editor);
        if (!foldingController) {
            return;
        }
        var foldingModelPromise = foldingController.getFoldingModel();
        if (foldingModelPromise) {
            this.reportTelemetry(accessor, editor);
            return foldingModelPromise.then(function (foldingModel) {
                if (foldingModel) {
                    _this.invoke(foldingController, foldingModel, editor, args);
                    foldingController.reveal(editor.getSelection().getStartPosition());
                }
            });
        }
    };
    FoldingAction.prototype.getSelectedLines = function (editor) {
        var selections = editor.getSelections();
        return selections ? selections.map(function (s) { return s.startLineNumber; }) : [];
    };
    FoldingAction.prototype.getLineNumbers = function (args, editor) {
        if (args && args.selectionLines) {
            return args.selectionLines.map(function (l) { return l + 1; }); // to 0-bases line numbers
        }
        return this.getSelectedLines(editor);
    };
    FoldingAction.prototype.run = function (accessor, editor) {
    };
    return FoldingAction;
}(EditorAction));
function foldingArgumentsConstraint(args) {
    if (!isUndefined(args)) {
        if (!isObject(args)) {
            return false;
        }
        var foldingArgs = args;
        if (!isUndefined(foldingArgs.levels) && !isNumber(foldingArgs.levels)) {
            return false;
        }
        if (!isUndefined(foldingArgs.direction) && !isString(foldingArgs.direction)) {
            return false;
        }
        if (!isUndefined(foldingArgs.selectionLines) && (!isArray(foldingArgs.selectionLines) || !foldingArgs.selectionLines.every(isNumber))) {
            return false;
        }
    }
    return true;
}
var UnfoldAction = /** @class */ (function (_super) {
    __extends$e(UnfoldAction, _super);
    function UnfoldAction() {
        return _super.call(this, {
            id: 'editor.unfold',
            label: localize('unfoldAction.label', "Unfold"),
            alias: 'Unfold',
            precondition: null,
            kbOpts: {
                kbExpr: EditorContextKeys.editorTextFocus,
                primary: 2048 /* CtrlCmd */ | 1024 /* Shift */ | 89 /* US_CLOSE_SQUARE_BRACKET */,
                mac: {
                    primary: 2048 /* CtrlCmd */ | 512 /* Alt */ | 89 /* US_CLOSE_SQUARE_BRACKET */
                }
            },
            description: {
                description: 'Unfold the content in the editor',
                args: [
                    {
                        name: 'Unfold editor argument',
                        description: "Property-value pairs that can be passed through this argument:\n\t\t\t\t\t\t* 'levels': Number of levels to unfold. If not set, defaults to 1.\n\t\t\t\t\t\t* 'direction': If 'up', unfold given number of levels up otherwise unfolds down\n\t\t\t\t\t\t* 'selectionLines': The start lines (0-based) of the editor selections to apply the unfold action to. If not set, the active selection(s) will be used.\n\t\t\t\t\t\t",
                        constraint: foldingArgumentsConstraint
                    }
                ]
            }
        }) || this;
    }
    UnfoldAction.prototype.invoke = function (foldingController, foldingModel, editor, args) {
        var levels = args && args.levels || 1;
        var lineNumbers = this.getLineNumbers(args, editor);
        if (args && args.direction === 'up') {
            setCollapseStateLevelsUp(foldingModel, false, levels, lineNumbers);
        }
        else {
            setCollapseStateLevelsDown(foldingModel, false, levels, lineNumbers);
        }
    };
    return UnfoldAction;
}(FoldingAction));
var UnFoldRecursivelyAction = /** @class */ (function (_super) {
    __extends$e(UnFoldRecursivelyAction, _super);
    function UnFoldRecursivelyAction() {
        return _super.call(this, {
            id: 'editor.unfoldRecursively',
            label: localize('unFoldRecursivelyAction.label', "Unfold Recursively"),
            alias: 'Unfold Recursively',
            precondition: null,
            kbOpts: {
                kbExpr: EditorContextKeys.editorTextFocus,
                primary: KeyChord(2048 /* CtrlCmd */ | 41 /* KEY_K */, 2048 /* CtrlCmd */ | 89 /* US_CLOSE_SQUARE_BRACKET */)
            }
        }) || this;
    }
    UnFoldRecursivelyAction.prototype.invoke = function (foldingController, foldingModel, editor, args) {
        setCollapseStateLevelsDown(foldingModel, false, Number.MAX_VALUE, this.getSelectedLines(editor));
    };
    return UnFoldRecursivelyAction;
}(FoldingAction));
var FoldAction = /** @class */ (function (_super) {
    __extends$e(FoldAction, _super);
    function FoldAction() {
        return _super.call(this, {
            id: 'editor.fold',
            label: localize('foldAction.label', "Fold"),
            alias: 'Fold',
            precondition: null,
            kbOpts: {
                kbExpr: EditorContextKeys.editorTextFocus,
                primary: 2048 /* CtrlCmd */ | 1024 /* Shift */ | 87 /* US_OPEN_SQUARE_BRACKET */,
                mac: {
                    primary: 2048 /* CtrlCmd */ | 512 /* Alt */ | 87 /* US_OPEN_SQUARE_BRACKET */
                }
            },
            description: {
                description: 'Fold the content in the editor',
                args: [
                    {
                        name: 'Fold editor argument',
                        description: "Property-value pairs that can be passed through this argument:\n\t\t\t\t\t\t\t* 'levels': Number of levels to fold. Defaults to 1\n\t\t\t\t\t\t\t* 'direction': If 'up', folds given number of levels up otherwise folds down\n\t\t\t\t\t\t\t* 'selectionLines': The start lines (0-based) of the editor selections to apply the fold action to. If not set, the active selection(s) will be used.\n\t\t\t\t\t\t",
                        constraint: foldingArgumentsConstraint
                    }
                ]
            }
        }) || this;
    }
    FoldAction.prototype.invoke = function (foldingController, foldingModel, editor, args) {
        var levels = args && args.levels || 1;
        var lineNumbers = this.getLineNumbers(args, editor);
        if (args && args.direction === 'up') {
            setCollapseStateLevelsUp(foldingModel, true, levels, lineNumbers);
        }
        else {
            setCollapseStateLevelsDown(foldingModel, true, levels, lineNumbers);
        }
    };
    return FoldAction;
}(FoldingAction));
var FoldRecursivelyAction = /** @class */ (function (_super) {
    __extends$e(FoldRecursivelyAction, _super);
    function FoldRecursivelyAction() {
        return _super.call(this, {
            id: 'editor.foldRecursively',
            label: localize('foldRecursivelyAction.label', "Fold Recursively"),
            alias: 'Fold Recursively',
            precondition: null,
            kbOpts: {
                kbExpr: EditorContextKeys.editorTextFocus,
                primary: KeyChord(2048 /* CtrlCmd */ | 41 /* KEY_K */, 2048 /* CtrlCmd */ | 87 /* US_OPEN_SQUARE_BRACKET */)
            }
        }) || this;
    }
    FoldRecursivelyAction.prototype.invoke = function (foldingController, foldingModel, editor) {
        var selectedLines = this.getSelectedLines(editor);
        setCollapseStateLevelsDown(foldingModel, true, Number.MAX_VALUE, selectedLines);
    };
    return FoldRecursivelyAction;
}(FoldingAction));
var FoldAllBlockCommentsAction = /** @class */ (function (_super) {
    __extends$e(FoldAllBlockCommentsAction, _super);
    function FoldAllBlockCommentsAction() {
        return _super.call(this, {
            id: 'editor.foldAllBlockComments',
            label: localize('foldAllBlockComments.label', "Fold All Block Comments"),
            alias: 'Fold All Block Comments',
            precondition: null,
            kbOpts: {
                kbExpr: EditorContextKeys.editorTextFocus,
                primary: KeyChord(2048 /* CtrlCmd */ | 41 /* KEY_K */, 2048 /* CtrlCmd */ | 85 /* US_SLASH */)
            }
        }) || this;
    }
    FoldAllBlockCommentsAction.prototype.invoke = function (foldingController, foldingModel, editor) {
        if (foldingModel.regions.hasTypes()) {
            setCollapseStateForType(foldingModel, FoldingRangeKind.Comment.value, true);
        }
        else {
            var comments = LanguageConfigurationRegistry.getComments(editor.getModel().getLanguageIdentifier().id);
            if (comments && comments.blockCommentStartToken) {
                var regExp = new RegExp('^\\s*' + escapeRegExpCharacters(comments.blockCommentStartToken));
                setCollapseStateForMatchingLines(foldingModel, regExp, true);
            }
        }
    };
    return FoldAllBlockCommentsAction;
}(FoldingAction));
var FoldAllRegionsAction = /** @class */ (function (_super) {
    __extends$e(FoldAllRegionsAction, _super);
    function FoldAllRegionsAction() {
        return _super.call(this, {
            id: 'editor.foldAllMarkerRegions',
            label: localize('foldAllMarkerRegions.label', "Fold All Regions"),
            alias: 'Fold All Regions',
            precondition: null,
            kbOpts: {
                kbExpr: EditorContextKeys.editorTextFocus,
                primary: KeyChord(2048 /* CtrlCmd */ | 41 /* KEY_K */, 2048 /* CtrlCmd */ | 29 /* KEY_8 */)
            }
        }) || this;
    }
    FoldAllRegionsAction.prototype.invoke = function (foldingController, foldingModel, editor) {
        if (foldingModel.regions.hasTypes()) {
            setCollapseStateForType(foldingModel, FoldingRangeKind.Region.value, true);
        }
        else {
            var foldingRules = LanguageConfigurationRegistry.getFoldingRules(editor.getModel().getLanguageIdentifier().id);
            if (foldingRules && foldingRules.markers && foldingRules.markers.start) {
                var regExp = new RegExp(foldingRules.markers.start);
                setCollapseStateForMatchingLines(foldingModel, regExp, true);
            }
        }
    };
    return FoldAllRegionsAction;
}(FoldingAction));
var UnfoldAllRegionsAction = /** @class */ (function (_super) {
    __extends$e(UnfoldAllRegionsAction, _super);
    function UnfoldAllRegionsAction() {
        return _super.call(this, {
            id: 'editor.unfoldAllMarkerRegions',
            label: localize('unfoldAllMarkerRegions.label', "Unfold All Regions"),
            alias: 'Unfold All Regions',
            precondition: null,
            kbOpts: {
                kbExpr: EditorContextKeys.editorTextFocus,
                primary: KeyChord(2048 /* CtrlCmd */ | 41 /* KEY_K */, 2048 /* CtrlCmd */ | 30 /* KEY_9 */)
            }
        }) || this;
    }
    UnfoldAllRegionsAction.prototype.invoke = function (foldingController, foldingModel, editor) {
        if (foldingModel.regions.hasTypes()) {
            setCollapseStateForType(foldingModel, FoldingRangeKind.Region.value, false);
        }
        else {
            var foldingRules = LanguageConfigurationRegistry.getFoldingRules(editor.getModel().getLanguageIdentifier().id);
            if (foldingRules && foldingRules.markers && foldingRules.markers.start) {
                var regExp = new RegExp(foldingRules.markers.start);
                setCollapseStateForMatchingLines(foldingModel, regExp, false);
            }
        }
    };
    return UnfoldAllRegionsAction;
}(FoldingAction));
var FoldAllAction = /** @class */ (function (_super) {
    __extends$e(FoldAllAction, _super);
    function FoldAllAction() {
        return _super.call(this, {
            id: 'editor.foldAll',
            label: localize('foldAllAction.label', "Fold All"),
            alias: 'Fold All',
            precondition: null,
            kbOpts: {
                kbExpr: EditorContextKeys.editorTextFocus,
                primary: KeyChord(2048 /* CtrlCmd */ | 41 /* KEY_K */, 2048 /* CtrlCmd */ | 21 /* KEY_0 */)
            }
        }) || this;
    }
    FoldAllAction.prototype.invoke = function (foldingController, foldingModel, editor) {
        setCollapseStateLevelsDown(foldingModel, true);
    };
    return FoldAllAction;
}(FoldingAction));
var UnfoldAllAction = /** @class */ (function (_super) {
    __extends$e(UnfoldAllAction, _super);
    function UnfoldAllAction() {
        return _super.call(this, {
            id: 'editor.unfoldAll',
            label: localize('unfoldAllAction.label', "Unfold All"),
            alias: 'Unfold All',
            precondition: null,
            kbOpts: {
                kbExpr: EditorContextKeys.editorTextFocus,
                primary: KeyChord(2048 /* CtrlCmd */ | 41 /* KEY_K */, 2048 /* CtrlCmd */ | 40 /* KEY_J */)
            }
        }) || this;
    }
    UnfoldAllAction.prototype.invoke = function (foldingController, foldingModel, editor) {
        setCollapseStateLevelsDown(foldingModel, false);
    };
    return UnfoldAllAction;
}(FoldingAction));
var FoldLevelAction = /** @class */ (function (_super) {
    __extends$e(FoldLevelAction, _super);
    function FoldLevelAction() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    FoldLevelAction.prototype.getFoldingLevel = function () {
        return parseInt(this.id.substr(FoldLevelAction.ID_PREFIX.length));
    };
    FoldLevelAction.prototype.invoke = function (foldingController, foldingModel, editor) {
        setCollapseStateAtLevel(foldingModel, this.getFoldingLevel(), true, this.getSelectedLines(editor));
    };
    FoldLevelAction.ID_PREFIX = 'editor.foldLevel';
    FoldLevelAction.ID = function (level) { return FoldLevelAction.ID_PREFIX + level; };
    return FoldLevelAction;
}(FoldingAction));
registerEditorContribution(FoldingController);
registerEditorAction(UnfoldAction);
registerEditorAction(UnFoldRecursivelyAction);
registerEditorAction(FoldAction);
registerEditorAction(FoldRecursivelyAction);
registerEditorAction(FoldAllAction);
registerEditorAction(UnfoldAllAction);
registerEditorAction(FoldAllBlockCommentsAction);
registerEditorAction(FoldAllRegionsAction);
registerEditorAction(UnfoldAllRegionsAction);
for (var i = 1; i <= 7; i++) {
    registerInstantiatedEditorAction(new FoldLevelAction({
        id: FoldLevelAction.ID(i),
        label: localize('foldLevelAction.label', "Fold Level {0}", i),
        alias: "Fold Level " + i,
        precondition: null,
        kbOpts: {
            kbExpr: EditorContextKeys.editorTextFocus,
            primary: KeyChord(2048 /* CtrlCmd */ | 41 /* KEY_K */, 2048 /* CtrlCmd */ | (21 /* KEY_0 */ + i))
        }
    }));
}

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$f = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var NoProviderError = /** @class */ (function (_super) {
    __extends$f(NoProviderError, _super);
    function NoProviderError(message) {
        var _this = _super.call(this) || this;
        _this.name = NoProviderError.Name;
        _this.message = message;
        return _this;
    }
    NoProviderError.Name = 'NOPRO';
    return NoProviderError;
}(Error));
function getDocumentRangeFormattingEdits(model, range$$1, options) {
    var providers = DocumentRangeFormattingEditProviderRegistry.ordered(model);
    if (providers.length === 0) {
        return TPromise.wrapError(new NoProviderError());
    }
    var result;
    return sequence(providers.map(function (provider) {
        return function () {
            if (!isFalsyOrEmpty(result)) {
                return undefined;
            }
            return asWinJsPromise(function (token) { return provider.provideDocumentRangeFormattingEdits(model, range$$1, options, token); }).then(function (value) {
                result = value;
            }, onUnexpectedExternalError);
        };
    })).then(function () { return result; });
}
function getDocumentFormattingEdits(model, options) {
    var providers = DocumentFormattingEditProviderRegistry.ordered(model);
    // try range formatters when no document formatter is registered
    if (providers.length === 0) {
        return getDocumentRangeFormattingEdits(model, model.getFullModelRange(), options);
    }
    var result;
    return sequence(providers.map(function (provider) {
        return function () {
            if (!isFalsyOrEmpty(result)) {
                return undefined;
            }
            return asWinJsPromise(function (token) { return provider.provideDocumentFormattingEdits(model, options, token); }).then(function (value) {
                result = value;
            }, onUnexpectedExternalError);
        };
    })).then(function () { return result; });
}
function getOnTypeFormattingEdits(model, position, ch, options) {
    var support = OnTypeFormattingEditProviderRegistry.ordered(model)[0];
    if (!support) {
        return TPromise.as(undefined);
    }
    if (support.autoFormatTriggerCharacters.indexOf(ch) < 0) {
        return TPromise.as(undefined);
    }
    return asWinJsPromise(function (token) {
        return support.provideOnTypeFormattingEdits(model, position, ch, options, token);
    }).then(function (r) { return r; }, onUnexpectedExternalError);
}
registerLanguageCommand('_executeFormatRangeProvider', function (accessor, args) {
    var resource = args.resource, range$$1 = args.range, options = args.options;
    if (!(resource instanceof URI) || !Range.isIRange(range$$1)) {
        throw illegalArgument();
    }
    var model = accessor.get(IModelService).getModel(resource);
    if (!model) {
        throw illegalArgument('resource');
    }
    return getDocumentRangeFormattingEdits(model, Range.lift(range$$1), options);
});
registerLanguageCommand('_executeFormatDocumentProvider', function (accessor, args) {
    var resource = args.resource, options = args.options;
    if (!(resource instanceof URI)) {
        throw illegalArgument('resource');
    }
    var model = accessor.get(IModelService).getModel(resource);
    if (!model) {
        throw illegalArgument('resource');
    }
    return getDocumentFormattingEdits(model, options);
});
registerDefaultLanguageCommand('_executeFormatOnTypeProvider', function (model, position, args) {
    var ch = args.ch, options = args.options;
    if (typeof ch !== 'string') {
        throw illegalArgument('ch');
    }
    return getOnTypeFormattingEdits(model, position, ch, options);
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var EditOperationsCommand = /** @class */ (function () {
    function EditOperationsCommand(edits, initialSelection) {
        this._initialSelection = initialSelection;
        this._edits = edits;
    }
    EditOperationsCommand._handleEolEdits = function (editor, edits) {
        var newEol = undefined;
        var singleEdits = [];
        for (var _i = 0, edits_1 = edits; _i < edits_1.length; _i++) {
            var edit = edits_1[_i];
            if (typeof edit.eol === 'number') {
                newEol = edit.eol;
            }
            if (edit.range && typeof edit.text === 'string') {
                singleEdits.push(edit);
            }
        }
        if (typeof newEol === 'number') {
            editor.getModel().setEOL(newEol);
        }
        return singleEdits;
    };
    EditOperationsCommand.executeAsCommand = function (editor, _edits) {
        var edits = this._handleEolEdits(editor, _edits);
        var cmd = new EditOperationsCommand(edits, editor.getSelection());
        editor.pushUndoStop();
        editor.executeCommand('formatEditsCommand', cmd);
        editor.pushUndoStop();
    };
    EditOperationsCommand.isFullModelReplaceEdit = function (editor, edit) {
        var model = editor.getModel();
        var editRange = model.validateRange(edit.range);
        var fullModelRange = model.getFullModelRange();
        return fullModelRange.equalsRange(editRange);
    };
    EditOperationsCommand.execute = function (editor, _edits) {
        var edits = this._handleEolEdits(editor, _edits);
        editor.pushUndoStop();
        if (edits.length === 1 && EditOperationsCommand.isFullModelReplaceEdit(editor, edits[0])) {
            // We use replace semantics and hope that markers stay put...
            editor.executeEdits('formatEditsCommand', edits.map(function (edit) { return EditOperation.replace(Range.lift(edit.range), edit.text); }));
        }
        else {
            editor.executeEdits('formatEditsCommand', edits.map(function (edit) { return EditOperation.replaceMove(Range.lift(edit.range), edit.text); }));
        }
        editor.pushUndoStop();
    };
    EditOperationsCommand.prototype.getEditOperations = function (model, builder) {
        for (var _i = 0, _a = this._edits; _i < _a.length; _i++) {
            var edit = _a[_i];
            // We know that this edit.range comes from the mirror model, so it should only contain \n and no \r's
            var trimEdit = EditOperationsCommand.trimEdit(edit, model);
            if (trimEdit !== null) { // produced above in case the edit.text is identical to the existing text
                builder.addEditOperation(Range.lift(edit.range), edit.text);
            }
        }
        var selectionIsSet = false;
        if (Array.isArray(this._edits) && this._edits.length === 1 && this._initialSelection.isEmpty()) {
            if (this._edits[0].range.startColumn === this._initialSelection.endColumn &&
                this._edits[0].range.startLineNumber === this._initialSelection.endLineNumber) {
                selectionIsSet = true;
                this._selectionId = builder.trackSelection(this._initialSelection, true);
            }
            else if (this._edits[0].range.endColumn === this._initialSelection.startColumn &&
                this._edits[0].range.endLineNumber === this._initialSelection.startLineNumber) {
                selectionIsSet = true;
                this._selectionId = builder.trackSelection(this._initialSelection, false);
            }
        }
        if (!selectionIsSet) {
            this._selectionId = builder.trackSelection(this._initialSelection);
        }
    };
    EditOperationsCommand.prototype.computeCursorState = function (model, helper) {
        return helper.getTrackedSelection(this._selectionId);
    };
    EditOperationsCommand.fixLineTerminators = function (edit, model) {
        edit.text = edit.text.replace(/\r\n|\r|\n/g, model.getEOL());
    };
    /**
     * This is used to minimize the edits by removing changes that appear on the edges of the range which are identical
     * to the current text.
     *
     * The reason this was introduced is to allow better selection tracking of the current cursor and solve
     * bug #15108. There the cursor was jumping since the tracked selection was in the middle of the range edit
     * and was lost.
     */
    EditOperationsCommand.trimEdit = function (edit, model) {
        this.fixLineTerminators(edit, model);
        return this._trimEdit(model.validateRange(edit.range), edit.text, edit.forceMoveMarkers, model);
    };
    EditOperationsCommand._trimEdit = function (editRange, editText, editForceMoveMarkers, model) {
        var currentText = model.getValueInRange(editRange);
        // Find the equal characters in the front
        var commonPrefixLength$$1 = commonPrefixLength(editText, currentText);
        // If the two strings are identical, return no edit (no-op)
        if (commonPrefixLength$$1 === currentText.length && commonPrefixLength$$1 === editText.length) {
            return null;
        }
        if (commonPrefixLength$$1 > 0) {
            // Apply front trimming
            var newStartPosition = model.modifyPosition(editRange.getStartPosition(), commonPrefixLength$$1);
            editRange = new Range(newStartPosition.lineNumber, newStartPosition.column, editRange.endLineNumber, editRange.endColumn);
            editText = editText.substring(commonPrefixLength$$1);
            currentText = currentText.substr(commonPrefixLength$$1);
        }
        // Find the equal characters in the rear
        var commonSuffixLength$$1 = commonSuffixLength(editText, currentText);
        if (commonSuffixLength$$1 > 0) {
            // Apply rear trimming
            var newEndPosition = model.modifyPosition(editRange.getEndPosition(), -commonSuffixLength$$1);
            editRange = new Range(editRange.startLineNumber, editRange.startColumn, newEndPosition.lineNumber, newEndPosition.column);
            editText = editText.substring(0, editText.length - commonSuffixLength$$1);
            currentText = currentText.substring(0, currentText.length - commonSuffixLength$$1);
        }
        return {
            text: editText,
            range: editRange,
            forceMoveMarkers: editForceMoveMarkers
        };
    };
    return EditOperationsCommand;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$g = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate$4 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$4 = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
function alertFormattingEdits(edits) {
    edits = edits.filter(function (edit) { return edit.range; });
    if (!edits.length) {
        return;
    }
    var range$$1 = edits[0].range;
    for (var i = 1; i < edits.length; i++) {
        range$$1 = Range.plusRange(range$$1, edits[i].range);
    }
    var startLineNumber = range$$1.startLineNumber, endLineNumber = range$$1.endLineNumber;
    if (startLineNumber === endLineNumber) {
        if (edits.length === 1) {
            alert(localize('hint11', "Made 1 formatting edit on line {0}", startLineNumber));
        }
        else {
            alert(localize('hintn1', "Made {0} formatting edits on line {1}", edits.length, startLineNumber));
        }
    }
    else {
        if (edits.length === 1) {
            alert(localize('hint1n', "Made 1 formatting edit between lines {0} and {1}", startLineNumber, endLineNumber));
        }
        else {
            alert(localize('hintnn', "Made {0} formatting edits between lines {1} and {2}", edits.length, startLineNumber, endLineNumber));
        }
    }
}
var FormatOnType = /** @class */ (function () {
    function FormatOnType(editor, workerService) {
        var _this = this;
        this.editor = editor;
        this.workerService = workerService;
        this.callOnDispose = [];
        this.callOnModel = [];
        this.callOnDispose.push(editor.onDidChangeConfiguration(function () { return _this.update(); }));
        this.callOnDispose.push(editor.onDidChangeModel(function () { return _this.update(); }));
        this.callOnDispose.push(editor.onDidChangeModelLanguage(function () { return _this.update(); }));
        this.callOnDispose.push(OnTypeFormattingEditProviderRegistry.onDidChange(this.update, this));
    }
    FormatOnType.prototype.update = function () {
        var _this = this;
        // clean up
        this.callOnModel = dispose(this.callOnModel);
        // we are disabled
        if (!this.editor.getConfiguration().contribInfo.formatOnType) {
            return;
        }
        // no model
        if (!this.editor.getModel()) {
            return;
        }
        var model = this.editor.getModel();
        // no support
        var support = OnTypeFormattingEditProviderRegistry.ordered(model)[0];
        if (!support || !support.autoFormatTriggerCharacters) {
            return;
        }
        // register typing listeners that will trigger the format
        var triggerChars = new CharacterSet();
        for (var _i = 0, _a = support.autoFormatTriggerCharacters; _i < _a.length; _i++) {
            var ch = _a[_i];
            triggerChars.add(ch.charCodeAt(0));
        }
        this.callOnModel.push(this.editor.onDidType(function (text) {
            var lastCharCode = text.charCodeAt(text.length - 1);
            if (triggerChars.has(lastCharCode)) {
                _this.trigger(String.fromCharCode(lastCharCode));
            }
        }));
    };
    FormatOnType.prototype.trigger = function (ch) {
        var _this = this;
        if (this.editor.getSelections().length > 1) {
            return;
        }
        var model = this.editor.getModel(), position = this.editor.getPosition(), canceled$$1 = false;
        // install a listener that checks if edits happens before the
        // position on which we format right now. If so, we won't
        // apply the format edits
        var unbind = this.editor.onDidChangeModelContent(function (e) {
            if (e.isFlush) {
                // a model.setValue() was called
                // cancel only once
                canceled$$1 = true;
                unbind.dispose();
                return;
            }
            for (var i = 0, len = e.changes.length; i < len; i++) {
                var change = e.changes[i];
                if (change.range.endLineNumber <= position.lineNumber) {
                    // cancel only once
                    canceled$$1 = true;
                    unbind.dispose();
                    return;
                }
            }
        });
        var modelOpts = model.getOptions();
        getOnTypeFormattingEdits(model, position, ch, {
            tabSize: modelOpts.tabSize,
            insertSpaces: modelOpts.insertSpaces
        }).then(function (edits) {
            return _this.workerService.computeMoreMinimalEdits(model.uri, edits);
        }).then(function (edits) {
            unbind.dispose();
            if (canceled$$1 || isFalsyOrEmpty(edits)) {
                return;
            }
            EditOperationsCommand.executeAsCommand(_this.editor, edits);
            alertFormattingEdits(edits);
        }, function (err) {
            unbind.dispose();
            throw err;
        });
    };
    FormatOnType.prototype.getId = function () {
        return FormatOnType.ID;
    };
    FormatOnType.prototype.dispose = function () {
        this.callOnDispose = dispose(this.callOnDispose);
        this.callOnModel = dispose(this.callOnModel);
    };
    FormatOnType.ID = 'editor.contrib.autoFormat';
    FormatOnType = __decorate$4([
        __param$4(1, IEditorWorkerService)
    ], FormatOnType);
    return FormatOnType;
}());
var FormatOnPaste = /** @class */ (function () {
    function FormatOnPaste(editor, workerService) {
        var _this = this;
        this.editor = editor;
        this.workerService = workerService;
        this.callOnDispose = [];
        this.callOnModel = [];
        this.callOnDispose.push(editor.onDidChangeConfiguration(function () { return _this.update(); }));
        this.callOnDispose.push(editor.onDidChangeModel(function () { return _this.update(); }));
        this.callOnDispose.push(editor.onDidChangeModelLanguage(function () { return _this.update(); }));
        this.callOnDispose.push(DocumentRangeFormattingEditProviderRegistry.onDidChange(this.update, this));
    }
    FormatOnPaste.prototype.update = function () {
        var _this = this;
        // clean up
        this.callOnModel = dispose(this.callOnModel);
        // we are disabled
        if (!this.editor.getConfiguration().contribInfo.formatOnPaste) {
            return;
        }
        // no model
        if (!this.editor.getModel()) {
            return;
        }
        var model = this.editor.getModel();
        // no support
        var support = DocumentRangeFormattingEditProviderRegistry.ordered(model)[0];
        if (!support || !support.provideDocumentRangeFormattingEdits) {
            return;
        }
        this.callOnModel.push(this.editor.onDidPaste(function (range$$1) {
            _this.trigger(range$$1);
        }));
    };
    FormatOnPaste.prototype.trigger = function (range$$1) {
        var _this = this;
        if (this.editor.getSelections().length > 1) {
            return;
        }
        var model = this.editor.getModel();
        var _a = model.getOptions(), tabSize = _a.tabSize, insertSpaces = _a.insertSpaces;
        var state = new EditorState(this.editor, 1 /* Value */ | 4 /* Position */);
        getDocumentRangeFormattingEdits(model, range$$1, { tabSize: tabSize, insertSpaces: insertSpaces }).then(function (edits) {
            return _this.workerService.computeMoreMinimalEdits(model.uri, edits);
        }).then(function (edits) {
            if (!state.validate(_this.editor) || isFalsyOrEmpty(edits)) {
                return;
            }
            EditOperationsCommand.execute(_this.editor, edits);
            alertFormattingEdits(edits);
        });
    };
    FormatOnPaste.prototype.getId = function () {
        return FormatOnPaste.ID;
    };
    FormatOnPaste.prototype.dispose = function () {
        this.callOnDispose = dispose(this.callOnDispose);
        this.callOnModel = dispose(this.callOnModel);
    };
    FormatOnPaste.ID = 'editor.contrib.formatOnPaste';
    FormatOnPaste = __decorate$4([
        __param$4(1, IEditorWorkerService)
    ], FormatOnPaste);
    return FormatOnPaste;
}());
var AbstractFormatAction = /** @class */ (function (_super) {
    __extends$g(AbstractFormatAction, _super);
    function AbstractFormatAction() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    AbstractFormatAction.prototype.run = function (accessor, editor) {
        var _this = this;
        var workerService = accessor.get(IEditorWorkerService);
        var notificationService = accessor.get(INotificationService);
        var formattingPromise = this._getFormattingEdits(editor);
        if (!formattingPromise) {
            return TPromise.as(void 0);
        }
        // Capture the state of the editor
        var state = new EditorState(editor, 1 /* Value */ | 4 /* Position */);
        // Receive formatted value from worker
        return formattingPromise.then(function (edits) { return workerService.computeMoreMinimalEdits(editor.getModel().uri, edits); }).then(function (edits) {
            if (!state.validate(editor) || isFalsyOrEmpty(edits)) {
                return;
            }
            EditOperationsCommand.execute(editor, edits);
            alertFormattingEdits(edits);
            editor.focus();
        }, function (err) {
            if (err instanceof Error && err.name === NoProviderError.Name) {
                _this._notifyNoProviderError(notificationService, editor.getModel().getLanguageIdentifier().language);
            }
            else {
                throw err;
            }
        });
    };
    AbstractFormatAction.prototype._notifyNoProviderError = function (notificationService, language) {
        notificationService.info(localize('no.provider', "There is no formatter for '{0}'-files installed.", language));
    };
    return AbstractFormatAction;
}(EditorAction));
var FormatDocumentAction = /** @class */ (function (_super) {
    __extends$g(FormatDocumentAction, _super);
    function FormatDocumentAction() {
        return _super.call(this, {
            id: 'editor.action.formatDocument',
            label: localize('formatDocument.label', "Format Document"),
            alias: 'Format Document',
            precondition: EditorContextKeys.writable,
            kbOpts: {
                kbExpr: EditorContextKeys.editorTextFocus,
                primary: 1024 /* Shift */ | 512 /* Alt */ | 36 /* KEY_F */,
                // secondary: [KeyChord(KeyMod.CtrlCmd | KeyCode.KEY_K, KeyMod.CtrlCmd | KeyCode.KEY_D)],
                linux: { primary: 2048 /* CtrlCmd */ | 1024 /* Shift */ | 39 /* KEY_I */ }
            },
            menuOpts: {
                when: EditorContextKeys.hasDocumentFormattingProvider,
                group: '1_modification',
                order: 1.3
            }
        }) || this;
    }
    FormatDocumentAction.prototype._getFormattingEdits = function (editor) {
        var model = editor.getModel();
        var _a = model.getOptions(), tabSize = _a.tabSize, insertSpaces = _a.insertSpaces;
        return getDocumentFormattingEdits(model, { tabSize: tabSize, insertSpaces: insertSpaces });
    };
    FormatDocumentAction.prototype._notifyNoProviderError = function (notificationService, language) {
        notificationService.info(localize('no.documentprovider', "There is no document formatter for '{0}'-files installed.", language));
    };
    return FormatDocumentAction;
}(AbstractFormatAction));
var FormatSelectionAction = /** @class */ (function (_super) {
    __extends$g(FormatSelectionAction, _super);
    function FormatSelectionAction() {
        return _super.call(this, {
            id: 'editor.action.formatSelection',
            label: localize('formatSelection.label', "Format Selection"),
            alias: 'Format Code',
            precondition: ContextKeyExpr.and(EditorContextKeys.writable, EditorContextKeys.hasNonEmptySelection),
            kbOpts: {
                kbExpr: EditorContextKeys.editorTextFocus,
                primary: KeyChord(2048 /* CtrlCmd */ | 41 /* KEY_K */, 2048 /* CtrlCmd */ | 36 /* KEY_F */)
            },
            menuOpts: {
                when: ContextKeyExpr.and(EditorContextKeys.hasDocumentSelectionFormattingProvider, EditorContextKeys.hasNonEmptySelection),
                group: '1_modification',
                order: 1.31
            }
        }) || this;
    }
    FormatSelectionAction.prototype._getFormattingEdits = function (editor) {
        var model = editor.getModel();
        var _a = model.getOptions(), tabSize = _a.tabSize, insertSpaces = _a.insertSpaces;
        return getDocumentRangeFormattingEdits(model, editor.getSelection(), { tabSize: tabSize, insertSpaces: insertSpaces });
    };
    FormatSelectionAction.prototype._notifyNoProviderError = function (notificationService, language) {
        notificationService.info(localize('no.selectionprovider', "There is no selection formatter for '{0}'-files installed.", language));
    };
    return FormatSelectionAction;
}(AbstractFormatAction));
registerEditorContribution(FormatOnType);
registerEditorContribution(FormatOnPaste);
registerEditorAction(FormatDocumentAction);
registerEditorAction(FormatSelectionAction);
// this is the old format action that does both (format document OR format selection)
// and we keep it here such that existing keybinding configurations etc will still work
CommandsRegistry.registerCommand('editor.action.format', function (accessor) {
    var editor = accessor.get(ICodeEditorService).getFocusedCodeEditor();
    if (editor) {
        return new /** @class */ (function (_super) {
            __extends$g(class_1, _super);
            function class_1() {
                return _super.call(this, {}) || this;
            }
            class_1.prototype._getFormattingEdits = function (editor) {
                var model = editor.getModel();
                var editorSelection = editor.getSelection();
                var _a = model.getOptions(), tabSize = _a.tabSize, insertSpaces = _a.insertSpaces;
                return editorSelection.isEmpty()
                    ? getDocumentFormattingEdits(model, { tabSize: tabSize, insertSpaces: insertSpaces })
                    : getDocumentRangeFormattingEdits(model, editorSelection, { tabSize: tabSize, insertSpaces: insertSpaces });
            };
            return class_1;
        }(AbstractFormatAction))().run(accessor, editor);
    }
    return undefined;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
function getDefinitions(model, position, registry, provide) {
    var provider = registry.ordered(model);
    // get results
    var promises = provider.map(function (provider, idx) {
        return asWinJsPromise(function (token) {
            return provide(provider, model, position, token);
        }).then(undefined, function (err) {
            onUnexpectedExternalError(err);
            return null;
        });
    });
    return TPromise.join(promises)
        .then(flatten)
        .then(function (references) { return references.filter(function (x) { return !!x; }); });
}
function getDefinitionsAtPosition(model, position) {
    return getDefinitions(model, position, DefinitionProviderRegistry, function (provider, model, position, token) {
        return provider.provideDefinition(model, position, token);
    });
}
function getImplementationsAtPosition(model, position) {
    return getDefinitions(model, position, ImplementationProviderRegistry, function (provider, model, position, token) {
        return provider.provideImplementation(model, position, token);
    });
}
function getTypeDefinitionsAtPosition(model, position) {
    return getDefinitions(model, position, TypeDefinitionProviderRegistry, function (provider, model, position, token) {
        return provider.provideTypeDefinition(model, position, token);
    });
}
registerDefaultLanguageCommand('_executeDefinitionProvider', getDefinitionsAtPosition);
registerDefaultLanguageCommand('_executeImplementationProvider', getImplementationsAtPosition);
registerDefaultLanguageCommand('_executeTypeDefinitionProvider', getTypeDefinitionsAtPosition);

const css$a = "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n/* -- zone widget */\n.monaco-editor .zone-widget .zone-widget-container.reference-zone-widget {\n\tborder-top-width: 1px;\n\tborder-bottom-width: 1px;\n}\n\n.monaco-editor .zone-widget .zone-widget-container.reference-zone-widget.results-loaded {\n\t-webkit-transition: height 100ms ease-in;\n\ttransition: height 100ms ease-in;\n}\n\n.monaco-editor .reference-zone-widget .inline {\n\tdisplay: inline-block;\n\tvertical-align: top;\n}\n\n.monaco-editor .reference-zone-widget .messages {\n\theight: 100%;\n\twidth: 100%;\n\ttext-align: center;\n\tpadding: 3em 0;\n}\n\n.monaco-editor .reference-zone-widget .ref-tree {\n\tline-height: 23px;\n}\n\n.monaco-editor .reference-zone-widget .ref-tree .reference {\n\ttext-overflow: ellipsis;\n\toverflow: hidden;\n}\n\n.monaco-editor .reference-zone-widget .ref-tree .reference-file {\n\tdisplay: inline-flex;\n\twidth: 100%;\n\theight: 100%;\n}\n\n.monaco-editor .reference-zone-widget .ref-tree .reference-file .count {\n\tmargin-right: 12px;\n\tmargin-left: auto;\n}\n\n/* High Contrast Theming */\n\n.monaco-editor.hc-black .reference-zone-widget .ref-tree .reference-file {\n\tfont-weight: bold;\n}\n";
  const element$a = ((css, src) => {
if (typeof document !== 'object')
console.info(`Skipped loading "${src}"`);
try {
const id = src
  .replace(/\.css.*$/, '')
  .replace(/[\\:]/g, '/')
  .replace(/[^\w\/]+/g, '');
return (
  document.querySelector(`style[id="${id}"]`) ||
  document.head.appendChild(
    Object.assign(document.createElement('style'), {
      id,
      textContent: `${css}\n\n /* sourceURL=${src} */`,
    }),
  )
);
} catch (exception) {
console.warn(`Failed load "${src}"`, exception);
}
})(css$a, "…monaco-editor/esm/vs/editor/contrib/referenceSearch/media/referencesWidget.css");
  //@ sourceURL=/Users/daflair/Projects/packages/monaco-es/node_modules/monaco-editor/esm/vs/editor/contrib/referenceSearch/media/referencesWidget.css

const css$b = "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n.monaco-count-badge {\n\tpadding: 0.2em 0.5em;\n\tborder-radius: 1em;\n\tfont-size: 85%;\n\tfont-weight: normal;\n\ttext-align: center;\n\tdisplay: inline;\n}";
  const element$b = ((css, src) => {
if (typeof document !== 'object')
console.info(`Skipped loading "${src}"`);
try {
const id = src
  .replace(/\.css.*$/, '')
  .replace(/[\\:]/g, '/')
  .replace(/[^\w\/]+/g, '');
return (
  document.querySelector(`style[id="${id}"]`) ||
  document.head.appendChild(
    Object.assign(document.createElement('style'), {
      id,
      textContent: `${css}\n\n /* sourceURL=${src} */`,
    }),
  )
);
} catch (exception) {
console.warn(`Failed load "${src}"`, exception);
}
})(css$b, "…monaco-editor/esm/vs/base/browser/ui/countBadge/countBadge.css");
  //@ sourceURL=/Users/daflair/Projects/packages/monaco-es/node_modules/monaco-editor/esm/vs/base/browser/ui/countBadge/countBadge.css

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var defaultOpts$2 = {
    badgeBackground: Color.fromHex('#4D4D4D'),
    badgeForeground: Color.fromHex('#FFFFFF')
};
var CountBadge = /** @class */ (function () {
    function CountBadge(container, options) {
        this.options = options || Object.create(null);
        mixin(this.options, defaultOpts$2, false);
        this.badgeBackground = this.options.badgeBackground;
        this.badgeForeground = this.options.badgeForeground;
        this.badgeBorder = this.options.badgeBorder;
        this.element = append(container, $('.monaco-count-badge'));
        this.countFormat = this.options.countFormat || '{0}';
        this.titleFormat = this.options.titleFormat || '';
        this.setCount(this.options.count || 0);
    }
    CountBadge.prototype.setCount = function (count) {
        this.count = count;
        this.render();
    };
    CountBadge.prototype.setCountFormat = function (countFormat) {
        this.countFormat = countFormat;
        this.render();
    };
    CountBadge.prototype.setTitleFormat = function (titleFormat) {
        this.titleFormat = titleFormat;
        this.render();
    };
    CountBadge.prototype.render = function () {
        this.element.textContent = format(this.countFormat, this.count);
        this.element.title = format(this.titleFormat, this.count);
        this.applyStyles();
    };
    CountBadge.prototype.style = function (styles) {
        this.badgeBackground = styles.badgeBackground;
        this.badgeForeground = styles.badgeForeground;
        this.badgeBorder = styles.badgeBorder;
        this.applyStyles();
    };
    CountBadge.prototype.applyStyles = function () {
        if (this.element) {
            var background = this.badgeBackground ? this.badgeBackground.toString() : null;
            var foreground$$1 = this.badgeForeground ? this.badgeForeground.toString() : null;
            var border = this.badgeBorder ? this.badgeBorder.toString() : null;
            this.element.style.backgroundColor = background;
            this.element.style.color = foreground$$1;
            this.element.style.borderWidth = border ? '1px' : null;
            this.element.style.borderStyle = border ? 'solid' : null;
            this.element.style.borderColor = border;
        }
    };
    return CountBadge;
}());

const css$c = "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n/* ---------- Icon label ---------- */\n\n.monaco-icon-label {\n\tdisplay: flex; /* required for icons support :before rule */\n\toverflow: hidden;\n\ttext-overflow: ellipsis;\n}\n\n.monaco-icon-label::before {\n\n\t/* svg icons rendered as background image */\n\tbackground-size: 16px;\n\tbackground-position: left center;\n\tbackground-repeat: no-repeat;\n\tpadding-right: 6px;\n\twidth: 16px;\n\theight: 22px;\n\tdisplay: inline-block;\n\n\t/* fonts icons */\n\t-webkit-font-smoothing: antialiased;\n\tvertical-align: top;\n\n\tflex-shrink: 0; /* fix for https://github.com/Microsoft/vscode/issues/13787 */\n}\n\n.monaco-icon-label > .monaco-icon-label-description-container {\n\toverflow: hidden; /* this causes the label/description to shrink first if decorations are enabled */\n\ttext-overflow: ellipsis;\n}\n\n.monaco-icon-label > .monaco-icon-label-description-container > .label-name {\n\tcolor: inherit;\n\twhite-space: pre; /* enable to show labels that include multiple whitespaces */\n}\n\n.monaco-icon-label > .monaco-icon-label-description-container > .label-description {\n\topacity: 0.7;\n\tmargin-left: 0.5em;\n\tfont-size: 0.9em;\n\twhite-space: pre; /* enable to show labels that include multiple whitespaces */\n}\n\n.monaco-icon-label.italic > .monaco-icon-label-description-container > .label-name,\n.monaco-icon-label.italic > .monaco-icon-label-description-container > .label-description {\n\tfont-style: italic;\n}\n\n.monaco-icon-label::after {\n\topacity: 0.75;\n\tfont-size: 90%;\n\tfont-weight: 600;\n\tpadding: 0 12px 0 5px;\n\tmargin-left: auto;\n\ttext-align: center;\n}\n\n/* make sure selection color wins when a label is being selected */\n.monaco-tree.focused .selected .monaco-icon-label, /* tree */\n.monaco-tree.focused .selected .monaco-icon-label::after,\n.monaco-list:focus .selected .monaco-icon-label, /* list */\n.monaco-list:focus .selected .monaco-icon-label::after\n{\n\tcolor: inherit !important;\n}\n";
  const element$c = ((css, src) => {
if (typeof document !== 'object')
console.info(`Skipped loading "${src}"`);
try {
const id = src
  .replace(/\.css.*$/, '')
  .replace(/[\\:]/g, '/')
  .replace(/[^\w\/]+/g, '');
return (
  document.querySelector(`style[id="${id}"]`) ||
  document.head.appendChild(
    Object.assign(document.createElement('style'), {
      id,
      textContent: `${css}\n\n /* sourceURL=${src} */`,
    }),
  )
);
} catch (exception) {
console.warn(`Failed load "${src}"`, exception);
}
})(css$c, "…monaco-editor/esm/vs/base/browser/ui/iconLabel/iconlabel.css");
  //@ sourceURL=/Users/daflair/Projects/packages/monaco-es/node_modules/monaco-editor/esm/vs/base/browser/ui/iconLabel/iconlabel.css

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
function renderOcticons(text) {
    return escape(text);
}
var OcticonLabel = /** @class */ (function () {
    function OcticonLabel(container) {
        this._container = container;
    }
    Object.defineProperty(OcticonLabel.prototype, "text", {
        set: function (text) {
            this._container.innerHTML = renderOcticons(text || '');
        },
        enumerable: true,
        configurable: true
    });
    return OcticonLabel;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var HighlightedLabel = /** @class */ (function () {
    function HighlightedLabel(container) {
        this.domNode = document.createElement('span');
        this.domNode.className = 'monaco-highlighted-label';
        this.didEverRender = false;
        container.appendChild(this.domNode);
    }
    Object.defineProperty(HighlightedLabel.prototype, "element", {
        get: function () {
            return this.domNode;
        },
        enumerable: true,
        configurable: true
    });
    HighlightedLabel.prototype.set = function (text, highlights) {
        if (highlights === void 0) { highlights = []; }
        if (!text) {
            text = '';
        }
        if (this.didEverRender && this.text === text && equals(this.highlights, highlights)) {
            return;
        }
        if (!Array.isArray(highlights)) {
            highlights = [];
        }
        this.text = text;
        this.highlights = highlights;
        this.render();
    };
    HighlightedLabel.prototype.render = function () {
        clearNode(this.domNode);
        var htmlContent = [], highlight, pos = 0;
        for (var i = 0; i < this.highlights.length; i++) {
            highlight = this.highlights[i];
            if (highlight.end === highlight.start) {
                continue;
            }
            if (pos < highlight.start) {
                htmlContent.push('<span>');
                htmlContent.push(renderOcticons(this.text.substring(pos, highlight.start)));
                htmlContent.push('</span>');
                pos = highlight.end;
            }
            htmlContent.push('<span class="highlight">');
            htmlContent.push(renderOcticons(this.text.substring(highlight.start, highlight.end)));
            htmlContent.push('</span>');
            pos = highlight.end;
        }
        if (pos < this.text.length) {
            htmlContent.push('<span>');
            htmlContent.push(renderOcticons(this.text.substring(pos)));
            htmlContent.push('</span>');
        }
        this.domNode.innerHTML = htmlContent.join('');
        this.didEverRender = true;
    };
    HighlightedLabel.prototype.dispose = function () {
        this.text = null;
        this.highlights = null;
    };
    return HighlightedLabel;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$h = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var FastLabelNode = /** @class */ (function () {
    function FastLabelNode(_element) {
        this._element = _element;
    }
    Object.defineProperty(FastLabelNode.prototype, "element", {
        get: function () {
            return this._element;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FastLabelNode.prototype, "textContent", {
        set: function (content) {
            if (this.disposed || content === this._textContent) {
                return;
            }
            this._textContent = content;
            this._element.textContent = content;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FastLabelNode.prototype, "className", {
        set: function (className) {
            if (this.disposed || className === this._className) {
                return;
            }
            this._className = className;
            this._element.className = className;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FastLabelNode.prototype, "title", {
        set: function (title) {
            if (this.disposed || title === this._title) {
                return;
            }
            this._title = title;
            if (this._title) {
                this._element.title = title;
            }
            else {
                this._element.removeAttribute('title');
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FastLabelNode.prototype, "empty", {
        set: function (empty$$1) {
            if (this.disposed || empty$$1 === this._empty) {
                return;
            }
            this._empty = empty$$1;
            this._element.style.marginLeft = empty$$1 ? '0' : null;
        },
        enumerable: true,
        configurable: true
    });
    FastLabelNode.prototype.dispose = function () {
        this.disposed = true;
    };
    return FastLabelNode;
}());
var IconLabel = /** @class */ (function () {
    function IconLabel(container, options) {
        var _this = this;
        this.domNode = new FastLabelNode(append(container, $('.monaco-icon-label')));
        this.labelDescriptionContainer = new FastLabelNode(append(this.domNode.element, $('.monaco-icon-label-description-container')));
        if (options && options.supportHighlights) {
            this.labelNode = new HighlightedLabel(append(this.labelDescriptionContainer.element, $('a.label-name')));
        }
        else {
            this.labelNode = new FastLabelNode(append(this.labelDescriptionContainer.element, $('a.label-name')));
        }
        if (options && options.supportDescriptionHighlights) {
            this.descriptionNodeFactory = function () { return new HighlightedLabel(append(_this.labelDescriptionContainer.element, $('span.label-description'))); };
        }
        else {
            this.descriptionNodeFactory = function () { return new FastLabelNode(append(_this.labelDescriptionContainer.element, $('span.label-description'))); };
        }
    }
    Object.defineProperty(IconLabel.prototype, "element", {
        get: function () {
            return this.domNode.element;
        },
        enumerable: true,
        configurable: true
    });
    IconLabel.prototype.onClick = function (callback) {
        return combinedDisposable([
            addDisposableListener(this.labelDescriptionContainer.element, EventType.CLICK, function (e) { return callback(e); }),
        ]);
    };
    IconLabel.prototype.setValue = function (label, description, options) {
        var classes = ['monaco-icon-label'];
        if (options) {
            if (options.extraClasses) {
                classes.push.apply(classes, options.extraClasses);
            }
            if (options.italic) {
                classes.push('italic');
            }
        }
        this.domNode.className = classes.join(' ');
        this.domNode.title = options && options.title ? options.title : '';
        if (this.labelNode instanceof HighlightedLabel) {
            this.labelNode.set(label || '', options ? options.matches : void 0);
        }
        else {
            this.labelNode.textContent = label || '';
        }
        if (description || this.descriptionNode) {
            if (!this.descriptionNode) {
                this.descriptionNode = this.descriptionNodeFactory(); // description node is created lazily on demand
            }
            if (this.descriptionNode instanceof HighlightedLabel) {
                this.descriptionNode.set(description || '', options ? options.descriptionMatches : void 0);
                if (options && options.descriptionTitle) {
                    this.descriptionNode.element.title = options.descriptionTitle;
                }
                else {
                    this.descriptionNode.element.removeAttribute('title');
                }
            }
            else {
                this.descriptionNode.textContent = description || '';
                this.descriptionNode.title = options && options.descriptionTitle ? options.descriptionTitle : '';
                this.descriptionNode.empty = !description;
            }
        }
    };
    IconLabel.prototype.dispose = function () {
        this.domNode.dispose();
        this.labelNode.dispose();
        if (this.descriptionNode) {
            this.descriptionNode.dispose();
        }
    };
    return IconLabel;
}());
var FileLabel = /** @class */ (function (_super) {
    __extends$h(FileLabel, _super);
    function FileLabel(container, file, provider, userHome) {
        var _this = _super.call(this, container) || this;
        _this.setFile(file, provider, userHome);
        return _this;
    }
    FileLabel.prototype.setFile = function (file, provider, userHome) {
        var parent = dirname(file.fsPath);
        this.setValue(getBaseLabel(file), parent && parent !== '.' ? getPathLabel(parent, provider, userHome) : '', { title: file.fsPath });
    };
    return FileLabel;
}(IconLabel));

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$i = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate$5 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$5 = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var EmbeddedCodeEditorWidget = /** @class */ (function (_super) {
    __extends$i(EmbeddedCodeEditorWidget, _super);
    function EmbeddedCodeEditorWidget(domElement, options, parentEditor, instantiationService, codeEditorService, commandService, contextKeyService, themeService, notificationService) {
        var _this = _super.call(this, domElement, parentEditor.getRawConfiguration(), instantiationService, codeEditorService, commandService, contextKeyService, themeService, notificationService) || this;
        _this._parentEditor = parentEditor;
        _this._overwriteOptions = options;
        // Overwrite parent's options
        _super.prototype.updateOptions.call(_this, _this._overwriteOptions);
        _this._register(parentEditor.onDidChangeConfiguration(function (e) { return _this._onParentConfigurationChanged(e); }));
        return _this;
    }
    EmbeddedCodeEditorWidget.prototype.getParentEditor = function () {
        return this._parentEditor;
    };
    EmbeddedCodeEditorWidget.prototype._onParentConfigurationChanged = function (e) {
        _super.prototype.updateOptions.call(this, this._parentEditor.getRawConfiguration());
        _super.prototype.updateOptions.call(this, this._overwriteOptions);
    };
    EmbeddedCodeEditorWidget.prototype.updateOptions = function (newOptions) {
        mixin(this._overwriteOptions, newOptions, true);
        _super.prototype.updateOptions.call(this, this._overwriteOptions);
    };
    EmbeddedCodeEditorWidget = __decorate$5([
        __param$5(3, IInstantiationService),
        __param$5(4, ICodeEditorService),
        __param$5(5, ICommandService),
        __param$5(6, IContextKeyService),
        __param$5(7, IThemeService),
        __param$5(8, INotificationService)
    ], EmbeddedCodeEditorWidget);
    return EmbeddedCodeEditorWidget;
}(CodeEditor));
var EmbeddedDiffEditorWidget = /** @class */ (function (_super) {
    __extends$i(EmbeddedDiffEditorWidget, _super);
    function EmbeddedDiffEditorWidget(domElement, options, parentEditor, editorWorkerService, contextKeyService, instantiationService, codeEditorService, themeService, notificationService) {
        var _this = _super.call(this, domElement, parentEditor.getRawConfiguration(), editorWorkerService, contextKeyService, instantiationService, codeEditorService, themeService, notificationService) || this;
        _this._parentEditor = parentEditor;
        _this._overwriteOptions = options;
        // Overwrite parent's options
        _super.prototype.updateOptions.call(_this, _this._overwriteOptions);
        _this._register(parentEditor.onDidChangeConfiguration(function (e) { return _this._onParentConfigurationChanged(e); }));
        return _this;
    }
    EmbeddedDiffEditorWidget.prototype.getParentEditor = function () {
        return this._parentEditor;
    };
    EmbeddedDiffEditorWidget.prototype._onParentConfigurationChanged = function (e) {
        _super.prototype.updateOptions.call(this, this._parentEditor.getRawConfiguration());
        _super.prototype.updateOptions.call(this, this._overwriteOptions);
    };
    EmbeddedDiffEditorWidget.prototype.updateOptions = function (newOptions) {
        mixin(this._overwriteOptions, newOptions, true);
        _super.prototype.updateOptions.call(this, this._overwriteOptions);
    };
    EmbeddedDiffEditorWidget = __decorate$5([
        __param$5(3, IEditorWorkerService),
        __param$5(4, IContextKeyService),
        __param$5(5, IInstantiationService),
        __param$5(6, ICodeEditorService),
        __param$5(7, IThemeService),
        __param$5(8, INotificationService)
    ], EmbeddedDiffEditorWidget);
    return EmbeddedDiffEditorWidget;
}(DiffEditorWidget));

const css$d = "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n.monaco-editor .peekview-widget .head {\n\t-webkit-box-sizing:\tborder-box;\n\t-o-box-sizing: border-box;\n\t-moz-box-sizing: border-box;\n\t-ms-box-sizing: border-box;\n\tbox-sizing:\tborder-box;\n\tdisplay: flex;\n}\n\n.monaco-editor .peekview-widget .head .peekview-title {\n\tdisplay: inline-block;\n\tfont-size: 13px;\n\tmargin-left: 20px;\n\tcursor: pointer;\n}\n\n.monaco-editor .peekview-widget .head .peekview-title .dirname:not(:empty) {\n\tfont-size: 0.9em;\n\tmargin-left: 0.5em;\n}\n\n.monaco-editor .peekview-widget .head .peekview-actions {\n\tflex: 1;\n\ttext-align: right;\n\tpadding-right: 2px;\n}\n\n.monaco-editor .peekview-widget .head .peekview-actions > .monaco-action-bar {\n\tdisplay: inline-block;\n}\n\n.monaco-editor .peekview-widget .head .peekview-actions > .monaco-action-bar,\n.monaco-editor .peekview-widget .head .peekview-actions > .monaco-action-bar > .actions-container {\n\theight: 100%;\n}\n\n.monaco-editor .peekview-widget .head .peekview-actions > .monaco-action-bar .action-item {\n\tmargin-left: 4px;\n}\n\n.monaco-editor .peekview-widget .head .peekview-actions > .monaco-action-bar .action-label {\n\twidth: 16px;\n\theight: 100%;\n\tmargin: 0;\n\tline-height: inherit;\n\tbackground-repeat: no-repeat;\n\tbackground-position: center center;\n}\n\n.monaco-editor .peekview-widget .head .peekview-actions > .monaco-action-bar .action-label.octicon {\n\tmargin: 0;\n}\n\n.monaco-editor .peekview-widget .head .peekview-actions .action-label.icon.close-peekview-action {\n\tbackground: url(\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgaGVpZ2h0PSIxNiIgdmlld0JveD0iMyAzIDE2IDE2IiBlbmFibGUtYmFja2dyb3VuZD0ibmV3IDMgMyAxNiAxNiI+PHBvbHlnb24gZmlsbD0iIzQyNDI0MiIgcG9pbnRzPSIxMi41OTcsMTEuMDQyIDE1LjQsMTMuODQ1IDEzLjg0NCwxNS40IDExLjA0MiwxMi41OTggOC4yMzksMTUuNCA2LjY4MywxMy44NDUgOS40ODUsMTEuMDQyIDYuNjgzLDguMjM5IDguMjM4LDYuNjgzIDExLjA0Miw5LjQ4NiAxMy44NDUsNi42ODMgMTUuNCw4LjIzOSIvPjwvc3ZnPg==\") center center no-repeat;\n}\n\n.monaco-editor .peekview-widget > .body {\n\tborder-top: 1px solid;\n\tposition: relative;\n}\n\n/* Dark Theme */\n/* High Contrast Theme */\n\n.monaco-editor.hc-black .peekview-widget .head .peekview-actions .action-label.icon.close-peekview-action,\n.monaco-editor.vs-dark .peekview-widget .head .peekview-actions .action-label.icon.close-peekview-action {\n\tbackground: url(\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgaGVpZ2h0PSIxNiIgdmlld0JveD0iMyAzIDE2IDE2IiBlbmFibGUtYmFja2dyb3VuZD0ibmV3IDMgMyAxNiAxNiI+PHBvbHlnb24gZmlsbD0iI2U4ZThlOCIgcG9pbnRzPSIxMi41OTcsMTEuMDQyIDE1LjQsMTMuODQ1IDEzLjg0NCwxNS40IDExLjA0MiwxMi41OTggOC4yMzksMTUuNCA2LjY4MywxMy44NDUgOS40ODUsMTEuMDQyIDYuNjgzLDguMjM5IDguMjM4LDYuNjgzIDExLjA0Miw5LjQ4NiAxMy44NDUsNi42ODMgMTUuNCw4LjIzOSIvPjwvc3ZnPg==\") center center no-repeat;\n}\n\n";
  const element$d = ((css, src) => {
if (typeof document !== 'object')
console.info(`Skipped loading "${src}"`);
try {
const id = src
  .replace(/\.css.*$/, '')
  .replace(/[\\:]/g, '/')
  .replace(/[^\w\/]+/g, '');
return (
  document.querySelector(`style[id="${id}"]`) ||
  document.head.appendChild(
    Object.assign(document.createElement('style'), {
      id,
      textContent: `${css}\n\n /* sourceURL=${src} */`,
    }),
  )
);
} catch (exception) {
console.warn(`Failed load "${src}"`, exception);
}
})(css$d, "…monaco-editor/esm/vs/editor/contrib/referenceSearch/media/peekViewWidget.css");
  //@ sourceURL=/Users/daflair/Projects/packages/monaco-es/node_modules/monaco-editor/esm/vs/editor/contrib/referenceSearch/media/peekViewWidget.css

const css$e = "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n.monaco-editor .zone-widget {\n\tposition: absolute;\n\tz-index: 10;\n}\n\n\n.monaco-editor .zone-widget .zone-widget-container {\n\tborder-top-style: solid;\n\tborder-bottom-style: solid;\n\tborder-top-width: 0;\n\tborder-bottom-width: 0;\n\tposition: relative;\n}\n";
  const element$e = ((css, src) => {
if (typeof document !== 'object')
console.info(`Skipped loading "${src}"`);
try {
const id = src
  .replace(/\.css.*$/, '')
  .replace(/[\\:]/g, '/')
  .replace(/[^\w\/]+/g, '');
return (
  document.querySelector(`style[id="${id}"]`) ||
  document.head.appendChild(
    Object.assign(document.createElement('style'), {
      id,
      textContent: `${css}\n\n /* sourceURL=${src} */`,
    }),
  )
);
} catch (exception) {
console.warn(`Failed load "${src}"`, exception);
}
})(css$e, "…monaco-editor/esm/vs/editor/contrib/zoneWidget/zoneWidget.css");
  //@ sourceURL=/Users/daflair/Projects/packages/monaco-es/node_modules/monaco-editor/esm/vs/editor/contrib/zoneWidget/zoneWidget.css

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var defaultColor = new Color(new RGBA(0, 122, 204));
var defaultOptions = {
    showArrow: true,
    showFrame: true,
    className: '',
    frameColor: defaultColor,
    arrowColor: defaultColor,
    keepEditorSelection: false
};
var WIDGET_ID = 'vs.editor.contrib.zoneWidget';
var ViewZoneDelegate = /** @class */ (function () {
    function ViewZoneDelegate(domNode, afterLineNumber, afterColumn, heightInLines, onDomNodeTop, onComputedHeight) {
        this.domNode = domNode;
        this.afterLineNumber = afterLineNumber;
        this.afterColumn = afterColumn;
        this.heightInLines = heightInLines;
        this._onDomNodeTop = onDomNodeTop;
        this._onComputedHeight = onComputedHeight;
    }
    ViewZoneDelegate.prototype.onDomNodeTop = function (top) {
        this._onDomNodeTop(top);
    };
    ViewZoneDelegate.prototype.onComputedHeight = function (height) {
        this._onComputedHeight(height);
    };
    return ViewZoneDelegate;
}());
var OverlayWidgetDelegate = /** @class */ (function () {
    function OverlayWidgetDelegate(id, domNode) {
        this._id = id;
        this._domNode = domNode;
    }
    OverlayWidgetDelegate.prototype.getId = function () {
        return this._id;
    };
    OverlayWidgetDelegate.prototype.getDomNode = function () {
        return this._domNode;
    };
    OverlayWidgetDelegate.prototype.getPosition = function () {
        return null;
    };
    return OverlayWidgetDelegate;
}());
var Arrow = /** @class */ (function () {
    function Arrow(_editor) {
        this._editor = _editor;
        this._ruleName = Arrow._IdGenerator.nextId();
        this._decorations = [];
        //
    }
    Arrow.prototype.dispose = function () {
        this.hide();
        removeCSSRulesContainingSelector(this._ruleName);
    };
    Object.defineProperty(Arrow.prototype, "color", {
        set: function (value) {
            if (this._color !== value) {
                this._color = value;
                this._updateStyle();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Arrow.prototype, "height", {
        set: function (value) {
            if (this._height !== value) {
                this._height = value;
                this._updateStyle();
            }
        },
        enumerable: true,
        configurable: true
    });
    Arrow.prototype._updateStyle = function () {
        removeCSSRulesContainingSelector(this._ruleName);
        createCSSRule(".monaco-editor " + this._ruleName, "border-style: solid; border-color: transparent; border-bottom-color: " + this._color + "; border-width: " + this._height + "px; bottom: -" + this._height + "px; margin-left: -" + this._height + "px; ");
    };
    Arrow.prototype.show = function (where) {
        this._decorations = this._editor.deltaDecorations(this._decorations, [{ range: Range.fromPositions(where), options: { className: this._ruleName, stickiness: TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges } }]);
    };
    Arrow.prototype.hide = function () {
        this._editor.deltaDecorations(this._decorations, []);
    };
    Arrow._IdGenerator = new IdGenerator('.arrow-decoration-');
    return Arrow;
}());
var ZoneWidget = /** @class */ (function () {
    function ZoneWidget(editor, options) {
        if (options === void 0) { options = {}; }
        var _this = this;
        this._positionMarkerId = [];
        this._disposables = [];
        this._isShowing = false;
        this.editor = editor;
        this.options = deepClone(options);
        mixin(this.options, defaultOptions, false);
        this.domNode = document.createElement('div');
        if (!this.options.isAccessible) {
            this.domNode.setAttribute('aria-hidden', 'true');
            this.domNode.setAttribute('role', 'presentation');
        }
        this._disposables.push(this.editor.onDidLayoutChange(function (info) {
            var width = _this._getWidth(info);
            _this.domNode.style.width = width + 'px';
            _this.domNode.style.left = _this._getLeft(info) + 'px';
            _this._onWidth(width);
        }));
    }
    ZoneWidget.prototype.dispose = function () {
        var _this = this;
        dispose(this._disposables);
        if (this._overlayWidget) {
            this.editor.removeOverlayWidget(this._overlayWidget);
            this._overlayWidget = null;
        }
        if (this._viewZone) {
            this.editor.changeViewZones(function (accessor) {
                accessor.removeZone(_this._viewZone.id);
                _this._viewZone = null;
            });
        }
        this.editor.deltaDecorations(this._positionMarkerId, []);
        this._positionMarkerId = [];
    };
    ZoneWidget.prototype.create = function () {
        addClass(this.domNode, 'zone-widget');
        addClass(this.domNode, this.options.className);
        this.container = document.createElement('div');
        addClass(this.container, 'zone-widget-container');
        this.domNode.appendChild(this.container);
        if (this.options.showArrow) {
            this._arrow = new Arrow(this.editor);
            this._disposables.push(this._arrow);
        }
        this._fillContainer(this.container);
        this._initSash();
        this._applyStyles();
    };
    ZoneWidget.prototype.style = function (styles) {
        if (styles.frameColor) {
            this.options.frameColor = styles.frameColor;
        }
        if (styles.arrowColor) {
            this.options.arrowColor = styles.arrowColor;
        }
        this._applyStyles();
    };
    ZoneWidget.prototype._applyStyles = function () {
        if (this.container) {
            var frameColor = this.options.frameColor.toString();
            this.container.style.borderTopColor = frameColor;
            this.container.style.borderBottomColor = frameColor;
        }
        if (this._arrow) {
            var arrowColor = this.options.arrowColor.toString();
            this._arrow.color = arrowColor;
        }
    };
    ZoneWidget.prototype._getWidth = function (info) {
        return info.width - info.minimapWidth - info.verticalScrollbarWidth;
    };
    ZoneWidget.prototype._getLeft = function (info) {
        // If minimap is to the left, we move beyond it
        if (info.minimapWidth > 0 && info.minimapLeft === 0) {
            return info.minimapWidth;
        }
        return 0;
    };
    ZoneWidget.prototype._onViewZoneTop = function (top) {
        this.domNode.style.top = top + 'px';
    };
    ZoneWidget.prototype._onViewZoneHeight = function (height) {
        this.domNode.style.height = height + "px";
        var containerHeight = height - this._decoratingElementsHeight();
        this.container.style.height = containerHeight + "px";
        var layoutInfo = this.editor.getLayoutInfo();
        this._doLayout(containerHeight, this._getWidth(layoutInfo));
        this._resizeSash.layout();
    };
    Object.defineProperty(ZoneWidget.prototype, "position", {
        get: function () {
            var id = this._positionMarkerId[0];
            if (!id) {
                return undefined;
            }
            var range$$1 = this.editor.getModel().getDecorationRange(id);
            if (!range$$1) {
                return undefined;
            }
            return range$$1.getStartPosition();
        },
        enumerable: true,
        configurable: true
    });
    ZoneWidget.prototype.show = function (rangeOrPos, heightInLines) {
        var range$$1 = Range.isIRange(rangeOrPos)
            ? rangeOrPos
            : new Range(rangeOrPos.lineNumber, rangeOrPos.column, rangeOrPos.lineNumber, rangeOrPos.column);
        this._isShowing = true;
        this._showImpl(range$$1, heightInLines);
        this._isShowing = false;
        this._positionMarkerId = this.editor.deltaDecorations(this._positionMarkerId, [{ range: range$$1, options: ModelDecorationOptions.EMPTY }]);
    };
    ZoneWidget.prototype.hide = function () {
        var _this = this;
        if (this._viewZone) {
            this.editor.changeViewZones(function (accessor) {
                accessor.removeZone(_this._viewZone.id);
            });
            this._viewZone = null;
        }
        if (this._overlayWidget) {
            this.editor.removeOverlayWidget(this._overlayWidget);
            this._overlayWidget = null;
        }
        if (this._arrow) {
            this._arrow.hide();
        }
    };
    ZoneWidget.prototype._decoratingElementsHeight = function () {
        var lineHeight = this.editor.getConfiguration().lineHeight;
        var result = 0;
        if (this.options.showArrow) {
            var arrowHeight = Math.round(lineHeight / 3);
            result += 2 * arrowHeight;
        }
        if (this.options.showFrame) {
            var frameThickness = Math.round(lineHeight / 9);
            result += 2 * frameThickness;
        }
        return result;
    };
    ZoneWidget.prototype._showImpl = function (where, heightInLines) {
        var _this = this;
        var position = {
            lineNumber: where.startLineNumber,
            column: where.startColumn
        };
        var layoutInfo = this.editor.getLayoutInfo();
        var width = this._getWidth(layoutInfo);
        this.domNode.style.width = width + "px";
        this.domNode.style.left = this._getLeft(layoutInfo) + 'px';
        // Render the widget as zone (rendering) and widget (lifecycle)
        var viewZoneDomNode = document.createElement('div');
        viewZoneDomNode.style.overflow = 'hidden';
        var lineHeight = this.editor.getConfiguration().lineHeight;
        // adjust heightInLines to viewport
        var maxHeightInLines = (this.editor.getLayoutInfo().height / lineHeight) * .8;
        if (heightInLines >= maxHeightInLines) {
            heightInLines = maxHeightInLines;
        }
        var arrowHeight = 0;
        var frameThickness = 0;
        // Render the arrow one 1/3 of an editor line height
        if (this.options.showArrow) {
            arrowHeight = Math.round(lineHeight / 3);
            this._arrow.height = arrowHeight;
            this._arrow.show(position);
        }
        // Render the frame as 1/9 of an editor line height
        if (this.options.showFrame) {
            frameThickness = Math.round(lineHeight / 9);
        }
        // insert zone widget
        this.editor.changeViewZones(function (accessor) {
            if (_this._viewZone) {
                accessor.removeZone(_this._viewZone.id);
            }
            if (_this._overlayWidget) {
                _this.editor.removeOverlayWidget(_this._overlayWidget);
                _this._overlayWidget = null;
            }
            _this.domNode.style.top = '-1000px';
            _this._viewZone = new ViewZoneDelegate(viewZoneDomNode, position.lineNumber, position.column, heightInLines, function (top) { return _this._onViewZoneTop(top); }, function (height) { return _this._onViewZoneHeight(height); });
            _this._viewZone.id = accessor.addZone(_this._viewZone);
            _this._overlayWidget = new OverlayWidgetDelegate(WIDGET_ID + _this._viewZone.id, _this.domNode);
            _this.editor.addOverlayWidget(_this._overlayWidget);
        });
        if (this.options.showFrame) {
            var width_1 = this.options.frameWidth ? this.options.frameWidth : frameThickness;
            this.container.style.borderTopWidth = width_1 + 'px';
            this.container.style.borderBottomWidth = width_1 + 'px';
        }
        var containerHeight = heightInLines * lineHeight - this._decoratingElementsHeight();
        this.container.style.top = arrowHeight + 'px';
        this.container.style.height = containerHeight + 'px';
        this.container.style.overflow = 'hidden';
        this._doLayout(containerHeight, width);
        if (!this.options.keepEditorSelection) {
            this.editor.setSelection(where);
        }
        // Reveal the line above or below the zone widget, to get the zone widget in the viewport
        var revealLineNumber = Math.min(this.editor.getModel().getLineCount(), Math.max(1, where.endLineNumber + 1));
        this.revealLine(revealLineNumber);
    };
    ZoneWidget.prototype.revealLine = function (lineNumber) {
        this.editor.revealLine(lineNumber, 0 /* Smooth */);
    };
    ZoneWidget.prototype.setCssClass = function (className, classToReplace) {
        if (classToReplace) {
            this.container.classList.remove(classToReplace);
        }
        addClass(this.container, className);
    };
    ZoneWidget.prototype._onWidth = function (widthInPixel) {
        // implement in subclass
    };
    ZoneWidget.prototype._doLayout = function (heightInPixel, widthInPixel) {
        // implement in subclass
    };
    ZoneWidget.prototype._relayout = function (newHeightInLines) {
        var _this = this;
        if (this._viewZone.heightInLines !== newHeightInLines) {
            this.editor.changeViewZones(function (accessor) {
                _this._viewZone.heightInLines = newHeightInLines;
                accessor.layoutZone(_this._viewZone.id);
            });
        }
    };
    // --- sash
    ZoneWidget.prototype._initSash = function () {
        var _this = this;
        this._resizeSash = new Sash(this.domNode, this, { orientation: Orientation.HORIZONTAL });
        if (!this.options.isResizeable) {
            this._resizeSash.hide();
            this._resizeSash.disable();
        }
        var data;
        this._disposables.push(this._resizeSash.onDidStart(function (e) {
            if (_this._viewZone) {
                data = {
                    startY: e.startY,
                    heightInLines: _this._viewZone.heightInLines,
                };
            }
        }));
        this._disposables.push(this._resizeSash.onDidEnd(function () {
            data = undefined;
        }));
        this._disposables.push(this._resizeSash.onDidChange(function (evt) {
            if (data) {
                var lineDelta = (evt.currentY - data.startY) / _this.editor.getConfiguration().lineHeight;
                var roundedLineDelta = lineDelta < 0 ? Math.ceil(lineDelta) : Math.floor(lineDelta);
                var newHeightInLines = data.heightInLines + roundedLineDelta;
                if (newHeightInLines > 5 && newHeightInLines < 35) {
                    _this._relayout(newHeightInLines);
                }
            }
        }));
    };
    ZoneWidget.prototype.getHorizontalSashLeft = function () {
        return 0;
    };
    ZoneWidget.prototype.getHorizontalSashTop = function () {
        return parseInt(this.domNode.style.height) - (this._decoratingElementsHeight() / 2);
    };
    ZoneWidget.prototype.getHorizontalSashWidth = function () {
        var layoutInfo = this.editor.getLayoutInfo();
        return layoutInfo.width - layoutInfo.minimapWidth;
    };
    return ZoneWidget;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$j = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var PeekContext;
(function (PeekContext) {
    PeekContext.inPeekEditor = new RawContextKey('inReferenceSearchEditor', true);
    PeekContext.notInPeekEditor = PeekContext.inPeekEditor.toNegated();
})(PeekContext || (PeekContext = {}));
function getOuterEditor(accessor) {
    var editor = accessor.get(ICodeEditorService).getFocusedCodeEditor();
    if (editor instanceof EmbeddedCodeEditorWidget) {
        return editor.getParentEditor();
    }
    return editor;
}
var defaultOptions$1 = {
    headerBackgroundColor: Color.white,
    primaryHeadingColor: Color.fromHex('#333333'),
    secondaryHeadingColor: Color.fromHex('#6c6c6cb3')
};
var PeekViewWidget = /** @class */ (function (_super) {
    __extends$j(PeekViewWidget, _super);
    function PeekViewWidget(editor, options) {
        if (options === void 0) { options = {}; }
        var _this = _super.call(this, editor, options) || this;
        _this._onDidClose = new Emitter();
        mixin(_this.options, defaultOptions$1, false);
        return _this;
    }
    PeekViewWidget.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
        this._onDidClose.fire(this);
    };
    Object.defineProperty(PeekViewWidget.prototype, "onDidClose", {
        get: function () {
            return this._onDidClose.event;
        },
        enumerable: true,
        configurable: true
    });
    PeekViewWidget.prototype.style = function (styles) {
        var options = this.options;
        if (styles.headerBackgroundColor) {
            options.headerBackgroundColor = styles.headerBackgroundColor;
        }
        if (styles.primaryHeadingColor) {
            options.primaryHeadingColor = styles.primaryHeadingColor;
        }
        if (styles.secondaryHeadingColor) {
            options.secondaryHeadingColor = styles.secondaryHeadingColor;
        }
        _super.prototype.style.call(this, styles);
    };
    PeekViewWidget.prototype._applyStyles = function () {
        _super.prototype._applyStyles.call(this);
        var options = this.options;
        if (this._headElement) {
            this._headElement.style.backgroundColor = options.headerBackgroundColor.toString();
        }
        if (this._primaryHeading) {
            this._primaryHeading.style.color = options.primaryHeadingColor.toString();
        }
        if (this._secondaryHeading) {
            this._secondaryHeading.style.color = options.secondaryHeadingColor.toString();
        }
        if (this._bodyElement) {
            this._bodyElement.style.borderColor = options.frameColor.toString();
        }
    };
    PeekViewWidget.prototype._fillContainer = function (container) {
        this.setCssClass('peekview-widget');
        this._headElement = $$1('.head').getHTMLElement();
        this._bodyElement = $$1('.body').getHTMLElement();
        this._fillHead(this._headElement);
        this._fillBody(this._bodyElement);
        container.appendChild(this._headElement);
        container.appendChild(this._bodyElement);
    };
    PeekViewWidget.prototype._fillHead = function (container) {
        var _this = this;
        var titleElement = $$1('.peekview-title').
            on(EventType.CLICK, function (e) { return _this._onTitleClick(e); }).
            appendTo(this._headElement).
            getHTMLElement();
        this._primaryHeading = $$1('span.filename').appendTo(titleElement).getHTMLElement();
        this._secondaryHeading = $$1('span.dirname').appendTo(titleElement).getHTMLElement();
        this._metaHeading = $$1('span.meta').appendTo(titleElement).getHTMLElement();
        var actionsContainer = $$1('.peekview-actions').appendTo(this._headElement);
        var actionBarOptions = this._getActionBarOptions();
        this._actionbarWidget = new ActionBar(actionsContainer.getHTMLElement(), actionBarOptions);
        this._disposables.push(this._actionbarWidget);
        this._actionbarWidget.push(new Action('peekview.close', localize('label.close', "Close"), 'close-peekview-action', true, function () {
            _this.dispose();
            return null;
        }), { label: false, icon: true });
    };
    PeekViewWidget.prototype._getActionBarOptions = function () {
        return {};
    };
    PeekViewWidget.prototype._onTitleClick = function (event) {
        // implement me
    };
    PeekViewWidget.prototype.setTitle = function (primaryHeading, secondaryHeading) {
        $$1(this._primaryHeading).safeInnerHtml(primaryHeading);
        this._primaryHeading.setAttribute('aria-label', primaryHeading);
        if (secondaryHeading) {
            $$1(this._secondaryHeading).safeInnerHtml(secondaryHeading);
        }
        else {
            clearNode(this._secondaryHeading);
        }
    };
    PeekViewWidget.prototype.setMetaTitle = function (value) {
        if (value) {
            $$1(this._metaHeading).safeInnerHtml(value);
        }
        else {
            clearNode(this._metaHeading);
        }
    };
    PeekViewWidget.prototype._doLayout = function (heightInPixel, widthInPixel) {
        if (!this._isShowing && heightInPixel < 0) {
            // Looks like the view zone got folded away!
            this.dispose();
            return;
        }
        var headHeight = Math.ceil(this.editor.getConfiguration().lineHeight * 1.2), bodyHeight = heightInPixel - (headHeight + 2 /* the border-top/bottom width*/);
        this._doLayoutHead(headHeight, widthInPixel);
        this._doLayoutBody(bodyHeight, widthInPixel);
    };
    PeekViewWidget.prototype._doLayoutHead = function (heightInPixel, widthInPixel) {
        this._headElement.style.height = format('{0}px', heightInPixel);
        this._headElement.style.lineHeight = this._headElement.style.height;
    };
    PeekViewWidget.prototype._doLayoutBody = function (heightInPixel, widthInPixel) {
        this._bodyElement.style.height = format('{0}px', heightInPixel);
    };
    return PeekViewWidget;
}(ZoneWidget));

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var OneReference = /** @class */ (function () {
    function OneReference(_parent, _range) {
        this._parent = _parent;
        this._range = _range;
        this._onRefChanged = new Emitter();
        this.onRefChanged = this._onRefChanged.event;
        this._id = defaultGenerator.nextId();
    }
    Object.defineProperty(OneReference.prototype, "id", {
        get: function () {
            return this._id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OneReference.prototype, "model", {
        get: function () {
            return this._parent;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OneReference.prototype, "parent", {
        get: function () {
            return this._parent;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OneReference.prototype, "uri", {
        get: function () {
            return this._parent.uri;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OneReference.prototype, "name", {
        get: function () {
            return this._parent.name;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OneReference.prototype, "directory", {
        get: function () {
            return this._parent.directory;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OneReference.prototype, "range", {
        get: function () {
            return this._range;
        },
        set: function (value) {
            this._range = value;
            this._onRefChanged.fire(this);
        },
        enumerable: true,
        configurable: true
    });
    OneReference.prototype.getAriaMessage = function () {
        return localize('aria.oneReference', "symbol in {0} on line {1} at column {2}", basename(this.uri.fsPath), this.range.startLineNumber, this.range.startColumn);
    };
    return OneReference;
}());
var FilePreview = /** @class */ (function () {
    function FilePreview(_modelReference) {
        this._modelReference = _modelReference;
    }
    Object.defineProperty(FilePreview.prototype, "_model", {
        get: function () { return this._modelReference.object.textEditorModel; },
        enumerable: true,
        configurable: true
    });
    FilePreview.prototype.preview = function (range$$1, n) {
        if (n === void 0) { n = 8; }
        var model = this._model;
        if (!model) {
            return undefined;
        }
        var startLineNumber = range$$1.startLineNumber, startColumn = range$$1.startColumn, endLineNumber = range$$1.endLineNumber, endColumn = range$$1.endColumn;
        var word = model.getWordUntilPosition({ lineNumber: startLineNumber, column: startColumn - n });
        var beforeRange = new Range(startLineNumber, word.startColumn, startLineNumber, startColumn);
        var afterRange = new Range(endLineNumber, endColumn, endLineNumber, Number.MAX_VALUE);
        var ret = {
            before: model.getValueInRange(beforeRange).replace(/^\s+/, empty),
            inside: model.getValueInRange(range$$1),
            after: model.getValueInRange(afterRange).replace(/\s+$/, empty)
        };
        return ret;
    };
    FilePreview.prototype.dispose = function () {
        if (this._modelReference) {
            this._modelReference.dispose();
            this._modelReference = null;
        }
    };
    return FilePreview;
}());
var FileReferences = /** @class */ (function () {
    function FileReferences(_parent, _uri) {
        this._parent = _parent;
        this._uri = _uri;
        this._children = [];
    }
    Object.defineProperty(FileReferences.prototype, "id", {
        get: function () {
            return this._uri.toString();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FileReferences.prototype, "parent", {
        get: function () {
            return this._parent;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FileReferences.prototype, "children", {
        get: function () {
            return this._children;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FileReferences.prototype, "uri", {
        get: function () {
            return this._uri;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FileReferences.prototype, "name", {
        get: function () {
            return basename(this.uri.fsPath);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FileReferences.prototype, "directory", {
        get: function () {
            return dirname(this.uri.fsPath);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FileReferences.prototype, "preview", {
        get: function () {
            return this._preview;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FileReferences.prototype, "failure", {
        get: function () {
            return this._loadFailure;
        },
        enumerable: true,
        configurable: true
    });
    FileReferences.prototype.getAriaMessage = function () {
        var len = this.children.length;
        if (len === 1) {
            return localize('aria.fileReferences.1', "1 symbol in {0}, full path {1}", basename(this.uri.fsPath), this.uri.fsPath);
        }
        else {
            return localize('aria.fileReferences.N', "{0} symbols in {1}, full path {2}", len, basename(this.uri.fsPath), this.uri.fsPath);
        }
    };
    FileReferences.prototype.resolve = function (textModelResolverService) {
        var _this = this;
        if (this._resolved) {
            return TPromise.as(this);
        }
        return textModelResolverService.createModelReference(this._uri).then(function (modelReference) {
            var model = modelReference.object;
            if (!model) {
                modelReference.dispose();
                throw new Error();
            }
            _this._preview = new FilePreview(modelReference);
            _this._resolved = true;
            return _this;
        }, function (err) {
            // something wrong here
            _this._children = [];
            _this._resolved = true;
            _this._loadFailure = err;
            return _this;
        });
    };
    FileReferences.prototype.dispose = function () {
        if (this._preview) {
            this._preview.dispose();
            this._preview = null;
        }
    };
    return FileReferences;
}());
var ReferencesModel = /** @class */ (function () {
    function ReferencesModel(references) {
        var _this = this;
        this._groups = [];
        this._references = [];
        this._onDidChangeReferenceRange = new Emitter();
        this.onDidChangeReferenceRange = this._onDidChangeReferenceRange.event;
        this._disposables = [];
        // grouping and sorting
        references.sort(ReferencesModel._compareReferences);
        var current;
        for (var _i = 0, references_1 = references; _i < references_1.length; _i++) {
            var ref = references_1[_i];
            if (!current || current.uri.toString() !== ref.uri.toString()) {
                // new group
                current = new FileReferences(this, ref.uri);
                this.groups.push(current);
            }
            // append, check for equality first!
            if (current.children.length === 0
                || !Range.equalsRange(ref.range, current.children[current.children.length - 1].range)) {
                var oneRef = new OneReference(current, ref.range);
                this._disposables.push(oneRef.onRefChanged(function (e) { return _this._onDidChangeReferenceRange.fire(e); }));
                this._references.push(oneRef);
                current.children.push(oneRef);
            }
        }
    }
    Object.defineProperty(ReferencesModel.prototype, "empty", {
        get: function () {
            return this._groups.length === 0;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ReferencesModel.prototype, "references", {
        get: function () {
            return this._references;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ReferencesModel.prototype, "groups", {
        get: function () {
            return this._groups;
        },
        enumerable: true,
        configurable: true
    });
    ReferencesModel.prototype.getAriaMessage = function () {
        if (this.empty) {
            return localize('aria.result.0', "No results found");
        }
        else if (this.references.length === 1) {
            return localize('aria.result.1', "Found 1 symbol in {0}", this.references[0].uri.fsPath);
        }
        else if (this.groups.length === 1) {
            return localize('aria.result.n1', "Found {0} symbols in {1}", this.references.length, this.groups[0].uri.fsPath);
        }
        else {
            return localize('aria.result.nm', "Found {0} symbols in {1} files", this.references.length, this.groups.length);
        }
    };
    ReferencesModel.prototype.nextOrPreviousReference = function (reference, next) {
        var parent = reference.parent;
        var idx = parent.children.indexOf(reference);
        var childCount = parent.children.length;
        var groupCount = parent.parent.groups.length;
        if (groupCount === 1 || next && idx + 1 < childCount || !next && idx > 0) {
            // cycling within one file
            if (next) {
                idx = (idx + 1) % childCount;
            }
            else {
                idx = (idx + childCount - 1) % childCount;
            }
            return parent.children[idx];
        }
        idx = parent.parent.groups.indexOf(parent);
        if (next) {
            idx = (idx + 1) % groupCount;
            return parent.parent.groups[idx].children[0];
        }
        else {
            idx = (idx + groupCount - 1) % groupCount;
            return parent.parent.groups[idx].children[parent.parent.groups[idx].children.length - 1];
        }
    };
    ReferencesModel.prototype.nearestReference = function (resource, position) {
        var nearest = this._references.map(function (ref, idx) {
            return {
                idx: idx,
                prefixLen: commonPrefixLength(ref.uri.toString(), resource.toString()),
                offsetDist: Math.abs(ref.range.startLineNumber - position.lineNumber) * 100 + Math.abs(ref.range.startColumn - position.column)
            };
        }).sort(function (a, b) {
            if (a.prefixLen > b.prefixLen) {
                return -1;
            }
            else if (a.prefixLen < b.prefixLen) {
                return 1;
            }
            else if (a.offsetDist < b.offsetDist) {
                return -1;
            }
            else if (a.offsetDist > b.offsetDist) {
                return 1;
            }
            else {
                return 0;
            }
        })[0];
        if (nearest) {
            return this._references[nearest.idx];
        }
        return undefined;
    };
    ReferencesModel.prototype.dispose = function () {
        this._groups = dispose(this._groups);
        dispose(this._disposables);
        this._disposables.length = 0;
    };
    ReferencesModel._compareReferences = function (a, b) {
        var auri = a.uri.toString();
        var buri = b.uri.toString();
        if (auri < buri) {
            return -1;
        }
        else if (auri > buri) {
            return 1;
        }
        else {
            return Range.compareRangesUsingStarts(a.range, b.range);
        }
    };
    return ReferencesModel;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var IEnvironmentService = createDecorator('environmentService');

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$k = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate$6 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$6 = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var DecorationsManager = /** @class */ (function () {
    function DecorationsManager(_editor, _model) {
        var _this = this;
        this._editor = _editor;
        this._model = _model;
        this._decorations = new Map();
        this._decorationIgnoreSet = new Set();
        this._callOnDispose = [];
        this._callOnModelChange = [];
        this._callOnDispose.push(this._editor.onDidChangeModel(function () { return _this._onModelChanged(); }));
        this._onModelChanged();
    }
    DecorationsManager.prototype.dispose = function () {
        this._callOnModelChange = dispose(this._callOnModelChange);
        this._callOnDispose = dispose(this._callOnDispose);
        this.removeDecorations();
    };
    DecorationsManager.prototype._onModelChanged = function () {
        this._callOnModelChange = dispose(this._callOnModelChange);
        var model = this._editor.getModel();
        if (model) {
            for (var _i = 0, _a = this._model.groups; _i < _a.length; _i++) {
                var ref = _a[_i];
                if (ref.uri.toString() === model.uri.toString()) {
                    this._addDecorations(ref);
                    return;
                }
            }
        }
    };
    DecorationsManager.prototype._addDecorations = function (reference) {
        var _this = this;
        this._callOnModelChange.push(this._editor.getModel().onDidChangeDecorations(function (event) { return _this._onDecorationChanged(); }));
        var newDecorations = [];
        var newDecorationsActualIndex = [];
        for (var i = 0, len = reference.children.length; i < len; i++) {
            var oneReference = reference.children[i];
            if (this._decorationIgnoreSet.has(oneReference.id)) {
                continue;
            }
            newDecorations.push({
                range: oneReference.range,
                options: DecorationsManager.DecorationOptions
            });
            newDecorationsActualIndex.push(i);
        }
        var decorations = this._editor.deltaDecorations([], newDecorations);
        for (var i = 0; i < decorations.length; i++) {
            this._decorations.set(decorations[i], reference.children[newDecorationsActualIndex[i]]);
        }
    };
    DecorationsManager.prototype._onDecorationChanged = function () {
        var _this = this;
        var toRemove = [];
        this._decorations.forEach(function (reference, decorationId) {
            var newRange = _this._editor.getModel().getDecorationRange(decorationId);
            if (!newRange) {
                return;
            }
            var ignore = false;
            if (Range.equalsRange(newRange, reference.range)) {
                return;
            }
            else if (Range.spansMultipleLines(newRange)) {
                ignore = true;
            }
            else {
                var lineLength = reference.range.endColumn - reference.range.startColumn;
                var newLineLength = newRange.endColumn - newRange.startColumn;
                if (lineLength !== newLineLength) {
                    ignore = true;
                }
            }
            if (ignore) {
                _this._decorationIgnoreSet.add(reference.id);
                toRemove.push(decorationId);
            }
            else {
                reference.range = newRange;
            }
        });
        for (var i = 0, len = toRemove.length; i < len; i++) {
            this._decorations.delete(toRemove[i]);
        }
        this._editor.deltaDecorations(toRemove, []);
    };
    DecorationsManager.prototype.removeDecorations = function () {
        var toRemove = [];
        this._decorations.forEach(function (value, key) {
            toRemove.push(key);
        });
        this._editor.deltaDecorations(toRemove, []);
        this._decorations.clear();
    };
    DecorationsManager.DecorationOptions = ModelDecorationOptions.register({
        stickiness: TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges,
        className: 'reference-decoration'
    });
    return DecorationsManager;
}());
var DataSource = /** @class */ (function () {
    function DataSource(_textModelResolverService) {
        this._textModelResolverService = _textModelResolverService;
        //
    }
    DataSource.prototype.getId = function (tree, element) {
        if (element instanceof ReferencesModel) {
            return 'root';
        }
        else if (element instanceof FileReferences) {
            return element.id;
        }
        else if (element instanceof OneReference) {
            return element.id;
        }
        return undefined;
    };
    DataSource.prototype.hasChildren = function (tree, element) {
        if (element instanceof ReferencesModel) {
            return true;
        }
        if (element instanceof FileReferences && !element.failure) {
            return true;
        }
        return false;
    };
    DataSource.prototype.getChildren = function (tree, element) {
        if (element instanceof ReferencesModel) {
            return TPromise.as(element.groups);
        }
        else if (element instanceof FileReferences) {
            return element.resolve(this._textModelResolverService).then(function (val) {
                if (element.failure) {
                    // refresh the element on failure so that
                    // we can update its rendering
                    return tree.refresh(element).then(function () { return val.children; });
                }
                return val.children;
            });
        }
        else {
            return TPromise.as([]);
        }
    };
    DataSource.prototype.getParent = function (tree, element) {
        var result = null;
        if (element instanceof FileReferences) {
            result = element.parent;
        }
        else if (element instanceof OneReference) {
            result = element.parent;
        }
        return TPromise.as(result);
    };
    DataSource = __decorate$6([
        __param$6(0, ITextModelService)
    ], DataSource);
    return DataSource;
}());
var Controller = /** @class */ (function (_super) {
    __extends$k(Controller, _super);
    function Controller() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._onDidFocus = new Emitter();
        _this.onDidFocus = _this._onDidFocus.event;
        _this._onDidSelect = new Emitter();
        _this.onDidSelect = _this._onDidSelect.event;
        _this._onDidOpenToSide = new Emitter();
        _this.onDidOpenToSide = _this._onDidOpenToSide.event;
        return _this;
    }
    Controller.prototype.onTap = function (tree, element, event) {
        if (element instanceof FileReferences) {
            event.preventDefault();
            event.stopPropagation();
            return this._expandCollapse(tree, element);
        }
        var result = _super.prototype.onTap.call(this, tree, element, event);
        this._onDidFocus.fire(element);
        return result;
    };
    Controller.prototype.onMouseDown = function (tree, element, event) {
        var isDoubleClick = event.detail === 2;
        if (event.leftButton) {
            if (element instanceof FileReferences) {
                if (this.openOnSingleClick || isDoubleClick || this.isClickOnTwistie(event)) {
                    event.preventDefault();
                    event.stopPropagation();
                    return this._expandCollapse(tree, element);
                }
            }
            var result = _super.prototype.onClick.call(this, tree, element, event);
            var openToSide = event.ctrlKey || event.metaKey || event.altKey;
            if (openToSide && (isDoubleClick || this.openOnSingleClick)) {
                this._onDidOpenToSide.fire(element);
            }
            else if (isDoubleClick) {
                this._onDidSelect.fire(element);
            }
            else if (this.openOnSingleClick) {
                this._onDidFocus.fire(element);
            }
            return result;
        }
        return false;
    };
    Controller.prototype.onClick = function (tree, element, event) {
        if (event.leftButton) {
            return false; // Already handled by onMouseDown
        }
        return _super.prototype.onClick.call(this, tree, element, event);
    };
    Controller.prototype._expandCollapse = function (tree, element) {
        if (tree.isExpanded(element)) {
            tree.collapse(element).done(null, onUnexpectedError);
        }
        else {
            tree.expand(element).done(null, onUnexpectedError);
        }
        return true;
    };
    Controller.prototype.onEscape = function (tree, event) {
        return false;
    };
    Controller.prototype.dispose = function () {
        this._onDidFocus.dispose();
        this._onDidSelect.dispose();
        this._onDidOpenToSide.dispose();
    };
    return Controller;
}(WorkbenchTreeController));
var FileReferencesTemplate = /** @class */ (function () {
    function FileReferencesTemplate(container, _contextService, _environmentService, themeService) {
        var _this = this;
        this._contextService = _contextService;
        this._environmentService = _environmentService;
        var parent = document.createElement('div');
        addClass(parent, 'reference-file');
        container.appendChild(parent);
        this.file = new FileLabel(parent, URI.parse('no:file'), this._contextService, this._environmentService);
        this.badge = new CountBadge($$1('.count').appendTo(parent).getHTMLElement());
        var styler = attachBadgeStyler(this.badge, themeService);
        this.dispose = function () {
            _this.file.dispose();
            styler.dispose();
        };
    }
    FileReferencesTemplate.prototype.set = function (element) {
        this.file.setFile(element.uri, this._contextService, this._environmentService);
        var len = element.children.length;
        this.badge.setCount(len);
        if (element.failure) {
            this.badge.setTitleFormat(localize('referencesFailre', "Failed to resolve file."));
        }
        else if (len > 1) {
            this.badge.setTitleFormat(localize('referencesCount', "{0} references", len));
        }
        else {
            this.badge.setTitleFormat(localize('referenceCount', "{0} reference", len));
        }
    };
    FileReferencesTemplate = __decorate$6([
        __param$6(1, IWorkspaceContextService),
        __param$6(2, optional(IEnvironmentService)),
        __param$6(3, IThemeService)
    ], FileReferencesTemplate);
    return FileReferencesTemplate;
}());
var OneReferenceTemplate = /** @class */ (function () {
    function OneReferenceTemplate(container) {
        var parent = document.createElement('div');
        this.before = document.createElement('span');
        this.inside = document.createElement('span');
        this.after = document.createElement('span');
        addClass(this.inside, 'referenceMatch');
        addClass(parent, 'reference');
        parent.appendChild(this.before);
        parent.appendChild(this.inside);
        parent.appendChild(this.after);
        container.appendChild(parent);
    }
    OneReferenceTemplate.prototype.set = function (element) {
        var _a = element.parent.preview.preview(element.range), before = _a.before, inside = _a.inside, after = _a.after;
        this.before.innerHTML = escape(before);
        this.inside.innerHTML = escape(inside);
        this.after.innerHTML = escape(after);
    };
    return OneReferenceTemplate;
}());
var Renderer$1 = /** @class */ (function () {
    function Renderer(_contextService, _themeService, _environmentService) {
        this._contextService = _contextService;
        this._themeService = _themeService;
        this._environmentService = _environmentService;
        //
    }
    Renderer.prototype.getHeight = function (tree, element) {
        return 23;
    };
    Renderer.prototype.getTemplateId = function (tree, element) {
        if (element instanceof FileReferences) {
            return Renderer._ids.FileReferences;
        }
        else if (element instanceof OneReference) {
            return Renderer._ids.OneReference;
        }
        throw element;
    };
    Renderer.prototype.renderTemplate = function (tree, templateId, container) {
        if (templateId === Renderer._ids.FileReferences) {
            return new FileReferencesTemplate(container, this._contextService, this._environmentService, this._themeService);
        }
        else if (templateId === Renderer._ids.OneReference) {
            return new OneReferenceTemplate(container);
        }
        throw templateId;
    };
    Renderer.prototype.renderElement = function (tree, element, templateId, templateData) {
        if (element instanceof FileReferences) {
            templateData.set(element);
        }
        else if (element instanceof OneReference) {
            templateData.set(element);
        }
        else {
            throw templateId;
        }
    };
    Renderer.prototype.disposeTemplate = function (tree, templateId, templateData) {
        if (templateData instanceof FileReferencesTemplate) {
            templateData.dispose();
        }
    };
    Renderer._ids = {
        FileReferences: 'FileReferences',
        OneReference: 'OneReference'
    };
    Renderer = __decorate$6([
        __param$6(0, IWorkspaceContextService),
        __param$6(1, IThemeService),
        __param$6(2, optional(IEnvironmentService))
    ], Renderer);
    return Renderer;
}());
var AriaProvider = /** @class */ (function () {
    function AriaProvider() {
    }
    AriaProvider.prototype.getAriaLabel = function (tree, element) {
        if (element instanceof FileReferences) {
            return element.getAriaMessage();
        }
        else if (element instanceof OneReference) {
            return element.getAriaMessage();
        }
        else {
            return undefined;
        }
    };
    return AriaProvider;
}());
var VSash = /** @class */ (function () {
    function VSash(container, ratio) {
        var _this = this;
        this._disposables = [];
        this._onDidChangePercentages = new Emitter();
        this._ratio = ratio;
        this._sash = new Sash(container, {
            getVerticalSashLeft: function () { return _this._width * _this._ratio; },
            getVerticalSashHeight: function () { return _this._height; }
        });
        // compute the current widget clientX postion since
        // the sash works with clientX when dragging
        var clientX;
        this._disposables.push(this._sash.onDidStart(function (e) {
            clientX = e.startX - (_this._width * _this.ratio);
        }));
        this._disposables.push(this._sash.onDidChange(function (e) {
            // compute the new position of the sash and from that
            // compute the new ratio that we are using
            var newLeft = e.currentX - clientX;
            if (newLeft > 20 && newLeft + 20 < _this._width) {
                _this._ratio = newLeft / _this._width;
                _this._sash.layout();
                _this._onDidChangePercentages.fire(_this);
            }
        }));
    }
    VSash.prototype.dispose = function () {
        this._sash.dispose();
        this._onDidChangePercentages.dispose();
        dispose(this._disposables);
    };
    Object.defineProperty(VSash.prototype, "onDidChangePercentages", {
        get: function () {
            return this._onDidChangePercentages.event;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(VSash.prototype, "width", {
        set: function (value) {
            this._width = value;
            this._sash.layout();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(VSash.prototype, "height", {
        set: function (value) {
            this._height = value;
            this._sash.layout();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(VSash.prototype, "percentages", {
        get: function () {
            var left = 100 * this._ratio;
            var right = 100 - left;
            return [left + "%", right + "%"];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(VSash.prototype, "ratio", {
        get: function () {
            return this._ratio;
        },
        enumerable: true,
        configurable: true
    });
    return VSash;
}());
var ctxReferenceWidgetSearchTreeFocused = new RawContextKey('referenceSearchTreeFocused', true);
/**
 * ZoneWidget that is shown inside the editor
 */
var ReferenceWidget = /** @class */ (function (_super) {
    __extends$k(ReferenceWidget, _super);
    function ReferenceWidget(editor, _defaultTreeKeyboardSupport, layoutData, _textModelResolverService, _contextService, themeService, _instantiationService, _environmentService) {
        var _this = _super.call(this, editor, { showFrame: false, showArrow: true, isResizeable: true, isAccessible: true }) || this;
        _this._defaultTreeKeyboardSupport = _defaultTreeKeyboardSupport;
        _this.layoutData = layoutData;
        _this._textModelResolverService = _textModelResolverService;
        _this._contextService = _contextService;
        _this._instantiationService = _instantiationService;
        _this._environmentService = _environmentService;
        _this._disposeOnNewModel = [];
        _this._callOnDispose = [];
        _this._onDidSelectReference = new Emitter();
        _this._applyTheme(themeService.getTheme());
        _this._callOnDispose.push(themeService.onThemeChange(_this._applyTheme.bind(_this)));
        _this.create();
        return _this;
    }
    ReferenceWidget.prototype._applyTheme = function (theme) {
        var borderColor = theme.getColor(peekViewBorder) || Color.transparent;
        this.style({
            arrowColor: borderColor,
            frameColor: borderColor,
            headerBackgroundColor: theme.getColor(peekViewTitleBackground) || Color.transparent,
            primaryHeadingColor: theme.getColor(peekViewTitleForeground),
            secondaryHeadingColor: theme.getColor(peekViewTitleInfoForeground)
        });
    };
    ReferenceWidget.prototype.dispose = function () {
        this.setModel(null);
        this._callOnDispose = dispose(this._callOnDispose);
        dispose(this._preview, this._previewNotAvailableMessage, this._tree, this._sash, this._previewModelReference);
        _super.prototype.dispose.call(this);
    };
    Object.defineProperty(ReferenceWidget.prototype, "onDidSelectReference", {
        get: function () {
            return this._onDidSelectReference.event;
        },
        enumerable: true,
        configurable: true
    });
    ReferenceWidget.prototype.show = function (where) {
        this.editor.revealRangeInCenterIfOutsideViewport(where, 0 /* Smooth */);
        _super.prototype.show.call(this, where, this.layoutData.heightInLines || 18);
    };
    ReferenceWidget.prototype.focus = function () {
        this._tree.domFocus();
    };
    ReferenceWidget.prototype._onTitleClick = function (e) {
        if (this._preview && this._preview.getModel()) {
            this._onDidSelectReference.fire({
                element: this._getFocusedReference(),
                kind: e.ctrlKey || e.metaKey || e.altKey ? 'side' : 'open',
                source: 'title'
            });
        }
    };
    ReferenceWidget.prototype._fillBody = function (containerElement) {
        var _this = this;
        var container = $$1(containerElement);
        this.setCssClass('reference-zone-widget');
        // message pane
        container.div({ 'class': 'messages' }, function (div) {
            _this._messageContainer = div.hide();
        });
        // editor
        container.div({ 'class': 'preview inline' }, function (div) {
            var options = {
                scrollBeyondLastLine: false,
                scrollbar: {
                    verticalScrollbarSize: 14,
                    horizontal: 'auto',
                    useShadows: true,
                    verticalHasArrows: false,
                    horizontalHasArrows: false
                },
                overviewRulerLanes: 2,
                fixedOverflowWidgets: true,
                minimap: {
                    enabled: false
                }
            };
            _this._preview = _this._instantiationService.createInstance(EmbeddedCodeEditorWidget, div.getHTMLElement(), options, _this.editor);
            _this._previewContainer = div.hide();
            _this._previewNotAvailableMessage = TextModel.createFromString(localize('missingPreviewMessage', "no preview available"));
        });
        // sash
        this._sash = new VSash(containerElement, this.layoutData.ratio || .8);
        this._sash.onDidChangePercentages(function () {
            var _a = _this._sash.percentages, left = _a[0], right = _a[1];
            _this._previewContainer.style({ width: left });
            _this._treeContainer.style({ width: right });
            _this._preview.layout();
            _this._tree.layout();
            _this.layoutData.ratio = _this._sash.ratio;
        });
        // tree
        container.div({ 'class': 'ref-tree inline' }, function (div) {
            var controller = _this._instantiationService.createInstance(Controller, { keyboardSupport: _this._defaultTreeKeyboardSupport, clickBehavior: ClickBehavior.ON_MOUSE_UP /* our controller already deals with this */ });
            _this._callOnDispose.push(controller);
            var config = {
                dataSource: _this._instantiationService.createInstance(DataSource),
                renderer: _this._instantiationService.createInstance(Renderer$1),
                controller: controller,
                accessibilityProvider: new AriaProvider()
            };
            var options = {
                twistiePixels: 20,
                ariaLabel: localize('treeAriaLabel', "References")
            };
            _this._tree = _this._instantiationService.createInstance(WorkbenchTree, div.getHTMLElement(), config, options);
            ctxReferenceWidgetSearchTreeFocused.bindTo(_this._tree.contextKeyService);
            // listen on selection and focus
            var onEvent = function (element, kind) {
                if (element instanceof OneReference) {
                    if (kind === 'show') {
                        _this._revealReference(element, false);
                    }
                    _this._onDidSelectReference.fire({ element: element, kind: kind, source: 'tree' });
                }
            };
            _this._disposables.push(_this._tree.onDidChangeFocus(function (event) {
                if (event && event.payload && event.payload.origin === 'keyboard') {
                    onEvent(event.focus, 'show'); // only handle events from keyboard, mouse/touch is handled by other listeners below
                }
            }));
            _this._disposables.push(_this._tree.onDidChangeSelection(function (event) {
                if (event && event.payload && event.payload.origin === 'keyboard') {
                    onEvent(event.selection[0], 'goto'); // only handle events from keyboard, mouse/touch is handled by other listeners below
                }
            }));
            _this._disposables.push(controller.onDidFocus(function (element) { return onEvent(element, 'show'); }));
            _this._disposables.push(controller.onDidSelect(function (element) { return onEvent(element, 'goto'); }));
            _this._disposables.push(controller.onDidOpenToSide(function (element) { return onEvent(element, 'side'); }));
            _this._treeContainer = div.hide();
        });
    };
    ReferenceWidget.prototype._doLayoutBody = function (heightInPixel, widthInPixel) {
        _super.prototype._doLayoutBody.call(this, heightInPixel, widthInPixel);
        var height = heightInPixel + 'px';
        this._sash.height = heightInPixel;
        this._sash.width = widthInPixel;
        // set height/width
        var _a = this._sash.percentages, left = _a[0], right = _a[1];
        this._previewContainer.style({ height: height, width: left });
        this._treeContainer.style({ height: height, width: right });
        // forward
        this._tree.layout(heightInPixel);
        this._preview.layout();
        // store layout data
        this.layoutData = {
            heightInLines: this._viewZone.heightInLines,
            ratio: this._sash.ratio
        };
    };
    ReferenceWidget.prototype._onWidth = function (widthInPixel) {
        this._sash.width = widthInPixel;
        this._preview.layout();
    };
    ReferenceWidget.prototype.setSelection = function (selection) {
        var _this = this;
        return this._revealReference(selection, true).then(function () {
            // show in tree
            _this._tree.setSelection([selection]);
            _this._tree.setFocus(selection);
        });
    };
    ReferenceWidget.prototype.setModel = function (newModel) {
        // clean up
        this._disposeOnNewModel = dispose(this._disposeOnNewModel);
        this._model = newModel;
        if (this._model) {
            return this._onNewModel();
        }
        return undefined;
    };
    ReferenceWidget.prototype._onNewModel = function () {
        var _this = this;
        if (this._model.empty) {
            this.setTitle('');
            this._messageContainer.innerHtml(localize('noResults', "No results")).show();
            return TPromise.as(void 0);
        }
        this._messageContainer.hide();
        this._decorationsManager = new DecorationsManager(this._preview, this._model);
        this._disposeOnNewModel.push(this._decorationsManager);
        // listen on model changes
        this._disposeOnNewModel.push(this._model.onDidChangeReferenceRange(function (reference) { return _this._tree.refresh(reference); }));
        // listen on editor
        this._disposeOnNewModel.push(this._preview.onMouseDown(function (e) {
            var event = e.event, target = e.target;
            if (event.detail === 2) {
                _this._onDidSelectReference.fire({
                    element: { uri: _this._getFocusedReference().uri, range: target.range },
                    kind: (event.ctrlKey || event.metaKey || event.altKey) ? 'side' : 'open',
                    source: 'editor'
                });
            }
        }));
        // make sure things are rendered
        addClass(this.container, 'results-loaded');
        this._treeContainer.show();
        this._previewContainer.show();
        this._preview.layout();
        this._tree.layout();
        this.focus();
        // pick input and a reference to begin with
        var input = this._model.groups.length === 1 ? this._model.groups[0] : this._model;
        return this._tree.setInput(input);
    };
    ReferenceWidget.prototype._getFocusedReference = function () {
        var element = this._tree.getFocus();
        if (element instanceof OneReference) {
            return element;
        }
        else if (element instanceof FileReferences) {
            if (element.children.length > 0) {
                return element.children[0];
            }
        }
        return undefined;
    };
    ReferenceWidget.prototype._revealReference = function (reference, revealParent) {
        return __awaiter(this, void 0, TPromise, function () {
            var _this = this;
            var promise;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        // Update widget header
                        if (reference.uri.scheme !== Schemas.inMemory) {
                            this.setTitle(reference.name, getPathLabel(reference.directory, this._contextService, this._environmentService));
                        }
                        else {
                            this.setTitle(localize('peekView.alternateTitle', "References"));
                        }
                        promise = this._textModelResolverService.createModelReference(reference.uri);
                        if (!revealParent) return [3 /*break*/, 2];
                        return [4 /*yield*/, this._tree.reveal(reference.parent)];
                    case 1:
                        _a.sent();
                        _a.label = 2;
                    case 2: return [2 /*return*/, TPromise.join([promise, this._tree.reveal(reference)]).then(function (values) {
                            var ref = values[0];
                            if (!_this._model) {
                                ref.dispose();
                                // disposed
                                return;
                            }
                            dispose(_this._previewModelReference);
                            // show in editor
                            var model = ref.object;
                            if (model) {
                                _this._previewModelReference = ref;
                                var isSameModel = (_this._preview.getModel() === model.textEditorModel);
                                _this._preview.setModel(model.textEditorModel);
                                var sel = Range.lift(reference.range).collapseToStart();
                                _this._preview.setSelection(sel);
                                _this._preview.revealRangeInCenter(sel, isSameModel ? 0 /* Smooth */ : 1 /* Immediate */);
                            }
                            else {
                                _this._preview.setModel(_this._previewNotAvailableMessage);
                                ref.dispose();
                            }
                        }, onUnexpectedError)];
                }
            });
        });
    };
    return ReferenceWidget;
}(PeekViewWidget));
// theming
var peekViewTitleBackground = registerColor('peekViewTitle.background', { dark: '#1E1E1E', light: '#FFFFFF', hc: '#0C141F' }, localize('peekViewTitleBackground', 'Background color of the peek view title area.'));
var peekViewTitleForeground = registerColor('peekViewTitleLabel.foreground', { dark: '#FFFFFF', light: '#333333', hc: '#FFFFFF' }, localize('peekViewTitleForeground', 'Color of the peek view title.'));
var peekViewTitleInfoForeground = registerColor('peekViewTitleDescription.foreground', { dark: '#ccccccb3', light: '#6c6c6cb3', hc: '#FFFFFF99' }, localize('peekViewTitleInfoForeground', 'Color of the peek view title info.'));
var peekViewBorder = registerColor('peekView.border', { dark: '#007acc', light: '#007acc', hc: contrastBorder }, localize('peekViewBorder', 'Color of the peek view borders and arrow.'));
var peekViewResultsBackground = registerColor('peekViewResult.background', { dark: '#252526', light: '#F3F3F3', hc: Color.black }, localize('peekViewResultsBackground', 'Background color of the peek view result list.'));
var peekViewResultsMatchForeground = registerColor('peekViewResult.lineForeground', { dark: '#bbbbbb', light: '#646465', hc: Color.white }, localize('peekViewResultsMatchForeground', 'Foreground color for line nodes in the peek view result list.'));
var peekViewResultsFileForeground = registerColor('peekViewResult.fileForeground', { dark: Color.white, light: '#1E1E1E', hc: Color.white }, localize('peekViewResultsFileForeground', 'Foreground color for file nodes in the peek view result list.'));
var peekViewResultsSelectionBackground = registerColor('peekViewResult.selectionBackground', { dark: '#3399ff33', light: '#3399ff33', hc: null }, localize('peekViewResultsSelectionBackground', 'Background color of the selected entry in the peek view result list.'));
var peekViewResultsSelectionForeground = registerColor('peekViewResult.selectionForeground', { dark: Color.white, light: '#6C6C6C', hc: Color.white }, localize('peekViewResultsSelectionForeground', 'Foreground color of the selected entry in the peek view result list.'));
var peekViewEditorBackground = registerColor('peekViewEditor.background', { dark: '#001F33', light: '#F2F8FC', hc: Color.black }, localize('peekViewEditorBackground', 'Background color of the peek view editor.'));
var peekViewEditorGutterBackground = registerColor('peekViewEditorGutter.background', { dark: peekViewEditorBackground, light: peekViewEditorBackground, hc: peekViewEditorBackground }, localize('peekViewEditorGutterBackground', 'Background color of the gutter in the peek view editor.'));
var peekViewResultsMatchHighlight = registerColor('peekViewResult.matchHighlightBackground', { dark: '#ea5c004d', light: '#ea5c004d', hc: null }, localize('peekViewResultsMatchHighlight', 'Match highlight color in the peek view result list.'));
var peekViewEditorMatchHighlight = registerColor('peekViewEditor.matchHighlightBackground', { dark: '#ff8f0099', light: '#f5d802de', hc: null }, localize('peekViewEditorMatchHighlight', 'Match highlight color in the peek view editor.'));
var peekViewEditorMatchHighlightBorder = registerColor('peekViewEditor.matchHighlightBorder', { dark: null, light: null, hc: activeContrastBorder }, localize('peekViewEditorMatchHighlightBorder', 'Match highlight border in the peek view editor.'));
registerThemingParticipant(function (theme, collector) {
    var findMatchHighlightColor = theme.getColor(peekViewResultsMatchHighlight);
    if (findMatchHighlightColor) {
        collector.addRule(".monaco-editor .reference-zone-widget .ref-tree .referenceMatch { background-color: " + findMatchHighlightColor + "; }");
    }
    var referenceHighlightColor = theme.getColor(peekViewEditorMatchHighlight);
    if (referenceHighlightColor) {
        collector.addRule(".monaco-editor .reference-zone-widget .preview .reference-decoration { background-color: " + referenceHighlightColor + "; }");
    }
    var referenceHighlightBorder = theme.getColor(peekViewEditorMatchHighlightBorder);
    if (referenceHighlightBorder) {
        collector.addRule(".monaco-editor .reference-zone-widget .preview .reference-decoration { border: 2px solid " + referenceHighlightBorder + "; box-sizing: border-box; }");
    }
    var hcOutline = theme.getColor(activeContrastBorder);
    if (hcOutline) {
        collector.addRule(".monaco-editor .reference-zone-widget .ref-tree .referenceMatch { border: 1px dotted " + hcOutline + "; box-sizing: border-box; }");
    }
    var resultsBackground = theme.getColor(peekViewResultsBackground);
    if (resultsBackground) {
        collector.addRule(".monaco-editor .reference-zone-widget .ref-tree { background-color: " + resultsBackground + "; }");
    }
    var resultsMatchForeground = theme.getColor(peekViewResultsMatchForeground);
    if (resultsMatchForeground) {
        collector.addRule(".monaco-editor .reference-zone-widget .ref-tree { color: " + resultsMatchForeground + "; }");
    }
    var resultsFileForeground = theme.getColor(peekViewResultsFileForeground);
    if (resultsFileForeground) {
        collector.addRule(".monaco-editor .reference-zone-widget .ref-tree .reference-file { color: " + resultsFileForeground + "; }");
    }
    var resultsSelectedBackground = theme.getColor(peekViewResultsSelectionBackground);
    if (resultsSelectedBackground) {
        collector.addRule(".monaco-editor .reference-zone-widget .ref-tree .monaco-tree.focused .monaco-tree-rows > .monaco-tree-row.selected:not(.highlighted) { background-color: " + resultsSelectedBackground + "; }");
    }
    var resultsSelectedForeground = theme.getColor(peekViewResultsSelectionForeground);
    if (resultsSelectedForeground) {
        collector.addRule(".monaco-editor .reference-zone-widget .ref-tree .monaco-tree.focused .monaco-tree-rows > .monaco-tree-row.selected:not(.highlighted) { color: " + resultsSelectedForeground + " !important; }");
    }
    var editorBackground = theme.getColor(peekViewEditorBackground);
    if (editorBackground) {
        collector.addRule(".monaco-editor .reference-zone-widget .preview .monaco-editor .monaco-editor-background," +
            ".monaco-editor .reference-zone-widget .preview .monaco-editor .inputarea.ime-input {" +
            ("\tbackground-color: " + editorBackground + ";") +
            "}");
    }
    var editorGutterBackground = theme.getColor(peekViewEditorGutterBackground);
    if (editorGutterBackground) {
        collector.addRule(".monaco-editor .reference-zone-widget .preview .monaco-editor .margin {" +
            ("\tbackground-color: " + editorGutterBackground + ";") +
            "}");
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __decorate$7 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$7 = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var __awaiter$1 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator$1 = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var ctxReferenceSearchVisible = new RawContextKey('referenceSearchVisible', false);
var ReferencesController = /** @class */ (function () {
    function ReferencesController(_defaultTreeKeyboardSupport, editor, contextKeyService, _editorService, _textModelResolverService, _notificationService, _instantiationService, _contextService, _storageService, _themeService, _configurationService, _environmentService) {
        this._defaultTreeKeyboardSupport = _defaultTreeKeyboardSupport;
        this._editorService = _editorService;
        this._textModelResolverService = _textModelResolverService;
        this._notificationService = _notificationService;
        this._instantiationService = _instantiationService;
        this._contextService = _contextService;
        this._storageService = _storageService;
        this._themeService = _themeService;
        this._configurationService = _configurationService;
        this._environmentService = _environmentService;
        this._requestIdPool = 0;
        this._disposables = [];
        this._ignoreModelChangeEvent = false;
        this._editor = editor;
        this._referenceSearchVisible = ctxReferenceSearchVisible.bindTo(contextKeyService);
    }
    ReferencesController.get = function (editor) {
        return editor.getContribution(ReferencesController.ID);
    };
    ReferencesController.prototype.getId = function () {
        return ReferencesController.ID;
    };
    ReferencesController.prototype.dispose = function () {
        if (this._widget) {
            this._widget.dispose();
            this._widget = null;
        }
        this._editor = null;
    };
    ReferencesController.prototype.toggleWidget = function (range$$1, modelPromise, options) {
        var _this = this;
        // close current widget and return early is position didn't change
        var widgetPosition;
        if (this._widget) {
            widgetPosition = this._widget.position;
        }
        this.closeWidget();
        if (!!widgetPosition && range$$1.containsPosition(widgetPosition)) {
            return null;
        }
        this._referenceSearchVisible.set(true);
        // close the widget on model/mode changes
        this._disposables.push(this._editor.onDidChangeModelLanguage(function () { _this.closeWidget(); }));
        this._disposables.push(this._editor.onDidChangeModel(function () {
            if (!_this._ignoreModelChangeEvent) {
                _this.closeWidget();
            }
        }));
        var storageKey = 'peekViewLayout';
        var data = JSON.parse(this._storageService.get(storageKey, undefined, '{}'));
        this._widget = new ReferenceWidget(this._editor, this._defaultTreeKeyboardSupport, data, this._textModelResolverService, this._contextService, this._themeService, this._instantiationService, this._environmentService);
        this._widget.setTitle(localize('labelLoading', "Loading..."));
        this._widget.show(range$$1);
        this._disposables.push(this._widget.onDidClose(function () {
            modelPromise.cancel();
            _this._storageService.store(storageKey, JSON.stringify(_this._widget.layoutData));
            _this._widget = null;
            _this.closeWidget();
        }));
        this._disposables.push(this._widget.onDidSelectReference(function (event) {
            var element = event.element, kind = event.kind;
            switch (kind) {
                case 'open':
                    if (event.source === 'editor'
                        && _this._configurationService.getValue('editor.stablePeek')) {
                        // when stable peek is configured we don't close
                        // the peek window on selecting the editor
                        break;
                    }
                case 'side':
                    _this.openReference(element, kind === 'side');
                    break;
                case 'goto':
                    if (options.onGoto) {
                        options.onGoto(element);
                    }
                    else {
                        _this._gotoReference(element);
                    }
                    break;
            }
        }));
        var requestId = ++this._requestIdPool;
        modelPromise.then(function (model) {
            // still current request? widget still open?
            if (requestId !== _this._requestIdPool || !_this._widget) {
                return undefined;
            }
            if (_this._model) {
                _this._model.dispose();
            }
            _this._model = model;
            // show widget
            return _this._widget.setModel(_this._model).then(function () {
                if (_this._widget) { // might have been closed
                    // set title
                    _this._widget.setMetaTitle(options.getMetaTitle(_this._model));
                    // set 'best' selection
                    var uri = _this._editor.getModel().uri;
                    var pos = new Position(range$$1.startLineNumber, range$$1.startColumn);
                    var selection = _this._model.nearestReference(uri, pos);
                    if (selection) {
                        return _this._widget.setSelection(selection);
                    }
                }
                return undefined;
            });
        }, function (error) {
            _this._notificationService.error(error);
        });
    };
    ReferencesController.prototype.goToNextOrPreviousReference = function (fwd) {
        return __awaiter$1(this, void 0, void 0, function () {
            var source, target, editorFocus;
            return __generator$1(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this._model) return [3 /*break*/, 3];
                        source = this._model.nearestReference(this._editor.getModel().uri, this._widget.position);
                        target = this._model.nextOrPreviousReference(source, fwd);
                        editorFocus = this._editor.isFocused();
                        return [4 /*yield*/, this._widget.setSelection(target)];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, this._gotoReference(target)];
                    case 2:
                        _a.sent();
                        if (editorFocus) {
                            this._editor.focus();
                        }
                        _a.label = 3;
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    ReferencesController.prototype.closeWidget = function () {
        if (this._widget) {
            this._widget.dispose();
            this._widget = null;
        }
        this._referenceSearchVisible.reset();
        this._disposables = dispose(this._disposables);
        if (this._model) {
            this._model.dispose();
            this._model = null;
        }
        this._editor.focus();
        this._requestIdPool += 1; // Cancel pending requests
    };
    ReferencesController.prototype._gotoReference = function (ref) {
        var _this = this;
        this._widget.hide();
        this._ignoreModelChangeEvent = true;
        var range$$1 = Range.lift(ref.range).collapseToStart();
        return this._editorService.openEditor({
            resource: ref.uri,
            options: { selection: range$$1 }
        }).then(function (openedEditor) {
            _this._ignoreModelChangeEvent = false;
            if (!openedEditor || openedEditor.getControl() !== _this._editor) {
                // TODO@Alex TODO@Joh
                // when opening the current reference we might end up
                // in a different editor instance. that means we also have
                // a different instance of this reference search controller
                // and cannot hold onto the widget (which likely doesn't
                // exist). Instead of bailing out we should find the
                // 'sister' action and pass our current model on to it.
                _this.closeWidget();
                return;
            }
            _this._widget.show(range$$1);
            _this._widget.focus();
        }, function (err) {
            _this._ignoreModelChangeEvent = false;
            onUnexpectedError(err);
        });
    };
    ReferencesController.prototype.openReference = function (ref, sideBySide) {
        var uri = ref.uri, range$$1 = ref.range;
        this._editorService.openEditor({
            resource: uri,
            options: { selection: range$$1 }
        }, sideBySide);
        // clear stage
        if (!sideBySide) {
            this.closeWidget();
        }
    };
    ReferencesController.ID = 'editor.contrib.referencesController';
    ReferencesController = __decorate$7([
        __param$7(2, IContextKeyService),
        __param$7(3, IEditorService),
        __param$7(4, ITextModelService),
        __param$7(5, INotificationService),
        __param$7(6, IInstantiationService),
        __param$7(7, IWorkspaceContextService),
        __param$7(8, IStorageService),
        __param$7(9, IThemeService),
        __param$7(10, IConfigurationService),
        __param$7(11, optional(IEnvironmentService))
    ], ReferencesController);
    return ReferencesController;
}());

const css$f = "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n.monaco-editor .monaco-editor-overlaymessage {\n\tpadding-bottom: 8px;\n}\n\n@keyframes fadeIn {\n\tfrom { opacity: 0; }\n\tto { opacity: 1; }\n}\n.monaco-editor .monaco-editor-overlaymessage.fadeIn {\n\tanimation: fadeIn 150ms ease-out;\n}\n\n@keyframes fadeOut {\n\tfrom { opacity: 1; }\n\tto { opacity: 0; }\n}\n.monaco-editor .monaco-editor-overlaymessage.fadeOut {\n\tanimation: fadeOut 100ms ease-out;\n}\n\n.monaco-editor .monaco-editor-overlaymessage .message {\n\tpadding: 1px 4px;\n}\n\n.monaco-editor .monaco-editor-overlaymessage .anchor {\n\twidth: 0 !important;\n\theight: 0 !important;\n\tborder-color: transparent;\n\tborder-style: solid;\n\tz-index: 1000;\n\tborder-width: 8px;\n\tposition: absolute;\n}\n";
  const element$f = ((css, src) => {
if (typeof document !== 'object')
console.info(`Skipped loading "${src}"`);
try {
const id = src
  .replace(/\.css.*$/, '')
  .replace(/[\\:]/g, '/')
  .replace(/[^\w\/]+/g, '');
return (
  document.querySelector(`style[id="${id}"]`) ||
  document.head.appendChild(
    Object.assign(document.createElement('style'), {
      id,
      textContent: `${css}\n\n /* sourceURL=${src} */`,
    }),
  )
);
} catch (exception) {
console.warn(`Failed load "${src}"`, exception);
}
})(css$f, "…monaco-editor/esm/vs/editor/contrib/message/messageController.css");
  //@ sourceURL=/Users/daflair/Projects/packages/monaco-es/node_modules/monaco-editor/esm/vs/editor/contrib/message/messageController.css

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$l = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate$8 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$8 = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var MessageController = /** @class */ (function (_super) {
    __extends$l(MessageController, _super);
    function MessageController(editor, contextKeyService) {
        var _this = _super.call(this) || this;
        _this._messageListeners = [];
        _this._editor = editor;
        _this._visible = MessageController.MESSAGE_VISIBLE.bindTo(contextKeyService);
        _this._register(_this._editor.onDidAttemptReadOnlyEdit(function () { return _this._onDidAttemptReadOnlyEdit(); }));
        return _this;
    }
    MessageController.get = function (editor) {
        return editor.getContribution(MessageController._id);
    };
    MessageController.prototype.getId = function () {
        return MessageController._id;
    };
    MessageController.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
        this._visible.reset();
    };
    MessageController.prototype.isVisible = function () {
        return this._visible.get();
    };
    MessageController.prototype.showMessage = function (message, position) {
        var _this = this;
        alert(message);
        this._visible.set(true);
        dispose(this._messageWidget);
        this._messageListeners = dispose(this._messageListeners);
        this._messageWidget = new MessageWidget(this._editor, position, message);
        // close on blur, cursor, model change, dispose
        this._messageListeners.push(this._editor.onDidBlurEditorText(function () { return _this.closeMessage(); }));
        this._messageListeners.push(this._editor.onDidChangeCursorPosition(function () { return _this.closeMessage(); }));
        this._messageListeners.push(this._editor.onDidDispose(function () { return _this.closeMessage(); }));
        this._messageListeners.push(this._editor.onDidChangeModel(function () { return _this.closeMessage(); }));
        // close after 3s
        this._messageListeners.push(setDisposableTimeout(function () { return _this.closeMessage(); }, 3000));
        // close on mouse move
        var bounds;
        this._messageListeners.push(this._editor.onMouseMove(function (e) {
            // outside the text area
            if (!e.target.position) {
                return;
            }
            if (!bounds) {
                // define bounding box around position and first mouse occurance
                bounds = new Range(position.lineNumber - 3, 1, e.target.position.lineNumber + 3, 1);
            }
            else if (!bounds.containsPosition(e.target.position)) {
                // check if position is still in bounds
                _this.closeMessage();
            }
        }));
    };
    MessageController.prototype.closeMessage = function () {
        this._visible.reset();
        this._messageListeners = dispose(this._messageListeners);
        this._messageListeners.push(MessageWidget.fadeOut(this._messageWidget));
    };
    MessageController.prototype._onDidAttemptReadOnlyEdit = function () {
        this.showMessage(localize('editor.readonly', "Cannot edit in read-only editor"), this._editor.getPosition());
    };
    MessageController._id = 'editor.contrib.messageController';
    MessageController.MESSAGE_VISIBLE = new RawContextKey('messageVisible', false);
    MessageController = __decorate$8([
        __param$8(1, IContextKeyService)
    ], MessageController);
    return MessageController;
}(Disposable));
var MessageCommand = EditorCommand.bindToContribution(MessageController.get);
registerEditorCommand(new MessageCommand({
    id: 'leaveEditorMessage',
    precondition: MessageController.MESSAGE_VISIBLE,
    handler: function (c) { return c.closeMessage(); },
    kbOpts: {
        weight: KeybindingsRegistry.WEIGHT.editorContrib(30),
        primary: 9 /* Escape */
    }
}));
var MessageWidget = /** @class */ (function () {
    function MessageWidget(editor, _a, text) {
        var lineNumber = _a.lineNumber, column = _a.column;
        // Editor.IContentWidget.allowEditorOverflow
        this.allowEditorOverflow = true;
        this.suppressMouseDown = false;
        this._editor = editor;
        this._editor.revealLinesInCenterIfOutsideViewport(lineNumber, lineNumber, 0 /* Smooth */);
        this._position = { lineNumber: lineNumber, column: column - 1 };
        this._domNode = document.createElement('div');
        this._domNode.classList.add('monaco-editor-overlaymessage');
        var message = document.createElement('div');
        message.classList.add('message');
        message.textContent = text;
        this._domNode.appendChild(message);
        var anchor = document.createElement('div');
        anchor.classList.add('anchor');
        this._domNode.appendChild(anchor);
        this._editor.addContentWidget(this);
        this._domNode.classList.add('fadeIn');
    }
    MessageWidget.fadeOut = function (messageWidget) {
        var handle;
        var dispose$$1 = function () {
            messageWidget.dispose();
            clearTimeout(handle);
            messageWidget.getDomNode().removeEventListener('animationend', dispose$$1);
        };
        handle = setTimeout(dispose$$1, 110);
        messageWidget.getDomNode().addEventListener('animationend', dispose$$1);
        messageWidget.getDomNode().classList.add('fadeOut');
        return { dispose: dispose$$1 };
    };
    MessageWidget.prototype.dispose = function () {
        this._editor.removeContentWidget(this);
    };
    MessageWidget.prototype.getId = function () {
        return 'messageoverlay';
    };
    MessageWidget.prototype.getDomNode = function () {
        return this._domNode;
    };
    MessageWidget.prototype.getPosition = function () {
        return { position: this._position, preference: [ContentWidgetPositionPreference.ABOVE] };
    };
    return MessageWidget;
}());
registerEditorContribution(MessageController);
registerThemingParticipant(function (theme, collector) {
    var border = theme.getColor(inputValidationInfoBorder);
    if (border) {
        var borderWidth = theme.type === HIGH_CONTRAST ? 2 : 1;
        collector.addRule(".monaco-editor .monaco-editor-overlaymessage .anchor { border-top-color: " + border + "; }");
        collector.addRule(".monaco-editor .monaco-editor-overlaymessage .message { border: " + borderWidth + "px solid " + border + "; }");
    }
    var background = theme.getColor(inputValidationInfoBackground);
    if (background) {
        collector.addRule(".monaco-editor .monaco-editor-overlaymessage .message { background-color: " + background + "; }");
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$m = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var DefinitionActionConfig = /** @class */ (function () {
    function DefinitionActionConfig(openToSide, openInPeek, filterCurrent, showMessage) {
        if (openToSide === void 0) { openToSide = false; }
        if (openInPeek === void 0) { openInPeek = false; }
        if (filterCurrent === void 0) { filterCurrent = true; }
        if (showMessage === void 0) { showMessage = true; }
        this.openToSide = openToSide;
        this.openInPeek = openInPeek;
        this.filterCurrent = filterCurrent;
        this.showMessage = showMessage;
        //
    }
    return DefinitionActionConfig;
}());
var DefinitionAction = /** @class */ (function (_super) {
    __extends$m(DefinitionAction, _super);
    function DefinitionAction(configuration, opts) {
        var _this = _super.call(this, opts) || this;
        _this._configuration = configuration;
        return _this;
    }
    DefinitionAction.prototype.run = function (accessor, editor) {
        var _this = this;
        var notificationService = accessor.get(INotificationService);
        var editorService = accessor.get(IEditorService);
        var progressService = accessor.get(IProgressService);
        var model = editor.getModel();
        var pos = editor.getPosition();
        var definitionPromise = this._getDeclarationsAtPosition(model, pos).then(function (references) {
            if (model.isDisposed() || editor.getModel() !== model) {
                // new model, no more model
                return;
            }
            // * remove falsy references
            // * find reference at the current pos
            var idxOfCurrent = -1;
            var result = [];
            for (var i = 0; i < references.length; i++) {
                var reference = references[i];
                if (!reference || !reference.range) {
                    continue;
                }
                var uri = reference.uri, range$$1 = reference.range;
                var newLen = result.push({
                    uri: uri,
                    range: range$$1
                });
                if (_this._configuration.filterCurrent
                    && uri.toString() === model.uri.toString()
                    && Range.containsPosition(range$$1, pos)
                    && idxOfCurrent === -1) {
                    idxOfCurrent = newLen - 1;
                }
            }
            if (result.length === 0) {
                // no result -> show message
                if (_this._configuration.showMessage) {
                    var info = model.getWordAtPosition(pos);
                    MessageController.get(editor).showMessage(_this._getNoResultFoundMessage(info), pos);
                }
            }
            else if (result.length === 1 && idxOfCurrent !== -1) {
                // only the position at which we are -> adjust selection
                var current = result[0];
                _this._openReference(editorService, current, false);
            }
            else {
                // handle multile results
                _this._onResult(editorService, editor, new ReferencesModel(result));
            }
        }, function (err) {
            // report an error
            notificationService.error(err);
        });
        progressService.showWhile(definitionPromise, 250);
        return definitionPromise;
    };
    DefinitionAction.prototype._getDeclarationsAtPosition = function (model, position) {
        return getDefinitionsAtPosition(model, position);
    };
    DefinitionAction.prototype._getNoResultFoundMessage = function (info) {
        return info && info.word
            ? localize('noResultWord', "No definition found for '{0}'", info.word)
            : localize('generic.noResults', "No definition found");
    };
    DefinitionAction.prototype._getMetaTitle = function (model) {
        return model.references.length > 1 && localize('meta.title', " – {0} definitions", model.references.length);
    };
    DefinitionAction.prototype._onResult = function (editorService, editor, model) {
        var _this = this;
        var msg = model.getAriaMessage();
        alert(msg);
        if (this._configuration.openInPeek) {
            this._openInPeek(editorService, editor, model);
        }
        else {
            var next = model.nearestReference(editor.getModel().uri, editor.getPosition());
            this._openReference(editorService, next, this._configuration.openToSide).then(function (editor) {
                if (editor && model.references.length > 1) {
                    _this._openInPeek(editorService, editor, model);
                }
                else {
                    model.dispose();
                }
            });
        }
    };
    DefinitionAction.prototype._openReference = function (editorService, reference, sideBySide) {
        var uri = reference.uri, range$$1 = reference.range;
        return editorService.openEditor({
            resource: uri,
            options: {
                selection: Range.collapseToStart(range$$1),
                revealIfVisible: true,
                revealInCenterIfOutsideViewport: true
            }
        }, sideBySide).then(function (editor) {
            return editor && editor.getControl();
        });
    };
    DefinitionAction.prototype._openInPeek = function (editorService, target, model) {
        var _this = this;
        var controller = ReferencesController.get(target);
        if (controller) {
            controller.toggleWidget(target.getSelection(), TPromise.as(model), {
                getMetaTitle: function (model) {
                    return _this._getMetaTitle(model);
                },
                onGoto: function (reference) {
                    controller.closeWidget();
                    return _this._openReference(editorService, reference, false);
                }
            });
        }
        else {
            model.dispose();
        }
    };
    return DefinitionAction;
}(EditorAction));
var goToDeclarationKb = isWeb
    ? 2048 /* CtrlCmd */ | 70 /* F12 */
    : 70 /* F12 */;
var GoToDefinitionAction = /** @class */ (function (_super) {
    __extends$m(GoToDefinitionAction, _super);
    function GoToDefinitionAction() {
        return _super.call(this, new DefinitionActionConfig(), {
            id: GoToDefinitionAction.ID,
            label: localize('actions.goToDecl.label', "Go to Definition"),
            alias: 'Go to Definition',
            precondition: ContextKeyExpr.and(EditorContextKeys.hasDefinitionProvider, EditorContextKeys.isInEmbeddedEditor.toNegated()),
            kbOpts: {
                kbExpr: EditorContextKeys.editorTextFocus,
                primary: goToDeclarationKb
            },
            menuOpts: {
                group: 'navigation',
                order: 1.1
            }
        }) || this;
    }
    GoToDefinitionAction.ID = 'editor.action.goToDeclaration';
    return GoToDefinitionAction;
}(DefinitionAction));
var OpenDefinitionToSideAction = /** @class */ (function (_super) {
    __extends$m(OpenDefinitionToSideAction, _super);
    function OpenDefinitionToSideAction() {
        return _super.call(this, new DefinitionActionConfig(true), {
            id: OpenDefinitionToSideAction.ID,
            label: localize('actions.goToDeclToSide.label', "Open Definition to the Side"),
            alias: 'Open Definition to the Side',
            precondition: ContextKeyExpr.and(EditorContextKeys.hasDefinitionProvider, EditorContextKeys.isInEmbeddedEditor.toNegated()),
            kbOpts: {
                kbExpr: EditorContextKeys.editorTextFocus,
                primary: KeyChord(2048 /* CtrlCmd */ | 41 /* KEY_K */, goToDeclarationKb)
            }
        }) || this;
    }
    OpenDefinitionToSideAction.ID = 'editor.action.openDeclarationToTheSide';
    return OpenDefinitionToSideAction;
}(DefinitionAction));
var PeekDefinitionAction = /** @class */ (function (_super) {
    __extends$m(PeekDefinitionAction, _super);
    function PeekDefinitionAction() {
        return _super.call(this, new DefinitionActionConfig(void 0, true, false), {
            id: 'editor.action.previewDeclaration',
            label: localize('actions.previewDecl.label', "Peek Definition"),
            alias: 'Peek Definition',
            precondition: ContextKeyExpr.and(EditorContextKeys.hasDefinitionProvider, PeekContext.notInPeekEditor, EditorContextKeys.isInEmbeddedEditor.toNegated()),
            kbOpts: {
                kbExpr: EditorContextKeys.editorTextFocus,
                primary: 512 /* Alt */ | 70 /* F12 */,
                linux: { primary: 2048 /* CtrlCmd */ | 1024 /* Shift */ | 68 /* F10 */ }
            },
            menuOpts: {
                group: 'navigation',
                order: 1.2
            }
        }) || this;
    }
    return PeekDefinitionAction;
}(DefinitionAction));
var ImplementationAction = /** @class */ (function (_super) {
    __extends$m(ImplementationAction, _super);
    function ImplementationAction() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ImplementationAction.prototype._getDeclarationsAtPosition = function (model, position) {
        return getImplementationsAtPosition(model, position);
    };
    ImplementationAction.prototype._getNoResultFoundMessage = function (info) {
        return info && info.word
            ? localize('goToImplementation.noResultWord', "No implementation found for '{0}'", info.word)
            : localize('goToImplementation.generic.noResults', "No implementation found");
    };
    ImplementationAction.prototype._getMetaTitle = function (model) {
        return model.references.length > 1 && localize('meta.implementations.title', " – {0} implementations", model.references.length);
    };
    return ImplementationAction;
}(DefinitionAction));
var GoToImplementationAction = /** @class */ (function (_super) {
    __extends$m(GoToImplementationAction, _super);
    function GoToImplementationAction() {
        return _super.call(this, new DefinitionActionConfig(), {
            id: GoToImplementationAction.ID,
            label: localize('actions.goToImplementation.label', "Go to Implementation"),
            alias: 'Go to Implementation',
            precondition: ContextKeyExpr.and(EditorContextKeys.hasImplementationProvider, EditorContextKeys.isInEmbeddedEditor.toNegated()),
            kbOpts: {
                kbExpr: EditorContextKeys.editorTextFocus,
                primary: 2048 /* CtrlCmd */ | 70 /* F12 */
            }
        }) || this;
    }
    GoToImplementationAction.ID = 'editor.action.goToImplementation';
    return GoToImplementationAction;
}(ImplementationAction));
var PeekImplementationAction = /** @class */ (function (_super) {
    __extends$m(PeekImplementationAction, _super);
    function PeekImplementationAction() {
        return _super.call(this, new DefinitionActionConfig(false, true, false), {
            id: PeekImplementationAction.ID,
            label: localize('actions.peekImplementation.label', "Peek Implementation"),
            alias: 'Peek Implementation',
            precondition: ContextKeyExpr.and(EditorContextKeys.hasImplementationProvider, EditorContextKeys.isInEmbeddedEditor.toNegated()),
            kbOpts: {
                kbExpr: EditorContextKeys.editorTextFocus,
                primary: 2048 /* CtrlCmd */ | 1024 /* Shift */ | 70 /* F12 */
            }
        }) || this;
    }
    PeekImplementationAction.ID = 'editor.action.peekImplementation';
    return PeekImplementationAction;
}(ImplementationAction));
var TypeDefinitionAction = /** @class */ (function (_super) {
    __extends$m(TypeDefinitionAction, _super);
    function TypeDefinitionAction() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    TypeDefinitionAction.prototype._getDeclarationsAtPosition = function (model, position) {
        return getTypeDefinitionsAtPosition(model, position);
    };
    TypeDefinitionAction.prototype._getNoResultFoundMessage = function (info) {
        return info && info.word
            ? localize('goToTypeDefinition.noResultWord', "No type definition found for '{0}'", info.word)
            : localize('goToTypeDefinition.generic.noResults', "No type definition found");
    };
    TypeDefinitionAction.prototype._getMetaTitle = function (model) {
        return model.references.length > 1 && localize('meta.typeDefinitions.title', " – {0} type definitions", model.references.length);
    };
    return TypeDefinitionAction;
}(DefinitionAction));
var GoToTypeDefintionAction = /** @class */ (function (_super) {
    __extends$m(GoToTypeDefintionAction, _super);
    function GoToTypeDefintionAction() {
        return _super.call(this, new DefinitionActionConfig(), {
            id: GoToTypeDefintionAction.ID,
            label: localize('actions.goToTypeDefinition.label', "Go to Type Definition"),
            alias: 'Go to Type Definition',
            precondition: ContextKeyExpr.and(EditorContextKeys.hasTypeDefinitionProvider, EditorContextKeys.isInEmbeddedEditor.toNegated()),
            kbOpts: {
                kbExpr: EditorContextKeys.editorTextFocus,
                primary: 0
            },
            menuOpts: {
                group: 'navigation',
                order: 1.4
            }
        }) || this;
    }
    GoToTypeDefintionAction.ID = 'editor.action.goToTypeDefinition';
    return GoToTypeDefintionAction;
}(TypeDefinitionAction));
var PeekTypeDefinitionAction = /** @class */ (function (_super) {
    __extends$m(PeekTypeDefinitionAction, _super);
    function PeekTypeDefinitionAction() {
        return _super.call(this, new DefinitionActionConfig(false, true, false), {
            id: PeekTypeDefinitionAction.ID,
            label: localize('actions.peekTypeDefinition.label', "Peek Type Definition"),
            alias: 'Peek Type Definition',
            precondition: ContextKeyExpr.and(EditorContextKeys.hasTypeDefinitionProvider, EditorContextKeys.isInEmbeddedEditor.toNegated()),
            kbOpts: {
                kbExpr: EditorContextKeys.editorTextFocus,
                primary: 0
            }
        }) || this;
    }
    PeekTypeDefinitionAction.ID = 'editor.action.peekTypeDefinition';
    return PeekTypeDefinitionAction;
}(TypeDefinitionAction));
registerEditorAction(GoToDefinitionAction);
registerEditorAction(OpenDefinitionToSideAction);
registerEditorAction(PeekDefinitionAction);
registerEditorAction(GoToImplementationAction);
registerEditorAction(PeekImplementationAction);
registerEditorAction(GoToTypeDefintionAction);
registerEditorAction(PeekTypeDefinitionAction);

const css$g = "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n.monaco-editor .goto-definition-link {\n\ttext-decoration: underline;\n\tcursor: pointer;\n}";
  const element$g = ((css, src) => {
if (typeof document !== 'object')
console.info(`Skipped loading "${src}"`);
try {
const id = src
  .replace(/\.css.*$/, '')
  .replace(/[\\:]/g, '/')
  .replace(/[^\w\/]+/g, '');
return (
  document.querySelector(`style[id="${id}"]`) ||
  document.head.appendChild(
    Object.assign(document.createElement('style'), {
      id,
      textContent: `${css}\n\n /* sourceURL=${src} */`,
    }),
  )
);
} catch (exception) {
console.warn(`Failed load "${src}"`, exception);
}
})(css$g, "…monaco-editor/esm/vs/editor/contrib/goToDeclaration/goToDeclarationMouse.css");
  //@ sourceURL=/Users/daflair/Projects/packages/monaco-es/node_modules/monaco-editor/esm/vs/editor/contrib/goToDeclaration/goToDeclarationMouse.css

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$n = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
function hasModifier(e, modifier) {
    return !!e[modifier];
}
/**
 * An event that encapsulates the various trigger modifiers logic needed for go to definition.
 */
var ClickLinkMouseEvent = /** @class */ (function () {
    function ClickLinkMouseEvent(source, opts) {
        this.target = source.target;
        this.hasTriggerModifier = hasModifier(source.event, opts.triggerModifier);
        this.hasSideBySideModifier = hasModifier(source.event, opts.triggerSideBySideModifier);
        this.isNoneOrSingleMouseDown = (isIE || source.event.detail <= 1); // IE does not support event.detail properly
    }
    return ClickLinkMouseEvent;
}());
/**
 * An event that encapsulates the various trigger modifiers logic needed for go to definition.
 */
var ClickLinkKeyboardEvent = /** @class */ (function () {
    function ClickLinkKeyboardEvent(source, opts) {
        this.keyCodeIsTriggerKey = (source.keyCode === opts.triggerKey);
        this.keyCodeIsSideBySideKey = (source.keyCode === opts.triggerSideBySideKey);
        this.hasTriggerModifier = hasModifier(source, opts.triggerModifier);
    }
    return ClickLinkKeyboardEvent;
}());
var ClickLinkOptions = /** @class */ (function () {
    function ClickLinkOptions(triggerKey, triggerModifier, triggerSideBySideKey, triggerSideBySideModifier) {
        this.triggerKey = triggerKey;
        this.triggerModifier = triggerModifier;
        this.triggerSideBySideKey = triggerSideBySideKey;
        this.triggerSideBySideModifier = triggerSideBySideModifier;
    }
    ClickLinkOptions.prototype.equals = function (other) {
        return (this.triggerKey === other.triggerKey
            && this.triggerModifier === other.triggerModifier
            && this.triggerSideBySideKey === other.triggerSideBySideKey
            && this.triggerSideBySideModifier === other.triggerSideBySideModifier);
    };
    return ClickLinkOptions;
}());
function createOptions(multiCursorModifier) {
    if (multiCursorModifier === 'altKey') {
        if (isMacintosh) {
            return new ClickLinkOptions(57 /* Meta */, 'metaKey', 6 /* Alt */, 'altKey');
        }
        return new ClickLinkOptions(5 /* Ctrl */, 'ctrlKey', 6 /* Alt */, 'altKey');
    }
    if (isMacintosh) {
        return new ClickLinkOptions(6 /* Alt */, 'altKey', 57 /* Meta */, 'metaKey');
    }
    return new ClickLinkOptions(6 /* Alt */, 'altKey', 5 /* Ctrl */, 'ctrlKey');
}
var ClickLinkGesture = /** @class */ (function (_super) {
    __extends$n(ClickLinkGesture, _super);
    function ClickLinkGesture(editor) {
        var _this = _super.call(this) || this;
        _this._onMouseMoveOrRelevantKeyDown = _this._register(new Emitter());
        _this.onMouseMoveOrRelevantKeyDown = _this._onMouseMoveOrRelevantKeyDown.event;
        _this._onExecute = _this._register(new Emitter());
        _this.onExecute = _this._onExecute.event;
        _this._onCancel = _this._register(new Emitter());
        _this.onCancel = _this._onCancel.event;
        _this._editor = editor;
        _this._opts = createOptions(_this._editor.getConfiguration().multiCursorModifier);
        _this.lastMouseMoveEvent = null;
        _this.hasTriggerKeyOnMouseDown = false;
        _this._register(_this._editor.onDidChangeConfiguration(function (e) {
            if (e.multiCursorModifier) {
                var newOpts = createOptions(_this._editor.getConfiguration().multiCursorModifier);
                if (_this._opts.equals(newOpts)) {
                    return;
                }
                _this._opts = newOpts;
                _this.lastMouseMoveEvent = null;
                _this.hasTriggerKeyOnMouseDown = false;
                _this._onCancel.fire();
            }
        }));
        _this._register(_this._editor.onMouseMove(function (e) { return _this.onEditorMouseMove(new ClickLinkMouseEvent(e, _this._opts)); }));
        _this._register(_this._editor.onMouseDown(function (e) { return _this.onEditorMouseDown(new ClickLinkMouseEvent(e, _this._opts)); }));
        _this._register(_this._editor.onMouseUp(function (e) { return _this.onEditorMouseUp(new ClickLinkMouseEvent(e, _this._opts)); }));
        _this._register(_this._editor.onKeyDown(function (e) { return _this.onEditorKeyDown(new ClickLinkKeyboardEvent(e, _this._opts)); }));
        _this._register(_this._editor.onKeyUp(function (e) { return _this.onEditorKeyUp(new ClickLinkKeyboardEvent(e, _this._opts)); }));
        _this._register(_this._editor.onMouseDrag(function () { return _this.resetHandler(); }));
        _this._register(_this._editor.onDidChangeCursorSelection(function (e) { return _this.onDidChangeCursorSelection(e); }));
        _this._register(_this._editor.onDidChangeModel(function (e) { return _this.resetHandler(); }));
        _this._register(_this._editor.onDidChangeModelContent(function () { return _this.resetHandler(); }));
        _this._register(_this._editor.onDidScrollChange(function (e) {
            if (e.scrollTopChanged || e.scrollLeftChanged) {
                _this.resetHandler();
            }
        }));
        return _this;
    }
    ClickLinkGesture.prototype.onDidChangeCursorSelection = function (e) {
        if (e.selection && e.selection.startColumn !== e.selection.endColumn) {
            this.resetHandler(); // immediately stop this feature if the user starts to select (https://github.com/Microsoft/vscode/issues/7827)
        }
    };
    ClickLinkGesture.prototype.onEditorMouseMove = function (mouseEvent) {
        this.lastMouseMoveEvent = mouseEvent;
        this._onMouseMoveOrRelevantKeyDown.fire([mouseEvent, null]);
    };
    ClickLinkGesture.prototype.onEditorMouseDown = function (mouseEvent) {
        // We need to record if we had the trigger key on mouse down because someone might select something in the editor
        // holding the mouse down and then while mouse is down start to press Ctrl/Cmd to start a copy operation and then
        // release the mouse button without wanting to do the navigation.
        // With this flag we prevent goto definition if the mouse was down before the trigger key was pressed.
        this.hasTriggerKeyOnMouseDown = mouseEvent.hasTriggerModifier;
    };
    ClickLinkGesture.prototype.onEditorMouseUp = function (mouseEvent) {
        if (this.hasTriggerKeyOnMouseDown) {
            this._onExecute.fire(mouseEvent);
        }
    };
    ClickLinkGesture.prototype.onEditorKeyDown = function (e) {
        if (this.lastMouseMoveEvent
            && (e.keyCodeIsTriggerKey // User just pressed Ctrl/Cmd (normal goto definition)
                || (e.keyCodeIsSideBySideKey && e.hasTriggerModifier) // User pressed Ctrl/Cmd+Alt (goto definition to the side)
            )) {
            this._onMouseMoveOrRelevantKeyDown.fire([this.lastMouseMoveEvent, e]);
        }
        else if (e.hasTriggerModifier) {
            this._onCancel.fire(); // remove decorations if user holds another key with ctrl/cmd to prevent accident goto declaration
        }
    };
    ClickLinkGesture.prototype.onEditorKeyUp = function (e) {
        if (e.keyCodeIsTriggerKey) {
            this._onCancel.fire();
        }
    };
    ClickLinkGesture.prototype.resetHandler = function () {
        this.lastMouseMoveEvent = null;
        this.hasTriggerKeyOnMouseDown = false;
        this._onCancel.fire();
    };
    return ClickLinkGesture;
}(Disposable));

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __decorate$9 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$9 = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var GotoDefinitionWithMouseEditorContribution = /** @class */ (function () {
    function GotoDefinitionWithMouseEditorContribution(editor, textModelResolverService, modeService) {
        var _this = this;
        this.textModelResolverService = textModelResolverService;
        this.modeService = modeService;
        this.toUnhook = [];
        this.decorations = [];
        this.editor = editor;
        this.throttler = new Throttler();
        var linkGesture = new ClickLinkGesture(editor);
        this.toUnhook.push(linkGesture);
        this.toUnhook.push(linkGesture.onMouseMoveOrRelevantKeyDown(function (_a) {
            var mouseEvent = _a[0], keyboardEvent = _a[1];
            _this.startFindDefinition(mouseEvent, keyboardEvent);
        }));
        this.toUnhook.push(linkGesture.onExecute(function (mouseEvent) {
            if (_this.isEnabled(mouseEvent)) {
                _this.gotoDefinition(mouseEvent.target, mouseEvent.hasSideBySideModifier).done(function () {
                    _this.removeDecorations();
                }, function (error) {
                    _this.removeDecorations();
                    onUnexpectedError(error);
                });
            }
        }));
        this.toUnhook.push(linkGesture.onCancel(function () {
            _this.removeDecorations();
            _this.currentWordUnderMouse = null;
        }));
    }
    GotoDefinitionWithMouseEditorContribution.prototype.startFindDefinition = function (mouseEvent, withKey) {
        var _this = this;
        if (!this.isEnabled(mouseEvent, withKey)) {
            this.currentWordUnderMouse = null;
            this.removeDecorations();
            return;
        }
        // Find word at mouse position
        var position = mouseEvent.target.position;
        var word = position ? this.editor.getModel().getWordAtPosition(position) : null;
        if (!word) {
            this.currentWordUnderMouse = null;
            this.removeDecorations();
            return;
        }
        // Return early if word at position is still the same
        if (this.currentWordUnderMouse && this.currentWordUnderMouse.startColumn === word.startColumn && this.currentWordUnderMouse.endColumn === word.endColumn && this.currentWordUnderMouse.word === word.word) {
            return;
        }
        this.currentWordUnderMouse = word;
        // Find definition and decorate word if found
        var state = new EditorState(this.editor, 4 /* Position */ | 1 /* Value */ | 2 /* Selection */ | 8 /* Scroll */);
        this.throttler.queue(function () {
            return state.validate(_this.editor)
                ? _this.findDefinition(mouseEvent.target)
                : TPromise.wrap(null);
        }).then(function (results) {
            if (!results || !results.length || !state.validate(_this.editor)) {
                _this.removeDecorations();
                return;
            }
            // Multiple results
            if (results.length > 1) {
                _this.addDecoration(new Range(position.lineNumber, word.startColumn, position.lineNumber, word.endColumn), new MarkdownString().appendText(localize('multipleResults', "Click to show {0} definitions.", results.length)));
            }
            // Single result
            else {
                var result_1 = results[0];
                if (!result_1.uri) {
                    return;
                }
                _this.textModelResolverService.createModelReference(result_1.uri).then(function (ref) {
                    if (!ref.object || !ref.object.textEditorModel) {
                        ref.dispose();
                        return;
                    }
                    var textEditorModel = ref.object.textEditorModel;
                    var startLineNumber = result_1.range.startLineNumber;
                    if (textEditorModel.getLineMaxColumn(startLineNumber) === 0) {
                        ref.dispose();
                        return;
                    }
                    var startIndent = textEditorModel.getLineFirstNonWhitespaceColumn(startLineNumber);
                    var maxLineNumber = Math.min(textEditorModel.getLineCount(), startLineNumber + GotoDefinitionWithMouseEditorContribution.MAX_SOURCE_PREVIEW_LINES);
                    var endLineNumber = startLineNumber + 1;
                    var minIndent = startIndent;
                    for (; endLineNumber < maxLineNumber; endLineNumber++) {
                        var endIndent = textEditorModel.getLineFirstNonWhitespaceColumn(endLineNumber);
                        minIndent = Math.min(minIndent, endIndent);
                        if (startIndent === endIndent) {
                            break;
                        }
                    }
                    var previewRange = new Range(startLineNumber, 1, endLineNumber + 1, 1);
                    var value = textEditorModel.getValueInRange(previewRange).replace(new RegExp("^\\s{" + (minIndent - 1) + "}", 'gm'), '').trim();
                    _this.addDecoration(new Range(position.lineNumber, word.startColumn, position.lineNumber, word.endColumn), new MarkdownString().appendCodeblock(_this.modeService.getModeIdByFilenameOrFirstLine(textEditorModel.uri.fsPath), value));
                    ref.dispose();
                });
            }
        }).done(undefined, onUnexpectedError);
    };
    GotoDefinitionWithMouseEditorContribution.prototype.addDecoration = function (range$$1, hoverMessage) {
        var newDecorations = {
            range: range$$1,
            options: {
                inlineClassName: 'goto-definition-link',
                hoverMessage: hoverMessage
            }
        };
        this.decorations = this.editor.deltaDecorations(this.decorations, [newDecorations]);
    };
    GotoDefinitionWithMouseEditorContribution.prototype.removeDecorations = function () {
        if (this.decorations.length > 0) {
            this.decorations = this.editor.deltaDecorations(this.decorations, []);
        }
    };
    GotoDefinitionWithMouseEditorContribution.prototype.isEnabled = function (mouseEvent, withKey) {
        return this.editor.getModel() &&
            mouseEvent.isNoneOrSingleMouseDown &&
            mouseEvent.target.type === MouseTargetType.CONTENT_TEXT &&
            (mouseEvent.hasTriggerModifier || (withKey && withKey.keyCodeIsTriggerKey)) &&
            DefinitionProviderRegistry.has(this.editor.getModel());
    };
    GotoDefinitionWithMouseEditorContribution.prototype.findDefinition = function (target) {
        var model = this.editor.getModel();
        if (!model) {
            return TPromise.as(null);
        }
        return getDefinitionsAtPosition(this.editor.getModel(), target.position);
    };
    GotoDefinitionWithMouseEditorContribution.prototype.gotoDefinition = function (target, sideBySide) {
        var _this = this;
        this.editor.setPosition(target.position);
        var action = new DefinitionAction(new DefinitionActionConfig(sideBySide, false, true, false), { alias: undefined, label: undefined, id: undefined, precondition: undefined });
        return this.editor.invokeWithinContext(function (accessor) { return action.run(accessor, _this.editor); });
    };
    GotoDefinitionWithMouseEditorContribution.prototype.getId = function () {
        return GotoDefinitionWithMouseEditorContribution.ID;
    };
    GotoDefinitionWithMouseEditorContribution.prototype.dispose = function () {
        this.toUnhook = dispose(this.toUnhook);
    };
    GotoDefinitionWithMouseEditorContribution.ID = 'editor.contrib.gotodefinitionwithmouse';
    GotoDefinitionWithMouseEditorContribution.MAX_SOURCE_PREVIEW_LINES = 8;
    GotoDefinitionWithMouseEditorContribution = __decorate$9([
        __param$9(1, ITextModelService),
        __param$9(2, IModeService)
    ], GotoDefinitionWithMouseEditorContribution);
    return GotoDefinitionWithMouseEditorContribution;
}());
registerEditorContribution(GotoDefinitionWithMouseEditorContribution);
registerThemingParticipant(function (theme, collector) {
    var activeLinkForeground = theme.getColor(editorActiveLinkForeground);
    if (activeLinkForeground) {
        collector.addRule(".monaco-editor .goto-definition-link { color: " + activeLinkForeground + " !important; }");
    }
});

const css$h = "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n/* marker zone */\n\n.monaco-editor .marker-widget {\n\tpadding-left: 2px;\n\ttext-overflow: ellipsis;\n\twhite-space: nowrap;\n}\n\n.monaco-editor .marker-widget > .stale {\n\topacity: 0.6;\n\tfont-style: italic;\n}\n\n.monaco-editor .marker-widget div.block {\n\tdisplay: inline-block;\n\tvertical-align: top;\n}\n\n.monaco-editor .marker-widget .title {\n\tdisplay: inline-block;\n\tpadding-right: 5px;\n}\n\n.monaco-editor .marker-widget .descriptioncontainer {\n\tposition: relative;\n\twhite-space: pre;\n\t-webkit-user-select: text;\n\tuser-select: text;\n}\n\n.monaco-editor .marker-widget .descriptioncontainer .filename {\n\tcursor: pointer;\n\topacity: 0.6;\n}\n";
  const element$h = ((css, src) => {
if (typeof document !== 'object')
console.info(`Skipped loading "${src}"`);
try {
const id = src
  .replace(/\.css.*$/, '')
  .replace(/[\\:]/g, '/')
  .replace(/[^\w\/]+/g, '');
return (
  document.querySelector(`style[id="${id}"]`) ||
  document.head.appendChild(
    Object.assign(document.createElement('style'), {
      id,
      textContent: `${css}\n\n /* sourceURL=${src} */`,
    }),
  )
);
} catch (exception) {
console.warn(`Failed load "${src}"`, exception);
}
})(css$h, "…monaco-editor/esm/vs/editor/contrib/gotoError/gotoErrorWidget.css");
  //@ sourceURL=/Users/daflair/Projects/packages/monaco-es/node_modules/monaco-editor/esm/vs/editor/contrib/gotoError/gotoErrorWidget.css

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$o = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var MessageWidget$1 = /** @class */ (function () {
    function MessageWidget(parent, editor, onRelatedInformation) {
        var _this = this;
        this.lines = 0;
        this.longestLineLength = 0;
        this._relatedDiagnostics = new WeakMap();
        this._disposables = [];
        this._editor = editor;
        var domNode = document.createElement('div');
        domNode.className = 'descriptioncontainer';
        domNode.setAttribute('aria-live', 'assertive');
        domNode.setAttribute('role', 'alert');
        this._messageBlock = document.createElement('span');
        domNode.appendChild(this._messageBlock);
        this._relatedBlock = document.createElement('div');
        domNode.appendChild(this._relatedBlock);
        this._disposables.push(addStandardDisposableListener(this._relatedBlock, 'click', function (event) {
            event.preventDefault();
            var related = _this._relatedDiagnostics.get(event.target);
            if (related) {
                onRelatedInformation(related);
            }
        }));
        this._scrollable = new ScrollableElement(domNode, {
            horizontal: ScrollbarVisibility.Auto,
            vertical: ScrollbarVisibility.Hidden,
            useShadows: false,
            horizontalScrollbarSize: 3
        });
        addClass(this._scrollable.getDomNode(), 'block');
        parent.appendChild(this._scrollable.getDomNode());
        this._disposables.push(this._scrollable.onScroll(function (e) { return domNode.style.left = "-" + e.scrollLeft + "px"; }));
        this._disposables.push(this._scrollable);
    }
    MessageWidget.prototype.dispose = function () {
        dispose(this._disposables);
    };
    MessageWidget.prototype.update = function (_a) {
        var source = _a.source, message = _a.message, relatedInformation = _a.relatedInformation;
        if (source) {
            this.lines = 0;
            this.longestLineLength = 0;
            var indent = new Array(source.length + 3 + 1).join(' ');
            var lines = message.split(/\r\n|\r|\n/g);
            for (var i = 0; i < lines.length; i++) {
                var line = lines[i];
                this.lines += 1;
                this.longestLineLength = Math.max(line.length, this.longestLineLength);
                if (i === 0) {
                    message = "[" + source + "] " + line;
                }
                else {
                    message += "\n" + indent + line;
                }
            }
        }
        else {
            this.lines = 1;
            this.longestLineLength = message.length;
        }
        clearNode(this._relatedBlock);
        if (!isFalsyOrEmpty(relatedInformation)) {
            this._relatedBlock.style.paddingTop = Math.floor(this._editor.getConfiguration().lineHeight * .66) + "px";
            this.lines += 1;
            for (var _i = 0, relatedInformation_1 = relatedInformation; _i < relatedInformation_1.length; _i++) {
                var related = relatedInformation_1[_i];
                var container = document.createElement('div');
                var relatedResource = document.createElement('span');
                addClass(relatedResource, 'filename');
                relatedResource.innerHTML = getBaseLabel(related.resource) + "(" + related.startLineNumber + ", " + related.startColumn + "): ";
                relatedResource.title = getPathLabel(related.resource);
                this._relatedDiagnostics.set(relatedResource, related);
                var relatedMessage = document.createElement('span');
                relatedMessage.innerText = related.message;
                this._editor.applyFontInfo(relatedMessage);
                container.appendChild(relatedResource);
                container.appendChild(relatedMessage);
                this.lines += 1;
                this._relatedBlock.appendChild(container);
            }
        }
        this._messageBlock.innerText = message;
        this._editor.applyFontInfo(this._messageBlock);
        var width = Math.floor(this._editor.getConfiguration().fontInfo.typicalFullwidthCharacterWidth * this.longestLineLength);
        this._scrollable.setScrollDimensions({ scrollWidth: width });
    };
    MessageWidget.prototype.layout = function (height, width) {
        this._scrollable.setScrollDimensions({ width: width });
    };
    return MessageWidget;
}());
var MarkerNavigationWidget = /** @class */ (function (_super) {
    __extends$o(MarkerNavigationWidget, _super);
    function MarkerNavigationWidget(editor, _themeService) {
        var _this = _super.call(this, editor, { showArrow: true, showFrame: true, isAccessible: true }) || this;
        _this._themeService = _themeService;
        _this._callOnDispose = [];
        _this._onDidSelectRelatedInformation = new Emitter();
        _this.onDidSelectRelatedInformation = _this._onDidSelectRelatedInformation.event;
        _this._severity = MarkerSeverity.Warning;
        _this._backgroundColor = Color.white;
        _this._applyTheme(_themeService.getTheme());
        _this._callOnDispose.push(_themeService.onThemeChange(_this._applyTheme.bind(_this)));
        _this.create();
        return _this;
    }
    MarkerNavigationWidget.prototype._applyTheme = function (theme) {
        this._backgroundColor = theme.getColor(editorMarkerNavigationBackground);
        var colorId = editorMarkerNavigationError;
        if (this._severity === MarkerSeverity.Warning) {
            colorId = editorMarkerNavigationWarning;
        }
        else if (this._severity === MarkerSeverity.Info) {
            colorId = editorMarkerNavigationInfo;
        }
        var frameColor = theme.getColor(colorId);
        this.style({
            arrowColor: frameColor,
            frameColor: frameColor
        }); // style() will trigger _applyStyles
    };
    MarkerNavigationWidget.prototype._applyStyles = function () {
        if (this._parentContainer) {
            this._parentContainer.style.backgroundColor = this._backgroundColor.toString();
        }
        _super.prototype._applyStyles.call(this);
    };
    MarkerNavigationWidget.prototype.dispose = function () {
        this._callOnDispose = dispose(this._callOnDispose);
        _super.prototype.dispose.call(this);
    };
    MarkerNavigationWidget.prototype.focus = function () {
        this._parentContainer.focus();
    };
    MarkerNavigationWidget.prototype._fillContainer = function (container) {
        var _this = this;
        this._parentContainer = container;
        addClass(container, 'marker-widget');
        this._parentContainer.tabIndex = 0;
        this._parentContainer.setAttribute('role', 'tooltip');
        this._container = document.createElement('div');
        container.appendChild(this._container);
        this._title = document.createElement('div');
        this._title.className = 'block title';
        this._container.appendChild(this._title);
        this._message = new MessageWidget$1(this._container, this.editor, function (related) { return _this._onDidSelectRelatedInformation.fire(related); });
        this._disposables.push(this._message);
    };
    MarkerNavigationWidget.prototype.show = function (where, heightInLines) {
        throw new Error('call showAtMarker');
    };
    MarkerNavigationWidget.prototype.showAtMarker = function (marker, markerIdx, markerCount) {
        // update:
        // * title
        // * message
        this._container.classList.remove('stale');
        this._title.innerHTML = localize('title.wo_source', "({0}/{1})", markerIdx, markerCount);
        this._message.update(marker);
        // update frame color (only applied on 'show')
        this._severity = marker.severity;
        this._applyTheme(this._themeService.getTheme());
        // show
        var range$$1 = Range.lift(marker);
        var position = range$$1.containsPosition(this.editor.getPosition()) ? this.editor.getPosition() : range$$1.getStartPosition();
        _super.prototype.show.call(this, position, this.computeRequiredHeight());
        this.editor.revealPositionInCenter(position, 0 /* Smooth */);
        if (this.editor.getConfiguration().accessibilitySupport !== 1 /* Disabled */) {
            this.focus();
        }
    };
    MarkerNavigationWidget.prototype.updateMarker = function (marker) {
        this._container.classList.remove('stale');
        this._message.update(marker);
    };
    MarkerNavigationWidget.prototype.showStale = function () {
        this._container.classList.add('stale');
        this._relayout();
    };
    MarkerNavigationWidget.prototype._doLayout = function (heightInPixel, widthInPixel) {
        this._message.layout(heightInPixel, widthInPixel);
        this._container.style.height = heightInPixel + "px";
    };
    MarkerNavigationWidget.prototype._relayout = function () {
        _super.prototype._relayout.call(this, this.computeRequiredHeight());
    };
    MarkerNavigationWidget.prototype.computeRequiredHeight = function () {
        return 1 + this._message.lines;
    };
    return MarkerNavigationWidget;
}(ZoneWidget));
// theming
var errorDefault = oneOf(editorErrorForeground, editorErrorBorder);
var warningDefault = oneOf(editorWarningForeground, editorWarningBorder);
var infoDefault = oneOf(editorInfoForeground, editorInfoBorder);
var editorMarkerNavigationError = registerColor('editorMarkerNavigationError.background', { dark: errorDefault, light: errorDefault, hc: errorDefault }, localize('editorMarkerNavigationError', 'Editor marker navigation widget error color.'));
var editorMarkerNavigationWarning = registerColor('editorMarkerNavigationWarning.background', { dark: warningDefault, light: warningDefault, hc: warningDefault }, localize('editorMarkerNavigationWarning', 'Editor marker navigation widget warning color.'));
var editorMarkerNavigationInfo = registerColor('editorMarkerNavigationInfo.background', { dark: infoDefault, light: infoDefault, hc: infoDefault }, localize('editorMarkerNavigationInfo', 'Editor marker navigation widget info color.'));
var editorMarkerNavigationBackground = registerColor('editorMarkerNavigation.background', { dark: '#2D2D30', light: Color.white, hc: '#0C141F' }, localize('editorMarkerNavigationBackground', 'Editor marker navigation widget background.'));

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$p = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate$a = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$a = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var MarkerModel = /** @class */ (function () {
    function MarkerModel(editor, markers) {
        var _this = this;
        this._editor = editor;
        this._markers = null;
        this._nextIdx = -1;
        this._toUnbind = [];
        this._ignoreSelectionChange = false;
        this._onCurrentMarkerChanged = new Emitter();
        this._onMarkerSetChanged = new Emitter();
        this.setMarkers(markers);
        // listen on editor
        this._toUnbind.push(this._editor.onDidDispose(function () { return _this.dispose(); }));
        this._toUnbind.push(this._editor.onDidChangeCursorPosition(function () {
            if (_this._ignoreSelectionChange) {
                return;
            }
            if (_this.currentMarker && Range.containsPosition(_this.currentMarker, _this._editor.getPosition())) {
                return;
            }
            _this._nextIdx = -1;
        }));
    }
    Object.defineProperty(MarkerModel.prototype, "onCurrentMarkerChanged", {
        get: function () {
            return this._onCurrentMarkerChanged.event;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MarkerModel.prototype, "onMarkerSetChanged", {
        get: function () {
            return this._onMarkerSetChanged.event;
        },
        enumerable: true,
        configurable: true
    });
    MarkerModel.prototype.setMarkers = function (markers) {
        var oldMarker = this._nextIdx >= 0 ? this._markers[this._nextIdx] : undefined;
        this._markers = markers || [];
        this._markers.sort(MarkerNavigationAction.compareMarker);
        if (!oldMarker) {
            this._nextIdx = -1;
        }
        else {
            this._nextIdx = Math.max(-1, binarySearch(this._markers, oldMarker, MarkerNavigationAction.compareMarker));
        }
        this._onMarkerSetChanged.fire(this);
    };
    MarkerModel.prototype.withoutWatchingEditorPosition = function (callback) {
        this._ignoreSelectionChange = true;
        try {
            callback();
        }
        finally {
            this._ignoreSelectionChange = false;
        }
    };
    MarkerModel.prototype._initIdx = function (fwd) {
        var found = false;
        var position = this._editor.getPosition();
        for (var i = 0; i < this._markers.length; i++) {
            var range$$1 = Range.lift(this._markers[i]);
            if (range$$1.isEmpty()) {
                var word = this._editor.getModel().getWordAtPosition(range$$1.getStartPosition());
                if (word) {
                    range$$1 = new Range(range$$1.startLineNumber, word.startColumn, range$$1.startLineNumber, word.endColumn);
                }
            }
            if (range$$1.containsPosition(position) || position.isBeforeOrEqual(range$$1.getStartPosition())) {
                this._nextIdx = i;
                found = true;
                break;
            }
        }
        if (!found) {
            // after the last change
            this._nextIdx = fwd ? 0 : this._markers.length - 1;
        }
        if (this._nextIdx < 0) {
            this._nextIdx = this._markers.length - 1;
        }
    };
    Object.defineProperty(MarkerModel.prototype, "currentMarker", {
        get: function () {
            return this.canNavigate() ? this._markers[this._nextIdx] : undefined;
        },
        enumerable: true,
        configurable: true
    });
    MarkerModel.prototype.move = function (fwd, inCircles) {
        if (!this.canNavigate()) {
            this._onCurrentMarkerChanged.fire(undefined);
            return !inCircles;
        }
        var oldIdx = this._nextIdx;
        var atEdge = false;
        if (this._nextIdx === -1) {
            this._initIdx(fwd);
        }
        else if (fwd) {
            if (inCircles || this._nextIdx + 1 < this._markers.length) {
                this._nextIdx = (this._nextIdx + 1) % this._markers.length;
            }
            else {
                atEdge = true;
            }
        }
        else if (!fwd) {
            if (inCircles || this._nextIdx > 0) {
                this._nextIdx = (this._nextIdx - 1 + this._markers.length) % this._markers.length;
            }
            else {
                atEdge = true;
            }
        }
        if (oldIdx !== this._nextIdx) {
            var marker = this._markers[this._nextIdx];
            this._onCurrentMarkerChanged.fire(marker);
        }
        return atEdge;
    };
    MarkerModel.prototype.canNavigate = function () {
        return this._markers.length > 0;
    };
    MarkerModel.prototype.findMarkerAtPosition = function (pos) {
        for (var _i = 0, _a = this._markers; _i < _a.length; _i++) {
            var marker = _a[_i];
            if (Range.containsPosition(marker, pos)) {
                return marker;
            }
        }
        return undefined;
    };
    Object.defineProperty(MarkerModel.prototype, "total", {
        get: function () {
            return this._markers.length;
        },
        enumerable: true,
        configurable: true
    });
    MarkerModel.prototype.indexOf = function (marker) {
        return 1 + this._markers.indexOf(marker);
    };
    MarkerModel.prototype.dispose = function () {
        this._toUnbind = dispose(this._toUnbind);
    };
    return MarkerModel;
}());
var MarkerController = /** @class */ (function () {
    function MarkerController(editor, _markerService, _contextKeyService, _themeService, _editorService) {
        this._markerService = _markerService;
        this._contextKeyService = _contextKeyService;
        this._themeService = _themeService;
        this._editorService = _editorService;
        this._disposeOnClose = [];
        this._editor = editor;
        this._widgetVisible = CONTEXT_MARKERS_NAVIGATION_VISIBLE.bindTo(this._contextKeyService);
    }
    MarkerController.get = function (editor) {
        return editor.getContribution(MarkerController.ID);
    };
    MarkerController.prototype.getId = function () {
        return MarkerController.ID;
    };
    MarkerController.prototype.dispose = function () {
        this._cleanUp();
    };
    MarkerController.prototype._cleanUp = function () {
        this._widgetVisible.reset();
        this._disposeOnClose = dispose(this._disposeOnClose);
        this._widget = null;
        this._model = null;
    };
    MarkerController.prototype.getOrCreateModel = function () {
        var _this = this;
        if (this._model) {
            return this._model;
        }
        var markers = this._getMarkers();
        this._model = new MarkerModel(this._editor, markers);
        this._markerService.onMarkerChanged(this._onMarkerChanged, this, this._disposeOnClose);
        this._widget = new MarkerNavigationWidget(this._editor, this._themeService);
        this._widgetVisible.set(true);
        this._disposeOnClose.push(this._model);
        this._disposeOnClose.push(this._widget);
        this._disposeOnClose.push(this._widget.onDidSelectRelatedInformation(function (related) {
            _this._editorService.openEditor({
                resource: related.resource,
                options: { pinned: true, revealIfOpened: true, selection: Range.lift(related).collapseToStart() }
            }).then(undefined, onUnexpectedError);
            _this.closeMarkersNavigation(false);
        }));
        this._disposeOnClose.push(this._editor.onDidChangeModel(function () { return _this._cleanUp(); }));
        this._disposeOnClose.push(this._model.onCurrentMarkerChanged(function (marker) {
            if (!marker) {
                _this._cleanUp();
            }
            else {
                _this._model.withoutWatchingEditorPosition(function () {
                    _this._widget.showAtMarker(marker, _this._model.indexOf(marker), _this._model.total);
                });
            }
        }));
        this._disposeOnClose.push(this._model.onMarkerSetChanged(function () {
            var marker = _this._model.findMarkerAtPosition(_this._widget.position);
            if (marker) {
                _this._widget.updateMarker(marker);
            }
            else {
                _this._widget.showStale();
            }
        }));
        return this._model;
    };
    MarkerController.prototype.closeMarkersNavigation = function (focusEditor) {
        if (focusEditor === void 0) { focusEditor = true; }
        this._cleanUp();
        if (focusEditor) {
            this._editor.focus();
        }
    };
    MarkerController.prototype._onMarkerChanged = function (changedResources) {
        var _this = this;
        if (!changedResources.some(function (r) { return _this._editor.getModel().uri.toString() === r.toString(); })) {
            return;
        }
        this._model.setMarkers(this._getMarkers());
    };
    MarkerController.prototype._getMarkers = function () {
        return this._markerService.read({
            resource: this._editor.getModel().uri,
            severities: MarkerSeverity.Error | MarkerSeverity.Warning | MarkerSeverity.Info
        });
    };
    MarkerController.ID = 'editor.contrib.markerController';
    MarkerController = __decorate$a([
        __param$a(1, IMarkerService),
        __param$a(2, IContextKeyService),
        __param$a(3, IThemeService),
        __param$a(4, IEditorService)
    ], MarkerController);
    return MarkerController;
}());
var MarkerNavigationAction = /** @class */ (function (_super) {
    __extends$p(MarkerNavigationAction, _super);
    function MarkerNavigationAction(next, opts) {
        var _this = _super.call(this, opts) || this;
        _this._isNext = next;
        return _this;
    }
    MarkerNavigationAction.prototype.run = function (accessor, editor) {
        var _this = this;
        var markerService = accessor.get(IMarkerService);
        var editorService = accessor.get(IEditorService);
        var controller = MarkerController.get(editor);
        if (!controller) {
            return undefined;
        }
        var model = controller.getOrCreateModel();
        var atEdge = model.move(this._isNext, false);
        if (!atEdge) {
            return undefined;
        }
        // try with the next/prev file
        var markers = markerService.read({ severities: MarkerSeverity.Error | MarkerSeverity.Warning | MarkerSeverity.Info }).sort(MarkerNavigationAction.compareMarker);
        if (markers.length === 0) {
            return undefined;
        }
        var oldMarker = model.currentMarker || { resource: editor.getModel().uri, severity: MarkerSeverity.Error, startLineNumber: 1, startColumn: 1, endLineNumber: 1, endColumn: 1 };
        var idx = binarySearch(markers, oldMarker, MarkerNavigationAction.compareMarker);
        if (idx < 0) {
            // find best match...
            idx = ~idx;
            idx %= markers.length;
        }
        else if (this._isNext) {
            idx = (idx + 1) % markers.length;
        }
        else {
            idx = (idx + markers.length - 1) % markers.length;
        }
        var newMarker = markers[idx];
        if (newMarker.resource.toString() === editor.getModel().uri.toString()) {
            // the next `resource` is this resource which
            // means we cycle within this file
            model.move(this._isNext, true);
            return undefined;
        }
        // close the widget for this editor-instance, open the resource
        // for the next marker and re-start marker navigation in there
        controller.closeMarkersNavigation();
        return editorService.openEditor({
            resource: newMarker.resource,
            options: { pinned: false, revealIfOpened: true, revealInCenterIfOutsideViewport: true, selection: newMarker }
        }).then(function (editor) {
            if (!editor || !isCodeEditor(editor.getControl())) {
                return undefined;
            }
            return editor.getControl().getAction(_this.id).run();
        });
    };
    MarkerNavigationAction.compareMarker = function (a, b) {
        var res = compare(a.resource.toString(), b.resource.toString());
        if (res === 0) {
            res = MarkerSeverity.compare(a.severity, b.severity);
        }
        if (res === 0) {
            res = Range.compareRangesUsingStarts(a, b);
        }
        return res;
    };
    return MarkerNavigationAction;
}(EditorAction));
var NextMarkerAction = /** @class */ (function (_super) {
    __extends$p(NextMarkerAction, _super);
    function NextMarkerAction() {
        return _super.call(this, true, {
            id: 'editor.action.marker.next',
            label: localize('markerAction.next.label', "Go to Next Problem (Error, Warning, Info)"),
            alias: 'Go to Next Error or Warning',
            precondition: EditorContextKeys.writable,
            kbOpts: {
                kbExpr: EditorContextKeys.focus,
                primary: 66 /* F8 */
            }
        }) || this;
    }
    return NextMarkerAction;
}(MarkerNavigationAction));
var PrevMarkerAction = /** @class */ (function (_super) {
    __extends$p(PrevMarkerAction, _super);
    function PrevMarkerAction() {
        return _super.call(this, false, {
            id: 'editor.action.marker.prev',
            label: localize('markerAction.previous.label', "Go to Previous Problem (Error, Warning, Info)"),
            alias: 'Go to Previous Error or Warning',
            precondition: EditorContextKeys.writable,
            kbOpts: {
                kbExpr: EditorContextKeys.focus,
                primary: 1024 /* Shift */ | 66 /* F8 */
            }
        }) || this;
    }
    return PrevMarkerAction;
}(MarkerNavigationAction));
registerEditorContribution(MarkerController);
registerEditorAction(NextMarkerAction);
registerEditorAction(PrevMarkerAction);
var CONTEXT_MARKERS_NAVIGATION_VISIBLE = new RawContextKey('markersNavigationVisible', false);
var MarkerCommand = EditorCommand.bindToContribution(MarkerController.get);
registerEditorCommand(new MarkerCommand({
    id: 'closeMarkersNavigation',
    precondition: CONTEXT_MARKERS_NAVIGATION_VISIBLE,
    handler: function (x) { return x.closeMarkersNavigation(); },
    kbOpts: {
        weight: KeybindingsRegistry.WEIGHT.editorContrib(50),
        kbExpr: EditorContextKeys.focus,
        primary: 9 /* Escape */,
        secondary: [1024 /* Shift */ | 9 /* Escape */]
    }
}));

const css$i = "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n.monaco-editor-hover {\n\tcursor: default;\n\tposition: absolute;\n\toverflow: hidden;\n\tz-index: 50;\n\t-webkit-user-select: text;\n\t-ms-user-select: text;\n\t-khtml-user-select: text;\n\t-moz-user-select: text;\n\t-o-user-select: text;\n\tuser-select: text;\n\tbox-sizing: initial;\n\tanimation: fadein 100ms linear;\n\tline-height: 1.5em;\n}\n\n.monaco-editor-hover.hidden {\n\tdisplay: none;\n}\n\n.monaco-editor-hover .monaco-editor-hover-content {\n\tmax-width: 500px;\n}\n\n.monaco-editor-hover .hover-row {\n\tpadding: 4px 5px;\n}\n\n.monaco-editor-hover p,\n.monaco-editor-hover ul {\n\tmargin: 8px 0;\n}\n\n.monaco-editor-hover p:first-child,\n.monaco-editor-hover ul:first-child {\n\tmargin-top: 0;\n}\n\n.monaco-editor-hover p:last-child,\n.monaco-editor-hover ul:last-child {\n\tmargin-bottom: 0;\n}\n\n.monaco-editor-hover ul {\n\tpadding-left: 20px;\n}\n\n.monaco-editor-hover li > p {\n\tmargin-bottom: 0;\n}\n\n.monaco-editor-hover li > ul {\n\tmargin-top: 0;\n}\n\n.monaco-editor-hover code {\n\tborder-radius: 3px;\n\tpadding: 0 0.4em;\n}\n\n.monaco-editor-hover .monaco-tokenized-source {\n\twhite-space: pre-wrap;\n\tword-break: break-all;\n}\n";
  const element$i = ((css, src) => {
if (typeof document !== 'object')
console.info(`Skipped loading "${src}"`);
try {
const id = src
  .replace(/\.css.*$/, '')
  .replace(/[\\:]/g, '/')
  .replace(/[^\w\/]+/g, '');
return (
  document.querySelector(`style[id="${id}"]`) ||
  document.head.appendChild(
    Object.assign(document.createElement('style'), {
      id,
      textContent: `${css}\n\n /* sourceURL=${src} */`,
    }),
  )
);
} catch (exception) {
console.warn(`Failed load "${src}"`, exception);
}
})(css$i, "…monaco-editor/esm/vs/editor/contrib/hover/hover.css");
  //@ sourceURL=/Users/daflair/Projects/packages/monaco-es/node_modules/monaco-editor/esm/vs/editor/contrib/hover/hover.css

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
function getHover(model, position) {
    var supports = HoverProviderRegistry.ordered(model);
    var values = [];
    var promises = supports.map(function (support, idx) {
        return asWinJsPromise(function (token) {
            return support.provideHover(model, position, token);
        }).then(function (result) {
            if (result) {
                var hasRange = (typeof result.range !== 'undefined');
                var hasHtmlContent = typeof result.contents !== 'undefined' && result.contents && result.contents.length > 0;
                if (hasRange && hasHtmlContent) {
                    values[idx] = result;
                }
            }
        }, function (err) {
            onUnexpectedExternalError(err);
        });
    });
    return TPromise.join(promises).then(function () { return coalesce(values); });
}
registerDefaultLanguageCommand('_executeHoverProvider', getHover);

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var HoverOperation = /** @class */ (function () {
    function HoverOperation(computer, success, error, progress) {
        var _this = this;
        this._computer = computer;
        this._state = 0 /* IDLE */;
        this._firstWaitScheduler = new RunOnceScheduler(function () { return _this._triggerAsyncComputation(); }, this._getHoverTimeMillis() / 2);
        this._secondWaitScheduler = new RunOnceScheduler(function () { return _this._triggerSyncComputation(); }, this._getHoverTimeMillis() / 2);
        this._loadingMessageScheduler = new RunOnceScheduler(function () { return _this._showLoadingMessage(); }, 3 * this._getHoverTimeMillis());
        this._asyncComputationPromise = null;
        this._asyncComputationPromiseDone = false;
        this._completeCallback = success;
        this._errorCallback = error;
        this._progressCallback = progress;
    }
    HoverOperation.prototype._getHoverTimeMillis = function () {
        if (this._computer.getHoverTimeMillis) {
            return this._computer.getHoverTimeMillis();
        }
        return HoverOperation.HOVER_TIME;
    };
    HoverOperation.prototype._triggerAsyncComputation = function () {
        var _this = this;
        this._state = 2 /* SECOND_WAIT */;
        this._secondWaitScheduler.schedule();
        if (this._computer.computeAsync) {
            this._asyncComputationPromiseDone = false;
            this._asyncComputationPromise = this._computer.computeAsync().then(function (asyncResult) {
                _this._asyncComputationPromiseDone = true;
                _this._withAsyncResult(asyncResult);
            }, function (e) { return _this._onError(e); });
        }
        else {
            this._asyncComputationPromiseDone = true;
        }
    };
    HoverOperation.prototype._triggerSyncComputation = function () {
        if (this._computer.computeSync) {
            this._computer.onResult(this._computer.computeSync(), true);
        }
        if (this._asyncComputationPromiseDone) {
            this._state = 0 /* IDLE */;
            this._onComplete(this._computer.getResult());
        }
        else {
            this._state = 3 /* WAITING_FOR_ASYNC_COMPUTATION */;
            this._onProgress(this._computer.getResult());
        }
    };
    HoverOperation.prototype._showLoadingMessage = function () {
        if (this._state === 3 /* WAITING_FOR_ASYNC_COMPUTATION */) {
            this._onProgress(this._computer.getResultWithLoadingMessage());
        }
    };
    HoverOperation.prototype._withAsyncResult = function (asyncResult) {
        if (asyncResult) {
            this._computer.onResult(asyncResult, false);
        }
        if (this._state === 3 /* WAITING_FOR_ASYNC_COMPUTATION */) {
            this._state = 0 /* IDLE */;
            this._onComplete(this._computer.getResult());
        }
    };
    HoverOperation.prototype._onComplete = function (value) {
        if (this._completeCallback) {
            this._completeCallback(value);
        }
    };
    HoverOperation.prototype._onError = function (error) {
        if (this._errorCallback) {
            this._errorCallback(error);
        }
        else {
            onUnexpectedError(error);
        }
    };
    HoverOperation.prototype._onProgress = function (value) {
        if (this._progressCallback) {
            this._progressCallback(value);
        }
    };
    HoverOperation.prototype.start = function () {
        if (this._state === 0 /* IDLE */) {
            this._state = 1 /* FIRST_WAIT */;
            this._firstWaitScheduler.schedule();
            this._loadingMessageScheduler.schedule();
        }
    };
    HoverOperation.prototype.cancel = function () {
        this._loadingMessageScheduler.cancel();
        if (this._state === 1 /* FIRST_WAIT */) {
            this._firstWaitScheduler.cancel();
        }
        if (this._state === 2 /* SECOND_WAIT */) {
            this._secondWaitScheduler.cancel();
            if (this._asyncComputationPromise) {
                this._asyncComputationPromise.cancel();
                this._asyncComputationPromise = null;
            }
        }
        if (this._state === 3 /* WAITING_FOR_ASYNC_COMPUTATION */) {
            if (this._asyncComputationPromise) {
                this._asyncComputationPromise.cancel();
                this._asyncComputationPromise = null;
            }
        }
        this._state = 0 /* IDLE */;
    };
    HoverOperation.HOVER_TIME = 300;
    return HoverOperation;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$q = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var ContentHoverWidget = /** @class */ (function (_super) {
    __extends$q(ContentHoverWidget, _super);
    function ContentHoverWidget(id, editor) {
        var _this = _super.call(this) || this;
        _this.disposables = [];
        // Editor.IContentWidget.allowEditorOverflow
        _this.allowEditorOverflow = true;
        _this._id = id;
        _this._editor = editor;
        _this._isVisible = false;
        _this._containerDomNode = document.createElement('div');
        _this._containerDomNode.className = 'monaco-editor-hover hidden';
        _this._containerDomNode.tabIndex = 0;
        _this._domNode = document.createElement('div');
        _this._domNode.className = 'monaco-editor-hover-content';
        _this.scrollbar = new DomScrollableElement(_this._domNode, {});
        _this.disposables.push(_this.scrollbar);
        _this._containerDomNode.appendChild(_this.scrollbar.getDomNode());
        _this.onkeydown(_this._containerDomNode, function (e) {
            if (e.equals(9 /* Escape */)) {
                _this.hide();
            }
        });
        _this._register(_this._editor.onDidChangeConfiguration(function (e) {
            if (e.fontInfo) {
                _this.updateFont();
            }
        }));
        _this._editor.onDidLayoutChange(function (e) { return _this.updateMaxHeight(); });
        _this.updateMaxHeight();
        _this._editor.addContentWidget(_this);
        _this._showAtPosition = null;
        return _this;
    }
    Object.defineProperty(ContentHoverWidget.prototype, "isVisible", {
        get: function () {
            return this._isVisible;
        },
        set: function (value) {
            this._isVisible = value;
            toggleClass(this._containerDomNode, 'hidden', !this._isVisible);
        },
        enumerable: true,
        configurable: true
    });
    ContentHoverWidget.prototype.getId = function () {
        return this._id;
    };
    ContentHoverWidget.prototype.getDomNode = function () {
        return this._containerDomNode;
    };
    ContentHoverWidget.prototype.showAt = function (position, focus) {
        // Position has changed
        this._showAtPosition = new Position(position.lineNumber, position.column);
        this.isVisible = true;
        this._editor.layoutContentWidget(this);
        // Simply force a synchronous render on the editor
        // such that the widget does not really render with left = '0px'
        this._editor.render();
        this._stoleFocus = focus;
        if (focus) {
            this._containerDomNode.focus();
        }
    };
    ContentHoverWidget.prototype.hide = function () {
        if (!this.isVisible) {
            return;
        }
        this.isVisible = false;
        this._editor.layoutContentWidget(this);
        if (this._stoleFocus) {
            this._editor.focus();
        }
    };
    ContentHoverWidget.prototype.getPosition = function () {
        if (this.isVisible) {
            return {
                position: this._showAtPosition,
                preference: [
                    ContentWidgetPositionPreference.ABOVE,
                    ContentWidgetPositionPreference.BELOW
                ]
            };
        }
        return null;
    };
    ContentHoverWidget.prototype.dispose = function () {
        this._editor.removeContentWidget(this);
        this.disposables = dispose(this.disposables);
        _super.prototype.dispose.call(this);
    };
    ContentHoverWidget.prototype.updateFont = function () {
        var _this = this;
        var codeClasses = Array.prototype.slice.call(this._domNode.getElementsByClassName('code'));
        codeClasses.forEach(function (node) { return _this._editor.applyFontInfo(node); });
    };
    ContentHoverWidget.prototype.updateContents = function (node) {
        this._domNode.textContent = '';
        this._domNode.appendChild(node);
        this.updateFont();
        this._editor.layoutContentWidget(this);
        this.onContentsChange();
    };
    ContentHoverWidget.prototype.onContentsChange = function () {
        this.scrollbar.scanDomNode();
    };
    ContentHoverWidget.prototype.updateMaxHeight = function () {
        var height = Math.max(this._editor.getLayoutInfo().height / 4, 250);
        var _a = this._editor.getConfiguration().fontInfo, fontSize = _a.fontSize, lineHeight = _a.lineHeight;
        this._domNode.style.fontSize = fontSize + "px";
        this._domNode.style.lineHeight = lineHeight + "px";
        this._domNode.style.maxHeight = height + "px";
    };
    return ContentHoverWidget;
}(Widget));
var GlyphHoverWidget = /** @class */ (function (_super) {
    __extends$q(GlyphHoverWidget, _super);
    function GlyphHoverWidget(id, editor) {
        var _this = _super.call(this) || this;
        _this._id = id;
        _this._editor = editor;
        _this._isVisible = false;
        _this._domNode = document.createElement('div');
        _this._domNode.className = 'monaco-editor-hover hidden';
        _this._domNode.setAttribute('aria-hidden', 'true');
        _this._domNode.setAttribute('role', 'presentation');
        _this._showAtLineNumber = -1;
        _this._register(_this._editor.onDidChangeConfiguration(function (e) {
            if (e.fontInfo) {
                _this.updateFont();
            }
        }));
        _this._editor.addOverlayWidget(_this);
        return _this;
    }
    Object.defineProperty(GlyphHoverWidget.prototype, "isVisible", {
        get: function () {
            return this._isVisible;
        },
        set: function (value) {
            this._isVisible = value;
            toggleClass(this._domNode, 'hidden', !this._isVisible);
        },
        enumerable: true,
        configurable: true
    });
    GlyphHoverWidget.prototype.getId = function () {
        return this._id;
    };
    GlyphHoverWidget.prototype.getDomNode = function () {
        return this._domNode;
    };
    GlyphHoverWidget.prototype.showAt = function (lineNumber) {
        this._showAtLineNumber = lineNumber;
        if (!this.isVisible) {
            this.isVisible = true;
        }
        var editorLayout = this._editor.getLayoutInfo();
        var topForLineNumber = this._editor.getTopForLineNumber(this._showAtLineNumber);
        var editorScrollTop = this._editor.getScrollTop();
        var lineHeight = this._editor.getConfiguration().lineHeight;
        var nodeHeight = this._domNode.clientHeight;
        var top = topForLineNumber - editorScrollTop - ((nodeHeight - lineHeight) / 2);
        this._domNode.style.left = editorLayout.glyphMarginLeft + editorLayout.glyphMarginWidth + "px";
        this._domNode.style.top = Math.max(Math.round(top), 0) + "px";
    };
    GlyphHoverWidget.prototype.hide = function () {
        if (!this.isVisible) {
            return;
        }
        this.isVisible = false;
    };
    GlyphHoverWidget.prototype.getPosition = function () {
        return null;
    };
    GlyphHoverWidget.prototype.dispose = function () {
        this._editor.removeOverlayWidget(this);
        _super.prototype.dispose.call(this);
    };
    GlyphHoverWidget.prototype.updateFont = function () {
        var _this = this;
        var codeTags = Array.prototype.slice.call(this._domNode.getElementsByTagName('code'));
        var codeClasses = Array.prototype.slice.call(this._domNode.getElementsByClassName('code'));
        codeTags.concat(codeClasses).forEach(function (node) { return _this._editor.applyFontInfo(node); });
    };
    GlyphHoverWidget.prototype.updateContents = function (node) {
        this._domNode.textContent = '';
        this._domNode.appendChild(node);
        this.updateFont();
    };
    return GlyphHoverWidget;
}(Widget));

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var ColorPickerModel = /** @class */ (function () {
    function ColorPickerModel(color, availableColorPresentations, presentationIndex) {
        this.presentationIndex = presentationIndex;
        this._onColorFlushed = new Emitter();
        this.onColorFlushed = this._onColorFlushed.event;
        this._onDidChangeColor = new Emitter();
        this.onDidChangeColor = this._onDidChangeColor.event;
        this._onDidChangePresentation = new Emitter();
        this.onDidChangePresentation = this._onDidChangePresentation.event;
        this.originalColor = color;
        this._color = color;
        this._colorPresentations = availableColorPresentations;
    }
    Object.defineProperty(ColorPickerModel.prototype, "color", {
        get: function () {
            return this._color;
        },
        set: function (color) {
            if (this._color.equals(color)) {
                return;
            }
            this._color = color;
            this._onDidChangeColor.fire(color);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ColorPickerModel.prototype, "presentation", {
        get: function () { return this.colorPresentations[this.presentationIndex]; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ColorPickerModel.prototype, "colorPresentations", {
        get: function () {
            return this._colorPresentations;
        },
        set: function (colorPresentations) {
            this._colorPresentations = colorPresentations;
            if (this.presentationIndex > colorPresentations.length - 1) {
                this.presentationIndex = 0;
            }
            this._onDidChangePresentation.fire(this.presentation);
        },
        enumerable: true,
        configurable: true
    });
    ColorPickerModel.prototype.selectNextColorPresentation = function () {
        this.presentationIndex = (this.presentationIndex + 1) % this.colorPresentations.length;
        this.flushColor();
        this._onDidChangePresentation.fire(this.presentation);
    };
    ColorPickerModel.prototype.guessColorPresentation = function (color, originalText) {
        for (var i = 0; i < this.colorPresentations.length; i++) {
            if (originalText === this.colorPresentations[i].label) {
                this.presentationIndex = i;
                this._onDidChangePresentation.fire(this.presentation);
                break;
            }
        }
    };
    ColorPickerModel.prototype.flushColor = function () {
        this._onColorFlushed.fire(this._color);
    };
    return ColorPickerModel;
}());

const css$j = "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n.colorpicker-widget {\n\theight: 190px;\n\tuser-select: none;\n}\n\n.monaco-editor .colorpicker-hover:focus {\n\toutline: none;\n}\n\n\n/* Header */\n\n.colorpicker-header {\n\tdisplay: flex;\n\theight: 24px;\n\tposition: relative;\n\tbackground: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAAECAYAAACp8Z5+AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAZdEVYdFNvZnR3YXJlAHBhaW50Lm5ldCA0LjAuMTZEaa/1AAAAHUlEQVQYV2PYvXu3JAi7uLiAMaYAjAGTQBPYLQkAa/0Zef3qRswAAAAASUVORK5CYII=\");\n\tbackground-size: 9px 9px;\n\timage-rendering: pixelated;\n}\n\n.colorpicker-header .picked-color {\n\twidth: 216px;\n\ttext-align: center;\n\tline-height: 24px;\n\tcursor: pointer;\n\tcolor: white;\n\tflex: 1;\n\ttext-align: center;\n}\n\n.colorpicker-header .picked-color.light {\n\tcolor: black;\n}\n\n.colorpicker-header .original-color {\n\twidth: 74px;\n\tz-index: inherit;\n\tcursor: pointer;\n}\n\n\n/* Body */\n\n.colorpicker-body {\n\tdisplay: flex;\n\tpadding: 8px;\n\tposition: relative;\n}\n\n.colorpicker-body .saturation-wrap {\n\toverflow: hidden;\n\theight: 150px;\n\tposition: relative;\n\tmin-width: 220px;\n\tflex: 1;\n}\n\n.colorpicker-body .saturation-box {\n\theight: 150px;\n\tposition: absolute;\n}\n\n.colorpicker-body .saturation-selection {\n\twidth: 9px;\n\theight: 9px;\n\tmargin: -5px 0 0 -5px;\n\tborder: 1px solid rgb(255, 255, 255);\n\tborder-radius: 100%;\n\tbox-shadow: 0px 0px 2px rgba(0, 0, 0, 0.8);\n\tposition: absolute;\n}\n\n.colorpicker-body .strip {\n\twidth: 25px;\n\theight: 150px;\n}\n\n.colorpicker-body .hue-strip {\n\tposition: relative;\n\tmargin-left: 8px;\n\tcursor: -webkit-grab;\n\tbackground: linear-gradient(to bottom, #ff0000 0%, #ffff00 17%, #00ff00 33%, #00ffff 50%, #0000ff 67%, #ff00ff 83%, #ff0000 100%);\n}\n\n.colorpicker-body .opacity-strip {\n\tposition: relative;\n\tmargin-left: 8px;\n\tcursor: -webkit-grab;\n\tbackground: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAAECAYAAACp8Z5+AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAZdEVYdFNvZnR3YXJlAHBhaW50Lm5ldCA0LjAuMTZEaa/1AAAAHUlEQVQYV2PYvXu3JAi7uLiAMaYAjAGTQBPYLQkAa/0Zef3qRswAAAAASUVORK5CYII=\");\n\tbackground-size: 9px 9px;\n\timage-rendering: pixelated;\n}\n\n.colorpicker-body .strip.grabbing {\n\tcursor: -webkit-grabbing;\n}\n\n.colorpicker-body .slider {\n\tposition: absolute;\n\ttop: 0;\n\tleft: -2px;\n\twidth: calc(100% + 4px);\n\theight: 4px;\n\tbox-sizing: border-box;\n\tborder: 1px solid rgba(255, 255, 255, 0.71);\n\tbox-shadow: 0px 0px 1px rgba(0, 0, 0, 0.85);\n}\n\n.colorpicker-body .strip .overlay {\n\theight: 150px;\n\tpointer-events: none;\n}";
  const element$j = ((css, src) => {
if (typeof document !== 'object')
console.info(`Skipped loading "${src}"`);
try {
const id = src
  .replace(/\.css.*$/, '')
  .replace(/[\\:]/g, '/')
  .replace(/[^\w\/]+/g, '');
return (
  document.querySelector(`style[id="${id}"]`) ||
  document.head.appendChild(
    Object.assign(document.createElement('style'), {
      id,
      textContent: `${css}\n\n /* sourceURL=${src} */`,
    }),
  )
);
} catch (exception) {
console.warn(`Failed load "${src}"`, exception);
}
})(css$j, "…monaco-editor/esm/vs/editor/contrib/colorPicker/colorPicker.css");
  //@ sourceURL=/Users/daflair/Projects/packages/monaco-es/node_modules/monaco-editor/esm/vs/editor/contrib/colorPicker/colorPicker.css

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$r = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var $$3 = $;
var ColorPickerHeader = /** @class */ (function (_super) {
    __extends$r(ColorPickerHeader, _super);
    function ColorPickerHeader(container, model, themeService) {
        var _this = _super.call(this) || this;
        _this.model = model;
        _this.domNode = $$3('.colorpicker-header');
        append(container, _this.domNode);
        _this.pickedColorNode = append(_this.domNode, $$3('.picked-color'));
        var colorBox = append(_this.domNode, $$3('.original-color'));
        colorBox.style.backgroundColor = Color.Format.CSS.format(_this.model.originalColor);
        _this.backgroundColor = themeService.getTheme().getColor(editorHoverBackground) || Color.white;
        _this._register(registerThemingParticipant(function (theme, collector) {
            _this.backgroundColor = theme.getColor(editorHoverBackground) || Color.white;
        }));
        _this._register(addDisposableListener(_this.pickedColorNode, EventType.CLICK, function () { return _this.model.selectNextColorPresentation(); }));
        _this._register(addDisposableListener(colorBox, EventType.CLICK, function () {
            _this.model.color = _this.model.originalColor;
            _this.model.flushColor();
        }));
        _this._register(model.onDidChangeColor(_this.onDidChangeColor, _this));
        _this._register(model.onDidChangePresentation(_this.onDidChangePresentation, _this));
        _this.pickedColorNode.style.backgroundColor = Color.Format.CSS.format(model.color);
        toggleClass(_this.pickedColorNode, 'light', model.color.rgba.a < 0.5 ? _this.backgroundColor.isLighter() : model.color.isLighter());
        return _this;
    }
    ColorPickerHeader.prototype.onDidChangeColor = function (color) {
        this.pickedColorNode.style.backgroundColor = Color.Format.CSS.format(color);
        toggleClass(this.pickedColorNode, 'light', color.rgba.a < 0.5 ? this.backgroundColor.isLighter() : color.isLighter());
        this.onDidChangePresentation();
    };
    ColorPickerHeader.prototype.onDidChangePresentation = function () {
        this.pickedColorNode.textContent = this.model.presentation.label;
    };
    return ColorPickerHeader;
}(Disposable));
var ColorPickerBody = /** @class */ (function (_super) {
    __extends$r(ColorPickerBody, _super);
    function ColorPickerBody(container, model, pixelRatio) {
        var _this = _super.call(this) || this;
        _this.model = model;
        _this.pixelRatio = pixelRatio;
        _this.domNode = $$3('.colorpicker-body');
        append(container, _this.domNode);
        _this.saturationBox = new SaturationBox(_this.domNode, _this.model, _this.pixelRatio);
        _this._register(_this.saturationBox);
        _this._register(_this.saturationBox.onDidChange(_this.onDidSaturationValueChange, _this));
        _this._register(_this.saturationBox.onColorFlushed(_this.flushColor, _this));
        _this.opacityStrip = new OpacityStrip(_this.domNode, _this.model);
        _this._register(_this.opacityStrip);
        _this._register(_this.opacityStrip.onDidChange(_this.onDidOpacityChange, _this));
        _this._register(_this.opacityStrip.onColorFlushed(_this.flushColor, _this));
        _this.hueStrip = new HueStrip(_this.domNode, _this.model);
        _this._register(_this.hueStrip);
        _this._register(_this.hueStrip.onDidChange(_this.onDidHueChange, _this));
        _this._register(_this.hueStrip.onColorFlushed(_this.flushColor, _this));
        return _this;
    }
    ColorPickerBody.prototype.flushColor = function () {
        this.model.flushColor();
    };
    ColorPickerBody.prototype.onDidSaturationValueChange = function (_a) {
        var s = _a.s, v = _a.v;
        var hsva = this.model.color.hsva;
        this.model.color = new Color(new HSVA(hsva.h, s, v, hsva.a));
    };
    ColorPickerBody.prototype.onDidOpacityChange = function (a) {
        var hsva = this.model.color.hsva;
        this.model.color = new Color(new HSVA(hsva.h, hsva.s, hsva.v, a));
    };
    ColorPickerBody.prototype.onDidHueChange = function (value) {
        var hsva = this.model.color.hsva;
        var h = (1 - value) * 360;
        this.model.color = new Color(new HSVA(h === 360 ? 0 : h, hsva.s, hsva.v, hsva.a));
    };
    ColorPickerBody.prototype.layout = function () {
        this.saturationBox.layout();
        this.opacityStrip.layout();
        this.hueStrip.layout();
    };
    return ColorPickerBody;
}(Disposable));
var SaturationBox = /** @class */ (function (_super) {
    __extends$r(SaturationBox, _super);
    function SaturationBox(container, model, pixelRatio) {
        var _this = _super.call(this) || this;
        _this.model = model;
        _this.pixelRatio = pixelRatio;
        _this._onDidChange = new Emitter();
        _this.onDidChange = _this._onDidChange.event;
        _this._onColorFlushed = new Emitter();
        _this.onColorFlushed = _this._onColorFlushed.event;
        _this.domNode = $$3('.saturation-wrap');
        append(container, _this.domNode);
        // Create canvas, draw selected color
        _this.canvas = document.createElement('canvas');
        _this.canvas.className = 'saturation-box';
        append(_this.domNode, _this.canvas);
        // Add selection circle
        _this.selection = $$3('.saturation-selection');
        append(_this.domNode, _this.selection);
        _this.layout();
        _this._register(addDisposableListener(_this.domNode, EventType.MOUSE_DOWN, function (e) { return _this.onMouseDown(e); }));
        _this._register(_this.model.onDidChangeColor(_this.onDidChangeColor, _this));
        _this.monitor = null;
        return _this;
    }
    SaturationBox.prototype.onMouseDown = function (e) {
        var _this = this;
        this.monitor = this._register(new GlobalMouseMoveMonitor());
        var origin = getDomNodePagePosition(this.domNode);
        if (e.target !== this.selection) {
            this.onDidChangePosition(e.offsetX, e.offsetY);
        }
        this.monitor.startMonitoring(standardMouseMoveMerger, function (event) { return _this.onDidChangePosition(event.posx - origin.left, event.posy - origin.top); }, function () { return null; });
        var mouseUpListener = addDisposableListener(document, EventType.MOUSE_UP, function () {
            _this._onColorFlushed.fire();
            mouseUpListener.dispose();
            _this.monitor.stopMonitoring(true);
            _this.monitor = null;
        }, true);
    };
    SaturationBox.prototype.onDidChangePosition = function (left, top) {
        var s = Math.max(0, Math.min(1, left / this.width));
        var v = Math.max(0, Math.min(1, 1 - (top / this.height)));
        this.paintSelection(s, v);
        this._onDidChange.fire({ s: s, v: v });
    };
    SaturationBox.prototype.layout = function () {
        this.width = this.domNode.offsetWidth;
        this.height = this.domNode.offsetHeight;
        this.canvas.width = this.width * this.pixelRatio;
        this.canvas.height = this.height * this.pixelRatio;
        this.paint();
        var hsva = this.model.color.hsva;
        this.paintSelection(hsva.s, hsva.v);
    };
    SaturationBox.prototype.paint = function () {
        var hsva = this.model.color.hsva;
        var saturatedColor = new Color(new HSVA(hsva.h, 1, 1, 1));
        var ctx = this.canvas.getContext('2d');
        var whiteGradient = ctx.createLinearGradient(0, 0, this.canvas.width, 0);
        whiteGradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
        whiteGradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.5)');
        whiteGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
        var blackGradient = ctx.createLinearGradient(0, 0, 0, this.canvas.height);
        blackGradient.addColorStop(0, 'rgba(0, 0, 0, 0)');
        blackGradient.addColorStop(1, 'rgba(0, 0, 0, 1)');
        ctx.rect(0, 0, this.canvas.width, this.canvas.height);
        ctx.fillStyle = Color.Format.CSS.format(saturatedColor);
        ctx.fill();
        ctx.fillStyle = whiteGradient;
        ctx.fill();
        ctx.fillStyle = blackGradient;
        ctx.fill();
    };
    SaturationBox.prototype.paintSelection = function (s, v) {
        this.selection.style.left = s * this.width + "px";
        this.selection.style.top = this.height - v * this.height + "px";
    };
    SaturationBox.prototype.onDidChangeColor = function () {
        if (this.monitor && this.monitor.isMonitoring()) {
            return;
        }
        this.paint();
    };
    return SaturationBox;
}(Disposable));
var Strip = /** @class */ (function (_super) {
    __extends$r(Strip, _super);
    function Strip(container, model) {
        var _this = _super.call(this) || this;
        _this.model = model;
        _this._onDidChange = new Emitter();
        _this.onDidChange = _this._onDidChange.event;
        _this._onColorFlushed = new Emitter();
        _this.onColorFlushed = _this._onColorFlushed.event;
        _this.domNode = append(container, $$3('.strip'));
        _this.overlay = append(_this.domNode, $$3('.overlay'));
        _this.slider = append(_this.domNode, $$3('.slider'));
        _this.slider.style.top = "0px";
        _this._register(addDisposableListener(_this.domNode, EventType.MOUSE_DOWN, function (e) { return _this.onMouseDown(e); }));
        _this.layout();
        return _this;
    }
    Strip.prototype.layout = function () {
        this.height = this.domNode.offsetHeight - this.slider.offsetHeight;
        var value = this.getValue(this.model.color);
        this.updateSliderPosition(value);
    };
    Strip.prototype.onMouseDown = function (e) {
        var _this = this;
        var monitor = this._register(new GlobalMouseMoveMonitor());
        var origin = getDomNodePagePosition(this.domNode);
        addClass(this.domNode, 'grabbing');
        if (e.target !== this.slider) {
            this.onDidChangeTop(e.offsetY);
        }
        monitor.startMonitoring(standardMouseMoveMerger, function (event) { return _this.onDidChangeTop(event.posy - origin.top); }, function () { return null; });
        var mouseUpListener = addDisposableListener(document, EventType.MOUSE_UP, function () {
            _this._onColorFlushed.fire();
            mouseUpListener.dispose();
            monitor.stopMonitoring(true);
            removeClass(_this.domNode, 'grabbing');
        }, true);
    };
    Strip.prototype.onDidChangeTop = function (top) {
        var value = Math.max(0, Math.min(1, 1 - (top / this.height)));
        this.updateSliderPosition(value);
        this._onDidChange.fire(value);
    };
    Strip.prototype.updateSliderPosition = function (value) {
        this.slider.style.top = (1 - value) * this.height + "px";
    };
    return Strip;
}(Disposable));
var OpacityStrip = /** @class */ (function (_super) {
    __extends$r(OpacityStrip, _super);
    function OpacityStrip(container, model) {
        var _this = _super.call(this, container, model) || this;
        addClass(_this.domNode, 'opacity-strip');
        _this._register(model.onDidChangeColor(_this.onDidChangeColor, _this));
        _this.onDidChangeColor(_this.model.color);
        return _this;
    }
    OpacityStrip.prototype.onDidChangeColor = function (color) {
        var _a = color.rgba, r = _a.r, g = _a.g, b = _a.b;
        var opaque = new Color(new RGBA(r, g, b, 1));
        var transparent = new Color(new RGBA(r, g, b, 0));
        this.overlay.style.background = "linear-gradient(to bottom, " + opaque + " 0%, " + transparent + " 100%)";
    };
    OpacityStrip.prototype.getValue = function (color) {
        return color.hsva.a;
    };
    return OpacityStrip;
}(Strip));
var HueStrip = /** @class */ (function (_super) {
    __extends$r(HueStrip, _super);
    function HueStrip(container, model) {
        var _this = _super.call(this, container, model) || this;
        addClass(_this.domNode, 'hue-strip');
        return _this;
    }
    HueStrip.prototype.getValue = function (color) {
        return 1 - (color.hsva.h / 360);
    };
    return HueStrip;
}(Strip));
var ColorPickerWidget = /** @class */ (function (_super) {
    __extends$r(ColorPickerWidget, _super);
    function ColorPickerWidget(container, model, pixelRatio, themeService) {
        var _this = _super.call(this) || this;
        _this.model = model;
        _this.pixelRatio = pixelRatio;
        _this._register(onDidChangeZoomLevel(function () { return _this.layout(); }));
        var element = $$3('.colorpicker-widget');
        container.appendChild(element);
        var header = new ColorPickerHeader(element, _this.model, themeService);
        _this.body = new ColorPickerBody(element, _this.model, _this.pixelRatio);
        _this._register(header);
        _this._register(_this.body);
        return _this;
    }
    ColorPickerWidget.prototype.getId = function () {
        return ColorPickerWidget.ID;
    };
    ColorPickerWidget.prototype.layout = function () {
        this.body.layout();
    };
    ColorPickerWidget.ID = 'editor.contrib.colorPickerWidget';
    return ColorPickerWidget;
}(Widget));

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$s = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var $$4 = $;
var ColorHover = /** @class */ (function () {
    function ColorHover(range$$1, color, provider) {
        this.range = range$$1;
        this.color = color;
        this.provider = provider;
    }
    return ColorHover;
}());
var ModesContentComputer = /** @class */ (function () {
    function ModesContentComputer(editor) {
        this._editor = editor;
        this._range = null;
    }
    ModesContentComputer.prototype.setRange = function (range$$1) {
        this._range = range$$1;
        this._result = [];
    };
    ModesContentComputer.prototype.clearResult = function () {
        this._result = [];
    };
    ModesContentComputer.prototype.computeAsync = function () {
        var model = this._editor.getModel();
        if (!HoverProviderRegistry.has(model)) {
            return TPromise.as(null);
        }
        return getHover(model, new Position(this._range.startLineNumber, this._range.startColumn));
    };
    ModesContentComputer.prototype.computeSync = function () {
        var _this = this;
        var lineNumber = this._range.startLineNumber;
        if (lineNumber > this._editor.getModel().getLineCount()) {
            // Illegal line number => no results
            return [];
        }
        var colorDetector = ColorDetector.get(this._editor);
        var maxColumn = this._editor.getModel().getLineMaxColumn(lineNumber);
        var lineDecorations = this._editor.getLineDecorations(lineNumber);
        var didFindColor = false;
        var result = lineDecorations.map(function (d) {
            var startColumn = (d.range.startLineNumber === lineNumber) ? d.range.startColumn : 1;
            var endColumn = (d.range.endLineNumber === lineNumber) ? d.range.endColumn : maxColumn;
            if (startColumn > _this._range.startColumn || _this._range.endColumn > endColumn) {
                return null;
            }
            var range$$1 = new Range(_this._range.startLineNumber, startColumn, _this._range.startLineNumber, endColumn);
            var colorData = colorDetector.getColorData(d.range.getStartPosition());
            if (!didFindColor && colorData) {
                didFindColor = true;
                var _a = colorData.colorInfo, color = _a.color, range_1 = _a.range;
                return new ColorHover(range_1, color, colorData.provider);
            }
            else {
                if (isEmptyMarkdownString(d.options.hoverMessage)) {
                    return null;
                }
                var contents = void 0;
                if (d.options.hoverMessage) {
                    if (Array.isArray(d.options.hoverMessage)) {
                        contents = d.options.hoverMessage.slice();
                    }
                    else {
                        contents = [d.options.hoverMessage];
                    }
                }
                return { contents: contents, range: range$$1 };
            }
        });
        return result.filter(function (d) { return !!d; });
    };
    ModesContentComputer.prototype.onResult = function (result, isFromSynchronousComputation) {
        // Always put synchronous messages before asynchronous ones
        if (isFromSynchronousComputation) {
            this._result = result.concat(this._result.sort(function (a, b) {
                if (a instanceof ColorHover) { // sort picker messages at to the top
                    return -1;
                }
                else if (b instanceof ColorHover) {
                    return 1;
                }
                return 0;
            }));
        }
        else {
            this._result = this._result.concat(result);
        }
    };
    ModesContentComputer.prototype.getResult = function () {
        return this._result.slice(0);
    };
    ModesContentComputer.prototype.getResultWithLoadingMessage = function () {
        return this._result.slice(0).concat([this._getLoadingMessage()]);
    };
    ModesContentComputer.prototype._getLoadingMessage = function () {
        return {
            range: this._range,
            contents: [new MarkdownString().appendText(localize('modesContentHover.loading', "Loading..."))]
        };
    };
    return ModesContentComputer;
}());
var ModesContentHoverWidget = /** @class */ (function (_super) {
    __extends$s(ModesContentHoverWidget, _super);
    function ModesContentHoverWidget(editor, markdownRenderner, _themeService) {
        var _this = _super.call(this, ModesContentHoverWidget.ID, editor) || this;
        _this._themeService = _themeService;
        _this.renderDisposable = empty$1;
        _this.toDispose = [];
        _this._computer = new ModesContentComputer(_this._editor);
        _this._highlightDecorations = [];
        _this._isChangingDecorations = false;
        _this._markdownRenderer = markdownRenderner;
        markdownRenderner.onDidRenderCodeBlock(_this.onContentsChange, _this, _this.toDispose);
        _this._hoverOperation = new HoverOperation(_this._computer, function (result) { return _this._withResult(result, true); }, null, function (result) { return _this._withResult(result, false); });
        _this.toDispose.push(addStandardDisposableListener(_this.getDomNode(), EventType.FOCUS, function () {
            if (_this._colorPicker) {
                addClass(_this.getDomNode(), 'colorpicker-hover');
            }
        }));
        _this.toDispose.push(addStandardDisposableListener(_this.getDomNode(), EventType.BLUR, function () {
            removeClass(_this.getDomNode(), 'colorpicker-hover');
        }));
        return _this;
    }
    ModesContentHoverWidget.prototype.dispose = function () {
        this.renderDisposable.dispose();
        this.renderDisposable = empty$1;
        this._hoverOperation.cancel();
        this.toDispose = dispose(this.toDispose);
        _super.prototype.dispose.call(this);
    };
    ModesContentHoverWidget.prototype.onModelDecorationsChanged = function () {
        if (this._isChangingDecorations) {
            return;
        }
        if (this.isVisible) {
            // The decorations have changed and the hover is visible,
            // we need to recompute the displayed text
            this._hoverOperation.cancel();
            this._computer.clearResult();
            if (!this._colorPicker) { // TODO@Michel ensure that displayed text for other decorations is computed even if color picker is in place
                this._hoverOperation.start();
            }
        }
    };
    ModesContentHoverWidget.prototype.startShowingAt = function (range$$1, focus) {
        if (this._lastRange && this._lastRange.equalsRange(range$$1)) {
            // We have to show the widget at the exact same range as before, so no work is needed
            return;
        }
        this._hoverOperation.cancel();
        if (this.isVisible) {
            // The range might have changed, but the hover is visible
            // Instead of hiding it completely, filter out messages that are still in the new range and
            // kick off a new computation
            if (this._showAtPosition.lineNumber !== range$$1.startLineNumber) {
                this.hide();
            }
            else {
                var filteredMessages = [];
                for (var i = 0, len = this._messages.length; i < len; i++) {
                    var msg = this._messages[i];
                    var rng = msg.range;
                    if (rng.startColumn <= range$$1.startColumn && rng.endColumn >= range$$1.endColumn) {
                        filteredMessages.push(msg);
                    }
                }
                if (filteredMessages.length > 0) {
                    if (hoverContentsEquals(filteredMessages, this._messages)) {
                        return;
                    }
                    this._renderMessages(range$$1, filteredMessages);
                }
                else {
                    this.hide();
                }
            }
        }
        this._lastRange = range$$1;
        this._computer.setRange(range$$1);
        this._shouldFocus = focus;
        this._hoverOperation.start();
    };
    ModesContentHoverWidget.prototype.hide = function () {
        this._lastRange = null;
        this._hoverOperation.cancel();
        _super.prototype.hide.call(this);
        this._isChangingDecorations = true;
        this._highlightDecorations = this._editor.deltaDecorations(this._highlightDecorations, []);
        this._isChangingDecorations = false;
        this.renderDisposable.dispose();
        this.renderDisposable = empty$1;
        this._colorPicker = null;
    };
    ModesContentHoverWidget.prototype.isColorPickerVisible = function () {
        if (this._colorPicker) {
            return true;
        }
        return false;
    };
    ModesContentHoverWidget.prototype._withResult = function (result, complete) {
        this._messages = result;
        if (this._lastRange && this._messages.length > 0) {
            this._renderMessages(this._lastRange, this._messages);
        }
        else if (complete) {
            this.hide();
        }
    };
    ModesContentHoverWidget.prototype._renderMessages = function (renderRange, messages) {
        var _this = this;
        this.renderDisposable.dispose();
        this._colorPicker = null;
        // update column from which to show
        var renderColumn = Number.MAX_VALUE, highlightRange = messages[0].range, fragment = document.createDocumentFragment(), isEmptyHoverContent = true;
        var containColorPicker = false;
        var markdownDisposeable;
        messages.forEach(function (msg) {
            if (!msg.range) {
                return;
            }
            renderColumn = Math.min(renderColumn, msg.range.startColumn);
            highlightRange = Range.plusRange(highlightRange, msg.range);
            if (!(msg instanceof ColorHover)) {
                msg.contents
                    .filter(function (contents) { return !isEmptyMarkdownString(contents); })
                    .forEach(function (contents) {
                    var renderedContents = _this._markdownRenderer.render(contents);
                    markdownDisposeable = renderedContents;
                    fragment.appendChild($$4('div.hover-row', null, renderedContents.element));
                    isEmptyHoverContent = false;
                });
            }
            else {
                containColorPicker = true;
                var _a = msg.color, red = _a.red, green = _a.green, blue = _a.blue, alpha = _a.alpha;
                var rgba = new RGBA(red * 255, green * 255, blue * 255, alpha);
                var color_1 = new Color(rgba);
                var editorModel_1 = _this._editor.getModel();
                var range_2 = new Range(msg.range.startLineNumber, msg.range.startColumn, msg.range.endLineNumber, msg.range.endColumn);
                var colorInfo = { range: msg.range, color: msg.color };
                // create blank olor picker model and widget first to ensure it's positioned correctly.
                var model_1 = new ColorPickerModel(color_1, [], 0);
                var widget_1 = new ColorPickerWidget(fragment, model_1, _this._editor.getConfiguration().pixelRatio, _this._themeService);
                getColorPresentations(editorModel_1, colorInfo, msg.provider).then(function (colorPresentations) {
                    model_1.colorPresentations = colorPresentations;
                    var originalText = _this._editor.getModel().getValueInRange(msg.range);
                    model_1.guessColorPresentation(color_1, originalText);
                    var updateEditorModel = function () {
                        var textEdits;
                        var newRange;
                        if (model_1.presentation.textEdit) {
                            textEdits = [model_1.presentation.textEdit];
                            newRange = new Range(model_1.presentation.textEdit.range.startLineNumber, model_1.presentation.textEdit.range.startColumn, model_1.presentation.textEdit.range.endLineNumber, model_1.presentation.textEdit.range.endColumn);
                            newRange = newRange.setEndPosition(newRange.endLineNumber, newRange.startColumn + model_1.presentation.textEdit.text.length);
                        }
                        else {
                            textEdits = [{ identifier: null, range: range_2, text: model_1.presentation.label, forceMoveMarkers: false }];
                            newRange = range_2.setEndPosition(range_2.endLineNumber, range_2.startColumn + model_1.presentation.label.length);
                        }
                        editorModel_1.pushEditOperations([], textEdits, function () { return []; });
                        if (model_1.presentation.additionalTextEdits) {
                            textEdits = model_1.presentation.additionalTextEdits.slice();
                            editorModel_1.pushEditOperations([], textEdits, function () { return []; });
                            _this.hide();
                        }
                        _this._editor.pushUndoStop();
                        range_2 = newRange;
                    };
                    var updateColorPresentations = function (color) {
                        return getColorPresentations(editorModel_1, {
                            range: range_2,
                            color: {
                                red: color.rgba.r / 255,
                                green: color.rgba.g / 255,
                                blue: color.rgba.b / 255,
                                alpha: color.rgba.a
                            }
                        }, msg.provider).then(function (colorPresentations) {
                            model_1.colorPresentations = colorPresentations;
                        });
                    };
                    var colorListener = model_1.onColorFlushed(function (color) {
                        updateColorPresentations(color).then(updateEditorModel);
                    });
                    var colorChangeListener = model_1.onDidChangeColor(updateColorPresentations);
                    _this._colorPicker = widget_1;
                    _this.showAt(new Position(renderRange.startLineNumber, renderColumn), _this._shouldFocus);
                    _this.updateContents(fragment);
                    _this._colorPicker.layout();
                    _this.renderDisposable = combinedDisposable([colorListener, colorChangeListener, widget_1, markdownDisposeable]);
                });
            }
        });
        // show
        if (!containColorPicker && !isEmptyHoverContent) {
            this.showAt(new Position(renderRange.startLineNumber, renderColumn), this._shouldFocus);
            this.updateContents(fragment);
        }
        this._isChangingDecorations = true;
        this._highlightDecorations = this._editor.deltaDecorations(this._highlightDecorations, [{
                range: highlightRange,
                options: ModesContentHoverWidget._DECORATION_OPTIONS
            }]);
        this._isChangingDecorations = false;
    };
    ModesContentHoverWidget.ID = 'editor.contrib.modesContentHoverWidget';
    ModesContentHoverWidget._DECORATION_OPTIONS = ModelDecorationOptions.register({
        className: 'hoverHighlight'
    });
    return ModesContentHoverWidget;
}(ContentHoverWidget));
function hoverContentsEquals(first$$1, second) {
    if ((!first$$1 && second) || (first$$1 && !second) || first$$1.length !== second.length) {
        return false;
    }
    for (var i = 0; i < first$$1.length; i++) {
        var firstElement = first$$1[i];
        var secondElement = second[i];
        if (firstElement instanceof ColorHover) {
            return false;
        }
        if (secondElement instanceof ColorHover) {
            return false;
        }
        if (!markedStringsEquals(firstElement.contents, secondElement.contents)) {
            return false;
        }
    }
    return true;
}

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$t = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var MarginComputer = /** @class */ (function () {
    function MarginComputer(editor) {
        this._editor = editor;
        this._lineNumber = -1;
    }
    MarginComputer.prototype.setLineNumber = function (lineNumber) {
        this._lineNumber = lineNumber;
        this._result = [];
    };
    MarginComputer.prototype.clearResult = function () {
        this._result = [];
    };
    MarginComputer.prototype.computeSync = function () {
        var toHoverMessage = function (contents) {
            return {
                value: contents
            };
        };
        var lineDecorations = this._editor.getLineDecorations(this._lineNumber);
        var result = [];
        for (var i = 0, len = lineDecorations.length; i < len; i++) {
            var d = lineDecorations[i];
            if (!d.options.glyphMarginClassName) {
                continue;
            }
            var hoverMessage = d.options.glyphMarginHoverMessage;
            if (isEmptyMarkdownString(hoverMessage)) {
                continue;
            }
            if (Array.isArray(hoverMessage)) {
                result = result.concat(hoverMessage.map(toHoverMessage));
            }
            else {
                result.push(toHoverMessage(hoverMessage));
            }
        }
        return result;
    };
    MarginComputer.prototype.onResult = function (result, isFromSynchronousComputation) {
        this._result = this._result.concat(result);
    };
    MarginComputer.prototype.getResult = function () {
        return this._result;
    };
    MarginComputer.prototype.getResultWithLoadingMessage = function () {
        return this.getResult();
    };
    return MarginComputer;
}());
var ModesGlyphHoverWidget = /** @class */ (function (_super) {
    __extends$t(ModesGlyphHoverWidget, _super);
    function ModesGlyphHoverWidget(editor, markdownRenderer) {
        var _this = _super.call(this, ModesGlyphHoverWidget.ID, editor) || this;
        _this._lastLineNumber = -1;
        _this._markdownRenderer = markdownRenderer;
        _this._computer = new MarginComputer(_this._editor);
        _this._hoverOperation = new HoverOperation(_this._computer, function (result) { return _this._withResult(result); }, null, function (result) { return _this._withResult(result); });
        return _this;
    }
    ModesGlyphHoverWidget.prototype.dispose = function () {
        this._renderDisposeables = dispose(this._renderDisposeables);
        this._hoverOperation.cancel();
        _super.prototype.dispose.call(this);
    };
    ModesGlyphHoverWidget.prototype.onModelDecorationsChanged = function () {
        if (this.isVisible) {
            // The decorations have changed and the hover is visible,
            // we need to recompute the displayed text
            this._hoverOperation.cancel();
            this._computer.clearResult();
            this._hoverOperation.start();
        }
    };
    ModesGlyphHoverWidget.prototype.startShowingAt = function (lineNumber) {
        if (this._lastLineNumber === lineNumber) {
            // We have to show the widget at the exact same line number as before, so no work is needed
            return;
        }
        this._hoverOperation.cancel();
        this.hide();
        this._lastLineNumber = lineNumber;
        this._computer.setLineNumber(lineNumber);
        this._hoverOperation.start();
    };
    ModesGlyphHoverWidget.prototype.hide = function () {
        this._lastLineNumber = -1;
        this._hoverOperation.cancel();
        _super.prototype.hide.call(this);
    };
    ModesGlyphHoverWidget.prototype._withResult = function (result) {
        this._messages = result;
        if (this._messages.length > 0) {
            this._renderMessages(this._lastLineNumber, this._messages);
        }
        else {
            this.hide();
        }
    };
    ModesGlyphHoverWidget.prototype._renderMessages = function (lineNumber, messages) {
        var _this = this;
        dispose(this._renderDisposeables);
        this._renderDisposeables = [];
        var fragment = document.createDocumentFragment();
        messages.forEach(function (msg) {
            var renderedContents = _this._markdownRenderer.render(msg.value);
            _this._renderDisposeables.push(renderedContents);
            fragment.appendChild($('div.hover-row', null, renderedContents.element));
        });
        this.updateContents(fragment);
        this.showAt(lineNumber);
    };
    ModesGlyphHoverWidget.ID = 'editor.contrib.modesGlyphHoverWidget';
    return ModesGlyphHoverWidget;
}(GlyphHoverWidget));

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __decorate$b = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$b = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var MarkdownRenderer = /** @class */ (function () {
    function MarkdownRenderer(_editor, _modeService, _openerService) {
        if (_openerService === void 0) { _openerService = NullOpenerService; }
        this._editor = _editor;
        this._modeService = _modeService;
        this._openerService = _openerService;
        this._onDidRenderCodeBlock = new Emitter();
        this.onDidRenderCodeBlock = this._onDidRenderCodeBlock.event;
    }
    MarkdownRenderer.prototype.getOptions = function (disposeables) {
        var _this = this;
        return {
            codeBlockRenderer: function (languageAlias, value) {
                // In markdown,
                // it is possible that we stumble upon language aliases (e.g.js instead of javascript)
                // it is possible no alias is given in which case we fall back to the current editor lang
                var modeId = languageAlias
                    ? _this._modeService.getModeIdForLanguageName(languageAlias)
                    : _this._editor.getModel().getLanguageIdentifier().language;
                return _this._modeService.getOrCreateMode(modeId).then(function (_) {
                    return tokenizeToString(value, modeId);
                }).then(function (code) {
                    return "<span style=\"font-family: " + _this._editor.getConfiguration().fontInfo.fontFamily + "\">" + code + "</span>";
                });
            },
            codeBlockRenderCallback: function () { return _this._onDidRenderCodeBlock.fire(); },
            actionHandler: {
                callback: function (content) {
                    _this._openerService.open(URI.parse(content)).then(void 0, onUnexpectedError);
                },
                disposeables: disposeables
            }
        };
    };
    MarkdownRenderer.prototype.render = function (markdown) {
        var disposeables = [];
        var element;
        if (!markdown) {
            element = document.createElement('span');
        }
        else {
            element = renderMarkdown(markdown, this.getOptions(disposeables));
        }
        return {
            element: element,
            dispose: function () { return dispose(disposeables); }
        };
    };
    MarkdownRenderer = __decorate$b([
        __param$b(1, IModeService),
        __param$b(2, optional(IOpenerService))
    ], MarkdownRenderer);
    return MarkdownRenderer;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$u = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate$c = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$c = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var ModesHoverController = /** @class */ (function () {
    function ModesHoverController(editor, _openerService, _modeService, _themeService) {
        var _this = this;
        this._openerService = _openerService;
        this._modeService = _modeService;
        this._themeService = _themeService;
        this._editor = editor;
        this._toUnhook = [];
        this._isMouseDown = false;
        if (editor.getConfiguration().contribInfo.hover) {
            this._toUnhook.push(this._editor.onMouseDown(function (e) { return _this._onEditorMouseDown(e); }));
            this._toUnhook.push(this._editor.onMouseUp(function (e) { return _this._onEditorMouseUp(e); }));
            this._toUnhook.push(this._editor.onMouseMove(function (e) { return _this._onEditorMouseMove(e); }));
            this._toUnhook.push(this._editor.onMouseLeave(function (e) { return _this._hideWidgets(); }));
            this._toUnhook.push(this._editor.onKeyDown(function (e) { return _this._onKeyDown(e); }));
            this._toUnhook.push(this._editor.onDidChangeModel(function () { return _this._hideWidgets(); }));
            this._toUnhook.push(this._editor.onDidChangeModelDecorations(function () { return _this._onModelDecorationsChanged(); }));
            this._toUnhook.push(this._editor.onDidScrollChange(function (e) {
                if (e.scrollTopChanged || e.scrollLeftChanged) {
                    _this._hideWidgets();
                }
            }));
        }
    }
    Object.defineProperty(ModesHoverController.prototype, "contentWidget", {
        get: function () {
            if (!this._contentWidget) {
                this._createHoverWidget();
            }
            return this._contentWidget;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ModesHoverController.prototype, "glyphWidget", {
        get: function () {
            if (!this._glyphWidget) {
                this._createHoverWidget();
            }
            return this._glyphWidget;
        },
        enumerable: true,
        configurable: true
    });
    ModesHoverController.get = function (editor) {
        return editor.getContribution(ModesHoverController.ID);
    };
    ModesHoverController.prototype._onModelDecorationsChanged = function () {
        this.contentWidget.onModelDecorationsChanged();
        this.glyphWidget.onModelDecorationsChanged();
    };
    ModesHoverController.prototype._onEditorMouseDown = function (mouseEvent) {
        this._isMouseDown = true;
        var targetType = mouseEvent.target.type;
        if (targetType === MouseTargetType.CONTENT_WIDGET && mouseEvent.target.detail === ModesContentHoverWidget.ID) {
            this._hoverClicked = true;
            // mouse down on top of content hover widget
            return;
        }
        if (targetType === MouseTargetType.OVERLAY_WIDGET && mouseEvent.target.detail === ModesGlyphHoverWidget.ID) {
            // mouse down on top of overlay hover widget
            return;
        }
        if (targetType !== MouseTargetType.OVERLAY_WIDGET && mouseEvent.target.detail !== ModesGlyphHoverWidget.ID) {
            this._hoverClicked = false;
        }
        this._hideWidgets();
    };
    ModesHoverController.prototype._onEditorMouseUp = function (mouseEvent) {
        this._isMouseDown = false;
    };
    ModesHoverController.prototype._onEditorMouseMove = function (mouseEvent) {
        var targetType = mouseEvent.target.type;
        var stopKey = isMacintosh ? 'metaKey' : 'ctrlKey';
        if (this._isMouseDown && this._hoverClicked && this.contentWidget.isColorPickerVisible()) {
            return;
        }
        if (targetType === MouseTargetType.CONTENT_WIDGET && mouseEvent.target.detail === ModesContentHoverWidget.ID && !mouseEvent.event[stopKey]) {
            // mouse moved on top of content hover widget
            return;
        }
        if (targetType === MouseTargetType.OVERLAY_WIDGET && mouseEvent.target.detail === ModesGlyphHoverWidget.ID && !mouseEvent.event[stopKey]) {
            // mouse moved on top of overlay hover widget
            return;
        }
        if (targetType === MouseTargetType.CONTENT_EMPTY) {
            var epsilon = this._editor.getConfiguration().fontInfo.typicalHalfwidthCharacterWidth / 2;
            var data = mouseEvent.target.detail;
            if (data && !data.isAfterLines && typeof data.horizontalDistanceToText === 'number' && data.horizontalDistanceToText < epsilon) {
                // Let hover kick in even when the mouse is technically in the empty area after a line, given the distance is small enough
                targetType = MouseTargetType.CONTENT_TEXT;
            }
        }
        if (this._editor.getConfiguration().contribInfo.hover && targetType === MouseTargetType.CONTENT_TEXT) {
            this.glyphWidget.hide();
            this.contentWidget.startShowingAt(mouseEvent.target.range, false);
        }
        else if (targetType === MouseTargetType.GUTTER_GLYPH_MARGIN) {
            this.contentWidget.hide();
            this.glyphWidget.startShowingAt(mouseEvent.target.position.lineNumber);
        }
        else {
            this._hideWidgets();
        }
    };
    ModesHoverController.prototype._onKeyDown = function (e) {
        if (e.keyCode !== 5 /* Ctrl */ && e.keyCode !== 6 /* Alt */ && e.keyCode !== 57 /* Meta */) {
            // Do not hide hover when Ctrl/Meta is pressed
            this._hideWidgets();
        }
    };
    ModesHoverController.prototype._hideWidgets = function () {
        if (!this._contentWidget || (this._isMouseDown && this._hoverClicked && this._contentWidget.isColorPickerVisible())) {
            return;
        }
        this._glyphWidget.hide();
        this._contentWidget.hide();
    };
    ModesHoverController.prototype._createHoverWidget = function () {
        var renderer = new MarkdownRenderer(this._editor, this._modeService, this._openerService);
        this._contentWidget = new ModesContentHoverWidget(this._editor, renderer, this._themeService);
        this._glyphWidget = new ModesGlyphHoverWidget(this._editor, renderer);
    };
    ModesHoverController.prototype.showContentHover = function (range$$1, focus) {
        this.contentWidget.startShowingAt(range$$1, focus);
    };
    ModesHoverController.prototype.getId = function () {
        return ModesHoverController.ID;
    };
    ModesHoverController.prototype.dispose = function () {
        this._toUnhook = dispose(this._toUnhook);
        if (this._glyphWidget) {
            this._glyphWidget.dispose();
            this._glyphWidget = null;
        }
        if (this._contentWidget) {
            this._contentWidget.dispose();
            this._contentWidget = null;
        }
    };
    ModesHoverController.ID = 'editor.contrib.hover';
    ModesHoverController = __decorate$c([
        __param$c(1, IOpenerService),
        __param$c(2, IModeService),
        __param$c(3, IThemeService)
    ], ModesHoverController);
    return ModesHoverController;
}());
var ShowHoverAction = /** @class */ (function (_super) {
    __extends$u(ShowHoverAction, _super);
    function ShowHoverAction() {
        return _super.call(this, {
            id: 'editor.action.showHover',
            label: localize({
                key: 'showHover',
                comment: [
                    'Label for action that will trigger the showing of a hover in the editor.',
                    'This allows for users to show the hover without using the mouse.'
                ]
            }, "Show Hover"),
            alias: 'Show Hover',
            precondition: null,
            kbOpts: {
                kbExpr: EditorContextKeys.editorTextFocus,
                primary: KeyChord(2048 /* CtrlCmd */ | 41 /* KEY_K */, 2048 /* CtrlCmd */ | 39 /* KEY_I */)
            }
        }) || this;
    }
    ShowHoverAction.prototype.run = function (accessor, editor) {
        var controller = ModesHoverController.get(editor);
        if (!controller) {
            return;
        }
        var position = editor.getPosition();
        var range$$1 = new Range(position.lineNumber, position.column, position.lineNumber, position.column);
        controller.showContentHover(range$$1, true);
    };
    return ShowHoverAction;
}(EditorAction));
registerEditorContribution(ModesHoverController);
registerEditorAction(ShowHoverAction);
// theming
registerThemingParticipant(function (theme, collector) {
    var editorHoverHighlightColor = theme.getColor(editorHoverHighlight);
    if (editorHoverHighlightColor) {
        collector.addRule(".monaco-editor .hoverHighlight { background-color: " + editorHoverHighlightColor + "; }");
    }
    var hoverBackground = theme.getColor(editorHoverBackground);
    if (hoverBackground) {
        collector.addRule(".monaco-editor .monaco-editor-hover { background-color: " + hoverBackground + "; }");
    }
    var hoverBorder = theme.getColor(editorHoverBorder);
    if (hoverBorder) {
        collector.addRule(".monaco-editor .monaco-editor-hover { border: 1px solid " + hoverBorder + "; }");
        collector.addRule(".monaco-editor .monaco-editor-hover .hover-row:not(:first-child):not(:empty) { border-top: 1px solid " + hoverBorder.transparent(0.5) + "; }");
    }
    var link = theme.getColor(textLinkForeground);
    if (link) {
        collector.addRule(".monaco-editor .monaco-editor-hover a { color: " + link + "; }");
    }
    var codeBackground = theme.getColor(textCodeBlockBackground);
    if (codeBackground) {
        collector.addRule(".monaco-editor .monaco-editor-hover code { background-color: " + codeBackground + "; }");
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var InPlaceReplaceCommand = /** @class */ (function () {
    function InPlaceReplaceCommand(editRange, originalSelection, text) {
        this._editRange = editRange;
        this._originalSelection = originalSelection;
        this._text = text;
    }
    InPlaceReplaceCommand.prototype.getEditOperations = function (model, builder) {
        builder.addTrackedEditOperation(this._editRange, this._text);
    };
    InPlaceReplaceCommand.prototype.computeCursorState = function (model, helper) {
        var inverseEditOperations = helper.getInverseEditOperations();
        var srcRange = inverseEditOperations[0].range;
        if (!this._originalSelection.isEmpty()) {
            // Preserve selection and extends to typed text
            return new Selection(srcRange.endLineNumber, srcRange.endColumn - this._text.length, srcRange.endLineNumber, srcRange.endColumn);
        }
        return new Selection(srcRange.endLineNumber, Math.min(this._originalSelection.positionColumn, srcRange.endColumn), srcRange.endLineNumber, Math.min(this._originalSelection.positionColumn, srcRange.endColumn));
    };
    return InPlaceReplaceCommand;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$v = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate$d = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$d = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var InPlaceReplaceController = /** @class */ (function () {
    function InPlaceReplaceController(editor, editorWorkerService) {
        this.editor = editor;
        this.editorWorkerService = editorWorkerService;
        this.currentRequest = TPromise.as(null);
        this.decorationRemover = TPromise.as(null);
        this.decorationIds = [];
    }
    InPlaceReplaceController.get = function (editor) {
        return editor.getContribution(InPlaceReplaceController.ID);
    };
    InPlaceReplaceController.prototype.dispose = function () {
    };
    InPlaceReplaceController.prototype.getId = function () {
        return InPlaceReplaceController.ID;
    };
    InPlaceReplaceController.prototype.run = function (source, up) {
        var _this = this;
        // cancel any pending request
        this.currentRequest.cancel();
        var selection = this.editor.getSelection(), model = this.editor.getModel(), modelURI = model.uri;
        if (selection.startLineNumber !== selection.endLineNumber) {
            // Can't accept multiline selection
            return null;
        }
        var state = new EditorState(this.editor, 1 /* Value */ | 4 /* Position */);
        if (!this.editorWorkerService.canNavigateValueSet(modelURI)) {
            this.currentRequest = TPromise.as(null);
        }
        else {
            this.currentRequest = this.editorWorkerService.navigateValueSet(modelURI, selection, up);
            this.currentRequest = this.currentRequest.then(function (basicResult) {
                if (basicResult && basicResult.range && basicResult.value) {
                    return basicResult;
                }
                return null;
            });
        }
        return this.currentRequest.then(function (result) {
            if (!result || !result.range || !result.value) {
                // No proper result
                return;
            }
            if (!state.validate(_this.editor)) {
                // state has changed
                return;
            }
            // Selection
            var editRange = Range.lift(result.range), highlightRange = result.range, diff = result.value.length - (selection.endColumn - selection.startColumn);
            // highlight
            highlightRange = {
                startLineNumber: highlightRange.startLineNumber,
                startColumn: highlightRange.startColumn,
                endLineNumber: highlightRange.endLineNumber,
                endColumn: highlightRange.startColumn + result.value.length
            };
            if (diff > 1) {
                selection = new Selection(selection.startLineNumber, selection.startColumn, selection.endLineNumber, selection.endColumn + diff - 1);
            }
            // Insert new text
            var command = new InPlaceReplaceCommand(editRange, selection, result.value);
            _this.editor.pushUndoStop();
            _this.editor.executeCommand(source, command);
            _this.editor.pushUndoStop();
            // add decoration
            _this.decorationIds = _this.editor.deltaDecorations(_this.decorationIds, [{
                    range: highlightRange,
                    options: InPlaceReplaceController.DECORATION
                }]);
            // remove decoration after delay
            _this.decorationRemover.cancel();
            _this.decorationRemover = TPromise.timeout(350);
            _this.decorationRemover.then(function () {
                _this.decorationIds = _this.editor.deltaDecorations(_this.decorationIds, []);
            });
        });
    };
    InPlaceReplaceController.ID = 'editor.contrib.inPlaceReplaceController';
    InPlaceReplaceController.DECORATION = ModelDecorationOptions.register({
        className: 'valueSetReplacement'
    });
    InPlaceReplaceController = __decorate$d([
        __param$d(1, IEditorWorkerService)
    ], InPlaceReplaceController);
    return InPlaceReplaceController;
}());
var InPlaceReplaceUp = /** @class */ (function (_super) {
    __extends$v(InPlaceReplaceUp, _super);
    function InPlaceReplaceUp() {
        return _super.call(this, {
            id: 'editor.action.inPlaceReplace.up',
            label: localize('InPlaceReplaceAction.previous.label', "Replace with Previous Value"),
            alias: 'Replace with Previous Value',
            precondition: EditorContextKeys.writable,
            kbOpts: {
                kbExpr: EditorContextKeys.editorTextFocus,
                primary: 2048 /* CtrlCmd */ | 1024 /* Shift */ | 82 /* US_COMMA */
            }
        }) || this;
    }
    InPlaceReplaceUp.prototype.run = function (accessor, editor) {
        var controller = InPlaceReplaceController.get(editor);
        if (!controller) {
            return undefined;
        }
        return controller.run(this.id, true);
    };
    return InPlaceReplaceUp;
}(EditorAction));
var InPlaceReplaceDown = /** @class */ (function (_super) {
    __extends$v(InPlaceReplaceDown, _super);
    function InPlaceReplaceDown() {
        return _super.call(this, {
            id: 'editor.action.inPlaceReplace.down',
            label: localize('InPlaceReplaceAction.next.label', "Replace with Next Value"),
            alias: 'Replace with Next Value',
            precondition: EditorContextKeys.writable,
            kbOpts: {
                kbExpr: EditorContextKeys.editorTextFocus,
                primary: 2048 /* CtrlCmd */ | 1024 /* Shift */ | 84 /* US_DOT */
            }
        }) || this;
    }
    InPlaceReplaceDown.prototype.run = function (accessor, editor) {
        var controller = InPlaceReplaceController.get(editor);
        if (!controller) {
            return undefined;
        }
        return controller.run(this.id, false);
    };
    return InPlaceReplaceDown;
}(EditorAction));
registerEditorContribution(InPlaceReplaceController);
registerEditorAction(InPlaceReplaceUp);
registerEditorAction(InPlaceReplaceDown);
registerThemingParticipant(function (theme, collector) {
    var border = theme.getColor(editorBracketMatchBorder);
    if (border) {
        collector.addRule(".monaco-editor.vs .valueSetReplacement { outline: solid 2px " + border + "; }");
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var SortLinesCommand = /** @class */ (function () {
    function SortLinesCommand(selection, descending) {
        this.selection = selection;
        this.descending = descending;
    }
    SortLinesCommand.prototype.getEditOperations = function (model, builder) {
        var op = sortLines(model, this.selection, this.descending);
        if (op) {
            builder.addEditOperation(op.range, op.text);
        }
        this.selectionId = builder.trackSelection(this.selection);
    };
    SortLinesCommand.prototype.computeCursorState = function (model, helper) {
        return helper.getTrackedSelection(this.selectionId);
    };
    SortLinesCommand.canRun = function (model, selection, descending) {
        var data = getSortData(model, selection, descending);
        if (!data) {
            return false;
        }
        for (var i = 0, len = data.before.length; i < len; i++) {
            if (data.before[i] !== data.after[i]) {
                return true;
            }
        }
        return false;
    };
    return SortLinesCommand;
}());
function getSortData(model, selection, descending) {
    var startLineNumber = selection.startLineNumber;
    var endLineNumber = selection.endLineNumber;
    if (selection.endColumn === 1) {
        endLineNumber--;
    }
    // Nothing to sort if user didn't select anything.
    if (startLineNumber >= endLineNumber) {
        return null;
    }
    var linesToSort = [];
    // Get the contents of the selection to be sorted.
    for (var lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {
        linesToSort.push(model.getLineContent(lineNumber));
    }
    var sorted = linesToSort.slice(0);
    sorted.sort(function (a, b) {
        return a.toLowerCase().localeCompare(b.toLowerCase());
    });
    // If descending, reverse the order.
    if (descending === true) {
        sorted = sorted.reverse();
    }
    return {
        startLineNumber: startLineNumber,
        endLineNumber: endLineNumber,
        before: linesToSort,
        after: sorted
    };
}
/**
 * Generate commands for sorting lines on a model.
 */
function sortLines(model, selection, descending) {
    var data = getSortData(model, selection, descending);
    if (!data) {
        return null;
    }
    return EditOperation.replace(new Range(data.startLineNumber, 1, data.endLineNumber, model.getLineMaxColumn(data.endLineNumber)), data.after.join('\n'));
}

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var TrimTrailingWhitespaceCommand = /** @class */ (function () {
    function TrimTrailingWhitespaceCommand(selection, cursors) {
        this.selection = selection;
        this.cursors = cursors;
    }
    TrimTrailingWhitespaceCommand.prototype.getEditOperations = function (model, builder) {
        var ops = trimTrailingWhitespace(model, this.cursors);
        for (var i = 0, len = ops.length; i < len; i++) {
            var op = ops[i];
            builder.addEditOperation(op.range, op.text);
        }
        this.selectionId = builder.trackSelection(this.selection);
    };
    TrimTrailingWhitespaceCommand.prototype.computeCursorState = function (model, helper) {
        return helper.getTrackedSelection(this.selectionId);
    };
    return TrimTrailingWhitespaceCommand;
}());
/**
 * Generate commands for trimming trailing whitespace on a model and ignore lines on which cursors are sitting.
 */
function trimTrailingWhitespace(model, cursors) {
    // Sort cursors ascending
    cursors.sort(function (a, b) {
        if (a.lineNumber === b.lineNumber) {
            return a.column - b.column;
        }
        return a.lineNumber - b.lineNumber;
    });
    // Reduce multiple cursors on the same line and only keep the last one on the line
    for (var i = cursors.length - 2; i >= 0; i--) {
        if (cursors[i].lineNumber === cursors[i + 1].lineNumber) {
            // Remove cursor at `i`
            cursors.splice(i, 1);
        }
    }
    var r = [];
    var rLen = 0;
    var cursorIndex = 0;
    var cursorLen = cursors.length;
    for (var lineNumber = 1, lineCount = model.getLineCount(); lineNumber <= lineCount; lineNumber++) {
        var lineContent = model.getLineContent(lineNumber);
        var maxLineColumn = lineContent.length + 1;
        var minEditColumn = 0;
        if (cursorIndex < cursorLen && cursors[cursorIndex].lineNumber === lineNumber) {
            minEditColumn = cursors[cursorIndex].column;
            cursorIndex++;
            if (minEditColumn === maxLineColumn) {
                // The cursor is at the end of the line => no edits for sure on this line
                continue;
            }
        }
        if (lineContent.length === 0) {
            continue;
        }
        var lastNonWhitespaceIndex$$1 = lastNonWhitespaceIndex(lineContent);
        var fromColumn = 0;
        if (lastNonWhitespaceIndex$$1 === -1) {
            // Entire line is whitespace
            fromColumn = 1;
        }
        else if (lastNonWhitespaceIndex$$1 !== lineContent.length - 1) {
            // There is trailing whitespace
            fromColumn = lastNonWhitespaceIndex$$1 + 2;
        }
        else {
            // There is no trailing whitespace
            continue;
        }
        fromColumn = Math.max(minEditColumn, fromColumn);
        r[rLen++] = EditOperation.delete(new Range(lineNumber, fromColumn, lineNumber, maxLineColumn));
    }
    return r;
}

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var CopyLinesCommand = /** @class */ (function () {
    function CopyLinesCommand(selection, isCopyingDown) {
        this._selection = selection;
        this._isCopyingDown = isCopyingDown;
    }
    CopyLinesCommand.prototype.getEditOperations = function (model, builder) {
        var s = this._selection;
        this._startLineNumberDelta = 0;
        this._endLineNumberDelta = 0;
        if (s.startLineNumber < s.endLineNumber && s.endColumn === 1) {
            this._endLineNumberDelta = 1;
            s = s.setEndPosition(s.endLineNumber - 1, model.getLineMaxColumn(s.endLineNumber - 1));
        }
        var sourceLines = [];
        for (var i = s.startLineNumber; i <= s.endLineNumber; i++) {
            sourceLines.push(model.getLineContent(i));
        }
        var sourceText = sourceLines.join('\n');
        if (sourceText === '') {
            // Duplicating empty line
            if (this._isCopyingDown) {
                this._startLineNumberDelta++;
                this._endLineNumberDelta++;
            }
        }
        if (!this._isCopyingDown) {
            builder.addEditOperation(new Range(s.endLineNumber, model.getLineMaxColumn(s.endLineNumber), s.endLineNumber, model.getLineMaxColumn(s.endLineNumber)), '\n' + sourceText);
        }
        else {
            builder.addEditOperation(new Range(s.startLineNumber, 1, s.startLineNumber, 1), sourceText + '\n');
        }
        this._selectionId = builder.trackSelection(s);
        this._selectionDirection = this._selection.getDirection();
    };
    CopyLinesCommand.prototype.computeCursorState = function (model, helper) {
        var result = helper.getTrackedSelection(this._selectionId);
        if (this._startLineNumberDelta !== 0 || this._endLineNumberDelta !== 0) {
            var startLineNumber = result.startLineNumber, startColumn = result.startColumn, endLineNumber = result.endLineNumber, endColumn = result.endColumn;
            if (this._startLineNumberDelta !== 0) {
                startLineNumber = startLineNumber + this._startLineNumberDelta;
                startColumn = 1;
            }
            if (this._endLineNumberDelta !== 0) {
                endLineNumber = endLineNumber + this._endLineNumberDelta;
                endColumn = 1;
            }
            result = Selection.createWithDirection(startLineNumber, startColumn, endLineNumber, endColumn, this._selectionDirection);
        }
        return result;
    };
    return CopyLinesCommand;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var DeleteLinesCommand = /** @class */ (function () {
    function DeleteLinesCommand(startLineNumber, endLineNumber, restoreCursorToColumn) {
        this.startLineNumber = startLineNumber;
        this.endLineNumber = endLineNumber;
        this.restoreCursorToColumn = restoreCursorToColumn;
    }
    DeleteLinesCommand.prototype.getEditOperations = function (model, builder) {
        if (model.getLineCount() === 1 && model.getLineMaxColumn(1) === 1) {
            // Model is empty
            return;
        }
        var startLineNumber = this.startLineNumber;
        var endLineNumber = this.endLineNumber;
        var startColumn = 1;
        var endColumn = model.getLineMaxColumn(endLineNumber);
        if (endLineNumber < model.getLineCount()) {
            endLineNumber += 1;
            endColumn = 1;
        }
        else if (startLineNumber > 1) {
            startLineNumber -= 1;
            startColumn = model.getLineMaxColumn(startLineNumber);
        }
        builder.addTrackedEditOperation(new Range(startLineNumber, startColumn, endLineNumber, endColumn), null);
    };
    DeleteLinesCommand.prototype.computeCursorState = function (model, helper) {
        var inverseEditOperations = helper.getInverseEditOperations();
        var srcRange = inverseEditOperations[0].range;
        return new Selection(srcRange.endLineNumber, this.restoreCursorToColumn, srcRange.endLineNumber, this.restoreCursorToColumn);
    };
    return DeleteLinesCommand;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
function getSpaceCnt(str, tabSize) {
    var spacesCnt = 0;
    for (var i = 0; i < str.length; i++) {
        if (str.charAt(i) === '\t') {
            spacesCnt += tabSize;
        }
        else {
            spacesCnt++;
        }
    }
    return spacesCnt;
}
function generateIndent(spacesCnt, tabSize, insertSpaces) {
    spacesCnt = spacesCnt < 0 ? 0 : spacesCnt;
    var result = '';
    if (!insertSpaces) {
        var tabsCnt = Math.floor(spacesCnt / tabSize);
        spacesCnt = spacesCnt % tabSize;
        for (var i = 0; i < tabsCnt; i++) {
            result += '\t';
        }
    }
    for (var i = 0; i < spacesCnt; i++) {
        result += ' ';
    }
    return result;
}

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var MoveLinesCommand = /** @class */ (function () {
    function MoveLinesCommand(selection, isMovingDown, autoIndent) {
        this._selection = selection;
        this._isMovingDown = isMovingDown;
        this._autoIndent = autoIndent;
        this._moveEndLineSelectionShrink = false;
    }
    MoveLinesCommand.prototype.getEditOperations = function (model, builder) {
        var modelLineCount = model.getLineCount();
        if (this._isMovingDown && this._selection.endLineNumber === modelLineCount) {
            return;
        }
        if (!this._isMovingDown && this._selection.startLineNumber === 1) {
            return;
        }
        this._moveEndPositionDown = false;
        var s = this._selection;
        if (s.startLineNumber < s.endLineNumber && s.endColumn === 1) {
            this._moveEndPositionDown = true;
            s = s.setEndPosition(s.endLineNumber - 1, model.getLineMaxColumn(s.endLineNumber - 1));
        }
        var tabSize = model.getOptions().tabSize;
        var insertSpaces = model.getOptions().insertSpaces;
        var indentConverter = this.buildIndentConverter(tabSize);
        var virtualModel = {
            getLineTokens: function (lineNumber) {
                return model.getLineTokens(lineNumber);
            },
            getLanguageIdentifier: function () {
                return model.getLanguageIdentifier();
            },
            getLanguageIdAtPosition: function (lineNumber, column) {
                return model.getLanguageIdAtPosition(lineNumber, column);
            },
            getLineContent: null
        };
        if (s.startLineNumber === s.endLineNumber && model.getLineMaxColumn(s.startLineNumber) === 1) {
            // Current line is empty
            var lineNumber = s.startLineNumber;
            var otherLineNumber = (this._isMovingDown ? lineNumber + 1 : lineNumber - 1);
            if (model.getLineMaxColumn(otherLineNumber) === 1) {
                // Other line number is empty too, so no editing is needed
                // Add a no-op to force running by the model
                builder.addEditOperation(new Range(1, 1, 1, 1), null);
            }
            else {
                // Type content from other line number on line number
                builder.addEditOperation(new Range(lineNumber, 1, lineNumber, 1), model.getLineContent(otherLineNumber));
                // Remove content from other line number
                builder.addEditOperation(new Range(otherLineNumber, 1, otherLineNumber, model.getLineMaxColumn(otherLineNumber)), null);
            }
            // Track selection at the other line number
            s = new Selection(otherLineNumber, 1, otherLineNumber, 1);
        }
        else {
            var movingLineNumber, movingLineText;
            if (this._isMovingDown) {
                movingLineNumber = s.endLineNumber + 1;
                movingLineText = model.getLineContent(movingLineNumber);
                // Delete line that needs to be moved
                builder.addEditOperation(new Range(movingLineNumber - 1, model.getLineMaxColumn(movingLineNumber - 1), movingLineNumber, model.getLineMaxColumn(movingLineNumber)), null);
                var insertingText_1 = movingLineText;
                if (this.shouldAutoIndent(model, s)) {
                    var movingLineMatchResult = this.matchEnterRule(model, indentConverter, tabSize, movingLineNumber, s.startLineNumber - 1);
                    // if s.startLineNumber - 1 matches onEnter rule, we still honor that.
                    if (movingLineMatchResult !== null) {
                        var oldIndentation = getLeadingWhitespace(model.getLineContent(movingLineNumber));
                        var newSpaceCnt = movingLineMatchResult + getSpaceCnt(oldIndentation, tabSize);
                        var newIndentation = generateIndent(newSpaceCnt, tabSize, insertSpaces);
                        insertingText_1 = newIndentation + this.trimLeft(movingLineText);
                    }
                    else {
                        // no enter rule matches, let's check indentatin rules then.
                        virtualModel.getLineContent = function (lineNumber) {
                            if (lineNumber === s.startLineNumber) {
                                return model.getLineContent(movingLineNumber);
                            }
                            else {
                                return model.getLineContent(lineNumber);
                            }
                        };
                        var indentOfMovingLine = LanguageConfigurationRegistry.getGoodIndentForLine(virtualModel, model.getLanguageIdAtPosition(movingLineNumber, 1), s.startLineNumber, indentConverter);
                        if (indentOfMovingLine !== null) {
                            var oldIndentation = getLeadingWhitespace(model.getLineContent(movingLineNumber));
                            var newSpaceCnt = getSpaceCnt(indentOfMovingLine, tabSize);
                            var oldSpaceCnt = getSpaceCnt(oldIndentation, tabSize);
                            if (newSpaceCnt !== oldSpaceCnt) {
                                var newIndentation = generateIndent(newSpaceCnt, tabSize, insertSpaces);
                                insertingText_1 = newIndentation + this.trimLeft(movingLineText);
                            }
                        }
                    }
                    // add edit operations for moving line first to make sure it's executed after we make indentation change
                    // to s.startLineNumber
                    builder.addEditOperation(new Range(s.startLineNumber, 1, s.startLineNumber, 1), insertingText_1 + '\n');
                    var ret = this.matchEnterRule(model, indentConverter, tabSize, s.startLineNumber, s.startLineNumber, insertingText_1);
                    // check if the line being moved before matches onEnter rules, if so let's adjust the indentation by onEnter rules.
                    if (ret !== null) {
                        if (ret !== 0) {
                            this.getIndentEditsOfMovingBlock(model, builder, s, tabSize, insertSpaces, ret);
                        }
                    }
                    else {
                        // it doesn't match onEnter rules, let's check indentation rules then.
                        virtualModel.getLineContent = function (lineNumber) {
                            if (lineNumber === s.startLineNumber) {
                                return insertingText_1;
                            }
                            else if (lineNumber >= s.startLineNumber + 1 && lineNumber <= s.endLineNumber + 1) {
                                return model.getLineContent(lineNumber - 1);
                            }
                            else {
                                return model.getLineContent(lineNumber);
                            }
                        };
                        var newIndentatOfMovingBlock = LanguageConfigurationRegistry.getGoodIndentForLine(virtualModel, model.getLanguageIdAtPosition(movingLineNumber, 1), s.startLineNumber + 1, indentConverter);
                        if (newIndentatOfMovingBlock !== null) {
                            var oldIndentation = getLeadingWhitespace(model.getLineContent(s.startLineNumber));
                            var newSpaceCnt = getSpaceCnt(newIndentatOfMovingBlock, tabSize);
                            var oldSpaceCnt = getSpaceCnt(oldIndentation, tabSize);
                            if (newSpaceCnt !== oldSpaceCnt) {
                                var spaceCntOffset = newSpaceCnt - oldSpaceCnt;
                                this.getIndentEditsOfMovingBlock(model, builder, s, tabSize, insertSpaces, spaceCntOffset);
                            }
                        }
                    }
                }
                else {
                    // Insert line that needs to be moved before
                    builder.addEditOperation(new Range(s.startLineNumber, 1, s.startLineNumber, 1), insertingText_1 + '\n');
                }
            }
            else {
                movingLineNumber = s.startLineNumber - 1;
                movingLineText = model.getLineContent(movingLineNumber);
                // Delete line that needs to be moved
                builder.addEditOperation(new Range(movingLineNumber, 1, movingLineNumber + 1, 1), null);
                // Insert line that needs to be moved after
                builder.addEditOperation(new Range(s.endLineNumber, model.getLineMaxColumn(s.endLineNumber), s.endLineNumber, model.getLineMaxColumn(s.endLineNumber)), '\n' + movingLineText);
                if (this.shouldAutoIndent(model, s)) {
                    virtualModel.getLineContent = function (lineNumber) {
                        if (lineNumber === movingLineNumber) {
                            return model.getLineContent(s.startLineNumber);
                        }
                        else {
                            return model.getLineContent(lineNumber);
                        }
                    };
                    var ret = this.matchEnterRule(model, indentConverter, tabSize, s.startLineNumber, s.startLineNumber - 2);
                    // check if s.startLineNumber - 2 matches onEnter rules, if so adjust the moving block by onEnter rules.
                    if (ret !== null) {
                        if (ret !== 0) {
                            this.getIndentEditsOfMovingBlock(model, builder, s, tabSize, insertSpaces, ret);
                        }
                    }
                    else {
                        // it doesn't match any onEnter rule, let's check indentation rules then.
                        var indentOfFirstLine = LanguageConfigurationRegistry.getGoodIndentForLine(virtualModel, model.getLanguageIdAtPosition(s.startLineNumber, 1), movingLineNumber, indentConverter);
                        if (indentOfFirstLine !== null) {
                            // adjust the indentation of the moving block
                            var oldIndent = getLeadingWhitespace(model.getLineContent(s.startLineNumber));
                            var newSpaceCnt = getSpaceCnt(indentOfFirstLine, tabSize);
                            var oldSpaceCnt = getSpaceCnt(oldIndent, tabSize);
                            if (newSpaceCnt !== oldSpaceCnt) {
                                var spaceCntOffset = newSpaceCnt - oldSpaceCnt;
                                this.getIndentEditsOfMovingBlock(model, builder, s, tabSize, insertSpaces, spaceCntOffset);
                            }
                        }
                    }
                }
            }
        }
        this._selectionId = builder.trackSelection(s);
    };
    MoveLinesCommand.prototype.buildIndentConverter = function (tabSize) {
        return {
            shiftIndent: function (indentation) {
                var desiredIndentCount = ShiftCommand.shiftIndentCount(indentation, indentation.length + 1, tabSize);
                var newIndentation = '';
                for (var i = 0; i < desiredIndentCount; i++) {
                    newIndentation += '\t';
                }
                return newIndentation;
            },
            unshiftIndent: function (indentation) {
                var desiredIndentCount = ShiftCommand.unshiftIndentCount(indentation, indentation.length + 1, tabSize);
                var newIndentation = '';
                for (var i = 0; i < desiredIndentCount; i++) {
                    newIndentation += '\t';
                }
                return newIndentation;
            }
        };
    };
    MoveLinesCommand.prototype.matchEnterRule = function (model, indentConverter, tabSize, line, oneLineAbove, oneLineAboveText) {
        var validPrecedingLine = oneLineAbove;
        while (validPrecedingLine >= 1) {
            // ship empty lines as empty lines just inherit indentation
            var lineContent = void 0;
            if (validPrecedingLine === oneLineAbove && oneLineAboveText !== undefined) {
                lineContent = oneLineAboveText;
            }
            else {
                lineContent = model.getLineContent(validPrecedingLine);
            }
            var nonWhitespaceIdx = lastNonWhitespaceIndex(lineContent);
            if (nonWhitespaceIdx >= 0) {
                break;
            }
            validPrecedingLine--;
        }
        if (validPrecedingLine < 1 || line > model.getLineCount()) {
            return null;
        }
        var maxColumn = model.getLineMaxColumn(validPrecedingLine);
        var enter = LanguageConfigurationRegistry.getEnterAction(model, new Range(validPrecedingLine, maxColumn, validPrecedingLine, maxColumn));
        if (enter) {
            var enterPrefix = enter.indentation;
            var enterAction = enter.enterAction;
            if (enterAction.indentAction === IndentAction.None) {
                enterPrefix = enter.indentation + enterAction.appendText;
            }
            else if (enterAction.indentAction === IndentAction.Indent) {
                enterPrefix = enter.indentation + enterAction.appendText;
            }
            else if (enterAction.indentAction === IndentAction.IndentOutdent) {
                enterPrefix = enter.indentation;
            }
            else if (enterAction.indentAction === IndentAction.Outdent) {
                enterPrefix = indentConverter.unshiftIndent(enter.indentation) + enterAction.appendText;
            }
            var movingLineText = model.getLineContent(line);
            if (this.trimLeft(movingLineText).indexOf(this.trimLeft(enterPrefix)) >= 0) {
                var oldIndentation = getLeadingWhitespace(model.getLineContent(line));
                var newIndentation = getLeadingWhitespace(enterPrefix);
                var indentMetadataOfMovelingLine = LanguageConfigurationRegistry.getIndentMetadata(model, line);
                if (indentMetadataOfMovelingLine & 2 /* DECREASE_MASK */) {
                    newIndentation = indentConverter.unshiftIndent(newIndentation);
                }
                var newSpaceCnt = getSpaceCnt(newIndentation, tabSize);
                var oldSpaceCnt = getSpaceCnt(oldIndentation, tabSize);
                return newSpaceCnt - oldSpaceCnt;
            }
        }
        return null;
    };
    MoveLinesCommand.prototype.trimLeft = function (str) {
        return str.replace(/^\s+/, '');
    };
    MoveLinesCommand.prototype.shouldAutoIndent = function (model, selection) {
        if (!this._autoIndent) {
            return false;
        }
        // if it's not easy to tokenize, we stop auto indent.
        if (!model.isCheapToTokenize(selection.startLineNumber)) {
            return false;
        }
        var languageAtSelectionStart = model.getLanguageIdAtPosition(selection.startLineNumber, 1);
        var languageAtSelectionEnd = model.getLanguageIdAtPosition(selection.endLineNumber, 1);
        if (languageAtSelectionStart !== languageAtSelectionEnd) {
            return false;
        }
        if (LanguageConfigurationRegistry.getIndentRulesSupport(languageAtSelectionStart) === null) {
            return false;
        }
        return true;
    };
    MoveLinesCommand.prototype.getIndentEditsOfMovingBlock = function (model, builder, s, tabSize, insertSpaces, offset) {
        for (var i = s.startLineNumber; i <= s.endLineNumber; i++) {
            var lineContent = model.getLineContent(i);
            var originalIndent = getLeadingWhitespace(lineContent);
            var originalSpacesCnt = getSpaceCnt(originalIndent, tabSize);
            var newSpacesCnt = originalSpacesCnt + offset;
            var newIndent = generateIndent(newSpacesCnt, tabSize, insertSpaces);
            if (newIndent !== originalIndent) {
                builder.addEditOperation(new Range(i, 1, i, originalIndent.length + 1), newIndent);
                if (i === s.endLineNumber && s.endColumn <= originalIndent.length + 1 && newIndent === '') {
                    // as users select part of the original indent white spaces
                    // when we adjust the indentation of endLine, we should adjust the cursor position as well.
                    this._moveEndLineSelectionShrink = true;
                }
            }
        }
    };
    MoveLinesCommand.prototype.computeCursorState = function (model, helper) {
        var result = helper.getTrackedSelection(this._selectionId);
        if (this._moveEndPositionDown) {
            result = result.setEndPosition(result.endLineNumber + 1, 1);
        }
        if (this._moveEndLineSelectionShrink && result.startLineNumber < result.endLineNumber) {
            result = result.setEndPosition(result.endLineNumber, 2);
        }
        return result;
    };
    return MoveLinesCommand;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$w = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
// copy lines
var AbstractCopyLinesAction = /** @class */ (function (_super) {
    __extends$w(AbstractCopyLinesAction, _super);
    function AbstractCopyLinesAction(down, opts) {
        var _this = _super.call(this, opts) || this;
        _this.down = down;
        return _this;
    }
    AbstractCopyLinesAction.prototype.run = function (accessor, editor) {
        var commands = [];
        var selections = editor.getSelections();
        for (var i = 0; i < selections.length; i++) {
            commands.push(new CopyLinesCommand(selections[i], this.down));
        }
        editor.pushUndoStop();
        editor.executeCommands(this.id, commands);
        editor.pushUndoStop();
    };
    return AbstractCopyLinesAction;
}(EditorAction));
var CopyLinesUpAction = /** @class */ (function (_super) {
    __extends$w(CopyLinesUpAction, _super);
    function CopyLinesUpAction() {
        return _super.call(this, false, {
            id: 'editor.action.copyLinesUpAction',
            label: localize('lines.copyUp', "Copy Line Up"),
            alias: 'Copy Line Up',
            precondition: EditorContextKeys.writable,
            kbOpts: {
                kbExpr: EditorContextKeys.editorTextFocus,
                primary: 512 /* Alt */ | 1024 /* Shift */ | 16 /* UpArrow */,
                linux: { primary: 2048 /* CtrlCmd */ | 512 /* Alt */ | 1024 /* Shift */ | 16 /* UpArrow */ }
            }
        }) || this;
    }
    return CopyLinesUpAction;
}(AbstractCopyLinesAction));
var CopyLinesDownAction = /** @class */ (function (_super) {
    __extends$w(CopyLinesDownAction, _super);
    function CopyLinesDownAction() {
        return _super.call(this, true, {
            id: 'editor.action.copyLinesDownAction',
            label: localize('lines.copyDown', "Copy Line Down"),
            alias: 'Copy Line Down',
            precondition: EditorContextKeys.writable,
            kbOpts: {
                kbExpr: EditorContextKeys.editorTextFocus,
                primary: 512 /* Alt */ | 1024 /* Shift */ | 18 /* DownArrow */,
                linux: { primary: 2048 /* CtrlCmd */ | 512 /* Alt */ | 1024 /* Shift */ | 18 /* DownArrow */ }
            }
        }) || this;
    }
    return CopyLinesDownAction;
}(AbstractCopyLinesAction));
// move lines
var AbstractMoveLinesAction = /** @class */ (function (_super) {
    __extends$w(AbstractMoveLinesAction, _super);
    function AbstractMoveLinesAction(down, opts) {
        var _this = _super.call(this, opts) || this;
        _this.down = down;
        return _this;
    }
    AbstractMoveLinesAction.prototype.run = function (accessor, editor) {
        var commands = [];
        var selections = editor.getSelections();
        var autoIndent = editor.getConfiguration().autoIndent;
        for (var i = 0; i < selections.length; i++) {
            commands.push(new MoveLinesCommand(selections[i], this.down, autoIndent));
        }
        editor.pushUndoStop();
        editor.executeCommands(this.id, commands);
        editor.pushUndoStop();
    };
    return AbstractMoveLinesAction;
}(EditorAction));
var MoveLinesUpAction = /** @class */ (function (_super) {
    __extends$w(MoveLinesUpAction, _super);
    function MoveLinesUpAction() {
        return _super.call(this, false, {
            id: 'editor.action.moveLinesUpAction',
            label: localize('lines.moveUp', "Move Line Up"),
            alias: 'Move Line Up',
            precondition: EditorContextKeys.writable,
            kbOpts: {
                kbExpr: EditorContextKeys.editorTextFocus,
                primary: 512 /* Alt */ | 16 /* UpArrow */,
                linux: { primary: 512 /* Alt */ | 16 /* UpArrow */ }
            }
        }) || this;
    }
    return MoveLinesUpAction;
}(AbstractMoveLinesAction));
var MoveLinesDownAction = /** @class */ (function (_super) {
    __extends$w(MoveLinesDownAction, _super);
    function MoveLinesDownAction() {
        return _super.call(this, true, {
            id: 'editor.action.moveLinesDownAction',
            label: localize('lines.moveDown', "Move Line Down"),
            alias: 'Move Line Down',
            precondition: EditorContextKeys.writable,
            kbOpts: {
                kbExpr: EditorContextKeys.editorTextFocus,
                primary: 512 /* Alt */ | 18 /* DownArrow */,
                linux: { primary: 512 /* Alt */ | 18 /* DownArrow */ }
            }
        }) || this;
    }
    return MoveLinesDownAction;
}(AbstractMoveLinesAction));
var AbstractSortLinesAction = /** @class */ (function (_super) {
    __extends$w(AbstractSortLinesAction, _super);
    function AbstractSortLinesAction(descending, opts) {
        var _this = _super.call(this, opts) || this;
        _this.descending = descending;
        return _this;
    }
    AbstractSortLinesAction.prototype.run = function (accessor, editor) {
        var selections = editor.getSelections();
        for (var i = 0, len = selections.length; i < len; i++) {
            var selection = selections[i];
            if (!SortLinesCommand.canRun(editor.getModel(), selection, this.descending)) {
                return;
            }
        }
        var commands = [];
        for (var i = 0, len = selections.length; i < len; i++) {
            commands[i] = new SortLinesCommand(selections[i], this.descending);
        }
        editor.pushUndoStop();
        editor.executeCommands(this.id, commands);
        editor.pushUndoStop();
    };
    return AbstractSortLinesAction;
}(EditorAction));
var SortLinesAscendingAction = /** @class */ (function (_super) {
    __extends$w(SortLinesAscendingAction, _super);
    function SortLinesAscendingAction() {
        return _super.call(this, false, {
            id: 'editor.action.sortLinesAscending',
            label: localize('lines.sortAscending', "Sort Lines Ascending"),
            alias: 'Sort Lines Ascending',
            precondition: EditorContextKeys.writable
        }) || this;
    }
    return SortLinesAscendingAction;
}(AbstractSortLinesAction));
var SortLinesDescendingAction = /** @class */ (function (_super) {
    __extends$w(SortLinesDescendingAction, _super);
    function SortLinesDescendingAction() {
        return _super.call(this, true, {
            id: 'editor.action.sortLinesDescending',
            label: localize('lines.sortDescending', "Sort Lines Descending"),
            alias: 'Sort Lines Descending',
            precondition: EditorContextKeys.writable
        }) || this;
    }
    return SortLinesDescendingAction;
}(AbstractSortLinesAction));
var TrimTrailingWhitespaceAction = /** @class */ (function (_super) {
    __extends$w(TrimTrailingWhitespaceAction, _super);
    function TrimTrailingWhitespaceAction() {
        return _super.call(this, {
            id: TrimTrailingWhitespaceAction.ID,
            label: localize('lines.trimTrailingWhitespace', "Trim Trailing Whitespace"),
            alias: 'Trim Trailing Whitespace',
            precondition: EditorContextKeys.writable,
            kbOpts: {
                kbExpr: EditorContextKeys.editorTextFocus,
                primary: KeyChord(2048 /* CtrlCmd */ | 41 /* KEY_K */, 2048 /* CtrlCmd */ | 54 /* KEY_X */)
            }
        }) || this;
    }
    TrimTrailingWhitespaceAction.prototype.run = function (accessor, editor, args) {
        var cursors = [];
        if (args.reason === 'auto-save') {
            // See https://github.com/editorconfig/editorconfig-vscode/issues/47
            // It is very convenient for the editor config extension to invoke this action.
            // So, if we get a reason:'auto-save' passed in, let's preserve cursor positions.
            cursors = editor.getSelections().map(function (s) { return new Position(s.positionLineNumber, s.positionColumn); });
        }
        var command = new TrimTrailingWhitespaceCommand(editor.getSelection(), cursors);
        editor.pushUndoStop();
        editor.executeCommands(this.id, [command]);
        editor.pushUndoStop();
    };
    TrimTrailingWhitespaceAction.ID = 'editor.action.trimTrailingWhitespace';
    return TrimTrailingWhitespaceAction;
}(EditorAction));
var AbstractRemoveLinesAction = /** @class */ (function (_super) {
    __extends$w(AbstractRemoveLinesAction, _super);
    function AbstractRemoveLinesAction() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    AbstractRemoveLinesAction.prototype._getLinesToRemove = function (editor) {
        // Construct delete operations
        var operations = editor.getSelections().map(function (s) {
            var endLineNumber = s.endLineNumber;
            if (s.startLineNumber < s.endLineNumber && s.endColumn === 1) {
                endLineNumber -= 1;
            }
            return {
                startLineNumber: s.startLineNumber,
                endLineNumber: endLineNumber,
                positionColumn: s.positionColumn
            };
        });
        // Sort delete operations
        operations.sort(function (a, b) {
            return a.startLineNumber - b.startLineNumber;
        });
        // Merge delete operations on consecutive lines
        var mergedOperations = [];
        var previousOperation = operations[0];
        for (var i = 1; i < operations.length; i++) {
            if (previousOperation.endLineNumber + 1 === operations[i].startLineNumber) {
                // Merge current operations into the previous one
                previousOperation.endLineNumber = operations[i].endLineNumber;
            }
            else {
                // Push previous operation
                mergedOperations.push(previousOperation);
                previousOperation = operations[i];
            }
        }
        // Push the last operation
        mergedOperations.push(previousOperation);
        return mergedOperations;
    };
    return AbstractRemoveLinesAction;
}(EditorAction));
var DeleteLinesAction = /** @class */ (function (_super) {
    __extends$w(DeleteLinesAction, _super);
    function DeleteLinesAction() {
        return _super.call(this, {
            id: 'editor.action.deleteLines',
            label: localize('lines.delete', "Delete Line"),
            alias: 'Delete Line',
            precondition: EditorContextKeys.writable,
            kbOpts: {
                kbExpr: EditorContextKeys.textInputFocus,
                primary: 2048 /* CtrlCmd */ | 1024 /* Shift */ | 41 /* KEY_K */
            }
        }) || this;
    }
    DeleteLinesAction.prototype.run = function (accessor, editor) {
        var ops = this._getLinesToRemove(editor);
        // Finally, construct the delete lines commands
        var commands = ops.map(function (op) {
            return new DeleteLinesCommand(op.startLineNumber, op.endLineNumber, op.positionColumn);
        });
        editor.pushUndoStop();
        editor.executeCommands(this.id, commands);
        editor.pushUndoStop();
    };
    return DeleteLinesAction;
}(AbstractRemoveLinesAction));
var IndentLinesAction = /** @class */ (function (_super) {
    __extends$w(IndentLinesAction, _super);
    function IndentLinesAction() {
        return _super.call(this, {
            id: 'editor.action.indentLines',
            label: localize('lines.indent', "Indent Line"),
            alias: 'Indent Line',
            precondition: EditorContextKeys.writable,
            kbOpts: {
                kbExpr: EditorContextKeys.editorTextFocus,
                primary: 2048 /* CtrlCmd */ | 89 /* US_CLOSE_SQUARE_BRACKET */
            }
        }) || this;
    }
    IndentLinesAction.prototype.run = function (accessor, editor) {
        editor.pushUndoStop();
        editor.executeCommands(this.id, TypeOperations.indent(editor._getCursorConfiguration(), editor.getModel(), editor.getSelections()));
        editor.pushUndoStop();
    };
    return IndentLinesAction;
}(EditorAction));
var OutdentLinesAction = /** @class */ (function (_super) {
    __extends$w(OutdentLinesAction, _super);
    function OutdentLinesAction() {
        return _super.call(this, {
            id: 'editor.action.outdentLines',
            label: localize('lines.outdent', "Outdent Line"),
            alias: 'Outdent Line',
            precondition: EditorContextKeys.writable,
            kbOpts: {
                kbExpr: EditorContextKeys.editorTextFocus,
                primary: 2048 /* CtrlCmd */ | 87 /* US_OPEN_SQUARE_BRACKET */
            }
        }) || this;
    }
    OutdentLinesAction.prototype.run = function (accessor, editor) {
        CoreEditingCommands.Outdent.runEditorCommand(null, editor, null);
    };
    return OutdentLinesAction;
}(EditorAction));
var InsertLineBeforeAction = /** @class */ (function (_super) {
    __extends$w(InsertLineBeforeAction, _super);
    function InsertLineBeforeAction() {
        return _super.call(this, {
            id: 'editor.action.insertLineBefore',
            label: localize('lines.insertBefore', "Insert Line Above"),
            alias: 'Insert Line Above',
            precondition: EditorContextKeys.writable,
            kbOpts: {
                kbExpr: EditorContextKeys.editorTextFocus,
                primary: 2048 /* CtrlCmd */ | 1024 /* Shift */ | 3 /* Enter */
            }
        }) || this;
    }
    InsertLineBeforeAction.prototype.run = function (accessor, editor) {
        editor.pushUndoStop();
        editor.executeCommands(this.id, TypeOperations.lineInsertBefore(editor._getCursorConfiguration(), editor.getModel(), editor.getSelections()));
    };
    return InsertLineBeforeAction;
}(EditorAction));
var InsertLineAfterAction = /** @class */ (function (_super) {
    __extends$w(InsertLineAfterAction, _super);
    function InsertLineAfterAction() {
        return _super.call(this, {
            id: 'editor.action.insertLineAfter',
            label: localize('lines.insertAfter', "Insert Line Below"),
            alias: 'Insert Line Below',
            precondition: EditorContextKeys.writable,
            kbOpts: {
                kbExpr: EditorContextKeys.editorTextFocus,
                primary: 2048 /* CtrlCmd */ | 3 /* Enter */
            }
        }) || this;
    }
    InsertLineAfterAction.prototype.run = function (accessor, editor) {
        editor.pushUndoStop();
        editor.executeCommands(this.id, TypeOperations.lineInsertAfter(editor._getCursorConfiguration(), editor.getModel(), editor.getSelections()));
    };
    return InsertLineAfterAction;
}(EditorAction));
var AbstractDeleteAllToBoundaryAction = /** @class */ (function (_super) {
    __extends$w(AbstractDeleteAllToBoundaryAction, _super);
    function AbstractDeleteAllToBoundaryAction() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    AbstractDeleteAllToBoundaryAction.prototype.run = function (accessor, editor) {
        var primaryCursor = editor.getSelection();
        var rangesToDelete = this._getRangesToDelete(editor);
        // merge overlapping selections
        var effectiveRanges = [];
        for (var i = 0, count = rangesToDelete.length - 1; i < count; i++) {
            var range$$1 = rangesToDelete[i];
            var nextRange = rangesToDelete[i + 1];
            if (Range.intersectRanges(range$$1, nextRange) === null) {
                effectiveRanges.push(range$$1);
            }
            else {
                rangesToDelete[i + 1] = Range.plusRange(range$$1, nextRange);
            }
        }
        effectiveRanges.push(rangesToDelete[rangesToDelete.length - 1]);
        var endCursorState = this._getEndCursorState(primaryCursor, effectiveRanges);
        var edits = effectiveRanges.map(function (range$$1) {
            endCursorState.push(new Selection(range$$1.startLineNumber, range$$1.startColumn, range$$1.startLineNumber, range$$1.startColumn));
            return EditOperation.replace(range$$1, '');
        });
        editor.pushUndoStop();
        editor.executeEdits(this.id, edits, endCursorState);
        editor.pushUndoStop();
    };
    return AbstractDeleteAllToBoundaryAction;
}(EditorAction));
var DeleteAllLeftAction = /** @class */ (function (_super) {
    __extends$w(DeleteAllLeftAction, _super);
    function DeleteAllLeftAction() {
        return _super.call(this, {
            id: 'deleteAllLeft',
            label: localize('lines.deleteAllLeft', "Delete All Left"),
            alias: 'Delete All Left',
            precondition: EditorContextKeys.writable,
            kbOpts: {
                kbExpr: EditorContextKeys.textInputFocus,
                primary: null,
                mac: { primary: 2048 /* CtrlCmd */ | 1 /* Backspace */ }
            }
        }) || this;
    }
    DeleteAllLeftAction.prototype._getEndCursorState = function (primaryCursor, rangesToDelete) {
        var endPrimaryCursor;
        var endCursorState = [];
        for (var i = 0, len = rangesToDelete.length; i < len; i++) {
            var range$$1 = rangesToDelete[i];
            var endCursor = new Selection(rangesToDelete[i].startLineNumber, rangesToDelete[i].startColumn, rangesToDelete[i].startLineNumber, rangesToDelete[i].startColumn);
            if (range$$1.intersectRanges(primaryCursor)) {
                endPrimaryCursor = endCursor;
            }
            else {
                endCursorState.push(endCursor);
            }
        }
        if (endPrimaryCursor) {
            endCursorState.unshift(endPrimaryCursor);
        }
        return endCursorState;
    };
    DeleteAllLeftAction.prototype._getRangesToDelete = function (editor) {
        var rangesToDelete = editor.getSelections();
        rangesToDelete.sort(Range.compareRangesUsingStarts);
        rangesToDelete = rangesToDelete.map(function (selection) {
            if (selection.isEmpty()) {
                return new Range(selection.startLineNumber, 1, selection.startLineNumber, selection.startColumn);
            }
            else {
                return selection;
            }
        });
        return rangesToDelete;
    };
    return DeleteAllLeftAction;
}(AbstractDeleteAllToBoundaryAction));
var DeleteAllRightAction = /** @class */ (function (_super) {
    __extends$w(DeleteAllRightAction, _super);
    function DeleteAllRightAction() {
        return _super.call(this, {
            id: 'deleteAllRight',
            label: localize('lines.deleteAllRight', "Delete All Right"),
            alias: 'Delete All Right',
            precondition: EditorContextKeys.writable,
            kbOpts: {
                kbExpr: EditorContextKeys.textInputFocus,
                primary: null,
                mac: { primary: 256 /* WinCtrl */ | 41 /* KEY_K */, secondary: [2048 /* CtrlCmd */ | 20 /* Delete */] }
            }
        }) || this;
    }
    DeleteAllRightAction.prototype._getEndCursorState = function (primaryCursor, rangesToDelete) {
        var endPrimaryCursor;
        var endCursorState = [];
        for (var i = 0, len = rangesToDelete.length, offset = 0; i < len; i++) {
            var range$$1 = rangesToDelete[i];
            var endCursor = new Selection(range$$1.startLineNumber - offset, range$$1.startColumn, range$$1.startLineNumber - offset, range$$1.startColumn);
            if (range$$1.intersectRanges(primaryCursor)) {
                endPrimaryCursor = endCursor;
            }
            else {
                endCursorState.push(endCursor);
            }
        }
        if (endPrimaryCursor) {
            endCursorState.unshift(endPrimaryCursor);
        }
        return endCursorState;
    };
    DeleteAllRightAction.prototype._getRangesToDelete = function (editor) {
        var model = editor.getModel();
        var rangesToDelete = editor.getSelections().map(function (sel) {
            if (sel.isEmpty()) {
                var maxColumn = model.getLineMaxColumn(sel.startLineNumber);
                if (sel.startColumn === maxColumn) {
                    return new Range(sel.startLineNumber, sel.startColumn, sel.startLineNumber + 1, 1);
                }
                else {
                    return new Range(sel.startLineNumber, sel.startColumn, sel.startLineNumber, maxColumn);
                }
            }
            return sel;
        });
        rangesToDelete.sort(Range.compareRangesUsingStarts);
        return rangesToDelete;
    };
    return DeleteAllRightAction;
}(AbstractDeleteAllToBoundaryAction));
var JoinLinesAction = /** @class */ (function (_super) {
    __extends$w(JoinLinesAction, _super);
    function JoinLinesAction() {
        return _super.call(this, {
            id: 'editor.action.joinLines',
            label: localize('lines.joinLines', "Join Lines"),
            alias: 'Join Lines',
            precondition: EditorContextKeys.writable,
            kbOpts: {
                kbExpr: EditorContextKeys.editorTextFocus,
                primary: 0,
                mac: { primary: 256 /* WinCtrl */ | 40 /* KEY_J */ }
            }
        }) || this;
    }
    JoinLinesAction.prototype.run = function (accessor, editor) {
        var selections = editor.getSelections();
        var primaryCursor = editor.getSelection();
        selections.sort(Range.compareRangesUsingStarts);
        var reducedSelections = [];
        var lastSelection = selections.reduce(function (previousValue, currentValue) {
            if (previousValue.isEmpty()) {
                if (previousValue.endLineNumber === currentValue.startLineNumber) {
                    if (primaryCursor.equalsSelection(previousValue)) {
                        primaryCursor = currentValue;
                    }
                    return currentValue;
                }
                if (currentValue.startLineNumber > previousValue.endLineNumber + 1) {
                    reducedSelections.push(previousValue);
                    return currentValue;
                }
                else {
                    return new Selection(previousValue.startLineNumber, previousValue.startColumn, currentValue.endLineNumber, currentValue.endColumn);
                }
            }
            else {
                if (currentValue.startLineNumber > previousValue.endLineNumber) {
                    reducedSelections.push(previousValue);
                    return currentValue;
                }
                else {
                    return new Selection(previousValue.startLineNumber, previousValue.startColumn, currentValue.endLineNumber, currentValue.endColumn);
                }
            }
        });
        reducedSelections.push(lastSelection);
        var model = editor.getModel();
        var edits = [];
        var endCursorState = [];
        var endPrimaryCursor = primaryCursor;
        var lineOffset = 0;
        for (var i = 0, len = reducedSelections.length; i < len; i++) {
            var selection = reducedSelections[i];
            var startLineNumber = selection.startLineNumber;
            var startColumn = 1;
            var endLineNumber = void 0, endColumn = void 0, columnDeltaOffset = void 0;
            var selectionEndPositionOffset = model.getLineContent(selection.endLineNumber).length - selection.endColumn;
            if (selection.isEmpty() || selection.startLineNumber === selection.endLineNumber) {
                var position = selection.getStartPosition();
                if (position.lineNumber < model.getLineCount()) {
                    endLineNumber = startLineNumber + 1;
                    endColumn = model.getLineMaxColumn(endLineNumber);
                }
                else {
                    endLineNumber = position.lineNumber;
                    endColumn = model.getLineMaxColumn(position.lineNumber);
                }
            }
            else {
                endLineNumber = selection.endLineNumber;
                endColumn = model.getLineMaxColumn(endLineNumber);
            }
            var trimmedLinesContent = model.getLineContent(startLineNumber);
            for (var i_1 = startLineNumber + 1; i_1 <= endLineNumber; i_1++) {
                var lineText = model.getLineContent(i_1);
                var firstNonWhitespaceIdx = model.getLineFirstNonWhitespaceColumn(i_1);
                if (firstNonWhitespaceIdx >= 1) {
                    var insertSpace = true;
                    if (trimmedLinesContent === '') {
                        insertSpace = false;
                    }
                    if (insertSpace && (trimmedLinesContent.charAt(trimmedLinesContent.length - 1) === ' ' ||
                        trimmedLinesContent.charAt(trimmedLinesContent.length - 1) === '\t')) {
                        insertSpace = false;
                        trimmedLinesContent = trimmedLinesContent.replace(/[\s\uFEFF\xA0]+$/g, ' ');
                    }
                    var lineTextWithoutIndent = lineText.substr(firstNonWhitespaceIdx - 1);
                    trimmedLinesContent += (insertSpace ? ' ' : '') + lineTextWithoutIndent;
                    if (insertSpace) {
                        columnDeltaOffset = lineTextWithoutIndent.length + 1;
                    }
                    else {
                        columnDeltaOffset = lineTextWithoutIndent.length;
                    }
                }
                else {
                    columnDeltaOffset = 0;
                }
            }
            var deleteSelection = new Range(startLineNumber, startColumn, endLineNumber, endColumn);
            if (!deleteSelection.isEmpty()) {
                var resultSelection = void 0;
                if (selection.isEmpty()) {
                    edits.push(EditOperation.replace(deleteSelection, trimmedLinesContent));
                    resultSelection = new Selection(deleteSelection.startLineNumber - lineOffset, trimmedLinesContent.length - columnDeltaOffset + 1, startLineNumber - lineOffset, trimmedLinesContent.length - columnDeltaOffset + 1);
                }
                else {
                    if (selection.startLineNumber === selection.endLineNumber) {
                        edits.push(EditOperation.replace(deleteSelection, trimmedLinesContent));
                        resultSelection = new Selection(selection.startLineNumber - lineOffset, selection.startColumn, selection.endLineNumber - lineOffset, selection.endColumn);
                    }
                    else {
                        edits.push(EditOperation.replace(deleteSelection, trimmedLinesContent));
                        resultSelection = new Selection(selection.startLineNumber - lineOffset, selection.startColumn, selection.startLineNumber - lineOffset, trimmedLinesContent.length - selectionEndPositionOffset);
                    }
                }
                if (Range.intersectRanges(deleteSelection, primaryCursor) !== null) {
                    endPrimaryCursor = resultSelection;
                }
                else {
                    endCursorState.push(resultSelection);
                }
            }
            lineOffset += deleteSelection.endLineNumber - deleteSelection.startLineNumber;
        }
        endCursorState.unshift(endPrimaryCursor);
        editor.pushUndoStop();
        editor.executeEdits(this.id, edits, endCursorState);
        editor.pushUndoStop();
    };
    return JoinLinesAction;
}(EditorAction));
var TransposeAction = /** @class */ (function (_super) {
    __extends$w(TransposeAction, _super);
    function TransposeAction() {
        return _super.call(this, {
            id: 'editor.action.transpose',
            label: localize('editor.transpose', "Transpose characters around the cursor"),
            alias: 'Transpose characters around the cursor',
            precondition: EditorContextKeys.writable
        }) || this;
    }
    TransposeAction.prototype.run = function (accessor, editor) {
        var selections = editor.getSelections();
        var model = editor.getModel();
        var commands = [];
        for (var i = 0, len = selections.length; i < len; i++) {
            var selection = selections[i];
            if (!selection.isEmpty()) {
                continue;
            }
            var cursor = selection.getStartPosition();
            var maxColumn = model.getLineMaxColumn(cursor.lineNumber);
            if (cursor.column >= maxColumn) {
                if (cursor.lineNumber === model.getLineCount()) {
                    continue;
                }
                // The cursor is at the end of current line and current line is not empty
                // then we transpose the character before the cursor and the line break if there is any following line.
                var deleteSelection = new Range(cursor.lineNumber, Math.max(1, cursor.column - 1), cursor.lineNumber + 1, 1);
                var chars = model.getValueInRange(deleteSelection).split('').reverse().join('');
                commands.push(new ReplaceCommand(new Selection(cursor.lineNumber, Math.max(1, cursor.column - 1), cursor.lineNumber + 1, 1), chars));
            }
            else {
                var deleteSelection = new Range(cursor.lineNumber, Math.max(1, cursor.column - 1), cursor.lineNumber, cursor.column + 1);
                var chars = model.getValueInRange(deleteSelection).split('').reverse().join('');
                commands.push(new ReplaceCommandThatPreservesSelection(deleteSelection, chars, new Selection(cursor.lineNumber, cursor.column + 1, cursor.lineNumber, cursor.column + 1)));
            }
        }
        editor.pushUndoStop();
        editor.executeCommands(this.id, commands);
        editor.pushUndoStop();
    };
    return TransposeAction;
}(EditorAction));
var AbstractCaseAction = /** @class */ (function (_super) {
    __extends$w(AbstractCaseAction, _super);
    function AbstractCaseAction() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    AbstractCaseAction.prototype.run = function (accessor, editor) {
        var selections = editor.getSelections();
        var model = editor.getModel();
        var commands = [];
        for (var i = 0, len = selections.length; i < len; i++) {
            var selection = selections[i];
            if (selection.isEmpty()) {
                var cursor = selection.getStartPosition();
                var word = model.getWordAtPosition(cursor);
                if (!word) {
                    continue;
                }
                var wordRange = new Range(cursor.lineNumber, word.startColumn, cursor.lineNumber, word.endColumn);
                var text = model.getValueInRange(wordRange);
                commands.push(new ReplaceCommandThatPreservesSelection(wordRange, this._modifyText(text), new Selection(cursor.lineNumber, cursor.column, cursor.lineNumber, cursor.column)));
            }
            else {
                var text = model.getValueInRange(selection);
                commands.push(new ReplaceCommandThatPreservesSelection(selection, this._modifyText(text), selection));
            }
        }
        editor.pushUndoStop();
        editor.executeCommands(this.id, commands);
        editor.pushUndoStop();
    };
    return AbstractCaseAction;
}(EditorAction));
var UpperCaseAction = /** @class */ (function (_super) {
    __extends$w(UpperCaseAction, _super);
    function UpperCaseAction() {
        return _super.call(this, {
            id: 'editor.action.transformToUppercase',
            label: localize('editor.transformToUppercase', "Transform to Uppercase"),
            alias: 'Transform to Uppercase',
            precondition: EditorContextKeys.writable
        }) || this;
    }
    UpperCaseAction.prototype._modifyText = function (text) {
        return text.toLocaleUpperCase();
    };
    return UpperCaseAction;
}(AbstractCaseAction));
var LowerCaseAction = /** @class */ (function (_super) {
    __extends$w(LowerCaseAction, _super);
    function LowerCaseAction() {
        return _super.call(this, {
            id: 'editor.action.transformToLowercase',
            label: localize('editor.transformToLowercase', "Transform to Lowercase"),
            alias: 'Transform to Lowercase',
            precondition: EditorContextKeys.writable
        }) || this;
    }
    LowerCaseAction.prototype._modifyText = function (text) {
        return text.toLocaleLowerCase();
    };
    return LowerCaseAction;
}(AbstractCaseAction));
registerEditorAction(CopyLinesUpAction);
registerEditorAction(CopyLinesDownAction);
registerEditorAction(MoveLinesUpAction);
registerEditorAction(MoveLinesDownAction);
registerEditorAction(SortLinesAscendingAction);
registerEditorAction(SortLinesDescendingAction);
registerEditorAction(TrimTrailingWhitespaceAction);
registerEditorAction(DeleteLinesAction);
registerEditorAction(IndentLinesAction);
registerEditorAction(OutdentLinesAction);
registerEditorAction(InsertLineBeforeAction);
registerEditorAction(InsertLineAfterAction);
registerEditorAction(DeleteAllLeftAction);
registerEditorAction(DeleteAllRightAction);
registerEditorAction(JoinLinesAction);
registerEditorAction(TransposeAction);
registerEditorAction(UpperCaseAction);
registerEditorAction(LowerCaseAction);

const css$k = "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n.monaco-editor .detected-link,\n.monaco-editor .detected-link-active {\n\ttext-decoration: underline;\n\ttext-underline-position: under;\n}\n\n.monaco-editor .detected-link-active {\n\tcursor: pointer;\n}\n";
  const element$k = ((css, src) => {
if (typeof document !== 'object')
console.info(`Skipped loading "${src}"`);
try {
const id = src
  .replace(/\.css.*$/, '')
  .replace(/[\\:]/g, '/')
  .replace(/[^\w\/]+/g, '');
return (
  document.querySelector(`style[id="${id}"]`) ||
  document.head.appendChild(
    Object.assign(document.createElement('style'), {
      id,
      textContent: `${css}\n\n /* sourceURL=${src} */`,
    }),
  )
);
} catch (exception) {
console.warn(`Failed load "${src}"`, exception);
}
})(css$k, "…monaco-editor/esm/vs/editor/contrib/links/links.css");
  //@ sourceURL=/Users/daflair/Projects/packages/monaco-es/node_modules/monaco-editor/esm/vs/editor/contrib/links/links.css

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var Link = /** @class */ (function () {
    function Link(link, provider) {
        this._link = link;
        this._provider = provider;
    }
    Link.prototype.toJSON = function () {
        return {
            range: this.range,
            url: this.url
        };
    };
    Object.defineProperty(Link.prototype, "range", {
        get: function () {
            return this._link.range;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Link.prototype, "url", {
        get: function () {
            return this._link.url;
        },
        enumerable: true,
        configurable: true
    });
    Link.prototype.resolve = function () {
        var _this = this;
        if (this._link.url) {
            try {
                return TPromise.as(URI.parse(this._link.url));
            }
            catch (e) {
                return TPromise.wrapError(new Error('invalid'));
            }
        }
        if (typeof this._provider.resolveLink === 'function') {
            return asWinJsPromise(function (token) { return _this._provider.resolveLink(_this._link, token); }).then(function (value) {
                _this._link = value || _this._link;
                if (_this._link.url) {
                    // recurse
                    return _this.resolve();
                }
                return TPromise.wrapError(new Error('missing'));
            });
        }
        return TPromise.wrapError(new Error('missing'));
    };
    return Link;
}());
function getLinks(model) {
    var links = [];
    // ask all providers for links in parallel
    var promises = LinkProviderRegistry.ordered(model).reverse().map(function (provider) {
        return asWinJsPromise(function (token) { return provider.provideLinks(model, token); }).then(function (result) {
            if (Array.isArray(result)) {
                var newLinks = result.map(function (link) { return new Link(link, provider); });
                links = union(links, newLinks);
            }
        }, onUnexpectedExternalError);
    });
    return TPromise.join(promises).then(function () {
        return links;
    });
}
function union(oldLinks, newLinks) {
    // reunite oldLinks with newLinks and remove duplicates
    var result = [], oldIndex, oldLen, newIndex, newLen, oldLink, newLink, comparisonResult;
    for (oldIndex = 0, newIndex = 0, oldLen = oldLinks.length, newLen = newLinks.length; oldIndex < oldLen && newIndex < newLen;) {
        oldLink = oldLinks[oldIndex];
        newLink = newLinks[newIndex];
        if (Range.areIntersectingOrTouching(oldLink.range, newLink.range)) {
            // Remove the oldLink
            oldIndex++;
            continue;
        }
        comparisonResult = Range.compareRangesUsingStarts(oldLink.range, newLink.range);
        if (comparisonResult < 0) {
            // oldLink is before
            result.push(oldLink);
            oldIndex++;
        }
        else {
            // newLink is before
            result.push(newLink);
            newIndex++;
        }
    }
    for (; oldIndex < oldLen; oldIndex++) {
        result.push(oldLinks[oldIndex]);
    }
    for (; newIndex < newLen; newIndex++) {
        result.push(newLinks[newIndex]);
    }
    return result;
}
CommandsRegistry.registerCommand('_executeLinkProvider', function (accessor) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
    }
    var uri = args[0];
    if (!(uri instanceof URI)) {
        return undefined;
    }
    var model = accessor.get(IModelService).getModel(uri);
    if (!model) {
        return undefined;
    }
    return getLinks(model);
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$x = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate$e = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$e = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var HOVER_MESSAGE_GENERAL_META = new MarkdownString().appendText(isMacintosh
    ? localize('links.navigate.mac', "Cmd + click to follow link")
    : localize('links.navigate', "Ctrl + click to follow link"));
var HOVER_MESSAGE_COMMAND_META = new MarkdownString().appendText(isMacintosh
    ? localize('links.command.mac', "Cmd + click to execute command")
    : localize('links.command', "Ctrl + click to execute command"));
var HOVER_MESSAGE_GENERAL_ALT = new MarkdownString().appendText(isMacintosh
    ? localize('links.navigate.al.mac', "Option + click to follow link")
    : localize('links.navigate.al', "Alt + click to follow link"));
var HOVER_MESSAGE_COMMAND_ALT = new MarkdownString().appendText(isMacintosh
    ? localize('links.command.al.mac', "Option + click to execute command")
    : localize('links.command.al', "Alt + click to execute command"));
var decoration = {
    meta: ModelDecorationOptions.register({
        stickiness: TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges,
        inlineClassName: 'detected-link',
        hoverMessage: HOVER_MESSAGE_GENERAL_META
    }),
    metaActive: ModelDecorationOptions.register({
        stickiness: TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges,
        inlineClassName: 'detected-link-active',
        hoverMessage: HOVER_MESSAGE_GENERAL_META
    }),
    alt: ModelDecorationOptions.register({
        stickiness: TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges,
        inlineClassName: 'detected-link',
        hoverMessage: HOVER_MESSAGE_GENERAL_ALT
    }),
    altActive: ModelDecorationOptions.register({
        stickiness: TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges,
        inlineClassName: 'detected-link-active',
        hoverMessage: HOVER_MESSAGE_GENERAL_ALT
    }),
    altCommand: ModelDecorationOptions.register({
        stickiness: TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges,
        inlineClassName: 'detected-link',
        hoverMessage: HOVER_MESSAGE_COMMAND_ALT
    }),
    altCommandActive: ModelDecorationOptions.register({
        stickiness: TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges,
        inlineClassName: 'detected-link-active',
        hoverMessage: HOVER_MESSAGE_COMMAND_ALT
    }),
    metaCommand: ModelDecorationOptions.register({
        stickiness: TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges,
        inlineClassName: 'detected-link',
        hoverMessage: HOVER_MESSAGE_COMMAND_META
    }),
    metaCommandActive: ModelDecorationOptions.register({
        stickiness: TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges,
        inlineClassName: 'detected-link-active',
        hoverMessage: HOVER_MESSAGE_COMMAND_META
    }),
};
var LinkOccurrence = /** @class */ (function () {
    function LinkOccurrence(link, decorationId) {
        this.link = link;
        this.decorationId = decorationId;
    }
    LinkOccurrence.decoration = function (link, useMetaKey) {
        return {
            range: link.range,
            options: LinkOccurrence._getOptions(link, useMetaKey, false)
        };
    };
    LinkOccurrence._getOptions = function (link, useMetaKey, isActive) {
        if (/^command:/i.test(link.url)) {
            if (useMetaKey) {
                return (isActive ? decoration.metaCommandActive : decoration.metaCommand);
            }
            else {
                return (isActive ? decoration.altCommandActive : decoration.altCommand);
            }
        }
        else {
            if (useMetaKey) {
                return (isActive ? decoration.metaActive : decoration.meta);
            }
            else {
                return (isActive ? decoration.altActive : decoration.alt);
            }
        }
    };
    LinkOccurrence.prototype.activate = function (changeAccessor, useMetaKey) {
        changeAccessor.changeDecorationOptions(this.decorationId, LinkOccurrence._getOptions(this.link, useMetaKey, true));
    };
    LinkOccurrence.prototype.deactivate = function (changeAccessor, useMetaKey) {
        changeAccessor.changeDecorationOptions(this.decorationId, LinkOccurrence._getOptions(this.link, useMetaKey, false));
    };
    return LinkOccurrence;
}());
var LinkDetector = /** @class */ (function () {
    function LinkDetector(editor, openerService, notificationService) {
        var _this = this;
        this.editor = editor;
        this.openerService = openerService;
        this.notificationService = notificationService;
        this.listenersToRemove = [];
        var clickLinkGesture = new ClickLinkGesture(editor);
        this.listenersToRemove.push(clickLinkGesture);
        this.listenersToRemove.push(clickLinkGesture.onMouseMoveOrRelevantKeyDown(function (_a) {
            var mouseEvent = _a[0], keyboardEvent = _a[1];
            _this._onEditorMouseMove(mouseEvent, keyboardEvent);
        }));
        this.listenersToRemove.push(clickLinkGesture.onExecute(function (e) {
            _this.onEditorMouseUp(e);
        }));
        this.listenersToRemove.push(clickLinkGesture.onCancel(function (e) {
            _this.cleanUpActiveLinkDecoration();
        }));
        this.enabled = editor.getConfiguration().contribInfo.links;
        this.listenersToRemove.push(editor.onDidChangeConfiguration(function (e) {
            var enabled = editor.getConfiguration().contribInfo.links;
            if (_this.enabled === enabled) {
                // No change in our configuration option
                return;
            }
            _this.enabled = enabled;
            // Remove any links (for the getting disabled case)
            _this.updateDecorations([]);
            // Stop any computation (for the getting disabled case)
            _this.stop();
            // Start computing (for the getting enabled case)
            _this.beginCompute();
        }));
        this.listenersToRemove.push(editor.onDidChangeModelContent(function (e) { return _this.onChange(); }));
        this.listenersToRemove.push(editor.onDidChangeModel(function (e) { return _this.onModelChanged(); }));
        this.listenersToRemove.push(editor.onDidChangeModelLanguage(function (e) { return _this.onModelModeChanged(); }));
        this.listenersToRemove.push(LinkProviderRegistry.onDidChange(function (e) { return _this.onModelModeChanged(); }));
        this.timeoutPromise = null;
        this.computePromise = null;
        this.currentOccurrences = {};
        this.activeLinkDecorationId = null;
        this.beginCompute();
    }
    LinkDetector.get = function (editor) {
        return editor.getContribution(LinkDetector.ID);
    };
    LinkDetector.prototype.getId = function () {
        return LinkDetector.ID;
    };
    LinkDetector.prototype.onModelChanged = function () {
        this.currentOccurrences = {};
        this.activeLinkDecorationId = null;
        this.stop();
        this.beginCompute();
    };
    LinkDetector.prototype.onModelModeChanged = function () {
        this.stop();
        this.beginCompute();
    };
    LinkDetector.prototype.onChange = function () {
        var _this = this;
        if (!this.timeoutPromise) {
            this.timeoutPromise = TPromise.timeout(LinkDetector.RECOMPUTE_TIME);
            this.timeoutPromise.then(function () {
                _this.timeoutPromise = null;
                _this.beginCompute();
            });
        }
    };
    LinkDetector.prototype.beginCompute = function () {
        var _this = this;
        if (!this.editor.getModel() || !this.enabled) {
            return;
        }
        if (!LinkProviderRegistry.has(this.editor.getModel())) {
            return;
        }
        this.computePromise = getLinks(this.editor.getModel()).then(function (links) {
            _this.updateDecorations(links);
            _this.computePromise = null;
        });
    };
    LinkDetector.prototype.updateDecorations = function (links) {
        var useMetaKey = (this.editor.getConfiguration().multiCursorModifier === 'altKey');
        var oldDecorations = [];
        var keys = Object.keys(this.currentOccurrences);
        for (var i = 0, len = keys.length; i < len; i++) {
            var decorationId = keys[i];
            var occurance = this.currentOccurrences[decorationId];
            oldDecorations.push(occurance.decorationId);
        }
        var newDecorations = [];
        if (links) {
            // Not sure why this is sometimes null
            for (var i = 0; i < links.length; i++) {
                newDecorations.push(LinkOccurrence.decoration(links[i], useMetaKey));
            }
        }
        var decorations = this.editor.deltaDecorations(oldDecorations, newDecorations);
        this.currentOccurrences = {};
        this.activeLinkDecorationId = null;
        for (var i = 0, len = decorations.length; i < len; i++) {
            var occurance = new LinkOccurrence(links[i], decorations[i]);
            this.currentOccurrences[occurance.decorationId] = occurance;
        }
    };
    LinkDetector.prototype._onEditorMouseMove = function (mouseEvent, withKey) {
        var _this = this;
        var useMetaKey = (this.editor.getConfiguration().multiCursorModifier === 'altKey');
        if (this.isEnabled(mouseEvent, withKey)) {
            this.cleanUpActiveLinkDecoration(); // always remove previous link decoration as their can only be one
            var occurrence = this.getLinkOccurrence(mouseEvent.target.position);
            if (occurrence) {
                this.editor.changeDecorations(function (changeAccessor) {
                    occurrence.activate(changeAccessor, useMetaKey);
                    _this.activeLinkDecorationId = occurrence.decorationId;
                });
            }
        }
        else {
            this.cleanUpActiveLinkDecoration();
        }
    };
    LinkDetector.prototype.cleanUpActiveLinkDecoration = function () {
        var useMetaKey = (this.editor.getConfiguration().multiCursorModifier === 'altKey');
        if (this.activeLinkDecorationId) {
            var occurrence = this.currentOccurrences[this.activeLinkDecorationId];
            if (occurrence) {
                this.editor.changeDecorations(function (changeAccessor) {
                    occurrence.deactivate(changeAccessor, useMetaKey);
                });
            }
            this.activeLinkDecorationId = null;
        }
    };
    LinkDetector.prototype.onEditorMouseUp = function (mouseEvent) {
        if (!this.isEnabled(mouseEvent)) {
            return;
        }
        var occurrence = this.getLinkOccurrence(mouseEvent.target.position);
        if (!occurrence) {
            return;
        }
        this.openLinkOccurrence(occurrence, mouseEvent.hasSideBySideModifier);
    };
    LinkDetector.prototype.openLinkOccurrence = function (occurrence, openToSide) {
        var _this = this;
        if (!this.openerService) {
            return;
        }
        var link = occurrence.link;
        link.resolve().then(function (uri) {
            // open the uri
            return _this.openerService.open(uri, { openToSide: openToSide });
        }, function (err) {
            // different error cases
            if (err === 'invalid') {
                _this.notificationService.warn(localize('invalid.url', 'Failed to open this link because it is not well-formed: {0}', link.url));
            }
            else if (err === 'missing') {
                _this.notificationService.warn(localize('missing.url', 'Failed to open this link because its target is missing.'));
            }
            else {
                onUnexpectedError(err);
            }
        }).done(null, onUnexpectedError);
    };
    LinkDetector.prototype.getLinkOccurrence = function (position) {
        var decorations = this.editor.getModel().getDecorationsInRange({
            startLineNumber: position.lineNumber,
            startColumn: position.column,
            endLineNumber: position.lineNumber,
            endColumn: position.column
        }, 0, true);
        for (var i = 0; i < decorations.length; i++) {
            var decoration = decorations[i];
            var currentOccurrence = this.currentOccurrences[decoration.id];
            if (currentOccurrence) {
                return currentOccurrence;
            }
        }
        return null;
    };
    LinkDetector.prototype.isEnabled = function (mouseEvent, withKey) {
        return (mouseEvent.target.type === MouseTargetType.CONTENT_TEXT
            && (mouseEvent.hasTriggerModifier || (withKey && withKey.keyCodeIsTriggerKey)));
    };
    LinkDetector.prototype.stop = function () {
        if (this.timeoutPromise) {
            this.timeoutPromise.cancel();
            this.timeoutPromise = null;
        }
        if (this.computePromise) {
            this.computePromise.cancel();
            this.computePromise = null;
        }
    };
    LinkDetector.prototype.dispose = function () {
        this.listenersToRemove = dispose(this.listenersToRemove);
        this.stop();
    };
    LinkDetector.ID = 'editor.linkDetector';
    LinkDetector.RECOMPUTE_TIME = 1000; // ms
    LinkDetector = __decorate$e([
        __param$e(1, IOpenerService),
        __param$e(2, INotificationService)
    ], LinkDetector);
    return LinkDetector;
}());
var OpenLinkAction = /** @class */ (function (_super) {
    __extends$x(OpenLinkAction, _super);
    function OpenLinkAction() {
        return _super.call(this, {
            id: 'editor.action.openLink',
            label: localize('label', "Open Link"),
            alias: 'Open Link',
            precondition: null
        }) || this;
    }
    OpenLinkAction.prototype.run = function (accessor, editor) {
        var linkDetector = LinkDetector.get(editor);
        if (!linkDetector) {
            return;
        }
        var selections = editor.getSelections();
        for (var _i = 0, selections_1 = selections; _i < selections_1.length; _i++) {
            var sel = selections_1[_i];
            var link = linkDetector.getLinkOccurrence(sel.getEndPosition());
            if (link) {
                linkDetector.openLinkOccurrence(link, false);
            }
        }
    };
    return OpenLinkAction;
}(EditorAction));
registerEditorContribution(LinkDetector);
registerEditorAction(OpenLinkAction);
registerThemingParticipant(function (theme, collector) {
    var activeLinkForeground = theme.getColor(editorActiveLinkForeground);
    if (activeLinkForeground) {
        collector.addRule(".monaco-editor .detected-link-active { color: " + activeLinkForeground + " !important; }");
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$y = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var InsertCursorAbove = /** @class */ (function (_super) {
    __extends$y(InsertCursorAbove, _super);
    function InsertCursorAbove() {
        return _super.call(this, {
            id: 'editor.action.insertCursorAbove',
            label: localize('mutlicursor.insertAbove', "Add Cursor Above"),
            alias: 'Add Cursor Above',
            precondition: null,
            kbOpts: {
                kbExpr: EditorContextKeys.editorTextFocus,
                primary: 2048 /* CtrlCmd */ | 512 /* Alt */ | 16 /* UpArrow */,
                linux: {
                    primary: 1024 /* Shift */ | 512 /* Alt */ | 16 /* UpArrow */,
                    secondary: [2048 /* CtrlCmd */ | 1024 /* Shift */ | 16 /* UpArrow */]
                }
            }
        }) || this;
    }
    InsertCursorAbove.prototype.run = function (accessor, editor, args) {
        var cursors = editor._getCursors();
        var context = cursors.context;
        if (context.config.readOnly) {
            return;
        }
        context.model.pushStackElement();
        cursors.setStates(args.source, CursorChangeReason.Explicit, CursorMoveCommands.addCursorUp(context, cursors.getAll()));
        cursors.reveal(true, 1 /* TopMost */, 0 /* Smooth */);
    };
    return InsertCursorAbove;
}(EditorAction));
var InsertCursorBelow = /** @class */ (function (_super) {
    __extends$y(InsertCursorBelow, _super);
    function InsertCursorBelow() {
        return _super.call(this, {
            id: 'editor.action.insertCursorBelow',
            label: localize('mutlicursor.insertBelow', "Add Cursor Below"),
            alias: 'Add Cursor Below',
            precondition: null,
            kbOpts: {
                kbExpr: EditorContextKeys.editorTextFocus,
                primary: 2048 /* CtrlCmd */ | 512 /* Alt */ | 18 /* DownArrow */,
                linux: {
                    primary: 1024 /* Shift */ | 512 /* Alt */ | 18 /* DownArrow */,
                    secondary: [2048 /* CtrlCmd */ | 1024 /* Shift */ | 18 /* DownArrow */]
                }
            }
        }) || this;
    }
    InsertCursorBelow.prototype.run = function (accessor, editor, args) {
        var cursors = editor._getCursors();
        var context = cursors.context;
        if (context.config.readOnly) {
            return;
        }
        context.model.pushStackElement();
        cursors.setStates(args.source, CursorChangeReason.Explicit, CursorMoveCommands.addCursorDown(context, cursors.getAll()));
        cursors.reveal(true, 2 /* BottomMost */, 0 /* Smooth */);
    };
    return InsertCursorBelow;
}(EditorAction));
var InsertCursorAtEndOfEachLineSelected = /** @class */ (function (_super) {
    __extends$y(InsertCursorAtEndOfEachLineSelected, _super);
    function InsertCursorAtEndOfEachLineSelected() {
        return _super.call(this, {
            id: 'editor.action.insertCursorAtEndOfEachLineSelected',
            label: localize('mutlicursor.insertAtEndOfEachLineSelected', "Add Cursors to Line Ends"),
            alias: 'Add Cursors to Line Ends',
            precondition: null,
            kbOpts: {
                kbExpr: EditorContextKeys.editorTextFocus,
                primary: 1024 /* Shift */ | 512 /* Alt */ | 39 /* KEY_I */
            }
        }) || this;
    }
    InsertCursorAtEndOfEachLineSelected.prototype.getCursorsForSelection = function (selection, model, result) {
        if (selection.isEmpty()) {
            return;
        }
        for (var i = selection.startLineNumber; i < selection.endLineNumber; i++) {
            var currentLineMaxColumn = model.getLineMaxColumn(i);
            result.push(new Selection(i, currentLineMaxColumn, i, currentLineMaxColumn));
        }
        if (selection.endColumn > 1) {
            result.push(new Selection(selection.endLineNumber, selection.endColumn, selection.endLineNumber, selection.endColumn));
        }
    };
    InsertCursorAtEndOfEachLineSelected.prototype.run = function (accessor, editor) {
        var _this = this;
        var model = editor.getModel();
        var selections = editor.getSelections();
        var newSelections = [];
        selections.forEach(function (sel) { return _this.getCursorsForSelection(sel, model, newSelections); });
        if (newSelections.length > 0) {
            editor.setSelections(newSelections);
        }
    };
    return InsertCursorAtEndOfEachLineSelected;
}(EditorAction));
var MultiCursorSessionResult = /** @class */ (function () {
    function MultiCursorSessionResult(selections, revealRange, revealScrollType) {
        this.selections = selections;
        this.revealRange = revealRange;
        this.revealScrollType = revealScrollType;
    }
    return MultiCursorSessionResult;
}());
var MultiCursorSession = /** @class */ (function () {
    function MultiCursorSession(_editor, findController, isDisconnectedFromFindController, searchText, wholeWord, matchCase, currentMatch) {
        this._editor = _editor;
        this.findController = findController;
        this.isDisconnectedFromFindController = isDisconnectedFromFindController;
        this.searchText = searchText;
        this.wholeWord = wholeWord;
        this.matchCase = matchCase;
        this.currentMatch = currentMatch;
    }
    MultiCursorSession.create = function (editor, findController) {
        var findState = findController.getState();
        // Find widget owns entirely what we search for if:
        //  - focus is not in the editor (i.e. it is in the find widget)
        //  - and the search widget is visible
        //  - and the search string is non-empty
        if (!editor.isFocused() && findState.isRevealed && findState.searchString.length > 0) {
            // Find widget owns what is searched for
            return new MultiCursorSession(editor, findController, false, findState.searchString, findState.wholeWord, findState.matchCase, null);
        }
        // Otherwise, the selection gives the search text, and the find widget gives the search settings
        // The exception is the find state disassociation case: when beginning with a single, collapsed selection
        var isDisconnectedFromFindController = false;
        var wholeWord;
        var matchCase;
        var selections = editor.getSelections();
        if (selections.length === 1 && selections[0].isEmpty()) {
            isDisconnectedFromFindController = true;
            wholeWord = true;
            matchCase = true;
        }
        else {
            wholeWord = findState.wholeWord;
            matchCase = findState.matchCase;
        }
        // Selection owns what is searched for
        var s = editor.getSelection();
        var searchText;
        var currentMatch = null;
        if (s.isEmpty()) {
            // selection is empty => expand to current word
            var word = editor.getModel().getWordAtPosition(s.getStartPosition());
            if (!word) {
                return null;
            }
            searchText = word.word;
            currentMatch = new Selection(s.startLineNumber, word.startColumn, s.startLineNumber, word.endColumn);
        }
        else {
            searchText = editor.getModel().getValueInRange(s).replace(/\r\n/g, '\n');
        }
        return new MultiCursorSession(editor, findController, isDisconnectedFromFindController, searchText, wholeWord, matchCase, currentMatch);
    };
    MultiCursorSession.prototype.addSelectionToNextFindMatch = function () {
        var nextMatch = this._getNextMatch();
        if (!nextMatch) {
            return null;
        }
        var allSelections = this._editor.getSelections();
        return new MultiCursorSessionResult(allSelections.concat(nextMatch), nextMatch, 0 /* Smooth */);
    };
    MultiCursorSession.prototype.moveSelectionToNextFindMatch = function () {
        var nextMatch = this._getNextMatch();
        if (!nextMatch) {
            return null;
        }
        var allSelections = this._editor.getSelections();
        return new MultiCursorSessionResult(allSelections.slice(0, allSelections.length - 1).concat(nextMatch), nextMatch, 0 /* Smooth */);
    };
    MultiCursorSession.prototype._getNextMatch = function () {
        if (this.currentMatch) {
            var result = this.currentMatch;
            this.currentMatch = null;
            return result;
        }
        this.findController.highlightFindOptions();
        var allSelections = this._editor.getSelections();
        var lastAddedSelection = allSelections[allSelections.length - 1];
        var nextMatch = this._editor.getModel().findNextMatch(this.searchText, lastAddedSelection.getEndPosition(), false, this.matchCase, this.wholeWord ? this._editor.getConfiguration().wordSeparators : null, false);
        if (!nextMatch) {
            return null;
        }
        return new Selection(nextMatch.range.startLineNumber, nextMatch.range.startColumn, nextMatch.range.endLineNumber, nextMatch.range.endColumn);
    };
    MultiCursorSession.prototype.addSelectionToPreviousFindMatch = function () {
        var previousMatch = this._getPreviousMatch();
        if (!previousMatch) {
            return null;
        }
        var allSelections = this._editor.getSelections();
        return new MultiCursorSessionResult(allSelections.concat(previousMatch), previousMatch, 0 /* Smooth */);
    };
    MultiCursorSession.prototype.moveSelectionToPreviousFindMatch = function () {
        var previousMatch = this._getPreviousMatch();
        if (!previousMatch) {
            return null;
        }
        var allSelections = this._editor.getSelections();
        return new MultiCursorSessionResult(allSelections.slice(0, allSelections.length - 1).concat(previousMatch), previousMatch, 0 /* Smooth */);
    };
    MultiCursorSession.prototype._getPreviousMatch = function () {
        if (this.currentMatch) {
            var result = this.currentMatch;
            this.currentMatch = null;
            return result;
        }
        this.findController.highlightFindOptions();
        var allSelections = this._editor.getSelections();
        var lastAddedSelection = allSelections[allSelections.length - 1];
        var previousMatch = this._editor.getModel().findPreviousMatch(this.searchText, lastAddedSelection.getStartPosition(), false, this.matchCase, this.wholeWord ? this._editor.getConfiguration().wordSeparators : null, false);
        if (!previousMatch) {
            return null;
        }
        return new Selection(previousMatch.range.startLineNumber, previousMatch.range.startColumn, previousMatch.range.endLineNumber, previousMatch.range.endColumn);
    };
    MultiCursorSession.prototype.selectAll = function () {
        this.findController.highlightFindOptions();
        return this._editor.getModel().findMatches(this.searchText, true, false, this.matchCase, this.wholeWord ? this._editor.getConfiguration().wordSeparators : null, false, 1073741824 /* MAX_SAFE_SMALL_INTEGER */);
    };
    return MultiCursorSession;
}());
var MultiCursorSelectionController = /** @class */ (function (_super) {
    __extends$y(MultiCursorSelectionController, _super);
    function MultiCursorSelectionController(editor) {
        var _this = _super.call(this) || this;
        _this._editor = editor;
        _this._ignoreSelectionChange = false;
        _this._session = null;
        _this._sessionDispose = [];
        return _this;
    }
    MultiCursorSelectionController.get = function (editor) {
        return editor.getContribution(MultiCursorSelectionController.ID);
    };
    MultiCursorSelectionController.prototype.dispose = function () {
        this._endSession();
        _super.prototype.dispose.call(this);
    };
    MultiCursorSelectionController.prototype.getId = function () {
        return MultiCursorSelectionController.ID;
    };
    MultiCursorSelectionController.prototype._beginSessionIfNeeded = function (findController) {
        var _this = this;
        if (!this._session) {
            // Create a new session
            var session = MultiCursorSession.create(this._editor, findController);
            if (!session) {
                return;
            }
            this._session = session;
            var newState = { searchString: this._session.searchText };
            if (this._session.isDisconnectedFromFindController) {
                newState.wholeWordOverride = 1 /* True */;
                newState.matchCaseOverride = 1 /* True */;
                newState.isRegexOverride = 2 /* False */;
            }
            findController.getState().change(newState, false);
            this._sessionDispose = [
                this._editor.onDidChangeCursorSelection(function (e) {
                    if (_this._ignoreSelectionChange) {
                        return;
                    }
                    _this._endSession();
                }),
                this._editor.onDidBlurEditorText(function () {
                    _this._endSession();
                }),
                findController.getState().onFindReplaceStateChange(function (e) {
                    if (e.matchCase || e.wholeWord) {
                        _this._endSession();
                    }
                })
            ];
        }
    };
    MultiCursorSelectionController.prototype._endSession = function () {
        this._sessionDispose = dispose(this._sessionDispose);
        if (this._session && this._session.isDisconnectedFromFindController) {
            var newState = {
                wholeWordOverride: 0 /* NotSet */,
                matchCaseOverride: 0 /* NotSet */,
                isRegexOverride: 0 /* NotSet */,
            };
            this._session.findController.getState().change(newState, false);
        }
        this._session = null;
    };
    MultiCursorSelectionController.prototype._setSelections = function (selections) {
        this._ignoreSelectionChange = true;
        this._editor.setSelections(selections);
        this._ignoreSelectionChange = false;
    };
    MultiCursorSelectionController.prototype._expandEmptyToWord = function (model, selection) {
        if (!selection.isEmpty()) {
            return selection;
        }
        var word = model.getWordAtPosition(selection.getStartPosition());
        if (!word) {
            return selection;
        }
        return new Selection(selection.startLineNumber, word.startColumn, selection.startLineNumber, word.endColumn);
    };
    MultiCursorSelectionController.prototype._applySessionResult = function (result) {
        if (!result) {
            return;
        }
        this._setSelections(result.selections);
        if (result.revealRange) {
            this._editor.revealRangeInCenterIfOutsideViewport(result.revealRange, result.revealScrollType);
        }
    };
    MultiCursorSelectionController.prototype.getSession = function (findController) {
        return this._session;
    };
    MultiCursorSelectionController.prototype.addSelectionToNextFindMatch = function (findController) {
        if (!this._session) {
            // If there are multiple cursors, handle the case where they do not all select the same text.
            var allSelections = this._editor.getSelections();
            if (allSelections.length > 1) {
                var findState = findController.getState();
                var matchCase = findState.matchCase;
                var selectionsContainSameText = modelRangesContainSameText(this._editor.getModel(), allSelections, matchCase);
                if (!selectionsContainSameText) {
                    var model = this._editor.getModel();
                    var resultingSelections = [];
                    for (var i = 0, len = allSelections.length; i < len; i++) {
                        resultingSelections[i] = this._expandEmptyToWord(model, allSelections[i]);
                    }
                    this._editor.setSelections(resultingSelections);
                    return;
                }
            }
        }
        this._beginSessionIfNeeded(findController);
        if (this._session) {
            this._applySessionResult(this._session.addSelectionToNextFindMatch());
        }
    };
    MultiCursorSelectionController.prototype.addSelectionToPreviousFindMatch = function (findController) {
        this._beginSessionIfNeeded(findController);
        if (this._session) {
            this._applySessionResult(this._session.addSelectionToPreviousFindMatch());
        }
    };
    MultiCursorSelectionController.prototype.moveSelectionToNextFindMatch = function (findController) {
        this._beginSessionIfNeeded(findController);
        if (this._session) {
            this._applySessionResult(this._session.moveSelectionToNextFindMatch());
        }
    };
    MultiCursorSelectionController.prototype.moveSelectionToPreviousFindMatch = function (findController) {
        this._beginSessionIfNeeded(findController);
        if (this._session) {
            this._applySessionResult(this._session.moveSelectionToPreviousFindMatch());
        }
    };
    MultiCursorSelectionController.prototype.selectAll = function (findController) {
        var matches = null;
        var findState = findController.getState();
        // Special case: find widget owns entirely what we search for if:
        // - focus is not in the editor (i.e. it is in the find widget)
        // - and the search widget is visible
        // - and the search string is non-empty
        // - and we're searching for a regex
        if (findState.isRevealed && findState.searchString.length > 0 && findState.isRegex) {
            matches = this._editor.getModel().findMatches(findState.searchString, true, findState.isRegex, findState.matchCase, findState.wholeWord ? this._editor.getConfiguration().wordSeparators : null, false, 1073741824 /* MAX_SAFE_SMALL_INTEGER */);
        }
        else {
            this._beginSessionIfNeeded(findController);
            if (!this._session) {
                return;
            }
            matches = this._session.selectAll();
        }
        if (matches.length > 0) {
            var editorSelection = this._editor.getSelection();
            // Have the primary cursor remain the one where the action was invoked
            for (var i = 0, len = matches.length; i < len; i++) {
                var match = matches[i];
                var intersection = match.range.intersectRanges(editorSelection);
                if (intersection) {
                    // bingo!
                    matches[i] = matches[0];
                    matches[0] = match;
                    break;
                }
            }
            this._setSelections(matches.map(function (m) { return new Selection(m.range.startLineNumber, m.range.startColumn, m.range.endLineNumber, m.range.endColumn); }));
        }
    };
    MultiCursorSelectionController.ID = 'editor.contrib.multiCursorController';
    return MultiCursorSelectionController;
}(Disposable));
var MultiCursorSelectionControllerAction = /** @class */ (function (_super) {
    __extends$y(MultiCursorSelectionControllerAction, _super);
    function MultiCursorSelectionControllerAction() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    MultiCursorSelectionControllerAction.prototype.run = function (accessor, editor) {
        var multiCursorController = MultiCursorSelectionController.get(editor);
        if (!multiCursorController) {
            return;
        }
        var findController = CommonFindController.get(editor);
        if (!findController) {
            return null;
        }
        this._run(multiCursorController, findController);
    };
    return MultiCursorSelectionControllerAction;
}(EditorAction));
var AddSelectionToNextFindMatchAction = /** @class */ (function (_super) {
    __extends$y(AddSelectionToNextFindMatchAction, _super);
    function AddSelectionToNextFindMatchAction() {
        return _super.call(this, {
            id: 'editor.action.addSelectionToNextFindMatch',
            label: localize('addSelectionToNextFindMatch', "Add Selection To Next Find Match"),
            alias: 'Add Selection To Next Find Match',
            precondition: null,
            kbOpts: {
                kbExpr: EditorContextKeys.focus,
                primary: 2048 /* CtrlCmd */ | 34 /* KEY_D */
            }
        }) || this;
    }
    AddSelectionToNextFindMatchAction.prototype._run = function (multiCursorController, findController) {
        multiCursorController.addSelectionToNextFindMatch(findController);
    };
    return AddSelectionToNextFindMatchAction;
}(MultiCursorSelectionControllerAction));
var AddSelectionToPreviousFindMatchAction = /** @class */ (function (_super) {
    __extends$y(AddSelectionToPreviousFindMatchAction, _super);
    function AddSelectionToPreviousFindMatchAction() {
        return _super.call(this, {
            id: 'editor.action.addSelectionToPreviousFindMatch',
            label: localize('addSelectionToPreviousFindMatch', "Add Selection To Previous Find Match"),
            alias: 'Add Selection To Previous Find Match',
            precondition: null
        }) || this;
    }
    AddSelectionToPreviousFindMatchAction.prototype._run = function (multiCursorController, findController) {
        multiCursorController.addSelectionToPreviousFindMatch(findController);
    };
    return AddSelectionToPreviousFindMatchAction;
}(MultiCursorSelectionControllerAction));
var MoveSelectionToNextFindMatchAction = /** @class */ (function (_super) {
    __extends$y(MoveSelectionToNextFindMatchAction, _super);
    function MoveSelectionToNextFindMatchAction() {
        return _super.call(this, {
            id: 'editor.action.moveSelectionToNextFindMatch',
            label: localize('moveSelectionToNextFindMatch', "Move Last Selection To Next Find Match"),
            alias: 'Move Last Selection To Next Find Match',
            precondition: null,
            kbOpts: {
                kbExpr: EditorContextKeys.focus,
                primary: KeyChord(2048 /* CtrlCmd */ | 41 /* KEY_K */, 2048 /* CtrlCmd */ | 34 /* KEY_D */)
            }
        }) || this;
    }
    MoveSelectionToNextFindMatchAction.prototype._run = function (multiCursorController, findController) {
        multiCursorController.moveSelectionToNextFindMatch(findController);
    };
    return MoveSelectionToNextFindMatchAction;
}(MultiCursorSelectionControllerAction));
var MoveSelectionToPreviousFindMatchAction = /** @class */ (function (_super) {
    __extends$y(MoveSelectionToPreviousFindMatchAction, _super);
    function MoveSelectionToPreviousFindMatchAction() {
        return _super.call(this, {
            id: 'editor.action.moveSelectionToPreviousFindMatch',
            label: localize('moveSelectionToPreviousFindMatch', "Move Last Selection To Previous Find Match"),
            alias: 'Move Last Selection To Previous Find Match',
            precondition: null
        }) || this;
    }
    MoveSelectionToPreviousFindMatchAction.prototype._run = function (multiCursorController, findController) {
        multiCursorController.moveSelectionToPreviousFindMatch(findController);
    };
    return MoveSelectionToPreviousFindMatchAction;
}(MultiCursorSelectionControllerAction));
var SelectHighlightsAction = /** @class */ (function (_super) {
    __extends$y(SelectHighlightsAction, _super);
    function SelectHighlightsAction() {
        return _super.call(this, {
            id: 'editor.action.selectHighlights',
            label: localize('selectAllOccurrencesOfFindMatch', "Select All Occurrences of Find Match"),
            alias: 'Select All Occurrences of Find Match',
            precondition: null,
            kbOpts: {
                kbExpr: EditorContextKeys.focus,
                primary: 2048 /* CtrlCmd */ | 1024 /* Shift */ | 42 /* KEY_L */
            }
        }) || this;
    }
    SelectHighlightsAction.prototype._run = function (multiCursorController, findController) {
        multiCursorController.selectAll(findController);
    };
    return SelectHighlightsAction;
}(MultiCursorSelectionControllerAction));
var CompatChangeAll = /** @class */ (function (_super) {
    __extends$y(CompatChangeAll, _super);
    function CompatChangeAll() {
        return _super.call(this, {
            id: 'editor.action.changeAll',
            label: localize('changeAll.label', "Change All Occurrences"),
            alias: 'Change All Occurrences',
            precondition: EditorContextKeys.writable,
            kbOpts: {
                kbExpr: EditorContextKeys.editorTextFocus,
                primary: 2048 /* CtrlCmd */ | 60 /* F2 */
            },
            menuOpts: {
                group: '1_modification',
                order: 1.2
            }
        }) || this;
    }
    CompatChangeAll.prototype._run = function (multiCursorController, findController) {
        multiCursorController.selectAll(findController);
    };
    return CompatChangeAll;
}(MultiCursorSelectionControllerAction));
var SelectionHighlighterState = /** @class */ (function () {
    function SelectionHighlighterState(lastWordUnderCursor, searchText, matchCase, wordSeparators) {
        this.lastWordUnderCursor = lastWordUnderCursor;
        this.searchText = searchText;
        this.matchCase = matchCase;
        this.wordSeparators = wordSeparators;
    }
    /**
     * Everything equals except for `lastWordUnderCursor`
     */
    SelectionHighlighterState.softEquals = function (a, b) {
        if (!a && !b) {
            return true;
        }
        if (!a || !b) {
            return false;
        }
        return (a.searchText === b.searchText
            && a.matchCase === b.matchCase
            && a.wordSeparators === b.wordSeparators);
    };
    return SelectionHighlighterState;
}());
var SelectionHighlighter = /** @class */ (function (_super) {
    __extends$y(SelectionHighlighter, _super);
    function SelectionHighlighter(editor) {
        var _this = _super.call(this) || this;
        _this.editor = editor;
        _this._isEnabled = editor.getConfiguration().contribInfo.selectionHighlight;
        _this.decorations = [];
        _this.updateSoon = _this._register(new RunOnceScheduler(function () { return _this._update(); }, 300));
        _this.state = null;
        _this._register(editor.onDidChangeConfiguration(function (e) {
            _this._isEnabled = editor.getConfiguration().contribInfo.selectionHighlight;
        }));
        _this._register(editor.onDidChangeCursorSelection(function (e) {
            if (!_this._isEnabled) {
                // Early exit if nothing needs to be done!
                // Leave some form of early exit check here if you wish to continue being a cursor position change listener ;)
                return;
            }
            if (e.selection.isEmpty()) {
                if (e.reason === CursorChangeReason.Explicit) {
                    if (_this.state && (!_this.state.lastWordUnderCursor || !_this.state.lastWordUnderCursor.containsPosition(e.selection.getStartPosition()))) {
                        // no longer valid
                        _this._setState(null);
                    }
                    _this.updateSoon.schedule();
                }
                else {
                    _this._setState(null);
                }
            }
            else {
                _this._update();
            }
        }));
        _this._register(editor.onDidChangeModel(function (e) {
            _this._setState(null);
        }));
        _this._register(CommonFindController.get(editor).getState().onFindReplaceStateChange(function (e) {
            _this._update();
        }));
        return _this;
    }
    SelectionHighlighter.prototype.getId = function () {
        return SelectionHighlighter.ID;
    };
    SelectionHighlighter.prototype._update = function () {
        this._setState(SelectionHighlighter._createState(this._isEnabled, this.editor));
    };
    SelectionHighlighter._createState = function (isEnabled, editor) {
        if (!isEnabled) {
            return null;
        }
        var model = editor.getModel();
        if (!model) {
            return null;
        }
        var s = editor.getSelection();
        if (s.startLineNumber !== s.endLineNumber) {
            // multiline forbidden for perf reasons
            return null;
        }
        var multiCursorController = MultiCursorSelectionController.get(editor);
        if (!multiCursorController) {
            return null;
        }
        var findController = CommonFindController.get(editor);
        if (!findController) {
            return null;
        }
        var r = multiCursorController.getSession(findController);
        if (!r) {
            var allSelections = editor.getSelections();
            if (allSelections.length > 1) {
                var findState_1 = findController.getState();
                var matchCase = findState_1.matchCase;
                var selectionsContainSameText = modelRangesContainSameText(editor.getModel(), allSelections, matchCase);
                if (!selectionsContainSameText) {
                    return null;
                }
            }
            r = MultiCursorSession.create(editor, findController);
        }
        if (!r) {
            return null;
        }
        var lastWordUnderCursor = null;
        var hasFindOccurrences = DocumentHighlightProviderRegistry.has(model);
        if (r.currentMatch) {
            // This is an empty selection
            if (hasFindOccurrences) {
                // Do not interfere with semantic word highlighting in the no selection case
                return null;
            }
            var config = editor.getConfiguration();
            if (!config.contribInfo.occurrencesHighlight) {
                return null;
            }
            lastWordUnderCursor = r.currentMatch;
        }
        if (/^[ \t]+$/.test(r.searchText)) {
            // whitespace only selection
            return null;
        }
        if (r.searchText.length > 200) {
            // very long selection
            return null;
        }
        // TODO: better handling of this case
        var findState = findController.getState();
        var caseSensitive = findState.matchCase;
        // Return early if the find widget shows the exact same matches
        if (findState.isRevealed) {
            var findStateSearchString = findState.searchString;
            if (!caseSensitive) {
                findStateSearchString = findStateSearchString.toLowerCase();
            }
            var mySearchString = r.searchText;
            if (!caseSensitive) {
                mySearchString = mySearchString.toLowerCase();
            }
            if (findStateSearchString === mySearchString && r.matchCase === findState.matchCase && r.wholeWord === findState.wholeWord && !findState.isRegex) {
                return null;
            }
        }
        return new SelectionHighlighterState(lastWordUnderCursor, r.searchText, r.matchCase, r.wholeWord ? editor.getConfiguration().wordSeparators : null);
    };
    SelectionHighlighter.prototype._setState = function (state) {
        if (SelectionHighlighterState.softEquals(this.state, state)) {
            this.state = state;
            return;
        }
        this.state = state;
        if (!this.state) {
            this.decorations = this.editor.deltaDecorations(this.decorations, []);
            return;
        }
        var model = this.editor.getModel();
        if (model.isTooLargeForTokenization()) {
            // the file is too large, so searching word under cursor in the whole document takes is blocking the UI.
            return;
        }
        var hasFindOccurrences = DocumentHighlightProviderRegistry.has(model);
        var allMatches = model.findMatches(this.state.searchText, true, false, this.state.matchCase, this.state.wordSeparators, false).map(function (m) { return m.range; });
        allMatches.sort(Range.compareRangesUsingStarts);
        var selections = this.editor.getSelections();
        selections.sort(Range.compareRangesUsingStarts);
        // do not overlap with selection (issue #64 and #512)
        var matches = [];
        for (var i = 0, j = 0, len = allMatches.length, lenJ = selections.length; i < len;) {
            var match = allMatches[i];
            if (j >= lenJ) {
                // finished all editor selections
                matches.push(match);
                i++;
            }
            else {
                var cmp = Range.compareRangesUsingStarts(match, selections[j]);
                if (cmp < 0) {
                    // match is before sel
                    matches.push(match);
                    i++;
                }
                else if (cmp > 0) {
                    // sel is before match
                    j++;
                }
                else {
                    // sel is equal to match
                    i++;
                    j++;
                }
            }
        }
        var decorations = matches.map(function (r) {
            return {
                range: r,
                // Show in overviewRuler only if model has no semantic highlighting
                options: (hasFindOccurrences ? SelectionHighlighter._SELECTION_HIGHLIGHT : SelectionHighlighter._SELECTION_HIGHLIGHT_OVERVIEW)
            };
        });
        this.decorations = this.editor.deltaDecorations(this.decorations, decorations);
    };
    SelectionHighlighter.prototype.dispose = function () {
        this._setState(null);
        _super.prototype.dispose.call(this);
    };
    SelectionHighlighter.ID = 'editor.contrib.selectionHighlighter';
    SelectionHighlighter._SELECTION_HIGHLIGHT_OVERVIEW = ModelDecorationOptions.register({
        stickiness: TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges,
        className: 'selectionHighlight',
        overviewRuler: {
            color: themeColorFromId(overviewRulerSelectionHighlightForeground),
            darkColor: themeColorFromId(overviewRulerSelectionHighlightForeground),
            position: OverviewRulerLane.Center
        }
    });
    SelectionHighlighter._SELECTION_HIGHLIGHT = ModelDecorationOptions.register({
        stickiness: TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges,
        className: 'selectionHighlight',
    });
    return SelectionHighlighter;
}(Disposable));
function modelRangesContainSameText(model, ranges, matchCase) {
    var selectedText = getValueInRange(model, ranges[0], !matchCase);
    for (var i = 1, len = ranges.length; i < len; i++) {
        var range$$1 = ranges[i];
        if (range$$1.isEmpty()) {
            return false;
        }
        var thisSelectedText = getValueInRange(model, range$$1, !matchCase);
        if (selectedText !== thisSelectedText) {
            return false;
        }
    }
    return true;
}
function getValueInRange(model, range$$1, toLowerCase) {
    var text = model.getValueInRange(range$$1);
    return (toLowerCase ? text.toLowerCase() : text);
}
registerEditorContribution(MultiCursorSelectionController);
registerEditorContribution(SelectionHighlighter);
registerEditorAction(InsertCursorAbove);
registerEditorAction(InsertCursorBelow);
registerEditorAction(InsertCursorAtEndOfEachLineSelected);
registerEditorAction(AddSelectionToNextFindMatchAction);
registerEditorAction(AddSelectionToPreviousFindMatchAction);
registerEditorAction(MoveSelectionToNextFindMatchAction);
registerEditorAction(MoveSelectionToPreviousFindMatchAction);
registerEditorAction(SelectHighlightsAction);
registerEditorAction(CompatChangeAll);

const css$l = "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n.monaco-editor .parameter-hints-widget {\n\tz-index: 10;\n\tdisplay: flex;\n\tflex-direction: column;\n\tline-height: 1.5em;\n}\n\n.monaco-editor .parameter-hints-widget > .wrapper {\n\tmax-width: 440px;\n\tdisplay: flex;\n\tflex-direction: column;\n}\n\n.monaco-editor .parameter-hints-widget.multiple {\n\tmin-height: 3.3em;\n\tpadding: 0 0 0 1.9em;\n}\n\n.monaco-editor .parameter-hints-widget.visible {\n\t-webkit-transition: left .05s ease-in-out;\n\t-moz-transition: left .05s ease-in-out;\n\t-o-transition: left .05s ease-in-out;\n\ttransition: left .05s ease-in-out;\n}\n\n.monaco-editor .parameter-hints-widget p,\n.monaco-editor .parameter-hints-widget ul {\n\tmargin: 8px 0;\n}\n\n.monaco-editor .parameter-hints-widget .monaco-scrollable-element,\n.monaco-editor .parameter-hints-widget .body {\n\tdisplay: flex;\n\tflex-direction: column;\n}\n\n.monaco-editor .parameter-hints-widget .signature {\n\tpadding: 4px 5px;\n}\n\n.monaco-editor .parameter-hints-widget .docs {\n\tpadding: 0 10px 0 5px;\n\twhite-space: pre-wrap;\n}\n\n.monaco-editor .parameter-hints-widget .docs.markdown-docs {\n\twhite-space: initial;\n}\n\n.monaco-editor .parameter-hints-widget .docs .code {\n\twhite-space: pre-wrap;\n}\n\n.monaco-editor .parameter-hints-widget .docs code {\n\tborder-radius: 3px;\n\tpadding: 0 0.4em;\n}\n\n.monaco-editor .parameter-hints-widget .buttons {\n\tposition: absolute;\n\tdisplay: none;\n\tbottom: 0;\n\tleft: 0;\n}\n\n.monaco-editor .parameter-hints-widget.multiple .buttons {\n\tdisplay: block;\n}\n\n.monaco-editor .parameter-hints-widget.multiple .button {\n\tposition: absolute;\n\tleft: 2px;\n\twidth: 16px;\n\theight: 16px;\n\tbackground-repeat: no-repeat;\n\tcursor: pointer;\n}\n\n.monaco-editor .parameter-hints-widget .button.previous {\n\tbottom: 24px;\n\tbackground-image: url(\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNiAxNiI+PHBhdGggZmlsbD0iIzQyNDI0MiIgZD0iTTEwLjggOS41bC45LS45TDguMSA1IDQuMiA4LjZsLjkuOSAzLTIuNyAyLjcgMi43eiIvPjwvc3ZnPg==\");\n}\n\n.monaco-editor .parameter-hints-widget .button.next {\n\tbottom: 0;\n\tbackground-image: url(\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNiAxNiI+PHBhdGggZmlsbD0iIzQyNDI0MiIgZD0iTTUuMSA1bC0uOS45IDMuNiAzLjYgMy45LTMuNi0xLS45LTMgMi43TDUuMSA1eiIvPjwvc3ZnPg==\");\n}\n\n.monaco-editor .parameter-hints-widget .overloads {\n\tposition: absolute;\n\tdisplay: none;\n\ttext-align: center;\n\tbottom: 14px;\n\tleft: 0;\n\twidth: 22px;\n\theight: 12px;\n\tline-height: 12px;\n\topacity: 0.5;\n}\n\n.monaco-editor .parameter-hints-widget.multiple .overloads {\n\tdisplay: block;\n}\n\n.monaco-editor .parameter-hints-widget .signature .parameter {\n\tdisplay: inline-block;\n}\n\n.monaco-editor .parameter-hints-widget .signature .parameter.active {\n\tfont-weight: bold;\n\ttext-decoration: underline;\n}\n\n.monaco-editor .parameter-hints-widget .documentation-parameter > .parameter {\n\tfont-weight: bold;\n\tmargin-right: 0.5em;\n}\n\n/*** VS Dark & High Contrast*/\n\n.monaco-editor.hc-black .parameter-hints-widget .button.previous,\n.monaco-editor.vs-dark .parameter-hints-widget .button.previous {\n\tbackground-image: url(\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNiAxNiI+PHBhdGggZmlsbD0iI0U4RThFOCIgZD0iTTEwLjggOS41bC45LS45TDguMSA1IDQuMiA4LjZsLjkuOSAzLTIuNyAyLjcgMi43eiIvPjwvc3ZnPg==\");\n}\n\n.monaco-editor.hc-black .parameter-hints-widget .button.next,\n.monaco-editor.vs-dark .parameter-hints-widget .button.next {\n\tbackground-image: url(\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNiAxNiI+PHBhdGggZmlsbD0iI0U4RThFOCIgZD0iTTUuMSA1bC0uOS45IDMuNiAzLjYgMy45LTMuNi0xLS45LTMgMi43TDUuMSA1eiIvPjwvc3ZnPg==\");\n}";
  const element$l = ((css, src) => {
if (typeof document !== 'object')
console.info(`Skipped loading "${src}"`);
try {
const id = src
  .replace(/\.css.*$/, '')
  .replace(/[\\:]/g, '/')
  .replace(/[^\w\/]+/g, '');
return (
  document.querySelector(`style[id="${id}"]`) ||
  document.head.appendChild(
    Object.assign(document.createElement('style'), {
      id,
      textContent: `${css}\n\n /* sourceURL=${src} */`,
    }),
  )
);
} catch (exception) {
console.warn(`Failed load "${src}"`, exception);
}
})(css$l, "…monaco-editor/esm/vs/editor/contrib/parameterHints/parameterHints.css");
  //@ sourceURL=/Users/daflair/Projects/packages/monaco-es/node_modules/monaco-editor/esm/vs/editor/contrib/parameterHints/parameterHints.css

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var Context = {
    Visible: new RawContextKey('parameterHintsVisible', false),
    MultipleSignatures: new RawContextKey('parameterHintsMultipleSignatures', false),
};
function provideSignatureHelp(model, position) {
    var supports = SignatureHelpProviderRegistry.ordered(model);
    var result;
    return sequence(supports.map(function (support) { return function () {
        if (result) {
            // stop when there is a result
            return undefined;
        }
        return asWinJsPromise(function (token) { return support.provideSignatureHelp(model, position, token); }).then(function (thisResult) {
            result = thisResult;
        }, onUnexpectedExternalError);
    }; })).then(function () { return result; });
}
registerDefaultLanguageCommand('_executeSignatureHelpProvider', provideSignatureHelp);

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$z = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate$f = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$f = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var $$5 = $;
var ParameterHintsModel = /** @class */ (function (_super) {
    __extends$z(ParameterHintsModel, _super);
    function ParameterHintsModel(editor) {
        var _this = _super.call(this) || this;
        _this._onHint = _this._register(new Emitter());
        _this.onHint = _this._onHint.event;
        _this._onCancel = _this._register(new Emitter());
        _this.onCancel = _this._onCancel.event;
        _this.editor = editor;
        _this.enabled = false;
        _this.triggerCharactersListeners = [];
        _this.throttledDelayer = new RunOnceScheduler(function () { return _this.doTrigger(); }, ParameterHintsModel.DELAY);
        _this.active = false;
        _this._register(_this.editor.onDidChangeConfiguration(function () { return _this.onEditorConfigurationChange(); }));
        _this._register(_this.editor.onDidChangeModel(function (e) { return _this.onModelChanged(); }));
        _this._register(_this.editor.onDidChangeModelLanguage(function (_) { return _this.onModelChanged(); }));
        _this._register(_this.editor.onDidChangeCursorSelection(function (e) { return _this.onCursorChange(e); }));
        _this._register(SignatureHelpProviderRegistry.onDidChange(_this.onModelChanged, _this));
        _this.onEditorConfigurationChange();
        _this.onModelChanged();
        return _this;
    }
    ParameterHintsModel.prototype.cancel = function (silent) {
        if (silent === void 0) { silent = false; }
        this.active = false;
        this.throttledDelayer.cancel();
        if (!silent) {
            this._onCancel.fire(void 0);
        }
        if (this.provideSignatureHelpRequest) {
            this.provideSignatureHelpRequest.cancel();
            this.provideSignatureHelpRequest = undefined;
        }
    };
    ParameterHintsModel.prototype.trigger = function (delay) {
        if (delay === void 0) { delay = ParameterHintsModel.DELAY; }
        if (!SignatureHelpProviderRegistry.has(this.editor.getModel())) {
            return;
        }
        this.cancel(true);
        return this.throttledDelayer.schedule(delay);
    };
    ParameterHintsModel.prototype.doTrigger = function () {
        var _this = this;
        if (this.provideSignatureHelpRequest) {
            this.provideSignatureHelpRequest.cancel();
        }
        this.provideSignatureHelpRequest = provideSignatureHelp(this.editor.getModel(), this.editor.getPosition())
            .then(null, onUnexpectedError)
            .then(function (result) {
            if (!result || !result.signatures || result.signatures.length === 0) {
                _this.cancel();
                _this._onCancel.fire(void 0);
                return false;
            }
            _this.active = true;
            var event = { hints: result };
            _this._onHint.fire(event);
            return true;
        });
    };
    ParameterHintsModel.prototype.isTriggered = function () {
        return this.active || this.throttledDelayer.isScheduled();
    };
    ParameterHintsModel.prototype.onModelChanged = function () {
        var _this = this;
        if (this.active) {
            this.cancel();
        }
        this.triggerCharactersListeners = dispose(this.triggerCharactersListeners);
        var model = this.editor.getModel();
        if (!model) {
            return;
        }
        var triggerChars = new CharacterSet();
        for (var _i = 0, _a = SignatureHelpProviderRegistry.ordered(model); _i < _a.length; _i++) {
            var support = _a[_i];
            if (Array.isArray(support.signatureHelpTriggerCharacters)) {
                for (var _b = 0, _c = support.signatureHelpTriggerCharacters; _b < _c.length; _b++) {
                    var ch = _c[_b];
                    triggerChars.add(ch.charCodeAt(0));
                }
            }
        }
        this.triggerCharactersListeners.push(this.editor.onDidType(function (text) {
            if (!_this.enabled) {
                return;
            }
            if (triggerChars.has(text.charCodeAt(text.length - 1))) {
                _this.trigger();
            }
        }));
    };
    ParameterHintsModel.prototype.onCursorChange = function (e) {
        if (e.source === 'mouse') {
            this.cancel();
        }
        else if (this.isTriggered()) {
            this.trigger();
        }
    };
    ParameterHintsModel.prototype.onEditorConfigurationChange = function () {
        this.enabled = this.editor.getConfiguration().contribInfo.parameterHints;
        if (!this.enabled) {
            this.cancel();
        }
    };
    ParameterHintsModel.prototype.dispose = function () {
        this.cancel(true);
        this.triggerCharactersListeners = dispose(this.triggerCharactersListeners);
        _super.prototype.dispose.call(this);
    };
    ParameterHintsModel.DELAY = 120; // ms
    return ParameterHintsModel;
}(Disposable));
var ParameterHintsWidget = /** @class */ (function () {
    function ParameterHintsWidget(editor, contextKeyService, openerService, modeService) {
        var _this = this;
        this.editor = editor;
        // Editor.IContentWidget.allowEditorOverflow
        this.allowEditorOverflow = true;
        this.markdownRenderer = new MarkdownRenderer(editor, modeService, openerService);
        this.model = new ParameterHintsModel(editor);
        this.keyVisible = Context.Visible.bindTo(contextKeyService);
        this.keyMultipleSignatures = Context.MultipleSignatures.bindTo(contextKeyService);
        this.visible = false;
        this.disposables = [];
        this.disposables.push(this.model.onHint(function (e) {
            _this.show();
            _this.hints = e.hints;
            _this.currentSignature = e.hints.activeSignature;
            _this.render();
        }));
        this.disposables.push(this.model.onCancel(function () {
            _this.hide();
        }));
    }
    ParameterHintsWidget.prototype.createParamaterHintDOMNodes = function () {
        var _this = this;
        this.element = $$5('.editor-widget.parameter-hints-widget');
        var wrapper = append(this.element, $$5('.wrapper'));
        var buttons = append(wrapper, $$5('.buttons'));
        var previous = append(buttons, $$5('.button.previous'));
        var next = append(buttons, $$5('.button.next'));
        var onPreviousClick = stop(domEvent(previous, 'click'));
        onPreviousClick(this.previous, this, this.disposables);
        var onNextClick = stop(domEvent(next, 'click'));
        onNextClick(this.next, this, this.disposables);
        this.overloads = append(wrapper, $$5('.overloads'));
        var body = $$5('.body');
        this.scrollbar = new DomScrollableElement(body, {});
        this.disposables.push(this.scrollbar);
        wrapper.appendChild(this.scrollbar.getDomNode());
        this.signature = append(body, $$5('.signature'));
        this.docs = append(body, $$5('.docs'));
        this.currentSignature = 0;
        this.editor.addContentWidget(this);
        this.hide();
        this.disposables.push(this.editor.onDidChangeCursorSelection(function (e) {
            if (_this.visible) {
                _this.editor.layoutContentWidget(_this);
            }
        }));
        var updateFont = function () {
            var fontInfo = _this.editor.getConfiguration().fontInfo;
            _this.element.style.fontSize = fontInfo.fontSize + "px";
        };
        updateFont();
        chain(this.editor.onDidChangeConfiguration.bind(this.editor))
            .filter(function (e) { return e.fontInfo; })
            .on(updateFont, null, this.disposables);
        this.disposables.push(this.editor.onDidLayoutChange(function (e) { return _this.updateMaxHeight(); }));
        this.updateMaxHeight();
    };
    ParameterHintsWidget.prototype.show = function () {
        var _this = this;
        if (!this.model || this.visible) {
            return;
        }
        if (!this.element) {
            this.createParamaterHintDOMNodes();
        }
        this.keyVisible.set(true);
        this.visible = true;
        TPromise.timeout(100).done(function () { return addClass(_this.element, 'visible'); });
        this.editor.layoutContentWidget(this);
    };
    ParameterHintsWidget.prototype.hide = function () {
        if (!this.model || !this.visible) {
            return;
        }
        if (!this.element) {
            this.createParamaterHintDOMNodes();
        }
        this.keyVisible.reset();
        this.visible = false;
        this.hints = null;
        this.announcedLabel = null;
        removeClass(this.element, 'visible');
        this.editor.layoutContentWidget(this);
    };
    ParameterHintsWidget.prototype.getPosition = function () {
        if (this.visible) {
            return {
                position: this.editor.getPosition(),
                preference: [ContentWidgetPositionPreference.ABOVE, ContentWidgetPositionPreference.BELOW]
            };
        }
        return null;
    };
    ParameterHintsWidget.prototype.render = function () {
        var multiple = this.hints.signatures.length > 1;
        toggleClass(this.element, 'multiple', multiple);
        this.keyMultipleSignatures.set(multiple);
        this.signature.innerHTML = '';
        this.docs.innerHTML = '';
        var signature = this.hints.signatures[this.currentSignature];
        if (!signature) {
            return;
        }
        var code = append(this.signature, $$5('.code'));
        var hasParameters = signature.parameters.length > 0;
        var fontInfo = this.editor.getConfiguration().fontInfo;
        code.style.fontSize = fontInfo.fontSize + "px";
        code.style.fontFamily = fontInfo.fontFamily;
        if (!hasParameters) {
            var label = append(code, $$5('span'));
            label.textContent = signature.label;
        }
        else {
            this.renderParameters(code, signature, this.hints.activeParameter);
        }
        dispose(this.renderDisposeables);
        this.renderDisposeables = [];
        var activeParameter = signature.parameters[this.hints.activeParameter];
        if (activeParameter && activeParameter.documentation) {
            var documentation = $$5('span.documentation');
            if (typeof activeParameter.documentation === 'string') {
                removeClass(this.docs, 'markdown-docs');
                documentation.textContent = activeParameter.documentation;
            }
            else {
                addClass(this.docs, 'markdown-docs');
                var renderedContents = this.markdownRenderer.render(activeParameter.documentation);
                this.renderDisposeables.push(renderedContents);
                documentation.appendChild(renderedContents.element);
            }
            append(this.docs, $$5('p', null, documentation));
        }
        toggleClass(this.signature, 'has-docs', !!signature.documentation);
        if (typeof signature.documentation === 'string') {
            append(this.docs, $$5('p', null, signature.documentation));
        }
        else {
            var renderedContents = this.markdownRenderer.render(signature.documentation);
            this.renderDisposeables.push(renderedContents);
            append(this.docs, renderedContents.element);
        }
        var currentOverload = String(this.currentSignature + 1);
        if (this.hints.signatures.length < 10) {
            currentOverload += "/" + this.hints.signatures.length;
        }
        this.overloads.textContent = currentOverload;
        if (activeParameter) {
            var labelToAnnounce = activeParameter.label;
            // Select method gets called on every user type while parameter hints are visible.
            // We do not want to spam the user with same announcements, so we only announce if the current parameter changed.
            if (this.announcedLabel !== labelToAnnounce) {
                alert(localize('hint', "{0}, hint", labelToAnnounce));
                this.announcedLabel = labelToAnnounce;
            }
        }
        this.editor.layoutContentWidget(this);
        this.scrollbar.scanDomNode();
    };
    ParameterHintsWidget.prototype.renderParameters = function (parent, signature, currentParameter) {
        var end = signature.label.length;
        var idx = 0;
        var element;
        for (var i = signature.parameters.length - 1; i >= 0; i--) {
            var parameter = signature.parameters[i];
            idx = signature.label.lastIndexOf(parameter.label, end - 1);
            var signatureLabelOffset = 0;
            var signatureLabelEnd = 0;
            if (idx >= 0) {
                signatureLabelOffset = idx;
                signatureLabelEnd = idx + parameter.label.length;
            }
            // non parameter part
            element = document.createElement('span');
            element.textContent = signature.label.substring(signatureLabelEnd, end);
            prepend(parent, element);
            // parameter part
            element = document.createElement('span');
            element.className = "parameter " + (i === currentParameter ? 'active' : '');
            element.textContent = signature.label.substring(signatureLabelOffset, signatureLabelEnd);
            prepend(parent, element);
            end = signatureLabelOffset;
        }
        // non parameter part
        element = document.createElement('span');
        element.textContent = signature.label.substring(0, end);
        prepend(parent, element);
    };
    // private select(position: number): void {
    // 	const signature = this.signatureViews[position];
    // 	if (!signature) {
    // 		return;
    // 	}
    // 	this.signatures.style.height = `${ signature.height }px`;
    // 	this.signatures.scrollTop = signature.top;
    // 	let overloads = '' + (position + 1);
    // 	if (this.signatureViews.length < 10) {
    // 		overloads += '/' + this.signatureViews.length;
    // 	}
    // 	this.overloads.textContent = overloads;
    // 	if (this.hints && this.hints.signatures[position].parameters[this.hints.activeParameter]) {
    // 		const labelToAnnounce = this.hints.signatures[position].parameters[this.hints.activeParameter].label;
    // 		// Select method gets called on every user type while parameter hints are visible.
    // 		// We do not want to spam the user with same announcements, so we only announce if the current parameter changed.
    // 		if (this.announcedLabel !== labelToAnnounce) {
    // 			aria.alert(nls.localize('hint', "{0}, hint", labelToAnnounce));
    // 			this.announcedLabel = labelToAnnounce;
    // 		}
    // 	}
    // 	this.editor.layoutContentWidget(this);
    // }
    ParameterHintsWidget.prototype.next = function () {
        var length = this.hints.signatures.length;
        if (length < 2) {
            this.cancel();
            return false;
        }
        this.currentSignature = (this.currentSignature + 1) % length;
        this.render();
        return true;
    };
    ParameterHintsWidget.prototype.previous = function () {
        var length = this.hints.signatures.length;
        if (length < 2) {
            this.cancel();
            return false;
        }
        this.currentSignature = (this.currentSignature - 1 + length) % length;
        this.render();
        return true;
    };
    ParameterHintsWidget.prototype.cancel = function () {
        this.model.cancel();
    };
    ParameterHintsWidget.prototype.getDomNode = function () {
        return this.element;
    };
    ParameterHintsWidget.prototype.getId = function () {
        return ParameterHintsWidget.ID;
    };
    ParameterHintsWidget.prototype.trigger = function () {
        this.model.trigger(0);
    };
    ParameterHintsWidget.prototype.updateMaxHeight = function () {
        var height = Math.max(this.editor.getLayoutInfo().height / 4, 250);
        this.element.style.maxHeight = height + "px";
    };
    ParameterHintsWidget.prototype.dispose = function () {
        this.disposables = dispose(this.disposables);
        this.renderDisposeables = dispose(this.renderDisposeables);
        if (this.model) {
            this.model.dispose();
            this.model = null;
        }
    };
    ParameterHintsWidget.ID = 'editor.widget.parameterHintsWidget';
    ParameterHintsWidget = __decorate$f([
        __param$f(1, IContextKeyService),
        __param$f(2, IOpenerService),
        __param$f(3, IModeService)
    ], ParameterHintsWidget);
    return ParameterHintsWidget;
}());
registerThemingParticipant(function (theme, collector) {
    var border = theme.getColor(editorHoverBorder);
    if (border) {
        var borderWidth = theme.type === HIGH_CONTRAST ? 2 : 1;
        collector.addRule(".monaco-editor .parameter-hints-widget { border: " + borderWidth + "px solid " + border + "; }");
        collector.addRule(".monaco-editor .parameter-hints-widget.multiple .body { border-left: 1px solid " + border.transparent(0.5) + "; }");
        collector.addRule(".monaco-editor .parameter-hints-widget .signature.has-docs { border-bottom: 1px solid " + border.transparent(0.5) + "; }");
    }
    var background = theme.getColor(editorHoverBackground);
    if (background) {
        collector.addRule(".monaco-editor .parameter-hints-widget { background-color: " + background + "; }");
    }
    var link = theme.getColor(textLinkForeground);
    if (link) {
        collector.addRule(".monaco-editor .parameter-hints-widget a { color: " + link + "; }");
    }
    var codeBackground = theme.getColor(textCodeBlockBackground);
    if (codeBackground) {
        collector.addRule(".monaco-editor .parameter-hints-widget code { background-color: " + codeBackground + "; }");
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$A = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate$g = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$g = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var ParameterHintsController = /** @class */ (function () {
    function ParameterHintsController(editor, instantiationService) {
        this.editor = editor;
        this.widget = instantiationService.createInstance(ParameterHintsWidget, this.editor);
    }
    ParameterHintsController.get = function (editor) {
        return editor.getContribution(ParameterHintsController.ID);
    };
    ParameterHintsController.prototype.getId = function () {
        return ParameterHintsController.ID;
    };
    ParameterHintsController.prototype.cancel = function () {
        this.widget.cancel();
    };
    ParameterHintsController.prototype.previous = function () {
        this.widget.previous();
    };
    ParameterHintsController.prototype.next = function () {
        this.widget.next();
    };
    ParameterHintsController.prototype.trigger = function () {
        this.widget.trigger();
    };
    ParameterHintsController.prototype.dispose = function () {
        this.widget = dispose(this.widget);
    };
    ParameterHintsController.ID = 'editor.controller.parameterHints';
    ParameterHintsController = __decorate$g([
        __param$g(1, IInstantiationService)
    ], ParameterHintsController);
    return ParameterHintsController;
}());
var TriggerParameterHintsAction = /** @class */ (function (_super) {
    __extends$A(TriggerParameterHintsAction, _super);
    function TriggerParameterHintsAction() {
        return _super.call(this, {
            id: 'editor.action.triggerParameterHints',
            label: localize('parameterHints.trigger.label', "Trigger Parameter Hints"),
            alias: 'Trigger Parameter Hints',
            precondition: EditorContextKeys.hasSignatureHelpProvider,
            kbOpts: {
                kbExpr: EditorContextKeys.editorTextFocus,
                primary: 2048 /* CtrlCmd */ | 1024 /* Shift */ | 10 /* Space */
            }
        }) || this;
    }
    TriggerParameterHintsAction.prototype.run = function (accessor, editor) {
        var controller = ParameterHintsController.get(editor);
        if (controller) {
            controller.trigger();
        }
    };
    return TriggerParameterHintsAction;
}(EditorAction));
registerEditorContribution(ParameterHintsController);
registerEditorAction(TriggerParameterHintsAction);
var weight = KeybindingsRegistry.WEIGHT.editorContrib(75);
var ParameterHintsCommand = EditorCommand.bindToContribution(ParameterHintsController.get);
registerEditorCommand(new ParameterHintsCommand({
    id: 'closeParameterHints',
    precondition: Context.Visible,
    handler: function (x) { return x.cancel(); },
    kbOpts: {
        weight: weight,
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 9 /* Escape */,
        secondary: [1024 /* Shift */ | 9 /* Escape */]
    }
}));
registerEditorCommand(new ParameterHintsCommand({
    id: 'showPrevParameterHint',
    precondition: ContextKeyExpr.and(Context.Visible, Context.MultipleSignatures),
    handler: function (x) { return x.previous(); },
    kbOpts: {
        weight: weight,
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 16 /* UpArrow */,
        secondary: [512 /* Alt */ | 16 /* UpArrow */],
        mac: { primary: 16 /* UpArrow */, secondary: [512 /* Alt */ | 16 /* UpArrow */, 256 /* WinCtrl */ | 46 /* KEY_P */] }
    }
}));
registerEditorCommand(new ParameterHintsCommand({
    id: 'showNextParameterHint',
    precondition: ContextKeyExpr.and(Context.Visible, Context.MultipleSignatures),
    handler: function (x) { return x.next(); },
    kbOpts: {
        weight: weight,
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 18 /* DownArrow */,
        secondary: [512 /* Alt */ | 18 /* DownArrow */],
        mac: { primary: 18 /* DownArrow */, secondary: [512 /* Alt */ | 18 /* DownArrow */, 256 /* WinCtrl */ | 44 /* KEY_N */] }
    }
}));

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$B = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate$h = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$h = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var defaultReferenceSearchOptions = {
    getMetaTitle: function (model) {
        return model.references.length > 1 && localize('meta.titleReference', " – {0} references", model.references.length);
    }
};
var ReferenceController = /** @class */ (function () {
    function ReferenceController(editor, contextKeyService) {
        if (editor instanceof EmbeddedCodeEditorWidget) {
            PeekContext.inPeekEditor.bindTo(contextKeyService);
        }
    }
    ReferenceController.prototype.dispose = function () {
    };
    ReferenceController.prototype.getId = function () {
        return ReferenceController.ID;
    };
    ReferenceController.ID = 'editor.contrib.referenceController';
    ReferenceController = __decorate$h([
        __param$h(1, IContextKeyService)
    ], ReferenceController);
    return ReferenceController;
}());
var ReferenceAction = /** @class */ (function (_super) {
    __extends$B(ReferenceAction, _super);
    function ReferenceAction() {
        return _super.call(this, {
            id: 'editor.action.referenceSearch.trigger',
            label: localize('references.action.label', "Find All References"),
            alias: 'Find All References',
            precondition: ContextKeyExpr.and(EditorContextKeys.hasReferenceProvider, PeekContext.notInPeekEditor, EditorContextKeys.isInEmbeddedEditor.toNegated()),
            kbOpts: {
                kbExpr: EditorContextKeys.editorTextFocus,
                primary: 1024 /* Shift */ | 70 /* F12 */
            },
            menuOpts: {
                group: 'navigation',
                order: 1.5
            }
        }) || this;
    }
    ReferenceAction.prototype.run = function (accessor, editor) {
        var controller = ReferencesController.get(editor);
        if (!controller) {
            return;
        }
        var range$$1 = editor.getSelection();
        var model = editor.getModel();
        var references = provideReferences(model, range$$1.getStartPosition()).then(function (references) { return new ReferencesModel(references); });
        controller.toggleWidget(range$$1, references, defaultReferenceSearchOptions);
    };
    return ReferenceAction;
}(EditorAction));
registerEditorContribution(ReferenceController);
registerEditorAction(ReferenceAction);
var findReferencesCommand = function (accessor, resource, position) {
    if (!(resource instanceof URI)) {
        throw new Error('illegal argument, uri');
    }
    if (!position) {
        throw new Error('illegal argument, position');
    }
    return accessor.get(IEditorService).openEditor({ resource: resource }).then(function (editor) {
        var control = editor.getControl();
        if (!isCodeEditor(control)) {
            return undefined;
        }
        var controller = ReferencesController.get(control);
        if (!controller) {
            return undefined;
        }
        var references = provideReferences(control.getModel(), Position.lift(position)).then(function (references) { return new ReferencesModel(references); });
        var range$$1 = new Range(position.lineNumber, position.column, position.lineNumber, position.column);
        return TPromise.as(controller.toggleWidget(range$$1, references, defaultReferenceSearchOptions));
    });
};
var showReferencesCommand = function (accessor, resource, position, references) {
    if (!(resource instanceof URI)) {
        throw new Error('illegal argument, uri expected');
    }
    return accessor.get(IEditorService).openEditor({ resource: resource }).then(function (editor) {
        var control = editor.getControl();
        if (!isCodeEditor(control)) {
            return undefined;
        }
        var controller = ReferencesController.get(control);
        if (!controller) {
            return undefined;
        }
        return TPromise.as(controller.toggleWidget(new Range(position.lineNumber, position.column, position.lineNumber, position.column), TPromise.as(new ReferencesModel(references)), defaultReferenceSearchOptions)).then(function () { return true; });
    });
};
// register commands
CommandsRegistry.registerCommand({
    id: 'editor.action.findReferences',
    handler: findReferencesCommand
});
CommandsRegistry.registerCommand({
    id: 'editor.action.showReferences',
    handler: showReferencesCommand,
    description: {
        description: 'Show references at a position in a file',
        args: [
            { name: 'uri', description: 'The text document in which to show references', constraint: URI },
            { name: 'position', description: 'The position at which to show', constraint: Position.isIPosition },
            { name: 'locations', description: 'An array of locations.', constraint: Array },
        ]
    }
});
function closeActiveReferenceSearch(accessor, args) {
    withController(accessor, function (controller) { return controller.closeWidget(); });
}
function openReferenceToSide(accessor, args) {
    var listService = accessor.get(IListService);
    var focus = listService.lastFocusedList && listService.lastFocusedList.getFocus();
    if (focus instanceof OneReference) {
        withController(accessor, function (controller) { return controller.openReference(focus, true); });
    }
}
function withController(accessor, fn) {
    var outerEditor = getOuterEditor(accessor);
    if (!outerEditor) {
        return;
    }
    var controller = ReferencesController.get(outerEditor);
    if (!controller) {
        return;
    }
    fn(controller);
}
KeybindingsRegistry.registerCommandAndKeybindingRule({
    id: 'goToNextReference',
    weight: KeybindingsRegistry.WEIGHT.workbenchContrib(50),
    primary: 62 /* F4 */,
    when: ctxReferenceSearchVisible,
    handler: function (accessor) {
        withController(accessor, function (controller) {
            controller.goToNextOrPreviousReference(true);
        });
    }
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
    id: 'goToNextReferenceFromEmbeddedEditor',
    weight: KeybindingsRegistry.WEIGHT.editorContrib(50),
    primary: 62 /* F4 */,
    when: PeekContext.inPeekEditor,
    handler: function (accessor) {
        withController(accessor, function (controller) {
            controller.goToNextOrPreviousReference(true);
        });
    }
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
    id: 'goToPreviousReference',
    weight: KeybindingsRegistry.WEIGHT.workbenchContrib(50),
    primary: 1024 /* Shift */ | 62 /* F4 */,
    when: ctxReferenceSearchVisible,
    handler: function (accessor) {
        withController(accessor, function (controller) {
            controller.goToNextOrPreviousReference(false);
        });
    }
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
    id: 'goToPreviousReferenceFromEmbeddedEditor',
    weight: KeybindingsRegistry.WEIGHT.editorContrib(50),
    primary: 1024 /* Shift */ | 62 /* F4 */,
    when: PeekContext.inPeekEditor,
    handler: function (accessor) {
        withController(accessor, function (controller) {
            controller.goToNextOrPreviousReference(false);
        });
    }
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
    id: 'closeReferenceSearch',
    weight: KeybindingsRegistry.WEIGHT.workbenchContrib(50),
    primary: 9 /* Escape */,
    secondary: [1024 /* Shift */ | 9 /* Escape */],
    when: ContextKeyExpr.and(ctxReferenceSearchVisible, ContextKeyExpr.not('config.editor.stablePeek')),
    handler: closeActiveReferenceSearch
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
    id: 'closeReferenceSearchEditor',
    weight: KeybindingsRegistry.WEIGHT.editorContrib(-101),
    primary: 9 /* Escape */,
    secondary: [1024 /* Shift */ | 9 /* Escape */],
    when: ContextKeyExpr.and(PeekContext.inPeekEditor, ContextKeyExpr.not('config.editor.stablePeek')),
    handler: closeActiveReferenceSearch
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
    id: 'openReferenceToSide',
    weight: KeybindingsRegistry.WEIGHT.editorContrib(),
    primary: 2048 /* CtrlCmd */ | 3 /* Enter */,
    mac: {
        primary: 256 /* WinCtrl */ | 3 /* Enter */
    },
    when: ContextKeyExpr.and(ctxReferenceSearchVisible, ctxReferenceWidgetSearchTreeFocused),
    handler: openReferenceToSide
});
function provideReferences(model, position) {
    // collect references from all providers
    var promises = ReferenceProviderRegistry.ordered(model).map(function (provider) {
        return asWinJsPromise(function (token) {
            return provider.provideReferences(model, position, { includeDeclaration: true }, token);
        }).then(function (result) {
            if (Array.isArray(result)) {
                return result;
            }
            return undefined;
        }, function (err) {
            onUnexpectedExternalError(err);
        });
    });
    return TPromise.join(promises).then(function (references) {
        var result = [];
        for (var _i = 0, references_1 = references; _i < references_1.length; _i++) {
            var ref = references_1[_i];
            if (ref) {
                result.push.apply(result, ref);
            }
        }
        return result;
    });
}
registerDefaultLanguageCommand('_executeReferenceProvider', provideReferences);

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$C = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate$i = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$i = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var __awaiter$2 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator$2 = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var IRecording = /** @class */ (function () {
    function IRecording() {
    }
    IRecording.start = function (fileService) {
        var _changes = new Set();
        var stop$$1;
        if (fileService) {
            // watch only when there is a fileservice available
            stop$$1 = fileService.onFileChanges(function (event) {
                for (var _i = 0, _a = event.changes; _i < _a.length; _i++) {
                    var change = _a[_i];
                    if (change.type === FileChangeType.UPDATED) {
                        _changes.add(change.resource.toString());
                    }
                }
            });
        }
        return {
            stop: function () { return dispose(stop$$1); },
            hasChanged: function (resource) { return _changes.has(resource.toString()); }
        };
    };
    return IRecording;
}());
var EditTask = /** @class */ (function () {
    function EditTask(modelReference) {
        this._endCursorSelection = null;
        this._modelReference = modelReference;
        this._edits = [];
    }
    Object.defineProperty(EditTask.prototype, "_model", {
        get: function () { return this._modelReference.object.textEditorModel; },
        enumerable: true,
        configurable: true
    });
    EditTask.prototype.dispose = function () {
        if (this._model) {
            this._modelReference.dispose();
            this._modelReference = null;
        }
    };
    EditTask.prototype.addEdit = function (resourceEdit) {
        for (var _i = 0, _a = resourceEdit.edits; _i < _a.length; _i++) {
            var edit = _a[_i];
            if (typeof edit.eol === 'number') {
                // honor eol-change
                this._newEol = edit.eol;
            }
            if (edit.range || edit.text) {
                // create edit operation
                var range$$1 = void 0;
                if (!edit.range) {
                    range$$1 = this._model.getFullModelRange();
                }
                else {
                    range$$1 = Range.lift(edit.range);
                }
                this._edits.push(EditOperation.replaceMove(range$$1, edit.text));
            }
        }
    };
    EditTask.prototype.apply = function () {
        var _this = this;
        if (this._edits.length > 0) {
            this._edits = this._edits.map(function (value, index) { return ({ value: value, index: index }); }).sort(function (a, b) {
                var ret = Range.compareRangesUsingStarts(a.value.range, b.value.range);
                if (ret === 0) {
                    ret = a.index - b.index;
                }
                return ret;
            }).map(function (element) { return element.value; });
            this._initialSelections = this._getInitialSelections();
            this._model.pushStackElement();
            this._model.pushEditOperations(this._initialSelections, this._edits, function (edits) { return _this._getEndCursorSelections(edits); });
            this._model.pushStackElement();
        }
        if (this._newEol !== undefined) {
            this._model.pushStackElement();
            this._model.setEOL(this._newEol);
            this._model.pushStackElement();
        }
    };
    EditTask.prototype._getInitialSelections = function () {
        var firstRange = this._edits[0].range;
        var initialSelection = new Selection(firstRange.startLineNumber, firstRange.startColumn, firstRange.endLineNumber, firstRange.endColumn);
        return [initialSelection];
    };
    EditTask.prototype._getEndCursorSelections = function (inverseEditOperations) {
        var relevantEditIndex = 0;
        for (var i = 0; i < inverseEditOperations.length; i++) {
            var editRange = inverseEditOperations[i].range;
            for (var j = 0; j < this._initialSelections.length; j++) {
                var selectionRange = this._initialSelections[j];
                if (Range.areIntersectingOrTouching(editRange, selectionRange)) {
                    relevantEditIndex = i;
                    break;
                }
            }
        }
        var srcRange = inverseEditOperations[relevantEditIndex].range;
        this._endCursorSelection = new Selection(srcRange.endLineNumber, srcRange.endColumn, srcRange.endLineNumber, srcRange.endColumn);
        return [this._endCursorSelection];
    };
    EditTask.prototype.getEndCursorSelection = function () {
        return this._endCursorSelection;
    };
    return EditTask;
}());
var SourceModelEditTask = /** @class */ (function (_super) {
    __extends$C(SourceModelEditTask, _super);
    function SourceModelEditTask(modelReference, initialSelections) {
        var _this = _super.call(this, modelReference) || this;
        _this._knownInitialSelections = initialSelections;
        return _this;
    }
    SourceModelEditTask.prototype._getInitialSelections = function () {
        return this._knownInitialSelections;
    };
    return SourceModelEditTask;
}(EditTask));
var BulkEditModel = /** @class */ (function () {
    function BulkEditModel(textModelResolverService, editor, edits, progress) {
        this._edits = new Map();
        this._textModelResolverService = textModelResolverService;
        this._sourceModel = editor ? editor.getModel().uri : undefined;
        this._sourceSelections = editor ? editor.getSelections() : undefined;
        this._sourceModelTask = undefined;
        this._progress = progress;
        edits.forEach(this.addEdit, this);
    }
    BulkEditModel.prototype.dispose = function () {
        this._tasks = dispose(this._tasks);
    };
    BulkEditModel.prototype.addEdit = function (edit) {
        var array = this._edits.get(edit.resource.toString());
        if (!array) {
            array = [];
            this._edits.set(edit.resource.toString(), array);
        }
        array.push(edit);
    };
    BulkEditModel.prototype.prepare = function () {
        return __awaiter$2(this, void 0, TPromise, function () {
            var _this = this;
            var promises;
            return __generator$2(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this._tasks) {
                            throw new Error('illegal state - already prepared');
                        }
                        this._tasks = [];
                        promises = [];
                        this._edits.forEach(function (value, key) {
                            var promise = _this._textModelResolverService.createModelReference(URI.parse(key)).then(function (ref) {
                                var model = ref.object;
                                if (!model || !model.textEditorModel) {
                                    throw new Error("Cannot load file " + key);
                                }
                                var task;
                                if (_this._sourceModel && model.textEditorModel.uri.toString() === _this._sourceModel.toString()) {
                                    _this._sourceModelTask = new SourceModelEditTask(ref, _this._sourceSelections);
                                    task = _this._sourceModelTask;
                                }
                                else {
                                    task = new EditTask(ref);
                                }
                                value.forEach(function (edit) { return task.addEdit(edit); });
                                _this._tasks.push(task);
                                _this._progress.report(undefined);
                            });
                            promises.push(promise);
                        });
                        return [4 /*yield*/, TPromise.join(promises)];
                    case 1:
                        _a.sent();
                        return [2 /*return*/, this];
                }
            });
        });
    };
    BulkEditModel.prototype.apply = function () {
        for (var _i = 0, _a = this._tasks; _i < _a.length; _i++) {
            var task = _a[_i];
            task.apply();
            this._progress.report(undefined);
        }
        return this._sourceModelTask
            ? this._sourceModelTask.getEndCursorSelection()
            : undefined;
    };
    return BulkEditModel;
}());
var BulkEdit = /** @class */ (function () {
    function BulkEdit(editor, progress, _textModelService, _fileService) {
        this._textModelService = _textModelService;
        this._fileService = _fileService;
        this._edits = [];
        this._editor = editor;
        this._progress = progress || emptyProgressRunner;
    }
    BulkEdit.perform = function (edits, textModelService, fileService, editor) {
        var edit = new BulkEdit(editor, null, textModelService, fileService);
        edit.add(edits);
        return edit.perform();
    };
    BulkEdit.prototype.add = function (edits) {
        if (Array.isArray(edits)) {
            (_a = this._edits).push.apply(_a, edits);
        }
        else {
            this._edits.push(edits);
        }
        var _a;
    };
    BulkEdit.prototype.ariaMessage = function () {
        var editCount = this._edits.reduce(function (prev, cur) { return isResourceFileEdit(cur) ? prev : prev + cur.edits.length; }, 0);
        var resourceCount = this._edits.length;
        if (editCount === 0) {
            return localize('summary.0', "Made no edits");
        }
        else if (editCount > 1 && resourceCount > 1) {
            return localize('summary.nm', "Made {0} text edits in {1} files", editCount, resourceCount);
        }
        else {
            return localize('summary.n0', "Made {0} text edits in one file", editCount, resourceCount);
        }
    };
    BulkEdit.prototype.perform = function () {
        return __awaiter$2(this, void 0, TPromise, function () {
            var _this = this;
            var seen, total, groups, group, _i, _a, edit, progress, res, _b, groups_1, group_1;
            return __generator$2(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        seen = new Set();
                        total = 0;
                        groups = [];
                        for (_i = 0, _a = this._edits; _i < _a.length; _i++) {
                            edit = _a[_i];
                            if (!group
                                || (isResourceFileEdit(group[0]) && !isResourceFileEdit(edit))
                                || (isResourceTextEdit(group[0]) && !isResourceTextEdit(edit))) {
                                group = [];
                                groups.push(group);
                            }
                            group.push(edit);
                            if (isResourceFileEdit(edit)) {
                                total += 1;
                            }
                            else if (!seen.has(edit.resource.toString())) {
                                seen.add(edit.resource.toString());
                                total += 2;
                            }
                        }
                        // define total work and progress callback
                        // for child operations
                        this._progress.total(total);
                        progress = { report: function (_) { return _this._progress.worked(1); } };
                        res = undefined;
                        _b = 0, groups_1 = groups;
                        _c.label = 1;
                    case 1:
                        if (!(_b < groups_1.length)) return [3 /*break*/, 6];
                        group_1 = groups_1[_b];
                        if (!isResourceFileEdit(group_1[0])) return [3 /*break*/, 3];
                        return [4 /*yield*/, this._performFileEdits(group_1, progress)];
                    case 2:
                        _c.sent();
                        return [3 /*break*/, 5];
                    case 3: return [4 /*yield*/, this._performTextEdits(group_1, progress)];
                    case 4:
                        res = (_c.sent()) || res;
                        _c.label = 5;
                    case 5:
                        _b++;
                        return [3 /*break*/, 1];
                    case 6: return [2 /*return*/, res];
                }
            });
        });
    };
    BulkEdit.prototype._performFileEdits = function (edits, progress) {
        return __awaiter$2(this, void 0, void 0, function () {
            var _i, edits_1, edit;
            return __generator$2(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _i = 0, edits_1 = edits;
                        _a.label = 1;
                    case 1:
                        if (!(_i < edits_1.length)) return [3 /*break*/, 8];
                        edit = edits_1[_i];
                        progress.report(undefined);
                        if (!(edit.newUri && edit.oldUri)) return [3 /*break*/, 3];
                        return [4 /*yield*/, this._fileService.moveFile(edit.oldUri, edit.newUri, false)];
                    case 2:
                        _a.sent();
                        return [3 /*break*/, 7];
                    case 3:
                        if (!(!edit.newUri && edit.oldUri)) return [3 /*break*/, 5];
                        return [4 /*yield*/, this._fileService.del(edit.oldUri, true)];
                    case 4:
                        _a.sent();
                        return [3 /*break*/, 7];
                    case 5:
                        if (!(edit.newUri && !edit.oldUri)) return [3 /*break*/, 7];
                        return [4 /*yield*/, this._fileService.createFile(edit.newUri, undefined, { overwrite: false })];
                    case 6:
                        _a.sent();
                        _a.label = 7;
                    case 7:
                        _i++;
                        return [3 /*break*/, 1];
                    case 8: return [2 /*return*/];
                }
            });
        });
    };
    BulkEdit.prototype._performTextEdits = function (edits, progress) {
        return __awaiter$2(this, void 0, TPromise, function () {
            var recording, model, conflicts, selection;
            return __generator$2(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        recording = IRecording.start(this._fileService);
                        model = new BulkEditModel(this._textModelService, this._editor, edits, progress);
                        return [4 /*yield*/, model.prepare()];
                    case 1:
                        _a.sent();
                        conflicts = edits
                            .filter(function (edit) { return recording.hasChanged(edit.resource); })
                            .map(function (edit) { return getPathLabel(edit.resource); });
                        recording.stop();
                        if (conflicts.length > 0) {
                            model.dispose();
                            throw new Error(localize('conflict', "These files have changed in the meantime: {0}", conflicts.join(', ')));
                        }
                        return [4 /*yield*/, model.apply()];
                    case 2:
                        selection = _a.sent();
                        model.dispose();
                        return [2 /*return*/, selection];
                }
            });
        });
    };
    BulkEdit = __decorate$i([
        __param$i(2, ITextModelService),
        __param$i(3, optional(IFileService))
    ], BulkEdit);
    return BulkEdit;
}());

const css$m = "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n.monaco-editor .rename-box {\n\tz-index: 100;\n\tcolor: inherit;\n}\n\n.monaco-editor .rename-box .rename-input {\n\tpadding: 4px;\n}\n";
  const element$m = ((css, src) => {
if (typeof document !== 'object')
console.info(`Skipped loading "${src}"`);
try {
const id = src
  .replace(/\.css.*$/, '')
  .replace(/[\\:]/g, '/')
  .replace(/[^\w\/]+/g, '');
return (
  document.querySelector(`style[id="${id}"]`) ||
  document.head.appendChild(
    Object.assign(document.createElement('style'), {
      id,
      textContent: `${css}\n\n /* sourceURL=${src} */`,
    }),
  )
);
} catch (exception) {
console.warn(`Failed load "${src}"`, exception);
}
})(css$m, "…monaco-editor/esm/vs/editor/contrib/rename/renameInputField.css");
  //@ sourceURL=/Users/daflair/Projects/packages/monaco-es/node_modules/monaco-editor/esm/vs/editor/contrib/rename/renameInputField.css

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __decorate$j = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$j = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var RenameInputField = /** @class */ (function () {
    function RenameInputField(editor, themeService) {
        var _this = this;
        this.themeService = themeService;
        this._disposables = [];
        // Editor.IContentWidget.allowEditorOverflow
        this.allowEditorOverflow = true;
        this._currentAcceptInput = null;
        this._currentCancelInput = null;
        this._editor = editor;
        this._editor.addContentWidget(this);
        this._disposables.push(editor.onDidChangeConfiguration(function (e) {
            if (e.fontInfo) {
                _this.updateFont();
            }
        }));
        this._disposables.push(themeService.onThemeChange(function (theme) { return _this.onThemeChange(theme); }));
    }
    RenameInputField.prototype.onThemeChange = function (theme) {
        this.updateStyles(theme);
    };
    RenameInputField.prototype.dispose = function () {
        this._disposables = dispose(this._disposables);
        this._editor.removeContentWidget(this);
    };
    RenameInputField.prototype.getId = function () {
        return '__renameInputWidget';
    };
    RenameInputField.prototype.getDomNode = function () {
        if (!this._domNode) {
            this._inputField = document.createElement('input');
            this._inputField.className = 'rename-input';
            this._inputField.type = 'text';
            this._inputField.setAttribute('aria-label', localize('renameAriaLabel', "Rename input. Type new name and press Enter to commit."));
            this._domNode = document.createElement('div');
            this._domNode.style.height = this._editor.getConfiguration().lineHeight + "px";
            this._domNode.className = 'monaco-editor rename-box';
            this._domNode.appendChild(this._inputField);
            this.updateFont();
            this.updateStyles(this.themeService.getTheme());
        }
        return this._domNode;
    };
    RenameInputField.prototype.updateStyles = function (theme) {
        if (!this._inputField) {
            return;
        }
        var background = theme.getColor(inputBackground);
        var foreground$$1 = theme.getColor(inputForeground);
        var widgetShadowColor = theme.getColor(widgetShadow);
        var border = theme.getColor(inputBorder);
        this._inputField.style.backgroundColor = background ? background.toString() : null;
        this._inputField.style.color = foreground$$1 ? foreground$$1.toString() : null;
        this._inputField.style.borderWidth = border ? '1px' : '0px';
        this._inputField.style.borderStyle = border ? 'solid' : 'none';
        this._inputField.style.borderColor = border ? border.toString() : 'none';
        this._domNode.style.boxShadow = widgetShadowColor ? " 0 2px 8px " + widgetShadowColor : null;
    };
    RenameInputField.prototype.updateFont = function () {
        if (!this._inputField) {
            return;
        }
        var fontInfo = this._editor.getConfiguration().fontInfo;
        this._inputField.style.fontFamily = fontInfo.fontFamily;
        this._inputField.style.fontWeight = fontInfo.fontWeight;
        this._inputField.style.fontSize = fontInfo.fontSize + "px";
    };
    RenameInputField.prototype.getPosition = function () {
        return this._visible
            ? { position: this._position, preference: [ContentWidgetPositionPreference.BELOW, ContentWidgetPositionPreference.ABOVE] }
            : null;
    };
    RenameInputField.prototype.acceptInput = function () {
        if (this._currentAcceptInput) {
            this._currentAcceptInput();
        }
    };
    RenameInputField.prototype.cancelInput = function (focusEditor) {
        if (this._currentCancelInput) {
            this._currentCancelInput(focusEditor);
        }
    };
    RenameInputField.prototype.getInput = function (where, value, selectionStart, selectionEnd) {
        var _this = this;
        this._position = new Position(where.startLineNumber, where.startColumn);
        this._inputField.value = value;
        this._inputField.setAttribute('selectionStart', selectionStart.toString());
        this._inputField.setAttribute('selectionEnd', selectionEnd.toString());
        this._inputField.size = Math.max((where.endColumn - where.startColumn) * 1.1, 20);
        var disposeOnDone = [], always$$1;
        always$$1 = function () {
            dispose(disposeOnDone);
            _this._hide();
        };
        return new TPromise(function (resolve) {
            _this._currentCancelInput = function (focusEditor) {
                _this._currentAcceptInput = null;
                _this._currentCancelInput = null;
                resolve(focusEditor);
                return true;
            };
            _this._currentAcceptInput = function () {
                if (_this._inputField.value.trim().length === 0 || _this._inputField.value === value) {
                    // empty or whitespace only or not changed
                    _this.cancelInput(true);
                    return;
                }
                _this._currentAcceptInput = null;
                _this._currentCancelInput = null;
                resolve(_this._inputField.value);
            };
            var onCursorChanged = function () {
                if (!Range.containsPosition(where, _this._editor.getPosition())) {
                    _this.cancelInput(true);
                }
            };
            disposeOnDone.push(_this._editor.onDidChangeCursorSelection(onCursorChanged));
            disposeOnDone.push(_this._editor.onDidBlurEditor(function () { return _this.cancelInput(false); }));
            _this._show();
        }, function () {
            _this._currentCancelInput(true);
        }).then(function (newValue) {
            always$$1();
            return newValue;
        }, function (err) {
            always$$1();
            return TPromise.wrapError(err);
        });
    };
    RenameInputField.prototype._show = function () {
        var _this = this;
        this._editor.revealLineInCenterIfOutsideViewport(this._position.lineNumber, 0 /* Smooth */);
        this._visible = true;
        this._editor.layoutContentWidget(this);
        setTimeout(function () {
            _this._inputField.focus();
            _this._inputField.setSelectionRange(parseInt(_this._inputField.getAttribute('selectionStart')), parseInt(_this._inputField.getAttribute('selectionEnd')));
        }, 100);
    };
    RenameInputField.prototype._hide = function () {
        this._visible = false;
        this._editor.layoutContentWidget(this);
    };
    RenameInputField = __decorate$j([
        __param$j(1, IThemeService)
    ], RenameInputField);
    return RenameInputField;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$D = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate$k = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$k = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var __awaiter$3 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator$3 = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var RenameSkeleton = /** @class */ (function () {
    function RenameSkeleton(model, position) {
        this.model = model;
        this.position = position;
        this._provider = RenameProviderRegistry.ordered(model);
    }
    RenameSkeleton.prototype.hasProvider = function () {
        return this._provider.length > 0;
    };
    RenameSkeleton.prototype.resolveRenameLocation = function () {
        return __awaiter$3(this, void 0, TPromise, function () {
            var _this = this;
            var provider, res, word;
            return __generator$3(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        provider = this._provider[0];
                        if (!provider.resolveRenameLocation) return [3 /*break*/, 2];
                        return [4 /*yield*/, asWinJsPromise(function (token) { return provider.resolveRenameLocation(_this.model, _this.position, token); })];
                    case 1:
                        res = _a.sent();
                        _a.label = 2;
                    case 2:
                        if (!res) {
                            word = this.model.getWordAtPosition(this.position);
                            if (word) {
                                res = {
                                    range: new Range(this.position.lineNumber, word.startColumn, this.position.lineNumber, word.endColumn),
                                    text: word.word
                                };
                            }
                        }
                        return [2 /*return*/, res];
                }
            });
        });
    };
    RenameSkeleton.prototype.provideRenameEdits = function (newName, i, rejects, position) {
        if (i === void 0) { i = 0; }
        if (rejects === void 0) { rejects = []; }
        if (position === void 0) { position = this.position; }
        return __awaiter$3(this, void 0, TPromise, function () {
            var _this = this;
            var provider, result;
            return __generator$3(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (i >= this._provider.length) {
                            return [2 /*return*/, {
                                    edits: undefined,
                                    rejectReason: rejects.join('\n')
                                }];
                        }
                        provider = this._provider[i];
                        return [4 /*yield*/, asWinJsPromise(function (token) { return provider.provideRenameEdits(_this.model, _this.position, newName, token); })];
                    case 1:
                        result = _a.sent();
                        if (!result) {
                            return [2 /*return*/, this.provideRenameEdits(newName, i + 1, rejects.concat(localize('no result', "No result.")))];
                        }
                        else if (result.rejectReason) {
                            return [2 /*return*/, this.provideRenameEdits(newName, i + 1, rejects.concat(result.rejectReason))];
                        }
                        return [2 /*return*/, result];
                }
            });
        });
    };
    return RenameSkeleton;
}());
function rename(model, position, newName) {
    return __awaiter$3(this, void 0, TPromise, function () {
        return __generator$3(this, function (_a) {
            return [2 /*return*/, new RenameSkeleton(model, position).provideRenameEdits(newName)];
        });
    });
}
// ---  register actions and commands
var CONTEXT_RENAME_INPUT_VISIBLE = new RawContextKey('renameInputVisible', false);
var RenameController = /** @class */ (function () {
    function RenameController(editor, _notificationService, _textModelResolverService, _progressService, contextKeyService, themeService, _fileService) {
        this.editor = editor;
        this._notificationService = _notificationService;
        this._textModelResolverService = _textModelResolverService;
        this._progressService = _progressService;
        this._fileService = _fileService;
        this._renameInputField = new RenameInputField(editor, themeService);
        this._renameInputVisible = CONTEXT_RENAME_INPUT_VISIBLE.bindTo(contextKeyService);
    }
    RenameController.get = function (editor) {
        return editor.getContribution(RenameController.ID);
    };
    RenameController.prototype.dispose = function () {
        this._renameInputField.dispose();
    };
    RenameController.prototype.getId = function () {
        return RenameController.ID;
    };
    RenameController.prototype.run = function () {
        return __awaiter$3(this, void 0, TPromise, function () {
            var _this = this;
            var position, skeleton, loc, e_1, selection, selectionStart, selectionEnd;
            return __generator$3(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        position = this.editor.getPosition();
                        skeleton = new RenameSkeleton(this.editor.getModel(), position);
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, skeleton.resolveRenameLocation()];
                    case 2:
                        loc = _a.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        e_1 = _a.sent();
                        MessageController.get(this.editor).showMessage(e_1, position);
                        return [2 /*return*/, undefined];
                    case 4:
                        if (!loc) {
                            return [2 /*return*/, undefined];
                        }
                        selection = this.editor.getSelection();
                        selectionStart = 0;
                        selectionEnd = loc.text.length;
                        if (!Range.isEmpty(selection) && !Range.spansMultipleLines(selection) && Range.containsRange(loc.range, selection)) {
                            selectionStart = Math.max(0, selection.startColumn - loc.range.startColumn);
                            selectionEnd = Math.min(loc.range.endColumn, selection.endColumn) - loc.range.startColumn;
                        }
                        this._renameInputVisible.set(true);
                        return [2 /*return*/, this._renameInputField.getInput(loc.range, loc.text, selectionStart, selectionEnd).then(function (newNameOrFocusFlag) {
                                _this._renameInputVisible.reset();
                                if (typeof newNameOrFocusFlag === 'boolean') {
                                    if (newNameOrFocusFlag) {
                                        _this.editor.focus();
                                    }
                                    return undefined;
                                }
                                _this.editor.focus();
                                var edit = new BulkEdit(_this.editor, null, _this._textModelResolverService, _this._fileService);
                                var state = new EditorState(_this.editor, 4 /* Position */ | 1 /* Value */ | 2 /* Selection */ | 8 /* Scroll */);
                                var renameOperation = skeleton.provideRenameEdits(newNameOrFocusFlag, 0, [], Range.lift(loc.range).getStartPosition()).then(function (result) {
                                    if (result.rejectReason) {
                                        if (state.validate(_this.editor)) {
                                            MessageController.get(_this.editor).showMessage(result.rejectReason, _this.editor.getPosition());
                                        }
                                        else {
                                            _this._notificationService.info(result.rejectReason);
                                        }
                                        return undefined;
                                    }
                                    edit.add(result.edits);
                                    return edit.perform().then(function (selection) {
                                        if (selection) {
                                            _this.editor.setSelection(selection);
                                        }
                                        // alert
                                        alert(localize('aria', "Successfully renamed '{0}' to '{1}'. Summary: {2}", loc.text, newNameOrFocusFlag, edit.ariaMessage()));
                                    });
                                }, function (err) {
                                    _this._notificationService.error(localize('rename.failed', "Rename failed to execute."));
                                    return TPromise.wrapError(err);
                                });
                                _this._progressService.showWhile(renameOperation, 250);
                                return renameOperation;
                            }, function (err) {
                                _this._renameInputVisible.reset();
                                return TPromise.wrapError(err);
                            })];
                }
            });
        });
    };
    RenameController.prototype.acceptRenameInput = function () {
        this._renameInputField.acceptInput();
    };
    RenameController.prototype.cancelRenameInput = function () {
        this._renameInputField.cancelInput(true);
    };
    RenameController.ID = 'editor.contrib.renameController';
    RenameController = __decorate$k([
        __param$k(1, INotificationService),
        __param$k(2, ITextModelService),
        __param$k(3, IProgressService),
        __param$k(4, IContextKeyService),
        __param$k(5, IThemeService),
        __param$k(6, optional(IFileService))
    ], RenameController);
    return RenameController;
}());
// ---- action implementation
var RenameAction = /** @class */ (function (_super) {
    __extends$D(RenameAction, _super);
    function RenameAction() {
        return _super.call(this, {
            id: 'editor.action.rename',
            label: localize('rename.label', "Rename Symbol"),
            alias: 'Rename Symbol',
            precondition: ContextKeyExpr.and(EditorContextKeys.writable, EditorContextKeys.hasRenameProvider),
            kbOpts: {
                kbExpr: EditorContextKeys.editorTextFocus,
                primary: 60 /* F2 */
            },
            menuOpts: {
                group: '1_modification',
                order: 1.1
            }
        }) || this;
    }
    RenameAction.prototype.run = function (accessor, editor) {
        var controller = RenameController.get(editor);
        if (controller) {
            return controller.run();
        }
        return undefined;
    };
    return RenameAction;
}(EditorAction));
registerEditorContribution(RenameController);
registerEditorAction(RenameAction);
var RenameCommand = EditorCommand.bindToContribution(RenameController.get);
registerEditorCommand(new RenameCommand({
    id: 'acceptRenameInput',
    precondition: CONTEXT_RENAME_INPUT_VISIBLE,
    handler: function (x) { return x.acceptRenameInput(); },
    kbOpts: {
        weight: KeybindingsRegistry.WEIGHT.editorContrib(99),
        kbExpr: EditorContextKeys.focus,
        primary: 3 /* Enter */
    }
}));
registerEditorCommand(new RenameCommand({
    id: 'cancelRenameInput',
    precondition: CONTEXT_RENAME_INPUT_VISIBLE,
    handler: function (x) { return x.cancelRenameInput(); },
    kbOpts: {
        weight: KeybindingsRegistry.WEIGHT.editorContrib(99),
        kbExpr: EditorContextKeys.focus,
        primary: 9 /* Escape */,
        secondary: [1024 /* Shift */ | 9 /* Escape */]
    }
}));
// ---- api bridge command
registerDefaultLanguageCommand('_executeDocumentRenameProvider', function (model, position, args) {
    var newName = args.newName;
    if (typeof newName !== 'string') {
        throw illegalArgument('newName');
    }
    return rename(model, position, newName);
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$E = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var Node$1 = /** @class */ (function () {
    function Node() {
    }
    Object.defineProperty(Node.prototype, "range", {
        get: function () {
            return new Range(this.start.lineNumber, this.start.column, this.end.lineNumber, this.end.column);
        },
        enumerable: true,
        configurable: true
    });
    return Node;
}());
var NodeList = /** @class */ (function (_super) {
    __extends$E(NodeList, _super);
    function NodeList() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(NodeList.prototype, "start", {
        get: function () {
            return this.hasChildren
                ? this.children[0].start
                : this.parent.start;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NodeList.prototype, "end", {
        get: function () {
            return this.hasChildren
                ? this.children[this.children.length - 1].end
                : this.parent.end;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NodeList.prototype, "hasChildren", {
        get: function () {
            return this.children && this.children.length > 0;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NodeList.prototype, "isEmpty", {
        get: function () {
            return !this.hasChildren && !this.parent;
        },
        enumerable: true,
        configurable: true
    });
    NodeList.prototype.append = function (node) {
        if (!node) {
            return false;
        }
        node.parent = this;
        if (!this.children) {
            this.children = [];
        }
        if (node instanceof NodeList) {
            if (node.children) {
                this.children.push.apply(this.children, node.children);
            }
        }
        else {
            this.children.push(node);
        }
        return true;
    };
    return NodeList;
}(Node$1));
var Block = /** @class */ (function (_super) {
    __extends$E(Block, _super);
    function Block() {
        var _this = _super.call(this) || this;
        _this.elements = new NodeList();
        _this.elements.parent = _this;
        return _this;
    }
    Object.defineProperty(Block.prototype, "start", {
        get: function () {
            return this.open.start;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Block.prototype, "end", {
        get: function () {
            return this.close.end;
        },
        enumerable: true,
        configurable: true
    });
    return Block;
}(Node$1));
var Token = /** @class */ (function () {
    function Token(range$$1, bracket, bracketType) {
        this.range = range$$1;
        this.bracket = bracket;
        this.bracketType = bracketType;
    }
    return Token;
}());
function newNode(token) {
    var node = new Node$1();
    node.start = token.range.getStartPosition();
    node.end = token.range.getEndPosition();
    return node;
}
var RawToken = /** @class */ (function () {
    function RawToken(source, tokenIndex, lineNumber) {
        this.lineNumber = lineNumber;
        this.lineText = source.getLineContent();
        this.startOffset = source.getStartOffset(tokenIndex);
        this.endOffset = source.getEndOffset(tokenIndex);
        this.type = source.getStandardTokenType(tokenIndex);
        this.languageId = source.getLanguageId(tokenIndex);
    }
    return RawToken;
}());
var ModelRawTokenScanner = /** @class */ (function () {
    function ModelRawTokenScanner(model) {
        this._model = model;
        this._lineCount = this._model.getLineCount();
        this._versionId = this._model.getVersionId();
        this._lineNumber = 0;
        this._tokenIndex = 0;
        this._lineTokens = null;
        this._advance();
    }
    ModelRawTokenScanner.prototype._advance = function () {
        if (this._lineTokens) {
            this._tokenIndex++;
            if (this._tokenIndex >= this._lineTokens.getCount()) {
                this._lineTokens = null;
            }
        }
        while (this._lineNumber < this._lineCount && !this._lineTokens) {
            this._lineNumber++;
            this._model.forceTokenization(this._lineNumber);
            this._lineTokens = this._model.getLineTokens(this._lineNumber);
            this._tokenIndex = 0;
            if (this._lineTokens.getCount() === 0) {
                // Skip empty lines
                this._lineTokens = null;
            }
        }
    };
    ModelRawTokenScanner.prototype.next = function () {
        if (!this._lineTokens) {
            return null;
        }
        if (this._model.getVersionId() !== this._versionId) {
            return null;
        }
        var result = new RawToken(this._lineTokens, this._tokenIndex, this._lineNumber);
        this._advance();
        return result;
    };
    return ModelRawTokenScanner;
}());
var TokenScanner = /** @class */ (function () {
    function TokenScanner(model) {
        this._rawTokenScanner = new ModelRawTokenScanner(model);
        this._nextBuff = [];
        this._cachedLanguageBrackets = null;
        this._cachedLanguageId = -1;
    }
    TokenScanner.prototype.next = function () {
        if (this._nextBuff.length > 0) {
            return this._nextBuff.shift();
        }
        var token = this._rawTokenScanner.next();
        if (!token) {
            return null;
        }
        var lineNumber = token.lineNumber;
        var lineText = token.lineText;
        var tokenType = token.type;
        var startOffset = token.startOffset;
        var endOffset = token.endOffset;
        if (this._cachedLanguageId !== token.languageId) {
            this._cachedLanguageId = token.languageId;
            this._cachedLanguageBrackets = LanguageConfigurationRegistry.getBracketsSupport(this._cachedLanguageId);
        }
        var modeBrackets = this._cachedLanguageBrackets;
        if (!modeBrackets || ignoreBracketsInToken(tokenType)) {
            return new Token(new Range(lineNumber, startOffset + 1, lineNumber, endOffset + 1), 0 /* None */, null);
        }
        var foundBracket;
        do {
            foundBracket = BracketsUtils.findNextBracketInToken(modeBrackets.forwardRegex, lineNumber, lineText, startOffset, endOffset);
            if (foundBracket) {
                var foundBracketStartOffset = foundBracket.startColumn - 1;
                var foundBracketEndOffset = foundBracket.endColumn - 1;
                if (startOffset < foundBracketStartOffset) {
                    // there is some text before this bracket in this token
                    this._nextBuff.push(new Token(new Range(lineNumber, startOffset + 1, lineNumber, foundBracketStartOffset + 1), 0 /* None */, null));
                }
                var bracketText = lineText.substring(foundBracketStartOffset, foundBracketEndOffset);
                bracketText = bracketText.toLowerCase();
                var bracketData = modeBrackets.textIsBracket[bracketText];
                var bracketIsOpen = modeBrackets.textIsOpenBracket[bracketText];
                this._nextBuff.push(new Token(new Range(lineNumber, foundBracketStartOffset + 1, lineNumber, foundBracketEndOffset + 1), bracketIsOpen ? 1 /* Open */ : -1 /* Close */, bracketData.languageIdentifier.language + ";" + bracketData.open + ";" + bracketData.close));
                startOffset = foundBracketEndOffset;
            }
        } while (foundBracket);
        if (startOffset < endOffset) {
            // there is some remaining none-bracket text in this token
            this._nextBuff.push(new Token(new Range(lineNumber, startOffset + 1, lineNumber, endOffset + 1), 0 /* None */, null));
        }
        return this._nextBuff.shift();
    };
    return TokenScanner;
}());
var TokenTreeBuilder = /** @class */ (function () {
    function TokenTreeBuilder(model) {
        this._stack = [];
        this._scanner = new TokenScanner(model);
    }
    TokenTreeBuilder.prototype.build = function () {
        var node = new NodeList();
        while (node.append(this._line() || this._any())) {
            // accept all
        }
        return node;
    };
    TokenTreeBuilder.prototype._accept = function (condt) {
        var token = this._stack.pop() || this._scanner.next();
        if (!token) {
            return false;
        }
        var accepted = condt(token);
        if (!accepted) {
            this._stack.push(token);
            this._currentToken = null;
        }
        else {
            this._currentToken = token;
            //			console.log('accepted: ' + token.__debugContent);
        }
        return accepted;
    };
    TokenTreeBuilder.prototype._peek = function (condt) {
        var ret = false;
        this._accept(function (info) {
            ret = condt(info);
            return false;
        });
        return ret;
    };
    TokenTreeBuilder.prototype._line = function () {
        var node = new NodeList(), lineNumber;
        // capture current linenumber
        this._peek(function (info) {
            lineNumber = info.range.startLineNumber;
            return false;
        });
        while (this._peek(function (info) { return info.range.startLineNumber === lineNumber; })
            && node.append(this._token() || this._block())) {
            // all children that started on this line
        }
        if (!node.children || node.children.length === 0) {
            return null;
        }
        else if (node.children.length === 1) {
            return node.children[0];
        }
        else {
            return node;
        }
    };
    TokenTreeBuilder.prototype._token = function () {
        if (!this._accept(function (token) { return token.bracket === 0 /* None */; })) {
            return null;
        }
        return newNode(this._currentToken);
    };
    TokenTreeBuilder.prototype._block = function () {
        var bracketType, accepted;
        accepted = this._accept(function (token) {
            bracketType = token.bracketType;
            return token.bracket === 1 /* Open */;
        });
        if (!accepted) {
            return null;
        }
        var bracket = new Block();
        bracket.open = newNode(this._currentToken);
        while (bracket.elements.append(this._line())) {
            // inside brackets
        }
        if (!this._accept(function (token) { return token.bracket === -1 /* Close */ && token.bracketType === bracketType; })) {
            // missing closing bracket -> return just a node list
            var nodelist = new NodeList();
            nodelist.append(bracket.open);
            nodelist.append(bracket.elements);
            return nodelist;
        }
        bracket.close = newNode(this._currentToken);
        return bracket;
    };
    TokenTreeBuilder.prototype._any = function () {
        if (!this._accept(function (_) { return true; })) {
            return null;
        }
        return newNode(this._currentToken);
    };
    return TokenTreeBuilder;
}());
/**
 * Parses this grammar:
 *	grammer = { line }
 *	line = { block | "token" }
 *	block = "open_bracket" { line } "close_bracket"
 */
function build(model) {
    var node = new TokenTreeBuilder(model).build();
    return node;
}
function find(node, position) {
    if (node instanceof NodeList && node.isEmpty) {
        return null;
    }
    if (!Range.containsPosition(node.range, position)) {
        return null;
    }
    var result;
    if (node instanceof NodeList) {
        if (node.hasChildren) {
            for (var i = 0, len = node.children.length; i < len && !result; i++) {
                result = find(node.children[i], position);
            }
        }
    }
    else if (node instanceof Block) {
        result = find(node.open, position) || find(node.elements, position) || find(node.close, position);
    }
    return result || node;
}

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __decorate$l = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$l = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var TokenSelectionSupport = /** @class */ (function () {
    function TokenSelectionSupport(modelService) {
        this._modelService = modelService;
    }
    TokenSelectionSupport.prototype.getRangesToPosition = function (resource, position) {
        return TPromise.as(this.getRangesToPositionSync(resource, position));
    };
    TokenSelectionSupport.prototype.getRangesToPositionSync = function (resource, position) {
        var model = this._modelService.getModel(resource), entries = [];
        if (model) {
            this._doGetRangesToPosition(model, position).forEach(function (range$$1) {
                entries.push({
                    type: void 0,
                    range: range$$1
                });
            });
        }
        return entries;
    };
    TokenSelectionSupport.prototype._doGetRangesToPosition = function (model, position) {
        var tree = build(model), node, lastRange;
        node = find(tree, position);
        var ranges = [];
        while (node) {
            if (!lastRange || !Range.equalsRange(lastRange, node.range)) {
                ranges.push(node.range);
            }
            lastRange = node.range;
            node = node.parent;
        }
        ranges = ranges.reverse();
        return ranges;
    };
    TokenSelectionSupport = __decorate$l([
        __param$l(0, IModelService)
    ], TokenSelectionSupport);
    return TokenSelectionSupport;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$F = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate$m = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$m = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
// --- selection state machine
var State = /** @class */ (function () {
    function State(editor) {
        this.editor = editor;
        this.next = null;
        this.previous = null;
        this.selection = editor.getSelection();
    }
    return State;
}());
// --- shared state between grow and shrink actions
var state = null;
var ignoreSelection = false;
// -- action implementation
var SmartSelectController = /** @class */ (function () {
    function SmartSelectController(editor, instantiationService) {
        this.editor = editor;
        this._tokenSelectionSupport = instantiationService.createInstance(TokenSelectionSupport);
    }
    SmartSelectController.get = function (editor) {
        return editor.getContribution(SmartSelectController.ID);
    };
    SmartSelectController.prototype.dispose = function () {
    };
    SmartSelectController.prototype.getId = function () {
        return SmartSelectController.ID;
    };
    SmartSelectController.prototype.run = function (forward) {
        var _this = this;
        var selection = this.editor.getSelection();
        var model = this.editor.getModel();
        // forget about current state
        if (state) {
            if (state.editor !== this.editor) {
                state = null;
            }
        }
        var promise = TPromise.as(null);
        if (!state) {
            promise = this._tokenSelectionSupport.getRangesToPosition(model.uri, selection.getStartPosition()).then(function (elements) {
                if (isFalsyOrEmpty(elements)) {
                    return;
                }
                var lastState;
                elements.filter(function (element) {
                    // filter ranges inside the selection
                    var selection = _this.editor.getSelection();
                    var range$$1 = new Range(element.range.startLineNumber, element.range.startColumn, element.range.endLineNumber, element.range.endColumn);
                    return range$$1.containsPosition(selection.getStartPosition()) && range$$1.containsPosition(selection.getEndPosition());
                }).forEach(function (element) {
                    // create ranges
                    var range$$1 = element.range;
                    var state = new State(_this.editor);
                    state.selection = new Range(range$$1.startLineNumber, range$$1.startColumn, range$$1.endLineNumber, range$$1.endColumn);
                    if (lastState) {
                        state.next = lastState;
                        lastState.previous = state;
                    }
                    lastState = state;
                });
                // insert current selection
                var editorState = new State(_this.editor);
                editorState.next = lastState;
                if (lastState) {
                    lastState.previous = editorState;
                }
                state = editorState;
                // listen to caret move and forget about state
                var unhook = _this.editor.onDidChangeCursorPosition(function (e) {
                    if (ignoreSelection) {
                        return;
                    }
                    state = null;
                    unhook.dispose();
                });
            });
        }
        return promise.then(function () {
            if (!state) {
                return;
            }
            state = forward ? state.next : state.previous;
            if (!state) {
                return;
            }
            ignoreSelection = true;
            try {
                _this.editor.setSelection(state.selection);
            }
            finally {
                ignoreSelection = false;
            }
            return;
        });
    };
    SmartSelectController.ID = 'editor.contrib.smartSelectController';
    SmartSelectController = __decorate$m([
        __param$m(1, IInstantiationService)
    ], SmartSelectController);
    return SmartSelectController;
}());
var AbstractSmartSelect = /** @class */ (function (_super) {
    __extends$F(AbstractSmartSelect, _super);
    function AbstractSmartSelect(forward, opts) {
        var _this = _super.call(this, opts) || this;
        _this._forward = forward;
        return _this;
    }
    AbstractSmartSelect.prototype.run = function (accessor, editor) {
        var controller = SmartSelectController.get(editor);
        if (controller) {
            return controller.run(this._forward);
        }
        return undefined;
    };
    return AbstractSmartSelect;
}(EditorAction));
var GrowSelectionAction = /** @class */ (function (_super) {
    __extends$F(GrowSelectionAction, _super);
    function GrowSelectionAction() {
        return _super.call(this, true, {
            id: 'editor.action.smartSelect.grow',
            label: localize('smartSelect.grow', "Expand Select"),
            alias: 'Expand Select',
            precondition: null,
            kbOpts: {
                kbExpr: EditorContextKeys.editorTextFocus,
                primary: 1024 /* Shift */ | 512 /* Alt */ | 17 /* RightArrow */,
                mac: { primary: 2048 /* CtrlCmd */ | 256 /* WinCtrl */ | 1024 /* Shift */ | 17 /* RightArrow */ }
            }
        }) || this;
    }
    return GrowSelectionAction;
}(AbstractSmartSelect));
var ShrinkSelectionAction = /** @class */ (function (_super) {
    __extends$F(ShrinkSelectionAction, _super);
    function ShrinkSelectionAction() {
        return _super.call(this, false, {
            id: 'editor.action.smartSelect.shrink',
            label: localize('smartSelect.shrink', "Shrink Select"),
            alias: 'Shrink Select',
            precondition: null,
            kbOpts: {
                kbExpr: EditorContextKeys.editorTextFocus,
                primary: 1024 /* Shift */ | 512 /* Alt */ | 15 /* LeftArrow */,
                mac: { primary: 2048 /* CtrlCmd */ | 256 /* WinCtrl */ | 1024 /* Shift */ | 15 /* LeftArrow */ }
            }
        }) || this;
    }
    return ShrinkSelectionAction;
}(AbstractSmartSelect));
registerEditorContribution(SmartSelectController);
registerEditorAction(GrowSelectionAction);
registerEditorAction(ShrinkSelectionAction);

const css$n = "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n.monaco-editor.vs\t\t.snippet-placeholder { background-color: rgba(10, 50, 100, 0.2); min-width: 2px; }\n.monaco-editor.vs-dark\t.snippet-placeholder { background-color: rgba(124, 124, 124, 0.3); min-width: 2px; }\n.monaco-editor.hc-black\t.snippet-placeholder { background-color: rgba(124, 124, 124, 0.3); min-width: 2px; }\n\n.monaco-editor.vs\t\t.finish-snippet-placeholder { outline: rgba(10, 50, 100, 0.5) solid 1px; }\n.monaco-editor.vs-dark\t.finish-snippet-placeholder\t{ outline: #525252 solid 1px; }\n.monaco-editor.hc-black\t.finish-snippet-placeholder\t{ outline: #525252 solid 1px; }\n";
  const element$n = ((css, src) => {
if (typeof document !== 'object')
console.info(`Skipped loading "${src}"`);
try {
const id = src
  .replace(/\.css.*$/, '')
  .replace(/[\\:]/g, '/')
  .replace(/[^\w\/]+/g, '');
return (
  document.querySelector(`style[id="${id}"]`) ||
  document.head.appendChild(
    Object.assign(document.createElement('style'), {
      id,
      textContent: `${css}\n\n /* sourceURL=${src} */`,
    }),
  )
);
} catch (exception) {
console.warn(`Failed load "${src}"`, exception);
}
})(css$n, "…monaco-editor/esm/vs/editor/contrib/snippet/snippetSession.css");
  //@ sourceURL=/Users/daflair/Projects/packages/monaco-es/node_modules/monaco-editor/esm/vs/editor/contrib/snippet/snippetSession.css

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$G = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var TokenType;
(function (TokenType) {
    TokenType[TokenType["Dollar"] = 0] = "Dollar";
    TokenType[TokenType["Colon"] = 1] = "Colon";
    TokenType[TokenType["Comma"] = 2] = "Comma";
    TokenType[TokenType["CurlyOpen"] = 3] = "CurlyOpen";
    TokenType[TokenType["CurlyClose"] = 4] = "CurlyClose";
    TokenType[TokenType["Backslash"] = 5] = "Backslash";
    TokenType[TokenType["Forwardslash"] = 6] = "Forwardslash";
    TokenType[TokenType["Pipe"] = 7] = "Pipe";
    TokenType[TokenType["Int"] = 8] = "Int";
    TokenType[TokenType["VariableName"] = 9] = "VariableName";
    TokenType[TokenType["Format"] = 10] = "Format";
    TokenType[TokenType["Plus"] = 11] = "Plus";
    TokenType[TokenType["Dash"] = 12] = "Dash";
    TokenType[TokenType["QuestionMark"] = 13] = "QuestionMark";
    TokenType[TokenType["EOF"] = 14] = "EOF";
})(TokenType || (TokenType = {}));
var Scanner = /** @class */ (function () {
    function Scanner() {
        this.text('');
    }
    Scanner.isDigitCharacter = function (ch) {
        return ch >= 48 /* Digit0 */ && ch <= 57 /* Digit9 */;
    };
    Scanner.isVariableCharacter = function (ch) {
        return ch === 95 /* Underline */
            || (ch >= 97 /* a */ && ch <= 122 /* z */)
            || (ch >= 65 /* A */ && ch <= 90 /* Z */);
    };
    Scanner.prototype.text = function (value) {
        this.value = value;
        this.pos = 0;
    };
    Scanner.prototype.tokenText = function (token) {
        return this.value.substr(token.pos, token.len);
    };
    Scanner.prototype.next = function () {
        if (this.pos >= this.value.length) {
            return { type: TokenType.EOF, pos: this.pos, len: 0 };
        }
        var pos = this.pos;
        var len = 0;
        var ch = this.value.charCodeAt(pos);
        var type;
        // static types
        type = Scanner._table[ch];
        if (typeof type === 'number') {
            this.pos += 1;
            return { type: type, pos: pos, len: 1 };
        }
        // number
        if (Scanner.isDigitCharacter(ch)) {
            type = TokenType.Int;
            do {
                len += 1;
                ch = this.value.charCodeAt(pos + len);
            } while (Scanner.isDigitCharacter(ch));
            this.pos += len;
            return { type: type, pos: pos, len: len };
        }
        // variable name
        if (Scanner.isVariableCharacter(ch)) {
            type = TokenType.VariableName;
            do {
                ch = this.value.charCodeAt(pos + (++len));
            } while (Scanner.isVariableCharacter(ch) || Scanner.isDigitCharacter(ch));
            this.pos += len;
            return { type: type, pos: pos, len: len };
        }
        // format
        type = TokenType.Format;
        do {
            len += 1;
            ch = this.value.charCodeAt(pos + len);
        } while (!isNaN(ch)
            && typeof Scanner._table[ch] === 'undefined' // not static token
            && !Scanner.isDigitCharacter(ch) // not number
            && !Scanner.isVariableCharacter(ch) // not variable
        );
        this.pos += len;
        return { type: type, pos: pos, len: len };
    };
    Scanner._table = (_a = {},
        _a[36 /* DollarSign */] = TokenType.Dollar,
        _a[58 /* Colon */] = TokenType.Colon,
        _a[44 /* Comma */] = TokenType.Comma,
        _a[123 /* OpenCurlyBrace */] = TokenType.CurlyOpen,
        _a[125 /* CloseCurlyBrace */] = TokenType.CurlyClose,
        _a[92 /* Backslash */] = TokenType.Backslash,
        _a[47 /* Slash */] = TokenType.Forwardslash,
        _a[124 /* Pipe */] = TokenType.Pipe,
        _a[43 /* Plus */] = TokenType.Plus,
        _a[45 /* Dash */] = TokenType.Dash,
        _a[63 /* QuestionMark */] = TokenType.QuestionMark,
        _a);
    return Scanner;
}());
var Marker = /** @class */ (function () {
    function Marker() {
        this._children = [];
    }
    Marker.prototype.appendChild = function (child) {
        if (child instanceof Text && this._children[this._children.length - 1] instanceof Text) {
            // this and previous child are text -> merge them
            this._children[this._children.length - 1].value += child.value;
        }
        else {
            // normal adoption of child
            child.parent = this;
            this._children.push(child);
        }
        return this;
    };
    Marker.prototype.replace = function (child, others) {
        var parent = child.parent;
        var idx = parent.children.indexOf(child);
        var newChildren = parent.children.slice(0);
        newChildren.splice.apply(newChildren, [idx, 1].concat(others));
        parent._children = newChildren;
        others.forEach(function (node) { return node.parent = parent; });
    };
    Object.defineProperty(Marker.prototype, "children", {
        get: function () {
            return this._children;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Marker.prototype, "snippet", {
        get: function () {
            var candidate = this;
            while (true) {
                if (!candidate) {
                    return undefined;
                }
                if (candidate instanceof TextmateSnippet) {
                    return candidate;
                }
                candidate = candidate.parent;
            }
        },
        enumerable: true,
        configurable: true
    });
    Marker.prototype.toString = function () {
        return this.children.reduce(function (prev, cur) { return prev + cur.toString(); }, '');
    };
    Marker.prototype.len = function () {
        return 0;
    };
    return Marker;
}());
var Text = /** @class */ (function (_super) {
    __extends$G(Text, _super);
    function Text(value) {
        var _this = _super.call(this) || this;
        _this.value = value;
        return _this;
    }
    Text.escape = function (value) {
        return value.replace(/\$|}|\\/g, '\\$&');
    };
    Text.prototype.toString = function () {
        return this.value;
    };
    Text.prototype.toTextmateString = function () {
        return Text.escape(this.value);
    };
    Text.prototype.len = function () {
        return this.value.length;
    };
    Text.prototype.clone = function () {
        return new Text(this.value);
    };
    return Text;
}(Marker));
var Placeholder = /** @class */ (function (_super) {
    __extends$G(Placeholder, _super);
    function Placeholder(index) {
        var _this = _super.call(this) || this;
        _this.index = index;
        return _this;
    }
    Placeholder.compareByIndex = function (a, b) {
        if (a.index === b.index) {
            return 0;
        }
        else if (a.isFinalTabstop) {
            return 1;
        }
        else if (b.isFinalTabstop) {
            return -1;
        }
        else if (a.index < b.index) {
            return -1;
        }
        else if (a.index > b.index) {
            return 1;
        }
        else {
            return 0;
        }
    };
    Object.defineProperty(Placeholder.prototype, "isFinalTabstop", {
        get: function () {
            return this.index === 0;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Placeholder.prototype, "choice", {
        get: function () {
            return this._children.length === 1 && this._children[0] instanceof Choice
                ? this._children[0]
                : undefined;
        },
        enumerable: true,
        configurable: true
    });
    Placeholder.prototype.toTextmateString = function () {
        if (this.children.length === 0) {
            return "$" + this.index;
        }
        else if (this.choice) {
            return "${" + this.index + "|" + this.choice.toTextmateString() + "|}";
        }
        else {
            return "${" + this.index + ":" + this.children.map(function (child) { return child.toTextmateString(); }).join('') + "}";
        }
    };
    Placeholder.prototype.clone = function () {
        var ret = new Placeholder(this.index);
        ret._children = this.children.map(function (child) { return child.clone(); });
        return ret;
    };
    return Placeholder;
}(Marker));
var Choice = /** @class */ (function (_super) {
    __extends$G(Choice, _super);
    function Choice() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.options = [];
        return _this;
    }
    Choice.prototype.appendChild = function (marker) {
        if (marker instanceof Text) {
            marker.parent = this;
            this.options.push(marker);
        }
        return this;
    };
    Choice.prototype.toString = function () {
        return this.options[0].value;
    };
    Choice.prototype.toTextmateString = function () {
        return this.options
            .map(function (option) { return option.value.replace(/\||,/g, '\\$&'); })
            .join(',');
    };
    Choice.prototype.len = function () {
        return this.options[0].len();
    };
    Choice.prototype.clone = function () {
        var ret = new Choice();
        this.options.forEach(ret.appendChild, ret);
        return ret;
    };
    return Choice;
}(Marker));
var Transform = /** @class */ (function (_super) {
    __extends$G(Transform, _super);
    function Transform() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Transform.prototype.resolve = function (value) {
        var _this = this;
        return value.replace(this.regexp, function () {
            var ret = '';
            for (var _i = 0, _a = _this._children; _i < _a.length; _i++) {
                var marker = _a[_i];
                if (marker instanceof FormatString) {
                    var value_1 = arguments.length - 2 > marker.index ? arguments[marker.index] : '';
                    value_1 = marker.resolve(value_1);
                    ret += value_1;
                }
                else {
                    ret += marker.toString();
                }
            }
            return ret;
        });
    };
    Transform.prototype.toString = function () {
        return '';
    };
    Transform.prototype.toTextmateString = function () {
        return "/" + Text.escape(this.regexp.source) + "/" + this.children.map(function (c) { return c.toTextmateString(); }) + "/" + (this.regexp.ignoreCase ? 'i' : '');
    };
    Transform.prototype.clone = function () {
        var ret = new Transform();
        ret.regexp = new RegExp(this.regexp.source, '' + (this.regexp.ignoreCase ? 'i' : '') + (this.regexp.global ? 'g' : ''));
        ret._children = this.children.map(function (child) { return child.clone(); });
        return ret;
    };
    return Transform;
}(Marker));
var FormatString = /** @class */ (function (_super) {
    __extends$G(FormatString, _super);
    function FormatString(index, shorthandName, ifValue, elseValue) {
        var _this = _super.call(this) || this;
        _this.index = index;
        _this.shorthandName = shorthandName;
        _this.ifValue = ifValue;
        _this.elseValue = elseValue;
        return _this;
    }
    FormatString.prototype.resolve = function (value) {
        if (this.shorthandName === 'upcase') {
            return !value ? '' : value.toLocaleUpperCase();
        }
        else if (this.shorthandName === 'downcase') {
            return !value ? '' : value.toLocaleLowerCase();
        }
        else if (this.shorthandName === 'capitalize') {
            return !value ? '' : (value[0].toLocaleUpperCase() + value.substr(1));
        }
        else if (Boolean(value) && typeof this.ifValue === 'string') {
            return this.ifValue;
        }
        else if (!Boolean(value) && typeof this.elseValue === 'string') {
            return this.elseValue;
        }
        else {
            return value || '';
        }
    };
    FormatString.prototype.toTextmateString = function () {
        var value = '${';
        value += this.index;
        if (this.shorthandName) {
            value += ":/" + this.shorthandName;
        }
        else if (this.ifValue && this.elseValue) {
            value += ":?" + this.ifValue + ":" + this.elseValue;
        }
        else if (this.ifValue) {
            value += ":+" + this.ifValue;
        }
        else if (this.elseValue) {
            value += ":-" + this.elseValue;
        }
        value += '}';
        return value;
    };
    FormatString.prototype.clone = function () {
        var ret = new FormatString(this.index, this.shorthandName, this.ifValue, this.elseValue);
        return ret;
    };
    return FormatString;
}(Marker));
var Variable = /** @class */ (function (_super) {
    __extends$G(Variable, _super);
    function Variable(name) {
        var _this = _super.call(this) || this;
        _this.name = name;
        return _this;
    }
    Variable.prototype.resolve = function (resolver) {
        var value = resolver.resolve(this);
        var firstChild = this._children[0];
        if (firstChild instanceof Transform && this._children.length === 1) {
            value = firstChild.resolve(value || '');
        }
        if (value !== undefined) {
            this._children = [new Text(value)];
            return true;
        }
        return false;
    };
    Variable.prototype.toTextmateString = function () {
        if (this.children.length === 0) {
            return "${" + this.name + "}";
        }
        else {
            return "${" + this.name + ":" + this.children.map(function (child) { return child.toTextmateString(); }).join('') + "}";
        }
    };
    Variable.prototype.clone = function () {
        var ret = new Variable(this.name);
        ret._children = this.children.map(function (child) { return child.clone(); });
        return ret;
    };
    return Variable;
}(Marker));
function walk(marker, visitor) {
    var stack = marker.slice();
    while (stack.length > 0) {
        var marker_1 = stack.shift();
        var recurse = visitor(marker_1);
        if (!recurse) {
            break;
        }
        stack.unshift.apply(stack, marker_1.children);
    }
}
var TextmateSnippet = /** @class */ (function (_super) {
    __extends$G(TextmateSnippet, _super);
    function TextmateSnippet() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(TextmateSnippet.prototype, "placeholderInfo", {
        get: function () {
            if (!this._placeholders) {
                // fill in placeholders
                var all_1 = [];
                var last_1;
                this.walk(function (candidate) {
                    if (candidate instanceof Placeholder) {
                        all_1.push(candidate);
                        last_1 = !last_1 || last_1.index < candidate.index ? candidate : last_1;
                    }
                    return true;
                });
                this._placeholders = { all: all_1, last: last_1 };
            }
            return this._placeholders;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextmateSnippet.prototype, "placeholders", {
        get: function () {
            var all = this.placeholderInfo.all;
            return all;
        },
        enumerable: true,
        configurable: true
    });
    TextmateSnippet.prototype.offset = function (marker) {
        var pos = 0;
        var found = false;
        this.walk(function (candidate) {
            if (candidate === marker) {
                found = true;
                return false;
            }
            pos += candidate.len();
            return true;
        });
        if (!found) {
            return -1;
        }
        return pos;
    };
    TextmateSnippet.prototype.fullLen = function (marker) {
        var ret = 0;
        walk([marker], function (marker) {
            ret += marker.len();
            return true;
        });
        return ret;
    };
    TextmateSnippet.prototype.enclosingPlaceholders = function (placeholder) {
        var ret = [];
        var parent = placeholder.parent;
        while (parent) {
            if (parent instanceof Placeholder) {
                ret.push(parent);
            }
            parent = parent.parent;
        }
        return ret;
    };
    TextmateSnippet.prototype.resolveVariables = function (resolver) {
        var _this = this;
        this.walk(function (candidate) {
            if (candidate instanceof Variable) {
                if (candidate.resolve(resolver)) {
                    _this._placeholders = undefined;
                }
            }
            return true;
        });
        return this;
    };
    TextmateSnippet.prototype.appendChild = function (child) {
        this._placeholders = undefined;
        return _super.prototype.appendChild.call(this, child);
    };
    TextmateSnippet.prototype.replace = function (child, others) {
        this._placeholders = undefined;
        return _super.prototype.replace.call(this, child, others);
    };
    TextmateSnippet.prototype.toTextmateString = function () {
        return this.children.reduce(function (prev, cur) { return prev + cur.toTextmateString(); }, '');
    };
    TextmateSnippet.prototype.clone = function () {
        var ret = new TextmateSnippet();
        this._children = this.children.map(function (child) { return child.clone(); });
        return ret;
    };
    TextmateSnippet.prototype.walk = function (visitor) {
        walk(this.children, visitor);
    };
    return TextmateSnippet;
}(Marker));
var SnippetParser = /** @class */ (function () {
    function SnippetParser() {
        this._scanner = new Scanner();
    }
    SnippetParser.escape = function (value) {
        return value.replace(/\$|}|\\/g, '\\$&');
    };
    SnippetParser.prototype.text = function (value) {
        return this.parse(value).toString();
    };
    SnippetParser.prototype.parse = function (value, insertFinalTabstop, enforceFinalTabstop) {
        this._scanner.text(value);
        this._token = this._scanner.next();
        var snippet = new TextmateSnippet();
        while (this._parse(snippet)) {
            // nothing
        }
        // fill in values for placeholders. the first placeholder of an index
        // that has a value defines the value for all placeholders with that index
        var placeholderDefaultValues = new Map();
        var incompletePlaceholders = [];
        var placeholderCount = 0;
        snippet.walk(function (marker) {
            if (marker instanceof Placeholder) {
                placeholderCount += 1;
                if (marker.isFinalTabstop) {
                    placeholderDefaultValues.set(0, undefined);
                }
                else if (!placeholderDefaultValues.has(marker.index) && marker.children.length > 0) {
                    placeholderDefaultValues.set(marker.index, marker.children);
                }
                else {
                    incompletePlaceholders.push(marker);
                }
            }
            return true;
        });
        for (var _i = 0, incompletePlaceholders_1 = incompletePlaceholders; _i < incompletePlaceholders_1.length; _i++) {
            var placeholder = incompletePlaceholders_1[_i];
            if (placeholderDefaultValues.has(placeholder.index)) {
                var clone = new Placeholder(placeholder.index);
                for (var _a = 0, _b = placeholderDefaultValues.get(placeholder.index); _a < _b.length; _a++) {
                    var child = _b[_a];
                    clone.appendChild(child.clone());
                }
                snippet.replace(placeholder, [clone]);
            }
        }
        if (!enforceFinalTabstop) {
            enforceFinalTabstop = placeholderCount > 0 && insertFinalTabstop;
        }
        if (!placeholderDefaultValues.has(0) && enforceFinalTabstop) {
            // the snippet uses placeholders but has no
            // final tabstop defined -> insert at the end
            snippet.appendChild(new Placeholder(0));
        }
        return snippet;
    };
    SnippetParser.prototype._accept = function (type, value) {
        if (type === undefined || this._token.type === type) {
            var ret = !value ? true : this._scanner.tokenText(this._token);
            this._token = this._scanner.next();
            return ret;
        }
        return false;
    };
    SnippetParser.prototype._backTo = function (token) {
        this._scanner.pos = token.pos + token.len;
        this._token = token;
        return false;
    };
    SnippetParser.prototype._until = function (type) {
        if (this._token.type === TokenType.EOF) {
            return false;
        }
        var start = this._token;
        while (this._token.type !== type) {
            this._token = this._scanner.next();
        }
        var value = this._scanner.value.substring(start.pos, this._token.pos);
        this._token = this._scanner.next();
        return value;
    };
    SnippetParser.prototype._parse = function (marker) {
        return this._parseEscaped(marker)
            || this._parseTabstopOrVariableName(marker)
            || this._parseComplexPlaceholder(marker)
            || this._parseComplexVariable(marker)
            || this._parseAnything(marker);
    };
    // \$, \\, \} -> just text
    SnippetParser.prototype._parseEscaped = function (marker) {
        var value;
        if (value = this._accept(TokenType.Backslash, true)) {
            // saw a backslash, append escaped token or that backslash
            value = this._accept(TokenType.Dollar, true)
                || this._accept(TokenType.CurlyClose, true)
                || this._accept(TokenType.Backslash, true)
                || value;
            marker.appendChild(new Text(value));
            return true;
        }
        return false;
    };
    // $foo -> variable, $1 -> tabstop
    SnippetParser.prototype._parseTabstopOrVariableName = function (parent) {
        var value;
        var token = this._token;
        var match = this._accept(TokenType.Dollar)
            && (value = this._accept(TokenType.VariableName, true) || this._accept(TokenType.Int, true));
        if (!match) {
            return this._backTo(token);
        }
        parent.appendChild(/^\d+$/.test(value)
            ? new Placeholder(Number(value))
            : new Variable(value));
        return true;
    };
    // ${1:<children>}, ${1} -> placeholder
    SnippetParser.prototype._parseComplexPlaceholder = function (parent) {
        var index;
        var token = this._token;
        var match = this._accept(TokenType.Dollar)
            && this._accept(TokenType.CurlyOpen)
            && (index = this._accept(TokenType.Int, true));
        if (!match) {
            return this._backTo(token);
        }
        var placeholder = new Placeholder(Number(index));
        if (this._accept(TokenType.Colon)) {
            // ${1:<children>}
            while (true) {
                // ...} -> done
                if (this._accept(TokenType.CurlyClose)) {
                    parent.appendChild(placeholder);
                    return true;
                }
                if (this._parse(placeholder)) {
                    continue;
                }
                // fallback
                parent.appendChild(new Text('${' + index + ':'));
                placeholder.children.forEach(parent.appendChild, parent);
                return true;
            }
        }
        else if (placeholder.index > 0 && this._accept(TokenType.Pipe)) {
            // ${1|one,two,three|}
            var choice = new Choice();
            while (true) {
                if (this._parseChoiceElement(choice)) {
                    if (this._accept(TokenType.Comma)) {
                        // opt, -> more
                        continue;
                    }
                    if (this._accept(TokenType.Pipe) && this._accept(TokenType.CurlyClose)) {
                        // ..|} -> done
                        placeholder.appendChild(choice);
                        parent.appendChild(placeholder);
                        return true;
                    }
                }
                this._backTo(token);
                return false;
            }
        }
        else if (this._accept(TokenType.CurlyClose)) {
            // ${1}
            parent.appendChild(placeholder);
            return true;
        }
        else {
            // ${1 <- missing curly or colon
            return this._backTo(token);
        }
    };
    SnippetParser.prototype._parseChoiceElement = function (parent) {
        var token = this._token;
        var values = [];
        while (true) {
            if (this._token.type === TokenType.Comma || this._token.type === TokenType.Pipe) {
                break;
            }
            var value = void 0;
            if (value = this._accept(TokenType.Backslash, true)) {
                // \, or \|
                value = this._accept(TokenType.Comma, true)
                    || this._accept(TokenType.Pipe, true)
                    || value;
            }
            else {
                value = this._accept(undefined, true);
            }
            if (!value) {
                // EOF
                this._backTo(token);
                return false;
            }
            values.push(value);
        }
        if (values.length === 0) {
            this._backTo(token);
            return false;
        }
        parent.appendChild(new Text(values.join('')));
        return true;
    };
    // ${foo:<children>}, ${foo} -> variable
    SnippetParser.prototype._parseComplexVariable = function (parent) {
        var name;
        var token = this._token;
        var match = this._accept(TokenType.Dollar)
            && this._accept(TokenType.CurlyOpen)
            && (name = this._accept(TokenType.VariableName, true));
        if (!match) {
            return this._backTo(token);
        }
        var variable = new Variable(name);
        if (this._accept(TokenType.Colon)) {
            // ${foo:<children>}
            while (true) {
                // ...} -> done
                if (this._accept(TokenType.CurlyClose)) {
                    parent.appendChild(variable);
                    return true;
                }
                if (this._parse(variable)) {
                    continue;
                }
                // fallback
                parent.appendChild(new Text('${' + name + ':'));
                variable.children.forEach(parent.appendChild, parent);
                return true;
            }
        }
        else if (this._accept(TokenType.Forwardslash)) {
            // ${foo/<regex>/<format>/<options>}
            if (this._parseTransform(variable)) {
                parent.appendChild(variable);
                return true;
            }
            this._backTo(token);
            return false;
        }
        else if (this._accept(TokenType.CurlyClose)) {
            // ${foo}
            parent.appendChild(variable);
            return true;
        }
        else {
            // ${foo <- missing curly or colon
            return this._backTo(token);
        }
    };
    SnippetParser.prototype._parseTransform = function (parent) {
        // ...<regex>/<format>/<options>}
        var transform = new Transform();
        var regexValue = '';
        var regexOptions = '';
        // (1) /regex
        while (true) {
            if (this._accept(TokenType.Forwardslash)) {
                break;
            }
            var escaped = void 0;
            if (escaped = this._accept(TokenType.Backslash, true)) {
                escaped = this._accept(TokenType.Forwardslash, true) || escaped;
                regexValue += escaped;
                continue;
            }
            if (this._token.type !== TokenType.EOF) {
                regexValue += this._accept(undefined, true);
                continue;
            }
            return false;
        }
        // (2) /format
        while (true) {
            if (this._accept(TokenType.Forwardslash)) {
                break;
            }
            var escaped = void 0;
            if (escaped = this._accept(TokenType.Backslash, true)) {
                escaped = this._accept(TokenType.Forwardslash, true) || escaped;
                transform.appendChild(new Text(escaped));
                continue;
            }
            if (this._parseFormatString(transform) || this._parseAnything(transform)) {
                continue;
            }
            return false;
        }
        // (3) /option
        while (true) {
            if (this._accept(TokenType.CurlyClose)) {
                break;
            }
            if (this._token.type !== TokenType.EOF) {
                regexOptions += this._accept(undefined, true);
                continue;
            }
            return false;
        }
        try {
            transform.regexp = new RegExp(regexValue, regexOptions);
        }
        catch (e) {
            // invalid regexp
            return false;
        }
        parent.appendChild(transform);
        return true;
    };
    SnippetParser.prototype._parseFormatString = function (parent) {
        var token = this._token;
        if (!this._accept(TokenType.Dollar)) {
            return false;
        }
        var complex = false;
        if (this._accept(TokenType.CurlyOpen)) {
            complex = true;
        }
        var index = this._accept(TokenType.Int, true);
        if (!index) {
            this._backTo(token);
            return false;
        }
        else if (!complex) {
            // $1
            parent.appendChild(new FormatString(Number(index)));
            return true;
        }
        else if (this._accept(TokenType.CurlyClose)) {
            // ${1}
            parent.appendChild(new FormatString(Number(index)));
            return true;
        }
        else if (!this._accept(TokenType.Colon)) {
            this._backTo(token);
            return false;
        }
        if (this._accept(TokenType.Forwardslash)) {
            // ${1:/upcase}
            var shorthand = this._accept(TokenType.VariableName, true);
            if (!shorthand || !this._accept(TokenType.CurlyClose)) {
                this._backTo(token);
                return false;
            }
            else {
                parent.appendChild(new FormatString(Number(index), shorthand));
                return true;
            }
        }
        else if (this._accept(TokenType.Plus)) {
            // ${1:+<if>}
            var ifValue = this._until(TokenType.CurlyClose);
            if (ifValue) {
                parent.appendChild(new FormatString(Number(index), undefined, ifValue, undefined));
                return true;
            }
        }
        else if (this._accept(TokenType.Dash)) {
            // ${2:-<else>}
            var elseValue = this._until(TokenType.CurlyClose);
            if (elseValue) {
                parent.appendChild(new FormatString(Number(index), undefined, undefined, elseValue));
                return true;
            }
        }
        else if (this._accept(TokenType.QuestionMark)) {
            // ${2:?<if>:<else>}
            var ifValue = this._until(TokenType.Colon);
            if (ifValue) {
                var elseValue = this._until(TokenType.CurlyClose);
                if (elseValue) {
                    parent.appendChild(new FormatString(Number(index), undefined, ifValue, elseValue));
                    return true;
                }
            }
        }
        else {
            // ${1:<else>}
            var elseValue = this._until(TokenType.CurlyClose);
            if (elseValue) {
                parent.appendChild(new FormatString(Number(index), undefined, undefined, elseValue));
                return true;
            }
        }
        this._backTo(token);
        return false;
    };
    SnippetParser.prototype._parseAnything = function (marker) {
        if (this._token.type !== TokenType.EOF) {
            marker.appendChild(new Text(this._scanner.tokenText(this._token)));
            this._accept(undefined);
            return true;
        }
        return false;
    };
    return SnippetParser;
}());
var _a;

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var KnownSnippetVariableNames = Object.freeze({
    'CURRENT_YEAR': true,
    'CURRENT_YEAR_SHORT': true,
    'CURRENT_MONTH': true,
    'CURRENT_DATE': true,
    'CURRENT_HOUR': true,
    'CURRENT_MINUTE': true,
    'CURRENT_SECOND': true,
    'CURRENT_DAY_NAME': true,
    'CURRENT_DAY_NAME_SHORT': true,
    'CURRENT_MONTH_NAME': true,
    'CURRENT_MONTH_NAME_SHORT': true,
    'SELECTION': true,
    'CLIPBOARD': true,
    'TM_SELECTED_TEXT': true,
    'TM_CURRENT_LINE': true,
    'TM_CURRENT_WORD': true,
    'TM_LINE_INDEX': true,
    'TM_LINE_NUMBER': true,
    'TM_FILENAME': true,
    'TM_FILENAME_BASE': true,
    'TM_DIRECTORY': true,
    'TM_FILEPATH': true,
});
var CompositeSnippetVariableResolver = /** @class */ (function () {
    function CompositeSnippetVariableResolver(_delegates) {
        this._delegates = _delegates;
        //
    }
    CompositeSnippetVariableResolver.prototype.resolve = function (variable) {
        for (var _i = 0, _a = this._delegates; _i < _a.length; _i++) {
            var delegate = _a[_i];
            var value = delegate.resolve(variable);
            if (value !== void 0) {
                return value;
            }
        }
        return undefined;
    };
    return CompositeSnippetVariableResolver;
}());
var SelectionBasedVariableResolver = /** @class */ (function () {
    function SelectionBasedVariableResolver(_model, _selection) {
        this._model = _model;
        this._selection = _selection;
        //
    }
    SelectionBasedVariableResolver.prototype.resolve = function (variable) {
        var name = variable.name;
        if (name === 'SELECTION' || name === 'TM_SELECTED_TEXT') {
            var value = this._model.getValueInRange(this._selection) || undefined;
            if (value && this._selection.startLineNumber !== this._selection.endLineNumber) {
                // Selection is a multiline string which we indentation we now
                // need to adjust. We compare the indentation of this variable
                // with the indentation at the editor position and add potential
                // extra indentation to the value
                var line = this._model.getLineContent(this._selection.startLineNumber);
                var lineLeadingWhitespace = getLeadingWhitespace(line, 0, this._selection.startColumn - 1);
                var varLeadingWhitespace_1 = lineLeadingWhitespace;
                variable.snippet.walk(function (marker) {
                    if (marker === variable) {
                        return false;
                    }
                    if (marker instanceof Text) {
                        varLeadingWhitespace_1 = getLeadingWhitespace(marker.value.split(/\r\n|\r|\n/).pop());
                    }
                    return true;
                });
                var whitespaceCommonLength_1 = commonPrefixLength(varLeadingWhitespace_1, lineLeadingWhitespace);
                value = value.replace(/(\r\n|\r|\n)(.*)/g, function (m, newline, rest) { return "" + newline + varLeadingWhitespace_1.substr(whitespaceCommonLength_1) + rest; });
            }
            return value;
        }
        else if (name === 'TM_CURRENT_LINE') {
            return this._model.getLineContent(this._selection.positionLineNumber);
        }
        else if (name === 'TM_CURRENT_WORD') {
            var info = this._model.getWordAtPosition({
                lineNumber: this._selection.positionLineNumber,
                column: this._selection.positionColumn
            });
            return info && info.word || undefined;
        }
        else if (name === 'TM_LINE_INDEX') {
            return String(this._selection.positionLineNumber - 1);
        }
        else if (name === 'TM_LINE_NUMBER') {
            return String(this._selection.positionLineNumber);
        }
        return undefined;
    };
    return SelectionBasedVariableResolver;
}());
var ModelBasedVariableResolver = /** @class */ (function () {
    function ModelBasedVariableResolver(_model) {
        this._model = _model;
        //
    }
    ModelBasedVariableResolver.prototype.resolve = function (variable) {
        var name = variable.name;
        if (name === 'TM_FILENAME') {
            return basename(this._model.uri.fsPath);
        }
        else if (name === 'TM_FILENAME_BASE') {
            var name_1 = basename(this._model.uri.fsPath);
            var idx = name_1.lastIndexOf('.');
            if (idx <= 0) {
                return name_1;
            }
            else {
                return name_1.slice(0, idx);
            }
        }
        else if (name === 'TM_DIRECTORY') {
            var dir = dirname(this._model.uri.fsPath);
            return dir !== '.' ? dir : '';
        }
        else if (name === 'TM_FILEPATH') {
            return this._model.uri.fsPath;
        }
        return undefined;
    };
    return ModelBasedVariableResolver;
}());
var ClipboardBasedVariableResolver = /** @class */ (function () {
    function ClipboardBasedVariableResolver(_clipboardService, _selectionIdx, _selectionCount) {
        this._clipboardService = _clipboardService;
        this._selectionIdx = _selectionIdx;
        this._selectionCount = _selectionCount;
        //
    }
    ClipboardBasedVariableResolver.prototype.resolve = function (variable) {
        if (variable.name !== 'CLIPBOARD' || !this._clipboardService) {
            return undefined;
        }
        var text = this._clipboardService.readText();
        if (!text) {
            return undefined;
        }
        var lines = text.split(/\r\n|\n|\r/).filter(function (s) { return !isFalsyOrWhitespace(s); });
        if (lines.length === this._selectionCount) {
            return lines[this._selectionIdx];
        }
        else {
            return text;
        }
    };
    return ClipboardBasedVariableResolver;
}());
var TimeBasedVariableResolver = /** @class */ (function () {
    function TimeBasedVariableResolver() {
    }
    TimeBasedVariableResolver.prototype.resolve = function (variable) {
        var name = variable.name;
        if (name === 'CURRENT_YEAR') {
            return String(new Date().getFullYear());
        }
        else if (name === 'CURRENT_YEAR_SHORT') {
            return String(new Date().getFullYear()).slice(-2);
        }
        else if (name === 'CURRENT_MONTH') {
            return pad((new Date().getMonth().valueOf() + 1), 2);
        }
        else if (name === 'CURRENT_DATE') {
            return pad(new Date().getDate().valueOf(), 2);
        }
        else if (name === 'CURRENT_HOUR') {
            return pad(new Date().getHours().valueOf(), 2);
        }
        else if (name === 'CURRENT_MINUTE') {
            return pad(new Date().getMinutes().valueOf(), 2);
        }
        else if (name === 'CURRENT_SECOND') {
            return pad(new Date().getSeconds().valueOf(), 2);
        }
        else if (name === 'CURRENT_DAY_NAME') {
            return TimeBasedVariableResolver.dayNames[new Date().getDay()];
        }
        else if (name === 'CURRENT_DAY_NAME_SHORT') {
            return TimeBasedVariableResolver.dayNamesShort[new Date().getDay()];
        }
        else if (name === 'CURRENT_MONTH_NAME') {
            return TimeBasedVariableResolver.monthNames[new Date().getMonth()];
        }
        else if (name === 'CURRENT_MONTH_NAME_SHORT') {
            return TimeBasedVariableResolver.monthNamesShort[new Date().getMonth()];
        }
        return undefined;
    };
    TimeBasedVariableResolver.dayNames = [localize('Sunday', "Sunday"), localize('Monday', "Monday"), localize('Tuesday', "Tuesday"), localize('Wednesday', "Wednesday"), localize('Thursday', "Thursday"), localize('Friday', "Friday"), localize('Saturday', "Saturday")];
    TimeBasedVariableResolver.dayNamesShort = [localize('SundayShort', "Sun"), localize('MondayShort', "Mon"), localize('TuesdayShort', "Tue"), localize('WednesdayShort', "Wed"), localize('ThursdayShort', "Thu"), localize('FridayShort', "Fri"), localize('SaturdayShort', "Sat")];
    TimeBasedVariableResolver.monthNames = [localize('January', "January"), localize('February', "February"), localize('March', "March"), localize('April', "April"), localize('May', "May"), localize('June', "June"), localize('July', "July"), localize('August', "August"), localize('September', "September"), localize('October', "October"), localize('November', "November"), localize('December', "December")];
    TimeBasedVariableResolver.monthNamesShort = [localize('JanuaryShort', "Jan"), localize('FebruaryShort', "Feb"), localize('MarchShort', "Mar"), localize('AprilShort', "Apr"), localize('MayShort', "May"), localize('JuneShort', "Jun"), localize('JulyShort', "Jul"), localize('AugustShort', "Aug"), localize('SeptemberShort', "Sep"), localize('OctoberShort', "Oct"), localize('NovemberShort', "Nov"), localize('DecemberShort', "Dec")];
    return TimeBasedVariableResolver;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var OneSnippet = /** @class */ (function () {
    function OneSnippet(editor, snippet, offset) {
        this._nestingLevel = 1;
        this._editor = editor;
        this._snippet = snippet;
        this._offset = offset;
        this._placeholderGroups = groupBy(snippet.placeholders, Placeholder.compareByIndex);
        this._placeholderGroupsIdx = -1;
    }
    OneSnippet.prototype.dispose = function () {
        if (this._placeholderDecorations) {
            var toRemove_1 = [];
            this._placeholderDecorations.forEach(function (handle) { return toRemove_1.push(handle); });
            this._editor.deltaDecorations(toRemove_1, []);
        }
        this._placeholderGroups.length = 0;
    };
    OneSnippet.prototype._initDecorations = function () {
        var _this = this;
        if (this._placeholderDecorations) {
            // already initialized
            return;
        }
        this._placeholderDecorations = new Map();
        var model = this._editor.getModel();
        this._editor.changeDecorations(function (accessor) {
            // create a decoration for each placeholder
            for (var _i = 0, _a = _this._snippet.placeholders; _i < _a.length; _i++) {
                var placeholder = _a[_i];
                var placeholderOffset = _this._snippet.offset(placeholder);
                var placeholderLen = _this._snippet.fullLen(placeholder);
                var range$$1 = Range.fromPositions(model.getPositionAt(_this._offset + placeholderOffset), model.getPositionAt(_this._offset + placeholderOffset + placeholderLen));
                var options = placeholder.isFinalTabstop ? OneSnippet._decor.inactiveFinal : OneSnippet._decor.inactive;
                var handle = accessor.addDecoration(range$$1, options);
                _this._placeholderDecorations.set(placeholder, handle);
            }
        });
    };
    OneSnippet.prototype.move = function (fwd) {
        var _this = this;
        this._initDecorations();
        if (fwd === true && this._placeholderGroupsIdx < this._placeholderGroups.length - 1) {
            this._placeholderGroupsIdx += 1;
        }
        else if (fwd === false && this._placeholderGroupsIdx > 0) {
            this._placeholderGroupsIdx -= 1;
        }
        return this._editor.getModel().changeDecorations(function (accessor) {
            var activePlaceholders = new Set();
            // change stickiness to always grow when typing at its edges
            // because these decorations represent the currently active
            // tabstop.
            // Special case #1: reaching the final tabstop
            // Special case #2: placeholders enclosing active placeholders
            var selections = [];
            for (var _i = 0, _a = _this._placeholderGroups[_this._placeholderGroupsIdx]; _i < _a.length; _i++) {
                var placeholder = _a[_i];
                var id = _this._placeholderDecorations.get(placeholder);
                var range$$1 = _this._editor.getModel().getDecorationRange(id);
                selections.push(new Selection(range$$1.startLineNumber, range$$1.startColumn, range$$1.endLineNumber, range$$1.endColumn));
                accessor.changeDecorationOptions(id, placeholder.isFinalTabstop ? OneSnippet._decor.activeFinal : OneSnippet._decor.active);
                activePlaceholders.add(placeholder);
                for (var _b = 0, _c = _this._snippet.enclosingPlaceholders(placeholder); _b < _c.length; _b++) {
                    var enclosingPlaceholder = _c[_b];
                    var id_1 = _this._placeholderDecorations.get(enclosingPlaceholder);
                    accessor.changeDecorationOptions(id_1, enclosingPlaceholder.isFinalTabstop ? OneSnippet._decor.activeFinal : OneSnippet._decor.active);
                    activePlaceholders.add(enclosingPlaceholder);
                }
            }
            // change stickness to never grow when typing at its edges
            // so that in-active tabstops never grow
            _this._placeholderDecorations.forEach(function (id, placeholder) {
                if (!activePlaceholders.has(placeholder)) {
                    accessor.changeDecorationOptions(id, placeholder.isFinalTabstop ? OneSnippet._decor.inactiveFinal : OneSnippet._decor.inactive);
                }
            });
            return selections;
        });
    };
    Object.defineProperty(OneSnippet.prototype, "isAtFirstPlaceholder", {
        get: function () {
            return this._placeholderGroupsIdx <= 0 || this._placeholderGroups.length === 0;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OneSnippet.prototype, "isAtLastPlaceholder", {
        get: function () {
            return this._placeholderGroupsIdx === this._placeholderGroups.length - 1;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OneSnippet.prototype, "hasPlaceholder", {
        get: function () {
            return this._snippet.placeholders.length > 0;
        },
        enumerable: true,
        configurable: true
    });
    OneSnippet.prototype.computePossibleSelections = function () {
        var result = new Map();
        for (var _i = 0, _a = this._placeholderGroups; _i < _a.length; _i++) {
            var placeholdersWithEqualIndex = _a[_i];
            var ranges = void 0;
            for (var _b = 0, placeholdersWithEqualIndex_1 = placeholdersWithEqualIndex; _b < placeholdersWithEqualIndex_1.length; _b++) {
                var placeholder = placeholdersWithEqualIndex_1[_b];
                if (placeholder.isFinalTabstop) {
                    // ignore those
                    break;
                }
                if (!ranges) {
                    ranges = [];
                    result.set(placeholder.index, ranges);
                }
                var id = this._placeholderDecorations.get(placeholder);
                var range$$1 = this._editor.getModel().getDecorationRange(id);
                ranges.push(range$$1);
            }
        }
        return result;
    };
    Object.defineProperty(OneSnippet.prototype, "choice", {
        get: function () {
            return this._placeholderGroups[this._placeholderGroupsIdx][0].choice;
        },
        enumerable: true,
        configurable: true
    });
    OneSnippet.prototype.merge = function (others) {
        var _this = this;
        var model = this._editor.getModel();
        this._nestingLevel *= 10;
        this._editor.changeDecorations(function (accessor) {
            // For each active placeholder take one snippet and merge it
            // in that the placeholder (can be many for `$1foo$1foo`). Because
            // everything is sorted by editor selection we can simply remove
            // elements from the beginning of the array
            for (var _i = 0, _a = _this._placeholderGroups[_this._placeholderGroupsIdx]; _i < _a.length; _i++) {
                var placeholder = _a[_i];
                var nested = others.shift();
                console.assert(!nested._placeholderDecorations);
                // Massage placeholder-indicies of the nested snippet to be
                // sorted right after the insertion point. This ensures we move
                // through the placeholders in the correct order
                for (var _b = 0, _c = nested._snippet.placeholderInfo.all; _b < _c.length; _b++) {
                    var nestedPlaceholder = _c[_b];
                    if (nestedPlaceholder.isFinalTabstop) {
                        nestedPlaceholder.index = placeholder.index + ((nested._snippet.placeholderInfo.last.index + 1) / _this._nestingLevel);
                    }
                    else {
                        nestedPlaceholder.index = placeholder.index + (nestedPlaceholder.index / _this._nestingLevel);
                    }
                }
                _this._snippet.replace(placeholder, nested._snippet.children);
                // Remove the placeholder at which position are inserting
                // the snippet and also remove its decoration.
                var id = _this._placeholderDecorations.get(placeholder);
                accessor.removeDecoration(id);
                _this._placeholderDecorations.delete(placeholder);
                // For each *new* placeholder we create decoration to monitor
                // how and if it grows/shrinks.
                for (var _d = 0, _e = nested._snippet.placeholders; _d < _e.length; _d++) {
                    var placeholder_1 = _e[_d];
                    var placeholderOffset = nested._snippet.offset(placeholder_1);
                    var placeholderLen = nested._snippet.fullLen(placeholder_1);
                    var range$$1 = Range.fromPositions(model.getPositionAt(nested._offset + placeholderOffset), model.getPositionAt(nested._offset + placeholderOffset + placeholderLen));
                    var handle = accessor.addDecoration(range$$1, OneSnippet._decor.inactive);
                    _this._placeholderDecorations.set(placeholder_1, handle);
                }
            }
            // Last, re-create the placeholder groups by sorting placeholders by their index.
            _this._placeholderGroups = groupBy(_this._snippet.placeholders, Placeholder.compareByIndex);
        });
    };
    OneSnippet.prototype.getEnclosingRange = function () {
        var result;
        var model = this._editor.getModel();
        this._placeholderDecorations.forEach(function (decorationId) {
            var placeholderRange = model.getDecorationRange(decorationId);
            if (!result) {
                result = placeholderRange;
            }
            else {
                result = result.plusRange(placeholderRange);
            }
        });
        return result;
    };
    OneSnippet._decor = {
        active: ModelDecorationOptions.register({ stickiness: TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges, className: 'snippet-placeholder' }),
        inactive: ModelDecorationOptions.register({ stickiness: TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges, className: 'snippet-placeholder' }),
        activeFinal: ModelDecorationOptions.register({ stickiness: TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges, className: 'finish-snippet-placeholder' }),
        inactiveFinal: ModelDecorationOptions.register({ stickiness: TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges, className: 'finish-snippet-placeholder' }),
    };
    return OneSnippet;
}());
var SnippetSession = /** @class */ (function () {
    function SnippetSession(editor, template, overwriteBefore, overwriteAfter) {
        if (overwriteBefore === void 0) { overwriteBefore = 0; }
        if (overwriteAfter === void 0) { overwriteAfter = 0; }
        this._templateMerges = [];
        this._snippets = [];
        this._editor = editor;
        this._template = template;
        this._overwriteBefore = overwriteBefore;
        this._overwriteAfter = overwriteAfter;
    }
    SnippetSession.adjustWhitespace = function (model, position, template) {
        var line = model.getLineContent(position.lineNumber);
        var lineLeadingWhitespace = getLeadingWhitespace(line, 0, position.column - 1);
        var templateLines = template.split(/\r\n|\r|\n/);
        for (var i = 1; i < templateLines.length; i++) {
            var templateLeadingWhitespace = getLeadingWhitespace(templateLines[i]);
            templateLines[i] = model.normalizeIndentation(lineLeadingWhitespace + templateLeadingWhitespace) + templateLines[i].substr(templateLeadingWhitespace.length);
        }
        return templateLines.join(model.getEOL());
    };
    SnippetSession.adjustSelection = function (model, selection, overwriteBefore, overwriteAfter) {
        if (overwriteBefore !== 0 || overwriteAfter !== 0) {
            // overwrite[Before|After] is compute using the position, not the whole
            // selection. therefore we adjust the selection around that position
            var positionLineNumber = selection.positionLineNumber, positionColumn = selection.positionColumn;
            var positionColumnBefore = positionColumn - overwriteBefore;
            var positionColumnAfter = positionColumn + overwriteAfter;
            var range$$1 = model.validateRange({
                startLineNumber: positionLineNumber,
                startColumn: positionColumnBefore,
                endLineNumber: positionLineNumber,
                endColumn: positionColumnAfter
            });
            selection = Selection.createWithDirection(range$$1.startLineNumber, range$$1.startColumn, range$$1.endLineNumber, range$$1.endColumn, selection.getDirection());
        }
        return selection;
    };
    SnippetSession.createEditsAndSnippets = function (editor, template, overwriteBefore, overwriteAfter, enforceFinalTabstop) {
        var model = editor.getModel();
        var edits = [];
        var snippets = [];
        var modelBasedVariableResolver = new ModelBasedVariableResolver(model);
        var clipboardService = editor.invokeWithinContext(function (accessor) { return accessor.get(IClipboardService, optional); });
        var delta = 0;
        // know what text the overwrite[Before|After] extensions
        // of the primary curser have selected because only when
        // secondary selections extend to the same text we can grow them
        var firstBeforeText = model.getValueInRange(SnippetSession.adjustSelection(model, editor.getSelection(), overwriteBefore, 0));
        var firstAfterText = model.getValueInRange(SnippetSession.adjustSelection(model, editor.getSelection(), 0, overwriteAfter));
        // sort selections by their start position but remeber
        // the original index. that allows you to create correct
        // offset-based selection logic without changing the
        // primary selection
        var indexedSelections = editor.getSelections()
            .map(function (selection, idx) { return ({ selection: selection, idx: idx }); })
            .sort(function (a, b) { return Range.compareRangesUsingStarts(a.selection, b.selection); });
        for (var _i = 0, indexedSelections_1 = indexedSelections; _i < indexedSelections_1.length; _i++) {
            var _a = indexedSelections_1[_i], selection = _a.selection, idx = _a.idx;
            // extend selection with the `overwriteBefore` and `overwriteAfter` and then
            // compare if this matches the extensions of the primary selection
            var extensionBefore = SnippetSession.adjustSelection(model, selection, overwriteBefore, 0);
            var extensionAfter = SnippetSession.adjustSelection(model, selection, 0, overwriteAfter);
            if (firstBeforeText !== model.getValueInRange(extensionBefore)) {
                extensionBefore = selection;
            }
            if (firstAfterText !== model.getValueInRange(extensionAfter)) {
                extensionAfter = selection;
            }
            // merge the before and after selection into one
            var snippetSelection = selection
                .setStartPosition(extensionBefore.startLineNumber, extensionBefore.startColumn)
                .setEndPosition(extensionAfter.endLineNumber, extensionAfter.endColumn);
            // adjust the template string to match the indentation and
            // whitespace rules of this insert location (can be different for each cursor)
            var start = snippetSelection.getStartPosition();
            var adjustedTemplate = SnippetSession.adjustWhitespace(model, start, template);
            var snippet = new SnippetParser()
                .parse(adjustedTemplate, true, enforceFinalTabstop)
                .resolveVariables(new CompositeSnippetVariableResolver([
                modelBasedVariableResolver,
                new ClipboardBasedVariableResolver(clipboardService, idx, indexedSelections.length),
                new SelectionBasedVariableResolver(model, selection),
                new TimeBasedVariableResolver
            ]));
            var offset = model.getOffsetAt(start) + delta;
            delta += snippet.toString().length - model.getValueLengthInRange(snippetSelection);
            // store snippets with the index of their originating selection.
            // that ensures the primiary cursor stays primary despite not being
            // the one with lowest start position
            edits[idx] = EditOperation.replace(snippetSelection, snippet.toString());
            snippets[idx] = new OneSnippet(editor, snippet, offset);
        }
        return { edits: edits, snippets: snippets };
    };
    SnippetSession.prototype.dispose = function () {
        dispose(this._snippets);
    };
    SnippetSession.prototype._logInfo = function () {
        return "template=\"" + this._template + "\", merged_templates=\"" + this._templateMerges.join(' -> ') + "\"";
    };
    SnippetSession.prototype.insert = function () {
        var _this = this;
        var model = this._editor.getModel();
        // make insert edit and start with first selections
        var _a = SnippetSession.createEditsAndSnippets(this._editor, this._template, this._overwriteBefore, this._overwriteAfter, false), edits = _a.edits, snippets = _a.snippets;
        this._snippets = snippets;
        var selections = model.pushEditOperations(this._editor.getSelections(), edits, function (undoEdits) {
            if (_this._snippets[0].hasPlaceholder) {
                return _this._move(true);
            }
            else {
                return undoEdits.map(function (edit) { return Selection.fromPositions(edit.range.getEndPosition()); });
            }
        });
        this._editor.setSelections(selections);
        this._editor.revealRange(selections[0]);
    };
    SnippetSession.prototype.merge = function (template, overwriteBefore, overwriteAfter) {
        var _this = this;
        if (overwriteBefore === void 0) { overwriteBefore = 0; }
        if (overwriteAfter === void 0) { overwriteAfter = 0; }
        this._templateMerges.push([this._snippets[0]._nestingLevel, this._snippets[0]._placeholderGroupsIdx, template]);
        var _a = SnippetSession.createEditsAndSnippets(this._editor, template, overwriteBefore, overwriteAfter, true), edits = _a.edits, snippets = _a.snippets;
        this._editor.setSelections(this._editor.getModel().pushEditOperations(this._editor.getSelections(), edits, function (undoEdits) {
            for (var _i = 0, _a = _this._snippets; _i < _a.length; _i++) {
                var snippet = _a[_i];
                snippet.merge(snippets);
            }
            console.assert(snippets.length === 0);
            if (_this._snippets[0].hasPlaceholder) {
                return _this._move(undefined);
            }
            else {
                return undoEdits.map(function (edit) { return Selection.fromPositions(edit.range.getEndPosition()); });
            }
        }));
    };
    SnippetSession.prototype.next = function () {
        var newSelections = this._move(true);
        this._editor.setSelections(newSelections);
        this._editor.revealPositionInCenterIfOutsideViewport(newSelections[0].getPosition());
    };
    SnippetSession.prototype.prev = function () {
        var newSelections = this._move(false);
        this._editor.setSelections(newSelections);
        this._editor.revealPositionInCenterIfOutsideViewport(newSelections[0].getPosition());
    };
    SnippetSession.prototype._move = function (fwd) {
        var selections = [];
        for (var _i = 0, _a = this._snippets; _i < _a.length; _i++) {
            var snippet = _a[_i];
            var oneSelection = snippet.move(fwd);
            selections.push.apply(selections, oneSelection);
        }
        return selections;
    };
    Object.defineProperty(SnippetSession.prototype, "isAtFirstPlaceholder", {
        get: function () {
            return this._snippets[0].isAtFirstPlaceholder;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SnippetSession.prototype, "isAtLastPlaceholder", {
        get: function () {
            return this._snippets[0].isAtLastPlaceholder;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SnippetSession.prototype, "hasPlaceholder", {
        get: function () {
            return this._snippets[0].hasPlaceholder;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SnippetSession.prototype, "choice", {
        get: function () {
            return this._snippets[0].choice;
        },
        enumerable: true,
        configurable: true
    });
    SnippetSession.prototype.isSelectionWithinPlaceholders = function () {
        if (!this.hasPlaceholder) {
            return false;
        }
        var selections = this._editor.getSelections();
        if (selections.length < this._snippets.length) {
            // this means we started snippet mode with N
            // selections and have M (N > M) selections.
            // So one snippet is without selection -> cancel
            return false;
        }
        var allPossibleSelections;
        var _loop_1 = function (snippet) {
            var possibleSelections = snippet.computePossibleSelections();
            // for the first snippet find the placeholder (and its ranges)
            // that contain at least one selection. for all remaining snippets
            // the same placeholder (and their ranges) must be used.
            if (!allPossibleSelections) {
                allPossibleSelections = new Map();
                possibleSelections.forEach(function (ranges, index) {
                    ranges.sort(Range.compareRangesUsingStarts);
                    for (var _i = 0, selections_1 = selections; _i < selections_1.length; _i++) {
                        var selection = selections_1[_i];
                        if (ranges[0].containsRange(selection)) {
                            allPossibleSelections.set(index, []);
                            break;
                        }
                    }
                });
            }
            if (allPossibleSelections.size === 0) {
                return { value: false };
            }
            // add selections from 'this' snippet so that we know all
            // selections for this placeholder
            allPossibleSelections.forEach(function (array, index) {
                array.push.apply(array, possibleSelections.get(index));
            });
        };
        for (var _i = 0, _a = this._snippets; _i < _a.length; _i++) {
            var snippet = _a[_i];
            var state_1 = _loop_1(snippet);
            if (typeof state_1 === "object")
                return state_1.value;
        }
        // sort selections (and later placeholder-ranges). then walk both
        // arrays and make sure the placeholder-ranges contain the corresponding
        // selection
        selections.sort(Range.compareRangesUsingStarts);
        allPossibleSelections.forEach(function (ranges, index) {
            if (ranges.length !== selections.length) {
                allPossibleSelections.delete(index);
                return;
            }
            ranges.sort(Range.compareRangesUsingStarts);
            for (var i = 0; i < ranges.length; i++) {
                if (!ranges[i].containsRange(selections[i])) {
                    allPossibleSelections.delete(index);
                    return;
                }
            }
        });
        // from all possible selections we have deleted those
        // that don't match with the current selection. if we don't
        // have any left, we don't have a selection anymore
        return allPossibleSelections.size > 0;
    };
    SnippetSession.prototype.getEnclosingRange = function () {
        var result;
        for (var _i = 0, _a = this._snippets; _i < _a.length; _i++) {
            var snippet = _a[_i];
            var snippetRange = snippet.getEnclosingRange();
            if (!result) {
                result = snippetRange;
            }
            else {
                result = result.plusRange(snippetRange);
            }
        }
        return result;
    };
    return SnippetSession;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var Context$1 = {
    Visible: new RawContextKey('suggestWidgetVisible', false),
    MultipleSuggestions: new RawContextKey('suggestWidgetMultipleSuggestions', false),
    MakesTextEdit: new RawContextKey('suggestionMakesTextEdit', true),
    AcceptOnKey: new RawContextKey('suggestionSupportsAcceptOnKey', true),
    AcceptSuggestionsOnEnter: new RawContextKey('acceptSuggestionOnEnter', true)
};
var _snippetSuggestSupport;
function provideSuggestionItems(model, position, snippetConfig, onlyFrom, context) {
    if (snippetConfig === void 0) { snippetConfig = 'bottom'; }
    var allSuggestions = [];
    var acceptSuggestion = createSuggesionFilter(snippetConfig);
    position = position.clone();
    // get provider groups, always add snippet suggestion provider
    var supports = SuggestRegistry.orderedGroups(model);
    // add snippets provider unless turned off
    if (snippetConfig !== 'none' && _snippetSuggestSupport) {
        supports.unshift([_snippetSuggestSupport]);
    }
    var suggestConext = context || { triggerKind: SuggestTriggerKind.Invoke };
    // add suggestions from contributed providers - providers are ordered in groups of
    // equal score and once a group produces a result the process stops
    var hasResult = false;
    var factory = supports.map(function (supports) {
        return function () {
            // stop when we have a result
            if (hasResult) {
                return undefined;
            }
            // for each support in the group ask for suggestions
            return TPromise.join(supports.map(function (support) {
                if (!isFalsyOrEmpty(onlyFrom) && onlyFrom.indexOf(support) < 0) {
                    return undefined;
                }
                return asWinJsPromise(function (token) { return support.provideCompletionItems(model, position, suggestConext, token); }).then(function (container) {
                    var len = allSuggestions.length;
                    if (container && !isFalsyOrEmpty(container.suggestions)) {
                        for (var _i = 0, _a = container.suggestions; _i < _a.length; _i++) {
                            var suggestion = _a[_i];
                            if (acceptSuggestion(suggestion)) {
                                fixOverwriteBeforeAfter(suggestion, container);
                                allSuggestions.push({
                                    position: position,
                                    container: container,
                                    suggestion: suggestion,
                                    support: support,
                                    resolve: createSuggestionResolver(support, suggestion, model, position)
                                });
                            }
                        }
                    }
                    if (len !== allSuggestions.length && support !== _snippetSuggestSupport) {
                        hasResult = true;
                    }
                }, onUnexpectedExternalError);
            }));
        };
    });
    var result = sequence(factory).then(function () { return allSuggestions.sort(getSuggestionComparator(snippetConfig)); });
    // result.then(items => {
    // 	console.log(model.getWordUntilPosition(position), items.map(item => `${item.suggestion.label}, type=${item.suggestion.type}, incomplete?${item.container.incomplete}, overwriteBefore=${item.suggestion.overwriteBefore}`));
    // 	return items;
    // }, err => {
    // 	console.warn(model.getWordUntilPosition(position), err);
    // });
    return result;
}
function fixOverwriteBeforeAfter(suggestion, container) {
    if (typeof suggestion.overwriteBefore !== 'number') {
        suggestion.overwriteBefore = 0;
    }
    if (typeof suggestion.overwriteAfter !== 'number' || suggestion.overwriteAfter < 0) {
        suggestion.overwriteAfter = 0;
    }
}
function createSuggestionResolver(provider, suggestion, model, position) {
    return function () {
        if (typeof provider.resolveCompletionItem === 'function') {
            return asWinJsPromise(function (token) { return provider.resolveCompletionItem(model, position, suggestion, token); })
                .then(function (value) { assign(suggestion, value); });
        }
        return TPromise.as(void 0);
    };
}
function createSuggesionFilter(snippetConfig) {
    if (snippetConfig === 'none') {
        return function (suggestion) { return suggestion.type !== 'snippet'; };
    }
    else {
        return function () { return true; };
    }
}
function defaultComparator(a, b) {
    var ret = 0;
    // check with 'sortText'
    if (typeof a.suggestion.sortText === 'string' && typeof b.suggestion.sortText === 'string') {
        ret = compareIgnoreCase(a.suggestion.sortText, b.suggestion.sortText);
    }
    // check with 'label'
    if (ret === 0) {
        ret = compareIgnoreCase(a.suggestion.label, b.suggestion.label);
    }
    // check with 'type' and lower snippets
    if (ret === 0 && a.suggestion.type !== b.suggestion.type) {
        if (a.suggestion.type === 'snippet') {
            ret = 1;
        }
        else if (b.suggestion.type === 'snippet') {
            ret = -1;
        }
    }
    return ret;
}
function snippetUpComparator(a, b) {
    if (a.suggestion.type !== b.suggestion.type) {
        if (a.suggestion.type === 'snippet') {
            return -1;
        }
        else if (b.suggestion.type === 'snippet') {
            return 1;
        }
    }
    return defaultComparator(a, b);
}
function snippetDownComparator(a, b) {
    if (a.suggestion.type !== b.suggestion.type) {
        if (a.suggestion.type === 'snippet') {
            return 1;
        }
        else if (b.suggestion.type === 'snippet') {
            return -1;
        }
    }
    return defaultComparator(a, b);
}
function getSuggestionComparator(snippetConfig) {
    if (snippetConfig === 'top') {
        return snippetUpComparator;
    }
    else if (snippetConfig === 'bottom') {
        return snippetDownComparator;
    }
    else {
        return defaultComparator;
    }
}
registerDefaultLanguageCommand('_executeCompletionItemProvider', function (model, position, args) {
    var result = {
        incomplete: false,
        suggestions: []
    };
    var resolving = [];
    var maxItemsToResolve = args['maxItemsToResolve'] || 0;
    return provideSuggestionItems(model, position).then(function (items) {
        for (var _i = 0, items_1 = items; _i < items_1.length; _i++) {
            var item = items_1[_i];
            if (resolving.length < maxItemsToResolve) {
                resolving.push(item.resolve());
            }
            result.incomplete = result.incomplete || item.container.incomplete;
            result.suggestions.push(item.suggestion);
        }
    }).then(function () {
        return TPromise.join(resolving);
    }).then(function () {
        return result;
    });
});
var _suggestions;
var _provider = new /** @class */ (function () {
    function class_1() {
    }
    class_1.prototype.provideCompletionItems = function () {
        return _suggestions && { suggestions: _suggestions };
    };
    return class_1;
}());
SuggestRegistry.register('*', _provider);
function showSimpleSuggestions(editor, suggestions) {
    setTimeout(function () {
        _suggestions = suggestions;
        editor.getContribution('editor.contrib.suggestController').triggerSuggest([_provider]);
        _suggestions = undefined;
    }, 0);
}

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __decorate$n = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$n = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var SnippetController2 = /** @class */ (function () {
    function SnippetController2(_editor, _logService, contextKeyService) {
        this._editor = _editor;
        this._logService = _logService;
        this._snippetListener = [];
        this._inSnippet = SnippetController2.InSnippetMode.bindTo(contextKeyService);
        this._hasNextTabstop = SnippetController2.HasNextTabstop.bindTo(contextKeyService);
        this._hasPrevTabstop = SnippetController2.HasPrevTabstop.bindTo(contextKeyService);
    }
    SnippetController2.get = function (editor) {
        return editor.getContribution('snippetController2');
    };
    SnippetController2.prototype.dispose = function () {
        this._inSnippet.reset();
        this._hasPrevTabstop.reset();
        this._hasNextTabstop.reset();
        dispose(this._session);
    };
    SnippetController2.prototype.getId = function () {
        return 'snippetController2';
    };
    SnippetController2.prototype.insert = function (template, overwriteBefore, overwriteAfter, undoStopBefore, undoStopAfter) {
        if (overwriteBefore === void 0) { overwriteBefore = 0; }
        if (overwriteAfter === void 0) { overwriteAfter = 0; }
        if (undoStopBefore === void 0) { undoStopBefore = true; }
        if (undoStopAfter === void 0) { undoStopAfter = true; }
        // this is here to find out more about the yet-not-understood
        // error that sometimes happens when we fail to inserted a nested
        // snippet
        try {
            this._doInsert(template, overwriteBefore, overwriteAfter, undoStopBefore, undoStopAfter);
        }
        catch (e) {
            this.cancel();
            this._logService.error(e);
            this._logService.error('snippet_error');
            this._logService.error('insert_template=', template);
            this._logService.error('existing_template=', this._session ? this._session._logInfo() : '<no_session>');
        }
    };
    SnippetController2.prototype._doInsert = function (template, overwriteBefore, overwriteAfter, undoStopBefore, undoStopAfter) {
        var _this = this;
        if (overwriteBefore === void 0) { overwriteBefore = 0; }
        if (overwriteAfter === void 0) { overwriteAfter = 0; }
        if (undoStopBefore === void 0) { undoStopBefore = true; }
        if (undoStopAfter === void 0) { undoStopAfter = true; }
        // don't listen while inserting the snippet
        // as that is the inflight state causing cancelation
        this._snippetListener = dispose(this._snippetListener);
        if (undoStopBefore) {
            this._editor.getModel().pushStackElement();
        }
        if (!this._session) {
            this._modelVersionId = this._editor.getModel().getAlternativeVersionId();
            this._session = new SnippetSession(this._editor, template, overwriteBefore, overwriteAfter);
            this._session.insert();
        }
        else {
            this._session.merge(template, overwriteBefore, overwriteAfter);
        }
        if (undoStopAfter) {
            this._editor.getModel().pushStackElement();
        }
        this._updateState();
        this._snippetListener = [
            this._editor.onDidChangeModelContent(function (e) { return e.isFlush && _this.cancel(); }),
            this._editor.onDidChangeModel(function () { return _this.cancel(); }),
            this._editor.onDidChangeCursorSelection(function () { return _this._updateState(); })
        ];
    };
    SnippetController2.prototype._updateState = function () {
        if (!this._session) {
            // canceled in the meanwhile
            return;
        }
        if (this._modelVersionId === this._editor.getModel().getAlternativeVersionId()) {
            // undo until the 'before' state happened
            // and makes use cancel snippet mode
            return this.cancel();
        }
        if (!this._session.hasPlaceholder) {
            // don't listen for selection changes and don't
            // update context keys when the snippet is plain text
            return this.cancel();
        }
        if (this._session.isAtLastPlaceholder || !this._session.isSelectionWithinPlaceholders()) {
            return this.cancel();
        }
        this._inSnippet.set(true);
        this._hasPrevTabstop.set(!this._session.isAtFirstPlaceholder);
        this._hasNextTabstop.set(!this._session.isAtLastPlaceholder);
        this._handleChoice();
    };
    SnippetController2.prototype._handleChoice = function () {
        var choice = this._session.choice;
        if (!choice) {
            this._currentChoice = undefined;
            return;
        }
        if (this._currentChoice !== choice) {
            this._currentChoice = choice;
            this._editor.setSelections(this._editor.getSelections()
                .map(function (s) { return Selection.fromPositions(s.getStartPosition()); }));
            var first_1 = choice.options[0];
            showSimpleSuggestions(this._editor, choice.options.map(function (option, i) {
                // let before = choice.options.slice(0, i);
                // let after = choice.options.slice(i);
                return {
                    type: 'value',
                    label: option.value,
                    insertText: option.value,
                    // insertText: `\${1|${after.concat(before).join(',')}|}$0`,
                    // snippetType: 'textmate',
                    sortText: repeat('a', i),
                    overwriteAfter: first_1.value.length
                };
            }));
        }
    };
    SnippetController2.prototype.finish = function () {
        while (this._inSnippet.get()) {
            this.next();
        }
    };
    SnippetController2.prototype.cancel = function () {
        this._inSnippet.reset();
        this._hasPrevTabstop.reset();
        this._hasNextTabstop.reset();
        dispose(this._snippetListener);
        dispose(this._session);
        this._session = undefined;
        this._modelVersionId = -1;
    };
    SnippetController2.prototype.prev = function () {
        this._session.prev();
        this._updateState();
    };
    SnippetController2.prototype.next = function () {
        this._session.next();
        this._updateState();
    };
    SnippetController2.prototype.getSessionEnclosingRange = function () {
        if (this._session) {
            return this._session.getEnclosingRange();
        }
        return undefined;
    };
    SnippetController2.InSnippetMode = new RawContextKey('inSnippetMode', false);
    SnippetController2.HasNextTabstop = new RawContextKey('hasNextTabstop', false);
    SnippetController2.HasPrevTabstop = new RawContextKey('hasPrevTabstop', false);
    SnippetController2 = __decorate$n([
        __param$n(1, ILogService),
        __param$n(2, IContextKeyService)
    ], SnippetController2);
    return SnippetController2;
}());
registerEditorContribution(SnippetController2);
var CommandCtor = EditorCommand.bindToContribution(SnippetController2.get);
registerEditorCommand(new CommandCtor({
    id: 'jumpToNextSnippetPlaceholder',
    precondition: ContextKeyExpr.and(SnippetController2.InSnippetMode, SnippetController2.HasNextTabstop),
    handler: function (ctrl) { return ctrl.next(); },
    kbOpts: {
        weight: KeybindingsRegistry.WEIGHT.editorContrib(30),
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 2 /* Tab */
    }
}));
registerEditorCommand(new CommandCtor({
    id: 'jumpToPrevSnippetPlaceholder',
    precondition: ContextKeyExpr.and(SnippetController2.InSnippetMode, SnippetController2.HasPrevTabstop),
    handler: function (ctrl) { return ctrl.prev(); },
    kbOpts: {
        weight: KeybindingsRegistry.WEIGHT.editorContrib(30),
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 1024 /* Shift */ | 2 /* Tab */
    }
}));
registerEditorCommand(new CommandCtor({
    id: 'leaveSnippet',
    precondition: SnippetController2.InSnippetMode,
    handler: function (ctrl) { return ctrl.cancel(); },
    kbOpts: {
        weight: KeybindingsRegistry.WEIGHT.editorContrib(30),
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 9 /* Escape */,
        secondary: [1024 /* Shift */ | 9 /* Escape */]
    }
}));
registerEditorCommand(new CommandCtor({
    id: 'acceptSnippet',
    precondition: SnippetController2.InSnippetMode,
    handler: function (ctrl) { return ctrl.finish(); },
}));

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// Combined filters
/**
 * @returns A filter which combines the provided set
 * of filters with an or. The *first* filters that
 * matches defined the return value of the returned
 * filter.
 */
function or() {
    var filter = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        filter[_i] = arguments[_i];
    }
    return function (word, wordToMatchAgainst) {
        for (var i = 0, len = filter.length; i < len; i++) {
            var match = filter[i](word, wordToMatchAgainst);
            if (match) {
                return match;
            }
        }
        return null;
    };
}
// Prefix
var matchesStrictPrefix = _matchesPrefix.bind(undefined, false);
var matchesPrefix = _matchesPrefix.bind(undefined, true);
function _matchesPrefix(ignoreCase, word, wordToMatchAgainst) {
    if (!wordToMatchAgainst || wordToMatchAgainst.length < word.length) {
        return null;
    }
    var matches;
    if (ignoreCase) {
        matches = startsWithIgnoreCase(wordToMatchAgainst, word);
    }
    else {
        matches = wordToMatchAgainst.indexOf(word) === 0;
    }
    if (!matches) {
        return null;
    }
    return word.length > 0 ? [{ start: 0, end: word.length }] : [];
}
// Contiguous Substring
function matchesContiguousSubString(word, wordToMatchAgainst) {
    var index = wordToMatchAgainst.toLowerCase().indexOf(word.toLowerCase());
    if (index === -1) {
        return null;
    }
    return [{ start: index, end: index + word.length }];
}
// Substring
function matchesSubString(word, wordToMatchAgainst) {
    return _matchesSubString(word.toLowerCase(), wordToMatchAgainst.toLowerCase(), 0, 0);
}
function _matchesSubString(word, wordToMatchAgainst, i, j) {
    if (i === word.length) {
        return [];
    }
    else if (j === wordToMatchAgainst.length) {
        return null;
    }
    else {
        if (word[i] === wordToMatchAgainst[j]) {
            var result = null;
            if (result = _matchesSubString(word, wordToMatchAgainst, i + 1, j + 1)) {
                return join$1({ start: j, end: j + 1 }, result);
            }
            return null;
        }
        return _matchesSubString(word, wordToMatchAgainst, i, j + 1);
    }
}
// CamelCase
function isLower(code) {
    return 97 /* a */ <= code && code <= 122 /* z */;
}
function isUpper(code) {
    return 65 /* A */ <= code && code <= 90 /* Z */;
}
function isNumber$1(code) {
    return 48 /* Digit0 */ <= code && code <= 57 /* Digit9 */;
}
function isWhitespace(code) {
    return (code === 32 /* Space */
        || code === 9 /* Tab */
        || code === 10 /* LineFeed */
        || code === 13 /* CarriageReturn */);
}
function isAlphanumeric(code) {
    return isLower(code) || isUpper(code) || isNumber$1(code);
}
function join$1(head, tail$$1) {
    if (tail$$1.length === 0) {
        tail$$1 = [head];
    }
    else if (head.end === tail$$1[0].start) {
        tail$$1[0].start = head.start;
    }
    else {
        tail$$1.unshift(head);
    }
    return tail$$1;
}
function nextAnchor(camelCaseWord, start) {
    for (var i = start; i < camelCaseWord.length; i++) {
        var c = camelCaseWord.charCodeAt(i);
        if (isUpper(c) || isNumber$1(c) || (i > 0 && !isAlphanumeric(camelCaseWord.charCodeAt(i - 1)))) {
            return i;
        }
    }
    return camelCaseWord.length;
}
function _matchesCamelCase(word, camelCaseWord, i, j) {
    if (i === word.length) {
        return [];
    }
    else if (j === camelCaseWord.length) {
        return null;
    }
    else if (word[i] !== camelCaseWord[j].toLowerCase()) {
        return null;
    }
    else {
        var result = null;
        var nextUpperIndex = j + 1;
        result = _matchesCamelCase(word, camelCaseWord, i + 1, j + 1);
        while (!result && (nextUpperIndex = nextAnchor(camelCaseWord, nextUpperIndex)) < camelCaseWord.length) {
            result = _matchesCamelCase(word, camelCaseWord, i + 1, nextUpperIndex);
            nextUpperIndex++;
        }
        return result === null ? null : join$1({ start: j, end: j + 1 }, result);
    }
}
// Heuristic to avoid computing camel case matcher for words that don't
// look like camelCaseWords.
function analyzeCamelCaseWord(word) {
    var upper = 0, lower = 0, alpha = 0, numeric = 0, code = 0;
    for (var i = 0; i < word.length; i++) {
        code = word.charCodeAt(i);
        if (isUpper(code)) {
            upper++;
        }
        if (isLower(code)) {
            lower++;
        }
        if (isAlphanumeric(code)) {
            alpha++;
        }
        if (isNumber$1(code)) {
            numeric++;
        }
    }
    var upperPercent = upper / word.length;
    var lowerPercent = lower / word.length;
    var alphaPercent = alpha / word.length;
    var numericPercent = numeric / word.length;
    return { upperPercent: upperPercent, lowerPercent: lowerPercent, alphaPercent: alphaPercent, numericPercent: numericPercent };
}
function isUpperCaseWord(analysis) {
    var upperPercent = analysis.upperPercent, lowerPercent = analysis.lowerPercent;
    return lowerPercent === 0 && upperPercent > 0.6;
}
function isCamelCaseWord(analysis) {
    var upperPercent = analysis.upperPercent, lowerPercent = analysis.lowerPercent, alphaPercent = analysis.alphaPercent, numericPercent = analysis.numericPercent;
    return lowerPercent > 0.2 && upperPercent < 0.8 && alphaPercent > 0.6 && numericPercent < 0.2;
}
// Heuristic to avoid computing camel case matcher for words that don't
// look like camel case patterns.
function isCamelCasePattern(word) {
    var upper = 0, lower = 0, code = 0, whitespace = 0;
    for (var i = 0; i < word.length; i++) {
        code = word.charCodeAt(i);
        if (isUpper(code)) {
            upper++;
        }
        if (isLower(code)) {
            lower++;
        }
        if (isWhitespace(code)) {
            whitespace++;
        }
    }
    if ((upper === 0 || lower === 0) && whitespace === 0) {
        return word.length <= 30;
    }
    else {
        return upper <= 5;
    }
}
function matchesCamelCase(word, camelCaseWord) {
    if (!camelCaseWord) {
        return null;
    }
    camelCaseWord = camelCaseWord.trim();
    if (camelCaseWord.length === 0) {
        return null;
    }
    if (!isCamelCasePattern(word)) {
        return null;
    }
    if (camelCaseWord.length > 60) {
        return null;
    }
    var analysis = analyzeCamelCaseWord(camelCaseWord);
    if (!isCamelCaseWord(analysis)) {
        if (!isUpperCaseWord(analysis)) {
            return null;
        }
        camelCaseWord = camelCaseWord.toLowerCase();
    }
    var result = null;
    var i = 0;
    while (i < camelCaseWord.length && (result = _matchesCamelCase(word.toLowerCase(), camelCaseWord, 0, i)) === null) {
        i = nextAnchor(camelCaseWord, i + 1);
    }
    return result;
}
// Fuzzy
var fuzzyContiguousFilter = or(matchesPrefix, matchesCamelCase, matchesContiguousSubString);
var fuzzySeparateFilter = or(matchesPrefix, matchesCamelCase, matchesSubString);
var fuzzyRegExpCache = new LRUCache(10000); // bounded to 10000 elements
function matchesFuzzy(word, wordToMatchAgainst, enableSeparateSubstringMatching) {
    if (enableSeparateSubstringMatching === void 0) { enableSeparateSubstringMatching = false; }
    if (typeof word !== 'string' || typeof wordToMatchAgainst !== 'string') {
        return null; // return early for invalid input
    }
    // Form RegExp for wildcard matches
    var regexp = fuzzyRegExpCache.get(word);
    if (!regexp) {
        regexp = new RegExp(convertSimple2RegExpPattern(word), 'i');
        fuzzyRegExpCache.set(word, regexp);
    }
    // RegExp Filter
    var match = regexp.exec(wordToMatchAgainst);
    if (match) {
        return [{ start: match.index, end: match.index + match[0].length }];
    }
    // Default Filter
    return enableSeparateSubstringMatching ? fuzzySeparateFilter(word, wordToMatchAgainst) : fuzzyContiguousFilter(word, wordToMatchAgainst);
}
function skipScore(pattern, word, patternMaxWhitespaceIgnore) {
    pattern = pattern.toLowerCase();
    word = word.toLowerCase();
    var matches = [];
    var idx = 0;
    for (var pos = 0; pos < pattern.length; ++pos) {
        var thisIdx = word.indexOf(pattern.charAt(pos), idx);
        if (thisIdx >= 0) {
            matches.push(thisIdx);
            idx = thisIdx + 1;
        }
    }
    return [matches.length, matches];
}
//#region --- fuzzyScore ---
function createMatches(position) {
    var ret = [];
    if (!position) {
        return ret;
    }
    var last;
    for (var _i = 0, position_1 = position; _i < position_1.length; _i++) {
        var pos = position_1[_i];
        if (last && last.end === pos) {
            last.end += 1;
        }
        else {
            last = { start: pos, end: pos + 1 };
            ret.push(last);
        }
    }
    return ret;
}
function initTable() {
    var table = [];
    var row = [0];
    for (var i = 1; i <= 100; i++) {
        row.push(-i);
    }
    for (var i = 0; i <= 100; i++) {
        var thisRow = row.slice(0);
        thisRow[0] = -i;
        table.push(thisRow);
    }
    return table;
}
var _table = initTable();
var _scores = initTable();
var _arrows = initTable();
function isSeparatorAtPos(value, index) {
    if (index < 0 || index >= value.length) {
        return false;
    }
    var code = value.charCodeAt(index);
    switch (code) {
        case 95 /* Underline */:
        case 45 /* Dash */:
        case 46 /* Period */:
        case 32 /* Space */:
        case 47 /* Slash */:
        case 92 /* Backslash */:
        case 39 /* SingleQuote */:
        case 34 /* DoubleQuote */:
        case 58 /* Colon */:
            return true;
        default:
            return false;
    }
}
function isWhitespaceAtPos(value, index) {
    if (index < 0 || index >= value.length) {
        return false;
    }
    var code = value.charCodeAt(index);
    switch (code) {
        case 32 /* Space */:
        case 9 /* Tab */:
            return true;
        default:
            return false;
    }
}
function fuzzyScore(pattern, word, patternMaxWhitespaceIgnore) {
    var patternLen = pattern.length > 100 ? 100 : pattern.length;
    var wordLen = word.length > 100 ? 100 : word.length;
    // Check for leading whitespace in the pattern and
    // start matching just after that position. This is
    // like `pattern = pattern.rtrim()` but doesn't create
    // a new string
    var patternStartPos = 0;
    if (patternMaxWhitespaceIgnore === undefined) {
        patternMaxWhitespaceIgnore = patternLen;
    }
    while (patternStartPos < patternMaxWhitespaceIgnore) {
        if (isWhitespaceAtPos(pattern, patternStartPos)) {
            patternStartPos += 1;
        }
        else {
            break;
        }
    }
    if (patternStartPos === patternLen) {
        return [-100, []];
    }
    if (patternLen > wordLen) {
        return undefined;
    }
    var lowPattern = pattern.toLowerCase();
    var lowWord = word.toLowerCase();
    var patternPos = patternStartPos;
    var wordPos = 0;
    // Run a simple check if the characters of pattern occur
    // (in order) at all in word. If that isn't the case we
    // stop because no match will be possible
    while (patternPos < patternLen && wordPos < wordLen) {
        if (lowPattern[patternPos] === lowWord[wordPos]) {
            patternPos += 1;
        }
        wordPos += 1;
    }
    if (patternPos !== patternLen) {
        return undefined;
    }
    // There will be a mach, fill in tables
    for (patternPos = patternStartPos + 1; patternPos <= patternLen; patternPos++) {
        for (wordPos = 1; wordPos <= wordLen; wordPos++) {
            var score = -1;
            var lowWordChar = lowWord[wordPos - 1];
            if (lowPattern[patternPos - 1] === lowWordChar) {
                if (wordPos === (patternPos - patternStartPos)) {
                    // common prefix: `foobar <-> foobaz`
                    if (pattern[patternPos - 1] === word[wordPos - 1]) {
                        score = 7;
                    }
                    else {
                        score = 5;
                    }
                }
                else if (lowWordChar !== word[wordPos - 1]) {
                    // hitting upper-case: `foo <-> forOthers`
                    if (pattern[patternPos - 1] === word[wordPos - 1]) {
                        score = 7;
                    }
                    else {
                        score = 5;
                    }
                }
                else if (isSeparatorAtPos(lowWord, wordPos - 2) || isWhitespaceAtPos(lowWord, wordPos - 2)) {
                    // post separator: `foo <-> bar_foo`
                    score = 5;
                }
                else {
                    score = 1;
                }
            }
            _scores[patternPos][wordPos] = score;
            var diag = _table[patternPos - 1][wordPos - 1] + (score > 1 ? 1 : score);
            var top_1 = _table[patternPos - 1][wordPos] + -1;
            var left = _table[patternPos][wordPos - 1] + -1;
            if (left >= top_1) {
                // left or diag
                if (left > diag) {
                    _table[patternPos][wordPos] = left;
                    _arrows[patternPos][wordPos] = 4 /* Left */;
                }
                else if (left === diag) {
                    _table[patternPos][wordPos] = left;
                    _arrows[patternPos][wordPos] = 4 /* Left */ | 2 /* Diag */;
                }
                else {
                    _table[patternPos][wordPos] = diag;
                    _arrows[patternPos][wordPos] = 2 /* Diag */;
                }
            }
            else {
                // top or diag
                if (top_1 > diag) {
                    _table[patternPos][wordPos] = top_1;
                    _arrows[patternPos][wordPos] = 1 /* Top */;
                }
                else if (top_1 === diag) {
                    _table[patternPos][wordPos] = top_1;
                    _arrows[patternPos][wordPos] = 1 /* Top */ | 2 /* Diag */;
                }
                else {
                    _table[patternPos][wordPos] = diag;
                    _arrows[patternPos][wordPos] = 2 /* Diag */;
                }
            }
        }
    }
    // _bucket is an array of [PrefixArray] we use to keep
    // track of scores and matches. After calling `_findAllMatches`
    // the best match (if available) is the first item in the array
    _matchesCount = 0;
    _topScore = -100;
    _patternStartPos = patternStartPos;
    _findAllMatches(patternLen, wordLen, patternLen === wordLen ? 1 : 0, new LazyArray(), false);
    if (_matchesCount === 0) {
        return undefined;
    }
    return [_topScore, _topMatch.toArray()];
}
var _matchesCount = 0;
var _topMatch;
var _topScore = 0;
var _patternStartPos = 0;
function _findAllMatches(patternPos, wordPos, total, matches, lastMatched) {
    if (_matchesCount >= 10 || total < -25) {
        // stop when having already 10 results, or
        // when a potential alignment as already 5 gaps
        return;
    }
    var simpleMatchCount = 0;
    while (patternPos > _patternStartPos && wordPos > 0) {
        var score = _scores[patternPos][wordPos];
        var arrow = _arrows[patternPos][wordPos];
        if (arrow === 4 /* Left */) {
            // left
            wordPos -= 1;
            if (lastMatched) {
                total -= 5; // new gap penalty
            }
            else if (!matches.isEmpty()) {
                total -= 1; // gap penalty after first match
            }
            lastMatched = false;
            simpleMatchCount = 0;
        }
        else if (arrow & 2 /* Diag */) {
            if (arrow & 4 /* Left */) {
                // left
                _findAllMatches(patternPos, wordPos - 1, !matches.isEmpty() ? total - 1 : total, // gap penalty after first match
                matches.slice(), lastMatched);
            }
            // diag
            total += score;
            patternPos -= 1;
            wordPos -= 1;
            matches.unshift(wordPos);
            lastMatched = true;
            // count simple matches and boost a row of
            // simple matches when they yield in a
            // strong match.
            if (score === 1) {
                simpleMatchCount += 1;
                if (patternPos === _patternStartPos) {
                    // when the first match is a weak
                    // match we discard it
                    return undefined;
                }
            }
            else {
                // boost
                total += 1 + (simpleMatchCount * (score - 1));
                simpleMatchCount = 0;
            }
        }
        else {
            return undefined;
        }
    }
    total -= wordPos >= 3 ? 9 : wordPos * 3; // late start penalty
    // dynamically keep track of the current top score
    // and insert the current best score at head, the rest at tail
    _matchesCount += 1;
    if (total > _topScore) {
        _topScore = total;
        _topMatch = matches;
    }
}
var LazyArray = /** @class */ (function () {
    function LazyArray() {
    }
    LazyArray.prototype.isEmpty = function () {
        return !this._data && (!this._parent || this._parent.isEmpty());
    };
    LazyArray.prototype.unshift = function (n) {
        if (!this._data) {
            this._data = [n];
        }
        else {
            this._data.unshift(n);
        }
    };
    LazyArray.prototype.slice = function () {
        var ret = new LazyArray();
        ret._parent = this;
        ret._parentLen = this._data ? this._data.length : 0;
        return ret;
    };
    LazyArray.prototype.toArray = function () {
        if (!this._data) {
            return this._parent.toArray();
        }
        var bucket = [];
        var element = this;
        while (element) {
            if (element._parent && element._parent._data) {
                bucket.push(element._parent._data.slice(element._parent._data.length - element._parentLen));
            }
            element = element._parent;
        }
        return Array.prototype.concat.apply(this._data, bucket);
    };
    return LazyArray;
}());
//#endregion
//#region --- graceful ---
function fuzzyScoreGracefulAggressive(pattern, word, patternMaxWhitespaceIgnore) {
    return fuzzyScoreWithPermutations(pattern, word, true, patternMaxWhitespaceIgnore);
}
function fuzzyScoreWithPermutations(pattern, word, aggressive, patternMaxWhitespaceIgnore) {
    var top = fuzzyScore(pattern, word, patternMaxWhitespaceIgnore);
    if (top && !aggressive) {
        // when using the original pattern yield a result we`
        // return it unless we are aggressive and try to find
        // a better alignment, e.g. `cno` -> `^co^ns^ole` or `^c^o^nsole`.
        return top;
    }
    if (pattern.length >= 3) {
        // When the pattern is long enough then try a few (max 7)
        // permutations of the pattern to find a better match. The
        // permutations only swap neighbouring characters, e.g
        // `cnoso` becomes `conso`, `cnsoo`, `cnoos`.
        var tries = Math.min(7, pattern.length - 1);
        for (var patternPos = 1; patternPos < tries; patternPos++) {
            var newPattern = nextTypoPermutation(pattern, patternPos);
            if (newPattern) {
                var candidate = fuzzyScore(newPattern, word, patternMaxWhitespaceIgnore);
                if (candidate) {
                    candidate[0] -= 3; // permutation penalty
                    if (!top || candidate[0] > top[0]) {
                        top = candidate;
                    }
                }
            }
        }
    }
    return top;
}
function nextTypoPermutation(pattern, patternPos) {
    if (patternPos + 1 >= pattern.length) {
        return undefined;
    }
    var swap1 = pattern[patternPos];
    var swap2 = pattern[patternPos + 1];
    if (swap1 === swap2) {
        return undefined;
    }
    return pattern.slice(0, patternPos)
        + swap2
        + swap1
        + pattern.slice(patternPos + 2);
}

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var CompletionModel = /** @class */ (function () {
    function CompletionModel(items, column, lineContext, snippetConfig) {
        this._snippetCompareFn = CompletionModel._compareCompletionItems;
        this._items = items;
        this._column = column;
        this._refilterKind = 1 /* All */;
        this._lineContext = lineContext;
        if (snippetConfig === 'top') {
            this._snippetCompareFn = CompletionModel._compareCompletionItemsSnippetsUp;
        }
        else if (snippetConfig === 'bottom') {
            this._snippetCompareFn = CompletionModel._compareCompletionItemsSnippetsDown;
        }
    }
    CompletionModel.prototype.dispose = function () {
        var seen = new Set();
        for (var _i = 0, _a = this._items; _i < _a.length; _i++) {
            var container = _a[_i].container;
            if (!seen.has(container)) {
                seen.add(container);
                if (isDisposable(container)) {
                    container.dispose();
                }
            }
        }
    };
    Object.defineProperty(CompletionModel.prototype, "lineContext", {
        get: function () {
            return this._lineContext;
        },
        set: function (value) {
            if (this._lineContext.leadingLineContent !== value.leadingLineContent
                || this._lineContext.characterCountDelta !== value.characterCountDelta) {
                this._refilterKind = this._lineContext.characterCountDelta < value.characterCountDelta && this._filteredItems ? 2 /* Incr */ : 1 /* All */;
                this._lineContext = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CompletionModel.prototype, "items", {
        get: function () {
            this._ensureCachedState();
            return this._filteredItems;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CompletionModel.prototype, "incomplete", {
        get: function () {
            this._ensureCachedState();
            return this._isIncomplete;
        },
        enumerable: true,
        configurable: true
    });
    CompletionModel.prototype.resolveIncompleteInfo = function () {
        var incomplete = [];
        var complete = [];
        for (var _i = 0, _a = this._items; _i < _a.length; _i++) {
            var item = _a[_i];
            if (!item.container.incomplete) {
                complete.push(item);
            }
            else if (incomplete.indexOf(item.support) < 0) {
                incomplete.push(item.support);
            }
        }
        return { incomplete: incomplete, complete: complete };
    };
    Object.defineProperty(CompletionModel.prototype, "stats", {
        get: function () {
            this._ensureCachedState();
            return this._stats;
        },
        enumerable: true,
        configurable: true
    });
    CompletionModel.prototype._ensureCachedState = function () {
        if (this._refilterKind !== 0 /* Nothing */) {
            this._createCachedState();
        }
    };
    CompletionModel.prototype._createCachedState = function () {
        this._isIncomplete = false;
        this._stats = { suggestionCount: 0, snippetCount: 0, textCount: 0 };
        var _a = this._lineContext, leadingLineContent = _a.leadingLineContent, characterCountDelta = _a.characterCountDelta;
        var word = '';
        // incrementally filter less
        var source = this._refilterKind === 1 /* All */ ? this._items : this._filteredItems;
        var target = [];
        // picks a score function based on the number of
        // items that we have to score/filter
        var scoreFn = source.length > 2000 ? fuzzyScore : fuzzyScoreGracefulAggressive;
        for (var i = 0; i < source.length; i++) {
            var item = source[i];
            var suggestion = item.suggestion, container = item.container;
            // collect those supports that signaled having
            // an incomplete result
            this._isIncomplete = this._isIncomplete || container.incomplete;
            // 'word' is that remainder of the current line that we
            // filter and score against. In theory each suggestion uses a
            // different word, but in practice not - that's why we cache
            var wordLen = suggestion.overwriteBefore + characterCountDelta - (item.position.column - this._column);
            if (word.length !== wordLen) {
                word = wordLen === 0 ? '' : leadingLineContent.slice(-wordLen);
            }
            // remember the word against which this item was
            // scored
            item.word = word;
            if (wordLen === 0) {
                // when there is nothing to score against, don't
                // event try to do. Use a const rank and rely on
                // the fallback-sort using the initial sort order.
                // use a score of `-100` because that is out of the
                // bound of values `fuzzyScore` will return
                item.score = -100;
                item.matches = undefined;
            }
            else if (typeof suggestion.filterText === 'string') {
                // when there is a `filterText` it must match the `word`.
                // if it matches we check with the label to compute highlights
                // and if that doesn't yield a result we have no highlights,
                // despite having the match
                var match = scoreFn(word, suggestion.filterText, suggestion.overwriteBefore);
                if (!match) {
                    continue;
                }
                item.score = match[0];
                item.matches = skipScore(word, suggestion.label)[1];
            }
            else {
                // by default match `word` against the `label`
                var match = scoreFn(word, suggestion.label, suggestion.overwriteBefore);
                if (match) {
                    item.score = match[0];
                    item.matches = match[1];
                }
                else {
                    continue;
                }
            }
            item.idx = i;
            target.push(item);
            // update stats
            this._stats.suggestionCount++;
            switch (suggestion.type) {
                case 'snippet':
                    this._stats.snippetCount++;
                    break;
                case 'text':
                    this._stats.textCount++;
                    break;
            }
        }
        this._filteredItems = target.sort(this._snippetCompareFn);
        this._refilterKind = 0 /* Nothing */;
    };
    CompletionModel._compareCompletionItems = function (a, b) {
        if (a.score > b.score) {
            return -1;
        }
        else if (a.score < b.score) {
            return 1;
        }
        else if (a.idx < b.idx) {
            return -1;
        }
        else if (a.idx > b.idx) {
            return 1;
        }
        else {
            return 0;
        }
    };
    CompletionModel._compareCompletionItemsSnippetsDown = function (a, b) {
        if (a.suggestion.type !== b.suggestion.type) {
            if (a.suggestion.type === 'snippet') {
                return 1;
            }
            else if (b.suggestion.type === 'snippet') {
                return -1;
            }
        }
        return CompletionModel._compareCompletionItems(a, b);
    };
    CompletionModel._compareCompletionItemsSnippetsUp = function (a, b) {
        if (a.suggestion.type !== b.suggestion.type) {
            if (a.suggestion.type === 'snippet') {
                return -1;
            }
            else if (b.suggestion.type === 'snippet') {
                return 1;
            }
        }
        return CompletionModel._compareCompletionItems(a, b);
    };
    return CompletionModel;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var LineContext$1 = /** @class */ (function () {
    function LineContext$$1(model, position, auto) {
        this.leadingLineContent = model.getLineContent(position.lineNumber).substr(0, position.column - 1);
        this.leadingWord = model.getWordUntilPosition(position);
        this.lineNumber = position.lineNumber;
        this.column = position.column;
        this.auto = auto;
    }
    LineContext$$1.shouldAutoTrigger = function (editor) {
        var model = editor.getModel();
        if (!model) {
            return false;
        }
        var pos = editor.getPosition();
        model.tokenizeIfCheap(pos.lineNumber);
        var word = model.getWordAtPosition(pos);
        if (!word) {
            return false;
        }
        if (word.endColumn !== pos.column) {
            return false;
        }
        if (!isNaN(Number(word.word))) {
            return false;
        }
        return true;
    };
    return LineContext$$1;
}());
var SuggestModel = /** @class */ (function () {
    function SuggestModel(editor) {
        var _this = this;
        this._toDispose = [];
        this._triggerRefilter = new TimeoutTimer();
        this._onDidCancel = new Emitter();
        this._onDidTrigger = new Emitter();
        this._onDidSuggest = new Emitter();
        this.onDidCancel = this._onDidCancel.event;
        this.onDidTrigger = this._onDidTrigger.event;
        this.onDidSuggest = this._onDidSuggest.event;
        this._editor = editor;
        this._state = 0 /* Idle */;
        this._triggerAutoSuggestPromise = null;
        this._requestPromise = null;
        this._completionModel = null;
        this._context = null;
        this._currentSelection = this._editor.getSelection() || new Selection(1, 1, 1, 1);
        // wire up various listeners
        this._toDispose.push(this._editor.onDidChangeModel(function () {
            _this._updateTriggerCharacters();
            _this.cancel();
        }));
        this._toDispose.push(this._editor.onDidChangeModelLanguage(function () {
            _this._updateTriggerCharacters();
            _this.cancel();
        }));
        this._toDispose.push(this._editor.onDidChangeConfiguration(function () {
            _this._updateTriggerCharacters();
            _this._updateQuickSuggest();
        }));
        this._toDispose.push(SuggestRegistry.onDidChange(function () {
            _this._updateTriggerCharacters();
            _this._updateActiveSuggestSession();
        }));
        this._toDispose.push(this._editor.onDidChangeCursorSelection(function (e) {
            _this._onCursorChange(e);
        }));
        this._toDispose.push(this._editor.onDidChangeModelContent(function (e) {
            _this._refilterCompletionItems();
        }));
        this._updateTriggerCharacters();
        this._updateQuickSuggest();
    }
    SuggestModel.prototype.dispose = function () {
        dispose([this._onDidCancel, this._onDidSuggest, this._onDidTrigger, this._triggerCharacterListener, this._triggerRefilter]);
        this._toDispose = dispose(this._toDispose);
        dispose(this._completionModel);
        this.cancel();
    };
    // --- handle configuration & precondition changes
    SuggestModel.prototype._updateQuickSuggest = function () {
        this._quickSuggestDelay = this._editor.getConfiguration().contribInfo.quickSuggestionsDelay;
        if (isNaN(this._quickSuggestDelay) || (!this._quickSuggestDelay && this._quickSuggestDelay !== 0) || this._quickSuggestDelay < 0) {
            this._quickSuggestDelay = 10;
        }
    };
    SuggestModel.prototype._updateTriggerCharacters = function () {
        var _this = this;
        dispose(this._triggerCharacterListener);
        if (this._editor.getConfiguration().readOnly
            || !this._editor.getModel()
            || !this._editor.getConfiguration().contribInfo.suggestOnTriggerCharacters) {
            return;
        }
        var supportsByTriggerCharacter = Object.create(null);
        for (var _i = 0, _a = SuggestRegistry.all(this._editor.getModel()); _i < _a.length; _i++) {
            var support = _a[_i];
            if (isFalsyOrEmpty(support.triggerCharacters)) {
                continue;
            }
            for (var _b = 0, _c = support.triggerCharacters; _b < _c.length; _b++) {
                var ch = _c[_b];
                var array = supportsByTriggerCharacter[ch];
                if (!array) {
                    supportsByTriggerCharacter[ch] = [support];
                }
                else {
                    array.push(support);
                }
            }
        }
        this._triggerCharacterListener = this._editor.onDidType(function (text) {
            var lastChar = text.charAt(text.length - 1);
            var supports = supportsByTriggerCharacter[lastChar];
            if (supports) {
                // keep existing items that where not computed by the
                // supports/providers that want to trigger now
                var items = [];
                if (_this._completionModel) {
                    for (var _i = 0, _a = _this._completionModel.items; _i < _a.length; _i++) {
                        var item = _a[_i];
                        if (supports.indexOf(item.support) < 0) {
                            items.push(item);
                        }
                    }
                }
                _this.trigger({ auto: true, triggerCharacter: lastChar }, Boolean(_this._completionModel), supports, items);
            }
        });
    };
    Object.defineProperty(SuggestModel.prototype, "state", {
        // --- trigger/retrigger/cancel suggest
        get: function () {
            return this._state;
        },
        enumerable: true,
        configurable: true
    });
    SuggestModel.prototype.cancel = function (retrigger) {
        if (retrigger === void 0) { retrigger = false; }
        this._triggerRefilter.cancel();
        if (this._triggerAutoSuggestPromise) {
            this._triggerAutoSuggestPromise.cancel();
            this._triggerAutoSuggestPromise = null;
        }
        if (this._requestPromise) {
            this._requestPromise.cancel();
            this._requestPromise = null;
        }
        this._state = 0 /* Idle */;
        dispose(this._completionModel);
        this._completionModel = null;
        this._context = null;
        this._onDidCancel.fire({ retrigger: retrigger });
    };
    SuggestModel.prototype._updateActiveSuggestSession = function () {
        if (this._state !== 0 /* Idle */) {
            if (!SuggestRegistry.has(this._editor.getModel())) {
                this.cancel();
            }
            else {
                this.trigger({ auto: this._state === 2 /* Auto */ }, true);
            }
        }
    };
    SuggestModel.prototype._onCursorChange = function (e) {
        var _this = this;
        var prevSelection = this._currentSelection;
        this._currentSelection = this._editor.getSelection();
        if (!e.selection.isEmpty()
            || e.reason !== CursorChangeReason.NotSet
            || (e.source !== 'keyboard' && e.source !== 'deleteLeft')) {
            // Early exit if nothing needs to be done!
            // Leave some form of early exit check here if you wish to continue being a cursor position change listener ;)
            if (this._state !== 0 /* Idle */) {
                this.cancel();
            }
            return;
        }
        if (!SuggestRegistry.has(this._editor.getModel())) {
            return;
        }
        var model = this._editor.getModel();
        if (!model) {
            return;
        }
        if (this._state === 0 /* Idle */) {
            // trigger 24x7 IntelliSense when idle, enabled, when cursor
            // moved RIGHT, and when at a good position
            if (this._editor.getConfiguration().contribInfo.quickSuggestions !== false
                && (prevSelection.containsRange(this._currentSelection)
                    || prevSelection.getEndPosition().isBeforeOrEqual(this._currentSelection.getPosition()))) {
                this.cancel();
                this._triggerAutoSuggestPromise = TPromise.timeout(this._quickSuggestDelay);
                this._triggerAutoSuggestPromise.then(function () {
                    if (LineContext$1.shouldAutoTrigger(_this._editor)) {
                        var model_1 = _this._editor.getModel();
                        var pos = _this._editor.getPosition();
                        if (!model_1) {
                            return;
                        }
                        // validate enabled now
                        var quickSuggestions = _this._editor.getConfiguration().contribInfo.quickSuggestions;
                        if (quickSuggestions === false) {
                            return;
                        }
                        else if (quickSuggestions === true) ;
                        else {
                            // Check the type of the token that triggered this
                            model_1.tokenizeIfCheap(pos.lineNumber);
                            var lineTokens = model_1.getLineTokens(pos.lineNumber);
                            var tokenType = lineTokens.getStandardTokenType(lineTokens.findTokenIndexAtOffset(Math.max(pos.column - 1 - 1, 0)));
                            var inValidScope = quickSuggestions.other && tokenType === 0 /* Other */
                                || quickSuggestions.comments && tokenType === 1 /* Comment */
                                || quickSuggestions.strings && tokenType === 2 /* String */;
                            if (!inValidScope) {
                                return;
                            }
                        }
                        _this.trigger({ auto: true });
                    }
                    _this._triggerAutoSuggestPromise = null;
                });
            }
        }
    };
    SuggestModel.prototype._refilterCompletionItems = function () {
        var _this = this;
        if (this._state === 0 /* Idle */) {
            return;
        }
        var model = this._editor.getModel();
        if (model) {
            // refine active suggestion
            this._triggerRefilter.cancelAndSet(function () {
                var position = _this._editor.getPosition();
                var ctx = new LineContext$1(model, position, _this._state === 2 /* Auto */);
                _this._onNewContext(ctx);
            }, 25);
        }
    };
    SuggestModel.prototype.trigger = function (context, retrigger, onlyFrom, existingItems) {
        var _this = this;
        if (retrigger === void 0) { retrigger = false; }
        var model = this._editor.getModel();
        if (!model) {
            return;
        }
        var auto = context.auto;
        var ctx = new LineContext$1(model, this._editor.getPosition(), auto);
        // Cancel previous requests, change state & update UI
        this.cancel(retrigger);
        this._state = auto ? 2 /* Auto */ : 1 /* Manual */;
        this._onDidTrigger.fire({ auto: auto });
        // Capture context when request was sent
        this._context = ctx;
        // Build context for request
        var suggestCtx;
        if (context.triggerCharacter) {
            suggestCtx = {
                triggerKind: SuggestTriggerKind.TriggerCharacter,
                triggerCharacter: context.triggerCharacter
            };
        }
        else if (onlyFrom && onlyFrom.length) {
            suggestCtx = { triggerKind: SuggestTriggerKind.TriggerForIncompleteCompletions };
        }
        else {
            suggestCtx = { triggerKind: SuggestTriggerKind.Invoke };
        }
        this._requestPromise = provideSuggestionItems(model, this._editor.getPosition(), this._editor.getConfiguration().contribInfo.snippetSuggestions, onlyFrom, suggestCtx).then(function (items) {
            _this._requestPromise = null;
            if (_this._state === 0 /* Idle */) {
                return;
            }
            var model = _this._editor.getModel();
            if (!model) {
                return;
            }
            if (!isFalsyOrEmpty(existingItems)) {
                var cmpFn = getSuggestionComparator(_this._editor.getConfiguration().contribInfo.snippetSuggestions);
                items = items.concat(existingItems).sort(cmpFn);
            }
            var ctx = new LineContext$1(model, _this._editor.getPosition(), auto);
            dispose(_this._completionModel);
            _this._completionModel = new CompletionModel(items, _this._context.column, {
                leadingLineContent: ctx.leadingLineContent,
                characterCountDelta: _this._context ? ctx.column - _this._context.column : 0
            }, _this._editor.getConfiguration().contribInfo.snippetSuggestions);
            _this._onNewContext(ctx);
        }).then(null, onUnexpectedError);
    };
    SuggestModel.prototype._onNewContext = function (ctx) {
        if (!this._context) {
            // happens when 24x7 IntelliSense is enabled and still in its delay
            return;
        }
        if (ctx.lineNumber !== this._context.lineNumber) {
            // e.g. happens when pressing Enter while IntelliSense is computed
            this.cancel();
            return;
        }
        if (ctx.leadingWord.startColumn < this._context.leadingWord.startColumn) {
            // happens when the current word gets outdented
            this.cancel();
            return;
        }
        if (ctx.column < this._context.column) {
            // typed -> moved cursor LEFT -> retrigger if still on a word
            if (ctx.leadingWord.word) {
                this.trigger({ auto: this._context.auto }, true);
            }
            else {
                this.cancel();
            }
            return;
        }
        if (!this._completionModel) {
            // happens when IntelliSense is not yet computed
            return;
        }
        if (ctx.column > this._context.column && this._completionModel.incomplete && ctx.leadingWord.word.length !== 0) {
            // typed -> moved cursor RIGHT & incomple model & still on a word -> retrigger
            var _a = this._completionModel.resolveIncompleteInfo(), complete = _a.complete, incomplete = _a.incomplete;
            this.trigger({ auto: this._state === 2 /* Auto */ }, true, incomplete, complete);
        }
        else {
            // typed -> moved cursor RIGHT -> update UI
            var oldLineContext = this._completionModel.lineContext;
            var isFrozen = false;
            this._completionModel.lineContext = {
                leadingLineContent: ctx.leadingLineContent,
                characterCountDelta: ctx.column - this._context.column
            };
            if (this._completionModel.items.length === 0) {
                if (LineContext$1.shouldAutoTrigger(this._editor) && this._context.leadingWord.endColumn < ctx.leadingWord.startColumn) {
                    // retrigger when heading into a new word
                    this.trigger({ auto: this._context.auto }, true);
                    return;
                }
                if (!this._context.auto) {
                    // freeze when IntelliSense was manually requested
                    this._completionModel.lineContext = oldLineContext;
                    isFrozen = this._completionModel.items.length > 0;
                    if (isFrozen && ctx.leadingWord.word.length === 0) {
                        // there were results before but now there aren't
                        // and also we are not on a word anymore -> cancel
                        this.cancel();
                        return;
                    }
                }
                else {
                    // nothing left
                    this.cancel();
                    return;
                }
            }
            this._onDidSuggest.fire({
                completionModel: this._completionModel,
                auto: this._context.auto,
                isFrozen: isFrozen,
            });
        }
    };
    return SuggestModel;
}());

const css$o = "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n/* Suggest widget*/\n.monaco-editor .suggest-widget {\n\tz-index: 40;\n}\n\n/** Initial widths **/\n\n.monaco-editor .suggest-widget {\n\twidth: 430px;\n}\n\n.monaco-editor .suggest-widget > .message,\n.monaco-editor .suggest-widget > .tree,\n.monaco-editor .suggest-widget > .details {\n\twidth: 100%;\n\tborder-style: solid;\n\tborder-width: 1px;\n\tbox-sizing: border-box;\n}\n\n.monaco-editor.hc-black .suggest-widget > .message,\n.monaco-editor.hc-black .suggest-widget > .tree,\n.monaco-editor.hc-black .suggest-widget > .details {\n\tborder-width: 2px;\n}\n\n/** Adjust width when docs are expanded to the side **/\n.monaco-editor .suggest-widget.docs-side {\n\twidth: 660px;\n}\n\n.monaco-editor .suggest-widget.docs-side > .tree,\n.monaco-editor .suggest-widget.docs-side > .details {\n\twidth: 50%;\n\tfloat: left;\n}\n\n.monaco-editor .suggest-widget.docs-side.list-right > .tree,\n.monaco-editor .suggest-widget.docs-side.list-right > .details  {\n\tfloat: right;\n}\n\n\n/* Styles for Message element for when widget is loading or is empty */\n.monaco-editor .suggest-widget > .message {\n\tpadding-left: 22px;\n}\n\n/** Styles for the list element **/\n.monaco-editor .suggest-widget > .tree {\n\theight: 100%;\n}\n\n\n\n/** Styles for each row in the list element **/\n\n.monaco-editor .suggest-widget .monaco-list .monaco-list-row {\n\tdisplay: flex;\n\t-mox-box-sizing: border-box;\n\tbox-sizing: border-box;\n\tpadding-right: 10px;\n\tbackground-repeat: no-repeat;\n\tbackground-position: 2px 2px;\n\twhite-space: nowrap;\n}\n\n.monaco-editor .suggest-widget .monaco-list .monaco-list-row > .contents {\n\tflex: 1;\n\theight: 100%;\n\toverflow: hidden;\n\tpadding-left: 2px;\n}\n\n.monaco-editor .suggest-widget .monaco-list .monaco-list-row > .contents > .main {\n\tdisplay: flex;\n\toverflow: hidden;\n\ttext-overflow: ellipsis;\n\twhite-space: pre;\n}\n\n.monaco-editor .suggest-widget:not(.frozen) .monaco-highlighted-label .highlight {\n\tfont-weight: bold;\n}\n\n/** Icon styles **/\n\n.monaco-editor .suggest-widget .details > .monaco-scrollable-element > .body > .header > .close,\n.monaco-editor .suggest-widget .monaco-list .monaco-list-row > .contents > .main > .readMore {\n\topacity: 0.6;\n\tbackground-position: center center;\n\tbackground-repeat: no-repeat;\n\tbackground-size: 70%;\n\tcursor: pointer;\n}\n\n.monaco-editor .suggest-widget .details > .monaco-scrollable-element > .body > .header > .close {\n\tbackground-image: url(\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgaGVpZ2h0PSIxNiIgdmlld0JveD0iMyAzIDE2IDE2IiBlbmFibGUtYmFja2dyb3VuZD0ibmV3IDMgMyAxNiAxNiI+PHBvbHlnb24gZmlsbD0iIzQyNDI0MiIgcG9pbnRzPSIxMi41OTcsMTEuMDQyIDE1LjQsMTMuODQ1IDEzLjg0NCwxNS40IDExLjA0MiwxMi41OTggOC4yMzksMTUuNCA2LjY4MywxMy44NDUgOS40ODUsMTEuMDQyIDYuNjgzLDguMjM5IDguMjM4LDYuNjgzIDExLjA0Miw5LjQ4NiAxMy44NDUsNi42ODMgMTUuNCw4LjIzOSIvPjwvc3ZnPg==\");\n\tfloat: right;\n\tmargin-right: 5px;\n}\n\n.monaco-editor .suggest-widget .monaco-list .monaco-list-row > .contents > .main > .readMore {\n\tbackground-image: url(\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgaGVpZ2h0PSIxNiI+PHBhdGggZD0iTTggMWMtMy44NjUgMC03IDMuMTM1LTcgN3MzLjEzNSA3IDcgNyA3LTMuMTM1IDctNy0zLjEzNS03LTctN3ptMSAxMmgtMnYtN2gydjd6bTAtOGgtMnYtMmgydjJ6IiBmaWxsPSIjMUJBMUUyIi8+PHBhdGggZD0iTTcgNmgydjdoLTJ2LTd6bTAtMWgydi0yaC0ydjJ6IiBmaWxsPSIjZmZmIi8+PC9zdmc+\");\n}\n\n.monaco-editor .suggest-widget .details > .monaco-scrollable-element > .body > .header > .close:hover,\n.monaco-editor .suggest-widget .monaco-list .monaco-list-row > .contents > .main > .readMore:hover {\n\topacity: 1;\n}\n\n/** Type Info and icon next to the label in the focused completion item **/\n\n.monaco-editor .suggest-widget .monaco-list .monaco-list-row > .contents > .main > .type-label {\n\tmargin-left: 0.8em;\n\tflex: 1;\n\ttext-align: right;\n\toverflow: hidden;\n\ttext-overflow: ellipsis;\n\topacity: 0.7;\n}\n\n.monaco-editor .suggest-widget .monaco-list .monaco-list-row > .contents > .main > .type-label > .monaco-tokenized-source {\n\tdisplay: inline;\n}\n\n.monaco-editor .suggest-widget .monaco-list .monaco-list-row > .contents > .main > .readMore,\n.monaco-editor .suggest-widget .monaco-list .monaco-list-row > .contents > .main > .type-label,\n.monaco-editor .suggest-widget.docs-side .monaco-list .monaco-list-row.focused > .contents > .main > .readMore,\n.monaco-editor .suggest-widget.docs-side .monaco-list .monaco-list-row.focused > .contents > .main > .type-label,\n.monaco-editor .suggest-widget.docs-below .monaco-list .monaco-list-row.focused > .contents > .main > .readMore {\n\tdisplay: none;\n}\n\n.monaco-editor .suggest-widget .monaco-list .monaco-list-row.focused > .contents > .main > .readMore,\n.monaco-editor .suggest-widget .monaco-list .monaco-list-row.focused > .contents > .main > .type-label {\n\tdisplay: inline;\n}\n\n/** Styles for each row in the list **/\n\n.monaco-editor .suggest-widget .monaco-list .monaco-list-row .icon {\n\tdisplay: block;\n\theight: 16px;\n\twidth: 16px;\n\tbackground-repeat: no-repeat;\n\tbackground-size: 80%;\n\tbackground-position: center;\n}\n\n.monaco-editor .suggest-widget .monaco-list .monaco-list-row .icon { background-image: url(\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNiAxNiI+PHN0eWxlPi5pY29uLWNhbnZhcy10cmFuc3BhcmVudHtvcGFjaXR5OjA7ZmlsbDojZjZmNmY2fS5pY29uLXZzLW91dHtmaWxsOiNmNmY2ZjZ9Lmljb24tdnMtYmd7ZmlsbDojNDI0MjQyfTwvc3R5bGU+PHBhdGggY2xhc3M9Imljb24tY2FudmFzLXRyYW5zcGFyZW50IiBkPSJNMTYgMTZIMFYwaDE2djE2eiIgaWQ9ImNhbnZhcyIvPjxwYXRoIGNsYXNzPSJpY29uLXZzLW91dCIgZD0iTTE2IDEwYzAgMi4yMDUtMS43OTQgNC00IDQtMS44NTggMC0zLjQxMS0xLjI3OS0zLjg1OC0zaC0uOTc4bDIuMzE4IDRIMHYtMS43MDNsMi0zLjQwOFYwaDExdjYuMTQyYzEuNzIxLjQ0NyAzIDIgMyAzLjg1OHoiIGlkPSJvdXRsaW5lIi8+PHBhdGggY2xhc3M9Imljb24tdnMtYmciIGQ9Ik0xMiAxdjQuNzVBNC4yNTUgNC4yNTUgMCAwIDAgNy43NSAxMGgtLjczMkw0LjI3NSA1LjI2OSAzIDcuNDQyVjFoOXpNNy43NDcgMTRMNC4yNjkgOCAuNzQ4IDE0aDYuOTk5ek0xNSAxMGEzIDMgMCAxIDEtNiAwIDMgMyAwIDAgMSA2IDB6IiBpZD0iaWNvbkJnIi8+PC9zdmc+\"); }\n.monaco-editor .suggest-widget .monaco-list .monaco-list-row .icon.method,\n.monaco-editor .suggest-widget .monaco-list .monaco-list-row .icon.function,\n.monaco-editor .suggest-widget .monaco-list .monaco-list-row .icon.constructor { background-image: url(\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNiAxNiI+PHN0eWxlPi5pY29uLWNhbnZhcy10cmFuc3BhcmVudHtvcGFjaXR5OjA7ZmlsbDojZjZmNmY2fS5pY29uLXZzLW91dHtmaWxsOiNmNmY2ZjZ9Lmljb24tdnMtZmd7ZmlsbDojZjBlZmYxfS5pY29uLXZzLWFjdGlvbi1wdXJwbGV7ZmlsbDojNjUyZDkwfTwvc3R5bGU+PHBhdGggY2xhc3M9Imljb24tY2FudmFzLXRyYW5zcGFyZW50IiBkPSJNMTYgMTZIMFYwaDE2djE2eiIgaWQ9ImNhbnZhcyIvPjxwYXRoIGNsYXNzPSJpY29uLXZzLW91dCIgZD0iTTE1IDMuMzQ5djguNDAzTDguOTc1IDE2SDguMDdMMSAxMS41ODJWMy4zMjdMNy41OTUgMGgxLjExOEwxNSAzLjM0OXoiIGlkPSJvdXRsaW5lIi8+PHBhdGggY2xhc3M9Imljb24tdnMtZmciIGQ9Ik0xMi43MTUgNC4zOThMOC40ODcgNy4wMiAzLjU2NSA0LjI3Mmw0LjU3OC0yLjMwOSA0LjU3MiAyLjQzNXpNMyA1LjEwMmw1IDIuNzkydjUuNzA1bC01LTMuMTI1VjUuMTAyem02IDguNDM0VjcuODc4bDQtMi40OHY1LjMxN2wtNCAyLjgyMXoiIGlkPSJpY29uRmciLz48cGF0aCBjbGFzcz0iaWNvbi12cy1hY3Rpb24tcHVycGxlIiBkPSJNOC4xNTYuODM3TDIgMy45NDJ2Ny4wODVMOC41MTcgMTUuMSAxNCAxMS4yMzNWMy45NUw4LjE1Ni44Mzd6bTQuNTU5IDMuNTYxTDguNDg3IDcuMDIgMy41NjUgNC4yNzJsNC41NzgtMi4zMDkgNC41NzIgMi40MzV6TTMgNS4xMDJsNSAyLjc5MnY1LjcwNWwtNS0zLjEyNVY1LjEwMnptNiA4LjQzNFY3Ljg3OGw0LTIuNDh2NS4zMTdsLTQgMi44MjF6IiBpZD0iaWNvbkJnIi8+PC9zdmc+\"); }\n.monaco-editor .suggest-widget .monaco-list .monaco-list-row .icon.field { background-image: url(\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNiAxNiI+PHN0eWxlPi5pY29uLWNhbnZhcy10cmFuc3BhcmVudHtvcGFjaXR5OjA7ZmlsbDojZjZmNmY2fS5pY29uLXZzLW91dHtmaWxsOiNmNmY2ZjZ9Lmljb24tdnMtZmd7ZmlsbDojZjBlZmYxfS5pY29uLXZzLWFjdGlvbi1ibHVle2ZpbGw6IzAwNTM5Y308L3N0eWxlPjxwYXRoIGNsYXNzPSJpY29uLWNhbnZhcy10cmFuc3BhcmVudCIgZD0iTTE2IDE2SDBWMGgxNnYxNnoiIGlkPSJjYW52YXMiLz48cGF0aCBjbGFzcz0iaWNvbi12cy1vdXQiIGQ9Ik0wIDEwLjczNlY0LjVMOSAwbDcgMy41djYuMjM2bC05IDQuNS03LTMuNXoiIGlkPSJvdXRsaW5lIi8+PHBhdGggY2xhc3M9Imljb24tdnMtYWN0aW9uLWJsdWUiIGQ9Ik05IDFMMSA1djVsNiAzIDgtNFY0TDkgMXpNNyA2Ljg4MkwzLjIzNiA1IDkgMi4xMTggMTIuNzY0IDQgNyA2Ljg4MnoiIGlkPSJpY29uQmciLz48cGF0aCBjbGFzcz0iaWNvbi12cy1mZyIgZD0iTTkgMi4xMThMMTIuNzY0IDQgNyA2Ljg4MiAzLjIzNiA1IDkgMi4xMTh6IiBpZD0iaWNvbkZnIi8+PC9zdmc+\"); }\n.monaco-editor .suggest-widget .monaco-list .monaco-list-row .icon.event { background-image: url(\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNiAxNiI+PHN0eWxlPi5pY29uLWNhbnZhcy10cmFuc3BhcmVudHtvcGFjaXR5OjA7ZmlsbDojZjZmNmY2fS5pY29uLXZzLW91dHtmaWxsOiNmNmY2ZjZ9Lmljb24tdnMtYWN0aW9uLW9yYW5nZXtmaWxsOiNjMjdkMWF9PC9zdHlsZT48cGF0aCBjbGFzcz0iaWNvbi1jYW52YXMtdHJhbnNwYXJlbnQiIGQ9Ik0xNiAxNkgwVjBoMTZ2MTZ6IiBpZD0iY2FudmFzIi8+PHBhdGggY2xhc3M9Imljb24tdnMtb3V0IiBkPSJNMTQgMS40MTRMOS40MTQgNkgxNHYxLjQxNEw1LjQxNCAxNkgzdi0xLjIzNEw1LjM3MSAxMEgyVjguNzY0TDYuMzgyIDBIMTR2MS40MTR6IiBpZD0ib3V0bGluZSIgc3R5bGU9ImRpc3BsYXk6IG5vbmU7Ii8+PHBhdGggY2xhc3M9Imljb24tdnMtYWN0aW9uLW9yYW5nZSIgZD0iTTcgN2g2bC04IDhINGwyLjk4NS02SDNsNC04aDZMNyA3eiIgaWQ9Imljb25CZyIvPjwvc3ZnPg==\"); }\n.monaco-editor .suggest-widget .monaco-list .monaco-list-row .icon.operator { background-image: url(\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNiAxNiI+PHN0eWxlPi5pY29uLWNhbnZhcy10cmFuc3BhcmVudHtvcGFjaXR5OjA7ZmlsbDojZjZmNmY2fS5pY29uLXZzLW91dHtmaWxsOiNmNmY2ZjZ9Lmljb24tdnMtZmd7ZmlsbDojZjBlZmYxfS5pY29uLXZzLWFjdGlvbi1ibHVle2ZpbGw6IzAwNTM5Y308L3N0eWxlPjxwYXRoIGNsYXNzPSJpY29uLWNhbnZhcy10cmFuc3BhcmVudCIgZD0iTTE2IDE2SDBWMGgxNnYxNnoiIGlkPSJjYW52YXMiLz48cGF0aCBjbGFzcz0iaWNvbi12cy1vdXQiIGQ9Ik0xNiAxNkgwVjBoMTZ2MTZ6IiBpZD0ib3V0bGluZSIgc3R5bGU9ImRpc3BsYXk6IG5vbmU7Ii8+PHBhdGggY2xhc3M9Imljb24tdnMtYWN0aW9uLWJsdWUiIGQ9Ik0xIDF2MTRoMTRWMUgxem02IDEySDN2LTFoNHYxem0wLTNIM1Y5aDR2MXptMC01SDV2Mkg0VjVIMlY0aDJWMmgxdjJoMnYxem0zLjI4MSA4SDguNzE5bDMtNGgxLjU2M2wtMy4wMDEgNHpNMTQgNUg5VjRoNXYxeiIgaWQ9Imljb25CZyIvPjxwYXRoIGNsYXNzPSJpY29uLXZzLWZnIiBkPSJNNyA1SDV2Mkg0VjVIMlY0aDJWMmgxdjJoMnYxem03LTFIOXYxaDVWNHpNNyA5SDN2MWg0Vjl6bTAgM0gzdjFoNHYtMXptMy4yODEgMWwzLTRoLTEuNTYzbC0zIDRoMS41NjN6IiBpZD0iaWNvbkZnIiBzdHlsZT0iZGlzcGxheTogbm9uZTsiLz48L3N2Zz4=\"); }\n.monaco-editor .suggest-widget .monaco-list .monaco-list-row .icon.variable { background-image: url(\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNiAxNiI+PHN0eWxlPi5pY29uLWNhbnZhcy10cmFuc3BhcmVudHtvcGFjaXR5OjA7ZmlsbDojZjZmNmY2fS5pY29uLXZzLW91dHtmaWxsOiNmNmY2ZjZ9Lmljb24tdnMtYmd7ZmlsbDojNDI0MjQyfS5pY29uLXZzLWZne2ZpbGw6I2YwZWZmMX0uaWNvbi12cy1hY3Rpb24tYmx1ZXtmaWxsOiMwMDUzOWN9PC9zdHlsZT48cGF0aCBjbGFzcz0iaWNvbi1jYW52YXMtdHJhbnNwYXJlbnQiIGQ9Ik0xNiAxNkgwVjBoMTZ2MTZ6IiBpZD0iY2FudmFzIi8+PHBhdGggY2xhc3M9Imljb24tdnMtb3V0IiBkPSJNMTEgM3YxLjAxNUw4LjczMyAyLjg4MiA1IDQuNzQ5VjNIMHYxMGg1di0xLjg1OWwyLjE1NiAxLjA3N0wxMSAxMC4yOTVWMTNoNVYzaC01eiIgaWQ9Im91dGxpbmUiIHN0eWxlPSJkaXNwbGF5OiBub25lOyIvPjxwYXRoIGNsYXNzPSJpY29uLXZzLWJnIiBkPSJNMiA1djZoMnYxSDFWNGgzdjFIMnptMTAgNnYxaDNWNGgtM3YxaDJ2NmgtMnoiIGlkPSJpY29uQmciLz48cGF0aCBjbGFzcz0iaWNvbi12cy1mZyIgZD0iTTcuMTU2IDcuMTU2bC0xLjU3OC0uNzg5IDMuMTU2LTEuNTc4IDEuNTc4Ljc4OS0zLjE1NiAxLjU3OHoiIGlkPSJpY29uRmciIHN0eWxlPSJkaXNwbGF5OiBub25lOyIvPjxwYXRoIGNsYXNzPSJpY29uLXZzLWFjdGlvbi1ibHVlIiBkPSJNOC43MzMgNEw0IDYuMzY3djMuMTU2TDcuMTU2IDExLjFsNC43MzMtMi4zNjdWNS41NzhMOC43MzMgNHpNNy4xNTYgNy4xNTZsLTEuNTc4LS43ODkgMy4xNTYtMS41NzggMS41NzguNzg5LTMuMTU2IDEuNTc4eiIgaWQ9ImNvbG9ySW1wb3J0YW5jZSIvPjwvc3ZnPg==\"); }\n.monaco-editor .suggest-widget .monaco-list .monaco-list-row .icon.class { background-image: url(\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNiAxNiI+PHN0eWxlPi5pY29uLWNhbnZhcy10cmFuc3BhcmVudHtvcGFjaXR5OjA7ZmlsbDojZjZmNmY2fS5pY29uLXZzLW91dHtmaWxsOiNmNmY2ZjZ9Lmljb24tdnMtYWN0aW9uLW9yYW5nZXtmaWxsOiNjMjdkMWF9PC9zdHlsZT48cGF0aCBjbGFzcz0iaWNvbi1jYW52YXMtdHJhbnNwYXJlbnQiIGQ9Ik0xNiAxNkgwVjBoMTZ2MTZ6IiBpZD0iY2FudmFzIi8+PHBhdGggY2xhc3M9Imljb24tdnMtb3V0IiBkPSJNMTYgNi41ODZsLTMtM0wxMS41ODYgNUg5LjQxNGwxLTEtNC00aC0uODI4TDAgNS41ODZ2LjgyOGw0IDRMNi40MTQgOEg3djVoMS41ODZsMyAzaC44MjhMMTYgMTIuNDE0di0uODI4TDEzLjkxNCA5LjUgMTYgNy40MTR2LS44Mjh6IiBpZD0ib3V0bGluZSIvPjxwYXRoIGNsYXNzPSJpY29uLXZzLWFjdGlvbi1vcmFuZ2UiIGQ9Ik0xMyAxMGwyIDItMyAzLTItMiAxLTFIOFY3SDZMNCA5IDEgNmw1LTUgMyAzLTIgMmg1bDEtMSAyIDItMyAzLTItMiAxLTFIOXY0bDIuOTk5LjAwMkwxMyAxMHoiIGlkPSJpY29uQmciLz48L3N2Zz4=\"); }\n.monaco-editor .suggest-widget .monaco-list .monaco-list-row .icon.interface { background-image: url(\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNiAxNiI+PHN0eWxlPi5pY29uLWNhbnZhcy10cmFuc3BhcmVudHtvcGFjaXR5OjA7ZmlsbDojZjZmNmY2fS5pY29uLXZzLW91dHtmaWxsOiNmNmY2ZjZ9Lmljb24tdnMtZmd7ZmlsbDojZjBlZmYxfS5pY29uLXZzLWFjdGlvbi1ibHVle2ZpbGw6IzAwNTM5Y308L3N0eWxlPjxwYXRoIGNsYXNzPSJpY29uLWNhbnZhcy10cmFuc3BhcmVudCIgZD0iTTE2IDE2SDBWMGgxNnYxNnoiIGlkPSJjYW52YXMiLz48cGF0aCBjbGFzcz0iaWNvbi12cy1vdXQiIGQ9Ik0xMS41IDEyYy0xLjkxNSAwLTMuNjAyLTEuMjQxLTQuMjI4LTNoLTEuNDFhMy4xMSAzLjExIDAgMCAxLTIuNzM3IDEuNjI1QzEuNDAyIDEwLjYyNSAwIDkuMjIzIDAgNy41czEuNDAyLTMuMTI1IDMuMTI1LTMuMTI1YzEuMTY1IDAgMi4yMDEuNjM5IDIuNzM3IDEuNjI1aDEuNDFjLjYyNi0xLjc1OSAyLjMxMy0zIDQuMjI4LTNDMTMuOTgxIDMgMTYgNS4wMTkgMTYgNy41UzEzLjk4MSAxMiAxMS41IDEyeiIgaWQ9Im91dGxpbmUiLz48cGF0aCBjbGFzcz0iaWNvbi12cy1mZyIgZD0iTTExLjUgOUExLjUwMSAxLjUwMSAwIDEgMSAxMyA3LjVjMCAuODI2LS42NzMgMS41LTEuNSAxLjV6IiBpZD0iaWNvbkZnIi8+PHBhdGggY2xhc3M9Imljb24tdnMtYWN0aW9uLWJsdWUiIGQ9Ik0xMS41IDRhMy40OSAzLjQ5IDAgMCAwLTMuNDUgM0g1LjE4NUEyLjEyMiAyLjEyMiAwIDAgMCAxIDcuNWEyLjEyMyAyLjEyMyAwIDEgMCA0LjE4NS41SDguMDVhMy40OSAzLjQ5IDAgMCAwIDMuNDUgMyAzLjUgMy41IDAgMSAwIDAtN3ptMCA1Yy0uODI3IDAtMS41LS42NzMtMS41LTEuNVMxMC42NzMgNiAxMS41IDZzMS41LjY3MyAxLjUgMS41UzEyLjMyNyA5IDExLjUgOXoiIGlkPSJpY29uQmciLz48L3N2Zz4=\"); }\n.monaco-editor .suggest-widget .monaco-list .monaco-list-row .icon.struct { background-image: url(\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNiAxNiI+PHN0eWxlPi5pY29uLWNhbnZhcy10cmFuc3BhcmVudHtvcGFjaXR5OjA7ZmlsbDojZjZmNmY2fS5pY29uLXZzLW91dHtmaWxsOiNmNmY2ZjZ9Lmljb24tdnMtYWN0aW9uLWJsdWV7ZmlsbDojMDA1MzljfTwvc3R5bGU+PHBhdGggY2xhc3M9Imljb24tY2FudmFzLXRyYW5zcGFyZW50IiBkPSJNMTYgMTZIMFYwaDE2djE2eiIgaWQ9ImNhbnZhcyIvPjxwYXRoIGNsYXNzPSJpY29uLXZzLW91dCIgZD0iTTkgMTRWOEg3djZIMVYyaDE0djEySDl6IiBpZD0ib3V0bGluZSIgc3R5bGU9ImRpc3BsYXk6IG5vbmU7Ii8+PHBhdGggY2xhc3M9Imljb24tdnMtYWN0aW9uLWJsdWUiIGQ9Ik0xMCA5aDR2NGgtNFY5em0tOCA0aDRWOUgydjR6TTIgM3Y0aDEyVjNIMnoiIGlkPSJpY29uQmciLz48L3N2Zz4=\"); }\n.monaco-editor .suggest-widget .monaco-list .monaco-list-row .icon.type-parameter { background-image: url(\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNiAxNiI+PHN0eWxlPi5pY29uLWNhbnZhcy10cmFuc3BhcmVudHtvcGFjaXR5OjA7ZmlsbDojZjZmNmY2fS5pY29uLXZzLW91dHtmaWxsOiNmNmY2ZjZ9Lmljb24tdnMtYmd7ZmlsbDojNDI0MjQyfTwvc3R5bGU+PHBhdGggY2xhc3M9Imljb24tY2FudmFzLXRyYW5zcGFyZW50IiBkPSJNMTYgMTZIMFYwaDE2djE2eiIgaWQ9ImNhbnZhcyIvPjxwYXRoIGNsYXNzPSJpY29uLXZzLW91dCIgZD0iTTEwLjcwMiAxMC41bDItMi0yLTIgLjUtLjVIMTB2NWgxdjNINXYtM2gxVjZINC43OThsLjUuNS0yIDIgMiAyTDMgMTIuNzk3bC0zLTNWNy4yMDFsMy0zVjJoMTB2Mi4yMDFsMyAzdjIuNTk2bC0zIDMtMi4yOTgtMi4yOTd6IiBpZD0ib3V0bGluZSIgc3R5bGU9ImRpc3BsYXk6IG5vbmU7Ii8+PHBhdGggY2xhc3M9Imljb24tdnMtYmciIGQ9Ik00IDNoOHYyaC0xdi0uNWMwLS4yNzctLjIyNC0uNS0uNS0uNUg5djcuNWMwIC4yNzUuMjI0LjUuNS41aC41djFINnYtMWguNWEuNS41IDAgMCAwIC41LS41VjRINS41YS41LjUgMCAwIDAtLjUuNVY1SDRWM3pNMyA1LjYxNUwuMTE2IDguNSAzIDExLjM4M2wuODg0LS44ODMtMi0yIDItMkwzIDUuNjE1em0xMCAwbC0uODg0Ljg4NSAyIDItMiAyIC44ODQuODgzTDE1Ljg4NCA4LjUgMTMgNS42MTV6IiBpZD0iaWNvbkJnIi8+PC9zdmc+\"); }\n.monaco-editor .suggest-widget .monaco-list .monaco-list-row .icon.module { background-image: url(\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNiAxNiI+PHN0eWxlPi5pY29uLWNhbnZhcy10cmFuc3BhcmVudHtvcGFjaXR5OjA7ZmlsbDojZjZmNmY2fS5pY29uLXZzLW91dHtmaWxsOiNmNmY2ZjZ9Lmljb24tdnMtYmd7ZmlsbDojNDI0MjQyfTwvc3R5bGU+PHBhdGggY2xhc3M9Imljb24tY2FudmFzLXRyYW5zcGFyZW50IiBkPSJNMTYgMTZIMFYwaDE2djE2eiIgaWQ9ImNhbnZhcyIvPjxwYXRoIGNsYXNzPSJpY29uLXZzLW91dCIgZD0iTTkuMjYgMTEuOTg0bC45NzgtLjAyMWEuOTYyLjk2MiAwIDAgMCAuMDktLjAwNmMuMDExLS4wNjMuMDI2LS4xNzkuMDI2LS4zNjFWOS42ODhjMC0uNjc5LjE4NS0xLjI1Ny41My0xLjcwNy0uMzQ2LS40NTItLjUzLTEuMDMtLjUzLTEuNzA1VjQuMzVjMC0uMTY3LS4wMjEtLjI1OS0uMDM0LS4zMDJMOS4yNiA0LjAyVi45NzNsMS4wMTEuMDExYzIuMTY3LjAyNCAzLjQwOSAxLjE1NiAzLjQwOSAzLjEwNXYxLjk2MmMwIC4zNTEuMDcxLjQ2MS4wNzIuNDYybC45MzYuMDYuMDUzLjkyN3YxLjkzNmwtLjkzNi4wNjFjLS4wNzYuMDE2LS4xMjUuMTQ2LS4xMjUuNDI0djIuMDE3YzAgLjkxNC0uMzMyIDMuMDQzLTMuNDA4IDMuMDc4bC0xLjAxMi4wMTF2LTMuMDQzem0tMy41MjEgMy4wMzJjLTMuMDg5LS4wMzUtMy40MjItMi4xNjQtMy40MjItMy4wNzhWOS45MjFjMC0uMzI3LS4wNjYtLjQzMi0uMDY3LS40MzNsLS45MzctLjA2LS4wNjMtLjkyOVY2LjU2M2wuOTQyLS4wNmMuMDU4IDAgLjEyNS0uMTE0LjEyNS0uNDUyVjQuMDljMC0xLjk0OSAxLjI0OC0zLjA4MSAzLjQyMi0zLjEwNUw2Ljc1Ljk3M1Y0LjAybC0uOTc1LjAyM2EuNTcyLjU3MiAwIDAgMC0uMDkzLjAxYy4wMDYuMDIxLS4wMTkuMTE1LS4wMTkuMjk3djEuOTI4YzAgLjY3NS0uMTg2IDEuMjUzLS41MzQgMS43MDUuMzQ4LjQ1LjUzNCAxLjAyOC41MzQgMS43MDd2MS45MDdjMCAuMTc1LjAxNC4yOTEuMDI3LjM2My4wMjMuMDAyIDEuMDYuMDI1IDEuMDYuMDI1djMuMDQzbC0xLjAxMS0uMDEyeiIgaWQ9Im91dGxpbmUiLz48cGF0aCBjbGFzcz0iaWNvbi12cy1iZyIgZD0iTTUuNzUgMTQuMDE2Yy0xLjYyMy0uMDE5LTIuNDM0LS43MTEtMi40MzQtMi4wNzhWOS45MjFjMC0uOTAyLS4zNTUtMS4zNzYtMS4wNjYtMS40MjJ2LS45OThjLjcxMS0uMDQ1IDEuMDY2LS41MjkgMS4wNjYtMS40NDlWNC4wOWMwLTEuMzg1LjgxMS0yLjA4NyAyLjQzNC0yLjEwNXYxLjA2Yy0uNzI1LjAxNy0xLjA4Ny40NTMtMS4wODcgMS4zMDV2MS45MjhjMCAuOTItLjQ1NCAxLjQ4OC0xLjM2IDEuNzAyVjhjLjkwNy4yMDEgMS4zNi43NjMgMS4zNiAxLjY4OHYxLjkwN2MwIC40ODguMDgxLjgzNS4yNDMgMS4wNDIuMTYyLjIwOC40NDMuMzE2Ljg0NC4zMjV2MS4wNTR6bTcuOTktNS41MTdjLS43MDYuMDQ1LTEuMDYuNTItMS4wNiAxLjQyMnYyLjAxN2MwIDEuMzY3LS44MDcgMi4wNi0yLjQyIDIuMDc4di0xLjA1M2MuMzk2LS4wMDkuNjc4LS4xMTguODQ0LS4zMjguMTY3LS4yMS4yNS0uNTU2LjI1LTEuMDM5VjkuNjg4YzAtLjkyNS40NDktMS40ODggMS4zNDctMS42ODh2LS4wMjFjLS44OTgtLjIxNC0xLjM0Ny0uNzgyLTEuMzQ3LTEuNzAyVjQuMzVjMC0uODUyLS4zNjQtMS4yODgtMS4wOTQtMS4zMDZ2LTEuMDZjMS42MTMuMDE4IDIuNDIuNzIgMi40MiAyLjEwNXYxLjk2MmMwIC45Mi4zNTQgMS40MDQgMS4wNiAxLjQ0OXYuOTk5eiIgaWQ9Imljb25CZyIvPjwvc3ZnPg==\"); }\n.monaco-editor .suggest-widget .monaco-list .monaco-list-row .icon.property { background-image: url(\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNiAxNiI+PHN0eWxlPi5pY29uLWNhbnZhcy10cmFuc3BhcmVudHtvcGFjaXR5OjA7ZmlsbDojZjZmNmY2fS5pY29uLXZzLW91dHtmaWxsOiNmNmY2ZjZ9Lmljb24tdnMtYmd7ZmlsbDojNDI0MjQyfTwvc3R5bGU+PHBhdGggY2xhc3M9Imljb24tY2FudmFzLXRyYW5zcGFyZW50IiBkPSJNMTYgMTZIMFYwaDE2djE2eiIgaWQ9ImNhbnZhcyIvPjxwYXRoIGNsYXNzPSJpY29uLXZzLW91dCIgZD0iTTE2IDUuNWE1LjUgNS41IDAgMCAxLTUuNSA1LjVjLS4yNzUgMC0uNTQzLS4wMjctLjgwNy0uMDY2bC0uMDc5LS4wMTJhNS40MjkgNS40MjkgMCAwIDEtLjgxLS4xOTJsLTQuNTM3IDQuNTM3Yy0uNDcyLjQ3My0xLjEuNzMzLTEuNzY3LjczM3MtMS4yOTUtLjI2LTEuNzY4LS43MzJhMi41MDIgMi41MDIgMCAwIDEgMC0zLjUzNWw0LjUzNy00LjUzN2E1LjQ1MiA1LjQ1MiAwIDAgMS0uMTkxLS44MTJjLS4wMDUtLjAyNS0uMDA4LS4wNTEtLjAxMi0uMDc3QTUuNTAzIDUuNTAzIDAgMCAxIDUgNS41YTUuNSA1LjUgMCAxIDEgMTEgMHoiIGlkPSJvdXRsaW5lIi8+PHBhdGggY2xhc3M9Imljb24tdnMtYmciIGQ9Ik0xNSA1LjVhNC41IDQuNSAwIDAgMS00LjUgNC41Yy0uNjkzIDAtMS4zNDItLjE3LTEuOTI5LS40NWwtNS4wMSA1LjAxYy0uMjkzLjI5NC0uNjc3LjQ0LTEuMDYxLjQ0cy0uNzY4LS4xNDYtMS4wNjEtLjQzOWExLjUgMS41IDAgMCAxIDAtMi4xMjFsNS4wMS01LjAxQTQuNDgzIDQuNDgzIDAgMCAxIDYgNS41IDQuNSA0LjUgMCAwIDEgMTAuNSAxYy42OTMgMCAxLjM0Mi4xNyAxLjkyOS40NUw5LjYzNiA0LjI0M2wyLjEyMSAyLjEyMSAyLjc5My0yLjc5M2MuMjguNTg3LjQ1IDEuMjM2LjQ1IDEuOTI5eiIgaWQ9Imljb25CZyIvPjwvc3ZnPg==\"); }\n.monaco-editor .suggest-widget .monaco-list .monaco-list-row .icon.unit { background-image: url(\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNiAxNiI+PHN0eWxlPi5pY29uLWNhbnZhcy10cmFuc3BhcmVudHtvcGFjaXR5OjA7ZmlsbDojZjZmNmY2fS5pY29uLXZzLW91dHtmaWxsOiNmNmY2ZjZ9Lmljb24tdnMtYmd7ZmlsbDojNDI0MjQyfS5pY29uLXZzLWZne2ZpbGw6I2YwZWZmMX08L3N0eWxlPjxwYXRoIGNsYXNzPSJpY29uLWNhbnZhcy10cmFuc3BhcmVudCIgZD0iTTE2IDE2SDBWMGgxNnYxNnoiIGlkPSJjYW52YXMiLz48cGF0aCBjbGFzcz0iaWNvbi12cy1vdXQiIGQ9Ik0xNiAxMS4wMTNIMVY0aDE1djcuMDEzeiIgaWQ9Im91dGxpbmUiLz48cGF0aCBjbGFzcz0iaWNvbi12cy1mZyIgZD0iTTggOUg3VjZoM3YzSDlWN0g4djJ6TTQgN2gxdjJoMVY2SDN2M2gxVjd6bTggMGgxdjJoMVY2aC0zdjNoMVY3eiIgaWQ9Imljb25GZyIvPjxwYXRoIGNsYXNzPSJpY29uLXZzLWJnIiBkPSJNMiA1djVoMTNWNUgyem00IDRINVY3SDR2MkgzVjZoM3Yzem00IDBIOVY3SDh2Mkg3VjZoM3Yzem00IDBoLTFWN2gtMXYyaC0xVjZoM3YzeiIgaWQ9Imljb25CZyIvPjwvc3ZnPg==\"); }\n.monaco-editor .suggest-widget .monaco-list .monaco-list-row .icon.constant { background-image: url(\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNiAxNiI+PHN0eWxlPi5pY29uLWNhbnZhcy10cmFuc3BhcmVudHtvcGFjaXR5OjA7ZmlsbDojZjZmNmY2fS5pY29uLXZzLW91dHtmaWxsOiNmNmY2ZjZ9Lmljb24tdnMtYmd7ZmlsbDojNDI0MjQyfS5pY29uLXZzLWZne2ZpbGw6I2YwZWZmMX0uaWNvbi12cy1hY3Rpb24tYmx1ZXtmaWxsOiMwMDUzOWN9PC9zdHlsZT48cGF0aCBjbGFzcz0iaWNvbi1jYW52YXMtdHJhbnNwYXJlbnQiIGQ9Ik0xNiAxNkgwVjBoMTZ2MTZ6IiBpZD0iY2FudmFzIi8+PHBhdGggY2xhc3M9Imljb24tdnMtb3V0IiBkPSJNMi44NzkgMTRMMSAxMi4xMjFWMy44NzlMMi44NzkgMmgxMC4yNDJMMTUgMy44Nzl2OC4yNDJMMTMuMTIxIDE0SDIuODc5eiIgaWQ9Im91dGxpbmUiLz48cGF0aCBjbGFzcz0iaWNvbi12cy1mZyIgZD0iTTEyLjI5MyA0SDMuNzA3TDMgNC43MDd2Ni41ODZsLjcwNy43MDdoOC41ODZsLjcwNy0uNzA3VjQuNzA3TDEyLjI5MyA0ek0xMSAxMEg1VjloNnYxem0wLTNINVY2aDZ2MXoiIGlkPSJpY29uRmciLz48ZyBpZD0iaWNvbkJnIj48cGF0aCBjbGFzcz0iaWNvbi12cy1iZyIgZD0iTTEyLjcwNyAxM0gzLjI5M0wyIDExLjcwN1Y0LjI5M0wzLjI5MyAzaDkuNDE0TDE0IDQuMjkzdjcuNDE0TDEyLjcwNyAxM3ptLTktMWg4LjU4NmwuNzA3LS43MDdWNC43MDdMMTIuMjkzIDRIMy43MDdMMyA0LjcwN3Y2LjU4NmwuNzA3LjcwN3oiLz48cGF0aCBjbGFzcz0iaWNvbi12cy1hY3Rpb24tYmx1ZSIgZD0iTTExIDdINVY2aDZ2MXptMCAySDV2MWg2Vjl6Ii8+PC9nPjwvc3ZnPg==\"); }\n.monaco-editor .suggest-widget .monaco-list .monaco-list-row .icon.value,\n.monaco-editor .suggest-widget .monaco-list .monaco-list-row .icon.enum { background-image: url(\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNiAxNiI+PHN0eWxlPi5pY29uLWNhbnZhcy10cmFuc3BhcmVudHtvcGFjaXR5OjA7ZmlsbDojZjZmNmY2fS5pY29uLXZzLW91dHtmaWxsOiNmNmY2ZjZ9Lmljb24tdnMtZmd7ZmlsbDojZjBlZmYxfS5pY29uLXZzLWFjdGlvbi1vcmFuZ2V7ZmlsbDojYzI3ZDFhfTwvc3R5bGU+PHBhdGggY2xhc3M9Imljb24tY2FudmFzLXRyYW5zcGFyZW50IiBkPSJNMTYgMTZIMFYwaDE2djE2eiIgaWQ9ImNhbnZhcyIvPjxwYXRoIGNsYXNzPSJpY29uLXZzLW91dCIgZD0iTTE0LjQxNCAxTDE2IDIuNTg2djUuODI4TDE0LjQxNCAxMEgxMHYzLjQxNkw4LjQxNCAxNUgxLjU4NkwwIDEzLjQxNnYtNS44M0wxLjU4NiA2SDZWMi41ODZMNy41ODYgMWg2LjgyOHoiIGlkPSJvdXRsaW5lIi8+PHBhdGggY2xhc3M9Imljb24tdnMtZmciIGQ9Ik0yIDEzaDZWOEgydjV6bTEtNGg0djFIM1Y5em0wIDJoNHYxSDN2LTF6bTExLTVWM0g4djNoLjQxNEw5IDYuNTg2VjZoNHYxSDkuNDE0bC41ODYuNTg2VjhoNFY2em0tMS0xSDlWNGg0djF6IiBpZD0iaWNvbkZnIi8+PHBhdGggY2xhc3M9Imljb24tdnMtYWN0aW9uLW9yYW5nZSIgZD0iTTMgMTFoNC4wMDF2MUgzdi0xem0wLTFoNC4wMDFWOUgzdjF6bTYtMnY1bC0xIDFIMmwtMS0xVjhsMS0xaDZsMSAxek04IDhIMnY1aDZWOHptMS0ybDEgMWgzVjZIOXptMC0xaDRWNEg5djF6bTUtM0g4TDcgM3YzaDFWM2g2djVoLTR2MWg0bDEtMVYzbC0xLTF6IiBpZD0iaWNvbkJnIi8+PC9zdmc+\"); }\n.monaco-editor .suggest-widget .monaco-list .monaco-list-row .icon.enum-member { background-image: url(\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNiAxNiI+PHN0eWxlPi5pY29uLWNhbnZhcy10cmFuc3BhcmVudHtvcGFjaXR5OjA7ZmlsbDojZjZmNmY2fS5pY29uLXZzLW91dHtmaWxsOiNmNmY2ZjZ9Lmljb24tdnMtZmd7ZmlsbDojZjBlZmYxfS5pY29uLXZzLWFjdGlvbi1ibHVle2ZpbGw6IzAwNTM5Y308L3N0eWxlPjxwYXRoIGNsYXNzPSJpY29uLWNhbnZhcy10cmFuc3BhcmVudCIgZD0iTTE2IDE2SDBWMGgxNnYxNnoiIGlkPSJjYW52YXMiLz48cGF0aCBjbGFzcz0iaWNvbi12cy1vdXQiIGQ9Ik0wIDE1VjZoNlYyLjU4Nkw3LjU4NSAxaDYuODI5TDE2IDIuNTg2djUuODI5TDE0LjQxNCAxMEgxMHY1SDB6bTMtNnoiIGlkPSJvdXRsaW5lIi8+PHBhdGggY2xhc3M9Imljb24tdnMtZmciIGQ9Ik04IDN2M2g1djFoLTN2MWg0VjNIOHptNSAySDlWNGg0djF6TTIgOHY1aDZWOEgyem01IDNIM3YtMWg0djF6IiBpZD0iaWNvbkZnIi8+PHBhdGggY2xhc3M9Imljb24tdnMtYWN0aW9uLWJsdWUiIGQ9Ik0xMCA2aDN2MWgtM1Y2ek05IDR2MWg0VjRIOXptNS0ySDhMNyAzdjNoMVYzaDZ2NWgtNHYxaDRsMS0xVjNsLTEtMXptLTcgOEgzdjFoNHYtMXptMi0zdjdIMVY3aDh6TTggOEgydjVoNlY4eiIgaWQ9Imljb25CZyIvPjwvc3ZnPg==\"); }\n.monaco-editor .suggest-widget .monaco-list .monaco-list-row .icon.keyword { background-image: url(\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNiAxNiI+PHN0eWxlPi5pY29uLWNhbnZhcy10cmFuc3BhcmVudHtvcGFjaXR5OjA7ZmlsbDojZjZmNmY2fS5pY29uLXZzLW91dHtmaWxsOiNmNmY2ZjZ9Lmljb24tdnMtYmd7ZmlsbDojNDI0MjQyfS5pY29uLXZzLWZne2ZpbGw6I2YwZWZmMX08L3N0eWxlPjxwYXRoIGNsYXNzPSJpY29uLWNhbnZhcy10cmFuc3BhcmVudCIgZD0iTTE2IDE2SDBWMGgxNnYxNnoiIGlkPSJjYW52YXMiLz48cGF0aCBjbGFzcz0iaWNvbi12cy1vdXQiIGQ9Ik0xNiA1VjJIOVYxSDB2MTRoMTN2LTNoM1Y5aC0xVjZIOVY1aDd6bS04IDdWOWgxdjNIOHoiIGlkPSJvdXRsaW5lIi8+PHBhdGggY2xhc3M9Imljb24tdnMtZmciIGQ9Ik0yIDNoNXYxSDJWM3oiIGlkPSJpY29uRmciLz48cGF0aCBjbGFzcz0iaWNvbi12cy1iZyIgZD0iTTE1IDRoLTVWM2g1djF6bS0xIDNoLTJ2MWgyVjd6bS00IDBIMXYxaDlWN3ptMiA2SDF2MWgxMXYtMXptLTUtM0gxdjFoNnYtMXptOCAwaC01djFoNXYtMXpNOCAydjNIMVYyaDd6TTcgM0gydjFoNVYzeiIgaWQ9Imljb25CZyIvPjwvc3ZnPg==\"); }\n.monaco-editor .suggest-widget .monaco-list .monaco-list-row .icon.text { background-image: url(\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNiAxNiI+PHN0eWxlPi5pY29uLWNhbnZhcy10cmFuc3BhcmVudHtvcGFjaXR5OjA7ZmlsbDojZjZmNmY2fS5pY29uLXZzLW91dHtmaWxsOiNmNmY2ZjZ9Lmljb24tdnMtYmd7ZmlsbDojNDI0MjQyfS5pY29uLXZzLWZne2ZpbGw6I2YwZWZmMX08L3N0eWxlPjxwYXRoIGNsYXNzPSJpY29uLWNhbnZhcy10cmFuc3BhcmVudCIgZD0iTTE2IDE2SDBWMGgxNnYxNnoiIGlkPSJjYW52YXMiLz48cGF0aCBjbGFzcz0iaWNvbi12cy1vdXQiIGQ9Ik0xNiAxNUgwVjFoMTZ2MTR6IiBpZD0ib3V0bGluZSIvPjxwYXRoIGNsYXNzPSJpY29uLXZzLWZnIiBkPSJNOS4yMjkgNy4zNTRjLjAzNS4xNDYuMDUyLjMxLjA1Mi40OTQgMCAuMjM0LS4wMi40NDEtLjA2LjYyMS0uMDM5LjE4LS4wOTUuMzI4LS4xNjguNDQ1YS42ODcuNjg3IDAgMCAxLS45MTQuMjgxLjc2Ljc2IDAgMCAxLS4yMzctLjIwNy45ODguOTg4IDAgMCAxLS4xNTQtLjMwNiAxLjI2MiAxLjI2MiAwIDAgMS0uMDU3LS4zODF2LS41MDZjMC0uMTcuMDItLjMyNi4wNjEtLjQ2NXMuMDk2LS4yNTguMTY4LS4zNTlhLjc1Ni43NTYgMCAwIDEgLjI1Ny0uMjMyYy4xLS4wNTUuMjEtLjA4Mi4zMzEtLjA4MmEuNjQ2LjY0NiAwIDAgMSAuNTcxLjMyYy4wNjcuMTA1LjExNi4yMy4xNS4zNzd6bS01LjEyNi44NjlhLjU1Ny41NTcgMCAwIDAtLjE5Ni4xMzJjLS4wNDcuMDUzLS4wOC4xMTItLjA5Ny4xOHMtLjAyOC4xNDctLjAyOC4yMzNhLjUxMy41MTMgMCAwIDAgLjE1Ny4zOS41MjguNTI4IDAgMCAwIC4xODYuMTEzLjY4Mi42ODIgMCAwIDAgLjI0Mi4wNDEuNzYuNzYgMCAwIDAgLjU5My0uMjcxLjg5Ny44OTcgMCAwIDAgLjE2NS0uMjk1Yy4wMzgtLjExMy4wNTktLjIzNC4wNTktLjM2NXYtLjM0NmwtLjc2MS4xMWExLjI5IDEuMjkgMCAwIDAtLjMyLjA3OHpNMTQgM3YxMEgyVjNoMTJ6TTUuOTYyIDcuNDY5YzAtLjIzOC0uMDI3LS40NTEtLjA4My0uNjM3YTEuMjg2IDEuMjg2IDAgMCAwLS4yNDktLjQ3MSAxLjA4IDEuMDggMCAwIDAtLjQyNC0uMjk1IDEuNjQ0IDEuNjQ0IDAgMCAwLS42MDgtLjEwMWMtLjExOSAwLS4yNDEuMDEyLS4zNjguMDMzYTMuMjEzIDMuMjEzIDAgMCAwLS42NzMuMTk1IDEuMzEzIDEuMzEzIDAgMCAwLS4yMTIuMTE0di43NjhjLjE1OC0uMTMyLjM0MS0uMjM1LjU0NC0uMzEzLjIwNC0uMDc4LjQxMy0uMTE3LjYyNy0uMTE3LjIxMyAwIC4zNzcuMDYzLjQ5NC4xODYuMTE2LjEyNS4xNzQuMzI0LjE3NC42bC0xLjAzLjE1NGMtLjIwNS4wMjYtLjM4LjA3Ny0uNTI2LjE1MWExLjA4MyAxLjA4MyAwIDAgMC0uNTYzLjY2QTEuNTYyIDEuNTYyIDAgMCAwIDMgOC44NTdjMCAuMTcuMDI1LjMyMy4wNzQuNDYzYS45NDUuOTQ1IDAgMCAwIC41NjguNTk2Yy4xMzkuMDU3LjI5Ny4wODQuNDc4LjA4NC4yMjkgMCAuNDMxLS4wNTMuNjA0LS4xNmExLjMgMS4zIDAgMCAwIC40MzktLjQ2M2guMDE0di41MjloLjc4NVY3LjQ2OXpNMTAgNy44NjFhMy41NCAzLjU0IDAgMCAwLS4wNzQtLjczNCAyLjA0NyAyLjA0NyAwIDAgMC0uMjI4LS42MTEgMS4yMDMgMS4yMDMgMCAwIDAtLjM5NC0uNDE2IDEuMDMgMS4wMyAwIDAgMC0uNTc0LS4xNTNjLS4xMjMgMC0uMjM0LjAxOC0uMzM2LjA1MWExIDEgMCAwIDAtLjI3OC4xNDcgMS4xNTMgMS4xNTMgMCAwIDAtLjIyNS4yMjIgMi4wMjIgMi4wMjIgMCAwIDAtLjE4MS4yODloLS4wMTNWNUg3djQuODg3aC42OTd2LS40ODVoLjAxM2MuMDQ0LjA4Mi4wOTUuMTU4LjE1MS4yMjkuMDU3LjA3LjExOS4xMzMuMTkxLjE4NmEuODM1LjgzNSAwIDAgMCAuMjM4LjEyMS45NDMuOTQzIDAgMCAwIC4yOTMuMDQyYy4yMyAwIC40MzQtLjA1My42MDktLjE2YTEuMzQgMS4zNCAwIDAgMCAuNDQzLS40NDNjLjEyLS4xODguMjExLS40MTIuMjcyLS42NzJBMy42MiAzLjYyIDAgMCAwIDEwIDcuODYxem0zLTEuNjU4YS43LjcgMCAwIDAtLjEwNi0uMDY2IDEuMTgzIDEuMTgzIDAgMCAwLS4xNDItLjA2MyAxLjIzMyAxLjIzMyAwIDAgMC0uMzYzLS4wNjVjLS4yMDkgMC0uMzk5LjA1MS0uNTY5LjE1YTEuMzU1IDEuMzU1IDAgMCAwLS40MzMuNDI0Yy0uMTE4LjE4Mi0uMjEuNDAyLS4yNzMuNjZhMy42MyAzLjYzIDAgMCAwLS4wMDggMS42MTVjLjA2LjIzLjE0My40My4yNTIuNjAyLjEwOS4xNjguMjQxLjMwMy4zOTYuMzk2YS45NzIuOTcyIDAgMCAwIC41MjQuMTQ0Yy4xNTggMCAuMjk2LS4wMjEuNDEzLS4wNjguMTE3LS4wNDUuMjE5LS4xMDguMzA5LS4xODR2LS43N2ExLjA5NCAxLjA5NCAwIDAgMS0uMjg4LjIyNS44MTkuODE5IDAgMCAxLS4xNTguMDY4LjQ4LjQ4IDAgMCAxLS4xNTMuMDI3LjYyLjYyIDAgMCAxLS4yNzQtLjA3NGMtLjI0MS0uMTM2LS40MjMtLjQ3OS0uNDIzLTEuMTQ2IDAtLjcxNS4yMDYtMS4xMi40NjktMS4zMDEuMDc3LS4wMzIuMTUzLS4wNjQuMjM4LS4wNjQuMTEzIDAgLjIyLjAyNy4zMTcuMDgyLjA5Ni4wNTcuMTg4LjEzMS4yNzIuMjIzdi0uODE1eiIgaWQ9Imljb25GZyIvPjxwYXRoIGNsYXNzPSJpY29uLXZzLWJnIiBkPSJNMSAydjEyaDE0VjJIMXptMTMgMTFIMlYzaDEydjEwek01LjYzIDYuMzYxYTEuMDggMS4wOCAwIDAgMC0uNDI0LS4yOTUgMS42NDQgMS42NDQgMCAwIDAtLjYwOC0uMTAxYy0uMTE5IDAtLjI0MS4wMTItLjM2OC4wMzNhMy4yMTMgMy4yMTMgMCAwIDAtLjY3My4xOTUgMS4zMTMgMS4zMTMgMCAwIDAtLjIxMi4xMTR2Ljc2OGMuMTU4LS4xMzIuMzQxLS4yMzUuNTQ0LS4zMTMuMjA0LS4wNzguNDEzLS4xMTcuNjI3LS4xMTcuMjEzIDAgLjM3Ny4wNjMuNDk0LjE4Ni4xMTYuMTI1LjE3NC4zMjQuMTc0LjZsLTEuMDMuMTU0Yy0uMjA1LjAyNi0uMzguMDc3LS41MjYuMTUxYTEuMDgzIDEuMDgzIDAgMCAwLS41NjMuNjZBMS41NjIgMS41NjIgMCAwIDAgMyA4Ljg1N2MwIC4xNy4wMjUuMzIzLjA3NC40NjNhLjk0NS45NDUgMCAwIDAgLjU2OC41OTZjLjEzOS4wNTcuMjk3LjA4NC40NzguMDg0LjIyOSAwIC40MzEtLjA1My42MDQtLjE2YTEuMyAxLjMgMCAwIDAgLjQzOS0uNDYzaC4wMTR2LjUyOWguNzg1VjcuNDY5YzAtLjIzOC0uMDI3LS40NTEtLjA4My0uNjM3YTEuMjg2IDEuMjg2IDAgMCAwLS4yNDktLjQ3MXptLS40NDYgMi4wMmMwIC4xMzEtLjAyLjI1Mi0uMDU5LjM2NWEuODk3Ljg5NyAwIDAgMS0uMTY1LjI5NS43NTguNzU4IDAgMCAxLS41OTMuMjcyLjY4Mi42ODIgMCAwIDEtLjI0Mi0uMDQxLjUwNy41MDcgMCAwIDEtLjMwMi0uMjg2LjU4My41ODMgMCAwIDEtLjA0MS0uMjE4YzAtLjA4Ni4wMS0uMTY0LjAyNy0uMjMycy4wNTEtLjEyNy4wOTgtLjE4YS41NDYuNTQ2IDAgMCAxIC4xOTYtLjEzM2MuMDgzLS4wMzMuMTg5LS4wNjEuMzItLjA3OGwuNzYxLS4xMDl2LjM0NXptNC41MTQtMS44NjVhMS4yMDMgMS4yMDMgMCAwIDAtLjM5NC0uNDE2IDEuMDMgMS4wMyAwIDAgMC0uNTc0LS4xNTNjLS4xMjMgMC0uMjM0LjAxOC0uMzM2LjA1MWExIDEgMCAwIDAtLjI3OC4xNDcgMS4xNTMgMS4xNTMgMCAwIDAtLjIyNS4yMjIgMi4wMjIgMi4wMjIgMCAwIDAtLjE4MS4yODloLS4wMTNWNUg3djQuODg3aC42OTd2LS40ODVoLjAxM2MuMDQ0LjA4Mi4wOTUuMTU4LjE1MS4yMjkuMDU3LjA3LjExOS4xMzMuMTkxLjE4NmEuODM1LjgzNSAwIDAgMCAuMjM4LjEyMS45NDMuOTQzIDAgMCAwIC4yOTMuMDQyYy4yMyAwIC40MzQtLjA1My42MDktLjE2YTEuMzQgMS4zNCAwIDAgMCAuNDQzLS40NDNjLjEyLS4xODguMjExLS40MTIuMjcyLS42NzJBMy42MiAzLjYyIDAgMCAwIDEwIDcuODYxYTMuNTQgMy41NCAwIDAgMC0uMDc0LS43MzQgMi4wNDcgMi4wNDcgMCAwIDAtLjIyOC0uNjExem0tLjQ3NiAxLjk1M2MtLjAzOS4xOC0uMDk1LjMyOC0uMTY4LjQ0NWEuNzU1Ljc1NSAwIDAgMS0uMjY0LjI2Ni42ODcuNjg3IDAgMCAxLS42NTEuMDE1Ljc2Ljc2IDAgMCAxLS4yMzctLjIwNy45ODguOTg4IDAgMCAxLS4xNTQtLjMwNiAxLjI2MiAxLjI2MiAwIDAgMS0uMDU3LS4zODF2LS41MDZjMC0uMTcuMDItLjMyNi4wNjEtLjQ2NXMuMDk2LS4yNTguMTY4LS4zNTlhLjc1Ni43NTYgMCAwIDEgLjI1Ny0uMjMyYy4xLS4wNTUuMjEtLjA4Mi4zMzEtLjA4MmEuNjQ2LjY0NiAwIDAgMSAuNTcxLjMyYy4wNjYuMTA1LjExNi4yMy4xNS4zNzcuMDM1LjE0Ni4wNTIuMzEuMDUyLjQ5NCAwIC4yMzQtLjAxOS40NDEtLjA1OS42MjF6bTMuNjcyLTIuMzMyYS43LjcgMCAwIDEgLjEwNi4wNjZ2LjgxNGExLjE3OCAxLjE3OCAwIDAgMC0uMjczLS4yMjMuNjQ1LjY0NSAwIDAgMC0uMzE3LS4wODFjLS4wODUgMC0uMTYxLjAzMi0uMjM4LjA2NC0uMjYzLjE4MS0uNDY5LjU4Ni0uNDY5IDEuMzAxIDAgLjY2OC4xODIgMS4wMTEuNDIzIDEuMTQ2LjA4NC4wNC4xNzEuMDc0LjI3NC4wNzQuMDQ5IDAgLjEwMS0uMDEuMTUzLS4wMjdhLjg1Ni44NTYgMCAwIDAgLjE1OC0uMDY4IDEuMTYgMS4xNiAwIDAgMCAuMjg4LS4yMjV2Ljc3Yy0uMDkuMDc2LS4xOTIuMTM5LS4zMDkuMTg0YTEuMDk4IDEuMDk4IDAgMCAxLS40MTIuMDY4Ljk3NC45NzQgMCAwIDEtLjUyMy0uMTQzIDEuMjU3IDEuMjU3IDAgMCAxLS4zOTYtLjM5NiAyLjA5OCAyLjA5OCAwIDAgMS0uMjUyLS42MDIgMy4xMTggMy4xMTggMCAwIDEtLjA4OC0uNzU0YzAtLjMxNi4wMzItLjYwNC4wOTYtLjg2MS4wNjMtLjI1OC4xNTUtLjQ3OS4yNzMtLjY2LjExOS0uMTgyLjI2NS0uMzIyLjQzMy0uNDI0YTEuMTAyIDEuMTAyIDAgMCAxIDEuMDczLS4wMjN6IiBpZD0iaWNvbkJnIi8+PC9zdmc+\"); }\n.monaco-editor .suggest-widget .monaco-list .monaco-list-row .icon.color { background-image: url(\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNiAxNiI+PHN0eWxlPi5pY29uLWNhbnZhcy10cmFuc3BhcmVudHtvcGFjaXR5OjA7ZmlsbDojZjZmNmY2fS5pY29uLXZzLW91dHtmaWxsOiNmNmY2ZjZ9Lmljb24tdnMtYmd7ZmlsbDojNDI0MjQyfS5pY29uLXZzLXJlZHtmaWxsOiNlNTE0MDB9Lmljb24tdnMteWVsbG93e2ZpbGw6I2ZmY2MwMH0uaWNvbi12cy1ncmVlbntmaWxsOiMzMzk5MzN9Lmljb24tdnMtYmx1ZXtmaWxsOiMxYmExZTJ9Lmljb24tdnMtYWN0aW9uLXB1cnBsZXtmaWxsOiM2NTJkOTB9Lmljb24td2hpdGV7ZmlsbDojZmZmZmZmfTwvc3R5bGU+PHBhdGggY2xhc3M9Imljb24tY2FudmFzLXRyYW5zcGFyZW50IiBkPSJNMTYgMTZIMFYwaDE2djE2eiIgaWQ9ImNhbnZhcyIvPjxwYXRoIGNsYXNzPSJpY29uLXZzLW91dCIgZD0iTTE2IDhjMCA0LjQxMS0zLjU4OSA4LTggOGEyLjgwMyAyLjgwMyAwIDAgMS0yLjgtMi44YzAtLjgzMy4yNzItMS42MjkuNzY2LTIuMjQxYS41OTYuNTk2IDAgMCAwIC4xMDEtLjM1OS42NjcuNjY3IDAgMCAwLS42NjctLjY2Ni41OC41OCAwIDAgMC0uMzU4LjEwMkEzLjU4NCAzLjU4NCAwIDAgMSAyLjggMTAuOCAyLjgwMyAyLjgwMyAwIDAgMSAwIDhjMC00LjQxMSAzLjU4OS04IDgtOHM4IDMuNTg5IDggOHoiIGlkPSJvdXRsaW5lIi8+PHBhdGggY2xhc3M9Imljb24td2hpdGUiIGQ9Ik01LjQgNy45MzNhMi42NyAyLjY3IDAgMCAxIDIuNjY3IDIuNjY2YzAgLjYwNi0uMTkzIDEuMTc5LS41NDQgMS42MTRhMS41OTkgMS41OTkgMCAwIDAtLjMyMy45ODcuOC44IDAgMCAwIC44LjhjMy4zMDkgMCA2LTIuNjkxIDYtNnMtMi42OTEtNi02LTYtNiAyLjY5MS02IDZjMCAuNDQxLjM1OS44LjguOC4zNzggMCAuNzI5LS4xMTQuOTg2LS4zMjJBMi41NjggMi41NjggMCAwIDEgNS40IDcuOTMzeiIgaWQ9Imljb25GZyIvPjxnIGlkPSJpY29uQmciPjxwYXRoIGNsYXNzPSJpY29uLXZzLWJnIiBkPSJNOCAxNWMtLjk5MiAwLTEuOC0uODA4LTEuOC0xLjggMC0uNjA2LjE5My0xLjE3OS41NDQtMS42MTMuMjA4LS4yNTkuMzIzLS42MDkuMzIzLS45ODcgMC0uOTE5LS43NDgtMS42NjYtMS42NjctMS42NjYtLjM3NyAwLS43MjguMTE1LS45ODYuMzIzQTIuNTggMi41OCAwIDAgMSAyLjggOS44QzEuODA4IDkuOCAxIDguOTkyIDEgOGMwLTMuODYgMy4xNC03IDctNyAzLjg1OSAwIDcgMy4xNCA3IDcgMCAzLjg1OS0zLjE0MSA3LTcgN3pNNS40IDcuOTMzYTIuNjcgMi42NyAwIDAgMSAyLjY2NyAyLjY2NmMwIC42MDYtLjE5MyAxLjE3OS0uNTQ0IDEuNjE0YTEuNTk5IDEuNTk5IDAgMCAwLS4zMjMuOTg3LjguOCAwIDAgMCAuOC44YzMuMzA5IDAgNi0yLjY5MSA2LTZzLTIuNjkxLTYtNi02LTYgMi42OTEtNiA2YzAgLjQ0MS4zNTkuOC44LjguMzc4IDAgLjcyOS0uMTE0Ljk4Ni0uMzIyQTIuNTY4IDIuNTY4IDAgMCAxIDUuNCA3LjkzM3oiLz48cGF0aCBjbGFzcz0iaWNvbi12cy1hY3Rpb24tcHVycGxlIiBkPSJNNC41IDUuMzc1YS44NzUuODc1IDAgMSAwIDAgMS43NS44NzUuODc1IDAgMCAwIDAtMS43NXoiLz48cGF0aCBjbGFzcz0iaWNvbi12cy1ibHVlIiBkPSJNNy4xMjUgMy42MjVhLjg3NS44NzUgMCAxIDAgMCAxLjc1Ljg3NS44NzUgMCAwIDAgMC0xLjc1eiIvPjxwYXRoIGNsYXNzPSJpY29uLXZzLWdyZWVuIiBkPSJNMTAuNjI1IDQuNWEuODc1Ljg3NSAwIDEgMCAwIDEuNzUuODc1Ljg3NSAwIDAgMCAwLTEuNzV6Ii8+PHBhdGggY2xhc3M9Imljb24tdnMteWVsbG93IiBkPSJNMTEuNSA4YS44NzUuODc1IDAgMSAwIDAgMS43NS44NzUuODc1IDAgMCAwIDAtMS43NXoiLz48cGF0aCBjbGFzcz0iaWNvbi12cy1yZWQiIGQ9Ik05Ljc1IDEwLjYyNWEuODc1Ljg3NSAwIDEgMCAwIDEuNzUuODc1Ljg3NSAwIDAgMCAwLTEuNzV6Ii8+PC9nPjwvc3ZnPg==\"); }\n.monaco-editor .suggest-widget .monaco-list .monaco-list-row .icon.file { background-image: url(\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNiAxNiI+PHN0eWxlPi5pY29uLWNhbnZhcy10cmFuc3BhcmVudHtvcGFjaXR5OjA7ZmlsbDojZjZmNmY2fS5pY29uLXZzLW91dHtmaWxsOiNmNmY2ZjZ9Lmljb24tdnMtYmd7ZmlsbDojNDI0MjQyfS5pY29uLXZzLWZne2ZpbGw6I2YwZWZmMX08L3N0eWxlPjxwYXRoIGNsYXNzPSJpY29uLWNhbnZhcy10cmFuc3BhcmVudCIgZD0iTTE2IDE2SDBWMGgxNnYxNnoiIGlkPSJjYW52YXMiLz48cGF0aCBjbGFzcz0iaWNvbi12cy1vdXQiIGQ9Ik0xNSAxNkgyVjBoOC42MjFMMTUgNC4zNzlWMTZ6IiBpZD0ib3V0bGluZSIvPjxwYXRoIGNsYXNzPSJpY29uLXZzLWZnIiBkPSJNMTMgMTRINFYyaDV2NGg0djh6bS0zLTlWMi4yMDdMMTIuNzkzIDVIMTB6IiBpZD0iaWNvbkZnIi8+PHBhdGggY2xhc3M9Imljb24tdnMtYmciIGQ9Ik0zIDF2MTRoMTFWNC43OTNMMTAuMjA3IDFIM3ptMTAgMTNINFYyaDV2NGg0djh6bS0zLTlWMi4yMDdMMTIuNzkzIDVIMTB6IiBpZD0iaWNvbkJnIi8+PC9zdmc+\"); }\n.monaco-editor .suggest-widget .monaco-list .monaco-list-row .icon.reference { background-image: url(\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNiAxNiI+PHN0eWxlPi5pY29uLWNhbnZhcy10cmFuc3BhcmVudHtvcGFjaXR5OjA7ZmlsbDojZjZmNmY2fS5pY29uLXZzLW91dHtmaWxsOiNmNmY2ZjZ9Lmljb24tdnMtYmd7ZmlsbDojNDI0MjQyfS5pY29uLXZzLWZne2ZpbGw6I2YwZWZmMX0uaWNvbi12cy1hY3Rpb24tYmx1ZXtmaWxsOiMwMDUzOWN9PC9zdHlsZT48cGF0aCBjbGFzcz0iaWNvbi1jYW52YXMtdHJhbnNwYXJlbnQiIGQ9Ik0xNiAxNkgwVjBoMTZ2MTZ6IiBpZD0iY2FudmFzIi8+PHBhdGggY2xhc3M9Imljb24tdnMtb3V0IiBkPSJNMTQgNC41NTZWMTNjMCAuOTctLjcwMSAyLTIgMkg0Yy0uOTcgMC0yLS43MDEtMi0yVjYuNjQ5QTMuNDk1IDMuNDk1IDAgMCAxIDAgMy41QzAgMS41NyAxLjU3IDAgMy41IDBINXYxaDUuMDYxTDE0IDQuNTU2eiIgaWQ9Im91dGxpbmUiIHN0eWxlPSJkaXNwbGF5OiBub25lOyIvPjxwYXRoIGNsYXNzPSJpY29uLXZzLWJnIiBkPSJNMTMgNXY4cy0uMDM1IDEtMS4wMzUgMWgtOFMzIDE0IDMgMTNWOWgxdjRoOFY2SDkuMzk3bC41MTctLjUyTDkgNC41NzJWM0g3LjQxOUw2LjQxMyAyaDMuMjI4TDEzIDV6IiBpZD0iaWNvbkJnIi8+PHBhdGggY2xhc3M9Imljb24tdnMtZmciIGQ9Ik03LjQxOSAzSDl2MS41NzJMNy40MTkgM3ptMS45NzggM0w2LjQxNiA5SDR2NGg4VjZIOS4zOTd6IiBpZD0iaWNvbkZnIiBzdHlsZT0iZGlzcGxheTogbm9uZTsiLz48cGF0aCBjbGFzcz0iaWNvbi12cy1hY3Rpb24tYmx1ZSIgZD0iTTUuOTg4IDZIMy41YTIuNSAyLjUgMCAxIDEgMC01SDR2MWgtLjVDMi42NzMgMiAyIDIuNjczIDIgMy41UzIuNjczIDUgMy41IDVoMi41MTNMNCAzaDJsMi41IDIuNDg0TDYgOEg0bDEuOTg4LTJ6IiBpZD0iY29sb3JBY3Rpb24iLz48L3N2Zz4=\"); }\n.monaco-editor .suggest-widget .monaco-list .monaco-list-row .icon.snippet { background-image: url(\"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjxzdmcKICAgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIgogICB4bWxuczpjYz0iaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbnMjIgogICB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiCiAgIHhtbG5zOnN2Zz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIKICAgdmVyc2lvbj0iMS4xIgogICBpZD0ic3ZnNDY5NCIKICAgdmlld0JveD0iMCAwIDE2IDE2Ij4KICA8bWV0YWRhdGEKICAgICBpZD0ibWV0YWRhdGE0NzA1Ij4KICAgIDxyZGY6UkRGPgogICAgICA8Y2M6V29yawogICAgICAgICByZGY6YWJvdXQ9IiI+CiAgICAgICAgPGRjOmZvcm1hdD5pbWFnZS9zdmcreG1sPC9kYzpmb3JtYXQ+CiAgICAgICAgPGRjOnR5cGUKICAgICAgICAgICByZGY6cmVzb3VyY2U9Imh0dHA6Ly9wdXJsLm9yZy9kYy9kY21pdHlwZS9TdGlsbEltYWdlIiAvPgogICAgICAgIDxkYzp0aXRsZT48L2RjOnRpdGxlPgogICAgICA8L2NjOldvcms+CiAgICA8L3JkZjpSREY+CiAgPC9tZXRhZGF0YT4KICA8ZGVmcwogICAgIGlkPSJkZWZzNDcwMyIgLz4KICA8c3R5bGUKICAgICBpZD0ic3R5bGU0Njk2Ij4uaWNvbi1jYW52YXMtdHJhbnNwYXJlbnR7b3BhY2l0eTowO2ZpbGw6I2Y2ZjZmNn0uaWNvbi12cy1vdXR7ZmlsbDojZjZmNmY2fS5pY29uLXZzLWFjdGlvbi1vcmFuZ2V7ZmlsbDojYzI3ZDFhfTwvc3R5bGU+CiAgPGcKICAgICBpZD0iZzQ3MDciCiAgICAgdHJhbnNmb3JtPSJtYXRyaXgoMS4zMzMzMzMzLDAsMCwxLjMzMzMzMzMsLTI0NS45OTk5OSwtNS4zMzMzMzMpIj4KICAgIDxwYXRoCiAgICAgICBkPSJtIDE4NSw0IDExLDAgMCwxMiAtMTEsMCB6IgogICAgICAgaWQ9InBhdGg0NTM0IgogICAgICAgc3R5bGU9ImZpbGw6I2Y2ZjZmNiIgLz4KICAgIDxwYXRoCiAgICAgICBkPSJtIDE5NCwxMyAwLC03IC03LDAgMCw3IC0xLDAgMCwtOCA5LDAgMCw4IC0xLDAgeiBtIC03LDIgLTEsMCAwLC0xIDEsMCAwLDEgeiBtIDIsLTEgLTEsMCAwLDEgMSwwIDAsLTEgeiBtIDIsMCAtMSwwIDAsMSAxLDAgMCwtMSB6IG0gMiwxIC0xLDAgMCwtMSAxLDAgMCwxIHogbSAyLC0xIC0xLDAgMCwxIDEsMCAwLC0xIHoiCiAgICAgICBpZD0icGF0aDQ1MzYiCiAgICAgICBzdHlsZT0iZmlsbDojNDI0MjQyIiAvPgogICAgPHBhdGgKICAgICAgIGQ9Im0gMTg3LDEzIDAsLTcgNywwIDAsNyAtNywwIHoiCiAgICAgICBpZD0icGF0aDQ1MzgiCiAgICAgICBzdHlsZT0iZmlsbDojZjBlZmYxIiAvPgogIDwvZz4KICA8cGF0aAogICAgIGlkPSJjYW52YXMiCiAgICAgZD0iTTE2IDE2SDBWMGgxNnYxNnoiCiAgICAgY2xhc3M9Imljb24tY2FudmFzLXRyYW5zcGFyZW50IiAvPgo8L3N2Zz4K\"); }\n.monaco-editor .suggest-widget .monaco-list .monaco-list-row .icon.customcolor { background-image: none; }\n.monaco-editor .suggest-widget .monaco-list .monaco-list-row .icon.folder { background-image: url(\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgaGVpZ2h0PSIxNiI+PHN0eWxlIHR5cGU9InRleHQvY3NzIj4uaWNvbi1jYW52YXMtdHJhbnNwYXJlbnR7b3BhY2l0eTowO2ZpbGw6I0Y2RjZGNjt9IC5pY29uLXZzLW91dHtvcGFjaXR5OjA7ZmlsbDojRjZGNkY2O30gLmljb24tdnMtZmd7ZmlsbDojRjBFRkYxO30gLmljb24tZm9sZGVye2ZpbGw6IzY1NjU2NTt9PC9zdHlsZT48cGF0aCBjbGFzcz0iaWNvbi1jYW52YXMtdHJhbnNwYXJlbnQiIGQ9Ik0xNiAxNmgtMTZ2LTE2aDE2djE2eiIgaWQ9ImNhbnZhcyIvPjxwYXRoIGNsYXNzPSJpY29uLXZzLW91dCIgZD0iTTE2IDIuNXYxMGMwIC44MjctLjY3MyAxLjUtMS41IDEuNWgtMTEuOTk2Yy0uODI3IDAtMS41LS42NzMtMS41LTEuNXYtOGMwLS44MjcuNjczLTEuNSAxLjUtMS41aDIuODg2bDEtMmg4LjExYy44MjcgMCAxLjUuNjczIDEuNSAxLjV6IiBpZD0ib3V0bGluZSIvPjxwYXRoIGNsYXNzPSJpY29uLWZvbGRlciIgZD0iTTE0LjUgMmgtNy40OTJsLTEgMmgtMy41MDRjLS4yNzcgMC0uNS4yMjQtLjUuNXY4YzAgLjI3Ni4yMjMuNS41LjVoMTEuOTk2Yy4yNzUgMCAuNS0uMjI0LjUtLjV2LTEwYzAtLjI3Ni0uMjI1LS41LS41LS41em0tLjQ5NiAyaC02LjQ5NmwuNS0xaDUuOTk2djF6IiBpZD0iaWNvbkJnIi8+PHBhdGggY2xhc3M9Imljb24tdnMtZmciIGQ9Ik0xNCAzdjFoLTYuNWwuNS0xaDZ6IiBpZD0iaWNvbkZnIi8+PC9zdmc+\"); }\n\n.monaco-editor .suggest-widget .monaco-list .monaco-list-row .icon.customcolor .colorspan {\n\tmargin: 0 0 0 0.3em;\n\tborder: 0.1em solid #000;\n\twidth: 0.7em;\n\theight: 0.7em;\n\tdisplay: inline-block;\n}\n\n/** Styles for the docs of the completion item in focus **/\n.monaco-editor .suggest-widget .details {\n\tdisplay: flex;\n\tflex-direction: column;\n\tcursor: default;\n}\n\n.monaco-editor .suggest-widget .details.no-docs {\n\tdisplay: none;\n}\n\n.monaco-editor .suggest-widget.docs-below .details {\n\tborder-top-width: 0px;\n}\n\n.monaco-editor .suggest-widget .details > .monaco-scrollable-element {\n\tflex: 1;\n}\n\n.monaco-editor .suggest-widget .details > .monaco-scrollable-element > .body {\n\tposition: absolute;\n\tbox-sizing: border-box;\n\theight: 100%;\n\twidth: 100%;\n}\n\n.monaco-editor .suggest-widget .details > .monaco-scrollable-element > .body > .header > .type {\n\tflex: 2;\n\toverflow: hidden;\n\ttext-overflow: ellipsis;\n\topacity: 0.7;\n\tword-break: break-all;\n\tmargin: 0;\n\tpadding: 4px 0 4px 5px;\n}\n\n.monaco-editor .suggest-widget .details > .monaco-scrollable-element > .body > .docs {\n\tmargin: 0;\n\tpadding: 4px 5px;\n\twhite-space: pre-wrap;\n}\n\n.monaco-editor .suggest-widget .details > .monaco-scrollable-element > .body > .docs.markdown-docs {\n\twhite-space: initial;\n}\n\n.monaco-editor .suggest-widget .details > .monaco-scrollable-element > .body > .docs .code {\n\twhite-space: pre-wrap;\n\tword-wrap: break-word;\n}\n\n.monaco-editor .suggest-widget .details > .monaco-scrollable-element > .body > p:empty {\n\tdisplay: none;\n}\n\n.monaco-editor .suggest-widget .details code {\n\tborder-radius: 3px;\n\tpadding: 0 0.4em;\n}\n\n/* High Contrast and Dark Theming */\n\n.monaco-editor.vs-dark .suggest-widget .details > .monaco-scrollable-element > .body > .header > .close,\n.monaco-editor.hc-black .suggest-widget .details > .monaco-scrollable-element > .body > .header > .close {\n\tbackground-image: url(\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgaGVpZ2h0PSIxNiIgdmlld0JveD0iMyAzIDE2IDE2IiBlbmFibGUtYmFja2dyb3VuZD0ibmV3IDMgMyAxNiAxNiI+PHBvbHlnb24gZmlsbD0iI2U4ZThlOCIgcG9pbnRzPSIxMi41OTcsMTEuMDQyIDE1LjQsMTMuODQ1IDEzLjg0NCwxNS40IDExLjA0MiwxMi41OTggOC4yMzksMTUuNCA2LjY4MywxMy44NDUgOS40ODUsMTEuMDQyIDYuNjgzLDguMjM5IDguMjM4LDYuNjgzIDExLjA0Miw5LjQ4NiAxMy44NDUsNi42ODMgMTUuNCw4LjIzOSIvPjwvc3ZnPg==\");\n}\n\n.monaco-editor.vs-dark .suggest-widget .monaco-list .monaco-list-row .icon,\n.monaco-editor.hc-black .suggest-widget .monaco-list .monaco-list-row .icon { background-image: url(\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNiAxNiI+PHN0eWxlPi5pY29uLWNhbnZhcy10cmFuc3BhcmVudHtvcGFjaXR5OjA7ZmlsbDojMmQyZDMwfS5pY29uLXZzLW91dHtmaWxsOiMyZDJkMzB9Lmljb24tdnMtYmd7ZmlsbDojYzVjNWM1fTwvc3R5bGU+PHBhdGggY2xhc3M9Imljb24tY2FudmFzLXRyYW5zcGFyZW50IiBkPSJNMTYgMTZIMFYwaDE2djE2eiIgaWQ9ImNhbnZhcyIvPjxwYXRoIGNsYXNzPSJpY29uLXZzLW91dCIgZD0iTTE2IDEwYzAgMi4yMDUtMS43OTQgNC00IDQtMS44NTggMC0zLjQxMS0xLjI3OS0zLjg1OC0zaC0uOTc4bDIuMzE4IDRIMHYtMS43MDNsMi0zLjQwOFYwaDExdjYuMTQyYzEuNzIxLjQ0NyAzIDIgMyAzLjg1OHoiIGlkPSJvdXRsaW5lIi8+PHBhdGggY2xhc3M9Imljb24tdnMtYmciIGQ9Ik0xMiAxdjQuNzVBNC4yNTUgNC4yNTUgMCAwIDAgNy43NSAxMGgtLjczMkw0LjI3NSA1LjI2OSAzIDcuNDQyVjFoOXpNNy43NDcgMTRMNC4yNjkgOCAuNzQ4IDE0aDYuOTk5ek0xNSAxMGEzIDMgMCAxIDEtNiAwIDMgMyAwIDAgMSA2IDB6IiBpZD0iaWNvbkJnIi8+PC9zdmc+\"); }\n\n.monaco-editor.vs-dark .suggest-widget .monaco-list .monaco-list-row .icon.method,\n.monaco-editor.hc-black .suggest-widget .monaco-list .monaco-list-row .icon.method,\n.monaco-editor.vs-dark .suggest-widget .monaco-list .monaco-list-row .icon.function,\n.monaco-editor.hc-black .suggest-widget .monaco-list .monaco-list-row .icon.function,\n.monaco-editor.vs-dark .suggest-widget .monaco-list .monaco-list-row .icon.constructor,\n.monaco-editor.hc-black .suggest-widget .monaco-list .monaco-list-row .icon.constructor { background-image: url(\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNiAxNiI+PHN0eWxlPi5pY29uLWNhbnZhcy10cmFuc3BhcmVudHtvcGFjaXR5OjA7ZmlsbDojMmQyZDMwfS5pY29uLXZzLW91dHtmaWxsOiMyZDJkMzB9Lmljb24tdnMtZmd7ZmlsbDojMmIyODJlfS5pY29uLXZzLWFjdGlvbi1wdXJwbGV7ZmlsbDojYjE4MGQ3fTwvc3R5bGU+PHBhdGggY2xhc3M9Imljb24tY2FudmFzLXRyYW5zcGFyZW50IiBkPSJNMTYgMTZIMFYwaDE2djE2eiIgaWQ9ImNhbnZhcyIvPjxwYXRoIGNsYXNzPSJpY29uLXZzLW91dCIgZD0iTTE1IDMuMzQ5djguNDAzTDguOTc1IDE2SDguMDdMMSAxMS41ODJWMy4zMjdMNy41OTUgMGgxLjExOEwxNSAzLjM0OXoiIGlkPSJvdXRsaW5lIi8+PHBhdGggY2xhc3M9Imljb24tdnMtZmciIGQ9Ik0xMi43MTUgNC4zOThMOC40ODcgNy4wMiAzLjU2NSA0LjI3Mmw0LjU3OC0yLjMwOSA0LjU3MiAyLjQzNXpNMyA1LjEwMmw1IDIuNzkydjUuNzA1bC01LTMuMTI1VjUuMTAyem02IDguNDM0VjcuODc4bDQtMi40OHY1LjMxN2wtNCAyLjgyMXoiIGlkPSJpY29uRmciLz48cGF0aCBjbGFzcz0iaWNvbi12cy1hY3Rpb24tcHVycGxlIiBkPSJNOC4xNTYuODM3TDIgMy45NDJ2Ny4wODVMOC41MTcgMTUuMSAxNCAxMS4yMzNWMy45NUw4LjE1Ni44Mzd6bTQuNTU5IDMuNTYxTDguNDg3IDcuMDIgMy41NjUgNC4yNzJsNC41NzgtMi4zMDkgNC41NzIgMi40MzV6TTMgNS4xMDJsNSAyLjc5MnY1LjcwNWwtNS0zLjEyNVY1LjEwMnptNiA4LjQzNFY3Ljg3OGw0LTIuNDh2NS4zMTdsLTQgMi44MjF6IiBpZD0iaWNvbkJnIi8+PC9zdmc+\"); }\n\n.monaco-editor.vs-dark .suggest-widget .monaco-list .monaco-list-row .icon.field,\n.monaco-editor.hc-black .suggest-widget .monaco-list .monaco-list-row .icon.field { background-image: url(\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNiAxNiI+PHN0eWxlPi5pY29uLWNhbnZhcy10cmFuc3BhcmVudHtvcGFjaXR5OjA7ZmlsbDojMmQyZDMwfS5pY29uLXZzLW91dHtmaWxsOiMyZDJkMzB9Lmljb24tdnMtZmd7ZmlsbDojMmIyODJlfS5pY29uLXZzLWFjdGlvbi1ibHVle2ZpbGw6Izc1YmVmZn08L3N0eWxlPjxwYXRoIGNsYXNzPSJpY29uLWNhbnZhcy10cmFuc3BhcmVudCIgZD0iTTE2IDE2SDBWMGgxNnYxNnoiIGlkPSJjYW52YXMiLz48cGF0aCBjbGFzcz0iaWNvbi12cy1vdXQiIGQ9Ik0wIDEwLjczNlY0LjVMOSAwbDcgMy41djYuMjM2bC05IDQuNS03LTMuNXoiIGlkPSJvdXRsaW5lIi8+PHBhdGggY2xhc3M9Imljb24tdnMtYWN0aW9uLWJsdWUiIGQ9Ik05IDFMMSA1djVsNiAzIDgtNFY0TDkgMXpNNyA2Ljg4MkwzLjIzNiA1IDkgMi4xMTggMTIuNzY0IDQgNyA2Ljg4MnoiIGlkPSJpY29uQmciLz48cGF0aCBjbGFzcz0iaWNvbi12cy1mZyIgZD0iTTkgMi4xMThMMTIuNzY0IDQgNyA2Ljg4MiAzLjIzNiA1IDkgMi4xMTh6IiBpZD0iaWNvbkZnIi8+PC9zdmc+\"); }\n\n.monaco-editor.vs-dark .suggest-widget .monaco-list .monaco-list-row .icon.event,\n.monaco-editor.hc-black .suggest-widget .monaco-list .monaco-list-row .icon.event { background-image: url(\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNiAxNiI+PHN0eWxlPi5pY29uLWNhbnZhcy10cmFuc3BhcmVudHtvcGFjaXR5OjA7ZmlsbDojMmQyZDMwfS5pY29uLXZzLW91dHtmaWxsOiMyZDJkMzB9Lmljb24tdnMtYWN0aW9uLW9yYW5nZXtmaWxsOiNlOGFiNTN9PC9zdHlsZT48cGF0aCBjbGFzcz0iaWNvbi1jYW52YXMtdHJhbnNwYXJlbnQiIGQ9Ik0xNiAxNkgwVjBoMTZ2MTZ6IiBpZD0iY2FudmFzIi8+PHBhdGggY2xhc3M9Imljb24tdnMtb3V0IiBkPSJNMTQgMS40MTRMOS40MTQgNkgxNHYxLjQxNEw1LjQxNCAxNkgzdi0xLjIzNEw1LjM3MSAxMEgyVjguNzY0TDYuMzgyIDBIMTR2MS40MTR6IiBpZD0ib3V0bGluZSIgc3R5bGU9ImRpc3BsYXk6IG5vbmU7Ii8+PHBhdGggY2xhc3M9Imljb24tdnMtYWN0aW9uLW9yYW5nZSIgZD0iTTcgN2g2bC04IDhINGwyLjk4NS02SDNsNC04aDZMNyA3eiIgaWQ9Imljb25CZyIvPjwvc3ZnPg==\"); }\n\n.monaco-editor.vs-dark .suggest-widget .monaco-list .monaco-list-row .icon.operator,\n.monaco-editor.hc-black .suggest-widget .monaco-list .monaco-list-row .icon.operator { background-image: url(\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNiAxNiI+PHN0eWxlPi5pY29uLWNhbnZhcy10cmFuc3BhcmVudHtvcGFjaXR5OjA7ZmlsbDojMmQyZDMwfS5pY29uLXZzLW91dHtmaWxsOiMyZDJkMzB9Lmljb24tdnMtZmd7ZmlsbDojMmIyODJlfS5pY29uLXZzLWFjdGlvbi1ibHVle2ZpbGw6Izc1YmVmZn08L3N0eWxlPjxwYXRoIGNsYXNzPSJpY29uLWNhbnZhcy10cmFuc3BhcmVudCIgZD0iTTE2IDE2SDBWMGgxNnYxNnoiIGlkPSJjYW52YXMiLz48cGF0aCBjbGFzcz0iaWNvbi12cy1vdXQiIGQ9Ik0xNiAxNkgwVjBoMTZ2MTZ6IiBpZD0ib3V0bGluZSIgc3R5bGU9ImRpc3BsYXk6IG5vbmU7Ii8+PHBhdGggY2xhc3M9Imljb24tdnMtYWN0aW9uLWJsdWUiIGQ9Ik0xIDF2MTRoMTRWMUgxem02IDEySDN2LTFoNHYxem0wLTNIM1Y5aDR2MXptMC01SDV2Mkg0VjVIMlY0aDJWMmgxdjJoMnYxem0zLjI4MSA4SDguNzE5bDMtNGgxLjU2M2wtMy4wMDEgNHpNMTQgNUg5VjRoNXYxeiIgaWQ9Imljb25CZyIvPjxwYXRoIGNsYXNzPSJpY29uLXZzLWZnIiBkPSJNNyA1SDV2Mkg0VjVIMlY0aDJWMmgxdjJoMnYxem03LTFIOXYxaDVWNHpNNyA5SDN2MWg0Vjl6bTAgM0gzdjFoNHYtMXptMy4yODEgMWwzLTRoLTEuNTYzbC0zIDRoMS41NjN6IiBpZD0iaWNvbkZnIiBzdHlsZT0iZGlzcGxheTogbm9uZTsiLz48L3N2Zz4=\"); }\n\n.monaco-editor.vs-dark .suggest-widget .monaco-list .monaco-list-row .icon.variable,\n.monaco-editor.hc-black .suggest-widget .monaco-list .monaco-list-row .icon.variable { background-image: url(\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNiAxNiI+PHN0eWxlPi5pY29uLWNhbnZhcy10cmFuc3BhcmVudHtvcGFjaXR5OjA7ZmlsbDojMmQyZDMwfS5pY29uLXZzLW91dHtmaWxsOiMyZDJkMzB9Lmljb24tdnMtYmd7ZmlsbDojYzVjNWM1fS5pY29uLXZzLWZne2ZpbGw6IzJiMjgyZX0uaWNvbi12cy1hY3Rpb24tYmx1ZXtmaWxsOiM3NWJlZmZ9PC9zdHlsZT48cGF0aCBjbGFzcz0iaWNvbi1jYW52YXMtdHJhbnNwYXJlbnQiIGQ9Ik0xNiAxNkgwVjBoMTZ2MTZ6IiBpZD0iY2FudmFzIi8+PHBhdGggY2xhc3M9Imljb24tdnMtb3V0IiBkPSJNMTEgM3YxLjAxNUw4LjczMyAyLjg4MiA1IDQuNzQ5VjNIMHYxMGg1di0xLjg1OWwyLjE1NiAxLjA3N0wxMSAxMC4yOTVWMTNoNVYzaC01eiIgaWQ9Im91dGxpbmUiIHN0eWxlPSJkaXNwbGF5OiBub25lOyIvPjxwYXRoIGNsYXNzPSJpY29uLXZzLWJnIiBkPSJNMiA1djZoMnYxSDFWNGgzdjFIMnptMTAgNnYxaDNWNGgtM3YxaDJ2NmgtMnoiIGlkPSJpY29uQmciLz48cGF0aCBjbGFzcz0iaWNvbi12cy1mZyIgZD0iTTcuMTU2IDcuMTU2bC0xLjU3OC0uNzg5IDMuMTU2LTEuNTc4IDEuNTc4Ljc4OS0zLjE1NiAxLjU3OHoiIGlkPSJpY29uRmciIHN0eWxlPSJkaXNwbGF5OiBub25lOyIvPjxwYXRoIGNsYXNzPSJpY29uLXZzLWFjdGlvbi1ibHVlIiBkPSJNOC43MzMgNEw0IDYuMzY3djMuMTU2TDcuMTU2IDExLjFsNC43MzMtMi4zNjdWNS41NzhMOC43MzMgNHpNNy4xNTYgNy4xNTZsLTEuNTc4LS43ODkgMy4xNTYtMS41NzggMS41NzguNzg5LTMuMTU2IDEuNTc4eiIgaWQ9ImNvbG9ySW1wb3J0YW5jZSIvPjwvc3ZnPg==\"); }\n\n.monaco-editor.vs-dark .suggest-widget .monaco-list .monaco-list-row .icon.class,\n.monaco-editor.hc-black .suggest-widget .monaco-list .monaco-list-row .icon.class { background-image: url(\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNiAxNiI+PHN0eWxlPi5pY29uLWNhbnZhcy10cmFuc3BhcmVudHtvcGFjaXR5OjA7ZmlsbDojMmQyZDMwfS5pY29uLXZzLW91dHtmaWxsOiMyZDJkMzB9Lmljb24tdnMtYWN0aW9uLW9yYW5nZXtmaWxsOiNlOGFiNTN9PC9zdHlsZT48cGF0aCBjbGFzcz0iaWNvbi1jYW52YXMtdHJhbnNwYXJlbnQiIGQ9Ik0xNiAxNkgwVjBoMTZ2MTZ6IiBpZD0iY2FudmFzIi8+PHBhdGggY2xhc3M9Imljb24tdnMtb3V0IiBkPSJNMTYgNi41ODZsLTMtM0wxMS41ODYgNUg5LjQxNGwxLTEtNC00aC0uODI4TDAgNS41ODZ2LjgyOGw0IDRMNi40MTQgOEg3djVoMS41ODZsMyAzaC44MjhMMTYgMTIuNDE0di0uODI4TDEzLjkxNCA5LjUgMTYgNy40MTR2LS44Mjh6IiBpZD0ib3V0bGluZSIvPjxwYXRoIGNsYXNzPSJpY29uLXZzLWFjdGlvbi1vcmFuZ2UiIGQ9Ik0xMyAxMGwyIDItMyAzLTItMiAxLTFIOFY3SDZMNCA5IDEgNmw1LTUgMyAzLTIgMmg1bDEtMSAyIDItMyAzLTItMiAxLTFIOXY0bDIuOTk5LjAwMkwxMyAxMHoiIGlkPSJpY29uQmciLz48L3N2Zz4=\"); }\n\n.monaco-editor.vs-dark .suggest-widget .monaco-list .monaco-list-row .icon.interface,\n.monaco-editor.hc-black .suggest-widget .monaco-list .monaco-list-row .icon.interface { background-image: url(\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNiAxNiI+PHN0eWxlPi5pY29uLWNhbnZhcy10cmFuc3BhcmVudHtvcGFjaXR5OjA7ZmlsbDojMmQyZDMwfS5pY29uLXZzLW91dHtmaWxsOiMyZDJkMzB9Lmljb24tdnMtZmd7ZmlsbDojMmIyODJlfS5pY29uLXZzLWFjdGlvbi1ibHVle2ZpbGw6Izc1YmVmZn08L3N0eWxlPjxwYXRoIGNsYXNzPSJpY29uLWNhbnZhcy10cmFuc3BhcmVudCIgZD0iTTE2IDE2SDBWMGgxNnYxNnoiIGlkPSJjYW52YXMiLz48cGF0aCBjbGFzcz0iaWNvbi12cy1vdXQiIGQ9Ik0xMS41IDEyYy0xLjkxNSAwLTMuNjAyLTEuMjQxLTQuMjI4LTNoLTEuNDFhMy4xMSAzLjExIDAgMCAxLTIuNzM3IDEuNjI1QzEuNDAyIDEwLjYyNSAwIDkuMjIzIDAgNy41czEuNDAyLTMuMTI1IDMuMTI1LTMuMTI1YzEuMTY1IDAgMi4yMDEuNjM5IDIuNzM3IDEuNjI1aDEuNDFjLjYyNi0xLjc1OSAyLjMxMy0zIDQuMjI4LTNDMTMuOTgxIDMgMTYgNS4wMTkgMTYgNy41UzEzLjk4MSAxMiAxMS41IDEyeiIgaWQ9Im91dGxpbmUiLz48cGF0aCBjbGFzcz0iaWNvbi12cy1mZyIgZD0iTTExLjUgOUExLjUwMSAxLjUwMSAwIDEgMSAxMyA3LjVjMCAuODI2LS42NzMgMS41LTEuNSAxLjV6IiBpZD0iaWNvbkZnIi8+PHBhdGggY2xhc3M9Imljb24tdnMtYWN0aW9uLWJsdWUiIGQ9Ik0xMS41IDRhMy40OSAzLjQ5IDAgMCAwLTMuNDUgM0g1LjE4NUEyLjEyMiAyLjEyMiAwIDAgMCAxIDcuNWEyLjEyMyAyLjEyMyAwIDEgMCA0LjE4NS41SDguMDVhMy40OSAzLjQ5IDAgMCAwIDMuNDUgMyAzLjUgMy41IDAgMSAwIDAtN3ptMCA1Yy0uODI3IDAtMS41LS42NzMtMS41LTEuNVMxMC42NzMgNiAxMS41IDZzMS41LjY3MyAxLjUgMS41UzEyLjMyNyA5IDExLjUgOXoiIGlkPSJpY29uQmciLz48L3N2Zz4=\"); }\n\n.monaco-editor.vs-dark .suggest-widget .monaco-list .monaco-list-row .icon.struct,\n.monaco-editor.hc-black .suggest-widget .monaco-list .monaco-list-row .icon.struct { background-image: url(\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNiAxNiI+PHN0eWxlPi5pY29uLWNhbnZhcy10cmFuc3BhcmVudHtvcGFjaXR5OjA7ZmlsbDojMmQyZDMwfS5pY29uLXZzLW91dHtmaWxsOiMyZDJkMzB9Lmljb24tdnMtYWN0aW9uLWJsdWV7ZmlsbDojNzViZWZmfTwvc3R5bGU+PHBhdGggY2xhc3M9Imljb24tY2FudmFzLXRyYW5zcGFyZW50IiBkPSJNMTYgMTZIMFYwaDE2djE2eiIgaWQ9ImNhbnZhcyIvPjxwYXRoIGNsYXNzPSJpY29uLXZzLW91dCIgZD0iTTkgMTRWOEg3djZIMVYyaDE0djEySDl6IiBpZD0ib3V0bGluZSIgc3R5bGU9ImRpc3BsYXk6IG5vbmU7Ii8+PHBhdGggY2xhc3M9Imljb24tdnMtYWN0aW9uLWJsdWUiIGQ9Ik0xMCA5aDR2NGgtNFY5em0tOCA0aDRWOUgydjR6TTIgM3Y0aDEyVjNIMnoiIGlkPSJpY29uQmciLz48L3N2Zz4=\"); }\n\n.monaco-editor.vs-dark .suggest-widget .monaco-list .monaco-list-row .icon.type-parameter,\n.monaco-editor.hc-black .suggest-widget .monaco-list .monaco-list-row .icon.type-parameter { background-image: url(\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNiAxNiI+PHN0eWxlPi5pY29uLWNhbnZhcy10cmFuc3BhcmVudHtvcGFjaXR5OjA7ZmlsbDojMmQyZDMwfS5pY29uLXZzLW91dHtmaWxsOiMyZDJkMzB9Lmljb24tdnMtYmd7ZmlsbDojYzVjNWM1fTwvc3R5bGU+PHBhdGggY2xhc3M9Imljb24tY2FudmFzLXRyYW5zcGFyZW50IiBkPSJNMTYgMTZIMFYwaDE2djE2eiIgaWQ9ImNhbnZhcyIvPjxwYXRoIGNsYXNzPSJpY29uLXZzLW91dCIgZD0iTTEwLjcwMiAxMC41bDItMi0yLTIgLjUtLjVIMTB2NWgxdjNINXYtM2gxVjZINC43OThsLjUuNS0yIDIgMiAyTDMgMTIuNzk3bC0zLTNWNy4yMDFsMy0zVjJoMTB2Mi4yMDFsMyAzdjIuNTk2bC0zIDMtMi4yOTgtMi4yOTd6IiBpZD0ib3V0bGluZSIgc3R5bGU9ImRpc3BsYXk6IG5vbmU7Ii8+PHBhdGggY2xhc3M9Imljb24tdnMtYmciIGQ9Ik00IDNoOHYyaC0xdi0uNWMwLS4yNzctLjIyNC0uNS0uNS0uNUg5djcuNWMwIC4yNzUuMjI0LjUuNS41aC41djFINnYtMWguNWEuNS41IDAgMCAwIC41LS41VjRINS41YS41LjUgMCAwIDAtLjUuNVY1SDRWM3pNMyA1LjYxNUwuMTE2IDguNSAzIDExLjM4M2wuODg0LS44ODMtMi0yIDItMkwzIDUuNjE1em0xMCAwbC0uODg0Ljg4NSAyIDItMiAyIC44ODQuODgzTDE1Ljg4NCA4LjUgMTMgNS42MTV6IiBpZD0iaWNvbkJnIi8+PC9zdmc+\"); }\n\n.monaco-editor.vs-dark .suggest-widget .monaco-list .monaco-list-row .icon.module,\n.monaco-editor.hc-black .suggest-widget .monaco-list .monaco-list-row .icon.module { background-image: url(\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNiAxNiI+PHN0eWxlPi5pY29uLWNhbnZhcy10cmFuc3BhcmVudHtvcGFjaXR5OjA7ZmlsbDojMmQyZDMwfS5pY29uLXZzLW91dHtmaWxsOiMyZDJkMzB9Lmljb24tdnMtYmd7ZmlsbDojYzVjNWM1fTwvc3R5bGU+PHBhdGggY2xhc3M9Imljb24tY2FudmFzLXRyYW5zcGFyZW50IiBkPSJNMTYgMTZIMFYwaDE2djE2eiIgaWQ9ImNhbnZhcyIvPjxwYXRoIGNsYXNzPSJpY29uLXZzLW91dCIgZD0iTTkuMjYgMTEuOTg0bC45NzgtLjAyMWEuOTYyLjk2MiAwIDAgMCAuMDktLjAwNmMuMDExLS4wNjMuMDI2LS4xNzkuMDI2LS4zNjFWOS42ODhjMC0uNjc5LjE4NS0xLjI1Ny41My0xLjcwNy0uMzQ2LS40NTItLjUzLTEuMDMtLjUzLTEuNzA1VjQuMzVjMC0uMTY3LS4wMjEtLjI1OS0uMDM0LS4zMDJMOS4yNiA0LjAyVi45NzNsMS4wMTEuMDExYzIuMTY3LjAyNCAzLjQwOSAxLjE1NiAzLjQwOSAzLjEwNXYxLjk2MmMwIC4zNTEuMDcxLjQ2MS4wNzIuNDYybC45MzYuMDYuMDUzLjkyN3YxLjkzNmwtLjkzNi4wNjFjLS4wNzYuMDE2LS4xMjUuMTQ2LS4xMjUuNDI0djIuMDE3YzAgLjkxNC0uMzMyIDMuMDQzLTMuNDA4IDMuMDc4bC0xLjAxMi4wMTF2LTMuMDQzem0tMy41MjEgMy4wMzJjLTMuMDg5LS4wMzUtMy40MjItMi4xNjQtMy40MjItMy4wNzhWOS45MjFjMC0uMzI3LS4wNjYtLjQzMi0uMDY3LS40MzNsLS45MzctLjA2LS4wNjMtLjkyOVY2LjU2M2wuOTQyLS4wNmMuMDU4IDAgLjEyNS0uMTE0LjEyNS0uNDUyVjQuMDljMC0xLjk0OSAxLjI0OC0zLjA4MSAzLjQyMi0zLjEwNUw2Ljc1Ljk3M1Y0LjAybC0uOTc1LjAyM2EuNTcyLjU3MiAwIDAgMC0uMDkzLjAxYy4wMDYuMDIxLS4wMTkuMTE1LS4wMTkuMjk3djEuOTI4YzAgLjY3NS0uMTg2IDEuMjUzLS41MzQgMS43MDUuMzQ4LjQ1LjUzNCAxLjAyOC41MzQgMS43MDd2MS45MDdjMCAuMTc1LjAxNC4yOTEuMDI3LjM2My4wMjMuMDAyIDEuMDYuMDI1IDEuMDYuMDI1djMuMDQzbC0xLjAxMS0uMDEyeiIgaWQ9Im91dGxpbmUiLz48cGF0aCBjbGFzcz0iaWNvbi12cy1iZyIgZD0iTTUuNzUgMTQuMDE2Yy0xLjYyMy0uMDE5LTIuNDM0LS43MTEtMi40MzQtMi4wNzhWOS45MjFjMC0uOTAyLS4zNTUtMS4zNzYtMS4wNjYtMS40MjJ2LS45OThjLjcxMS0uMDQ1IDEuMDY2LS41MjkgMS4wNjYtMS40NDlWNC4wOWMwLTEuMzg1LjgxMS0yLjA4NyAyLjQzNC0yLjEwNXYxLjA2Yy0uNzI1LjAxNy0xLjA4Ny40NTMtMS4wODcgMS4zMDV2MS45MjhjMCAuOTItLjQ1NCAxLjQ4OC0xLjM2IDEuNzAyVjhjLjkwNy4yMDEgMS4zNi43NjMgMS4zNiAxLjY4OHYxLjkwN2MwIC40ODguMDgxLjgzNS4yNDMgMS4wNDIuMTYyLjIwOC40NDMuMzE2Ljg0NC4zMjV2MS4wNTR6bTcuOTktNS41MTdjLS43MDYuMDQ1LTEuMDYuNTItMS4wNiAxLjQyMnYyLjAxN2MwIDEuMzY3LS44MDcgMi4wNi0yLjQyIDIuMDc4di0xLjA1M2MuMzk2LS4wMDkuNjc4LS4xMTguODQ0LS4zMjguMTY3LS4yMS4yNS0uNTU2LjI1LTEuMDM5VjkuNjg4YzAtLjkyNS40NDktMS40ODggMS4zNDctMS42ODh2LS4wMjFjLS44OTgtLjIxNC0xLjM0Ny0uNzgyLTEuMzQ3LTEuNzAyVjQuMzVjMC0uODUyLS4zNjQtMS4yODgtMS4wOTQtMS4zMDZ2LTEuMDZjMS42MTMuMDE4IDIuNDIuNzIgMi40MiAyLjEwNXYxLjk2MmMwIC45Mi4zNTQgMS40MDQgMS4wNiAxLjQ0OXYuOTk5eiIgaWQ9Imljb25CZyIvPjwvc3ZnPg==\"); }\n\n.monaco-editor.vs-dark .suggest-widget .monaco-list .monaco-list-row .icon.property,\n.monaco-editor.hc-black .suggest-widget .monaco-list .monaco-list-row .icon.property { background-image: url(\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNiAxNiI+PHN0eWxlPi5pY29uLWNhbnZhcy10cmFuc3BhcmVudHtvcGFjaXR5OjA7ZmlsbDojMmQyZDMwfS5pY29uLXZzLW91dHtmaWxsOiMyZDJkMzB9Lmljb24tdnMtYmd7ZmlsbDojYzVjNWM1fTwvc3R5bGU+PHBhdGggY2xhc3M9Imljb24tY2FudmFzLXRyYW5zcGFyZW50IiBkPSJNMTYgMTZIMFYwaDE2djE2eiIgaWQ9ImNhbnZhcyIvPjxwYXRoIGNsYXNzPSJpY29uLXZzLW91dCIgZD0iTTE2IDUuNWE1LjUgNS41IDAgMCAxLTUuNSA1LjVjLS4yNzUgMC0uNTQzLS4wMjctLjgwNy0uMDY2bC0uMDc5LS4wMTJhNS40MjkgNS40MjkgMCAwIDEtLjgxLS4xOTJsLTQuNTM3IDQuNTM3Yy0uNDcyLjQ3My0xLjEuNzMzLTEuNzY3LjczM3MtMS4yOTUtLjI2LTEuNzY4LS43MzJhMi41MDIgMi41MDIgMCAwIDEgMC0zLjUzNWw0LjUzNy00LjUzN2E1LjQ1MiA1LjQ1MiAwIDAgMS0uMTkxLS44MTJjLS4wMDUtLjAyNS0uMDA4LS4wNTEtLjAxMi0uMDc3QTUuNTAzIDUuNTAzIDAgMCAxIDUgNS41YTUuNSA1LjUgMCAxIDEgMTEgMHoiIGlkPSJvdXRsaW5lIi8+PHBhdGggY2xhc3M9Imljb24tdnMtYmciIGQ9Ik0xNSA1LjVhNC41IDQuNSAwIDAgMS00LjUgNC41Yy0uNjkzIDAtMS4zNDItLjE3LTEuOTI5LS40NWwtNS4wMSA1LjAxYy0uMjkzLjI5NC0uNjc3LjQ0LTEuMDYxLjQ0cy0uNzY4LS4xNDYtMS4wNjEtLjQzOWExLjUgMS41IDAgMCAxIDAtMi4xMjFsNS4wMS01LjAxQTQuNDgzIDQuNDgzIDAgMCAxIDYgNS41IDQuNSA0LjUgMCAwIDEgMTAuNSAxYy42OTMgMCAxLjM0Mi4xNyAxLjkyOS40NUw5LjYzNiA0LjI0M2wyLjEyMSAyLjEyMSAyLjc5My0yLjc5M2MuMjguNTg3LjQ1IDEuMjM2LjQ1IDEuOTI5eiIgaWQ9Imljb25CZyIvPjwvc3ZnPg==\"); }\n\n.monaco-editor.vs-dark .suggest-widget .monaco-list .monaco-list-row .icon.unit,\n.monaco-editor.hc-black .suggest-widget .monaco-list .monaco-list-row .icon.unit { background-image: url(\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNiAxNiI+PHN0eWxlPi5pY29uLWNhbnZhcy10cmFuc3BhcmVudHtvcGFjaXR5OjA7ZmlsbDojMmQyZDMwfS5pY29uLXZzLW91dHtmaWxsOiMyZDJkMzB9Lmljb24tdnMtYmd7ZmlsbDojYzVjNWM1fS5pY29uLXZzLWZne2ZpbGw6IzJiMjgyZX08L3N0eWxlPjxwYXRoIGNsYXNzPSJpY29uLWNhbnZhcy10cmFuc3BhcmVudCIgZD0iTTE2IDE2SDBWMGgxNnYxNnoiIGlkPSJjYW52YXMiLz48cGF0aCBjbGFzcz0iaWNvbi12cy1vdXQiIGQ9Ik0xNiAxMS4wMTNIMVY0aDE1djcuMDEzeiIgaWQ9Im91dGxpbmUiLz48cGF0aCBjbGFzcz0iaWNvbi12cy1mZyIgZD0iTTggOUg3VjZoM3YzSDlWN0g4djJ6TTQgN2gxdjJoMVY2SDN2M2gxVjd6bTggMGgxdjJoMVY2aC0zdjNoMVY3eiIgaWQ9Imljb25GZyIvPjxwYXRoIGNsYXNzPSJpY29uLXZzLWJnIiBkPSJNMiA1djVoMTNWNUgyem00IDRINVY3SDR2MkgzVjZoM3Yzem00IDBIOVY3SDh2Mkg3VjZoM3Yzem00IDBoLTFWN2gtMXYyaC0xVjZoM3YzeiIgaWQ9Imljb25CZyIvPjwvc3ZnPg==\"); }\n\n.monaco-editor.vs-dark .suggest-widget .monaco-list .monaco-list-row .icon.constant,\n.monaco-editor.hc-black .suggest-widget .monaco-list .monaco-list-row .icon.constant { background-image: url(\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNiAxNiI+PHN0eWxlPi5pY29uLWNhbnZhcy10cmFuc3BhcmVudHtvcGFjaXR5OjA7ZmlsbDojMjUyNTI2fS5pY29uLXZzLW91dHtmaWxsOiMyNTI1MjZ9Lmljb24tdnMtYmd7ZmlsbDojYzVjNWM1fS5pY29uLXZzLWZne2ZpbGw6IzJiMjgyZX0uaWNvbi12cy1hY3Rpb24tYmx1ZXtmaWxsOiM3NWJlZmZ9PC9zdHlsZT48cGF0aCBjbGFzcz0iaWNvbi1jYW52YXMtdHJhbnNwYXJlbnQiIGQ9Ik0xNiAxNkgwVjBoMTZ2MTZ6IiBpZD0iY2FudmFzIi8+PHBhdGggY2xhc3M9Imljb24tdnMtb3V0IiBkPSJNMi44NzkgMTRMMSAxMi4xMjFWMy44NzlMMi44NzkgMmgxMC4yNDJMMTUgMy44Nzl2OC4yNDJMMTMuMTIxIDE0SDIuODc5eiIgaWQ9Im91dGxpbmUiLz48cGF0aCBjbGFzcz0iaWNvbi12cy1mZyIgZD0iTTEyLjI5MyA0SDMuNzA3TDMgNC43MDd2Ni41ODZsLjcwNy43MDdoOC41ODZsLjcwNy0uNzA3VjQuNzA3TDEyLjI5MyA0ek0xMSAxMEg1VjloNnYxem0wLTNINVY2aDZ2MXoiIGlkPSJpY29uRmciLz48ZyBpZD0iaWNvbkJnIj48cGF0aCBjbGFzcz0iaWNvbi12cy1iZyIgZD0iTTEyLjcwNyAxM0gzLjI5M0wyIDExLjcwN1Y0LjI5M0wzLjI5MyAzaDkuNDE0TDE0IDQuMjkzdjcuNDE0TDEyLjcwNyAxM3ptLTktMWg4LjU4NmwuNzA3LS43MDdWNC43MDdMMTIuMjkzIDRIMy43MDdMMyA0LjcwN3Y2LjU4NmwuNzA3LjcwN3oiLz48cGF0aCBjbGFzcz0iaWNvbi12cy1hY3Rpb24tYmx1ZSIgZD0iTTExIDdINVY2aDZ2MXptMCAySDV2MWg2Vjl6Ii8+PC9nPjwvc3ZnPg==\"); }\n\n.monaco-editor.vs-dark .suggest-widget .monaco-list .monaco-list-row .icon.value,\n.monaco-editor.hc-black .suggest-widget .monaco-list .monaco-list-row .icon.value,\n.monaco-editor.vs-dark .suggest-widget .monaco-list .monaco-list-row .icon.enum,\n.monaco-editor.hc-black .suggest-widget .monaco-list .monaco-list-row .icon.enum { background-image: url(\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNiAxNiI+PHN0eWxlPi5pY29uLWNhbnZhcy10cmFuc3BhcmVudHtvcGFjaXR5OjA7ZmlsbDojMmQyZDMwfS5pY29uLXZzLW91dHtmaWxsOiMyZDJkMzB9Lmljb24tdnMtZmd7ZmlsbDojMmIyODJlfS5pY29uLXZzLWFjdGlvbi1vcmFuZ2V7ZmlsbDojZThhYjUzfTwvc3R5bGU+PHBhdGggY2xhc3M9Imljb24tY2FudmFzLXRyYW5zcGFyZW50IiBkPSJNMTYgMTZIMFYwaDE2djE2eiIgaWQ9ImNhbnZhcyIvPjxwYXRoIGNsYXNzPSJpY29uLXZzLW91dCIgZD0iTTE0LjQxNCAxTDE2IDIuNTg2djUuODI4TDE0LjQxNCAxMEgxMHYzLjQxNkw4LjQxNCAxNUgxLjU4NkwwIDEzLjQxNnYtNS44M0wxLjU4NiA2SDZWMi41ODZMNy41ODYgMWg2LjgyOHoiIGlkPSJvdXRsaW5lIi8+PHBhdGggY2xhc3M9Imljb24tdnMtZmciIGQ9Ik0yIDEzaDZWOEgydjV6bTEtNGg0djFIM1Y5em0wIDJoNHYxSDN2LTF6bTExLTVWM0g4djNoLjQxNEw5IDYuNTg2VjZoNHYxSDkuNDE0bC41ODYuNTg2VjhoNFY2em0tMS0xSDlWNGg0djF6IiBpZD0iaWNvbkZnIi8+PHBhdGggY2xhc3M9Imljb24tdnMtYWN0aW9uLW9yYW5nZSIgZD0iTTMgMTFoNC4wMDF2MUgzdi0xem0wLTFoNC4wMDFWOUgzdjF6bTYtMnY1bC0xIDFIMmwtMS0xVjhsMS0xaDZsMSAxek04IDhIMnY1aDZWOHptMS0ybDEgMWgzVjZIOXptMC0xaDRWNEg5djF6bTUtM0g4TDcgM3YzaDFWM2g2djVoLTR2MWg0bDEtMVYzbC0xLTF6IiBpZD0iaWNvbkJnIi8+PC9zdmc+\"); }\n\n.monaco-editor.vs-dark .suggest-widget .monaco-list .monaco-list-row .icon.enum-member,\n.monaco-editor.hc-black .suggest-widget .monaco-list .monaco-list-row .icon.enum-member { background-image: url(\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNiAxNiI+PHN0eWxlPi5pY29uLWNhbnZhcy10cmFuc3BhcmVudHtvcGFjaXR5OjA7ZmlsbDojMmQyZDMwfS5pY29uLXZzLW91dHtmaWxsOiMyZDJkMzB9Lmljb24tdnMtZmd7ZmlsbDojMmIyODJlfS5pY29uLXZzLWFjdGlvbi1ibHVle2ZpbGw6Izc1YmVmZn08L3N0eWxlPjxwYXRoIGNsYXNzPSJpY29uLWNhbnZhcy10cmFuc3BhcmVudCIgZD0iTTE2IDE2SDBWMGgxNnYxNnoiIGlkPSJjYW52YXMiLz48cGF0aCBjbGFzcz0iaWNvbi12cy1vdXQiIGQ9Ik0wIDE1VjZoNlYyLjU4Nkw3LjU4NSAxaDYuODI5TDE2IDIuNTg2djUuODI5TDE0LjQxNCAxMEgxMHY1SDB6bTMtNnoiIGlkPSJvdXRsaW5lIi8+PHBhdGggY2xhc3M9Imljb24tdnMtZmciIGQ9Ik04IDN2M2g1djFoLTN2MWg0VjNIOHptNSAySDlWNGg0djF6TTIgOHY1aDZWOEgyem01IDNIM3YtMWg0djF6IiBpZD0iaWNvbkZnIi8+PHBhdGggY2xhc3M9Imljb24tdnMtYWN0aW9uLWJsdWUiIGQ9Ik0xMCA2aDN2MWgtM1Y2ek05IDR2MWg0VjRIOXptNS0ySDhMNyAzdjNoMVYzaDZ2NWgtNHYxaDRsMS0xVjNsLTEtMXptLTcgOEgzdjFoNHYtMXptMi0zdjdIMVY3aDh6TTggOEgydjVoNlY4eiIgaWQ9Imljb25CZyIvPjwvc3ZnPg==\"); }\n\n.monaco-editor.vs-dark .suggest-widget .monaco-list .monaco-list-row .icon.keyword,\n.monaco-editor.hc-black .suggest-widget .monaco-list .monaco-list-row .icon.keyword { background-image: url(\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNiAxNiI+PHN0eWxlPi5pY29uLWNhbnZhcy10cmFuc3BhcmVudHtvcGFjaXR5OjA7ZmlsbDojMmQyZDMwfS5pY29uLXZzLW91dHtmaWxsOiMyZDJkMzB9Lmljb24tdnMtYmd7ZmlsbDojYzVjNWM1fS5pY29uLXZzLWZne2ZpbGw6IzJiMjgyZX08L3N0eWxlPjxwYXRoIGNsYXNzPSJpY29uLWNhbnZhcy10cmFuc3BhcmVudCIgZD0iTTE2IDE2SDBWMGgxNnYxNnoiIGlkPSJjYW52YXMiLz48cGF0aCBjbGFzcz0iaWNvbi12cy1vdXQiIGQ9Ik0xNiA1VjJIOVYxSDB2MTRoMTN2LTNoM1Y5aC0xVjZIOVY1aDd6bS04IDdWOWgxdjNIOHoiIGlkPSJvdXRsaW5lIi8+PHBhdGggY2xhc3M9Imljb24tdnMtZmciIGQ9Ik0yIDNoNXYxSDJWM3oiIGlkPSJpY29uRmciLz48cGF0aCBjbGFzcz0iaWNvbi12cy1iZyIgZD0iTTE1IDRoLTVWM2g1djF6bS0xIDNoLTJ2MWgyVjd6bS00IDBIMXYxaDlWN3ptMiA2SDF2MWgxMXYtMXptLTUtM0gxdjFoNnYtMXptOCAwaC01djFoNXYtMXpNOCAydjNIMVYyaDd6TTcgM0gydjFoNVYzeiIgaWQ9Imljb25CZyIvPjwvc3ZnPg==\"); }\n\n.monaco-editor.vs-dark .suggest-widget .monaco-list .monaco-list-row .icon.text,\n.monaco-editor.hc-black .suggest-widget .monaco-list .monaco-list-row .icon.text { background-image: url(\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNiAxNiI+PHN0eWxlPi5pY29uLWNhbnZhcy10cmFuc3BhcmVudHtvcGFjaXR5OjA7ZmlsbDojMmQyZDMwfS5pY29uLXZzLW91dHtmaWxsOiMyZDJkMzB9Lmljb24tdnMtYmd7ZmlsbDojYzVjNWM1fS5pY29uLXZzLWZne2ZpbGw6IzJiMjgyZX08L3N0eWxlPjxwYXRoIGNsYXNzPSJpY29uLWNhbnZhcy10cmFuc3BhcmVudCIgZD0iTTE2IDE2SDBWMGgxNnYxNnoiIGlkPSJjYW52YXMiLz48cGF0aCBjbGFzcz0iaWNvbi12cy1vdXQiIGQ9Ik0xNiAxNUgwVjFoMTZ2MTR6IiBpZD0ib3V0bGluZSIvPjxwYXRoIGNsYXNzPSJpY29uLXZzLWZnIiBkPSJNOS4yMjkgNy4zNTRjLjAzNS4xNDYuMDUyLjMxLjA1Mi40OTQgMCAuMjM0LS4wMi40NDEtLjA2LjYyMS0uMDM5LjE4LS4wOTUuMzI4LS4xNjguNDQ1YS42ODcuNjg3IDAgMCAxLS45MTQuMjgxLjc2Ljc2IDAgMCAxLS4yMzctLjIwNy45ODguOTg4IDAgMCAxLS4xNTQtLjMwNiAxLjI2MiAxLjI2MiAwIDAgMS0uMDU3LS4zODF2LS41MDZjMC0uMTcuMDItLjMyNi4wNjEtLjQ2NXMuMDk2LS4yNTguMTY4LS4zNTlhLjc1Ni43NTYgMCAwIDEgLjI1Ny0uMjMyYy4xLS4wNTUuMjEtLjA4Mi4zMzEtLjA4MmEuNjQ2LjY0NiAwIDAgMSAuNTcxLjMyYy4wNjcuMTA1LjExNi4yMy4xNS4zNzd6bS01LjEyNi44NjlhLjU1Ny41NTcgMCAwIDAtLjE5Ni4xMzJjLS4wNDcuMDUzLS4wOC4xMTItLjA5Ny4xOHMtLjAyOC4xNDctLjAyOC4yMzNhLjUxMy41MTMgMCAwIDAgLjE1Ny4zOS41MjguNTI4IDAgMCAwIC4xODYuMTEzLjY4Mi42ODIgMCAwIDAgLjI0Mi4wNDEuNzYuNzYgMCAwIDAgLjU5My0uMjcxLjg5Ny44OTcgMCAwIDAgLjE2NS0uMjk1Yy4wMzgtLjExMy4wNTktLjIzNC4wNTktLjM2NXYtLjM0NmwtLjc2MS4xMWExLjI5IDEuMjkgMCAwIDAtLjMyLjA3OHpNMTQgM3YxMEgyVjNoMTJ6TTUuOTYyIDcuNDY5YzAtLjIzOC0uMDI3LS40NTEtLjA4My0uNjM3YTEuMjg2IDEuMjg2IDAgMCAwLS4yNDktLjQ3MSAxLjA4IDEuMDggMCAwIDAtLjQyNC0uMjk1IDEuNjQ0IDEuNjQ0IDAgMCAwLS42MDgtLjEwMWMtLjExOSAwLS4yNDEuMDEyLS4zNjguMDMzYTMuMjEzIDMuMjEzIDAgMCAwLS42NzMuMTk1IDEuMzEzIDEuMzEzIDAgMCAwLS4yMTIuMTE0di43NjhjLjE1OC0uMTMyLjM0MS0uMjM1LjU0NC0uMzEzLjIwNC0uMDc4LjQxMy0uMTE3LjYyNy0uMTE3LjIxMyAwIC4zNzcuMDYzLjQ5NC4xODYuMTE2LjEyNS4xNzQuMzI0LjE3NC42bC0xLjAzLjE1NGMtLjIwNS4wMjYtLjM4LjA3Ny0uNTI2LjE1MWExLjA4MyAxLjA4MyAwIDAgMC0uNTYzLjY2QTEuNTYyIDEuNTYyIDAgMCAwIDMgOC44NTdjMCAuMTcuMDI1LjMyMy4wNzQuNDYzYS45NDUuOTQ1IDAgMCAwIC41NjguNTk2Yy4xMzkuMDU3LjI5Ny4wODQuNDc4LjA4NC4yMjkgMCAuNDMxLS4wNTMuNjA0LS4xNmExLjMgMS4zIDAgMCAwIC40MzktLjQ2M2guMDE0di41MjloLjc4NVY3LjQ2OXpNMTAgNy44NjFhMy41NCAzLjU0IDAgMCAwLS4wNzQtLjczNCAyLjA0NyAyLjA0NyAwIDAgMC0uMjI4LS42MTEgMS4yMDMgMS4yMDMgMCAwIDAtLjM5NC0uNDE2IDEuMDMgMS4wMyAwIDAgMC0uNTc0LS4xNTNjLS4xMjMgMC0uMjM0LjAxOC0uMzM2LjA1MWExIDEgMCAwIDAtLjI3OC4xNDcgMS4xNTMgMS4xNTMgMCAwIDAtLjIyNS4yMjIgMi4wMjIgMi4wMjIgMCAwIDAtLjE4MS4yODloLS4wMTNWNUg3djQuODg3aC42OTd2LS40ODVoLjAxM2MuMDQ0LjA4Mi4wOTUuMTU4LjE1MS4yMjkuMDU3LjA3LjExOS4xMzMuMTkxLjE4NmEuODM1LjgzNSAwIDAgMCAuMjM4LjEyMS45NDMuOTQzIDAgMCAwIC4yOTMuMDQyYy4yMyAwIC40MzQtLjA1My42MDktLjE2YTEuMzQgMS4zNCAwIDAgMCAuNDQzLS40NDNjLjEyLS4xODguMjExLS40MTIuMjcyLS42NzJBMy42MiAzLjYyIDAgMCAwIDEwIDcuODYxem0zLTEuNjU4YS43LjcgMCAwIDAtLjEwNi0uMDY2IDEuMTgzIDEuMTgzIDAgMCAwLS4xNDItLjA2MyAxLjIzMyAxLjIzMyAwIDAgMC0uMzYzLS4wNjVjLS4yMDkgMC0uMzk5LjA1MS0uNTY5LjE1YTEuMzU1IDEuMzU1IDAgMCAwLS40MzMuNDI0Yy0uMTE4LjE4Mi0uMjEuNDAyLS4yNzMuNjZhMy42MyAzLjYzIDAgMCAwLS4wMDggMS42MTVjLjA2LjIzLjE0My40My4yNTIuNjAyLjEwOS4xNjguMjQxLjMwMy4zOTYuMzk2YS45NzIuOTcyIDAgMCAwIC41MjQuMTQ0Yy4xNTggMCAuMjk2LS4wMjEuNDEzLS4wNjguMTE3LS4wNDUuMjE5LS4xMDguMzA5LS4xODR2LS43N2ExLjA5NCAxLjA5NCAwIDAgMS0uMjg4LjIyNS44MTkuODE5IDAgMCAxLS4xNTguMDY4LjQ4LjQ4IDAgMCAxLS4xNTMuMDI3LjYyLjYyIDAgMCAxLS4yNzQtLjA3NGMtLjI0MS0uMTM2LS40MjMtLjQ3OS0uNDIzLTEuMTQ2IDAtLjcxNS4yMDYtMS4xMi40NjktMS4zMDEuMDc3LS4wMzIuMTUzLS4wNjQuMjM4LS4wNjQuMTEzIDAgLjIyLjAyNy4zMTcuMDgyLjA5Ni4wNTcuMTg4LjEzMS4yNzIuMjIzdi0uODE1eiIgaWQ9Imljb25GZyIvPjxwYXRoIGNsYXNzPSJpY29uLXZzLWJnIiBkPSJNMSAydjEyaDE0VjJIMXptMTMgMTFIMlYzaDEydjEwek01LjYzIDYuMzYxYTEuMDggMS4wOCAwIDAgMC0uNDI0LS4yOTUgMS42NDQgMS42NDQgMCAwIDAtLjYwOC0uMTAxYy0uMTE5IDAtLjI0MS4wMTItLjM2OC4wMzNhMy4yMTMgMy4yMTMgMCAwIDAtLjY3My4xOTUgMS4zMTMgMS4zMTMgMCAwIDAtLjIxMi4xMTR2Ljc2OGMuMTU4LS4xMzIuMzQxLS4yMzUuNTQ0LS4zMTMuMjA0LS4wNzguNDEzLS4xMTcuNjI3LS4xMTcuMjEzIDAgLjM3Ny4wNjMuNDk0LjE4Ni4xMTYuMTI1LjE3NC4zMjQuMTc0LjZsLTEuMDMuMTU0Yy0uMjA1LjAyNi0uMzguMDc3LS41MjYuMTUxYTEuMDgzIDEuMDgzIDAgMCAwLS41NjMuNjZBMS41NjIgMS41NjIgMCAwIDAgMyA4Ljg1N2MwIC4xNy4wMjUuMzIzLjA3NC40NjNhLjk0NS45NDUgMCAwIDAgLjU2OC41OTZjLjEzOS4wNTcuMjk3LjA4NC40NzguMDg0LjIyOSAwIC40MzEtLjA1My42MDQtLjE2YTEuMyAxLjMgMCAwIDAgLjQzOS0uNDYzaC4wMTR2LjUyOWguNzg1VjcuNDY5YzAtLjIzOC0uMDI3LS40NTEtLjA4My0uNjM3YTEuMjg2IDEuMjg2IDAgMCAwLS4yNDktLjQ3MXptLS40NDYgMi4wMmMwIC4xMzEtLjAyLjI1Mi0uMDU5LjM2NWEuODk3Ljg5NyAwIDAgMS0uMTY1LjI5NS43NTguNzU4IDAgMCAxLS41OTMuMjcyLjY4Mi42ODIgMCAwIDEtLjI0Mi0uMDQxLjUwNy41MDcgMCAwIDEtLjMwMi0uMjg2LjU4My41ODMgMCAwIDEtLjA0MS0uMjE4YzAtLjA4Ni4wMS0uMTY0LjAyNy0uMjMycy4wNTEtLjEyNy4wOTgtLjE4YS41NDYuNTQ2IDAgMCAxIC4xOTYtLjEzM2MuMDgzLS4wMzMuMTg5LS4wNjEuMzItLjA3OGwuNzYxLS4xMDl2LjM0NXptNC41MTQtMS44NjVhMS4yMDMgMS4yMDMgMCAwIDAtLjM5NC0uNDE2IDEuMDMgMS4wMyAwIDAgMC0uNTc0LS4xNTNjLS4xMjMgMC0uMjM0LjAxOC0uMzM2LjA1MWExIDEgMCAwIDAtLjI3OC4xNDcgMS4xNTMgMS4xNTMgMCAwIDAtLjIyNS4yMjIgMi4wMjIgMi4wMjIgMCAwIDAtLjE4MS4yODloLS4wMTNWNUg3djQuODg3aC42OTd2LS40ODVoLjAxM2MuMDQ0LjA4Mi4wOTUuMTU4LjE1MS4yMjkuMDU3LjA3LjExOS4xMzMuMTkxLjE4NmEuODM1LjgzNSAwIDAgMCAuMjM4LjEyMS45NDMuOTQzIDAgMCAwIC4yOTMuMDQyYy4yMyAwIC40MzQtLjA1My42MDktLjE2YTEuMzQgMS4zNCAwIDAgMCAuNDQzLS40NDNjLjEyLS4xODguMjExLS40MTIuMjcyLS42NzJBMy42MiAzLjYyIDAgMCAwIDEwIDcuODYxYTMuNTQgMy41NCAwIDAgMC0uMDc0LS43MzQgMi4wNDcgMi4wNDcgMCAwIDAtLjIyOC0uNjExem0tLjQ3NiAxLjk1M2MtLjAzOS4xOC0uMDk1LjMyOC0uMTY4LjQ0NWEuNzU1Ljc1NSAwIDAgMS0uMjY0LjI2Ni42ODcuNjg3IDAgMCAxLS42NTEuMDE1Ljc2Ljc2IDAgMCAxLS4yMzctLjIwNy45ODguOTg4IDAgMCAxLS4xNTQtLjMwNiAxLjI2MiAxLjI2MiAwIDAgMS0uMDU3LS4zODF2LS41MDZjMC0uMTcuMDItLjMyNi4wNjEtLjQ2NXMuMDk2LS4yNTguMTY4LS4zNTlhLjc1Ni43NTYgMCAwIDEgLjI1Ny0uMjMyYy4xLS4wNTUuMjEtLjA4Mi4zMzEtLjA4MmEuNjQ2LjY0NiAwIDAgMSAuNTcxLjMyYy4wNjYuMTA1LjExNi4yMy4xNS4zNzcuMDM1LjE0Ni4wNTIuMzEuMDUyLjQ5NCAwIC4yMzQtLjAxOS40NDEtLjA1OS42MjF6bTMuNjcyLTIuMzMyYS43LjcgMCAwIDEgLjEwNi4wNjZ2LjgxNGExLjE3OCAxLjE3OCAwIDAgMC0uMjczLS4yMjMuNjQ1LjY0NSAwIDAgMC0uMzE3LS4wODFjLS4wODUgMC0uMTYxLjAzMi0uMjM4LjA2NC0uMjYzLjE4MS0uNDY5LjU4Ni0uNDY5IDEuMzAxIDAgLjY2OC4xODIgMS4wMTEuNDIzIDEuMTQ2LjA4NC4wNC4xNzEuMDc0LjI3NC4wNzQuMDQ5IDAgLjEwMS0uMDEuMTUzLS4wMjdhLjg1Ni44NTYgMCAwIDAgLjE1OC0uMDY4IDEuMTYgMS4xNiAwIDAgMCAuMjg4LS4yMjV2Ljc3Yy0uMDkuMDc2LS4xOTIuMTM5LS4zMDkuMTg0YTEuMDk4IDEuMDk4IDAgMCAxLS40MTIuMDY4Ljk3NC45NzQgMCAwIDEtLjUyMy0uMTQzIDEuMjU3IDEuMjU3IDAgMCAxLS4zOTYtLjM5NiAyLjA5OCAyLjA5OCAwIDAgMS0uMjUyLS42MDIgMy4xMTggMy4xMTggMCAwIDEtLjA4OC0uNzU0YzAtLjMxNi4wMzItLjYwNC4wOTYtLjg2MS4wNjMtLjI1OC4xNTUtLjQ3OS4yNzMtLjY2LjExOS0uMTgyLjI2NS0uMzIyLjQzMy0uNDI0YTEuMTAyIDEuMTAyIDAgMCAxIDEuMDczLS4wMjN6IiBpZD0iaWNvbkJnIi8+PC9zdmc+\"); }\n\n.monaco-editor.vs-dark .suggest-widget .monaco-list .monaco-list-row .icon.color,\n.monaco-editor.hc-black .suggest-widget .monaco-list .monaco-list-row .icon.color { background-image: url(\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNiAxNiI+PHN0eWxlPi5pY29uLWNhbnZhcy10cmFuc3BhcmVudHtvcGFjaXR5OjA7ZmlsbDojMmQyZDMwfS5pY29uLXZzLW91dHtmaWxsOiMyZDJkMzB9Lmljb24tdnMtYmd7ZmlsbDojYzVjNWM1fS5pY29uLXZzLXJlZHtmaWxsOiNmNDg3NzF9Lmljb24tdnMteWVsbG93e2ZpbGw6I2ZmY2MwMH0uaWNvbi12cy1ncmVlbntmaWxsOiMzMzk5MzN9Lmljb24tdnMtYmx1ZXtmaWxsOiMxYmExZTJ9Lmljb24tdnMtYWN0aW9uLXB1cnBsZXtmaWxsOiNiMTgwZDd9Lmljb24td2hpdGV7ZmlsbDojMDAwMDAwfTwvc3R5bGU+PHBhdGggY2xhc3M9Imljb24tY2FudmFzLXRyYW5zcGFyZW50IiBkPSJNMTYgMTZIMFYwaDE2djE2eiIgaWQ9ImNhbnZhcyIvPjxwYXRoIGNsYXNzPSJpY29uLXZzLW91dCIgZD0iTTE2IDhjMCA0LjQxMS0zLjU4OSA4LTggOGEyLjgwMyAyLjgwMyAwIDAgMS0yLjgtMi44YzAtLjgzMy4yNzItMS42MjkuNzY2LTIuMjQxYS41OTYuNTk2IDAgMCAwIC4xMDEtLjM1OS42NjcuNjY3IDAgMCAwLS42NjctLjY2Ni41OC41OCAwIDAgMC0uMzU4LjEwMkEzLjU4NCAzLjU4NCAwIDAgMSAyLjggMTAuOCAyLjgwMyAyLjgwMyAwIDAgMSAwIDhjMC00LjQxMSAzLjU4OS04IDgtOHM4IDMuNTg5IDggOHoiIGlkPSJvdXRsaW5lIi8+PHBhdGggY2xhc3M9Imljb24td2hpdGUiIGQ9Ik01LjQgNy45MzNhMi42NyAyLjY3IDAgMCAxIDIuNjY3IDIuNjY2YzAgLjYwNi0uMTkzIDEuMTc5LS41NDQgMS42MTRhMS41OTkgMS41OTkgMCAwIDAtLjMyMy45ODcuOC44IDAgMCAwIC44LjhjMy4zMDkgMCA2LTIuNjkxIDYtNnMtMi42OTEtNi02LTYtNiAyLjY5MS02IDZjMCAuNDQxLjM1OS44LjguOC4zNzggMCAuNzI5LS4xMTQuOTg2LS4zMjJBMi41NjggMi41NjggMCAwIDEgNS40IDcuOTMzeiIgaWQ9Imljb25GZyIvPjxnIGlkPSJpY29uQmciPjxwYXRoIGNsYXNzPSJpY29uLXZzLWJnIiBkPSJNOCAxNWMtLjk5MiAwLTEuOC0uODA4LTEuOC0xLjggMC0uNjA2LjE5My0xLjE3OS41NDQtMS42MTMuMjA4LS4yNTkuMzIzLS42MDkuMzIzLS45ODcgMC0uOTE5LS43NDgtMS42NjYtMS42NjctMS42NjYtLjM3NyAwLS43MjguMTE1LS45ODYuMzIzQTIuNTggMi41OCAwIDAgMSAyLjggOS44QzEuODA4IDkuOCAxIDguOTkyIDEgOGMwLTMuODYgMy4xNC03IDctNyAzLjg1OSAwIDcgMy4xNCA3IDcgMCAzLjg1OS0zLjE0MSA3LTcgN3pNNS40IDcuOTMzYTIuNjcgMi42NyAwIDAgMSAyLjY2NyAyLjY2NmMwIC42MDYtLjE5MyAxLjE3OS0uNTQ0IDEuNjE0YTEuNTk5IDEuNTk5IDAgMCAwLS4zMjMuOTg3LjguOCAwIDAgMCAuOC44YzMuMzA5IDAgNi0yLjY5MSA2LTZzLTIuNjkxLTYtNi02LTYgMi42OTEtNiA2YzAgLjQ0MS4zNTkuOC44LjguMzc4IDAgLjcyOS0uMTE0Ljk4Ni0uMzIyQTIuNTY4IDIuNTY4IDAgMCAxIDUuNCA3LjkzM3oiLz48cGF0aCBjbGFzcz0iaWNvbi12cy1hY3Rpb24tcHVycGxlIiBkPSJNNC41IDUuMzc1YS44NzUuODc1IDAgMSAwIDAgMS43NS44NzUuODc1IDAgMCAwIDAtMS43NXoiLz48cGF0aCBjbGFzcz0iaWNvbi12cy1ibHVlIiBkPSJNNy4xMjUgMy42MjVhLjg3NS44NzUgMCAxIDAgMCAxLjc1Ljg3NS44NzUgMCAwIDAgMC0xLjc1eiIvPjxwYXRoIGNsYXNzPSJpY29uLXZzLWdyZWVuIiBkPSJNMTAuNjI1IDQuNWEuODc1Ljg3NSAwIDEgMCAwIDEuNzUuODc1Ljg3NSAwIDAgMCAwLTEuNzV6Ii8+PHBhdGggY2xhc3M9Imljb24tdnMteWVsbG93IiBkPSJNMTEuNSA4YS44NzUuODc1IDAgMSAwIDAgMS43NS44NzUuODc1IDAgMCAwIDAtMS43NXoiLz48cGF0aCBjbGFzcz0iaWNvbi12cy1yZWQiIGQ9Ik05Ljc1IDEwLjYyNWEuODc1Ljg3NSAwIDEgMCAwIDEuNzUuODc1Ljg3NSAwIDAgMCAwLTEuNzV6Ii8+PC9nPjwvc3ZnPg==\"); }\n\n.monaco-editor.vs-dark .suggest-widget .monaco-list .monaco-list-row .icon.file,\n.monaco-editor.hc-black .suggest-widget .monaco-list .monaco-list-row .icon.file { background-image: url(\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNiAxNiI+PHN0eWxlPi5pY29uLWNhbnZhcy10cmFuc3BhcmVudHtvcGFjaXR5OjA7ZmlsbDojMmQyZDMwfS5pY29uLXZzLW91dHtmaWxsOiMyZDJkMzB9Lmljb24tdnMtYmd7ZmlsbDojYzVjNWM1fS5pY29uLXZzLWZne2ZpbGw6IzJiMjgyZX08L3N0eWxlPjxwYXRoIGNsYXNzPSJpY29uLWNhbnZhcy10cmFuc3BhcmVudCIgZD0iTTE2IDE2SDBWMGgxNnYxNnoiIGlkPSJjYW52YXMiLz48cGF0aCBjbGFzcz0iaWNvbi12cy1vdXQiIGQ9Ik0xNSAxNkgyVjBoOC42MjFMMTUgNC4zNzlWMTZ6IiBpZD0ib3V0bGluZSIvPjxwYXRoIGNsYXNzPSJpY29uLXZzLWZnIiBkPSJNMTMgMTRINFYyaDV2NGg0djh6bS0zLTlWMi4yMDdMMTIuNzkzIDVIMTB6IiBpZD0iaWNvbkZnIi8+PHBhdGggY2xhc3M9Imljb24tdnMtYmciIGQ9Ik0zIDF2MTRoMTFWNC43OTNMMTAuMjA3IDFIM3ptMTAgMTNINFYyaDV2NGg0djh6bS0zLTlWMi4yMDdMMTIuNzkzIDVIMTB6IiBpZD0iaWNvbkJnIi8+PC9zdmc+\"); }\n\n.monaco-editor.vs-dark .suggest-widget .monaco-list .monaco-list-row .icon.reference,\n.monaco-editor.hc-black .suggest-widget .monaco-list .monaco-list-row .icon.reference { background-image: url(\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNiAxNiI+PHN0eWxlPi5pY29uLWNhbnZhcy10cmFuc3BhcmVudHtvcGFjaXR5OjA7ZmlsbDojMmQyZDMwfS5pY29uLXZzLW91dHtmaWxsOiMyZDJkMzB9Lmljb24tdnMtYmd7ZmlsbDojYzVjNWM1fS5pY29uLXZzLWZne2ZpbGw6IzJiMjgyZX0uaWNvbi12cy1hY3Rpb24tYmx1ZXtmaWxsOiM3NWJlZmZ9PC9zdHlsZT48cGF0aCBjbGFzcz0iaWNvbi1jYW52YXMtdHJhbnNwYXJlbnQiIGQ9Ik0xNiAxNkgwVjBoMTZ2MTZ6IiBpZD0iY2FudmFzIi8+PHBhdGggY2xhc3M9Imljb24tdnMtb3V0IiBkPSJNMTQgNC41NTZWMTNjMCAuOTctLjcwMSAyLTIgMkg0Yy0uOTcgMC0yLS43MDEtMi0yVjYuNjQ5QTMuNDk1IDMuNDk1IDAgMCAxIDAgMy41QzAgMS41NyAxLjU3IDAgMy41IDBINXYxaDUuMDYxTDE0IDQuNTU2eiIgaWQ9Im91dGxpbmUiIHN0eWxlPSJkaXNwbGF5OiBub25lOyIvPjxwYXRoIGNsYXNzPSJpY29uLXZzLWJnIiBkPSJNMTMgNXY4cy0uMDM1IDEtMS4wMzUgMWgtOFMzIDE0IDMgMTNWOWgxdjRoOFY2SDkuMzk3bC41MTctLjUyTDkgNC41NzJWM0g3LjQxOUw2LjQxMyAyaDMuMjI4TDEzIDV6IiBpZD0iaWNvbkJnIi8+PHBhdGggY2xhc3M9Imljb24tdnMtZmciIGQ9Ik03LjQxOSAzSDl2MS41NzJMNy40MTkgM3ptMS45NzggM0w2LjQxNiA5SDR2NGg4VjZIOS4zOTd6IiBpZD0iaWNvbkZnIiBzdHlsZT0iZGlzcGxheTogbm9uZTsiLz48cGF0aCBjbGFzcz0iaWNvbi12cy1hY3Rpb24tYmx1ZSIgZD0iTTUuOTg4IDZIMy41YTIuNSAyLjUgMCAxIDEgMC01SDR2MWgtLjVDMi42NzMgMiAyIDIuNjczIDIgMy41UzIuNjczIDUgMy41IDVoMi41MTNMNCAzaDJsMi41IDIuNDg0TDYgOEg0bDEuOTg4LTJ6IiBpZD0iY29sb3JBY3Rpb24iLz48L3N2Zz4=\"); }\n\n.monaco-editor.vs-dark .suggest-widget .monaco-list .monaco-list-row .icon.snippet,\n.monaco-editor.hc-black .suggest-widget .monaco-list .monaco-list-row .icon.snippet { background-image: url(\"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjxzdmcKICAgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIgogICB4bWxuczpjYz0iaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbnMjIgogICB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiCiAgIHhtbG5zOnN2Zz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIKICAgdmVyc2lvbj0iMS4xIgogICBpZD0ic3ZnNDY5NCIKICAgdmlld0JveD0iMCAwIDE2IDE2Ij4KICA8bWV0YWRhdGEKICAgICBpZD0ibWV0YWRhdGE0NzA1Ij4KICAgIDxyZGY6UkRGPgogICAgICA8Y2M6V29yawogICAgICAgICByZGY6YWJvdXQ9IiI+CiAgICAgICAgPGRjOmZvcm1hdD5pbWFnZS9zdmcreG1sPC9kYzpmb3JtYXQ+CiAgICAgICAgPGRjOnR5cGUKICAgICAgICAgICByZGY6cmVzb3VyY2U9Imh0dHA6Ly9wdXJsLm9yZy9kYy9kY21pdHlwZS9TdGlsbEltYWdlIiAvPgogICAgICAgIDxkYzp0aXRsZT48L2RjOnRpdGxlPgogICAgICA8L2NjOldvcms+CiAgICA8L3JkZjpSREY+CiAgPC9tZXRhZGF0YT4KICA8ZGVmcwogICAgIGlkPSJkZWZzNDcwMyIgLz4KICA8c3R5bGUKICAgICBpZD0ic3R5bGU0Njk2Ij4uaWNvbi1jYW52YXMtdHJhbnNwYXJlbnR7b3BhY2l0eTowO2ZpbGw6I2Y2ZjZmNn0uaWNvbi12cy1vdXR7ZmlsbDojZjZmNmY2fS5pY29uLXZzLWFjdGlvbi1vcmFuZ2V7ZmlsbDojYzI3ZDFhfTwvc3R5bGU+CiAgPGcKICAgICBpZD0iZzQ3MjQiCiAgICAgdHJhbnNmb3JtPSJtYXRyaXgoMS4zMzMzMzMzLDAsMCwxLjMzMzMzMzMsLTI0NS45OTk5OSwtMzEuOTk5OTk5KSI+CiAgICA8cGF0aAogICAgICAgZD0ibSAxODUsMjQgMTEsMCAwLDEyIC0xMSwwIHoiCiAgICAgICBpZD0icGF0aDQ1MjgiCiAgICAgICBzdHlsZT0iZmlsbDojMmQyZDMwIiAvPgogICAgPHBhdGgKICAgICAgIGQ9Im0gMTk0LDMzIDAsLTcgLTcsMCAwLDcgLTEsMCAwLC04IDksMCAwLDggeiBtIC04LDEgMSwwIDAsMSAtMSwwIHogbSAyLDAgMSwwIDAsMSAtMSwwIHogbSAyLDAgMSwwIDAsMSAtMSwwIHogbSAyLDAgMSwwIDAsMSAtMSwwIHogbSAyLDAgMSwwIDAsMSAtMSwwIHoiCiAgICAgICBpZD0icGF0aDQ1MzAiCiAgICAgICBzdHlsZT0iZmlsbDojYzVjNWM1IiAvPgogICAgPHBhdGgKICAgICAgIGQ9Im0gMTg3LDI2IDcsMCAwLDcgLTcsMCB6IgogICAgICAgaWQ9InBhdGg0NTMyIgogICAgICAgc3R5bGU9ImZpbGw6IzJiMjgyZSIgLz4KICA8L2c+Cjwvc3ZnPgo=\"); }\n\n.monaco-editor.vs-dark .suggest-widget .monaco-list .monaco-list-row .icon.customcolor,\n.monaco-editor.hc-black .suggest-widget .monaco-list .monaco-list-row .icon.customcolor { background-image: none; }\n\n.monaco-editor.vs-dark .suggest-widget .monaco-list .monaco-list-row .icon.folder,\n.monaco-editor.hc-black .suggest-widget .monaco-list .monaco-list-row .icon.folder { background-image: url(\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgaGVpZ2h0PSIxNiI+PHN0eWxlIHR5cGU9InRleHQvY3NzIj4uaWNvbi1jYW52YXMtdHJhbnNwYXJlbnR7b3BhY2l0eTowO2ZpbGw6I0Y2RjZGNjt9IC5pY29uLXZzLW91dHtvcGFjaXR5OjA7ZmlsbDojRjZGNkY2O30gLmljb24tdnMtZmd7b3BhY2l0eTowO2ZpbGw6I0YwRUZGMTt9IC5pY29uLWZvbGRlcntmaWxsOiNDNUM1QzU7fTwvc3R5bGU+PHBhdGggY2xhc3M9Imljb24tY2FudmFzLXRyYW5zcGFyZW50IiBkPSJNMTYgMTZoLTE2di0xNmgxNnYxNnoiIGlkPSJjYW52YXMiLz48cGF0aCBjbGFzcz0iaWNvbi12cy1vdXQiIGQ9Ik0xNiAyLjV2MTBjMCAuODI3LS42NzMgMS41LTEuNSAxLjVoLTExLjk5NmMtLjgyNyAwLTEuNS0uNjczLTEuNS0xLjV2LThjMC0uODI3LjY3My0xLjUgMS41LTEuNWgyLjg4NmwxLTJoOC4xMWMuODI3IDAgMS41LjY3MyAxLjUgMS41eiIgaWQ9Im91dGxpbmUiLz48cGF0aCBjbGFzcz0iaWNvbi1mb2xkZXIiIGQ9Ik0xNC41IDJoLTcuNDkybC0xIDJoLTMuNTA0Yy0uMjc3IDAtLjUuMjI0LS41LjV2OGMwIC4yNzYuMjIzLjUuNS41aDExLjk5NmMuMjc1IDAgLjUtLjIyNC41LS41di0xMGMwLS4yNzYtLjIyNS0uNS0uNS0uNXptLS40OTYgMmgtNi40OTZsLjUtMWg1Ljk5NnYxeiIgaWQ9Imljb25CZyIvPjxwYXRoIGNsYXNzPSJpY29uLXZzLWZnIiBkPSJNMTQgM3YxaC02LjVsLjUtMWg2eiIgaWQ9Imljb25GZyIvPjwvc3ZnPg==\"); }\n";
  const element$o = ((css, src) => {
if (typeof document !== 'object')
console.info(`Skipped loading "${src}"`);
try {
const id = src
  .replace(/\.css.*$/, '')
  .replace(/[\\:]/g, '/')
  .replace(/[^\w\/]+/g, '');
return (
  document.querySelector(`style[id="${id}"]`) ||
  document.head.appendChild(
    Object.assign(document.createElement('style'), {
      id,
      textContent: `${css}\n\n /* sourceURL=${src} */`,
    }),
  )
);
} catch (exception) {
console.warn(`Failed load "${src}"`, exception);
}
})(css$o, "…monaco-editor/esm/vs/editor/contrib/suggest/media/suggest.css");
  //@ sourceURL=/Users/daflair/Projects/packages/monaco-es/node_modules/monaco-editor/esm/vs/editor/contrib/suggest/media/suggest.css

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __assign = (undefined && undefined.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
var __decorate$o = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$o = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var expandSuggestionDocsByDefault = false;
var maxSuggestionsToShow = 12;
/**
 * Suggest widget colors
 */
var editorSuggestWidgetBackground = registerColor('editorSuggestWidget.background', { dark: editorWidgetBackground, light: editorWidgetBackground, hc: editorWidgetBackground }, localize('editorSuggestWidgetBackground', 'Background color of the suggest widget.'));
var editorSuggestWidgetBorder = registerColor('editorSuggestWidget.border', { dark: editorWidgetBorder, light: editorWidgetBorder, hc: editorWidgetBorder }, localize('editorSuggestWidgetBorder', 'Border color of the suggest widget.'));
var editorSuggestWidgetForeground = registerColor('editorSuggestWidget.foreground', { dark: editorForeground, light: editorForeground, hc: editorForeground }, localize('editorSuggestWidgetForeground', 'Foreground color of the suggest widget.'));
var editorSuggestWidgetSelectedBackground = registerColor('editorSuggestWidget.selectedBackground', { dark: listFocusBackground, light: listFocusBackground, hc: listFocusBackground }, localize('editorSuggestWidgetSelectedBackground', 'Background color of the selected entry in the suggest widget.'));
var editorSuggestWidgetHighlightForeground = registerColor('editorSuggestWidget.highlightForeground', { dark: listHighlightForeground, light: listHighlightForeground, hc: listHighlightForeground }, localize('editorSuggestWidgetHighlightForeground', 'Color of the match highlights in the suggest widget.'));
var colorRegExp = /^(#([\da-f]{3}){1,2}|(rgb|hsl)a\(\s*(\d{1,3}%?\s*,\s*){3}(1|0?\.\d+)\)|(rgb|hsl)\(\s*\d{1,3}%?(\s*,\s*\d{1,3}%?){2}\s*\))$/i;
function matchesColor(text) {
    return text && text.match(colorRegExp) ? text : null;
}
function canExpandCompletionItem(item) {
    if (!item) {
        return false;
    }
    var suggestion = item.suggestion;
    if (suggestion.documentation) {
        return true;
    }
    return (suggestion.detail && suggestion.detail !== suggestion.label);
}
var Renderer$2 = /** @class */ (function () {
    function Renderer(widget, editor, triggerKeybindingLabel) {
        this.widget = widget;
        this.editor = editor;
        this.triggerKeybindingLabel = triggerKeybindingLabel;
    }
    Object.defineProperty(Renderer.prototype, "templateId", {
        get: function () {
            return 'suggestion';
        },
        enumerable: true,
        configurable: true
    });
    Renderer.prototype.renderTemplate = function (container) {
        var _this = this;
        var data = Object.create(null);
        data.disposables = [];
        data.root = container;
        data.icon = append(container, $('.icon'));
        data.colorspan = append(data.icon, $('span.colorspan'));
        var text = append(container, $('.contents'));
        var main = append(text, $('.main'));
        data.highlightedLabel = new HighlightedLabel(main);
        data.disposables.push(data.highlightedLabel);
        data.typeLabel = append(main, $('span.type-label'));
        data.readMore = append(main, $('span.readMore'));
        data.readMore.title = localize('readMore', "Read More...{0}", this.triggerKeybindingLabel);
        var configureFont = function () {
            var configuration = _this.editor.getConfiguration();
            var fontFamily = configuration.fontInfo.fontFamily;
            var fontSize = configuration.contribInfo.suggestFontSize || configuration.fontInfo.fontSize;
            var lineHeight = configuration.contribInfo.suggestLineHeight || configuration.fontInfo.lineHeight;
            var fontSizePx = fontSize + "px";
            var lineHeightPx = lineHeight + "px";
            data.root.style.fontSize = fontSizePx;
            main.style.fontFamily = fontFamily;
            main.style.lineHeight = lineHeightPx;
            data.icon.style.height = lineHeightPx;
            data.icon.style.width = lineHeightPx;
            data.readMore.style.height = lineHeightPx;
            data.readMore.style.width = lineHeightPx;
        };
        configureFont();
        chain(this.editor.onDidChangeConfiguration.bind(this.editor))
            .filter(function (e) { return e.fontInfo || e.contribInfo; })
            .on(configureFont, null, data.disposables);
        return data;
    };
    Renderer.prototype.renderElement = function (element, index, templateData) {
        var _this = this;
        var data = templateData;
        var suggestion = element.suggestion;
        if (canExpandCompletionItem(element)) {
            data.root.setAttribute('aria-label', localize('suggestionWithDetailsAriaLabel', "{0}, suggestion, has details", suggestion.label));
        }
        else {
            data.root.setAttribute('aria-label', localize('suggestionAriaLabel', "{0}, suggestion", suggestion.label));
        }
        data.icon.className = 'icon ' + suggestion.type;
        data.colorspan.style.backgroundColor = '';
        if (suggestion.type === 'color') {
            var color = matchesColor(suggestion.label) || typeof suggestion.documentation === 'string' && matchesColor(suggestion.documentation);
            if (color) {
                data.icon.className = 'icon customcolor';
                data.colorspan.style.backgroundColor = color;
            }
        }
        data.highlightedLabel.set(suggestion.label, createMatches(element.matches));
        // data.highlightedLabel.set(`${suggestion.label} <${element.score}=score(${element.word}, ${suggestion.filterText || suggestion.label})>`, createMatches(element.matches));
        data.typeLabel.textContent = (suggestion.detail || '').replace(/\n.*$/m, '');
        if (canExpandCompletionItem(element)) {
            show(data.readMore);
            data.readMore.onmousedown = function (e) {
                e.stopPropagation();
                e.preventDefault();
            };
            data.readMore.onclick = function (e) {
                e.stopPropagation();
                e.preventDefault();
                _this.widget.toggleDetails();
            };
        }
        else {
            hide(data.readMore);
            data.readMore.onmousedown = null;
            data.readMore.onclick = null;
        }
    };
    Renderer.prototype.disposeTemplate = function (templateData) {
        templateData.disposables = dispose(templateData.disposables);
    };
    return Renderer;
}());
var SuggestionDetails = /** @class */ (function () {
    function SuggestionDetails(container, widget, editor, markdownRenderer, triggerKeybindingLabel) {
        var _this = this;
        this.widget = widget;
        this.editor = editor;
        this.markdownRenderer = markdownRenderer;
        this.triggerKeybindingLabel = triggerKeybindingLabel;
        this.borderWidth = 1;
        this.disposables = [];
        this.el = append(container, $('.details'));
        this.disposables.push(toDisposable(function () { return container.removeChild(_this.el); }));
        this.body = $('.body');
        this.scrollbar = new DomScrollableElement(this.body, {});
        append(this.el, this.scrollbar.getDomNode());
        this.disposables.push(this.scrollbar);
        this.header = append(this.body, $('.header'));
        this.close = append(this.header, $('span.close'));
        this.close.title = localize('readLess', "Read less...{0}", this.triggerKeybindingLabel);
        this.type = append(this.header, $('p.type'));
        this.docs = append(this.body, $('p.docs'));
        this.ariaLabel = null;
        this.configureFont();
        chain(this.editor.onDidChangeConfiguration.bind(this.editor))
            .filter(function (e) { return e.fontInfo; })
            .on(this.configureFont, this, this.disposables);
    }
    Object.defineProperty(SuggestionDetails.prototype, "element", {
        get: function () {
            return this.el;
        },
        enumerable: true,
        configurable: true
    });
    SuggestionDetails.prototype.render = function (item) {
        var _this = this;
        this.renderDisposeable = dispose(this.renderDisposeable);
        if (!item || !canExpandCompletionItem(item)) {
            this.type.textContent = '';
            this.docs.textContent = '';
            addClass(this.el, 'no-docs');
            this.ariaLabel = null;
            return;
        }
        removeClass(this.el, 'no-docs');
        if (typeof item.suggestion.documentation === 'string') {
            removeClass(this.docs, 'markdown-docs');
            this.docs.textContent = item.suggestion.documentation;
        }
        else {
            addClass(this.docs, 'markdown-docs');
            this.docs.innerHTML = '';
            var renderedContents = this.markdownRenderer.render(item.suggestion.documentation);
            this.renderDisposeable = renderedContents;
            this.docs.appendChild(renderedContents.element);
        }
        if (item.suggestion.detail) {
            this.type.innerText = item.suggestion.detail;
            show(this.type);
        }
        else {
            this.type.innerText = '';
            hide(this.type);
        }
        this.el.style.height = this.header.offsetHeight + this.docs.offsetHeight + (this.borderWidth * 2) + 'px';
        this.close.onmousedown = function (e) {
            e.preventDefault();
            e.stopPropagation();
        };
        this.close.onclick = function (e) {
            e.preventDefault();
            e.stopPropagation();
            _this.widget.toggleDetails();
        };
        this.body.scrollTop = 0;
        this.scrollbar.scanDomNode();
        this.ariaLabel = format('{0}\n{1}\n{2}', item.suggestion.label || '', item.suggestion.detail || '', item.suggestion.documentation || '');
    };
    SuggestionDetails.prototype.getAriaLabel = function () {
        return this.ariaLabel;
    };
    SuggestionDetails.prototype.scrollDown = function (much) {
        if (much === void 0) { much = 8; }
        this.body.scrollTop += much;
    };
    SuggestionDetails.prototype.scrollUp = function (much) {
        if (much === void 0) { much = 8; }
        this.body.scrollTop -= much;
    };
    SuggestionDetails.prototype.scrollTop = function () {
        this.body.scrollTop = 0;
    };
    SuggestionDetails.prototype.scrollBottom = function () {
        this.body.scrollTop = this.body.scrollHeight;
    };
    SuggestionDetails.prototype.pageDown = function () {
        this.scrollDown(80);
    };
    SuggestionDetails.prototype.pageUp = function () {
        this.scrollUp(80);
    };
    SuggestionDetails.prototype.setBorderWidth = function (width) {
        this.borderWidth = width;
    };
    SuggestionDetails.prototype.configureFont = function () {
        var configuration = this.editor.getConfiguration();
        var fontFamily = configuration.fontInfo.fontFamily;
        var fontSize = configuration.contribInfo.suggestFontSize || configuration.fontInfo.fontSize;
        var lineHeight = configuration.contribInfo.suggestLineHeight || configuration.fontInfo.lineHeight;
        var fontSizePx = fontSize + "px";
        var lineHeightPx = lineHeight + "px";
        this.el.style.fontSize = fontSizePx;
        this.type.style.fontFamily = fontFamily;
        this.close.style.height = lineHeightPx;
        this.close.style.width = lineHeightPx;
    };
    SuggestionDetails.prototype.dispose = function () {
        this.disposables = dispose(this.disposables);
        this.renderDisposeable = dispose(this.renderDisposeable);
    };
    return SuggestionDetails;
}());
var SuggestWidget = /** @class */ (function () {
    function SuggestWidget(editor, telemetryService, contextKeyService, themeService, storageService, keybindingService, modeService, openerService) {
        var _this = this;
        this.editor = editor;
        this.telemetryService = telemetryService;
        // Editor.IContentWidget.allowEditorOverflow
        this.allowEditorOverflow = true;
        this.ignoreFocusEvents = false;
        this.onDidSelectEmitter = new Emitter();
        this.onDidFocusEmitter = new Emitter();
        this.onDidHideEmitter = new Emitter();
        this.onDidShowEmitter = new Emitter();
        this.onDidSelect = this.onDidSelectEmitter.event;
        this.onDidFocus = this.onDidFocusEmitter.event;
        this.onDidHide = this.onDidHideEmitter.event;
        this.onDidShow = this.onDidShowEmitter.event;
        this.maxWidgetWidth = 660;
        this.listWidth = 330;
        this.storageServiceAvailable = true;
        this.expandSuggestionDocs = false;
        var kb = keybindingService.lookupKeybinding('editor.action.triggerSuggest');
        var triggerKeybindingLabel = !kb ? '' : " (" + kb.getLabel() + ")";
        var markdownRenderer = new MarkdownRenderer(editor, modeService, openerService);
        this.isAuto = false;
        this.focusedItem = null;
        this.storageService = storageService;
        if (this.expandDocsSettingFromStorage() === undefined) {
            this.storageService.store('expandSuggestionDocs', expandSuggestionDocsByDefault, StorageScope.GLOBAL);
            if (this.expandDocsSettingFromStorage() === undefined) {
                this.storageServiceAvailable = false;
            }
        }
        this.element = $('.editor-widget.suggest-widget');
        if (!this.editor.getConfiguration().contribInfo.iconsInSuggestions) {
            addClass(this.element, 'no-icons');
        }
        this.messageElement = append(this.element, $('.message'));
        this.listElement = append(this.element, $('.tree'));
        this.details = new SuggestionDetails(this.element, this, this.editor, markdownRenderer, triggerKeybindingLabel);
        var renderer = new Renderer$2(this, this.editor, triggerKeybindingLabel);
        this.list = new List(this.listElement, this, [renderer], {
            useShadows: false,
            selectOnMouseDown: true,
            focusOnMouseDown: false,
            openController: { shouldOpen: function () { return false; } }
        });
        this.toDispose = [
            attachListStyler(this.list, themeService, {
                listInactiveFocusBackground: editorSuggestWidgetSelectedBackground,
                listInactiveFocusOutline: activeContrastBorder
            }),
            themeService.onThemeChange(function (t) { return _this.onThemeChange(t); }),
            editor.onDidBlurEditorText(function () { return _this.onEditorBlur(); }),
            editor.onDidLayoutChange(function () { return _this.onEditorLayoutChange(); }),
            this.list.onSelectionChange(function (e) { return _this.onListSelection(e); }),
            this.list.onFocusChange(function (e) { return _this.onListFocus(e); }),
            this.editor.onDidChangeCursorSelection(function () { return _this.onCursorSelectionChanged(); })
        ];
        this.suggestWidgetVisible = Context$1.Visible.bindTo(contextKeyService);
        this.suggestWidgetMultipleSuggestions = Context$1.MultipleSuggestions.bindTo(contextKeyService);
        this.suggestionSupportsAutoAccept = Context$1.AcceptOnKey.bindTo(contextKeyService);
        this.editor.addContentWidget(this);
        this.setState(0 /* Hidden */);
        this.onThemeChange(themeService.getTheme());
        // TODO@Alex: this is useful, but spammy
        // var isVisible = false;
        // this.onDidVisibilityChange((newIsVisible) => {
        // 	if (isVisible === newIsVisible) {
        // 		return;
        // 	}
        // 	isVisible = newIsVisible;
        // 	if (isVisible) {
        // 		alert(nls.localize('suggestWidgetAriaVisible', "Suggestions opened"));
        // 	} else {
        // 		alert(nls.localize('suggestWidgetAriaInvisible', "Suggestions closed"));
        // 	}
        // });
    }
    SuggestWidget.prototype.onCursorSelectionChanged = function () {
        if (this.state === 0 /* Hidden */) {
            return;
        }
        this.editor.layoutContentWidget(this);
    };
    SuggestWidget.prototype.onEditorBlur = function () {
        var _this = this;
        this.editorBlurTimeout = TPromise.timeout(150).then(function () {
            if (!_this.editor.isFocused()) {
                _this.setState(0 /* Hidden */);
            }
        });
    };
    SuggestWidget.prototype.onEditorLayoutChange = function () {
        if ((this.state === 3 /* Open */ || this.state === 5 /* Details */) && this.expandDocsSettingFromStorage()) {
            this.expandSideOrBelow();
        }
    };
    SuggestWidget.prototype.onListSelection = function (e) {
        var _this = this;
        if (!e.elements.length) {
            return;
        }
        var item = e.elements[0];
        var index = e.indexes[0];
        item.resolve().then(function () {
            _this.onDidSelectEmitter.fire({ item: item, index: index, model: _this.completionModel });
            alert(localize('suggestionAriaAccepted', "{0}, accepted", item.suggestion.label));
            _this.editor.focus();
        });
    };
    SuggestWidget.prototype._getSuggestionAriaAlertLabel = function (item) {
        if (canExpandCompletionItem(item)) {
            return localize('ariaCurrentSuggestionWithDetails', "{0}, suggestion, has details", item.suggestion.label);
        }
        else {
            return localize('ariaCurrentSuggestion', "{0}, suggestion", item.suggestion.label);
        }
    };
    SuggestWidget.prototype._ariaAlert = function (newAriaAlertLabel) {
        if (this._lastAriaAlertLabel === newAriaAlertLabel) {
            return;
        }
        this._lastAriaAlertLabel = newAriaAlertLabel;
        if (this._lastAriaAlertLabel) {
            alert(this._lastAriaAlertLabel);
        }
    };
    SuggestWidget.prototype.onThemeChange = function (theme) {
        var backgroundColor = theme.getColor(editorSuggestWidgetBackground);
        if (backgroundColor) {
            this.listElement.style.backgroundColor = backgroundColor.toString();
            this.details.element.style.backgroundColor = backgroundColor.toString();
            this.messageElement.style.backgroundColor = backgroundColor.toString();
        }
        var borderColor = theme.getColor(editorSuggestWidgetBorder);
        if (borderColor) {
            this.listElement.style.borderColor = borderColor.toString();
            this.details.element.style.borderColor = borderColor.toString();
            this.messageElement.style.borderColor = borderColor.toString();
            this.detailsBorderColor = borderColor.toString();
        }
        var focusBorderColor = theme.getColor(focusBorder);
        if (focusBorderColor) {
            this.detailsFocusBorderColor = focusBorderColor.toString();
        }
        this.details.setBorderWidth(theme.type === 'hc' ? 2 : 1);
    };
    SuggestWidget.prototype.onListFocus = function (e) {
        var _this = this;
        if (this.ignoreFocusEvents) {
            return;
        }
        if (!e.elements.length) {
            if (this.currentSuggestionDetails) {
                this.currentSuggestionDetails.cancel();
                this.currentSuggestionDetails = null;
                this.focusedItem = null;
            }
            this._ariaAlert(null);
            return;
        }
        var item = e.elements[0];
        this._ariaAlert(this._getSuggestionAriaAlertLabel(item));
        if (item === this.focusedItem) {
            return;
        }
        if (this.currentSuggestionDetails) {
            this.currentSuggestionDetails.cancel();
            this.currentSuggestionDetails = null;
        }
        var index = e.indexes[0];
        this.suggestionSupportsAutoAccept.set(!item.suggestion.noAutoAccept);
        this.focusedItem = item;
        this.list.reveal(index);
        this.currentSuggestionDetails = item.resolve()
            .then(function () {
            // item can have extra information, so re-render
            _this.ignoreFocusEvents = true;
            _this.list.splice(index, 1, [item]);
            _this.list.setFocus([index]);
            _this.ignoreFocusEvents = false;
            if (_this.expandDocsSettingFromStorage()) {
                _this.showDetails();
            }
            else {
                removeClass(_this.element, 'docs-side');
            }
        })
            .then(null, function (err) { return !isPromiseCanceledError(err) && onUnexpectedError(err); })
            .then(function () { return _this.currentSuggestionDetails = null; });
        // emit an event
        this.onDidFocusEmitter.fire({ item: item, index: index, model: this.completionModel });
    };
    SuggestWidget.prototype.setState = function (state) {
        if (!this.element) {
            return;
        }
        var stateChanged = this.state !== state;
        this.state = state;
        toggleClass(this.element, 'frozen', state === 4 /* Frozen */);
        switch (state) {
            case 0 /* Hidden */:
                hide(this.messageElement, this.details.element, this.listElement);
                this.hide();
                this.listHeight = 0;
                if (stateChanged) {
                    this.list.splice(0, this.list.length);
                }
                break;
            case 1 /* Loading */:
                this.messageElement.textContent = SuggestWidget.LOADING_MESSAGE;
                hide(this.listElement, this.details.element);
                show(this.messageElement);
                removeClass(this.element, 'docs-side');
                this.show();
                break;
            case 2 /* Empty */:
                this.messageElement.textContent = SuggestWidget.NO_SUGGESTIONS_MESSAGE;
                hide(this.listElement, this.details.element);
                show(this.messageElement);
                removeClass(this.element, 'docs-side');
                this.show();
                break;
            case 3 /* Open */:
                hide(this.messageElement, this.details.element);
                show(this.listElement);
                this.show();
                break;
            case 4 /* Frozen */:
                hide(this.messageElement);
                show(this.listElement);
                this.show();
                break;
            case 5 /* Details */:
                hide(this.messageElement);
                show(this.details.element, this.listElement);
                this.show();
                this._ariaAlert(this.details.getAriaLabel());
                break;
        }
    };
    SuggestWidget.prototype.showTriggered = function (auto) {
        var _this = this;
        if (this.state !== 0 /* Hidden */) {
            return;
        }
        this.isAuto = !!auto;
        if (!this.isAuto) {
            this.loadingTimeout = setTimeout(function () {
                _this.loadingTimeout = null;
                _this.setState(1 /* Loading */);
            }, 50);
        }
    };
    SuggestWidget.prototype.showSuggestions = function (completionModel, selectionIndex, isFrozen, isAuto) {
        if (this.loadingTimeout) {
            clearTimeout(this.loadingTimeout);
            this.loadingTimeout = null;
        }
        this.completionModel = completionModel;
        if (isFrozen && this.state !== 2 /* Empty */ && this.state !== 0 /* Hidden */) {
            this.setState(4 /* Frozen */);
            return;
        }
        var visibleCount = this.completionModel.items.length;
        var isEmpty = visibleCount === 0;
        this.suggestWidgetMultipleSuggestions.set(visibleCount > 1);
        if (isEmpty) {
            if (isAuto) {
                this.setState(0 /* Hidden */);
            }
            else {
                this.setState(2 /* Empty */);
            }
            this.completionModel = null;
        }
        else {
            var stats = this.completionModel.stats;
            stats['wasAutomaticallyTriggered'] = !!isAuto;
            /* __GDPR__
                "suggestWidget" : {
                    "wasAutomaticallyTriggered" : { "classification": "SystemMetaData", "purpose": "FeatureInsight", "isMeasurement": true },
                    "${include}": [
                        "${ICompletionStats}",
                        "${EditorTelemetryData}"
                    ]
                }
            */
            this.telemetryService.publicLog('suggestWidget', __assign({}, stats, this.editor.getTelemetryData()));
            this.focusedItem = null;
            this.list.splice(0, this.list.length, this.completionModel.items);
            if (isFrozen) {
                this.setState(4 /* Frozen */);
            }
            else {
                this.setState(3 /* Open */);
            }
            this.list.reveal(selectionIndex, selectionIndex);
            this.list.setFocus([selectionIndex]);
            // Reset focus border
            if (this.detailsBorderColor) {
                this.details.element.style.borderColor = this.detailsBorderColor;
            }
        }
    };
    SuggestWidget.prototype.selectNextPage = function () {
        switch (this.state) {
            case 0 /* Hidden */:
                return false;
            case 5 /* Details */:
                this.details.pageDown();
                return true;
            case 1 /* Loading */:
                return !this.isAuto;
            default:
                this.list.focusNextPage();
                return true;
        }
    };
    SuggestWidget.prototype.selectNext = function () {
        switch (this.state) {
            case 0 /* Hidden */:
                return false;
            case 1 /* Loading */:
                return !this.isAuto;
            default:
                this.list.focusNext(1, true);
                return true;
        }
    };
    SuggestWidget.prototype.selectLast = function () {
        switch (this.state) {
            case 0 /* Hidden */:
                return false;
            case 5 /* Details */:
                this.details.scrollBottom();
                return true;
            case 1 /* Loading */:
                return !this.isAuto;
            default:
                this.list.focusLast();
                return true;
        }
    };
    SuggestWidget.prototype.selectPreviousPage = function () {
        switch (this.state) {
            case 0 /* Hidden */:
                return false;
            case 5 /* Details */:
                this.details.pageUp();
                return true;
            case 1 /* Loading */:
                return !this.isAuto;
            default:
                this.list.focusPreviousPage();
                return true;
        }
    };
    SuggestWidget.prototype.selectPrevious = function () {
        switch (this.state) {
            case 0 /* Hidden */:
                return false;
            case 1 /* Loading */:
                return !this.isAuto;
            default:
                this.list.focusPrevious(1, true);
                return false;
        }
    };
    SuggestWidget.prototype.selectFirst = function () {
        switch (this.state) {
            case 0 /* Hidden */:
                return false;
            case 5 /* Details */:
                this.details.scrollTop();
                return true;
            case 1 /* Loading */:
                return !this.isAuto;
            default:
                this.list.focusFirst();
                return true;
        }
    };
    SuggestWidget.prototype.getFocusedItem = function () {
        if (this.state !== 0 /* Hidden */
            && this.state !== 2 /* Empty */
            && this.state !== 1 /* Loading */) {
            return {
                item: this.list.getFocusedElements()[0],
                index: this.list.getFocus()[0],
                model: this.completionModel
            };
        }
        return undefined;
    };
    SuggestWidget.prototype.toggleDetailsFocus = function () {
        if (this.state === 5 /* Details */) {
            this.setState(3 /* Open */);
            if (this.detailsBorderColor) {
                this.details.element.style.borderColor = this.detailsBorderColor;
            }
        }
        else if (this.state === 3 /* Open */ && this.expandDocsSettingFromStorage()) {
            this.setState(5 /* Details */);
            if (this.detailsFocusBorderColor) {
                this.details.element.style.borderColor = this.detailsFocusBorderColor;
            }
        }
        /* __GDPR__
            "suggestWidget:toggleDetailsFocus" : {
                "${include}": [
                    "${EditorTelemetryData}"
                ]
            }
        */
        this.telemetryService.publicLog('suggestWidget:toggleDetailsFocus', this.editor.getTelemetryData());
    };
    SuggestWidget.prototype.toggleDetails = function () {
        if (!canExpandCompletionItem(this.list.getFocusedElements()[0])) {
            return;
        }
        if (this.expandDocsSettingFromStorage()) {
            this.updateExpandDocsSetting(false);
            hide(this.details.element);
            removeClass(this.element, 'docs-side');
            removeClass(this.element, 'docs-below');
            this.editor.layoutContentWidget(this);
            /* __GDPR__
                "suggestWidget:collapseDetails" : {
                    "${include}": [
                        "${EditorTelemetryData}"
                    ]
                }
            */
            this.telemetryService.publicLog('suggestWidget:collapseDetails', this.editor.getTelemetryData());
        }
        else {
            if (this.state !== 3 /* Open */ && this.state !== 5 /* Details */) {
                return;
            }
            this.updateExpandDocsSetting(true);
            this.showDetails();
            /* __GDPR__
                "suggestWidget:expandDetails" : {
                    "${include}": [
                        "${EditorTelemetryData}"
                    ]
                }
            */
            this.telemetryService.publicLog('suggestWidget:expandDetails', this.editor.getTelemetryData());
        }
    };
    SuggestWidget.prototype.showDetails = function () {
        this.expandSideOrBelow();
        show(this.details.element);
        this.details.render(this.list.getFocusedElements()[0]);
        this.details.element.style.maxHeight = this.maxWidgetHeight + 'px';
        // Reset margin-top that was set as Fix for #26416
        this.listElement.style.marginTop = '0px';
        // with docs showing up widget width/height may change, so reposition the widget
        this.editor.layoutContentWidget(this);
        this.adjustDocsPosition();
        this.editor.focus();
        this._ariaAlert(this.details.getAriaLabel());
    };
    SuggestWidget.prototype.show = function () {
        var _this = this;
        var newHeight = this.updateListHeight();
        if (newHeight !== this.listHeight) {
            this.editor.layoutContentWidget(this);
            this.listHeight = newHeight;
        }
        this.suggestWidgetVisible.set(true);
        this.showTimeout = TPromise.timeout(100).then(function () {
            addClass(_this.element, 'visible');
            _this.onDidShowEmitter.fire(_this);
        });
    };
    SuggestWidget.prototype.hide = function () {
        this.suggestWidgetVisible.reset();
        this.suggestWidgetMultipleSuggestions.reset();
        removeClass(this.element, 'visible');
    };
    SuggestWidget.prototype.hideWidget = function () {
        clearTimeout(this.loadingTimeout);
        this.setState(0 /* Hidden */);
        this.onDidHideEmitter.fire(this);
    };
    SuggestWidget.prototype.getPosition = function () {
        if (this.state === 0 /* Hidden */) {
            return null;
        }
        return {
            position: this.editor.getPosition(),
            preference: [ContentWidgetPositionPreference.BELOW, ContentWidgetPositionPreference.ABOVE]
        };
    };
    SuggestWidget.prototype.getDomNode = function () {
        return this.element;
    };
    SuggestWidget.prototype.getId = function () {
        return SuggestWidget.ID;
    };
    SuggestWidget.prototype.updateListHeight = function () {
        var height = 0;
        if (this.state === 2 /* Empty */ || this.state === 1 /* Loading */) {
            height = this.unfocusedHeight;
        }
        else {
            var suggestionCount = this.list.contentHeight / this.unfocusedHeight;
            height = Math.min(suggestionCount, maxSuggestionsToShow) * this.unfocusedHeight;
        }
        this.element.style.lineHeight = this.unfocusedHeight + "px";
        this.listElement.style.height = height + "px";
        this.list.layout(height);
        return height;
    };
    SuggestWidget.prototype.adjustDocsPosition = function () {
        var lineHeight = this.editor.getConfiguration().fontInfo.lineHeight;
        var cursorCoords = this.editor.getScrolledVisiblePosition(this.editor.getPosition());
        var editorCoords = getDomNodePagePosition(this.editor.getDomNode());
        var cursorX = editorCoords.left + cursorCoords.left;
        var cursorY = editorCoords.top + cursorCoords.top + cursorCoords.height;
        var widgetCoords = getDomNodePagePosition(this.element);
        var widgetX = widgetCoords.left;
        var widgetY = widgetCoords.top;
        if (widgetX < cursorX - this.listWidth) {
            // Widget is too far to the left of cursor, swap list and docs
            addClass(this.element, 'list-right');
        }
        else {
            removeClass(this.element, 'list-right');
        }
        // Compare top of the cursor (cursorY - lineheight) with widgetTop to determine if
        // margin-top needs to be applied on list to make it appear right above the cursor
        // Cannot compare cursorY directly as it may be a few decimals off due to zoooming
        if (hasClass(this.element, 'docs-side')
            && cursorY - lineHeight > widgetY
            && this.details.element.offsetHeight > this.listElement.offsetHeight) {
            // Fix for #26416
            // Docs is bigger than list and widget is above cursor, apply margin-top so that list appears right above cursor
            this.listElement.style.marginTop = this.details.element.offsetHeight - this.listElement.offsetHeight + "px";
        }
    };
    SuggestWidget.prototype.expandSideOrBelow = function () {
        var matches = this.element.style.maxWidth.match(/(\d+)px/);
        if (!matches || Number(matches[1]) < this.maxWidgetWidth) {
            addClass(this.element, 'docs-below');
            removeClass(this.element, 'docs-side');
        }
        else {
            addClass(this.element, 'docs-side');
            removeClass(this.element, 'docs-below');
        }
    };
    Object.defineProperty(SuggestWidget.prototype, "maxWidgetHeight", {
        // Heights
        get: function () {
            return this.unfocusedHeight * maxSuggestionsToShow;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SuggestWidget.prototype, "unfocusedHeight", {
        get: function () {
            var configuration = this.editor.getConfiguration();
            return configuration.contribInfo.suggestLineHeight || configuration.fontInfo.lineHeight;
        },
        enumerable: true,
        configurable: true
    });
    // IDelegate
    SuggestWidget.prototype.getHeight = function (element) {
        return this.unfocusedHeight;
    };
    SuggestWidget.prototype.getTemplateId = function (element) {
        return 'suggestion';
    };
    // Monaco Editor does not have a storage service
    SuggestWidget.prototype.expandDocsSettingFromStorage = function () {
        if (this.storageServiceAvailable) {
            return this.storageService.getBoolean('expandSuggestionDocs', StorageScope.GLOBAL);
        }
        else {
            return this.expandSuggestionDocs;
        }
    };
    // Monaco Editor does not have a storage service
    SuggestWidget.prototype.updateExpandDocsSetting = function (value) {
        if (this.storageServiceAvailable) {
            this.storageService.store('expandSuggestionDocs', value, StorageScope.GLOBAL);
        }
        else {
            this.expandSuggestionDocs = value;
        }
    };
    SuggestWidget.prototype.dispose = function () {
        this.state = null;
        this.suggestionSupportsAutoAccept = null;
        this.currentSuggestionDetails = null;
        this.focusedItem = null;
        this.element = null;
        this.messageElement = null;
        this.listElement = null;
        this.details.dispose();
        this.details = null;
        this.list.dispose();
        this.list = null;
        this.toDispose = dispose(this.toDispose);
        if (this.loadingTimeout) {
            clearTimeout(this.loadingTimeout);
            this.loadingTimeout = null;
        }
        if (this.editorBlurTimeout) {
            this.editorBlurTimeout.cancel();
            this.editorBlurTimeout = null;
        }
        if (this.showTimeout) {
            this.showTimeout.cancel();
            this.showTimeout = null;
        }
    };
    SuggestWidget.ID = 'editor.widget.suggestWidget';
    SuggestWidget.LOADING_MESSAGE = localize('suggestWidget.loading', "Loading...");
    SuggestWidget.NO_SUGGESTIONS_MESSAGE = localize('suggestWidget.noSuggestions', "No suggestions.");
    SuggestWidget = __decorate$o([
        __param$o(1, ITelemetryService),
        __param$o(2, IContextKeyService),
        __param$o(3, IThemeService),
        __param$o(4, IStorageService),
        __param$o(5, IKeybindingService),
        __param$o(6, IModeService),
        __param$o(7, IOpenerService)
    ], SuggestWidget);
    return SuggestWidget;
}());
registerThemingParticipant(function (theme, collector) {
    var matchHighlight = theme.getColor(editorSuggestWidgetHighlightForeground);
    if (matchHighlight) {
        collector.addRule(".monaco-editor .suggest-widget .monaco-list .monaco-list-row .monaco-highlighted-label .highlight { color: " + matchHighlight + "; }");
    }
    var foreground$$1 = theme.getColor(editorSuggestWidgetForeground);
    if (foreground$$1) {
        collector.addRule(".monaco-editor .suggest-widget { color: " + foreground$$1 + "; }");
    }
    var link = theme.getColor(textLinkForeground);
    if (link) {
        collector.addRule(".monaco-editor .suggest-widget a { color: " + link + "; }");
    }
    var codeBackground = theme.getColor(textCodeBlockBackground);
    if (codeBackground) {
        collector.addRule(".monaco-editor .suggest-widget code { background-color: " + codeBackground + "; }");
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$H = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate$p = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$p = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var Memory = /** @class */ (function () {
    function Memory() {
    }
    return Memory;
}());
var NoMemory = /** @class */ (function (_super) {
    __extends$H(NoMemory, _super);
    function NoMemory() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    NoMemory.prototype.memorize = function (model, pos, item) {
        // no-op
    };
    NoMemory.prototype.select = function (model, pos, items) {
        return 0;
    };
    NoMemory.prototype.toJSON = function () {
        return undefined;
    };
    NoMemory.prototype.fromJSON = function () {
        //
    };
    return NoMemory;
}(Memory));
var LRUMemory = /** @class */ (function (_super) {
    __extends$H(LRUMemory, _super);
    function LRUMemory() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._cache = new LRUCache(300, .66);
        _this._seq = 0;
        return _this;
    }
    LRUMemory.prototype.memorize = function (model, pos, item) {
        var label = item.suggestion.label;
        var key = model.getLanguageIdentifier().language + "/" + label;
        this._cache.set(key, {
            touch: this._seq++,
            type: item.suggestion.type,
            insertText: item.suggestion.insertText
        });
    };
    LRUMemory.prototype.select = function (model, pos, items) {
        // in order of completions, select the first
        // that has been used in the past
        var word = model.getWordUntilPosition(pos).word;
        if (word.length !== 0) {
            return 0;
        }
        var lineSuffix = model.getLineContent(pos.lineNumber).substr(pos.column - 10, pos.column - 1);
        if (/\s$/.test(lineSuffix)) {
            return 0;
        }
        var res = 0;
        var seq = -1;
        for (var i = 0; i < items.length; i++) {
            var suggestion = items[i].suggestion;
            var key = model.getLanguageIdentifier().language + "/" + suggestion.label;
            var item = this._cache.get(key);
            if (item && item.touch > seq && item.type === suggestion.type && item.insertText === suggestion.insertText) {
                seq = item.touch;
                res = i;
            }
        }
        return res;
    };
    LRUMemory.prototype.toJSON = function () {
        var data = [];
        this._cache.forEach(function (value, key) {
            data.push([key, value]);
        });
        return data;
    };
    LRUMemory.prototype.fromJSON = function (data) {
        this._cache.clear();
        var seq = 0;
        for (var _i = 0, data_1 = data; _i < data_1.length; _i++) {
            var _a = data_1[_i], key = _a[0], value = _a[1];
            value.touch = seq;
            this._cache.set(key, value);
        }
        this._seq = this._cache.size;
    };
    return LRUMemory;
}(Memory));
var PrefixMemory = /** @class */ (function (_super) {
    __extends$H(PrefixMemory, _super);
    function PrefixMemory() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._trie = TernarySearchTree.forStrings();
        _this._seq = 0;
        return _this;
    }
    PrefixMemory.prototype.memorize = function (model, pos, item) {
        var word = model.getWordUntilPosition(pos).word;
        var key = model.getLanguageIdentifier().language + "/" + word;
        this._trie.set(key, {
            type: item.suggestion.type,
            insertText: item.suggestion.insertText,
            touch: this._seq++
        });
    };
    PrefixMemory.prototype.select = function (model, pos, items) {
        var word = model.getWordUntilPosition(pos).word;
        if (!word) {
            return 0;
        }
        var key = model.getLanguageIdentifier().language + "/" + word;
        var item = this._trie.get(key);
        if (!item) {
            item = this._trie.findSubstr(key);
        }
        if (item) {
            for (var i = 0; i < items.length; i++) {
                var _a = items[i].suggestion, type = _a.type, insertText = _a.insertText;
                if (type === item.type && insertText === item.insertText) {
                    return i;
                }
            }
        }
        return 0;
    };
    PrefixMemory.prototype.toJSON = function () {
        var entries = [];
        this._trie.forEach(function (value, key) { return entries.push([key, value]); });
        // sort by last recently used (touch), then
        // take the top 200 item and normalize their
        // touch
        entries
            .sort(function (a, b) { return -(a[1].touch - b[1].touch); })
            .forEach(function (value, i) { return value[1].touch = i; });
        return entries.slice(0, 200);
    };
    PrefixMemory.prototype.fromJSON = function (data) {
        this._trie.clear();
        if (data.length > 0) {
            this._seq = data[0][1].touch + 1;
            for (var _i = 0, data_2 = data; _i < data_2.length; _i++) {
                var _a = data_2[_i], key = _a[0], value = _a[1];
                this._trie.set(key, value);
            }
        }
    };
    return PrefixMemory;
}(Memory));
var SuggestMemories = /** @class */ (function () {
    function SuggestMemories(mode, _storageService) {
        var _this = this;
        this._storageService = _storageService;
        this._storagePrefix = 'suggest/memories';
        this._persistSoon = new RunOnceScheduler(function () { return _this._flush(); }, 3000);
        this.setMode(mode);
    }
    SuggestMemories.prototype.setMode = function (mode) {
        if (this._mode === mode) {
            return;
        }
        this._mode = mode;
        this._strategy = mode === 'recentlyUsedByPrefix' ? new PrefixMemory() : mode === 'recentlyUsed' ? new LRUMemory() : new NoMemory();
        try {
            var raw = this._storageService.get(this._storagePrefix + "/" + this._mode, StorageScope.WORKSPACE);
            if (raw) {
                this._strategy.fromJSON(JSON.parse(raw));
            }
        }
        catch (e) {
            // things can go wrong with JSON...
        }
    };
    SuggestMemories.prototype.memorize = function (model, pos, item) {
        this._strategy.memorize(model, pos, item);
        this._persistSoon.schedule();
    };
    SuggestMemories.prototype.select = function (model, pos, items) {
        return this._strategy.select(model, pos, items);
    };
    SuggestMemories.prototype._flush = function () {
        var raw = JSON.stringify(this._strategy);
        this._storageService.store(this._storagePrefix + "/" + this._mode, raw, StorageScope.WORKSPACE);
    };
    SuggestMemories = __decorate$p([
        __param$p(1, IStorageService)
    ], SuggestMemories);
    return SuggestMemories;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$I = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate$q = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$q = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var AcceptOnCharacterOracle = /** @class */ (function () {
    function AcceptOnCharacterOracle(editor, widget, accept) {
        var _this = this;
        this._disposables = [];
        this._activeAcceptCharacters = new Set();
        this._disposables.push(widget.onDidShow(function () { return _this._onItem(widget.getFocusedItem()); }));
        this._disposables.push(widget.onDidFocus(this._onItem, this));
        this._disposables.push(widget.onDidHide(this.reset, this));
        this._disposables.push(editor.onWillType(function (text) {
            if (_this._activeItem) {
                var ch = text[text.length - 1];
                if (_this._activeAcceptCharacters.has(ch) && editor.getConfiguration().contribInfo.acceptSuggestionOnCommitCharacter) {
                    accept(_this._activeItem);
                }
            }
        }));
    }
    AcceptOnCharacterOracle.prototype._onItem = function (selected) {
        if (!selected || isFalsyOrEmpty(selected.item.suggestion.commitCharacters)) {
            this.reset();
            return;
        }
        this._activeItem = selected;
        this._activeAcceptCharacters.clear();
        for (var _i = 0, _a = selected.item.suggestion.commitCharacters; _i < _a.length; _i++) {
            var ch = _a[_i];
            if (ch.length > 0) {
                this._activeAcceptCharacters.add(ch[0]);
            }
        }
    };
    AcceptOnCharacterOracle.prototype.reset = function () {
        this._activeItem = undefined;
    };
    AcceptOnCharacterOracle.prototype.dispose = function () {
        dispose(this._disposables);
    };
    return AcceptOnCharacterOracle;
}());
var SuggestController = /** @class */ (function () {
    function SuggestController(_editor, _commandService, _contextKeyService, _instantiationService) {
        var _this = this;
        this._editor = _editor;
        this._commandService = _commandService;
        this._contextKeyService = _contextKeyService;
        this._instantiationService = _instantiationService;
        this._toDispose = [];
        this._model = new SuggestModel(this._editor);
        this._memory = _instantiationService.createInstance(SuggestMemories, this._editor.getConfiguration().contribInfo.suggestSelection);
        this._toDispose.push(this._model.onDidTrigger(function (e) {
            if (!_this._widget) {
                _this._createSuggestWidget();
            }
            _this._widget.showTriggered(e.auto);
        }));
        this._toDispose.push(this._model.onDidSuggest(function (e) {
            var index = _this._memory.select(_this._editor.getModel(), _this._editor.getPosition(), e.completionModel.items);
            _this._widget.showSuggestions(e.completionModel, index, e.isFrozen, e.auto);
        }));
        this._toDispose.push(this._model.onDidCancel(function (e) {
            if (_this._widget && !e.retrigger) {
                _this._widget.hideWidget();
            }
        }));
        // Manage the acceptSuggestionsOnEnter context key
        var acceptSuggestionsOnEnter = Context$1.AcceptSuggestionsOnEnter.bindTo(_contextKeyService);
        var updateFromConfig = function () {
            var _a = _this._editor.getConfiguration().contribInfo, acceptSuggestionOnEnter = _a.acceptSuggestionOnEnter, suggestSelection = _a.suggestSelection;
            acceptSuggestionsOnEnter.set(acceptSuggestionOnEnter === 'on' || acceptSuggestionOnEnter === 'smart');
            _this._memory.setMode(suggestSelection);
        };
        this._toDispose.push(this._editor.onDidChangeConfiguration(function (e) { return updateFromConfig(); }));
        updateFromConfig();
    }
    SuggestController.get = function (editor) {
        return editor.getContribution(SuggestController.ID);
    };
    SuggestController.prototype._createSuggestWidget = function () {
        var _this = this;
        this._widget = this._instantiationService.createInstance(SuggestWidget, this._editor);
        this._toDispose.push(this._widget.onDidSelect(this._onDidSelectItem, this));
        // Wire up logic to accept a suggestion on certain characters
        var autoAcceptOracle = new AcceptOnCharacterOracle(this._editor, this._widget, function (item) { return _this._onDidSelectItem(item); });
        this._toDispose.push(autoAcceptOracle, this._model.onDidSuggest(function (e) {
            if (e.completionModel.items.length === 0) {
                autoAcceptOracle.reset();
            }
        }));
        var makesTextEdit = Context$1.MakesTextEdit.bindTo(this._contextKeyService);
        this._toDispose.push(this._widget.onDidFocus(function (_a) {
            var item = _a.item;
            var position = _this._editor.getPosition();
            var startColumn = item.position.column - item.suggestion.overwriteBefore;
            var endColumn = position.column;
            var value = true;
            if (_this._editor.getConfiguration().contribInfo.acceptSuggestionOnEnter === 'smart'
                && _this._model.state === 2 /* Auto */
                && !item.suggestion.command
                && !item.suggestion.additionalTextEdits
                && item.suggestion.snippetType !== 'textmate'
                && endColumn - startColumn === item.suggestion.insertText.length) {
                var oldText = _this._editor.getModel().getValueInRange({
                    startLineNumber: position.lineNumber,
                    startColumn: startColumn,
                    endLineNumber: position.lineNumber,
                    endColumn: endColumn
                });
                value = oldText !== item.suggestion.insertText;
            }
            makesTextEdit.set(value);
        }));
        this._toDispose.push({
            dispose: function () { makesTextEdit.reset(); }
        });
    };
    SuggestController.prototype.getId = function () {
        return SuggestController.ID;
    };
    SuggestController.prototype.dispose = function () {
        this._toDispose = dispose(this._toDispose);
        if (this._widget) {
            this._widget.dispose();
            this._widget = null;
        }
        if (this._model) {
            this._model.dispose();
            this._model = null;
        }
    };
    SuggestController.prototype._onDidSelectItem = function (event) {
        if (!event || !event.item) {
            this._model.cancel();
            return;
        }
        var _a = event.item, suggestion = _a.suggestion, position = _a.position;
        var editorColumn = this._editor.getPosition().column;
        var columnDelta = editorColumn - position.column;
        if (Array.isArray(suggestion.additionalTextEdits)) {
            this._editor.pushUndoStop();
            this._editor.executeEdits('suggestController.additionalTextEdits', suggestion.additionalTextEdits.map(function (edit) { return EditOperation.replace(Range.lift(edit.range), edit.text); }));
            this._editor.pushUndoStop();
        }
        // keep item in memory
        this._memory.memorize(this._editor.getModel(), this._editor.getPosition(), event.item);
        var insertText = suggestion.insertText;
        if (suggestion.snippetType !== 'textmate') {
            insertText = SnippetParser.escape(insertText);
        }
        SnippetController2.get(this._editor).insert(insertText, suggestion.overwriteBefore + columnDelta, suggestion.overwriteAfter);
        if (!suggestion.command) {
            // done
            this._model.cancel();
        }
        else if (suggestion.command.id === TriggerSuggestAction.id) {
            // retigger
            this._model.trigger({ auto: true }, true);
        }
        else {
            // exec command, done
            (_b = this._commandService).executeCommand.apply(_b, [suggestion.command.id].concat(suggestion.command.arguments)).done(undefined, onUnexpectedError);
            this._model.cancel();
        }
        this._alertCompletionItem(event.item);
        var _b;
    };
    SuggestController.prototype._alertCompletionItem = function (_a) {
        var suggestion = _a.suggestion;
        var msg = localize('arai.alert.snippet', "Accepting '{0}' did insert the following text: {1}", suggestion.label, suggestion.insertText);
        alert(msg);
    };
    SuggestController.prototype.triggerSuggest = function (onlyFrom) {
        this._model.trigger({ auto: false }, false, onlyFrom);
        this._editor.revealLine(this._editor.getPosition().lineNumber, 0 /* Smooth */);
        this._editor.focus();
    };
    SuggestController.prototype.acceptSelectedSuggestion = function () {
        if (this._widget) {
            var item = this._widget.getFocusedItem();
            this._onDidSelectItem(item);
        }
    };
    SuggestController.prototype.cancelSuggestWidget = function () {
        if (this._widget) {
            this._model.cancel();
            this._widget.hideWidget();
        }
    };
    SuggestController.prototype.selectNextSuggestion = function () {
        if (this._widget) {
            this._widget.selectNext();
        }
    };
    SuggestController.prototype.selectNextPageSuggestion = function () {
        if (this._widget) {
            this._widget.selectNextPage();
        }
    };
    SuggestController.prototype.selectLastSuggestion = function () {
        if (this._widget) {
            this._widget.selectLast();
        }
    };
    SuggestController.prototype.selectPrevSuggestion = function () {
        if (this._widget) {
            this._widget.selectPrevious();
        }
    };
    SuggestController.prototype.selectPrevPageSuggestion = function () {
        if (this._widget) {
            this._widget.selectPreviousPage();
        }
    };
    SuggestController.prototype.selectFirstSuggestion = function () {
        if (this._widget) {
            this._widget.selectFirst();
        }
    };
    SuggestController.prototype.toggleSuggestionDetails = function () {
        if (this._widget) {
            this._widget.toggleDetails();
        }
    };
    SuggestController.prototype.toggleSuggestionFocus = function () {
        if (this._widget) {
            this._widget.toggleDetailsFocus();
        }
    };
    SuggestController.ID = 'editor.contrib.suggestController';
    SuggestController = __decorate$q([
        __param$q(1, ICommandService),
        __param$q(2, IContextKeyService),
        __param$q(3, IInstantiationService)
    ], SuggestController);
    return SuggestController;
}());
var TriggerSuggestAction = /** @class */ (function (_super) {
    __extends$I(TriggerSuggestAction, _super);
    function TriggerSuggestAction() {
        return _super.call(this, {
            id: TriggerSuggestAction.id,
            label: localize('suggest.trigger.label', "Trigger Suggest"),
            alias: 'Trigger Suggest',
            precondition: ContextKeyExpr.and(EditorContextKeys.writable, EditorContextKeys.hasCompletionItemProvider),
            kbOpts: {
                kbExpr: EditorContextKeys.textInputFocus,
                primary: 2048 /* CtrlCmd */ | 10 /* Space */,
                mac: { primary: 256 /* WinCtrl */ | 10 /* Space */ }
            }
        }) || this;
    }
    TriggerSuggestAction.prototype.run = function (accessor, editor) {
        var controller = SuggestController.get(editor);
        if (!controller) {
            return;
        }
        controller.triggerSuggest();
    };
    TriggerSuggestAction.id = 'editor.action.triggerSuggest';
    return TriggerSuggestAction;
}(EditorAction));
registerEditorContribution(SuggestController);
registerEditorAction(TriggerSuggestAction);
var weight$1 = KeybindingsRegistry.WEIGHT.editorContrib(90);
var SuggestCommand = EditorCommand.bindToContribution(SuggestController.get);
registerEditorCommand(new SuggestCommand({
    id: 'acceptSelectedSuggestion',
    precondition: Context$1.Visible,
    handler: function (x) { return x.acceptSelectedSuggestion(); },
    kbOpts: {
        weight: weight$1,
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 2 /* Tab */
    }
}));
registerEditorCommand(new SuggestCommand({
    id: 'acceptSelectedSuggestionOnEnter',
    precondition: Context$1.Visible,
    handler: function (x) { return x.acceptSelectedSuggestion(); },
    kbOpts: {
        weight: weight$1,
        kbExpr: ContextKeyExpr.and(EditorContextKeys.textInputFocus, Context$1.AcceptSuggestionsOnEnter, Context$1.MakesTextEdit),
        primary: 3 /* Enter */
    }
}));
registerEditorCommand(new SuggestCommand({
    id: 'hideSuggestWidget',
    precondition: Context$1.Visible,
    handler: function (x) { return x.cancelSuggestWidget(); },
    kbOpts: {
        weight: weight$1,
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 9 /* Escape */,
        secondary: [1024 /* Shift */ | 9 /* Escape */]
    }
}));
registerEditorCommand(new SuggestCommand({
    id: 'selectNextSuggestion',
    precondition: ContextKeyExpr.and(Context$1.Visible, Context$1.MultipleSuggestions),
    handler: function (c) { return c.selectNextSuggestion(); },
    kbOpts: {
        weight: weight$1,
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 18 /* DownArrow */,
        secondary: [2048 /* CtrlCmd */ | 18 /* DownArrow */],
        mac: { primary: 18 /* DownArrow */, secondary: [2048 /* CtrlCmd */ | 18 /* DownArrow */, 256 /* WinCtrl */ | 44 /* KEY_N */] }
    }
}));
registerEditorCommand(new SuggestCommand({
    id: 'selectNextPageSuggestion',
    precondition: ContextKeyExpr.and(Context$1.Visible, Context$1.MultipleSuggestions),
    handler: function (c) { return c.selectNextPageSuggestion(); },
    kbOpts: {
        weight: weight$1,
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 12 /* PageDown */,
        secondary: [2048 /* CtrlCmd */ | 12 /* PageDown */]
    }
}));
registerEditorCommand(new SuggestCommand({
    id: 'selectLastSuggestion',
    precondition: ContextKeyExpr.and(Context$1.Visible, Context$1.MultipleSuggestions),
    handler: function (c) { return c.selectLastSuggestion(); }
}));
registerEditorCommand(new SuggestCommand({
    id: 'selectPrevSuggestion',
    precondition: ContextKeyExpr.and(Context$1.Visible, Context$1.MultipleSuggestions),
    handler: function (c) { return c.selectPrevSuggestion(); },
    kbOpts: {
        weight: weight$1,
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 16 /* UpArrow */,
        secondary: [2048 /* CtrlCmd */ | 16 /* UpArrow */],
        mac: { primary: 16 /* UpArrow */, secondary: [2048 /* CtrlCmd */ | 16 /* UpArrow */, 256 /* WinCtrl */ | 46 /* KEY_P */] }
    }
}));
registerEditorCommand(new SuggestCommand({
    id: 'selectPrevPageSuggestion',
    precondition: ContextKeyExpr.and(Context$1.Visible, Context$1.MultipleSuggestions),
    handler: function (c) { return c.selectPrevPageSuggestion(); },
    kbOpts: {
        weight: weight$1,
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 11 /* PageUp */,
        secondary: [2048 /* CtrlCmd */ | 11 /* PageUp */]
    }
}));
registerEditorCommand(new SuggestCommand({
    id: 'selectFirstSuggestion',
    precondition: ContextKeyExpr.and(Context$1.Visible, Context$1.MultipleSuggestions),
    handler: function (c) { return c.selectFirstSuggestion(); }
}));
registerEditorCommand(new SuggestCommand({
    id: 'toggleSuggestionDetails',
    precondition: Context$1.Visible,
    handler: function (x) { return x.toggleSuggestionDetails(); },
    kbOpts: {
        weight: weight$1,
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 2048 /* CtrlCmd */ | 10 /* Space */,
        mac: { primary: 256 /* WinCtrl */ | 10 /* Space */ }
    }
}));
registerEditorCommand(new SuggestCommand({
    id: 'toggleSuggestionFocus',
    precondition: Context$1.Visible,
    handler: function (x) { return x.toggleSuggestionFocus(); },
    kbOpts: {
        weight: weight$1,
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 2048 /* CtrlCmd */ | 512 /* Alt */ | 10 /* Space */,
        mac: { primary: 256 /* WinCtrl */ | 512 /* Alt */ | 10 /* Space */ }
    }
}));

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$J = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var ToggleTabFocusModeAction = /** @class */ (function (_super) {
    __extends$J(ToggleTabFocusModeAction, _super);
    function ToggleTabFocusModeAction() {
        return _super.call(this, {
            id: ToggleTabFocusModeAction.ID,
            label: localize({ key: 'toggle.tabMovesFocus', comment: ['Turn on/off use of tab key for moving focus around VS Code'] }, "Toggle Tab Key Moves Focus"),
            alias: 'Toggle Tab Key Moves Focus',
            precondition: null,
            kbOpts: {
                kbExpr: null,
                primary: 2048 /* CtrlCmd */ | 43 /* KEY_M */,
                mac: { primary: 256 /* WinCtrl */ | 1024 /* Shift */ | 43 /* KEY_M */ }
            }
        }) || this;
    }
    ToggleTabFocusModeAction.prototype.run = function (accessor, editor) {
        var oldValue = TabFocus.getTabFocusMode();
        TabFocus.setTabFocusMode(!oldValue);
    };
    ToggleTabFocusModeAction.ID = 'editor.action.toggleTabFocusMode';
    return ToggleTabFocusModeAction;
}(EditorAction));
registerEditorAction(ToggleTabFocusModeAction);

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$K = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate$r = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$r = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var editorWordHighlight = registerColor('editor.wordHighlightBackground', { dark: '#575757B8', light: '#57575740', hc: null }, localize('wordHighlight', 'Background color of a symbol during read-access, like reading a variable. The color must not be opaque to not hide underlying decorations.'), true);
var editorWordHighlightStrong = registerColor('editor.wordHighlightStrongBackground', { dark: '#004972B8', light: '#0e639c40', hc: null }, localize('wordHighlightStrong', 'Background color of a symbol during write-access, like writing to a variable. The color must not be opaque to not hide underlying decorations.'), true);
var editorWordHighlightBorder = registerColor('editor.wordHighlightBorder', { light: null, dark: null, hc: activeContrastBorder }, localize('wordHighlightBorder', 'Border color of a symbol during read-access, like reading a variable.'));
var editorWordHighlightStrongBorder = registerColor('editor.wordHighlightStrongBorder', { light: null, dark: null, hc: activeContrastBorder }, localize('wordHighlightStrongBorder', 'Border color of a symbol during write-access, like writing to a variable.'));
var overviewRulerWordHighlightForeground = registerColor('editorOverviewRuler.wordHighlightForeground', { dark: '#A0A0A0CC', light: '#A0A0A0CC', hc: '#A0A0A0CC' }, localize('overviewRulerWordHighlightForeground', 'Overview ruler marker color for symbol highlights. The color must not be opaque to not hide underlying decorations.'), true);
var overviewRulerWordHighlightStrongForeground = registerColor('editorOverviewRuler.wordHighlightStrongForeground', { dark: '#C0A0C0CC', light: '#C0A0C0CC', hc: '#C0A0C0CC' }, localize('overviewRulerWordHighlightStrongForeground', 'Overview ruler marker color for write-access symbol highlights. The color must not be opaque to not hide underlying decorations.'), true);
var ctxHasWordHighlights = new RawContextKey('hasWordHighlights', false);
function getOccurrencesAtPosition(model, position) {
    var orderedByScore = DocumentHighlightProviderRegistry.ordered(model);
    var foundResult = false;
    // in order of score ask the occurrences provider
    // until someone response with a good result
    // (good = none empty array)
    return sequence(orderedByScore.map(function (provider) {
        return function () {
            if (!foundResult) {
                return asWinJsPromise(function (token) {
                    return provider.provideDocumentHighlights(model, position, token);
                }).then(function (data) {
                    if (Array.isArray(data) && data.length > 0) {
                        foundResult = true;
                        return data;
                    }
                    return undefined;
                }, function (err) {
                    onUnexpectedExternalError(err);
                    return undefined;
                });
            }
            return undefined;
        };
    })).then(function (values) {
        return values[0];
    });
}
registerDefaultLanguageCommand('_executeDocumentHighlights', getOccurrencesAtPosition);
var WordHighlighter = /** @class */ (function () {
    function WordHighlighter(editor, contextKeyService) {
        var _this = this;
        this.workerRequestTokenId = 0;
        this.workerRequest = null;
        this.workerRequestCompleted = false;
        this.workerRequestValue = [];
        this.lastCursorPositionChangeTime = 0;
        this.renderDecorationsTimer = -1;
        this.editor = editor;
        this._hasWordHighlights = ctxHasWordHighlights.bindTo(contextKeyService);
        this._ignorePositionChangeEvent = false;
        this.occurrencesHighlight = this.editor.getConfiguration().contribInfo.occurrencesHighlight;
        this.model = this.editor.getModel();
        this.toUnhook = [];
        this.toUnhook.push(editor.onDidChangeCursorPosition(function (e) {
            if (_this._ignorePositionChangeEvent) {
                // We are changing the position => ignore this event
                return;
            }
            if (!_this.occurrencesHighlight) {
                // Early exit if nothing needs to be done!
                // Leave some form of early exit check here if you wish to continue being a cursor position change listener ;)
                return;
            }
            _this._onPositionChanged(e);
        }));
        this.toUnhook.push(editor.onDidChangeModel(function (e) {
            _this._stopAll();
            _this.model = _this.editor.getModel();
        }));
        this.toUnhook.push(editor.onDidChangeModelContent(function (e) {
            _this._stopAll();
        }));
        this.toUnhook.push(editor.onDidChangeConfiguration(function (e) {
            var newValue = _this.editor.getConfiguration().contribInfo.occurrencesHighlight;
            if (_this.occurrencesHighlight !== newValue) {
                _this.occurrencesHighlight = newValue;
                _this._stopAll();
            }
        }));
        this._lastWordRange = null;
        this._decorationIds = [];
        this.workerRequestTokenId = 0;
        this.workerRequest = null;
        this.workerRequestCompleted = false;
        this.lastCursorPositionChangeTime = 0;
        this.renderDecorationsTimer = -1;
    }
    WordHighlighter.prototype.hasDecorations = function () {
        return (this._decorationIds.length > 0);
    };
    WordHighlighter.prototype.restore = function () {
        if (!this.occurrencesHighlight) {
            return;
        }
        this._run();
    };
    WordHighlighter.prototype._getSortedHighlights = function () {
        var _this = this;
        return this._decorationIds
            .map(function (id) { return _this.model.getDecorationRange(id); })
            .sort(Range.compareRangesUsingStarts);
    };
    WordHighlighter.prototype.moveNext = function () {
        var _this = this;
        var highlights = this._getSortedHighlights();
        var index = firstIndex(highlights, function (range$$1) { return range$$1.containsPosition(_this.editor.getPosition()); });
        var newIndex = ((index + 1) % highlights.length);
        var dest = highlights[newIndex];
        try {
            this._ignorePositionChangeEvent = true;
            this.editor.setPosition(dest.getStartPosition());
            this.editor.revealRangeInCenterIfOutsideViewport(dest);
        }
        finally {
            this._ignorePositionChangeEvent = false;
        }
    };
    WordHighlighter.prototype.moveBack = function () {
        var _this = this;
        var highlights = this._getSortedHighlights();
        var index = firstIndex(highlights, function (range$$1) { return range$$1.containsPosition(_this.editor.getPosition()); });
        var newIndex = ((index - 1 + highlights.length) % highlights.length);
        var dest = highlights[newIndex];
        try {
            this._ignorePositionChangeEvent = true;
            this.editor.setPosition(dest.getStartPosition());
            this.editor.revealRangeInCenterIfOutsideViewport(dest);
        }
        finally {
            this._ignorePositionChangeEvent = false;
        }
    };
    WordHighlighter.prototype._removeDecorations = function () {
        if (this._decorationIds.length > 0) {
            // remove decorations
            this._decorationIds = this.editor.deltaDecorations(this._decorationIds, []);
            this._hasWordHighlights.set(false);
        }
    };
    WordHighlighter.prototype._stopAll = function () {
        this._lastWordRange = null;
        // Remove any existing decorations
        this._removeDecorations();
        // Cancel any renderDecorationsTimer
        if (this.renderDecorationsTimer !== -1) {
            clearTimeout(this.renderDecorationsTimer);
            this.renderDecorationsTimer = -1;
        }
        // Cancel any worker request
        if (this.workerRequest !== null) {
            this.workerRequest.cancel();
            this.workerRequest = null;
        }
        // Invalidate any worker request callback
        if (!this.workerRequestCompleted) {
            this.workerRequestTokenId++;
            this.workerRequestCompleted = true;
        }
    };
    WordHighlighter.prototype._onPositionChanged = function (e) {
        // disabled
        if (!this.occurrencesHighlight) {
            this._stopAll();
            return;
        }
        // ignore typing & other
        if (e.reason !== CursorChangeReason.Explicit) {
            this._stopAll();
            return;
        }
        this._run();
    };
    WordHighlighter.prototype._run = function () {
        var _this = this;
        // no providers for this model
        if (!DocumentHighlightProviderRegistry.has(this.model)) {
            this._stopAll();
            return;
        }
        var editorSelection = this.editor.getSelection();
        // ignore multiline selection
        if (editorSelection.startLineNumber !== editorSelection.endLineNumber) {
            this._stopAll();
            return;
        }
        var lineNumber = editorSelection.startLineNumber;
        var startColumn = editorSelection.startColumn;
        var endColumn = editorSelection.endColumn;
        var word = this.model.getWordAtPosition({
            lineNumber: lineNumber,
            column: startColumn
        });
        // The selection must be inside a word or surround one word at most
        if (!word || word.startColumn > startColumn || word.endColumn < endColumn) {
            this._stopAll();
            return;
        }
        // All the effort below is trying to achieve this:
        // - when cursor is moved to a word, trigger immediately a findOccurrences request
        // - 250ms later after the last cursor move event, render the occurrences
        // - no flickering!
        var currentWordRange = new Range(lineNumber, word.startColumn, lineNumber, word.endColumn);
        var workerRequestIsValid = this._lastWordRange && this._lastWordRange.equalsRange(currentWordRange);
        // Even if we are on a different word, if that word is in the decorations ranges, the request is still valid
        // (Same symbol)
        for (var i = 0, len = this._decorationIds.length; !workerRequestIsValid && i < len; i++) {
            var range$$1 = this.model.getDecorationRange(this._decorationIds[i]);
            if (range$$1 && range$$1.startLineNumber === lineNumber) {
                if (range$$1.startColumn <= startColumn && range$$1.endColumn >= endColumn) {
                    workerRequestIsValid = true;
                }
            }
        }
        // There are 4 cases:
        // a) old workerRequest is valid & completed, renderDecorationsTimer fired
        // b) old workerRequest is valid & completed, renderDecorationsTimer not fired
        // c) old workerRequest is valid, but not completed
        // d) old workerRequest is not valid
        // For a) no action is needed
        // For c), member 'lastCursorPositionChangeTime' will be used when installing the timer so no action is needed
        this.lastCursorPositionChangeTime = (new Date()).getTime();
        if (workerRequestIsValid) {
            if (this.workerRequestCompleted && this.renderDecorationsTimer !== -1) {
                // case b)
                // Delay the firing of renderDecorationsTimer by an extra 250 ms
                clearTimeout(this.renderDecorationsTimer);
                this.renderDecorationsTimer = -1;
                this._beginRenderDecorations();
            }
        }
        else {
            // case d)
            // Stop all previous actions and start fresh
            this._stopAll();
            var myRequestId = ++this.workerRequestTokenId;
            this.workerRequestCompleted = false;
            this.workerRequest = getOccurrencesAtPosition(this.model, this.editor.getPosition());
            this.workerRequest.then(function (data) {
                if (myRequestId === _this.workerRequestTokenId) {
                    _this.workerRequestCompleted = true;
                    _this.workerRequestValue = data || [];
                    _this._beginRenderDecorations();
                }
            }).done();
        }
        this._lastWordRange = currentWordRange;
    };
    WordHighlighter.prototype._beginRenderDecorations = function () {
        var _this = this;
        var currentTime = (new Date()).getTime();
        var minimumRenderTime = this.lastCursorPositionChangeTime + 250;
        if (currentTime >= minimumRenderTime) {
            // Synchronous
            this.renderDecorationsTimer = -1;
            this.renderDecorations();
        }
        else {
            // Asynchronous
            this.renderDecorationsTimer = setTimeout(function () {
                _this.renderDecorations();
            }, (minimumRenderTime - currentTime));
        }
    };
    WordHighlighter.prototype.renderDecorations = function () {
        this.renderDecorationsTimer = -1;
        var decorations = [];
        for (var i = 0, len = this.workerRequestValue.length; i < len; i++) {
            var info = this.workerRequestValue[i];
            decorations.push({
                range: info.range,
                options: WordHighlighter._getDecorationOptions(info.kind)
            });
        }
        this._decorationIds = this.editor.deltaDecorations(this._decorationIds, decorations);
        this._hasWordHighlights.set(this.hasDecorations());
    };
    WordHighlighter._getDecorationOptions = function (kind) {
        if (kind === DocumentHighlightKind.Write) {
            return this._WRITE_OPTIONS;
        }
        else if (kind === DocumentHighlightKind.Text) {
            return this._TEXT_OPTIONS;
        }
        else {
            return this._REGULAR_OPTIONS;
        }
    };
    WordHighlighter.prototype.dispose = function () {
        this._stopAll();
        this.toUnhook = dispose(this.toUnhook);
    };
    WordHighlighter._WRITE_OPTIONS = ModelDecorationOptions.register({
        stickiness: TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges,
        className: 'wordHighlightStrong',
        overviewRuler: {
            color: themeColorFromId(overviewRulerWordHighlightStrongForeground),
            darkColor: themeColorFromId(overviewRulerWordHighlightStrongForeground),
            position: OverviewRulerLane.Center
        }
    });
    WordHighlighter._TEXT_OPTIONS = ModelDecorationOptions.register({
        stickiness: TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges,
        className: 'selectionHighlight',
        overviewRuler: {
            color: themeColorFromId(overviewRulerSelectionHighlightForeground),
            darkColor: themeColorFromId(overviewRulerSelectionHighlightForeground),
            position: OverviewRulerLane.Center
        }
    });
    WordHighlighter._REGULAR_OPTIONS = ModelDecorationOptions.register({
        stickiness: TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges,
        className: 'wordHighlight',
        overviewRuler: {
            color: themeColorFromId(overviewRulerWordHighlightForeground),
            darkColor: themeColorFromId(overviewRulerWordHighlightForeground),
            position: OverviewRulerLane.Center
        }
    });
    return WordHighlighter;
}());
var WordHighlighterContribution = /** @class */ (function () {
    function WordHighlighterContribution(editor, contextKeyService) {
        this.wordHighligher = new WordHighlighter(editor, contextKeyService);
    }
    WordHighlighterContribution.get = function (editor) {
        return editor.getContribution(WordHighlighterContribution.ID);
    };
    WordHighlighterContribution.prototype.getId = function () {
        return WordHighlighterContribution.ID;
    };
    WordHighlighterContribution.prototype.saveViewState = function () {
        if (this.wordHighligher.hasDecorations()) {
            return true;
        }
        return false;
    };
    WordHighlighterContribution.prototype.moveNext = function () {
        this.wordHighligher.moveNext();
    };
    WordHighlighterContribution.prototype.moveBack = function () {
        this.wordHighligher.moveBack();
    };
    WordHighlighterContribution.prototype.restoreViewState = function (state) {
        if (state) {
            this.wordHighligher.restore();
        }
    };
    WordHighlighterContribution.prototype.dispose = function () {
        this.wordHighligher.dispose();
    };
    WordHighlighterContribution.ID = 'editor.contrib.wordHighlighter';
    WordHighlighterContribution = __decorate$r([
        __param$r(1, IContextKeyService)
    ], WordHighlighterContribution);
    return WordHighlighterContribution;
}());
var WordHighlightNavigationAction = /** @class */ (function (_super) {
    __extends$K(WordHighlightNavigationAction, _super);
    function WordHighlightNavigationAction(next, opts) {
        var _this = _super.call(this, opts) || this;
        _this._isNext = next;
        return _this;
    }
    WordHighlightNavigationAction.prototype.run = function (accessor, editor) {
        var controller = WordHighlighterContribution.get(editor);
        if (!controller) {
            return;
        }
        if (this._isNext) {
            controller.moveNext();
        }
        else {
            controller.moveBack();
        }
    };
    return WordHighlightNavigationAction;
}(EditorAction));
var NextWordHighlightAction = /** @class */ (function (_super) {
    __extends$K(NextWordHighlightAction, _super);
    function NextWordHighlightAction() {
        return _super.call(this, true, {
            id: 'editor.action.wordHighlight.next',
            label: localize('wordHighlight.next.label', "Go to Next Symbol Highlight"),
            alias: 'Go to Next Symbol Highlight',
            precondition: ctxHasWordHighlights,
            kbOpts: {
                kbExpr: EditorContextKeys.editorTextFocus,
                primary: 65 /* F7 */
            }
        }) || this;
    }
    return NextWordHighlightAction;
}(WordHighlightNavigationAction));
var PrevWordHighlightAction = /** @class */ (function (_super) {
    __extends$K(PrevWordHighlightAction, _super);
    function PrevWordHighlightAction() {
        return _super.call(this, false, {
            id: 'editor.action.wordHighlight.prev',
            label: localize('wordHighlight.previous.label', "Go to Previous Symbol Highlight"),
            alias: 'Go to Previous Symbol Highlight',
            precondition: ctxHasWordHighlights,
            kbOpts: {
                kbExpr: EditorContextKeys.editorTextFocus,
                primary: 1024 /* Shift */ | 65 /* F7 */
            }
        }) || this;
    }
    return PrevWordHighlightAction;
}(WordHighlightNavigationAction));
registerEditorContribution(WordHighlighterContribution);
registerEditorAction(NextWordHighlightAction);
registerEditorAction(PrevWordHighlightAction);
registerThemingParticipant(function (theme, collector) {
    var selectionHighlight = theme.getColor(editorSelectionHighlight);
    if (selectionHighlight) {
        collector.addRule(".monaco-editor .focused .selectionHighlight { background-color: " + selectionHighlight + "; }");
        collector.addRule(".monaco-editor .selectionHighlight { background-color: " + selectionHighlight.transparent(0.5) + "; }");
    }
    var wordHighlight = theme.getColor(editorWordHighlight);
    if (wordHighlight) {
        collector.addRule(".monaco-editor .wordHighlight { background-color: " + wordHighlight + "; }");
    }
    var wordHighlightStrong = theme.getColor(editorWordHighlightStrong);
    if (wordHighlightStrong) {
        collector.addRule(".monaco-editor .wordHighlightStrong { background-color: " + wordHighlightStrong + "; }");
    }
    var selectionHighlightBorder = theme.getColor(editorSelectionHighlightBorder);
    if (selectionHighlightBorder) {
        collector.addRule(".monaco-editor .selectionHighlight { border: 1px " + (theme.type === 'hc' ? 'dotted' : 'solid') + " " + selectionHighlightBorder + "; box-sizing: border-box; }");
    }
    var wordHighlightBorder = theme.getColor(editorWordHighlightBorder);
    if (wordHighlightBorder) {
        collector.addRule(".monaco-editor .wordHighlight { border: 1px " + (theme.type === 'hc' ? 'dashed' : 'solid') + " " + wordHighlightBorder + "; box-sizing: border-box; }");
    }
    var wordHighlightStrongBorder = theme.getColor(editorWordHighlightStrongBorder);
    if (wordHighlightStrongBorder) {
        collector.addRule(".monaco-editor .wordHighlightStrong { border: 1px " + (theme.type === 'hc' ? 'dashed' : 'solid') + " " + wordHighlightStrongBorder + "; box-sizing: border-box; }");
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$L = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var MoveWordCommand = /** @class */ (function (_super) {
    __extends$L(MoveWordCommand, _super);
    function MoveWordCommand(opts) {
        var _this = _super.call(this, opts) || this;
        _this._inSelectionMode = opts.inSelectionMode;
        _this._wordNavigationType = opts.wordNavigationType;
        return _this;
    }
    MoveWordCommand.prototype.runEditorCommand = function (accessor, editor, args) {
        var _this = this;
        var config = editor.getConfiguration();
        var wordSeparators = getMapForWordSeparators(config.wordSeparators);
        var model = editor.getModel();
        var selections = editor.getSelections();
        var result = selections.map(function (sel) {
            var inPosition = new Position(sel.positionLineNumber, sel.positionColumn);
            var outPosition = _this._move(wordSeparators, model, inPosition, _this._wordNavigationType);
            return _this._moveTo(sel, outPosition, _this._inSelectionMode);
        });
        editor._getCursors().setStates('moveWordCommand', CursorChangeReason.NotSet, result.map(function (r) { return CursorState.fromModelSelection(r); }));
        if (result.length === 1) {
            var pos = new Position(result[0].positionLineNumber, result[0].positionColumn);
            editor.revealPosition(pos, 0 /* Smooth */);
        }
    };
    MoveWordCommand.prototype._moveTo = function (from, to, inSelectionMode) {
        if (inSelectionMode) {
            // move just position
            return new Selection(from.selectionStartLineNumber, from.selectionStartColumn, to.lineNumber, to.column);
        }
        else {
            // move everything
            return new Selection(to.lineNumber, to.column, to.lineNumber, to.column);
        }
    };
    return MoveWordCommand;
}(EditorCommand));
var WordLeftCommand = /** @class */ (function (_super) {
    __extends$L(WordLeftCommand, _super);
    function WordLeftCommand() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    WordLeftCommand.prototype._move = function (wordSeparators, model, position, wordNavigationType) {
        return WordOperations.moveWordLeft(wordSeparators, model, position, wordNavigationType);
    };
    return WordLeftCommand;
}(MoveWordCommand));
var WordRightCommand = /** @class */ (function (_super) {
    __extends$L(WordRightCommand, _super);
    function WordRightCommand() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    WordRightCommand.prototype._move = function (wordSeparators, model, position, wordNavigationType) {
        return WordOperations.moveWordRight(wordSeparators, model, position, wordNavigationType);
    };
    return WordRightCommand;
}(MoveWordCommand));
var CursorWordStartLeft = /** @class */ (function (_super) {
    __extends$L(CursorWordStartLeft, _super);
    function CursorWordStartLeft() {
        return _super.call(this, {
            inSelectionMode: false,
            wordNavigationType: 0 /* WordStart */,
            id: 'cursorWordStartLeft',
            precondition: null,
            kbOpts: {
                kbExpr: EditorContextKeys.textInputFocus,
                primary: 2048 /* CtrlCmd */ | 15 /* LeftArrow */,
                mac: { primary: 512 /* Alt */ | 15 /* LeftArrow */ }
            }
        }) || this;
    }
    return CursorWordStartLeft;
}(WordLeftCommand));
var CursorWordEndLeft = /** @class */ (function (_super) {
    __extends$L(CursorWordEndLeft, _super);
    function CursorWordEndLeft() {
        return _super.call(this, {
            inSelectionMode: false,
            wordNavigationType: 1 /* WordEnd */,
            id: 'cursorWordEndLeft',
            precondition: null
        }) || this;
    }
    return CursorWordEndLeft;
}(WordLeftCommand));
var CursorWordLeft = /** @class */ (function (_super) {
    __extends$L(CursorWordLeft, _super);
    function CursorWordLeft() {
        return _super.call(this, {
            inSelectionMode: false,
            wordNavigationType: 0 /* WordStart */,
            id: 'cursorWordLeft',
            precondition: null
        }) || this;
    }
    return CursorWordLeft;
}(WordLeftCommand));
var CursorWordStartLeftSelect = /** @class */ (function (_super) {
    __extends$L(CursorWordStartLeftSelect, _super);
    function CursorWordStartLeftSelect() {
        return _super.call(this, {
            inSelectionMode: true,
            wordNavigationType: 0 /* WordStart */,
            id: 'cursorWordStartLeftSelect',
            precondition: null,
            kbOpts: {
                kbExpr: EditorContextKeys.textInputFocus,
                primary: 2048 /* CtrlCmd */ | 1024 /* Shift */ | 15 /* LeftArrow */,
                mac: { primary: 512 /* Alt */ | 1024 /* Shift */ | 15 /* LeftArrow */ }
            }
        }) || this;
    }
    return CursorWordStartLeftSelect;
}(WordLeftCommand));
var CursorWordEndLeftSelect = /** @class */ (function (_super) {
    __extends$L(CursorWordEndLeftSelect, _super);
    function CursorWordEndLeftSelect() {
        return _super.call(this, {
            inSelectionMode: true,
            wordNavigationType: 1 /* WordEnd */,
            id: 'cursorWordEndLeftSelect',
            precondition: null
        }) || this;
    }
    return CursorWordEndLeftSelect;
}(WordLeftCommand));
var CursorWordLeftSelect = /** @class */ (function (_super) {
    __extends$L(CursorWordLeftSelect, _super);
    function CursorWordLeftSelect() {
        return _super.call(this, {
            inSelectionMode: true,
            wordNavigationType: 0 /* WordStart */,
            id: 'cursorWordLeftSelect',
            precondition: null
        }) || this;
    }
    return CursorWordLeftSelect;
}(WordLeftCommand));
var CursorWordStartRight = /** @class */ (function (_super) {
    __extends$L(CursorWordStartRight, _super);
    function CursorWordStartRight() {
        return _super.call(this, {
            inSelectionMode: false,
            wordNavigationType: 0 /* WordStart */,
            id: 'cursorWordStartRight',
            precondition: null
        }) || this;
    }
    return CursorWordStartRight;
}(WordRightCommand));
var CursorWordEndRight = /** @class */ (function (_super) {
    __extends$L(CursorWordEndRight, _super);
    function CursorWordEndRight() {
        return _super.call(this, {
            inSelectionMode: false,
            wordNavigationType: 1 /* WordEnd */,
            id: 'cursorWordEndRight',
            precondition: null,
            kbOpts: {
                kbExpr: EditorContextKeys.textInputFocus,
                primary: 2048 /* CtrlCmd */ | 17 /* RightArrow */,
                mac: { primary: 512 /* Alt */ | 17 /* RightArrow */ }
            }
        }) || this;
    }
    return CursorWordEndRight;
}(WordRightCommand));
var CursorWordRight = /** @class */ (function (_super) {
    __extends$L(CursorWordRight, _super);
    function CursorWordRight() {
        return _super.call(this, {
            inSelectionMode: false,
            wordNavigationType: 1 /* WordEnd */,
            id: 'cursorWordRight',
            precondition: null
        }) || this;
    }
    return CursorWordRight;
}(WordRightCommand));
var CursorWordStartRightSelect = /** @class */ (function (_super) {
    __extends$L(CursorWordStartRightSelect, _super);
    function CursorWordStartRightSelect() {
        return _super.call(this, {
            inSelectionMode: true,
            wordNavigationType: 0 /* WordStart */,
            id: 'cursorWordStartRightSelect',
            precondition: null
        }) || this;
    }
    return CursorWordStartRightSelect;
}(WordRightCommand));
var CursorWordEndRightSelect = /** @class */ (function (_super) {
    __extends$L(CursorWordEndRightSelect, _super);
    function CursorWordEndRightSelect() {
        return _super.call(this, {
            inSelectionMode: true,
            wordNavigationType: 1 /* WordEnd */,
            id: 'cursorWordEndRightSelect',
            precondition: null,
            kbOpts: {
                kbExpr: EditorContextKeys.textInputFocus,
                primary: 2048 /* CtrlCmd */ | 1024 /* Shift */ | 17 /* RightArrow */,
                mac: { primary: 512 /* Alt */ | 1024 /* Shift */ | 17 /* RightArrow */ }
            }
        }) || this;
    }
    return CursorWordEndRightSelect;
}(WordRightCommand));
var CursorWordRightSelect = /** @class */ (function (_super) {
    __extends$L(CursorWordRightSelect, _super);
    function CursorWordRightSelect() {
        return _super.call(this, {
            inSelectionMode: true,
            wordNavigationType: 1 /* WordEnd */,
            id: 'cursorWordRightSelect',
            precondition: null
        }) || this;
    }
    return CursorWordRightSelect;
}(WordRightCommand));
var DeleteWordCommand = /** @class */ (function (_super) {
    __extends$L(DeleteWordCommand, _super);
    function DeleteWordCommand(opts) {
        var _this = _super.call(this, opts) || this;
        _this._whitespaceHeuristics = opts.whitespaceHeuristics;
        _this._wordNavigationType = opts.wordNavigationType;
        return _this;
    }
    DeleteWordCommand.prototype.runEditorCommand = function (accessor, editor, args) {
        var _this = this;
        var config = editor.getConfiguration();
        var wordSeparators = getMapForWordSeparators(config.wordSeparators);
        var model = editor.getModel();
        var selections = editor.getSelections();
        var commands = selections.map(function (sel) {
            var deleteRange = _this._delete(wordSeparators, model, sel, _this._whitespaceHeuristics, _this._wordNavigationType);
            return new ReplaceCommand(deleteRange, '');
        });
        editor.pushUndoStop();
        editor.executeCommands(this.id, commands);
        editor.pushUndoStop();
    };
    return DeleteWordCommand;
}(EditorCommand));
var DeleteWordLeftCommand = /** @class */ (function (_super) {
    __extends$L(DeleteWordLeftCommand, _super);
    function DeleteWordLeftCommand() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    DeleteWordLeftCommand.prototype._delete = function (wordSeparators, model, selection, whitespaceHeuristics, wordNavigationType) {
        var r = WordOperations.deleteWordLeft(wordSeparators, model, selection, whitespaceHeuristics, wordNavigationType);
        if (r) {
            return r;
        }
        return new Range(1, 1, 1, 1);
    };
    return DeleteWordLeftCommand;
}(DeleteWordCommand));
var DeleteWordRightCommand = /** @class */ (function (_super) {
    __extends$L(DeleteWordRightCommand, _super);
    function DeleteWordRightCommand() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    DeleteWordRightCommand.prototype._delete = function (wordSeparators, model, selection, whitespaceHeuristics, wordNavigationType) {
        var r = WordOperations.deleteWordRight(wordSeparators, model, selection, whitespaceHeuristics, wordNavigationType);
        if (r) {
            return r;
        }
        var lineCount = model.getLineCount();
        var maxColumn = model.getLineMaxColumn(lineCount);
        return new Range(lineCount, maxColumn, lineCount, maxColumn);
    };
    return DeleteWordRightCommand;
}(DeleteWordCommand));
var DeleteWordStartLeft = /** @class */ (function (_super) {
    __extends$L(DeleteWordStartLeft, _super);
    function DeleteWordStartLeft() {
        return _super.call(this, {
            whitespaceHeuristics: false,
            wordNavigationType: 0 /* WordStart */,
            id: 'deleteWordStartLeft',
            precondition: EditorContextKeys.writable
        }) || this;
    }
    return DeleteWordStartLeft;
}(DeleteWordLeftCommand));
var DeleteWordEndLeft = /** @class */ (function (_super) {
    __extends$L(DeleteWordEndLeft, _super);
    function DeleteWordEndLeft() {
        return _super.call(this, {
            whitespaceHeuristics: false,
            wordNavigationType: 1 /* WordEnd */,
            id: 'deleteWordEndLeft',
            precondition: EditorContextKeys.writable
        }) || this;
    }
    return DeleteWordEndLeft;
}(DeleteWordLeftCommand));
var DeleteWordLeft = /** @class */ (function (_super) {
    __extends$L(DeleteWordLeft, _super);
    function DeleteWordLeft() {
        return _super.call(this, {
            whitespaceHeuristics: true,
            wordNavigationType: 0 /* WordStart */,
            id: 'deleteWordLeft',
            precondition: EditorContextKeys.writable,
            kbOpts: {
                kbExpr: EditorContextKeys.textInputFocus,
                primary: 2048 /* CtrlCmd */ | 1 /* Backspace */,
                mac: { primary: 512 /* Alt */ | 1 /* Backspace */ }
            }
        }) || this;
    }
    return DeleteWordLeft;
}(DeleteWordLeftCommand));
var DeleteWordStartRight = /** @class */ (function (_super) {
    __extends$L(DeleteWordStartRight, _super);
    function DeleteWordStartRight() {
        return _super.call(this, {
            whitespaceHeuristics: false,
            wordNavigationType: 0 /* WordStart */,
            id: 'deleteWordStartRight',
            precondition: EditorContextKeys.writable
        }) || this;
    }
    return DeleteWordStartRight;
}(DeleteWordRightCommand));
var DeleteWordEndRight = /** @class */ (function (_super) {
    __extends$L(DeleteWordEndRight, _super);
    function DeleteWordEndRight() {
        return _super.call(this, {
            whitespaceHeuristics: false,
            wordNavigationType: 1 /* WordEnd */,
            id: 'deleteWordEndRight',
            precondition: EditorContextKeys.writable
        }) || this;
    }
    return DeleteWordEndRight;
}(DeleteWordRightCommand));
var DeleteWordRight = /** @class */ (function (_super) {
    __extends$L(DeleteWordRight, _super);
    function DeleteWordRight() {
        return _super.call(this, {
            whitespaceHeuristics: true,
            wordNavigationType: 1 /* WordEnd */,
            id: 'deleteWordRight',
            precondition: EditorContextKeys.writable,
            kbOpts: {
                kbExpr: EditorContextKeys.textInputFocus,
                primary: 2048 /* CtrlCmd */ | 20 /* Delete */,
                mac: { primary: 512 /* Alt */ | 20 /* Delete */ }
            }
        }) || this;
    }
    return DeleteWordRight;
}(DeleteWordRightCommand));
registerEditorCommand(new CursorWordStartLeft());
registerEditorCommand(new CursorWordEndLeft());
registerEditorCommand(new CursorWordLeft());
registerEditorCommand(new CursorWordStartLeftSelect());
registerEditorCommand(new CursorWordEndLeftSelect());
registerEditorCommand(new CursorWordLeftSelect());
registerEditorCommand(new CursorWordStartRight());
registerEditorCommand(new CursorWordEndRight());
registerEditorCommand(new CursorWordRight());
registerEditorCommand(new CursorWordStartRightSelect());
registerEditorCommand(new CursorWordEndRightSelect());
registerEditorCommand(new CursorWordRightSelect());
registerEditorCommand(new DeleteWordStartLeft());
registerEditorCommand(new DeleteWordEndLeft());
registerEditorCommand(new DeleteWordLeft());
registerEditorCommand(new DeleteWordStartRight());
registerEditorCommand(new DeleteWordEndRight());
registerEditorCommand(new DeleteWordRight());

const css$p = "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n.monaco-editor .accessibilityHelpWidget {\n\tpadding: 10px;\n\tvertical-align: middle;\n\toverflow: scroll;\n}";
  const element$p = ((css, src) => {
if (typeof document !== 'object')
console.info(`Skipped loading "${src}"`);
try {
const id = src
  .replace(/\.css.*$/, '')
  .replace(/[\\:]/g, '/')
  .replace(/[^\w\/]+/g, '');
return (
  document.querySelector(`style[id="${id}"]`) ||
  document.head.appendChild(
    Object.assign(document.createElement('style'), {
      id,
      textContent: `${css}\n\n /* sourceURL=${src} */`,
    }),
  )
);
} catch (exception) {
console.warn(`Failed load "${src}"`, exception);
}
})(css$p, "…monaco-editor/esm/vs/editor/standalone/browser/accessibilityHelp/accessibilityHelp.css");
  //@ sourceURL=/Users/daflair/Projects/packages/monaco-es/node_modules/monaco-editor/esm/vs/editor/standalone/browser/accessibilityHelp/accessibilityHelp.css

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$M = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate$s = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$s = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var CONTEXT_ACCESSIBILITY_WIDGET_VISIBLE = new RawContextKey('accessibilityHelpWidgetVisible', false);
var AccessibilityHelpController = /** @class */ (function (_super) {
    __extends$M(AccessibilityHelpController, _super);
    function AccessibilityHelpController(editor, instantiationService) {
        var _this = _super.call(this) || this;
        _this._editor = editor;
        _this._widget = _this._register(instantiationService.createInstance(AccessibilityHelpWidget, _this._editor));
        return _this;
    }
    AccessibilityHelpController.get = function (editor) {
        return editor.getContribution(AccessibilityHelpController.ID);
    };
    AccessibilityHelpController.prototype.getId = function () {
        return AccessibilityHelpController.ID;
    };
    AccessibilityHelpController.prototype.show = function () {
        this._widget.show();
    };
    AccessibilityHelpController.prototype.hide = function () {
        this._widget.hide();
    };
    AccessibilityHelpController.ID = 'editor.contrib.accessibilityHelpController';
    AccessibilityHelpController = __decorate$s([
        __param$s(1, IInstantiationService)
    ], AccessibilityHelpController);
    return AccessibilityHelpController;
}(Disposable));
var nlsNoSelection = localize("noSelection", "No selection");
var nlsSingleSelectionRange = localize("singleSelectionRange", "Line {0}, Column {1} ({2} selected)");
var nlsSingleSelection = localize("singleSelection", "Line {0}, Column {1}");
var nlsMultiSelectionRange = localize("multiSelectionRange", "{0} selections ({1} characters selected)");
var nlsMultiSelection = localize("multiSelection", "{0} selections");
function getSelectionLabel(selections, charactersSelected) {
    if (!selections || selections.length === 0) {
        return nlsNoSelection;
    }
    if (selections.length === 1) {
        if (charactersSelected) {
            return format(nlsSingleSelectionRange, selections[0].positionLineNumber, selections[0].positionColumn, charactersSelected);
        }
        return format(nlsSingleSelection, selections[0].positionLineNumber, selections[0].positionColumn);
    }
    if (charactersSelected) {
        return format(nlsMultiSelectionRange, selections.length, charactersSelected);
    }
    if (selections.length > 0) {
        return format(nlsMultiSelection, selections.length);
    }
    return null;
}
var AccessibilityHelpWidget = /** @class */ (function (_super) {
    __extends$M(AccessibilityHelpWidget, _super);
    function AccessibilityHelpWidget(editor, _contextKeyService, _keybindingService, _openerService) {
        var _this = _super.call(this) || this;
        _this._contextKeyService = _contextKeyService;
        _this._keybindingService = _keybindingService;
        _this._openerService = _openerService;
        _this._editor = editor;
        _this._isVisibleKey = CONTEXT_ACCESSIBILITY_WIDGET_VISIBLE.bindTo(_this._contextKeyService);
        _this._domNode = createFastDomNode(document.createElement('div'));
        _this._domNode.setClassName('accessibilityHelpWidget');
        _this._domNode.setDisplay('none');
        _this._domNode.setAttribute('role', 'dialog');
        _this._domNode.setAttribute('aria-hidden', 'true');
        _this._contentDomNode = createFastDomNode(document.createElement('div'));
        _this._contentDomNode.setAttribute('role', 'document');
        _this._domNode.appendChild(_this._contentDomNode);
        _this._isVisible = false;
        _this._register(_this._editor.onDidLayoutChange(function () {
            if (_this._isVisible) {
                _this._layout();
            }
        }));
        // Intentionally not configurable!
        _this._register(addStandardDisposableListener(_this._contentDomNode.domNode, 'keydown', function (e) {
            if (!_this._isVisible) {
                return;
            }
            if (e.equals(2048 /* CtrlCmd */ | 35 /* KEY_E */)) {
                alert(localize("emergencyConfOn", "Now changing the setting `accessibilitySupport` to 'on'."));
                _this._editor.updateOptions({
                    accessibilitySupport: 'on'
                });
                clearNode(_this._contentDomNode.domNode);
                _this._buildContent();
                _this._contentDomNode.domNode.focus();
                e.preventDefault();
                e.stopPropagation();
            }
            if (e.equals(2048 /* CtrlCmd */ | 38 /* KEY_H */)) {
                alert(localize("openingDocs", "Now opening the Editor Accessibility documentation page."));
                var url = _this._editor.getRawConfiguration().accessibilityHelpUrl;
                if (typeof url === 'undefined') {
                    url = 'https://go.microsoft.com/fwlink/?linkid=852450';
                }
                _this._openerService.open(URI.parse(url));
                e.preventDefault();
                e.stopPropagation();
            }
        }));
        _this.onblur(_this._contentDomNode.domNode, function () {
            _this.hide();
        });
        _this._editor.addOverlayWidget(_this);
        return _this;
    }
    AccessibilityHelpWidget.prototype.dispose = function () {
        this._editor.removeOverlayWidget(this);
        _super.prototype.dispose.call(this);
    };
    AccessibilityHelpWidget.prototype.getId = function () {
        return AccessibilityHelpWidget.ID;
    };
    AccessibilityHelpWidget.prototype.getDomNode = function () {
        return this._domNode.domNode;
    };
    AccessibilityHelpWidget.prototype.getPosition = function () {
        return {
            preference: null
        };
    };
    AccessibilityHelpWidget.prototype.show = function () {
        if (this._isVisible) {
            return;
        }
        this._isVisible = true;
        this._isVisibleKey.set(true);
        this._layout();
        this._domNode.setDisplay('block');
        this._domNode.setAttribute('aria-hidden', 'false');
        this._contentDomNode.domNode.tabIndex = 0;
        this._buildContent();
        this._contentDomNode.domNode.focus();
    };
    AccessibilityHelpWidget.prototype._descriptionForCommand = function (commandId, msg, noKbMsg) {
        var kb = this._keybindingService.lookupKeybinding(commandId);
        if (kb) {
            return format(msg, kb.getAriaLabel());
        }
        return format(noKbMsg, commandId);
    };
    AccessibilityHelpWidget.prototype._buildContent = function () {
        var opts = this._editor.getConfiguration();
        var selections = this._editor.getSelections();
        var charactersSelected = 0;
        if (selections) {
            var model_1 = this._editor.getModel();
            if (model_1) {
                selections.forEach(function (selection) {
                    charactersSelected += model_1.getValueLengthInRange(selection);
                });
            }
        }
        var text = getSelectionLabel(selections, charactersSelected);
        if (opts.wrappingInfo.inDiffEditor) {
            if (opts.readOnly) {
                text += localize("readonlyDiffEditor", " in a read-only pane of a diff editor.");
            }
            else {
                text += localize("editableDiffEditor", " in a pane of a diff editor.");
            }
        }
        else {
            if (opts.readOnly) {
                text += localize("readonlyEditor", " in a read-only code editor");
            }
            else {
                text += localize("editableEditor", " in a code editor");
            }
        }
        switch (opts.accessibilitySupport) {
            case 0 /* Unknown */:
                var turnOnMessage = (isMacintosh
                    ? localize("changeConfigToOnMac", "To configure the editor to be optimized for usage with a Screen Reader press Command+E now.")
                    : localize("changeConfigToOnWinLinux", "To configure the editor to be optimized for usage with a Screen Reader press Control+E now."));
                text += '\n\n - ' + turnOnMessage;
                break;
            case 2 /* Enabled */:
                text += '\n\n - ' + localize("auto_on", "The editor is configured to be optimized for usage with a Screen Reader.");
                break;
            case 1 /* Disabled */:
                text += '\n\n - ' + localize("auto_off", "The editor is configured to never be optimized for usage with a Screen Reader, which is not the case at this time.");
                text += ' ' + turnOnMessage;
                break;
        }
        var NLS_TAB_FOCUS_MODE_ON = localize("tabFocusModeOnMsg", "Pressing Tab in the current editor will move focus to the next focusable element. Toggle this behavior by pressing {0}.");
        var NLS_TAB_FOCUS_MODE_ON_NO_KB = localize("tabFocusModeOnMsgNoKb", "Pressing Tab in the current editor will move focus to the next focusable element. The command {0} is currently not triggerable by a keybinding.");
        var NLS_TAB_FOCUS_MODE_OFF = localize("tabFocusModeOffMsg", "Pressing Tab in the current editor will insert the tab character. Toggle this behavior by pressing {0}.");
        var NLS_TAB_FOCUS_MODE_OFF_NO_KB = localize("tabFocusModeOffMsgNoKb", "Pressing Tab in the current editor will insert the tab character. The command {0} is currently not triggerable by a keybinding.");
        if (opts.tabFocusMode) {
            text += '\n\n - ' + this._descriptionForCommand(ToggleTabFocusModeAction.ID, NLS_TAB_FOCUS_MODE_ON, NLS_TAB_FOCUS_MODE_ON_NO_KB);
        }
        else {
            text += '\n\n - ' + this._descriptionForCommand(ToggleTabFocusModeAction.ID, NLS_TAB_FOCUS_MODE_OFF, NLS_TAB_FOCUS_MODE_OFF_NO_KB);
        }
        var openDocMessage = (isMacintosh
            ? localize("openDocMac", "Press Command+H now to open a browser window with more information related to editor accessibility.")
            : localize("openDocWinLinux", "Press Control+H now to open a browser window with more information related to editor accessibility."));
        text += '\n\n - ' + openDocMessage;
        text += '\n\n' + localize("outroMsg", "You can dismiss this tooltip and return to the editor by pressing Escape or Shift+Escape.");
        this._contentDomNode.domNode.appendChild(renderFormattedText(text));
        // Per https://www.w3.org/TR/wai-aria/roles#document, Authors SHOULD provide a title or label for documents
        this._contentDomNode.domNode.setAttribute('aria-label', text);
    };
    AccessibilityHelpWidget.prototype.hide = function () {
        if (!this._isVisible) {
            return;
        }
        this._isVisible = false;
        this._isVisibleKey.reset();
        this._domNode.setDisplay('none');
        this._domNode.setAttribute('aria-hidden', 'true');
        this._contentDomNode.domNode.tabIndex = -1;
        clearNode(this._contentDomNode.domNode);
        this._editor.focus();
    };
    AccessibilityHelpWidget.prototype._layout = function () {
        var editorLayout = this._editor.getLayoutInfo();
        var w = Math.max(5, Math.min(AccessibilityHelpWidget.WIDTH, editorLayout.width - 40));
        var h = Math.max(5, Math.min(AccessibilityHelpWidget.HEIGHT, editorLayout.height - 40));
        this._domNode.setWidth(w);
        this._domNode.setHeight(h);
        var top = Math.round((editorLayout.height - h) / 2);
        this._domNode.setTop(top);
        var left = Math.round((editorLayout.width - w) / 2);
        this._domNode.setLeft(left);
    };
    AccessibilityHelpWidget.ID = 'editor.contrib.accessibilityHelpWidget';
    AccessibilityHelpWidget.WIDTH = 500;
    AccessibilityHelpWidget.HEIGHT = 300;
    AccessibilityHelpWidget = __decorate$s([
        __param$s(1, IContextKeyService),
        __param$s(2, IKeybindingService),
        __param$s(3, IOpenerService)
    ], AccessibilityHelpWidget);
    return AccessibilityHelpWidget;
}(Widget));
var ShowAccessibilityHelpAction = /** @class */ (function (_super) {
    __extends$M(ShowAccessibilityHelpAction, _super);
    function ShowAccessibilityHelpAction() {
        return _super.call(this, {
            id: 'editor.action.showAccessibilityHelp',
            label: localize("ShowAccessibilityHelpAction", "Show Accessibility Help"),
            alias: 'Show Accessibility Help',
            precondition: null,
            kbOpts: {
                kbExpr: EditorContextKeys.focus,
                primary: (isIE ? 2048 /* CtrlCmd */ | 59 /* F1 */ : 512 /* Alt */ | 59 /* F1 */)
            }
        }) || this;
    }
    ShowAccessibilityHelpAction.prototype.run = function (accessor, editor) {
        var controller = AccessibilityHelpController.get(editor);
        if (controller) {
            controller.show();
        }
    };
    return ShowAccessibilityHelpAction;
}(EditorAction));
registerEditorContribution(AccessibilityHelpController);
registerEditorAction(ShowAccessibilityHelpAction);
var AccessibilityHelpCommand = EditorCommand.bindToContribution(AccessibilityHelpController.get);
registerEditorCommand(new AccessibilityHelpCommand({
    id: 'closeAccessibilityHelp',
    precondition: CONTEXT_ACCESSIBILITY_WIDGET_VISIBLE,
    handler: function (x) { return x.hide(); },
    kbOpts: {
        weight: KeybindingsRegistry.WEIGHT.editorContrib(100),
        kbExpr: EditorContextKeys.focus,
        primary: 9 /* Escape */,
        secondary: [1024 /* Shift */ | 9 /* Escape */]
    }
}));
registerThemingParticipant(function (theme, collector) {
    var widgetBackground = theme.getColor(editorWidgetBackground);
    if (widgetBackground) {
        collector.addRule(".monaco-editor .accessibilityHelpWidget { background-color: " + widgetBackground + "; }");
    }
    var widgetShadowColor = theme.getColor(widgetShadow);
    if (widgetShadowColor) {
        collector.addRule(".monaco-editor .accessibilityHelpWidget { box-shadow: 0 2px 8px " + widgetShadowColor + "; }");
    }
    var hcBorder = theme.getColor(contrastBorder);
    if (hcBorder) {
        collector.addRule(".monaco-editor .accessibilityHelpWidget { border: 2px solid " + hcBorder + "; }");
    }
});

const css$q = "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n.monaco-editor .tokens-inspect-widget {\n\tz-index: 50;\n\t-webkit-user-select: text;\n\t-ms-user-select: text;\n\t-khtml-user-select: text;\n\t-moz-user-select: text;\n\t-o-user-select: text;\n\tuser-select: text;\n\tpadding: 10px;\n}\n\n.tokens-inspect-separator {\n\theight: 1px;\n\tborder: 0;\n}\n\n.monaco-editor .tokens-inspect-widget .tm-token {\n\tfont-family: monospace;\n}\n\n.monaco-editor .tokens-inspect-widget .tm-token-length {\n\tfont-weight: normal;\n\tfont-size: 60%;\n\tfloat: right;\n}\n\n.monaco-editor .tokens-inspect-widget .tm-metadata-table {\n\twidth: 100%;\n}\n\n.monaco-editor .tokens-inspect-widget .tm-metadata-value {\n\tfont-family: monospace;\n\ttext-align: right;\n}\n\n.monaco-editor .tokens-inspect-widget .tm-token-type {\n\tfont-family: monospace;\n}\n";
  const element$q = ((css, src) => {
if (typeof document !== 'object')
console.info(`Skipped loading "${src}"`);
try {
const id = src
  .replace(/\.css.*$/, '')
  .replace(/[\\:]/g, '/')
  .replace(/[^\w\/]+/g, '');
return (
  document.querySelector(`style[id="${id}"]`) ||
  document.head.appendChild(
    Object.assign(document.createElement('style'), {
      id,
      textContent: `${css}\n\n /* sourceURL=${src} */`,
    }),
  )
);
} catch (exception) {
console.warn(`Failed load "${src}"`, exception);
}
})(css$q, "…monaco-editor/esm/vs/editor/standalone/browser/inspectTokens/inspectTokens.css");
  //@ sourceURL=/Users/daflair/Projects/packages/monaco-es/node_modules/monaco-editor/esm/vs/editor/standalone/browser/inspectTokens/inspectTokens.css

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$N = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate$t = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$t = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var InspectTokensController = /** @class */ (function (_super) {
    __extends$N(InspectTokensController, _super);
    function InspectTokensController(editor, standaloneColorService, modeService) {
        var _this = _super.call(this) || this;
        _this._editor = editor;
        _this._standaloneThemeService = standaloneColorService;
        _this._modeService = modeService;
        _this._widget = null;
        _this._register(_this._editor.onDidChangeModel(function (e) { return _this.stop(); }));
        _this._register(_this._editor.onDidChangeModelLanguage(function (e) { return _this.stop(); }));
        _this._register(TokenizationRegistry.onDidChange(function (e) { return _this.stop(); }));
        return _this;
    }
    InspectTokensController.get = function (editor) {
        return editor.getContribution(InspectTokensController.ID);
    };
    InspectTokensController.prototype.getId = function () {
        return InspectTokensController.ID;
    };
    InspectTokensController.prototype.dispose = function () {
        this.stop();
        _super.prototype.dispose.call(this);
    };
    InspectTokensController.prototype.launch = function () {
        if (this._widget) {
            return;
        }
        if (!this._editor.getModel()) {
            return;
        }
        this._widget = new InspectTokensWidget(this._editor, this._standaloneThemeService, this._modeService);
    };
    InspectTokensController.prototype.stop = function () {
        if (this._widget) {
            this._widget.dispose();
            this._widget = null;
        }
    };
    InspectTokensController.ID = 'editor.contrib.inspectTokens';
    InspectTokensController = __decorate$t([
        __param$t(1, IStandaloneThemeService),
        __param$t(2, IModeService)
    ], InspectTokensController);
    return InspectTokensController;
}(Disposable));
var InspectTokens = /** @class */ (function (_super) {
    __extends$N(InspectTokens, _super);
    function InspectTokens() {
        return _super.call(this, {
            id: 'editor.action.inspectTokens',
            label: localize('inspectTokens', "Developer: Inspect Tokens"),
            alias: 'Developer: Inspect Tokens',
            precondition: null
        }) || this;
    }
    InspectTokens.prototype.run = function (accessor, editor) {
        var controller = InspectTokensController.get(editor);
        if (controller) {
            controller.launch();
        }
    };
    return InspectTokens;
}(EditorAction));
function renderTokenText(tokenText) {
    var result = '';
    for (var charIndex = 0, len = tokenText.length; charIndex < len; charIndex++) {
        var charCode = tokenText.charCodeAt(charIndex);
        switch (charCode) {
            case 9 /* Tab */:
                result += '&rarr;';
                break;
            case 32 /* Space */:
                result += '&middot;';
                break;
            case 60 /* LessThan */:
                result += '&lt;';
                break;
            case 62 /* GreaterThan */:
                result += '&gt;';
                break;
            case 38 /* Ampersand */:
                result += '&amp;';
                break;
            default:
                result += String.fromCharCode(charCode);
        }
    }
    return result;
}
function getSafeTokenizationSupport(languageIdentifier) {
    var tokenizationSupport = TokenizationRegistry.get(languageIdentifier.language);
    if (tokenizationSupport) {
        return tokenizationSupport;
    }
    return {
        getInitialState: function () { return NULL_STATE; },
        tokenize: function (line, state, deltaOffset) { return nullTokenize(languageIdentifier.language, line, state, deltaOffset); },
        tokenize2: function (line, state, deltaOffset) { return nullTokenize2(languageIdentifier.id, line, state, deltaOffset); }
    };
}
var InspectTokensWidget = /** @class */ (function (_super) {
    __extends$N(InspectTokensWidget, _super);
    function InspectTokensWidget(editor, standaloneThemeService, modeService) {
        var _this = _super.call(this) || this;
        // Editor.IContentWidget.allowEditorOverflow
        _this.allowEditorOverflow = true;
        _this._editor = editor;
        _this._modeService = modeService;
        _this._model = _this._editor.getModel();
        _this._domNode = document.createElement('div');
        _this._domNode.className = 'tokens-inspect-widget';
        _this._tokenizationSupport = getSafeTokenizationSupport(_this._model.getLanguageIdentifier());
        _this._compute(_this._editor.getPosition());
        _this._register(_this._editor.onDidChangeCursorPosition(function (e) { return _this._compute(_this._editor.getPosition()); }));
        _this._editor.addContentWidget(_this);
        return _this;
    }
    InspectTokensWidget.prototype.dispose = function () {
        this._editor.removeContentWidget(this);
        _super.prototype.dispose.call(this);
    };
    InspectTokensWidget.prototype.getId = function () {
        return InspectTokensWidget._ID;
    };
    InspectTokensWidget.prototype._compute = function (position) {
        var data = this._getTokensAtLine(position.lineNumber);
        var token1Index = 0;
        for (var i = data.tokens1.length - 1; i >= 0; i--) {
            var t = data.tokens1[i];
            if (position.column - 1 >= t.offset) {
                token1Index = i;
                break;
            }
        }
        var token2Index = 0;
        for (var i = (data.tokens2.length >>> 1); i >= 0; i--) {
            if (position.column - 1 >= data.tokens2[(i << 1)]) {
                token2Index = i;
                break;
            }
        }
        var result = '';
        var lineContent = this._model.getLineContent(position.lineNumber);
        var tokenText = '';
        if (token1Index < data.tokens1.length) {
            var tokenStartIndex = data.tokens1[token1Index].offset;
            var tokenEndIndex = token1Index + 1 < data.tokens1.length ? data.tokens1[token1Index + 1].offset : lineContent.length;
            tokenText = lineContent.substring(tokenStartIndex, tokenEndIndex);
        }
        result += "<h2 class=\"tm-token\">" + renderTokenText(tokenText) + "<span class=\"tm-token-length\">(" + tokenText.length + " " + (tokenText.length === 1 ? 'char' : 'chars') + ")</span></h2>";
        result += "<hr class=\"tokens-inspect-separator\" style=\"clear:both\"/>";
        var metadata = this._decodeMetadata(data.tokens2[(token2Index << 1) + 1]);
        result += "<table class=\"tm-metadata-table\"><tbody>";
        result += "<tr><td class=\"tm-metadata-key\">language</td><td class=\"tm-metadata-value\">" + escape(metadata.languageIdentifier.language) + "</td>";
        result += "<tr><td class=\"tm-metadata-key\">token type</td><td class=\"tm-metadata-value\">" + this._tokenTypeToString(metadata.tokenType) + "</td>";
        result += "<tr><td class=\"tm-metadata-key\">font style</td><td class=\"tm-metadata-value\">" + this._fontStyleToString(metadata.fontStyle) + "</td>";
        result += "<tr><td class=\"tm-metadata-key\">foreground</td><td class=\"tm-metadata-value\">" + Color.Format.CSS.formatHex(metadata.foreground) + "</td>";
        result += "<tr><td class=\"tm-metadata-key\">background</td><td class=\"tm-metadata-value\">" + Color.Format.CSS.formatHex(metadata.background) + "</td>";
        result += "</tbody></table>";
        result += "<hr class=\"tokens-inspect-separator\"/>";
        if (token1Index < data.tokens1.length) {
            result += "<span class=\"tm-token-type\">" + escape(data.tokens1[token1Index].type) + "</span>";
        }
        this._domNode.innerHTML = result;
        this._editor.layoutContentWidget(this);
    };
    InspectTokensWidget.prototype._decodeMetadata = function (metadata) {
        var colorMap = TokenizationRegistry.getColorMap();
        var languageId = TokenMetadata.getLanguageId(metadata);
        var tokenType = TokenMetadata.getTokenType(metadata);
        var fontStyle = TokenMetadata.getFontStyle(metadata);
        var foreground$$1 = TokenMetadata.getForeground(metadata);
        var background = TokenMetadata.getBackground(metadata);
        return {
            languageIdentifier: this._modeService.getLanguageIdentifier(languageId),
            tokenType: tokenType,
            fontStyle: fontStyle,
            foreground: colorMap[foreground$$1],
            background: colorMap[background]
        };
    };
    InspectTokensWidget.prototype._tokenTypeToString = function (tokenType) {
        switch (tokenType) {
            case 0 /* Other */: return 'Other';
            case 1 /* Comment */: return 'Comment';
            case 2 /* String */: return 'String';
            case 4 /* RegEx */: return 'RegEx';
        }
        return '??';
    };
    InspectTokensWidget.prototype._fontStyleToString = function (fontStyle) {
        var r = '';
        if (fontStyle & 1 /* Italic */) {
            r += 'italic ';
        }
        if (fontStyle & 2 /* Bold */) {
            r += 'bold ';
        }
        if (fontStyle & 4 /* Underline */) {
            r += 'underline ';
        }
        if (r.length === 0) {
            r = '---';
        }
        return r;
    };
    InspectTokensWidget.prototype._getTokensAtLine = function (lineNumber) {
        var stateBeforeLine = this._getStateBeforeLine(lineNumber);
        var tokenizationResult1 = this._tokenizationSupport.tokenize(this._model.getLineContent(lineNumber), stateBeforeLine, 0);
        var tokenizationResult2 = this._tokenizationSupport.tokenize2(this._model.getLineContent(lineNumber), stateBeforeLine, 0);
        return {
            startState: stateBeforeLine,
            tokens1: tokenizationResult1.tokens,
            tokens2: tokenizationResult2.tokens,
            endState: tokenizationResult1.endState
        };
    };
    InspectTokensWidget.prototype._getStateBeforeLine = function (lineNumber) {
        var state = this._tokenizationSupport.getInitialState();
        for (var i = 1; i < lineNumber; i++) {
            var tokenizationResult = this._tokenizationSupport.tokenize(this._model.getLineContent(i), state, 0);
            state = tokenizationResult.endState;
        }
        return state;
    };
    InspectTokensWidget.prototype.getDomNode = function () {
        return this._domNode;
    };
    InspectTokensWidget.prototype.getPosition = function () {
        return {
            position: this._editor.getPosition(),
            preference: [ContentWidgetPositionPreference.BELOW, ContentWidgetPositionPreference.ABOVE]
        };
    };
    InspectTokensWidget._ID = 'editor.contrib.inspectTokensWidget';
    return InspectTokensWidget;
}(Disposable));
registerEditorContribution(InspectTokensController);
registerEditorAction(InspectTokens);
registerThemingParticipant(function (theme, collector) {
    var border = theme.getColor(editorHoverBorder);
    if (border) {
        var borderWidth = theme.type === HIGH_CONTRAST ? 2 : 1;
        collector.addRule(".monaco-editor .tokens-inspect-widget { border: " + borderWidth + "px solid " + border + "; }");
        collector.addRule(".monaco-editor .tokens-inspect-widget .tokens-inspect-separator { background-color: " + border + "; }");
    }
    var background = theme.getColor(editorHoverBackground);
    if (background) {
        collector.addRule(".monaco-editor .tokens-inspect-widget { background-color: " + background + "; }");
    }
});

const css$r = "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n.monaco-editor .iPadShowKeyboard {\n\twidth: 58px;\n\tmin-width: 0;\n\theight: 36px;\n\tmin-height: 0;\n\tmargin: 0;\n\tpadding: 0;\n\tposition: absolute;\n\tresize: none;\n\toverflow: hidden;\n\tbackground: url(\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI1OCIgaGVpZ2h0PSIzNiI+PHBhdGggZmlsbD0iI0YwRUZGMSIgZD0iTTU0IDMydi0yOGgtNTB2MjhoNTB6bS0xNi0yaC0xOHYtNmgxOHY2em02IDBoLTR2LTZoNHY2em04IDBoLTZ2LTZoNnY2em0tNC0yNGg0djRoLTR2LTR6bTAgNmg0djRoLTR2LTR6bTAgNmg0djRoLTR2LTR6bS02LTEyaDR2NGgtNHYtNHptMCA2aDR2NGgtNHYtNHptMCA2aDR2NGgtNHYtNHptLTYtMTJoNHY0aC00di00em0wIDZoNHY0aC00di00em0wIDZoNHY0aC00di00em0tNi0xMmg0djRoLTR2LTR6bTAgNmg0djRoLTR2LTR6bTAgNmg0djRoLTR2LTR6bS02LTEyaDR2NGgtNHYtNHptMCA2aDR2NGgtNHYtNHptMCA2aDR2NGgtNHYtNHptLTYtMTJoNHY0aC00di00em0wIDZoNHY0aC00di00em0wIDZoNHY0aC00di00em0wIDEyaC00di02aDR2NnptLTYtMjRoNHY0aC00di00em0wIDZoNHY0aC00di00em0wIDZoNHY0aC00di00em0tNi0xMmg0djRoLTR2LTR6bTAgNmg0djRoLTR2LTR6bTAgNmg0djRoLTR2LTR6bTAgNmg2djZoLTZ2LTZ6Ii8+PHBhdGggZmlsbD0iIzQyNDI0MiIgZD0iTTU1LjMzNiAwaC01My4yODVjLTEuMzQ0IDAtMi4wNTEuNjU2LTIuMDUxIDJ2MzJjMCAxLjM0NC43MDcgMS45NjUgMi4wNTEgMS45NjVsNTMuOTQ5LjAzNWMxLjM0NCAwIDItLjY1NiAyLTJ2LTMyYzAtMS4zNDQtMS4zMi0yLTIuNjY0LTJ6bS0xLjMzNiAzMmgtNTB2LTI4aDUwdjI4eiIvPjxyZWN0IHg9IjYiIHk9IjEyIiBmaWxsPSIjNDI0MjQyIiB3aWR0aD0iNCIgaGVpZ2h0PSI0Ii8+PHJlY3QgeD0iMTIiIHk9IjEyIiBmaWxsPSIjNDI0MjQyIiB3aWR0aD0iNCIgaGVpZ2h0PSI0Ii8+PHJlY3QgeD0iMTgiIHk9IjEyIiBmaWxsPSIjNDI0MjQyIiB3aWR0aD0iNCIgaGVpZ2h0PSI0Ii8+PHJlY3QgeD0iMjQiIHk9IjEyIiBmaWxsPSIjNDI0MjQyIiB3aWR0aD0iNCIgaGVpZ2h0PSI0Ii8+PHJlY3QgeD0iMzAiIHk9IjEyIiBmaWxsPSIjNDI0MjQyIiB3aWR0aD0iNCIgaGVpZ2h0PSI0Ii8+PHJlY3QgeD0iMzYiIHk9IjEyIiBmaWxsPSIjNDI0MjQyIiB3aWR0aD0iNCIgaGVpZ2h0PSI0Ii8+PHJlY3QgeD0iNDIiIHk9IjEyIiBmaWxsPSIjNDI0MjQyIiB3aWR0aD0iNCIgaGVpZ2h0PSI0Ii8+PHJlY3QgeD0iNDgiIHk9IjEyIiBmaWxsPSIjNDI0MjQyIiB3aWR0aD0iNCIgaGVpZ2h0PSI0Ii8+PHJlY3QgeD0iNiIgeT0iNiIgZmlsbD0iIzQyNDI0MiIgd2lkdGg9IjQiIGhlaWdodD0iNCIvPjxyZWN0IHg9IjEyIiB5PSI2IiBmaWxsPSIjNDI0MjQyIiB3aWR0aD0iNCIgaGVpZ2h0PSI0Ii8+PHJlY3QgeD0iMTgiIHk9IjYiIGZpbGw9IiM0MjQyNDIiIHdpZHRoPSI0IiBoZWlnaHQ9IjQiLz48cmVjdCB4PSIyNCIgeT0iNiIgZmlsbD0iIzQyNDI0MiIgd2lkdGg9IjQiIGhlaWdodD0iNCIvPjxyZWN0IHg9IjMwIiB5PSI2IiBmaWxsPSIjNDI0MjQyIiB3aWR0aD0iNCIgaGVpZ2h0PSI0Ii8+PHJlY3QgeD0iMzYiIHk9IjYiIGZpbGw9IiM0MjQyNDIiIHdpZHRoPSI0IiBoZWlnaHQ9IjQiLz48cmVjdCB4PSI0MiIgeT0iNiIgZmlsbD0iIzQyNDI0MiIgd2lkdGg9IjQiIGhlaWdodD0iNCIvPjxyZWN0IHg9IjQ4IiB5PSI2IiBmaWxsPSIjNDI0MjQyIiB3aWR0aD0iNCIgaGVpZ2h0PSI0Ii8+PHJlY3QgeD0iNiIgeT0iMTgiIGZpbGw9IiM0MjQyNDIiIHdpZHRoPSI0IiBoZWlnaHQ9IjQiLz48cmVjdCB4PSIxMiIgeT0iMTgiIGZpbGw9IiM0MjQyNDIiIHdpZHRoPSI0IiBoZWlnaHQ9IjQiLz48cmVjdCB4PSIxOCIgeT0iMTgiIGZpbGw9IiM0MjQyNDIiIHdpZHRoPSI0IiBoZWlnaHQ9IjQiLz48cmVjdCB4PSIyNCIgeT0iMTgiIGZpbGw9IiM0MjQyNDIiIHdpZHRoPSI0IiBoZWlnaHQ9IjQiLz48cmVjdCB4PSIzMCIgeT0iMTgiIGZpbGw9IiM0MjQyNDIiIHdpZHRoPSI0IiBoZWlnaHQ9IjQiLz48cmVjdCB4PSIzNiIgeT0iMTgiIGZpbGw9IiM0MjQyNDIiIHdpZHRoPSI0IiBoZWlnaHQ9IjQiLz48cmVjdCB4PSI0MiIgeT0iMTgiIGZpbGw9IiM0MjQyNDIiIHdpZHRoPSI0IiBoZWlnaHQ9IjQiLz48cmVjdCB4PSI0OCIgeT0iMTgiIGZpbGw9IiM0MjQyNDIiIHdpZHRoPSI0IiBoZWlnaHQ9IjQiLz48cmVjdCB4PSI2IiB5PSIyNCIgZmlsbD0iIzQyNDI0MiIgd2lkdGg9IjYiIGhlaWdodD0iNiIvPjxyZWN0IHg9IjQ2IiB5PSIyNCIgZmlsbD0iIzQyNDI0MiIgd2lkdGg9IjYiIGhlaWdodD0iNiIvPjxyZWN0IHg9IjIwIiB5PSIyNCIgZmlsbD0iIzQyNDI0MiIgd2lkdGg9IjE4IiBoZWlnaHQ9IjYiLz48cmVjdCB4PSIxNCIgeT0iMjQiIGZpbGw9IiM0MjQyNDIiIHdpZHRoPSI0IiBoZWlnaHQ9IjYiLz48cmVjdCB4PSI0MCIgeT0iMjQiIGZpbGw9IiM0MjQyNDIiIHdpZHRoPSI0IiBoZWlnaHQ9IjYiLz48L3N2Zz4=\") center center no-repeat;\n\tborder: 4px solid #F6F6F6;\n\tborder-radius: 4px;\n}\n\n.monaco-editor.vs-dark .iPadShowKeyboard {\n\tbackground: url(\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI1OCIgaGVpZ2h0PSIzNiI+PHBhdGggZmlsbD0iIzJCMjgyRSIgZD0iTTU0IDMydi0yOGgtNTB2MjhoNTB6bS0xNi0yaC0xOHYtNmgxOHY2em02IDBoLTR2LTZoNHY2em04IDBoLTZ2LTZoNnY2em0tNC0yNGg0djRoLTR2LTR6bTAgNmg0djRoLTR2LTR6bTAgNmg0djRoLTR2LTR6bS02LTEyaDR2NGgtNHYtNHptMCA2aDR2NGgtNHYtNHptMCA2aDR2NGgtNHYtNHptLTYtMTJoNHY0aC00di00em0wIDZoNHY0aC00di00em0wIDZoNHY0aC00di00em0tNi0xMmg0djRoLTR2LTR6bTAgNmg0djRoLTR2LTR6bTAgNmg0djRoLTR2LTR6bS02LTEyaDR2NGgtNHYtNHptMCA2aDR2NGgtNHYtNHptMCA2aDR2NGgtNHYtNHptLTYtMTJoNHY0aC00di00em0wIDZoNHY0aC00di00em0wIDZoNHY0aC00di00em0wIDEyaC00di02aDR2NnptLTYtMjRoNHY0aC00di00em0wIDZoNHY0aC00di00em0wIDZoNHY0aC00di00em0tNi0xMmg0djRoLTR2LTR6bTAgNmg0djRoLTR2LTR6bTAgNmg0djRoLTR2LTR6bTAgNmg2djZoLTZ2LTZ6Ii8+PHBhdGggZmlsbD0iI0M1QzVDNSIgZD0iTTU1LjMzNiAwaC01My4yODVjLTEuMzQ0IDAtMi4wNTEuNjU2LTIuMDUxIDJ2MzJjMCAxLjM0NC43MDcgMS45NjUgMi4wNTEgMS45NjVsNTMuOTQ5LjAzNWMxLjM0NCAwIDItLjY1NiAyLTJ2LTMyYzAtMS4zNDQtMS4zMi0yLTIuNjY0LTJ6bS0xLjMzNiAzMmgtNTB2LTI4aDUwdjI4eiIvPjxyZWN0IHg9IjYiIHk9IjEyIiBmaWxsPSIjQzVDNUM1IiB3aWR0aD0iNCIgaGVpZ2h0PSI0Ii8+PHJlY3QgeD0iMTIiIHk9IjEyIiBmaWxsPSIjQzVDNUM1IiB3aWR0aD0iNCIgaGVpZ2h0PSI0Ii8+PHJlY3QgeD0iMTgiIHk9IjEyIiBmaWxsPSIjQzVDNUM1IiB3aWR0aD0iNCIgaGVpZ2h0PSI0Ii8+PHJlY3QgeD0iMjQiIHk9IjEyIiBmaWxsPSIjQzVDNUM1IiB3aWR0aD0iNCIgaGVpZ2h0PSI0Ii8+PHJlY3QgeD0iMzAiIHk9IjEyIiBmaWxsPSIjQzVDNUM1IiB3aWR0aD0iNCIgaGVpZ2h0PSI0Ii8+PHJlY3QgeD0iMzYiIHk9IjEyIiBmaWxsPSIjQzVDNUM1IiB3aWR0aD0iNCIgaGVpZ2h0PSI0Ii8+PHJlY3QgeD0iNDIiIHk9IjEyIiBmaWxsPSIjQzVDNUM1IiB3aWR0aD0iNCIgaGVpZ2h0PSI0Ii8+PHJlY3QgeD0iNDgiIHk9IjEyIiBmaWxsPSIjQzVDNUM1IiB3aWR0aD0iNCIgaGVpZ2h0PSI0Ii8+PHJlY3QgeD0iNiIgeT0iNiIgZmlsbD0iI0M1QzVDNSIgd2lkdGg9IjQiIGhlaWdodD0iNCIvPjxyZWN0IHg9IjEyIiB5PSI2IiBmaWxsPSIjQzVDNUM1IiB3aWR0aD0iNCIgaGVpZ2h0PSI0Ii8+PHJlY3QgeD0iMTgiIHk9IjYiIGZpbGw9IiNDNUM1QzUiIHdpZHRoPSI0IiBoZWlnaHQ9IjQiLz48cmVjdCB4PSIyNCIgeT0iNiIgZmlsbD0iI0M1QzVDNSIgd2lkdGg9IjQiIGhlaWdodD0iNCIvPjxyZWN0IHg9IjMwIiB5PSI2IiBmaWxsPSIjQzVDNUM1IiB3aWR0aD0iNCIgaGVpZ2h0PSI0Ii8+PHJlY3QgeD0iMzYiIHk9IjYiIGZpbGw9IiNDNUM1QzUiIHdpZHRoPSI0IiBoZWlnaHQ9IjQiLz48cmVjdCB4PSI0MiIgeT0iNiIgZmlsbD0iI0M1QzVDNSIgd2lkdGg9IjQiIGhlaWdodD0iNCIvPjxyZWN0IHg9IjQ4IiB5PSI2IiBmaWxsPSIjQzVDNUM1IiB3aWR0aD0iNCIgaGVpZ2h0PSI0Ii8+PHJlY3QgeD0iNiIgeT0iMTgiIGZpbGw9IiNDNUM1QzUiIHdpZHRoPSI0IiBoZWlnaHQ9IjQiLz48cmVjdCB4PSIxMiIgeT0iMTgiIGZpbGw9IiNDNUM1QzUiIHdpZHRoPSI0IiBoZWlnaHQ9IjQiLz48cmVjdCB4PSIxOCIgeT0iMTgiIGZpbGw9IiNDNUM1QzUiIHdpZHRoPSI0IiBoZWlnaHQ9IjQiLz48cmVjdCB4PSIyNCIgeT0iMTgiIGZpbGw9IiNDNUM1QzUiIHdpZHRoPSI0IiBoZWlnaHQ9IjQiLz48cmVjdCB4PSIzMCIgeT0iMTgiIGZpbGw9IiNDNUM1QzUiIHdpZHRoPSI0IiBoZWlnaHQ9IjQiLz48cmVjdCB4PSIzNiIgeT0iMTgiIGZpbGw9IiNDNUM1QzUiIHdpZHRoPSI0IiBoZWlnaHQ9IjQiLz48cmVjdCB4PSI0MiIgeT0iMTgiIGZpbGw9IiNDNUM1QzUiIHdpZHRoPSI0IiBoZWlnaHQ9IjQiLz48cmVjdCB4PSI0OCIgeT0iMTgiIGZpbGw9IiNDNUM1QzUiIHdpZHRoPSI0IiBoZWlnaHQ9IjQiLz48cmVjdCB4PSI2IiB5PSIyNCIgZmlsbD0iI0M1QzVDNSIgd2lkdGg9IjYiIGhlaWdodD0iNiIvPjxyZWN0IHg9IjQ2IiB5PSIyNCIgZmlsbD0iI0M1QzVDNSIgd2lkdGg9IjYiIGhlaWdodD0iNiIvPjxyZWN0IHg9IjIwIiB5PSIyNCIgZmlsbD0iI0M1QzVDNSIgd2lkdGg9IjE4IiBoZWlnaHQ9IjYiLz48cmVjdCB4PSIxNCIgeT0iMjQiIGZpbGw9IiNDNUM1QzUiIHdpZHRoPSI0IiBoZWlnaHQ9IjYiLz48cmVjdCB4PSI0MCIgeT0iMjQiIGZpbGw9IiNDNUM1QzUiIHdpZHRoPSI0IiBoZWlnaHQ9IjYiLz48L3N2Zz4=\") center center no-repeat;\n\tborder: 4px solid #252526;\n}";
  const element$r = ((css, src) => {
if (typeof document !== 'object')
console.info(`Skipped loading "${src}"`);
try {
const id = src
  .replace(/\.css.*$/, '')
  .replace(/[\\:]/g, '/')
  .replace(/[^\w\/]+/g, '');
return (
  document.querySelector(`style[id="${id}"]`) ||
  document.head.appendChild(
    Object.assign(document.createElement('style'), {
      id,
      textContent: `${css}\n\n /* sourceURL=${src} */`,
    }),
  )
);
} catch (exception) {
console.warn(`Failed load "${src}"`, exception);
}
})(css$r, "…monaco-editor/esm/vs/editor/standalone/browser/iPadShowKeyboard/iPadShowKeyboard.css");
  //@ sourceURL=/Users/daflair/Projects/packages/monaco-es/node_modules/monaco-editor/esm/vs/editor/standalone/browser/iPadShowKeyboard/iPadShowKeyboard.css

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var IPadShowKeyboard = /** @class */ (function () {
    function IPadShowKeyboard(editor) {
        var _this = this;
        this.editor = editor;
        this.toDispose = [];
        if (isIPad) {
            this.toDispose.push(editor.onDidChangeConfiguration(function () { return _this.update(); }));
            this.update();
        }
    }
    IPadShowKeyboard.prototype.update = function () {
        var hasWidget = (!!this.widget);
        var shouldHaveWidget = (!this.editor.getConfiguration().readOnly);
        if (!hasWidget && shouldHaveWidget) {
            this.widget = new ShowKeyboardWidget(this.editor);
        }
        else if (hasWidget && !shouldHaveWidget) {
            this.widget.dispose();
            this.widget = null;
        }
    };
    IPadShowKeyboard.prototype.getId = function () {
        return IPadShowKeyboard.ID;
    };
    IPadShowKeyboard.prototype.dispose = function () {
        this.toDispose = dispose(this.toDispose);
        if (this.widget) {
            this.widget.dispose();
            this.widget = null;
        }
    };
    IPadShowKeyboard.ID = 'editor.contrib.iPadShowKeyboard';
    return IPadShowKeyboard;
}());
var ShowKeyboardWidget = /** @class */ (function () {
    function ShowKeyboardWidget(editor) {
        var _this = this;
        this.editor = editor;
        this._domNode = document.createElement('textarea');
        this._domNode.className = 'iPadShowKeyboard';
        this._toDispose = [];
        this._toDispose.push(addDisposableListener(this._domNode, 'touchstart', function (e) {
            _this.editor.focus();
        }));
        this._toDispose.push(addDisposableListener(this._domNode, 'focus', function (e) {
            _this.editor.focus();
        }));
        this.editor.addOverlayWidget(this);
    }
    ShowKeyboardWidget.prototype.dispose = function () {
        this.editor.removeOverlayWidget(this);
        this._toDispose = dispose(this._toDispose);
    };
    // ----- IOverlayWidget API
    ShowKeyboardWidget.prototype.getId = function () {
        return ShowKeyboardWidget.ID;
    };
    ShowKeyboardWidget.prototype.getDomNode = function () {
        return this._domNode;
    };
    ShowKeyboardWidget.prototype.getPosition = function () {
        return {
            preference: OverlayWidgetPositionPreference.BOTTOM_RIGHT_CORNER
        };
    };
    ShowKeyboardWidget.ID = 'editor.contrib.ShowKeyboardWidget';
    return ShowKeyboardWidget;
}());
registerEditorContribution(IPadShowKeyboard);

const css$s = "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n.monaco-quick-open-widget {\n\tfont-size: 13px;\n}\n\n.monaco-quick-open-widget .quick-open-tree .quick-open-entry .quick-open-entry-icon,\n.vs-dark .monaco-quick-open-widget .quick-open-tree .quick-open-entry .quick-open-entry-icon {\n\tbackground-image: url(\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIzMDAiIGhlaWdodD0iNDAiPjxwYXRoIGQ9Ik0yODguNDgzIDMzYy0uNzcyIDAtMS40OTctLjEyMy0yLjE1My0uMzY1LS42NzgtLjI1My0xLjI3LS42MTctMS43Ni0xLjA4NC0uNS0uNDc1LS44OTItMS4wNDktMS4xNjMtMS43MDQtLjI3LS42NDQtLjQwNy0xLjM3MS0uNDA3LTIuMTU4IDAtLjUxNy4wNjEtMS4wMTguMTc4LTEuNDkuMTE2LS40Ny4yOS0uOTI1LjUxNi0xLjM0OC4yMjUtLjQyMi41MDgtLjgxNS44NDQtMS4xNjcuMzM0LS4zNTIuNzE3LS42NTYgMS4xMzktLjkwNS40MTYtLjI0Ni44ODEtLjQ0IDEuMzgtLjU3Ni40OTMtLjEzNCAxLjAyNi0uMjAyIDEuNTg3LS4yMDIuNzA1IDAgMS4zODIuMTA5IDIuMDEzLjMyNC42NDIuMjE3IDEuMjE4LjUzOCAxLjcwOC45NTUuNTAxLjQyNS45MDMuOTQ4IDEuMTkzIDEuNTU2LjI5NC42MjMuNDQyIDEuMzE2LjQ0MiAyLjA2NCAwIC42MTktLjA5IDEuMTg1LS4yNjggMS42NzktLjE3OC40OTItLjQyLjkyLS43MjEgMS4yNzUtLjMzMS4zNzctLjY5OS42NTgtMS4xMDQuODQ3bC0uMDQ4LjAyMnYxLjUzbC0uNTg3LjI2NmMtLjEyOC4wNTktLjI4OC4xMTctLjQ3NC4xNzktLjE5My4wNjItLjQwNC4xMTQtLjY0NS4xNTktLjIyOS4wNC0uNDc3LjA3Ni0uNzUzLjEwMy0uMjcuMDI3LS41NzguMDQtLjkxNy4wNHoiIGZpbGw9IiMyRDJEMkQiLz48cGF0aCBkPSJNMjkxLjcxNiAyNC4wNDFjLS4zOTYtLjMzNi0uODU2LS41OTMtMS4zODQtLjc3MS0uNTI3LS4xOC0xLjA5LS4yNzEtMS42ODktLjI3MS0uNDczIDAtLjkxMi4wNTUtMS4zMjQuMTY3LS40MTQuMTEyLS43OTEuMjctMS4xMzUuNDczLS4zNDIuMjAyLS42NS40NDYtLjkyMi43MzMtLjI3My4yODYtLjUwMi42MDItLjY4Ni45NDktLjE4Ni4zNDctLjMzLjcyMi0uNDI4IDEuMTE5LS4xLjM5OS0uMTQ4LjgxNC0uMTQ4IDEuMjQ3IDAgLjY1Mi4xMDkgMS4yNDcuMzMyIDEuNzc2LjIxOS41MzEuNTMuOTg0LjkyOCAxLjM2MS4zOTYuMzc4Ljg3MS42NjcgMS40MTYuODcuNTQ4LjIwMiAxLjE1Mi4zMDQgMS44MDguMzA0LjMwMiAwIC41NzctLjAxMS44MjMtLjAzNS4yNDYtLjAyMy40NjgtLjA1Ni42NjQtLjA5MS4xOTUtLjAzNi4zNjYtLjA3OC41MTQtLjEyNWwuMzc1LS4xNHYtLjg1NGwtLjQ2My4xODRjLS4xNi4wNTYtLjMzNi4xMDQtLjUyMS4xNDMtLjE4OC4wMzctLjM4Ny4wNjktLjYwNC4wODktLjIxMy4wMjQtLjQ0OC4wMzQtLjcuMDM0LS41NjIgMC0xLjA2NC0uMDg4LTEuNTA5LS4yNjQtLjQ0Mi0uMTc2LS44MTYtLjQyMS0xLjEyNS0uNzMxLS4zMDktLjMxNC0uNTQ1LS42ODctLjcwOC0xLjEyNC0uMTYxLS40MzUtLjI0My0uOTEzLS4yNDMtMS40MzIgMC0uNTQ1LjA5LTEuMDUzLjI3My0xLjUyMi4xODItLjQ3MS40MzUtLjg3OS43NTgtMS4yMjUuMzI0LS4zNDUuNzA4LS42MTcgMS4xNTUtLjgxNS40NDYtLjE5Ni45MzQtLjI5NCAxLjQ1Ny0uMjk0LjQxOSAwIC43OTguMDQ0IDEuMTIyLjEzNi4zMjkuMDkxLjYyLjIxNS44NzEuMzY5LjI1NC4xNTguNDY1LjMzOS42NDMuNTQ3LjE3OS4yMDkuMzI0LjQzMi40MzguNjY3LjExMy4yMzcuMTkzLjQ4LjI0Ni43MzEuMDUxLjI1NC4wNzYuNS4wNzYuNzQxIDAgLjM0NC0uMDMzLjY1My0uMTAyLjkyNi0uMDY4LjI3NC0uMTU4LjUwMy0uMjY5LjY5NC0uMTEuMTg5LS4yMzkuMzM1LS4zODYuNDM0cy0uMjk1LjE0OC0uNDUzLjE0OGwtLjIxNS0uMDQ1Yy0uMDY2LS4wMjktLjExOS0uMDgtLjE2Ni0uMTU2LS4wNDYtLjA3NS0uMDgyLS4xNzctLjEwNy0uMzA2LS4wMjUtLjEyNi0uMDM5LS4yOTItLjAzOS0uNDkybC4wMTgtLjMyNS4wNDEtLjUzLjA1NS0uNjQ0LjA1OC0uNjQ3LjA0OC0uNTQ2LjAyNy0uMzQ0aC0uOTE5bC0uMDU0LjZoLS4wMjFjLS4wMjUtLjEwMy0uMDctLjE5NS0uMTM2LS4yODEtLjA2My0uMDgzLS4xNDEtLjE1NS0uMjMzLS4yMTYtLjA5MS0uMDYxLS4xOTMtLjEwNi0uMzA3LS4xNDEtLjExNS0uMDMzLS4yMzgtLjA0OC0uMzY5LS4wNDgtLjMzNyAwLS42NDYuMDctLjkyNC4yMTYtLjI4MS4xNDQtLjUxOC4zNDQtLjcyMS41OTktLjIwMS4yNTQtLjM1NS41NTYtLjQ2NS45MDUtLjExNS4zNS0uMTcuNzI2LS4xNyAxLjEzNCAwIC4zNDQuMDQ1LjY0NS4xMzUuOTAxLjA4OC4yNi4yMTEuNDczLjM1OS42NDYuMTUzLjE3MS4zMjkuMy41MzQuMzgyLjIuMDg2LjQxNS4xMjkuNjQxLjEyOS4xNzYgMCAuMzQyLS4wMjcuNDk5LS4wODEuMTU0LS4wNTIuMzAyLS4xMy40MzItLjIzMi4xMzQtLjEwNC4yNDgtLjIzLjM0OC0uMzguMTAyLS4xNDkuMTgyLS4zMjMuMjM2LS41MmguMDI3YzAgLjM3Ni4xMDEuNjc0LjMwNy44OTMuMjA3LjIyLjUwMi4zMy44ODkuMzMuMjkyIDAgLjU4LS4wNjQuODYzLS4xOTguMjgzLS4xMzIuNTM2LS4zMjguNzYyLS41ODYuMjIzLS4yNjIuNDA0LS41ODMuNTQzLS45NjYuMTM4LS4zODQuMjA4LS44My4yMDgtMS4zNCAwLS42MDUtLjExNy0xLjE1LS4zNDUtMS42MzQtLjIzMS0uNDgyLS41NDYtLjg5MS0uOTM5LTEuMjI1bS0yLjM2OCAzLjc3NGMtLjA1Ni4yNzctLjEzNi41MTctLjI0Ni43MTktLjEwOS4yMDMtLjI0Ni4zNjMtLjQwNy40ODEtLjE2My4xMTUtLjM1NC4xNzYtLjU3Mi4xNzYtLjEyIDAtLjIzNi0uMDI1LS4zNDQtLjA3OC0uMTA4LS4wNTItLjIwNi0uMTMtLjI4OS0uMjMyLS4wODEtLjEwMy0uMTQ4LS4yMzQtLjE5OC0uMzktLjA0Ni0uMTU2LS4wNy0uMzM3LS4wNy0uNTQ3IDAtLjIzNy4wMjctLjQ4MS4wOC0uNzI5LjA1Ni0uMjQ3LjEzNy0uNDczLjI1LS42NzcuMTA5LS4yLjI1LS4zNjMuNDE2LS40OTIuMTY1LS4xMjcuMzYxLS4xOTEuNTgyLS4xOTEuMTIzIDAgLjIzNC4wMjEuMzQuMDYzLjEwNy4wNDIuMTk4LjEwNy4yNzkuMTk2LjA4LjA4Ny4xNDUuMTk3LjE4OS4zMy4wNDMuMTM0LjA3LjI5NC4wNy40OCAwIC4zMTctLjAzMS42MTUtLjA4Ljg5MSIgZmlsbD0iI0M1QzVDNSIvPjxwYXRoIGQ9Ik0yODguNDgzIDEzYy0uNzcyIDAtMS40OTctLjEyMy0yLjE1My0uMzY1LS42NzgtLjI1My0xLjI3LS42MTctMS43Ni0xLjA4NC0uNS0uNDc1LS44OTItMS4wNDktMS4xNjMtMS43MDQtLjI2OS0uNjQ0LS40MDctMS4zNzEtLjQwNy0yLjE1OSAwLS41MTcuMDYxLTEuMDE4LjE3OC0xLjQ5LjExNi0uNDcuMjktLjkyNS41MTYtMS4zNDguMjI1LS40MjIuNTA4LS44MTUuODQ0LTEuMTY3LjMzNC0uMzUyLjcxNy0uNjU2IDEuMTM5LS45MDUuNDE2LS4yNDYuODgxLS40NCAxLjM4LS41NzYuNDkyLS4xMzQgMS4wMjUtLjIwMiAxLjU4Ni0uMjAyLjcwNSAwIDEuMzgyLjEwOSAyLjAxMy4zMjQuNjQyLjIxNyAxLjIxOC41MzggMS43MDguOTU1LjUwMS40MjUuOTAzLjk0OCAxLjE5MyAxLjU1Ni4yOTUuNjI0LjQ0MyAxLjMxNy40NDMgMi4wNjUgMCAuNjE5LS4wOSAxLjE4NS0uMjY4IDEuNjc5LS4xNzguNDkyLS40Mi45Mi0uNzIxIDEuMjc1LS4zMzEuMzc3LS42OTkuNjU4LTEuMTA0Ljg0N2wtLjA0OC4wMjJ2MS41M2wtLjU4Ny4yNjZjLS4xMjguMDU5LS4yODguMTE3LS40NzQuMTc5LS4xOTMuMDYyLS40MDQuMTE0LS42NDUuMTU5LS4yMjkuMDQtLjQ3Ny4wNzYtLjc1My4xMDMtLjI3LjAyNy0uNTc4LjA0LS45MTcuMDR6IiBmaWxsPSIjRjNGM0YzIi8+PHBhdGggZD0iTTI5MS43MTYgNC4wNDFjLS4zOTYtLjMzNi0uODU2LS41OTMtMS4zODQtLjc3MS0uNTI3LS4xNzktMS4wOS0uMjctMS42ODktLjI3LS40NzMgMC0uOTEyLjA1NS0xLjMyNC4xNjctLjQxNC4xMTItLjc5MS4yNy0xLjEzNS40NzMtLjM0Mi4yMDItLjY1LjQ0Ni0uOTIyLjczMy0uMjczLjI4Ni0uNTAyLjYwMi0uNjg2Ljk0OS0uMTg2LjM0Ny0uMzMuNzIyLS40MjggMS4xMTktLjA5OS40LS4xNDguODE1LS4xNDggMS4yNDcgMCAuNjUyLjEwOSAxLjI0Ny4zMzIgMS43NzYuMjE5LjUzMS41My45ODQuOTI4IDEuMzYxLjM5Ni4zNzguODcxLjY2NyAxLjQxNi44Ny41NDguMjAyIDEuMTUyLjMwNCAxLjgwOC4zMDQuMzAyIDAgLjU3Ny0uMDExLjgyMy0uMDM1LjI0Ni0uMDIzLjQ2OC0uMDU2LjY2NC0uMDkxLjE5NS0uMDM2LjM2Ni0uMDc4LjUxNC0uMTI1bC4zNzUtLjE0di0uODU0bC0uNDYzLjE4NGMtLjE2LjA1Ni0uMzM2LjEwNC0uNTIxLjE0My0uMTg4LjAzNy0uMzg3LjA2OS0uNjA0LjA4OS0uMjEzLjAyNC0uNDQ4LjAzNC0uNy4wMzQtLjU2MiAwLTEuMDY0LS4wODgtMS41MDktLjI2NC0uNDQyLS4xNzYtLjgxNi0uNDIxLTEuMTI1LS43MzEtLjMwOS0uMzE0LS41NDUtLjY4Ny0uNzA4LTEuMTI0LS4xNjEtLjQzNS0uMjQzLS45MTMtLjI0My0xLjQzMiAwLS41NDUuMDktMS4wNTMuMjczLTEuNTIyLjE4Mi0uNDcxLjQzNS0uODc5Ljc1OC0xLjIyNS4zMjQtLjM0NS43MDgtLjYxNyAxLjE1NS0uODE1LjQ0Ni0uMTk2LjkzNC0uMjk0IDEuNDU3LS4yOTQuNDE5IDAgLjc5OC4wNDQgMS4xMjIuMTM2LjMyOS4wOTEuNjIuMjE1Ljg3MS4zNjkuMjU0LjE1OC40NjUuMzM5LjY0My41NDcuMTc5LjIwOS4zMjQuNDMyLjQzOC42NjcuMTEzLjIzNy4xOTMuNDguMjQ2LjczMS4wNTEuMjU0LjA3Ni41LjA3Ni43NDEgMCAuMzQ0LS4wMzMuNjUzLS4xMDIuOTI2LS4wNjguMjc0LS4xNTguNTAzLS4yNjkuNjk0LS4xMS4xODktLjIzOS4zMzUtLjM4Ni40MzRzLS4yOTUuMTQ4LS40NTMuMTQ4bC0uMjE1LS4wNDVjLS4wNjYtLjAyOS0uMTE5LS4wOC0uMTY2LS4xNTYtLjA0Ni0uMDc1LS4wODItLjE3Ny0uMTA3LS4zMDYtLjAyNS0uMTI2LS4wMzktLjI5Mi0uMDM5LS40OTJsLjAxOC0uMzI1LjA0MS0uNTMuMDU1LS42NDQuMDU4LS42NDcuMDQ4LS41NDYuMDI3LS4zNDRoLS45MTlsLS4wNTQuNmgtLjAyMWMtLjAyNS0uMTAzLS4wNy0uMTk1LS4xMzYtLjI4MS0uMDYzLS4wODMtLjE0MS0uMTU1LS4yMzMtLjIxNi0uMDkxLS4wNjEtLjE5My0uMTA2LS4zMDctLjE0MS0uMTE1LS4wMzMtLjIzOC0uMDQ4LS4zNjktLjA0OC0uMzM3IDAtLjY0Ni4wNy0uOTI0LjIxNi0uMjgxLjE0NC0uNTE4LjM0NC0uNzIxLjU5OS0uMjAxLjI1NC0uMzU1LjU1Ni0uNDY1LjkwNS0uMTE1LjM1LS4xNy43MjYtLjE3IDEuMTM0IDAgLjM0NC4wNDUuNjQ1LjEzNS45MDEuMDg4LjI2LjIxMS40NzMuMzU5LjY0Ni4xNTMuMTcxLjMyOS4zLjUzNC4zODIuMi4wODYuNDE1LjEyOS42NDEuMTI5LjE3NiAwIC4zNDItLjAyNy40OTktLjA4MS4xNTQtLjA1Mi4zMDItLjEzLjQzMi0uMjMyLjEzNC0uMTA0LjI0OC0uMjMuMzQ4LS4zOC4xMDItLjE0OS4xODItLjMyMy4yMzYtLjUyaC4wMjdjMCAuMzc2LjEwMS42NzQuMzA3Ljg5My4yMDcuMjIuNTAyLjMzLjg4OS4zMy4yOTIgMCAuNTgtLjA2NC44NjMtLjE5OC4yODMtLjEzMi41MzYtLjMyOC43NjItLjU4Ni4yMjMtLjI2Mi40MDQtLjU4My41NDMtLjk2Ni4xMzgtLjM4NS4yMDgtLjgzMS4yMDgtMS4zNDEgMC0uNjA1LS4xMTctMS4xNS0uMzQ1LTEuNjM0LS4yMzEtLjQ4Mi0uNTQ2LS44OTEtLjkzOS0xLjIyNW0tMi4zNjggMy43NzRjLS4wNTYuMjc3LS4xMzYuNTE3LS4yNDYuNzE5LS4xMDkuMjAzLS4yNDYuMzYzLS40MDcuNDgxLS4xNjMuMTE1LS4zNTQuMTc2LS41NzIuMTc2LS4xMiAwLS4yMzYtLjAyNS0uMzQ0LS4wNzgtLjEwOC0uMDUyLS4yMDYtLjEzLS4yODktLjIzMi0uMDgxLS4xMDMtLjE0OC0uMjM0LS4xOTgtLjM5LS4wNDYtLjE1Ni0uMDctLjMzNy0uMDctLjU0NyAwLS4yMzcuMDI3LS40ODEuMDgtLjcyOS4wNTYtLjI0Ny4xMzctLjQ3My4yNS0uNjc3LjEwOS0uMi4yNS0uMzYzLjQxNi0uNDkyLjE2NS0uMTI3LjM2MS0uMTkxLjU4Mi0uMTkxLjEyMyAwIC4yMzQuMDIxLjM0LjA2My4xMDcuMDQyLjE5OC4xMDcuMjc5LjE5Ni4wOC4wODcuMTQ1LjE5Ny4xODkuMzMuMDQzLjEzNC4wNy4yOTQuMDcuNDggMCAuMzE3LS4wMzEuNjE1LS4wOC44OTEiIGZpbGw9IiM0MjQyNDIiLz48cGF0aCBkPSJNMjY0IDM3di0xNGg4LjYyNWwzLjM3NSAzLjU1NnYxMC40NDRoLTEyeiIgZmlsbD0iIzJEMkQyRCIvPjxwYXRoIGQ9Ik0yNzIgMjRoLTd2MTJoMTB2LTlsLTMtM3ptMiAxMWgtOHYtMTBoNXYzaDN2N3oiIGZpbGw9IiNDNUM1QzUiLz48cG9seWdvbiBwb2ludHM9IjI2NiwyNSAyNzEsMjUgMjcxLDI4IDI3NCwyOCAyNzQsMzUgMjY2LDM1IiBmaWxsPSIjMkQyRDJEIi8+PHBhdGggZD0iTTI2NCAxN3YtMTRoOC42MjVsMy4zNzUgMy41NTZ2MTAuNDQ0aC0xMnoiIGZpbGw9IiNGM0YzRjMiLz48cGF0aCBkPSJNMjcyIDRoLTd2MTJoMTB2LTlsLTMtM3ptMiAxMWgtOHYtMTBoNXYzaDN2N3oiIGZpbGw9IiM0MjQyNDIiLz48cG9seWdvbiBwb2ludHM9IjI2Niw1IDI3MSw1IDI3MSw4IDI3NCw4IDI3NCwxNSAyNjYsMTUiIGZpbGw9IiNGMEVGRjEiLz48cG9seWdvbiBwb2ludHM9IjI0NywzNCAyNDcsMzAgMjQ1LDMwIDI0NSwyNiAyNTUsMjYgMjU1LDM0IiBmaWxsPSIjMkQyRDJEIi8+PHBhdGggZD0iTTI1NCAyOWgtOHYtMmg4djJ6bTAgMWgtNnYxaDZ2LTF6bTAgMmgtNnYxaDZ2LTF6IiBmaWxsPSIjQzVDNUM1Ii8+PHBvbHlnb24gcG9pbnRzPSIyNDcsMTQgMjQ3LDEwIDI0NSwxMCAyNDUsNiAyNTUsNiAyNTUsMTQiIGZpbGw9IiNGM0YzRjMiLz48cGF0aCBkPSJNMjU0IDloLTh2LTJoOHYyem0wIDFoLTZ2MWg2di0xem0wIDJoLTZ2MWg2di0xeiIgZmlsbD0iIzQyNDI0MiIvPjxwYXRoIGQ9Ik0yMzAuNSAyMmMtNC4xNDMgMC03LjUgMy4zNTctNy41IDcuNXMzLjM1NyA3LjUgNy41IDcuNSA3LjUtMy4zNTcgNy41LTcuNS0zLjM1Ny03LjUtNy41LTcuNXptMCAxMWMtMS45MzMgMC0zLjUtMS41NjYtMy41LTMuNXMxLjU2Ny0zLjUgMy41LTMuNSAzLjUgMS41NjYgMy41IDMuNS0xLjU2NyAzLjUtMy41IDMuNXoiIGZpbGw9IiMyRDJEMkQiLz48cGF0aCBkPSJNMjI0LjAyNSAyOWMuMTA4LTEuNDE4LjY2OS0yLjcwOCAxLjU0Mi0zLjcyNmwxLjQzMSAxLjQzMWMtLjUxNi42NDYtLjg1MSAxLjQzLS45NDcgMi4yOTVoLTIuMDI2em0yLjk3MyAzLjI5NWMtLjUxNi0uNjQ2LS44NTEtMS40My0uOTQ3LTIuMjk1aC0yLjAyNWMuMTA4IDEuNDE4LjY2OSAyLjcwNyAxLjU0MiAzLjcyNmwxLjQzLTEuNDMxem00LjAwMi05LjI3djIuMDI1Yy44NjUuMDk3IDEuNjQ5LjQzMiAyLjI5NS45NDdsMS40MzEtMS40MzFjLTEuMDE4LS44NzItMi4zMDgtMS40MzItMy43MjYtMS41NDF6bS0zLjI5NSAyLjk3M2MuNjQ2LS41MTYgMS40My0uODUxIDIuMjk1LS45NDd2LTIuMDI1Yy0xLjQxOC4xMDgtMi43MDguNjY5LTMuNzI2IDEuNTQybDEuNDMxIDEuNDN6bTYuMjk3LjcwN2MuNTE2LjY0Ni44NTEgMS40My45NDcgMi4yOTVoMi4wMjVjLS4xMDgtMS40MTgtLjY2OS0yLjcwOC0xLjU0Mi0zLjcyNmwtMS40MyAxLjQzMXptLTQuMDAyIDcuMjQ0Yy0uODY1LS4wOTctMS42NDktLjQzMi0yLjI5NS0uOTQ3bC0xLjQzMSAxLjQzMWMxLjAxOC44NzMgMi4zMDcgMS40MzQgMy43MjYgMS41NDJ2LTIuMDI2em00Ljk0OS0zLjk0OWMtLjA5Ny44NjUtLjQzMiAxLjY0OC0uOTQ3IDIuMjk1bDEuNDMxIDEuNDMxYy44NzMtMS4wMTkgMS40MzQtMi4zMDggMS41NDItMy43MjZoLTIuMDI2em0tMS42NTQgMy4wMDJjLS42NDYuNTE2LTEuNDMuODUxLTIuMjk1Ljk0N3YyLjAyNWMxLjQxOS0uMTA4IDIuNzA4LS42NjkgMy43MjYtMS41NDJsLTEuNDMxLTEuNDN6IiBmaWxsPSIjQzVDNUM1Ii8+PHBhdGggZD0iTTIzMC41IDJjLTQuMTQzIDAtNy41IDMuMzU4LTcuNSA3LjUgMCA0LjE0MyAzLjM1NyA3LjUgNy41IDcuNXM3LjUtMy4zNTcgNy41LTcuNWMwLTQuMTQyLTMuMzU3LTcuNS03LjUtNy41em0wIDExYy0xLjkzMyAwLTMuNS0xLjU2Ni0zLjUtMy41IDAtMS45MzMgMS41NjctMy41IDMuNS0zLjVzMy41IDEuNTY3IDMuNSAzLjVjMCAxLjkzNC0xLjU2NyAzLjUtMy41IDMuNXoiIGZpbGw9IiNGM0YzRjMiLz48cGF0aCBkPSJNMjI0LjAyNSA5Yy4xMDgtMS40MTguNjY5LTIuNzA4IDEuNTQyLTMuNzI2bDEuNDMxIDEuNDMxYy0uNTE2LjY0Ni0uODUxIDEuNDMtLjk0NyAyLjI5NGgtMi4wMjZ6bTIuOTczIDMuMjk1Yy0uNTE2LS42NDYtLjg1MS0xLjQzLS45NDctMi4yOTVoLTIuMDI1Yy4xMDggMS40MTguNjY5IDIuNzA3IDEuNTQyIDMuNzI2bDEuNDMtMS40MzF6bTQuMDAyLTkuMjd2Mi4wMjVjLjg2NS4wOTcgMS42NDkuNDMyIDIuMjk1Ljk0OGwxLjQzMS0xLjQzMWMtMS4wMTgtLjg3My0yLjMwOC0xLjQzMy0zLjcyNi0xLjU0MnptLTMuMjk1IDIuOTc0Yy42NDYtLjUxNiAxLjQzLS44NTEgMi4yOTUtLjk0OHYtMi4wMjZjLTEuNDE4LjEwOC0yLjcwOC42NjktMy43MjYgMS41NDJsMS40MzEgMS40MzJ6bTYuMjk3LjcwN2MuNTE2LjY0Ni44NTEgMS40My45NDcgMi4yOTRoMi4wMjVjLS4xMDgtMS40MTgtLjY2OS0yLjcwOC0xLjU0Mi0zLjcyNmwtMS40MyAxLjQzMnptLTQuMDAyIDcuMjQzYy0uODY1LS4wOTctMS42NDktLjQzMi0yLjI5NS0uOTQ3bC0xLjQzMSAxLjQzMWMxLjAxOC44NzMgMi4zMDcgMS40MzQgMy43MjYgMS41NDJ2LTIuMDI2em00Ljk0OS0zLjk0OWMtLjA5Ny44NjUtLjQzMiAxLjY0OC0uOTQ3IDIuMjk1bDEuNDMxIDEuNDMxYy44NzMtMS4wMTkgMS40MzQtMi4zMDggMS41NDItMy43MjZoLTIuMDI2em0tMS42NTQgMy4wMDJjLS42NDYuNTE2LTEuNDMuODUxLTIuMjk1Ljk0N3YyLjAyNWMxLjQxOS0uMTA4IDIuNzA4LS42NjkgMy43MjYtMS41NDJsLTEuNDMxLTEuNDN6IiBmaWxsPSIjNDI0MjQyIi8+PHJlY3QgeD0iMjAyIiB5PSIyMyIgd2lkdGg9IjE2IiBoZWlnaHQ9IjE0IiBmaWxsPSIjMkQyRDJEIi8+PHBhdGggZD0iTTIwMyAyNHYxMmgxNHYtMTJoLTE0em0xMyAxMWgtMTJ2LTEwaDEydjEwem0tNi03di0xaC0xdjVoM3YtNGgtMnptMSAzaC0xdi0yaDF2MnptMy0ydjJoMXYxaC0ydi00aDJ2MWgtMXptLTYtMXY0aC0zdi0yaDF2MWgxdi0xaC0xdi0xaC0xdi0xaDN6IiBmaWxsPSIjQzVDNUM1Ii8+PHBhdGggZD0iTTIxMCAyOWgxdjJoLTF2LTJ6bS0zIDJ2LTFoLTF2MWgxem05LTZ2MTBoLTEydi0xMGgxMnptLTggM2gtM3YxaDF2MWgtMXYyaDN2LTR6bTQgMGgtMnYtMWgtMXY1aDN2LTR6bTMgMGgtMnY0aDJ2LTFoLTF2LTJoMXYtMXoiIGZpbGw9IiMyRDJEMkQiLz48cmVjdCB4PSIyMDIiIHk9IjMiIHdpZHRoPSIxNiIgaGVpZ2h0PSIxNCIgZmlsbD0iI0YzRjNGMyIvPjxwYXRoIGQ9Ik0yMDMgNHYxMmgxNHYtMTJoLTE0em0xMyAxMWgtMTJ2LTEwaDEydjEwem0tNi03di0xaC0xdjVoM3YtNGgtMnptMSAzaC0xdi0yaDF2MnptMy0ydjJoMXYxaC0ydi00aDJ2MWgtMXptLTYtMXY0aC0zdi0yaDF2MWgxdi0xaC0xdi0xaC0xdi0xaDN6IiBmaWxsPSIjNDI0MjQyIi8+PHBhdGggZD0iTTIxMCA5aDF2MmgtMXYtMnptLTMgMnYtMWgtMXYxaDF6bTktNnYxMGgtMTJ2LTEwaDEyem0tOCAzaC0zdjFoMXYxaC0xdjJoM3YtNHptNCAwaC0ydi0xaC0xdjVoM3YtNHptMyAwaC0ydjRoMnYtMWgtMXYtMmgxdi0xeiIgZmlsbD0iI0YwRUZGMSIvPjxwYXRoIGQ9Ik0xOTYuNjUyIDMyLjVjLjgxMS0uNTM3IDEuMzQ4LTEuNDU3IDEuMzQ4LTIuNSAwLTEuNjU0LTEuMzQ2LTMtMy0zLS43NzEgMC0xLjQ2OC4zMDEtMiAuNzc5di01Ljc3OWgtMTF2MTJoMy43NjRsLTEuNDUyLjcyNyAxLjQ4MSAxLjQ4Yy4zMjIuMzIyLjgwMy41IDEuMzU0LjUuNDM2IDAgLjg5Ny0uMTExIDEuMzAxLS4zMTNsMy4xNDQtMS41NzJjLjEzNC4wNTMuMjcxLjA5OC40MTQuMTI3bC0uMDA1LjA1MWMwIDEuNjU0IDEuMzQ2IDMgMyAzczMtMS4zNDYgMy0zYy0uMDAxLTEuMDQzLS41MzgtMS45NjMtMS4zNDktMi41eiIgZmlsbD0iIzJEMkQyRCIvPjxwYXRoIGQ9Ik0xOTUgMzNjLS4yOTMgMC0uNTY5LjA2Ni0uODIuMThsLS4yNS0uMjVjLjA0Mi0uMTM3LjA3LS4yNzkuMDctLjQzcy0uMDI4LS4yOTMtLjA3LS40M2wuMjUtLjI1Yy4yNTEuMTEzLjUyNy4xOC44Mi4xOCAxLjEwNCAwIDItLjg5NiAyLTIgMC0xLjEwNS0uODk2LTItMi0ycy0yIC44OTUtMiAyYzAgLjI5My4wNjYuNTY4LjE4LjgybC0uMjUuMjVjLS4xMzctLjA0My0uMjc5LS4wNy0uNDMtLjA3LS4zMzcgMC0uNjQ1LjExNS0uODk1LjMwM2wtMi42MDctMS4zMDUtLjk5OS0uNWMtLjU1Mi0uMjc1LTEuMjIzLS4yNzUtMS40OTkuMDAybC0uNS41IDUgMi41LTUgMi41LjUuNWMuMjc2LjI3NS45NDcuMjc1IDEuNSAwbDEtLjUgMi42MDUtMS4zMDNjLjI1LjE4OC41NTguMzAzLjg5NS4zMDMuMTUgMCAuMjkzLS4wMjkuNDMtLjA3bC4yNS4yNWMtLjExNC4yNS0uMTguNTI3LS4xOC44MiAwIDEuMTA0Ljg5NiAyIDIgMnMyLS44OTYgMi0yYzAtMS4xMDUtLjg5Ni0yLTItMnptMC00Yy41NTMgMCAxIC40NDcgMSAxIDAgLjU1MS0uNDQ3IDEtMSAxcy0xLS40NDktMS0xYzAtLjU1My40NDctMSAxLTF6bS0yLjUgNGMtLjI3NiAwLS41LS4yMjUtLjUtLjUgMC0uMjc3LjIyNC0uNS41LS41cy41LjIyMy41LjVjMCAuMjc1LS4yMjQuNS0uNS41em0yLjUgM2MtLjU1MyAwLTEtLjQ0OS0xLTEgMC0uNTUzLjQ0Ny0xIDEtMXMxIC40NDcgMSAxYzAgLjU1MS0uNDQ3IDEtMSAxem0tMy0xM3Y3LjA1MWMtLjE0Mi4wMjktLjI3OS4wNy0uNDEzLjEyM2wtLjU4Ny0uMTc0di02aC03djdoLTF2LThoOXptLTggMTBoLTF2LTFoMXYxem0yLTFoLTF2MWgxdi0xem0yIDBoLTF2MWgxdi0xeiIgZmlsbD0iI0M1QzVDNSIvPjxwYXRoIGQ9Ik0xODUuNzkzIDI4Ljc5M2wtMS43OTMgMS4yMDd2LTZoN3Y1LjM4MWwtMi41NTQtLjc3N2MtLjgxNi0uNDA5LTEuOTktLjQ3NS0yLjY1My4xODl6bS0uNzkzIDIuMjA3aC43NjRsLS43NjQtLjM4M3YuMzgzem0xMSA0YzAgLjU1MS0uNDQ3IDEtMSAxcy0xLS40NDktMS0xYzAtLjU1My40NDctMSAxLTFzMSAuNDQ3IDEgMXptLTMuNS0zYy0uMjc2IDAtLjUuMjIzLS41LjUgMCAuMjc1LjIyNC41LjUuNXMuNS0uMjI1LjUtLjVjMC0uMjc3LS4yMjQtLjUtLjUtLjV6bTIuNS0zYy0uNTUzIDAtMSAuNDQ3LTEgMSAwIC41NTEuNDQ3IDEgMSAxczEtLjQ0OSAxLTFjMC0uNTUzLS40NDctMS0xLTF6IiBmaWxsPSIjMkQyRDJEIi8+PHBhdGggZD0iTTE5Ni42NTIgMTIuNWMuODExLS41MzggMS4zNDgtMS40NTggMS4zNDgtMi41IDAtMS42NTQtMS4zNDYtMy0zLTMtLjc3MSAwLTEuNDY4LjMwMS0yIC43Nzl2LTUuNzc5aC0xMXYxMmgzLjc2NGwtMS40NTIuNzI3IDEuNDgxIDEuNDhjLjMyMi4zMjIuODAzLjUgMS4zNTQuNS40MzYgMCAuODk3LS4xMTEgMS4zMDEtLjMxM2wzLjE0NC0xLjU3MmMuMTM0LjA1My4yNzEuMDk4LjQxNC4xMjdsLS4wMDUuMDUxYzAgMS42NTQgMS4zNDYgMyAzIDNzMy0xLjM0NiAzLTNjLS4wMDEtMS4wNDMtLjUzOC0xLjk2My0xLjM0OS0yLjV6IiBmaWxsPSIjRjNGM0YzIi8+PHBhdGggZD0iTTE5NSAxM2MtLjI5MyAwLS41NjkuMDY2LS44Mi4xOGwtLjI1LS4yNWMuMDQyLS4xMzcuMDctLjI3OS4wNy0uNDNzLS4wMjgtLjI5My0uMDctLjQzbC4yNS0uMjVjLjI1MS4xMTMuNTI3LjE4LjgyLjE4IDEuMTA0IDAgMi0uODk2IDItMiAwLTEuMTA1LS44OTYtMi0yLTJzLTIgLjg5NS0yIDJjMCAuMjkzLjA2Ni41NjguMTguODJsLS4yNS4yNWMtLjEzNy0uMDQzLS4yNzktLjA3LS40My0uMDctLjMzNyAwLS42NDUuMTE1LS44OTUuMzAzbC0yLjYwNy0xLjMwNC0uOTk5LS41Yy0uNTUyLS4yNzUtMS4yMjMtLjI3NS0xLjQ5OS4wMDJsLS41LjQ5OSA1IDIuNS01IDIuNS41LjVjLjI3Ni4yNzUuOTQ3LjI3NSAxLjUgMGwxLS41IDIuNjA1LTEuMzAzYy4yNS4xODguNTU4LjMwMy44OTUuMzAzLjE1IDAgLjI5My0uMDI5LjQzLS4wN2wuMjUuMjVjLS4xMTMuMjUtLjE4LjUyNy0uMTguODIgMCAxLjEwNC44OTYgMiAyIDJzMi0uODk2IDItMmMwLTEuMTA2LS44OTYtMi0yLTJ6bTAtNGMuNTUzIDAgMSAuNDQ3IDEgMSAwIC41NTEtLjQ0NyAxLTEgMXMtMS0uNDQ5LTEtMWMwLS41NTMuNDQ3LTEgMS0xem0tMi41IDRjLS4yNzYgMC0uNS0uMjI1LS41LS41IDAtLjI3Ny4yMjQtLjUuNS0uNXMuNS4yMjMuNS41YzAgLjI3NS0uMjI0LjUtLjUuNXptMi41IDNjLS41NTMgMC0xLS40NDktMS0xIDAtLjU1My40NDctMSAxLTFzMSAuNDQ3IDEgMWMwIC41NS0uNDQ3IDEtMSAxem0tMy0xM3Y3LjA1MWMtLjE0Mi4wMjktLjI3OS4wNy0uNDEzLjEyM2wtLjU4Ny0uMTc0di02aC03djdoLTF2LThoOXptLTggMTBoLTF2LTFoMXYxem0yLTFoLTF2MWgxdi0xem0yIDBoLTF2MWgxdi0xeiIgZmlsbD0iIzQyNDI0MiIvPjxwYXRoIGQ9Ik0xODUuNzkzIDguNzkzbC0xLjc5MyAxLjIwN3YtNmg3djUuMzgxbC0yLjU1NC0uNzc3Yy0uODE2LS40MDktMS45OS0uNDc1LTIuNjUzLjE4OXptLS43OTMgMi4yMDdoLjc2NGwtLjc2NC0uMzgzdi4zODN6bTExIDRjMCAuNTUxLS40NDcgMS0xIDFzLTEtLjQ0OS0xLTFjMC0uNTUzLjQ0Ny0xIDEtMXMxIC40NDcgMSAxem0tMy41LTNjLS4yNzYgMC0uNS4yMjMtLjUuNSAwIC4yNzUuMjI0LjUuNS41cy41LS4yMjUuNS0uNWMwLS4yNzgtLjIyNC0uNS0uNS0uNXptMi41LTNjLS41NTMgMC0xIC40NDctMSAxIDAgLjU1MS40NDcgMSAxIDFzMS0uNDQ5IDEtMWMwLS41NTMtLjQ0Ny0xLTEtMXoiIGZpbGw9IiNGMEVGRjEiLz48cGF0aCBkPSJNMTc4IDI3di0zaC03di0xaC05djE0aDEzdi0zaDN2LTNoLTF2LTNoLTZ2LTFoN3ptLTggN3YtM2gxdjNoLTF6IiBmaWxsPSIjMkQyRDJEIi8+PHBhdGggZD0iTTE3NyAyNmgtNXYtMWg1djF6bS0xIDNoLTJ2MWgydi0xem0tNCAwaC05djFoOXYtMXptMiA2aC0xMXYxaDExdi0xem0tNS0zaC02djFoNnYtMXptOCAwaC01djFoNXYtMXptLTctOHYzaC03di0zaDd6bS0xIDFoLTV2MWg1di0xeiIgZmlsbD0iI0M1QzVDNSIvPjxyZWN0IHg9IjE2NCIgeT0iMjUiIHdpZHRoPSI1IiBoZWlnaHQ9IjEiIGZpbGw9IiMyRDJEMkQiLz48cGF0aCBkPSJNMTc4IDd2LTNoLTd2LTFoLTl2MTRoMTN2LTNoM3YtM2gtMXYtM2gtNnYtMWg3em0tOCA3di0zaDF2M2gtMXoiIGZpbGw9IiNGM0YzRjMiLz48cGF0aCBkPSJNMTc3IDZoLTV2LTFoNXYxem0tMSAzaC0ydjFoMnYtMXptLTQgMGgtOXYxaDl2LTF6bTIgNmgtMTF2MWgxMXYtMXptLTUtM2gtNnYxaDZ2LTF6bTggMGgtNXYxaDV2LTF6bS03LTh2M2gtN3YtM2g3em0tMSAxaC01djFoNXYtMXoiIGZpbGw9IiM0MjQyNDIiLz48cmVjdCB4PSIxNjQiIHk9IjUiIHdpZHRoPSI1IiBoZWlnaHQ9IjEiIGZpbGw9IiNGMEVGRjEiLz48cG9seWdvbiBwb2ludHM9IjE1NC40MTQsMjQgMTQ5LjU4NiwyNCAxNDgsMjUuNTg2IDE0OCwyOCAxNDQsMjggMTQ0LDM1IDE1MiwzNSAxNTIsMzEgMTU0LjQxNCwzMSAxNTYsMjkuNDE0IDE1NiwyNS41ODYiIGZpbGw9IiMyRDJEMkQiLz48ZyBmaWxsPSIjNzVCRUZGIj48cGF0aCBkPSJNMTU0IDI1aC00bC0xIDF2Mmg1djFoLTJ2MWgybDEtMXYtM2wtMS0xem0wIDJoLTR2LTFoNHYxek0xNDUgMzRoNnYtNWgtNnY1em0xLTNoNHYxaC00di0xeiIvPjwvZz48ZyBmaWxsPSIjMkQyRDJEIj48cmVjdCB4PSIxNDYiIHk9IjMxIiB3aWR0aD0iNCIgaGVpZ2h0PSIxIi8+PHJlY3QgeD0iMTUwIiB5PSIyNiIgd2lkdGg9IjQiIGhlaWdodD0iMSIvPjxyZWN0IHg9IjE1MiIgeT0iMjgiIHdpZHRoPSIyIiBoZWlnaHQ9IjEiLz48L2c+PHBvbHlnb24gcG9pbnRzPSIxNTQuNDE0LDQgMTQ5LjU4Niw0IDE0OCw1LjU4NiAxNDgsOCAxNDQsOCAxNDQsMTUgMTUyLDE1IDE1MiwxMSAxNTQuNDE0LDExIDE1Niw5LjQxNCAxNTYsNS41ODYiIGZpbGw9IiNGM0YzRjMiLz48ZyBmaWxsPSIjMDA1MzlDIj48cGF0aCBkPSJNMTU0IDVoLTRsLTEgMXYyaDV2MWgtMnYxaDJsMS0xdi0zbC0xLTF6bTAgMmgtNHYtMWg0djF6TTE0NSAxNGg2di01aC02djV6bTEtM2g0djFoLTR2LTF6Ii8+PC9nPjxnIGZpbGw9IiNGMEVGRjEiPjxyZWN0IHg9IjE0NiIgeT0iMTEiIHdpZHRoPSI0IiBoZWlnaHQ9IjEiLz48cmVjdCB4PSIxNTAiIHk9IjYiIHdpZHRoPSI0IiBoZWlnaHQ9IjEiLz48cmVjdCB4PSIxNTIiIHk9IjgiIHdpZHRoPSIyIiBoZWlnaHQ9IjEiLz48L2c+PHBhdGggZD0iTTEzOCAyNGgtMTV2NGgtMXY4aDh2LTZoOHYtNnptLTExIDloLTJ2LTJoMnYyeiIgZmlsbD0iIzJEMkQyRCIvPjxwYXRoIGQ9Ik0xMzcgMjloLTd2LTFoLTZ2LTNoMXYyaDF2LTJoMXYyaDF2LTJoMXYyaDF2LTJoMXYyaDF2LTJoMXYyaDF2LTJoMXYyaDF2LTJoMXY0em0tMTIgMXYtMWgtMnY2aDJ2LTFoLTF2LTRoMXptMiA0djFoMnYtNmgtMnYxaDF2NGgtMXoiIGZpbGw9IiNDNUM1QzUiLz48cGF0aCBkPSJNMTI1IDI3di0yaDF2MmgtMXptMyAwdi0yaC0xdjJoMXptMiAwdi0yaC0xdjJoMXptMiAwdi0yaC0xdjJoMXptMiAwdi0yaC0xdjJoMXptMiAwdi0yaC0xdjJoMXoiIGZpbGw9IiMyRDJEMkQiLz48cGF0aCBkPSJNMTM4IDRoLTE1djRoLTF2OGg4di02aDh2LTZ6bS0xMSA5aC0ydi0yaDJ2MnoiIGZpbGw9IiNGM0YzRjMiLz48cGF0aCBkPSJNMTM3IDloLTd2LTFoLTZ2LTNoMXYyaDF2LTJoMXYyaDF2LTJoMXYyaDF2LTJoMXYyaDF2LTJoMXYyaDF2LTJoMXYyaDF2LTJoMXY0em0tMTIgMXYtMWgtMnY2aDJ2LTFoLTF2LTRoMXptMiA0djFoMnYtNmgtMnYxaDF2NGgtMXoiIGZpbGw9IiM0MjQyNDIiLz48cGF0aCBkPSJNMTI1IDd2LTJoMXYyaC0xem0zIDB2LTJoLTF2Mmgxem0yIDB2LTJoLTF2Mmgxem0yIDB2LTJoLTF2Mmgxem0yIDB2LTJoLTF2Mmgxem0yIDB2LTJoLTF2MmgxeiIgZmlsbD0iI0YwRUZGMSIvPjxwYXRoIGQ9Ik0xMTAuNDQ5IDIzYy0xLjYzNyAwLTMuMDc1Ljc5Ny0zLjk4NyAyLjAxMmwuMDAxLjAwMmMtLjYyOC44MzYtMS4wMTQgMS44NjMtMS4wMTQgMi45ODYgMCAuNDY5LjA2Ny45MzMuMiAxLjM4NWwtMi45MDcgMi45MDhjLS42ODcuNjg2LTEuMjUzIDIuMTYxIDAgMy40MTQuNjA5LjYwOSAxLjI0NC43MzYgMS42Ny43MzYuOTU4IDAgMS42MjEtLjYxMyAxLjc0NC0uNzM2bDIuOTA3LTIuOTA4Yy40NTMuMTMzLjkxNy4yMDEgMS4zODYuMjAxIDEuMTIzIDAgMi4xNDktLjM4NyAyLjk4NS0xLjAxNGwuMDAyLjAwMWMxLjIxNi0uOTEyIDIuMDEzLTIuMzUyIDIuMDEzLTMuOTg3IDAtMi43NjItMi4yMzgtNS01LTV6IiBmaWxsPSIjMkQyRDJEIi8+PHBhdGggZD0iTTExNC4wOSAyNi4zNTlsLTIuNjQxIDIuNjQxLTItMiAyLjY0MS0yLjY0MWMtLjUwMi0uMjI3LTEuMDU1LS4zNTktMS42NDEtLjM1OS0yLjIwOSAwLTQgMS43OTEtNCA0IDAgLjU4Ni4xMzMgMS4xMzkuMzU5IDEuNjRsLTMuMzU5IDMuMzZzLTEgMSAwIDJoMmwzLjM1OS0zLjM2Yy41MDIuMjI3IDEuMDU1LjM2IDEuNjQxLjM2IDIuMjA5IDAgNC0xLjc5MSA0LTQgMC0uNTg2LS4xMzMtMS4xMzktLjM1OS0xLjY0MXoiIGZpbGw9IiNDNUM1QzUiLz48cGF0aCBkPSJNMTEwLjQ0OSAzYy0xLjYzNyAwLTMuMDc1Ljc5Ny0zLjk4NyAyLjAxMmwuMDAxLjAwMmMtLjYyOC44MzYtMS4wMTQgMS44NjMtMS4wMTQgMi45ODYgMCAuNDY5LjA2Ny45MzMuMiAxLjM4NWwtMi45MDcgMi45MDhjLS42ODcuNjg2LTEuMjUzIDIuMTYxIDAgMy40MTQuNjA5LjYwOSAxLjI0NC43MzYgMS42Ny43MzYuOTU4IDAgMS42MjEtLjYxMyAxLjc0NC0uNzM2bDIuOTA3LTIuOTA4Yy40NTMuMTMzLjkxNy4yMDEgMS4zODYuMjAxIDEuMTIzIDAgMi4xNDktLjM4NyAyLjk4NS0xLjAxNGwuMDAyLjAwMWMxLjIxNi0uOTEyIDIuMDEzLTIuMzUyIDIuMDEzLTMuOTg3IDAtMi43NjItMi4yMzgtNS01LTV6IiBmaWxsPSIjRjNGM0YzIi8+PHBhdGggZD0iTTExNC4wOSA2LjM1OWwtMi42NDEgMi42NDEtMi0yIDIuNjQxLTIuNjQxYy0uNTAyLS4yMjYtMS4wNTUtLjM1OS0xLjY0MS0uMzU5LTIuMjA5IDAtNCAxLjc5MS00IDQgMCAuNTg2LjEzMyAxLjEzOS4zNTkgMS42NGwtMy4zNTkgMy4zNnMtMSAxIDAgMmgybDMuMzU5LTMuMzZjLjUwMi4yMjcgMS4wNTUuMzYgMS42NDEuMzYgMi4yMDkgMCA0LTEuNzkxIDQtNCAwLS41ODYtLjEzMy0xLjEzOS0uMzU5LTEuNjQxeiIgZmlsbD0iIzQyNDI0MiIvPjxwYXRoIGQ9Ik04OSAzM2gxdi0xYzAtLjUzNy43NDEtMS42MTMgMS0yLS4yNTktLjM4OS0xLTEuNDY3LTEtMnYtMWgtMXYtM2gxYzEuOTY5LjAyMSAzIDEuMjc3IDMgM3YxbDEgMXYybC0xIDF2MWMwIDEuNzA5LTEuMDMxIDIuOTc5LTMgM2gtMXYtM3ptLTIgMGgtMXYtMWMwLS41MzctLjc0MS0xLjYxMy0xLTIgLjI1OS0uMzg5IDEtMS40NjcgMS0ydi0xaDF2LTNoLTFjLTEuOTY5LjAyMS0zIDEuMjc3LTMgM3YxbC0xIDF2MmwxIDF2MWMwIDEuNzA5IDEuMzE3IDIuOTc5IDMuMjg2IDNoLjcxNHYtM3oiIGZpbGw9IiMyRDJEMkQiLz48cGF0aCBkPSJNOTEgMzN2LTFjMC0uODM0LjQ5Ni0xLjczOCAxLTItLjUwNC0uMjctMS0xLjE2OC0xLTJ2LTFjMC0uODQtLjU4NC0xLTEtMXYtMWMyLjA4MyAwIDIgMS4xNjYgMiAydjFjMCAuOTY5LjcwMy45OCAxIDF2MmMtLjMyMi4wMi0xIC4wNTMtMSAxdjFjMCAuODM0LjA4MyAyLTIgMnYtMWMuODMzIDAgMS0xIDEtMXptLTYgMHYtMWMwLS44MzQtLjQ5Ni0xLjczOC0xLTIgLjUwNC0uMjcgMS0xLjE2OCAxLTJ2LTFjMC0uODQuNTg0LTEgMS0xdi0xYy0yLjA4MyAwLTIgMS4xNjYtMiAydjFjMCAuOTY5LS43MDMuOTgtMSAxdjJjLjMyMi4wMiAxIC4wNTMgMSAxdjFjMCAuODM0LS4wODMgMiAyIDJ2LTFjLS44MzMgMC0xLTEtMS0xeiIgZmlsbD0iI0M1QzVDNSIvPjxwYXRoIGQ9Ik04OSAxM2gxdi0xYzAtLjUzNy43NDEtMS42MTMgMS0yLS4yNTktLjM4OS0xLTEuNDY3LTEtMnYtMWgtMXYtM2gxYzEuOTY5LjAyMSAzIDEuMjc3IDMgM3YxbDEgMXYybC0xIDF2MWMwIDEuNzA5LTEuMDMxIDIuOTc5LTMgM2gtMXYtM3ptLTIgMGgtMXYtMWMwLS41MzctLjc0MS0xLjYxMy0xLTIgLjI1OS0uMzg5IDEtMS40NjcgMS0ydi0xaDF2LTNoLTFjLTEuOTY5LjAyMS0zIDEuMjc3LTMgM3YxbC0xIDF2MmwxIDF2MWMwIDEuNzA5IDEuMzE3IDIuOTc5IDMuMjg2IDNoLjcxNHYtM3oiIGZpbGw9IiNGM0YzRjMiLz48cGF0aCBkPSJNOTEgMTN2LTFjMC0uODM0LjQ5Ni0xLjczOCAxLTItLjUwNC0uMjctMS0xLjE2OC0xLTJ2LTFjMC0uODQtLjU4NC0xLTEtMXYtMWMyLjA4MyAwIDIgMS4xNjYgMiAydjFjMCAuOTY5LjcwMy45OCAxIDF2MmMtLjMyMi4wMi0xIC4wNTMtMSAxdjFjMCAuODM0LjA4MyAyLTIgMnYtMWMuODMzIDAgMS0xIDEtMXptLTYgMHYtMWMwLS44MzQtLjQ5Ni0xLjczOC0xLTIgLjUwNC0uMjcgMS0xLjE2OCAxLTJ2LTFjMC0uODQuNTg0LTEgMS0xdi0xYy0yLjA4MyAwLTIgMS4xNjYtMiAydjFjMCAuOTY5LS43MDMuOTgtMSAxdjJjLjMyMi4wMiAxIC4wNTMgMSAxdjFjMCAuODM0LS4wODMgMiAyIDJ2LTFjLS44MzMgMC0xLTEtMS0xeiIgZmlsbD0iIzQyNDI0MiIvPjxwYXRoIGQ9Ik03My41IDM0Yy0xLjkxNCAwLTMuNjAxLTEuMjQyLTQuMjI3LTNoLTEuNjgzYy0uNTI0LjkxLTEuNTAzIDEuNS0yLjU5MSAxLjUtMS42NTQgMC0zLTEuMzQ2LTMtM3MxLjM0Ni0zIDMtM2MxLjA4OCAwIDIuMDY2LjU4OCAyLjU5MSAxLjVoMS42ODNjLjYyNi0xLjc2IDIuMzEzLTMgNC4yMjctMyAyLjQ4MSAwIDQuNSAyLjAxOCA0LjUgNC41IDAgMi40OC0yLjAxOSA0LjUtNC41IDQuNXoiIGZpbGw9IiMyRDJEMkQiLz48cGF0aCBkPSJNNzMuNSAyNmMtMS43NTkgMC0zLjIwNCAxLjMwOC0zLjQ0OSAzaC0zLjEyMmMtLjIyMy0uODYxLS45OTgtMS41LTEuOTI5LTEuNS0xLjEwNCAwLTIgLjg5NS0yIDIgMCAxLjEwNC44OTYgMiAyIDIgLjkzMSAwIDEuNzA2LS42MzkgMS45MjktMS41aDMuMTIyYy4yNDUgMS42OTEgMS42OSAzIDMuNDQ5IDMgMS45MyAwIDMuNS0xLjU3IDMuNS0zLjUgMC0xLjkzMS0xLjU3LTMuNS0zLjUtMy41em0wIDVjLS44MjcgMC0xLjUtLjY3NC0xLjUtMS41IDAtLjgyOC42NzMtMS41IDEuNS0xLjVzMS41LjY3MiAxLjUgMS41YzAgLjgyNi0uNjczIDEuNS0xLjUgMS41eiIgZmlsbD0iIzc1QkVGRiIvPjxjaXJjbGUgY3g9IjczLjUiIGN5PSIyOS41IiByPSIxLjUiIGZpbGw9IiMyRDJEMkQiLz48cGF0aCBkPSJNNzMuNSAxNGMtMS45MTQgMC0zLjYwMS0xLjI0Mi00LjIyNy0zaC0xLjY4M2MtLjUyNC45MS0xLjUwMyAxLjUtMi41OTEgMS41LTEuNjU0IDAtMy0xLjM0Ni0zLTNzMS4zNDYtMyAzLTNjMS4wODggMCAyLjA2Ni41ODggMi41OTEgMS41aDEuNjgzYy42MjYtMS43NiAyLjMxMy0zIDQuMjI3LTMgMi40ODEgMCA0LjUgMi4wMTggNC41IDQuNSAwIDIuNDgtMi4wMTkgNC41LTQuNSA0LjV6IiBmaWxsPSIjRjNGM0YzIi8+PHBhdGggZD0iTTczLjUgNmMtMS43NTkgMC0zLjIwNCAxLjMwOC0zLjQ0OSAzaC0zLjEyMmMtLjIyMy0uODYxLS45OTgtMS41LTEuOTI5LTEuNS0xLjEwNCAwLTIgLjg5NS0yIDIgMCAxLjEwNC44OTYgMiAyIDIgLjkzMSAwIDEuNzA2LS42MzkgMS45MjktMS41aDMuMTIyYy4yNDUgMS42OTEgMS42OSAzIDMuNDQ5IDMgMS45MyAwIDMuNS0xLjU3IDMuNS0zLjUgMC0xLjkzMS0xLjU3LTMuNS0zLjUtMy41em0wIDVjLS44MjcgMC0xLjUtLjY3NC0xLjUtMS41IDAtLjgyOC42NzMtMS41IDEuNS0xLjVzMS41LjY3MiAxLjUgMS41YzAgLjgyNi0uNjczIDEuNS0xLjUgMS41eiIgZmlsbD0iIzAwNTM5QyIvPjxjaXJjbGUgY3g9IjczLjUiIGN5PSI5LjUiIHI9IjEuNSIgZmlsbD0iI0YwRUZGMSIvPjxwYXRoIGQ9Ik01OCAyOC41ODZsLTMtMy0xLjQxNCAxLjQxNGgtMi4xNzJsMS0xLTQtNGgtLjgyOGwtNS41ODYgNS41ODZ2LjgyOGw0IDQgMi40MTQtMi40MTRoLjU4NnY1aDEuNTg2bDMgM2guODI4bDMuNTg2LTMuNTg2di0uODI4bC0yLjA4Ni0yLjA4NiAyLjA4Ni0yLjA4NnYtLjgyOHoiIGZpbGw9IiMyRDJEMkQiLz48cG9seWdvbiBwb2ludHM9IjUzLjk5OCwzMy4wMDIgNTEsMzMgNTEsMjkgNTMsMjkgNTIsMzAgNTQsMzIgNTcsMjkgNTUsMjcgNTQsMjggNDksMjggNTEsMjYgNDgsMjMgNDMsMjggNDYsMzEgNDgsMjkgNTAsMjkgNTAsMzQgNTMsMzQgNTIsMzUgNTQsMzcgNTcsMzQgNTUsMzIiIGZpbGw9IiNDMjdEMUEiLz48cGF0aCBkPSJNNTggOC41ODZsLTMtMy0xLjQxNCAxLjQxNGgtMi4xNzJsMS0xLTQtNGgtLjgyOGwtNS41ODYgNS41ODZ2LjgyOGw0IDQgMi40MTQtMi40MTRoLjU4NnY1aDEuNTg2bDMgM2guODI4bDMuNTg2LTMuNTg2di0uODI4bC0yLjA4Ni0yLjA4NiAyLjA4Ni0yLjA4NnYtLjgyOHoiIGZpbGw9IiNGM0YzRjMiLz48cG9seWdvbiBwb2ludHM9IjUzLjk5OCwxMy4wMDIgNTEsMTMgNTEsOSA1Myw5IDUyLDEwIDU0LDEyIDU3LDkgNTUsNyA1NCw4IDQ5LDggNTEsNiA0OCwzIDQzLDggNDYsMTEgNDgsOSA1MCw5IDUwLDE0IDUzLDE0IDUyLDE1IDU0LDE3IDU3LDE0IDU1LDEyIiBmaWxsPSIjQzI3RDFBIi8+PHBhdGggZD0iTTI5LjI2MyAyNGw0LjczNyAyLjM2OXY1LjIzNmwtNi43OTEgMy4zOTVoLS40MmwtNC43ODktMi4zOTV2LTUuMjM2bDYuNzM5LTMuMzY5aC41MjR6IiBmaWxsPSIjMkQyRDJEIi8+PHBhdGggZD0iTTIzIDI4djRsNCAyIDYtM3YtNGwtNC0yLTYgM3ptNCAxbC0yLTEgNC0yIDIgMS00IDJ6IiBmaWxsPSIjNzVCRUZGIi8+PHBhdGggZD0iTTI5IDI2bDIgMS00IDItMi0xIDQtMnoiIGZpbGw9IiMyRDJEMkQiLz48cGF0aCBkPSJNMjkuMjYzIDRsNC43MzcgMi4zNjl2NS4yMzZsLTYuNzkxIDMuMzk1aC0uNDJsLTQuNzg5LTIuMzk1di01LjIzNmw2LjczOS0zLjM2OWguNTI0eiIgZmlsbD0iI0YzRjNGMyIvPjxwYXRoIGQ9Ik0yMyA4djRsNCAyIDYtM3YtNGwtNC0yLTYgM3ptNCAxbC0yLTEgNC0yIDIgMS00IDJ6IiBmaWxsPSIjMDA1MzlDIi8+PHBhdGggZD0iTTI5IDZsMiAxLTQgMi0yLTEgNC0yeiIgZmlsbD0iI0YwRUZGMSIvPjxwb2x5Z29uIHBvaW50cz0iMiwyNy4zMDggMiwzMi42OTIgNy4yMDksMzYgNy43OTEsMzYgMTMsMzIuNjkyIDEzLDI3LjMwOCA3Ljc5MSwyNCA3LjIwOSwyNCIgZmlsbD0iIzJEMkQyRCIvPjxwYXRoIGQ9Ik03LjUgMjVsLTQuNSAyLjg1N3Y0LjI4NWw0LjUgMi44NTggNC41LTIuODU3di00LjI4NWwtNC41LTIuODU4em0tLjUgOC40OThsLTMtMS45MDV2LTIuODE1bDMgMS45MDV2Mi44MTV6bS0yLjM1OC01LjQ5OGwyLjg1OC0xLjgxNSAyLjg1OCAxLjgxNS0yLjg1OCAxLjgxNS0yLjg1OC0xLjgxNXptNi4zNTggMy41OTNsLTMgMS45MDV2LTIuODE1bDMtMS45MDV2Mi44MTV6IiBmaWxsPSIjQjE4MEQ3Ii8+PHBvbHlnb24gcG9pbnRzPSIxMC4zNTgsMjggNy41LDI5LjgxNSA0LjY0MiwyOCA3LjUsMjYuMTg1IiBmaWxsPSIjMkQyRDJEIi8+PHBvbHlnb24gcG9pbnRzPSI0LDI4Ljc3NyA3LDMwLjY4MyA3LDMzLjQ5OCA0LDMxLjU5MyIgZmlsbD0iIzJEMkQyRCIvPjxwb2x5Z29uIHBvaW50cz0iOCwzMy40OTggOCwzMC42ODMgMTEsMjguNzc3IDExLDMxLjU5MyIgZmlsbD0iIzJEMkQyRCIvPjxwb2x5Z29uIHBvaW50cz0iMiw3LjMwOCAyLDEyLjY5MiA3LjIwOSwxNiA3Ljc5MSwxNiAxMywxMi42OTIgMTMsNy4zMDggNy43OTEsNCA3LjIwOSw0IiBmaWxsPSIjRjNGM0YzIi8+PHBhdGggZD0iTTcuNSA1bC00LjUgMi44NTd2NC4yODVsNC41IDIuODU4IDQuNS0yLjg1N3YtNC4yODZsLTQuNS0yLjg1N3ptLS41IDguNDk4bC0zLTEuOTA1di0yLjgxNmwzIDEuOTA1djIuODE2em0tMi4zNTgtNS40OThsMi44NTgtMS44MTUgMi44NTggMS44MTUtMi44NTggMS44MTUtMi44NTgtMS44MTV6bTYuMzU4IDMuNTkzbC0zIDEuOTA1di0yLjgxNWwzLTEuOTA1djIuODE1eiIgZmlsbD0iIzY1MkQ5MCIvPjxwb2x5Z29uIHBvaW50cz0iMTAuMzU4LDggNy41LDkuODE1IDQuNjQyLDggNy41LDYuMTg1IiBmaWxsPSIjRjBFRkYxIi8+PHBvbHlnb24gcG9pbnRzPSI0LDguNzc3IDcsMTAuNjgzIDcsMTMuNDk4IDQsMTEuNTkzIiBmaWxsPSIjRjBFRkYxIi8+PHBvbHlnb24gcG9pbnRzPSI4LDEzLjQ5OCA4LDEwLjY4MyAxMSw4Ljc3NyAxMSwxMS41OTMiIGZpbGw9IiNGMEVGRjEiLz48L3N2Zz4=\");\n\tbackground-repeat: no-repeat;\n}\n\n.monaco-quick-open-widget .quick-open-tree .quick-open-entry .quick-open-entry-icon.method,\n.monaco-quick-open-widget .quick-open-tree .quick-open-entry .quick-open-entry-icon.function,\n.monaco-quick-open-widget .quick-open-tree .quick-open-entry .quick-open-entry-icon.constructor\t\t{ background-position: 0 -4px; }\n.monaco-quick-open-widget .quick-open-tree .quick-open-entry .quick-open-entry-icon.field,\n.monaco-quick-open-widget .quick-open-tree .quick-open-entry .quick-open-entry-icon.variable \t\t\t{ background-position: -22px -4px; }\n.monaco-quick-open-widget .quick-open-tree .quick-open-entry .quick-open-entry-icon.class \t\t\t\t{ background-position: -43px -3px; }\n.monaco-quick-open-widget .quick-open-tree .quick-open-entry .quick-open-entry-icon.interface \t\t\t{ background-position: -63px -4px; }\n.monaco-quick-open-widget .quick-open-tree .quick-open-entry .quick-open-entry-icon.module \t\t\t{ background-position: -82px -4px; }\n.monaco-quick-open-widget .quick-open-tree .quick-open-entry .quick-open-entry-icon.property \t\t\t{ background-position: -102px -3px; }\n.monaco-quick-open-widget .quick-open-tree .quick-open-entry .quick-open-entry-icon.enum\t\t \t\t{ background-position: -122px -3px; }\n.monaco-quick-open-widget .quick-open-tree .quick-open-entry .quick-open-entry-icon.rule\t\t \t\t{ background-position: -242px -4px; }\n.monaco-quick-open-widget .quick-open-tree .quick-open-entry .quick-open-entry-icon.file\t\t \t\t{ background-position: -262px -4px; }\n\n.vs-dark .monaco-quick-open-widget .quick-open-tree .quick-open-entry .quick-open-entry-icon.method,\n.vs-dark .monaco-quick-open-widget .quick-open-tree .quick-open-entry .quick-open-entry-icon.function,\n.vs-dark .monaco-quick-open-widget .quick-open-tree .quick-open-entry .quick-open-entry-icon.constructor \t{ background-position: 0 -24px; }\n.vs-dark .monaco-quick-open-widget .quick-open-tree .quick-open-entry .quick-open-entry-icon.field,\n.vs-dark .monaco-quick-open-widget .quick-open-tree .quick-open-entry .quick-open-entry-icon.variable \t\t{ background-position: -22px -24px; }\n.vs-dark .monaco-quick-open-widget .quick-open-tree .quick-open-entry .quick-open-entry-icon.class \t\t{ background-position: -43px -23px; }\n.vs-dark .monaco-quick-open-widget .quick-open-tree .quick-open-entry .quick-open-entry-icon.interface \t{ background-position: -63px -24px; }\n.vs-dark .monaco-quick-open-widget .quick-open-tree .quick-open-entry .quick-open-entry-icon.module \t\t{ background-position: -82px -24px; }\n.vs-dark .monaco-quick-open-widget .quick-open-tree .quick-open-entry .quick-open-entry-icon.property \t\t{ background-position: -102px -23px; }\n.vs-dark .monaco-quick-open-widget .quick-open-tree .quick-open-entry .quick-open-entry-icon.enum\t\t \t{ background-position: -122px -23px; }\n.vs-dark .monaco-quick-open-widget .quick-open-tree .quick-open-entry .quick-open-entry-icon.rule\t\t \t{ background-position: -242px -24px; }\n.vs-dark .monaco-quick-open-widget .quick-open-tree .quick-open-entry .quick-open-entry-icon.file\t\t \t{ background-position: -262px -24px; }\n\n.hc-black .monaco-quick-open-widget .quick-open-tree .quick-open-entry .quick-open-entry-icon {\n\tbackground: none;\n\tdisplay: inline;\n}\n\n.hc-black .monaco-quick-open-widget .quick-open-tree .quick-open-entry .quick-open-entry-icon:before {\n\theight: 16px;\n\twidth: 16px;\n\tdisplay: inline-block;\n}\n\n.hc-black .monaco-quick-open-widget .quick-open-tree .quick-open-entry .quick-open-entry-icon.method:before,\n.hc-black .monaco-quick-open-widget .quick-open-tree .quick-open-entry .quick-open-entry-icon.function:before,\n.hc-black .monaco-quick-open-widget .quick-open-tree .quick-open-entry .quick-open-entry-icon.constructor:before {\n\tcontent: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgaGVpZ2h0PSIxNiI+PHBhdGggZmlsbD0iI0IxODBENyIgZD0iTTUuNSAzbC00LjUgMi44NTd2NC4yODVsNC41IDIuODU4IDQuNS0yLjg1N3YtNC4yODZsLTQuNS0yLjg1N3ptLS41IDguNDk4bC0zLTEuOTA1di0yLjgxNmwzIDEuOTA1djIuODE2em0tMi4zNTgtNS40OThsMi44NTgtMS44MTUgMi44NTggMS44MTUtMi44NTggMS44MTUtMi44NTgtMS44MTV6bTYuMzU4IDMuNTkzbC0zIDEuOTA1di0yLjgxNWwzLTEuOTA1djIuODE1eiIvPjwvc3ZnPg==);\n\tmargin-left: 2px;\n}\n\n.hc-black .monaco-quick-open-widget .quick-open-tree .quick-open-entry .quick-open-entry-icon.field:before,\n.hc-black .monaco-quick-open-widget .quick-open-tree .quick-open-entry .quick-open-entry-icon.variable:before {\n\tcontent: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgaGVpZ2h0PSIxNiI+PHBhdGggZmlsbD0iIzc1QkVGRiIgZD0iTTEgNnY0bDQgMiA2LTN2LTRsLTQtMi02IDN6bTQgMWwtMi0xIDQtMiAyIDEtNCAyeiIvPjwvc3ZnPg==);\n\tmargin-left: 2px;\n}\n\n.hc-black .monaco-quick-open-widget .quick-open-tree .quick-open-entry .quick-open-entry-icon.class:before {\n\tcontent: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgaGVpZ2h0PSIxNiI+PHBvbHlnb24gZmlsbD0iI0U4QUI1MyIgcG9pbnRzPSIxMS45OTgsMTEuMDAyIDksMTEgOSw3IDExLDcgMTAsOCAxMiwxMCAxNSw3IDEzLDUgMTIsNiA3LDYgOSw0IDYsMSAxLDYgNCw5IDYsNyA4LDcgOCwxMiAxMSwxMiAxMCwxMyAxMiwxNSAxNSwxMiAxMywxMCIvPjwvc3ZnPg==);\n}\n\n.hc-black .monaco-quick-open-widget .quick-open-tree .quick-open-entry .quick-open-entry-icon.interface:before {\n\tcontent: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgaGVpZ2h0PSIxNiI+PHBhdGggZmlsbD0iIzc1QkVGRiIgZD0iTTExLjUgNGMtMS43NTkgMC0zLjIwNCAxLjMwOC0zLjQ0OSAzaC0zLjEyMmMtLjIyMy0uODYxLS45OTgtMS41LTEuOTI5LTEuNS0xLjEwNCAwLTIgLjg5NS0yIDIgMCAxLjEwNC44OTYgMiAyIDIgLjkzMSAwIDEuNzA2LS42MzkgMS45MjktMS41aDMuMTIyYy4yNDUgMS42OTEgMS42OSAzIDMuNDQ5IDMgMS45MyAwIDMuNS0xLjU3IDMuNS0zLjUgMC0xLjkzMS0xLjU3LTMuNS0zLjUtMy41em0wIDVjLS44MjcgMC0xLjUtLjY3NC0xLjUtMS41IDAtLjgyOC42NzMtMS41IDEuNS0xLjVzMS41LjY3MiAxLjUgMS41YzAgLjgyNi0uNjczIDEuNS0xLjUgMS41eiIvPjwvc3ZnPg==);\n}\n\n.hc-black .monaco-quick-open-widget .quick-open-tree .quick-open-entry .quick-open-entry-icon.module:before {\n\tcontent: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgaGVpZ2h0PSIxNiI+PHBhdGggZmlsbD0iI0M1QzVDNSIgZD0iTTkgMTF2LTFjMC0uODM0LjQ5Ni0xLjczOCAxLTItLjUwNC0uMjctMS0xLjE2OC0xLTJ2LTFjMC0uODQtLjU4NC0xLTEtMXYtMWMyLjA4MyAwIDIgMS4xNjYgMiAydjFjMCAuOTY5LjcwMy45OCAxIDF2MmMtLjMyMi4wMi0xIC4wNTMtMSAxdjFjMCAuODM0LjA4MyAyLTIgMnYtMWMuODMzIDAgMS0xIDEtMXptLTYgMHYtMWMwLS44MzQtLjQ5Ni0xLjczOC0xLTIgLjUwNC0uMjcgMS0xLjE2OCAxLTJ2LTFjMC0uODQuNTg0LTEgMS0xdi0xYy0yLjA4MyAwLTIgMS4xNjYtMiAydjFjMCAuOTY5LS43MDMuOTgtMSAxdjJjLjMyMi4wMiAxIC4wNTMgMSAxdjFjMCAuODM0LS4wODMgMiAyIDJ2LTFjLS44MzMgMC0xLTEtMS0xeiIvPjwvc3ZnPg==);\n\tmargin-left: 2px;\n}\n\n.hc-black .monaco-quick-open-widget .quick-open-tree .quick-open-entry .quick-open-entry-icon.property:before\t{\n\tcontent: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgaGVpZ2h0PSIxNiI+PHBhdGggZmlsbD0iI0M1QzVDNSIgZD0iTTEyLjA5IDQuMzU5bC0yLjY0MSAyLjY0MS0yLTIgMi42NDEtMi42NDFjLS41MDItLjIyNi0xLjA1NS0uMzU5LTEuNjQxLS4zNTktMi4yMDkgMC00IDEuNzkxLTQgNCAwIC41ODYuMTMzIDEuMTM5LjM1OSAxLjY0bC0zLjM1OSAzLjM2cy0xIDEgMCAyaDJsMy4zNTktMy4zNmMuNTAzLjIyNiAxLjA1NS4zNiAxLjY0MS4zNiAyLjIwOSAwIDQtMS43OTEgNC00IDAtLjU4Ni0uMTMzLTEuMTM5LS4zNTktMS42NDF6Ii8+PC9zdmc+);\n\tmargin-left: 1px;\n}\n\n.hc-black .monaco-quick-open-widget .quick-open-tree .quick-open-entry .quick-open-entry-icon.value:before,\n.hc-black .monaco-quick-open-widget .quick-open-tree .quick-open-entry .quick-open-entry-icon.enum:before\t{\n\tcontent: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgaGVpZ2h0PSIxNiI+PGcgZmlsbD0iIzc1QkVGRiI+PHBhdGggZD0iTTEyIDNoLTRsLTEgMXYyaDV2MWgtMnYxaDJsMS0xdi0zbC0xLTF6bTAgMmgtNHYtMWg0djF6TTMgMTJoNnYtNWgtNnY1em0xLTNoNHYxaC00di0xeiIvPjwvZz48L3N2Zz4=);\n}\n\n.hc-black .monaco-quick-open-widget .quick-open-tree .quick-open-entry .quick-open-entry-icon.rule:before {\n\tcontent: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMiIgaGVpZ2h0PSIxMiI+PHBhdGggZmlsbD0iI0M1QzVDNSIgZD0iTTEwIDVoLTh2LTJoOHYyem0wIDFoLTZ2MWg2di0xem0wIDJoLTZ2MWg2di0xeiIvPjwvc3ZnPg==);\n}\n\n.hc-black .monaco-quick-open-widget .quick-open-tree .quick-open-entry .quick-open-entry-icon.file:before {\n\tcontent: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgaGVpZ2h0PSIxNiI+PHBhdGggZmlsbD0iI0M1QzVDNSIgZD0iTTkuNjc2IDJoLTYuNjc2djEyaDEwdi05bC0zLjMyNC0zem0yLjMyNCAxMWgtOHYtMTBoNXYzaDN2N3oiLz48L3N2Zz4=);\n}";
  const element$s = ((css, src) => {
if (typeof document !== 'object')
console.info(`Skipped loading "${src}"`);
try {
const id = src
  .replace(/\.css.*$/, '')
  .replace(/[\\:]/g, '/')
  .replace(/[^\w\/]+/g, '');
return (
  document.querySelector(`style[id="${id}"]`) ||
  document.head.appendChild(
    Object.assign(document.createElement('style'), {
      id,
      textContent: `${css}\n\n /* sourceURL=${src} */`,
    }),
  )
);
} catch (exception) {
console.warn(`Failed load "${src}"`, exception);
}
})(css$s, "…monaco-editor/esm/vs/editor/standalone/browser/quickOpen/quickOutline.css");
  //@ sourceURL=/Users/daflair/Projects/packages/monaco-es/node_modules/monaco-editor/esm/vs/editor/standalone/browser/quickOpen/quickOutline.css

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

const css$t = "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n.monaco-keybinding {\n\tdisplay: flex;\n\talign-items: center;\n\tline-height: 10px;\n}\n\n.monaco-keybinding > .monaco-keybinding-key {\n\tdisplay: inline-block;\n\tborder: solid 1px rgba(204, 204, 204, 0.4);\n\tborder-bottom-color: rgba(187, 187, 187, 0.4);\n\tborder-radius: 3px;\n\tbox-shadow: inset 0 -1px 0 rgba(187, 187, 187, 0.4);\n\tbackground-color: rgba(221, 221, 221, 0.4);\n\tvertical-align: middle;\n\tcolor: #555;\n\tfont-size: 11px;\n\tpadding: 3px 5px;\n}\n\n.hc-black .monaco-keybinding > .monaco-keybinding-key,\n.vs-dark .monaco-keybinding > .monaco-keybinding-key {\n\tbackground-color: rgba(128, 128, 128, 0.17);\n\tcolor: #ccc;\n\tborder: solid 1px rgba(51, 51, 51, 0.6);\n\tborder-bottom-color: rgba(68, 68, 68, 0.6);\n\tbox-shadow: inset 0 -1px 0 rgba(68, 68, 68, 0.6);\n}\n\n.monaco-keybinding > .monaco-keybinding-key-separator {\n\tdisplay: inline-block;\n}\n\n.monaco-keybinding > .monaco-keybinding-key-chord-separator {\n\twidth: 2px;\n}";
  const element$t = ((css, src) => {
if (typeof document !== 'object')
console.info(`Skipped loading "${src}"`);
try {
const id = src
  .replace(/\.css.*$/, '')
  .replace(/[\\:]/g, '/')
  .replace(/[^\w\/]+/g, '');
return (
  document.querySelector(`style[id="${id}"]`) ||
  document.head.appendChild(
    Object.assign(document.createElement('style'), {
      id,
      textContent: `${css}\n\n /* sourceURL=${src} */`,
    }),
  )
);
} catch (exception) {
console.warn(`Failed load "${src}"`, exception);
}
})(css$t, "…monaco-editor/esm/vs/base/browser/ui/keybindingLabel/keybindingLabel.css");
  //@ sourceURL=/Users/daflair/Projects/packages/monaco-es/node_modules/monaco-editor/esm/vs/base/browser/ui/keybindingLabel/keybindingLabel.css

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var $$6 = $;
var KeybindingLabel = /** @class */ (function () {
    function KeybindingLabel(container, os) {
        this.os = os;
        this.domNode = append(container, $$6('.monaco-keybinding'));
        this.didEverRender = false;
        container.appendChild(this.domNode);
    }
    Object.defineProperty(KeybindingLabel.prototype, "element", {
        get: function () {
            return this.domNode;
        },
        enumerable: true,
        configurable: true
    });
    KeybindingLabel.prototype.set = function (keybinding, matches) {
        if (this.didEverRender && this.keybinding === keybinding && KeybindingLabel.areSame(this.matches, matches)) {
            return;
        }
        this.keybinding = keybinding;
        this.matches = matches;
        this.render();
    };
    KeybindingLabel.prototype.render = function () {
        clearNode(this.domNode);
        if (this.keybinding) {
            var _a = this.keybinding.getParts(), firstPart = _a[0], chordPart = _a[1];
            if (firstPart) {
                this.renderPart(this.domNode, firstPart, this.matches ? this.matches.firstPart : null);
            }
            if (chordPart) {
                append(this.domNode, $$6('span.monaco-keybinding-key-chord-separator', null, ' '));
                this.renderPart(this.domNode, chordPart, this.matches ? this.matches.chordPart : null);
            }
            this.domNode.title = this.keybinding.getAriaLabel();
        }
        this.didEverRender = true;
    };
    KeybindingLabel.prototype.renderPart = function (parent, part, match) {
        var modifierLabels = UILabelProvider.modifierLabels[this.os];
        if (part.ctrlKey) {
            this.renderKey(parent, modifierLabels.ctrlKey, match && match.ctrlKey, modifierLabels.separator);
        }
        if (part.shiftKey) {
            this.renderKey(parent, modifierLabels.shiftKey, match && match.shiftKey, modifierLabels.separator);
        }
        if (part.altKey) {
            this.renderKey(parent, modifierLabels.altKey, match && match.altKey, modifierLabels.separator);
        }
        if (part.metaKey) {
            this.renderKey(parent, modifierLabels.metaKey, match && match.metaKey, modifierLabels.separator);
        }
        var keyLabel = part.keyLabel;
        if (keyLabel) {
            this.renderKey(parent, keyLabel, match && match.keyCode, '');
        }
    };
    KeybindingLabel.prototype.renderKey = function (parent, label, highlight, separator) {
        append(parent, $$6('span.monaco-keybinding-key' + (highlight ? '.highlight' : ''), null, label));
        if (separator) {
            append(parent, $$6('span.monaco-keybinding-key-separator', null, separator));
        }
    };
    KeybindingLabel.prototype.dispose = function () {
        this.keybinding = null;
    };
    KeybindingLabel.areSame = function (a, b) {
        if (a === b || (!a && !b)) {
            return true;
        }
        return !!a && !!b && equals(a.firstPart, b.firstPart) && equals(a.chordPart, b.chordPart);
    };
    return KeybindingLabel;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$O = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var IDS = 0;
var QuickOpenEntry = /** @class */ (function () {
    function QuickOpenEntry(highlights) {
        if (highlights === void 0) { highlights = []; }
        this.id = (IDS++).toString();
        this.labelHighlights = highlights;
        this.descriptionHighlights = [];
    }
    /**
     * A unique identifier for the entry
     */
    QuickOpenEntry.prototype.getId = function () {
        return this.id;
    };
    /**
     * The label of the entry to identify it from others in the list
     */
    QuickOpenEntry.prototype.getLabel = function () {
        return null;
    };
    /**
     * The options for the label to use for this entry
     */
    QuickOpenEntry.prototype.getLabelOptions = function () {
        return null;
    };
    /**
     * The label of the entry to use when a screen reader wants to read about the entry
     */
    QuickOpenEntry.prototype.getAriaLabel = function () {
        return this.getLabel();
    };
    /**
     * Detail information about the entry that is optional and can be shown below the label
     */
    QuickOpenEntry.prototype.getDetail = function () {
        return null;
    };
    /**
     * The icon of the entry to identify it from others in the list
     */
    QuickOpenEntry.prototype.getIcon = function () {
        return null;
    };
    /**
     * A secondary description that is optional and can be shown right to the label
     */
    QuickOpenEntry.prototype.getDescription = function () {
        return null;
    };
    /**
     * A tooltip to show when hovering over the entry.
     */
    QuickOpenEntry.prototype.getTooltip = function () {
        return null;
    };
    /**
     * A tooltip to show when hovering over the description portion of the entry.
     */
    QuickOpenEntry.prototype.getDescriptionTooltip = function () {
        return null;
    };
    /**
     * An optional keybinding to show for an entry.
     */
    QuickOpenEntry.prototype.getKeybinding = function () {
        return null;
    };
    /**
     * A resource for this entry. Resource URIs can be used to compare different kinds of entries and group
     * them together.
     */
    QuickOpenEntry.prototype.getResource = function () {
        return null;
    };
    /**
     * Allows to reuse the same model while filtering. Hidden entries will not show up in the viewer.
     */
    QuickOpenEntry.prototype.isHidden = function () {
        return this.hidden;
    };
    /**
     * Allows to reuse the same model while filtering. Hidden entries will not show up in the viewer.
     */
    QuickOpenEntry.prototype.setHidden = function (hidden) {
        this.hidden = hidden;
    };
    /**
     * Allows to set highlight ranges that should show up for the entry label and optionally description if set.
     */
    QuickOpenEntry.prototype.setHighlights = function (labelHighlights, descriptionHighlights, detailHighlights) {
        this.labelHighlights = labelHighlights;
        this.descriptionHighlights = descriptionHighlights;
        this.detailHighlights = detailHighlights;
    };
    /**
     * Allows to return highlight ranges that should show up for the entry label and description.
     */
    QuickOpenEntry.prototype.getHighlights = function () {
        return [this.labelHighlights, this.descriptionHighlights, this.detailHighlights];
    };
    /**
     * Called when the entry is selected for opening. Returns a boolean value indicating if an action was performed or not.
     * The mode parameter gives an indication if the element is previewed (using arrow keys) or opened.
     *
     * The context parameter provides additional context information how the run was triggered.
     */
    QuickOpenEntry.prototype.run = function (mode, context) {
        return false;
    };
    /**
     * Determines if this quick open entry should merge with the editor history in quick open. If set to true
     * and the resource of this entry is the same as the resource for an editor history, it will not show up
     * because it is considered to be a duplicate of an editor history.
     */
    QuickOpenEntry.prototype.mergeWithEditorHistory = function () {
        return false;
    };
    return QuickOpenEntry;
}());
var QuickOpenEntryGroup = /** @class */ (function (_super) {
    __extends$O(QuickOpenEntryGroup, _super);
    function QuickOpenEntryGroup(entry, groupLabel, withBorder) {
        var _this = _super.call(this) || this;
        _this.entry = entry;
        _this.groupLabel = groupLabel;
        _this.withBorder = withBorder;
        return _this;
    }
    /**
     * The label of the group or null if none.
     */
    QuickOpenEntryGroup.prototype.getGroupLabel = function () {
        return this.groupLabel;
    };
    QuickOpenEntryGroup.prototype.setGroupLabel = function (groupLabel) {
        this.groupLabel = groupLabel;
    };
    /**
     * Whether to show a border on top of the group entry or not.
     */
    QuickOpenEntryGroup.prototype.showBorder = function () {
        return this.withBorder;
    };
    QuickOpenEntryGroup.prototype.setShowBorder = function (showBorder) {
        this.withBorder = showBorder;
    };
    QuickOpenEntryGroup.prototype.getLabel = function () {
        return this.entry ? this.entry.getLabel() : _super.prototype.getLabel.call(this);
    };
    QuickOpenEntryGroup.prototype.getLabelOptions = function () {
        return this.entry ? this.entry.getLabelOptions() : _super.prototype.getLabelOptions.call(this);
    };
    QuickOpenEntryGroup.prototype.getAriaLabel = function () {
        return this.entry ? this.entry.getAriaLabel() : _super.prototype.getAriaLabel.call(this);
    };
    QuickOpenEntryGroup.prototype.getDetail = function () {
        return this.entry ? this.entry.getDetail() : _super.prototype.getDetail.call(this);
    };
    QuickOpenEntryGroup.prototype.getResource = function () {
        return this.entry ? this.entry.getResource() : _super.prototype.getResource.call(this);
    };
    QuickOpenEntryGroup.prototype.getIcon = function () {
        return this.entry ? this.entry.getIcon() : _super.prototype.getIcon.call(this);
    };
    QuickOpenEntryGroup.prototype.getDescription = function () {
        return this.entry ? this.entry.getDescription() : _super.prototype.getDescription.call(this);
    };
    QuickOpenEntryGroup.prototype.getEntry = function () {
        return this.entry;
    };
    QuickOpenEntryGroup.prototype.getHighlights = function () {
        return this.entry ? this.entry.getHighlights() : _super.prototype.getHighlights.call(this);
    };
    QuickOpenEntryGroup.prototype.isHidden = function () {
        return this.entry ? this.entry.isHidden() : _super.prototype.isHidden.call(this);
    };
    QuickOpenEntryGroup.prototype.setHighlights = function (labelHighlights, descriptionHighlights, detailHighlights) {
        this.entry ? this.entry.setHighlights(labelHighlights, descriptionHighlights, detailHighlights) : _super.prototype.setHighlights.call(this, labelHighlights, descriptionHighlights, detailHighlights);
    };
    QuickOpenEntryGroup.prototype.setHidden = function (hidden) {
        this.entry ? this.entry.setHidden(hidden) : _super.prototype.setHidden.call(this, hidden);
    };
    QuickOpenEntryGroup.prototype.run = function (mode, context) {
        return this.entry ? this.entry.run(mode, context) : _super.prototype.run.call(this, mode, context);
    };
    return QuickOpenEntryGroup;
}(QuickOpenEntry));
var NoActionProvider = /** @class */ (function () {
    function NoActionProvider() {
    }
    NoActionProvider.prototype.hasActions = function (tree, element) {
        return false;
    };
    NoActionProvider.prototype.getActions = function (tree, element) {
        return TPromise.as(null);
    };
    NoActionProvider.prototype.hasSecondaryActions = function (tree, element) {
        return false;
    };
    NoActionProvider.prototype.getSecondaryActions = function (tree, element) {
        return TPromise.as(null);
    };
    NoActionProvider.prototype.getActionItem = function (tree, element, action) {
        return null;
    };
    return NoActionProvider;
}());
var templateEntry = 'quickOpenEntry';
var templateEntryGroup = 'quickOpenEntryGroup';
var Renderer$3 = /** @class */ (function () {
    function Renderer(actionProvider, actionRunner) {
        if (actionProvider === void 0) { actionProvider = new NoActionProvider(); }
        if (actionRunner === void 0) { actionRunner = null; }
        this.actionProvider = actionProvider;
        this.actionRunner = actionRunner;
    }
    Renderer.prototype.getHeight = function (entry) {
        if (entry.getDetail()) {
            return 44;
        }
        return 22;
    };
    Renderer.prototype.getTemplateId = function (entry) {
        if (entry instanceof QuickOpenEntryGroup) {
            return templateEntryGroup;
        }
        return templateEntry;
    };
    Renderer.prototype.renderTemplate = function (templateId, container, styles) {
        var entryContainer = document.createElement('div');
        addClass(entryContainer, 'sub-content');
        container.appendChild(entryContainer);
        // Entry
        var row1 = $('.quick-open-row');
        var row2 = $('.quick-open-row');
        var entry = $('.quick-open-entry', null, row1, row2);
        entryContainer.appendChild(entry);
        // Icon
        var icon = document.createElement('span');
        row1.appendChild(icon);
        // Label
        var label = new IconLabel(row1, { supportHighlights: true, supportDescriptionHighlights: true });
        // Keybinding
        var keybindingContainer = document.createElement('span');
        row1.appendChild(keybindingContainer);
        addClass(keybindingContainer, 'quick-open-entry-keybinding');
        var keybinding = new KeybindingLabel(keybindingContainer, OS);
        // Detail
        var detailContainer = document.createElement('div');
        row2.appendChild(detailContainer);
        addClass(detailContainer, 'quick-open-entry-meta');
        var detail = new HighlightedLabel(detailContainer);
        // Entry Group
        var group;
        if (templateId === templateEntryGroup) {
            group = document.createElement('div');
            addClass(group, 'results-group');
            container.appendChild(group);
        }
        // Actions
        addClass(container, 'actions');
        var actionBarContainer = document.createElement('div');
        addClass(actionBarContainer, 'primary-action-bar');
        container.appendChild(actionBarContainer);
        var actionBar = new ActionBar(actionBarContainer, {
            actionRunner: this.actionRunner
        });
        return {
            container: container,
            entry: entry,
            icon: icon,
            label: label,
            detail: detail,
            keybinding: keybinding,
            group: group,
            actionBar: actionBar
        };
    };
    Renderer.prototype.renderElement = function (entry, templateId, data, styles) {
        // Action Bar
        if (this.actionProvider.hasActions(null, entry)) {
            addClass(data.container, 'has-actions');
        }
        else {
            removeClass(data.container, 'has-actions');
        }
        data.actionBar.context = entry; // make sure the context is the current element
        this.actionProvider.getActions(null, entry).then(function (actions) {
            if (data.actionBar.isEmpty() && actions && actions.length > 0) {
                data.actionBar.push(actions, { icon: true, label: false });
            }
            else if (!data.actionBar.isEmpty() && (!actions || actions.length === 0)) {
                data.actionBar.clear();
            }
        });
        // Entry group class
        if (entry instanceof QuickOpenEntryGroup && entry.getGroupLabel()) {
            addClass(data.container, 'has-group-label');
        }
        else {
            removeClass(data.container, 'has-group-label');
        }
        // Entry group
        if (entry instanceof QuickOpenEntryGroup) {
            var group = entry;
            var groupData = data;
            // Border
            if (group.showBorder()) {
                addClass(groupData.container, 'results-group-separator');
                groupData.container.style.borderTopColor = styles.pickerGroupBorder.toString();
            }
            else {
                removeClass(groupData.container, 'results-group-separator');
                groupData.container.style.borderTopColor = null;
            }
            // Group Label
            var groupLabel = group.getGroupLabel() || '';
            groupData.group.textContent = groupLabel;
            groupData.group.style.color = styles.pickerGroupForeground.toString();
        }
        // Normal Entry
        if (entry instanceof QuickOpenEntry) {
            var _a = entry.getHighlights(), labelHighlights = _a[0], descriptionHighlights = _a[1], detailHighlights = _a[2];
            // Icon
            var iconClass = entry.getIcon() ? ('quick-open-entry-icon ' + entry.getIcon()) : '';
            data.icon.className = iconClass;
            // Label
            var options = entry.getLabelOptions() || Object.create(null);
            options.matches = labelHighlights || [];
            options.title = entry.getTooltip();
            options.descriptionTitle = entry.getDescriptionTooltip() || entry.getDescription(); // tooltip over description because it could overflow
            options.descriptionMatches = descriptionHighlights || [];
            data.label.setValue(entry.getLabel(), entry.getDescription(), options);
            // Meta
            data.detail.set(entry.getDetail(), detailHighlights);
            // Keybinding
            data.keybinding.set(entry.getKeybinding(), null);
        }
    };
    Renderer.prototype.disposeTemplate = function (templateId, templateData) {
        var data = templateData;
        data.actionBar.dispose();
        data.actionBar = null;
        data.container = null;
        data.entry = null;
        data.keybinding.dispose();
        data.keybinding = null;
        data.detail.dispose();
        data.detail = null;
        data.group = null;
        data.icon = null;
        data.label.dispose();
        data.label = null;
    };
    return Renderer;
}());
var QuickOpenModel = /** @class */ (function () {
    function QuickOpenModel(entries, actionProvider) {
        if (entries === void 0) { entries = []; }
        if (actionProvider === void 0) { actionProvider = new NoActionProvider(); }
        this._entries = entries;
        this._dataSource = this;
        this._renderer = new Renderer$3(actionProvider);
        this._filter = this;
        this._runner = this;
        this._accessibilityProvider = this;
    }
    Object.defineProperty(QuickOpenModel.prototype, "entries", {
        get: function () { return this._entries; },
        set: function (entries) {
            this._entries = entries;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(QuickOpenModel.prototype, "dataSource", {
        get: function () { return this._dataSource; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(QuickOpenModel.prototype, "renderer", {
        get: function () { return this._renderer; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(QuickOpenModel.prototype, "filter", {
        get: function () { return this._filter; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(QuickOpenModel.prototype, "runner", {
        get: function () { return this._runner; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(QuickOpenModel.prototype, "accessibilityProvider", {
        get: function () { return this._accessibilityProvider; },
        enumerable: true,
        configurable: true
    });
    /**
     * Adds entries that should show up in the quick open viewer.
     */
    QuickOpenModel.prototype.addEntries = function (entries) {
        if (isArray(entries)) {
            this._entries = this._entries.concat(entries);
        }
    };
    /**
     * Set the entries that should show up in the quick open viewer.
     */
    QuickOpenModel.prototype.setEntries = function (entries) {
        if (isArray(entries)) {
            this._entries = entries;
        }
    };
    /**
     * Get the entries that should show up in the quick open viewer.
     *
     * @visibleOnly optional parameter to only return visible entries
     */
    QuickOpenModel.prototype.getEntries = function (visibleOnly) {
        if (visibleOnly) {
            return this._entries.filter(function (e) { return !e.isHidden(); });
        }
        return this._entries;
    };
    QuickOpenModel.prototype.getId = function (entry) {
        return entry.getId();
    };
    QuickOpenModel.prototype.getLabel = function (entry) {
        return entry.getLabel();
    };
    QuickOpenModel.prototype.getAriaLabel = function (entry) {
        var ariaLabel = entry.getAriaLabel();
        if (ariaLabel) {
            return localize('quickOpenAriaLabelEntry', "{0}, picker", entry.getAriaLabel());
        }
        return localize('quickOpenAriaLabel', "picker");
    };
    QuickOpenModel.prototype.isVisible = function (entry) {
        return !entry.isHidden();
    };
    QuickOpenModel.prototype.run = function (entry, mode, context) {
        return entry.run(mode, context);
    };
    return QuickOpenModel;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var Mode;
(function (Mode) {
    Mode[Mode["PREVIEW"] = 0] = "PREVIEW";
    Mode[Mode["OPEN"] = 1] = "OPEN";
    Mode[Mode["OPEN_IN_BACKGROUND"] = 2] = "OPEN_IN_BACKGROUND";
})(Mode || (Mode = {}));

const css$u = "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n.monaco-quick-open-widget {\n\tposition: absolute;\n\twidth: 600px;\n\tz-index: 2000;\n\tpadding-bottom: 6px;\n\tleft: 50%;\n\tmargin-left: -300px;\n}\n\n.monaco-quick-open-widget .monaco-progress-container {\n\tposition: absolute;\n\tleft: 0;\n\ttop: 38px;\n\tz-index: 1;\n\theight: 2px;\n}\n\n.monaco-quick-open-widget .monaco-progress-container .progress-bit {\n\theight: 2px;\n}\n\n.monaco-quick-open-widget .quick-open-input {\n\twidth: 588px;\n\tborder: none;\n\tmargin: 6px;\n}\n\n.monaco-quick-open-widget .quick-open-input .monaco-inputbox {\n\twidth: 100%;\n\theight: 25px;\n}\n\n.monaco-quick-open-widget .quick-open-tree {\n\tline-height: 22px;\n}\n\n.monaco-quick-open-widget .quick-open-tree .monaco-tree-row  > .content > .sub-content {\n\toverflow: hidden;\n}\n\n.monaco-quick-open-widget.content-changing .quick-open-tree .monaco-scrollable-element .slider {\n\tdisplay: none; /* scrollbar slider causes some hectic updates when input changes quickly, so hide it while quick open changes */\n}\n\n.monaco-quick-open-widget .quick-open-tree .quick-open-entry {\n\toverflow: hidden;\n\ttext-overflow: ellipsis;\n\tdisplay: flex;\n\tflex-direction: column;\n\theight: 100%;\n}\n\n.monaco-quick-open-widget .quick-open-tree .quick-open-entry > .quick-open-row {\n\tdisplay: flex;\n\talign-items: center;\n}\n\n.monaco-quick-open-widget .quick-open-tree .quick-open-entry .quick-open-entry-icon {\n\toverflow: hidden;\n\twidth: 16px;\n\theight: 16px;\n\tmargin-right: 4px;\n\tdisplay: inline-block;\n\tvertical-align: middle;\n\tflex-shrink: 0;\n}\n\n.monaco-quick-open-widget .quick-open-tree .monaco-icon-label,\n.monaco-quick-open-widget .quick-open-tree .monaco-icon-label .monaco-icon-label-description-container {\n\tflex: 1; /* make sure the icon label grows within the row */\n}\n\n.monaco-quick-open-widget .quick-open-tree .quick-open-entry .monaco-highlighted-label span {\n\topacity: 1;\n}\n\n.monaco-quick-open-widget .quick-open-tree .quick-open-entry-meta {\n\topacity: 0.7;\n\tline-height: normal;\n}\n\n.monaco-quick-open-widget .quick-open-tree .content.has-group-label .quick-open-entry-keybinding {\n\tmargin-right: 8px;\n}\n\n.monaco-quick-open-widget .quick-open-tree .quick-open-entry-keybinding .monaco-keybinding-key {\n\tvertical-align: text-bottom;\n}\n\n.monaco-quick-open-widget .quick-open-tree .results-group {\n\tmargin-right: 18px;\n}\n\n.monaco-quick-open-widget .quick-open-tree .monaco-tree-row.focused > .content.has-actions > .results-group,\n.monaco-quick-open-widget .quick-open-tree .monaco-tree-row:hover:not(.highlighted) > .content.has-actions > .results-group,\n.monaco-quick-open-widget .quick-open-tree .focused .monaco-tree-row.focused > .content.has-actions > .results-group {\n\tmargin-right: 0px;\n}\n\n.monaco-quick-open-widget .quick-open-tree .results-group-separator {\n\tborder-top-width: 1px;\n\tborder-top-style: solid;\n\tbox-sizing: border-box;\n\tmargin-left: -11px;\n\tpadding-left: 11px;\n}\n\n/* Actions in Quick Open Items */\n\n.monaco-tree .monaco-tree-row > .content.actions {\n\tposition: relative;\n\tdisplay: flex;\n}\n\n.monaco-tree .monaco-tree-row > .content.actions > .sub-content {\n\tflex: 1;\n}\n\n.monaco-tree .monaco-tree-row > .content.actions .action-item {\n\tmargin: 0;\n}\n\n.monaco-tree .monaco-tree-row > .content.actions > .primary-action-bar {\n\tline-height: 22px;\n}\n\n.monaco-tree .monaco-tree-row > .content.actions > .primary-action-bar {\n\tdisplay: none;\n\tpadding: 0 0.8em 0 0.4em;\n}\n\n.monaco-tree .monaco-tree-row.focused > .content.has-actions > .primary-action-bar {\n\twidth: 0; /* in order to support a11y with keyboard, we use width: 0 to hide the actions, which still allows to \"Tab\" into the actions */\n\tdisplay: block;\n}\n\n.monaco-tree .monaco-tree-row:hover:not(.highlighted) > .content.has-actions > .primary-action-bar,\n.monaco-tree.focused .monaco-tree-row.focused > .content.has-actions > .primary-action-bar,\n.monaco-tree .monaco-tree-row > .content.has-actions.more > .primary-action-bar {\n\twidth: inherit;\n\tdisplay: block;\n}\n\n.monaco-tree .monaco-tree-row > .content.actions > .primary-action-bar .action-label {\n\tmargin-right: 0.4em;\n\tmargin-top: 4px;\n\tbackground-repeat: no-repeat;\n\twidth: 16px;\n\theight: 16px;\n}\n\n.monaco-quick-open-widget .quick-open-tree .monaco-highlighted-label .highlight {\n\tfont-weight: bold;\n}";
  const element$u = ((css, src) => {
if (typeof document !== 'object')
console.info(`Skipped loading "${src}"`);
try {
const id = src
  .replace(/\.css.*$/, '')
  .replace(/[\\:]/g, '/')
  .replace(/[^\w\/]+/g, '');
return (
  document.querySelector(`style[id="${id}"]`) ||
  document.head.appendChild(
    Object.assign(document.createElement('style'), {
      id,
      textContent: `${css}\n\n /* sourceURL=${src} */`,
    }),
  )
);
} catch (exception) {
console.warn(`Failed load "${src}"`, exception);
}
})(css$u, "…monaco-editor/esm/vs/base/parts/quickopen/browser/quickopen.css");
  //@ sourceURL=/Users/daflair/Projects/packages/monaco-es/node_modules/monaco-editor/esm/vs/base/parts/quickopen/browser/quickopen.css

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var DataSource$1 = /** @class */ (function () {
    function DataSource(arg) {
        this.modelProvider = isFunction(arg.getModel) ? arg : { getModel: function () { return arg; } };
    }
    DataSource.prototype.getId = function (tree, element) {
        if (!element) {
            return null;
        }
        var model = this.modelProvider.getModel();
        return model === element ? '__root__' : model.dataSource.getId(element);
    };
    DataSource.prototype.hasChildren = function (tree, element) {
        var model = this.modelProvider.getModel();
        return model && model === element && model.entries.length > 0;
    };
    DataSource.prototype.getChildren = function (tree, element) {
        var model = this.modelProvider.getModel();
        return TPromise.as(model === element ? model.entries : []);
    };
    DataSource.prototype.getParent = function (tree, element) {
        return TPromise.as(null);
    };
    return DataSource;
}());
var AccessibilityProvider = /** @class */ (function () {
    function AccessibilityProvider(modelProvider) {
        this.modelProvider = modelProvider;
    }
    AccessibilityProvider.prototype.getAriaLabel = function (tree, element) {
        var model = this.modelProvider.getModel();
        return model.accessibilityProvider && model.accessibilityProvider.getAriaLabel(element);
    };
    AccessibilityProvider.prototype.getPosInSet = function (tree, element) {
        var model = this.modelProvider.getModel();
        return String(model.entries.indexOf(element) + 1);
    };
    AccessibilityProvider.prototype.getSetSize = function () {
        var model = this.modelProvider.getModel();
        return String(model.entries.length);
    };
    return AccessibilityProvider;
}());
var Filter = /** @class */ (function () {
    function Filter(modelProvider) {
        this.modelProvider = modelProvider;
    }
    Filter.prototype.isVisible = function (tree, element) {
        var model = this.modelProvider.getModel();
        if (!model.filter) {
            return true;
        }
        return model.filter.isVisible(element);
    };
    return Filter;
}());
var Renderer$4 = /** @class */ (function () {
    function Renderer(modelProvider, styles) {
        this.modelProvider = modelProvider;
        this.styles = styles;
    }
    Renderer.prototype.updateStyles = function (styles) {
        this.styles = styles;
    };
    Renderer.prototype.getHeight = function (tree, element) {
        var model = this.modelProvider.getModel();
        return model.renderer.getHeight(element);
    };
    Renderer.prototype.getTemplateId = function (tree, element) {
        var model = this.modelProvider.getModel();
        return model.renderer.getTemplateId(element);
    };
    Renderer.prototype.renderTemplate = function (tree, templateId, container) {
        var model = this.modelProvider.getModel();
        return model.renderer.renderTemplate(templateId, container, this.styles);
    };
    Renderer.prototype.renderElement = function (tree, element, templateId, templateData) {
        var model = this.modelProvider.getModel();
        model.renderer.renderElement(element, templateId, templateData, this.styles);
    };
    Renderer.prototype.disposeTemplate = function (tree, templateId, templateData) {
        var model = this.modelProvider.getModel();
        model.renderer.disposeTemplate(templateId, templateData);
    };
    return Renderer;
}());

const css$v = "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n.monaco-progress-container {\n\twidth: 100%;\n\theight: 5px;\n\toverflow: hidden; /* keep progress bit in bounds */\n}\n\n.monaco-progress-container .progress-bit {\n\twidth: 2%;\n\theight: 5px;\n\tposition: absolute;\n\tleft: 0;\n\tdisplay: none;\n}\n\n.monaco-progress-container.active .progress-bit {\n\tdisplay: inherit;\n}\n\n.monaco-progress-container.discrete .progress-bit {\n\tleft: 0;\n\ttransition: width 100ms linear;\n\t-webkit-transition: width 100ms linear;\n\t-o-transition: width 100ms linear;\n\t-moz-transition: width 100ms linear;\n\t-ms-transition: width 100ms linear;\n}\n\n.monaco-progress-container.discrete.done .progress-bit {\n\twidth: 100%;\n}\n\n.monaco-progress-container.infinite .progress-bit {\n\tanimation-name: progress;\n\tanimation-duration: 4s;\n\tanimation-iteration-count: infinite;\n\tanimation-timing-function: linear;\n\t-ms-animation-name: progress;\n\t-ms-animation-duration: 4s;\n\t-ms-animation-iteration-count: infinite;\n\t-ms-animation-timing-function: linear;\n\t-webkit-animation-name: progress;\n\t-webkit-animation-duration: 4s;\n\t-webkit-animation-iteration-count: infinite;\n\t-webkit-animation-timing-function: linear;\n\t-moz-animation-name: progress;\n\t-moz-animation-duration: 4s;\n\t-moz-animation-iteration-count: infinite;\n\t-moz-animation-timing-function: linear;\n\twill-change: transform;\n}\n\n/**\n * The progress bit has a width: 2% (1/50) of the parent container. The animation moves it from 0% to 100% of\n * that container. Since translateX is relative to the progress bit size, we have to multiple it with\n * its relative size to the parent container:\n *  50%: 50 * 50 = 2500%\n * 100%: 50 * 100 - 50 (do not overflow): 4950%\n */\n@keyframes progress { from { transform: translateX(0%) scaleX(1) } 50% { transform: translateX(2500%) scaleX(3) } to { transform: translateX(4950%) scaleX(1) } }\n@-ms-keyframes progress { from { transform: translateX(0%) scaleX(1) }\t50% { transform: translateX(2500%) scaleX(3) } to { transform: translateX(4950%) scaleX(1) } }\n@-webkit-keyframes progress { from { transform: translateX(0%) scaleX(1) }\t50% { transform: translateX(2500%) scaleX(3) } to { transform: translateX(4950%) scaleX(1) } }\n@-moz-keyframes progress { from { transform: translateX(0%) scaleX(1) }\t50% { transform: translateX(2500%) scaleX(3) } to { transform: translateX(4950%) scaleX(1) } }";
  const element$v = ((css, src) => {
if (typeof document !== 'object')
console.info(`Skipped loading "${src}"`);
try {
const id = src
  .replace(/\.css.*$/, '')
  .replace(/[\\:]/g, '/')
  .replace(/[^\w\/]+/g, '');
return (
  document.querySelector(`style[id="${id}"]`) ||
  document.head.appendChild(
    Object.assign(document.createElement('style'), {
      id,
      textContent: `${css}\n\n /* sourceURL=${src} */`,
    }),
  )
);
} catch (exception) {
console.warn(`Failed load "${src}"`, exception);
}
})(css$v, "…monaco-editor/esm/vs/base/browser/ui/progressbar/progressbar.css");
  //@ sourceURL=/Users/daflair/Projects/packages/monaco-es/node_modules/monaco-editor/esm/vs/base/browser/ui/progressbar/progressbar.css

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var css_done = 'done';
var css_active = 'active';
var css_infinite = 'infinite';
var css_discrete = 'discrete';
var css_progress_container = 'monaco-progress-container';
var css_progress_bit = 'progress-bit';
var defaultOpts$3 = {
    progressBarBackground: Color.fromHex('#0E70C0')
};
/**
 * A progress bar with support for infinite or discrete progress.
 */
var ProgressBar = /** @class */ (function () {
    function ProgressBar(container, options) {
        this.options = options || Object.create(null);
        mixin(this.options, defaultOpts$3, false);
        this.toUnbind = [];
        this.workedVal = 0;
        this.progressBarBackground = this.options.progressBarBackground;
        this.create(container);
    }
    ProgressBar.prototype.create = function (container) {
        var _this = this;
        $$1(container).div({ 'class': css_progress_container }, function (builder) {
            _this.element = builder.clone();
            builder.div({ 'class': css_progress_bit }).on([EventType.ANIMATION_START, EventType.ANIMATION_END, EventType.ANIMATION_ITERATION], function (e) {
                switch (e.type) {
                    case EventType.ANIMATION_ITERATION:
                        if (_this.animationStopToken) {
                            _this.animationStopToken(null);
                        }
                        break;
                }
            }, _this.toUnbind);
            _this.bit = builder.getHTMLElement();
        });
        this.applyStyles();
    };
    ProgressBar.prototype.off = function () {
        this.bit.style.width = 'inherit';
        this.bit.style.opacity = '1';
        this.element.removeClass(css_active);
        this.element.removeClass(css_infinite);
        this.element.removeClass(css_discrete);
        this.workedVal = 0;
        this.totalWork = undefined;
    };
    /**
     * Indicates to the progress bar that all work is done.
     */
    ProgressBar.prototype.done = function () {
        return this.doDone(true);
    };
    /**
     * Stops the progressbar from showing any progress instantly without fading out.
     */
    ProgressBar.prototype.stop = function () {
        return this.doDone(false);
    };
    ProgressBar.prototype.doDone = function (delayed) {
        var _this = this;
        this.element.addClass(css_done);
        // let it grow to 100% width and hide afterwards
        if (!this.element.hasClass(css_infinite)) {
            this.bit.style.width = 'inherit';
            if (delayed) {
                TPromise.timeout(200).then(function () { return _this.off(); });
            }
            else {
                this.off();
            }
        }
        // let it fade out and hide afterwards
        else {
            this.bit.style.opacity = '0';
            if (delayed) {
                TPromise.timeout(200).then(function () { return _this.off(); });
            }
            else {
                this.off();
            }
        }
        return this;
    };
    /**
     * Use this mode to indicate progress that has no total number of work units.
     */
    ProgressBar.prototype.infinite = function () {
        this.bit.style.width = '2%';
        this.bit.style.opacity = '1';
        this.element.removeClass(css_discrete);
        this.element.removeClass(css_done);
        this.element.addClass(css_active);
        this.element.addClass(css_infinite);
        return this;
    };
    /**
     * Tells the progress bar the total number of work. Use in combination with workedVal() to let
     * the progress bar show the actual progress based on the work that is done.
     */
    ProgressBar.prototype.total = function (value) {
        this.workedVal = 0;
        this.totalWork = value;
        return this;
    };
    /**
     * Finds out if this progress bar is configured with total work
     */
    ProgressBar.prototype.hasTotal = function () {
        return !isNaN(this.totalWork);
    };
    /**
     * Tells the progress bar that an amount of work has been completed.
     */
    ProgressBar.prototype.worked = function (value) {
        ok(!isNaN(this.totalWork), 'Total work not set');
        value = Number(value);
        ok(!isNaN(value), 'Value is not a number');
        value = Math.max(1, value);
        this.workedVal += value;
        this.workedVal = Math.min(this.totalWork, this.workedVal);
        if (this.element.hasClass(css_infinite)) {
            this.element.removeClass(css_infinite);
        }
        if (this.element.hasClass(css_done)) {
            this.element.removeClass(css_done);
        }
        if (!this.element.hasClass(css_active)) {
            this.element.addClass(css_active);
        }
        if (!this.element.hasClass(css_discrete)) {
            this.element.addClass(css_discrete);
        }
        this.bit.style.width = 100 * (this.workedVal / this.totalWork) + '%';
        return this;
    };
    ProgressBar.prototype.getContainer = function () {
        return this.element.getHTMLElement();
    };
    ProgressBar.prototype.show = function (delay) {
        if (typeof delay === 'number') {
            this.element.showDelayed(delay);
        }
        else {
            this.element.show();
        }
    };
    ProgressBar.prototype.hide = function () {
        this.element.hide();
    };
    ProgressBar.prototype.style = function (styles) {
        this.progressBarBackground = styles.progressBarBackground;
        this.applyStyles();
    };
    ProgressBar.prototype.applyStyles = function () {
        if (this.bit) {
            var background = this.progressBarBackground ? this.progressBarBackground.toString() : null;
            this.bit.style.backgroundColor = background;
        }
    };
    ProgressBar.prototype.dispose = function () {
        this.toUnbind = dispose(this.toUnbind);
    };
    return ProgressBar;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$P = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var QuickOpenController = /** @class */ (function (_super) {
    __extends$P(QuickOpenController, _super);
    function QuickOpenController() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    QuickOpenController.prototype.onContextMenu = function (tree, element, event) {
        if (isMacintosh) {
            return this.onLeftClick(tree, element, event); // https://github.com/Microsoft/vscode/issues/1011
        }
        return _super.prototype.onContextMenu.call(this, tree, element, event);
    };
    return QuickOpenController;
}(DefaultController));
var HideReason;
(function (HideReason) {
    HideReason[HideReason["ELEMENT_SELECTED"] = 0] = "ELEMENT_SELECTED";
    HideReason[HideReason["FOCUS_LOST"] = 1] = "FOCUS_LOST";
    HideReason[HideReason["CANCELED"] = 2] = "CANCELED";
})(HideReason || (HideReason = {}));
var defaultStyles = {
    background: Color.fromHex('#1E1E1E'),
    foreground: Color.fromHex('#CCCCCC'),
    pickerGroupForeground: Color.fromHex('#0097FB'),
    pickerGroupBorder: Color.fromHex('#3F3F46'),
    widgetShadow: Color.fromHex('#000000'),
    progressBarBackground: Color.fromHex('#0E70C0')
};
var DEFAULT_INPUT_ARIA_LABEL = localize('quickOpenAriaLabel', "Quick picker. Type to narrow down results.");
var QuickOpenWidget = /** @class */ (function () {
    function QuickOpenWidget(container, callbacks, options) {
        this.isDisposed = false;
        this.toUnbind = [];
        this.container = container;
        this.callbacks = callbacks;
        this.options = options;
        this.styles = options || Object.create(null);
        mixin(this.styles, defaultStyles, false);
        this.model = null;
    }
    QuickOpenWidget.prototype.getElement = function () {
        return $$1(this.builder).getHTMLElement();
    };
    QuickOpenWidget.prototype.getModel = function () {
        return this.model;
    };
    QuickOpenWidget.prototype.setCallbacks = function (callbacks) {
        this.callbacks = callbacks;
    };
    QuickOpenWidget.prototype.create = function () {
        var _this = this;
        this.builder = $$1().div(function (div) {
            // Eventing
            div.on(EventType.KEY_DOWN, function (e) {
                var keyboardEvent = new StandardKeyboardEvent(e);
                if (keyboardEvent.keyCode === 9 /* Escape */) {
                    EventHelper.stop(e, true);
                    _this.hide(HideReason.CANCELED);
                }
            })
                .on(EventType.CONTEXT_MENU, function (e) { return EventHelper.stop(e, true); }) // Do this to fix an issue on Mac where the menu goes into the way
                .on(EventType.FOCUS, function (e) { return _this.gainingFocus(); }, null, true)
                .on(EventType.BLUR, function (e) { return _this.loosingFocus(e); }, null, true);
            // Progress Bar
            _this.progressBar = new ProgressBar(div.clone(), { progressBarBackground: _this.styles.progressBarBackground });
            _this.progressBar.hide();
            // Input Field
            div.div({ 'class': 'quick-open-input' }, function (inputContainer) {
                _this.inputContainer = inputContainer;
                _this.inputBox = new InputBox(inputContainer.getHTMLElement(), null, {
                    placeholder: _this.options.inputPlaceHolder || '',
                    ariaLabel: DEFAULT_INPUT_ARIA_LABEL,
                    inputBackground: _this.styles.inputBackground,
                    inputForeground: _this.styles.inputForeground,
                    inputBorder: _this.styles.inputBorder,
                    inputValidationInfoBackground: _this.styles.inputValidationInfoBackground,
                    inputValidationInfoBorder: _this.styles.inputValidationInfoBorder,
                    inputValidationWarningBackground: _this.styles.inputValidationWarningBackground,
                    inputValidationWarningBorder: _this.styles.inputValidationWarningBorder,
                    inputValidationErrorBackground: _this.styles.inputValidationErrorBackground,
                    inputValidationErrorBorder: _this.styles.inputValidationErrorBorder
                });
                // ARIA
                _this.inputElement = _this.inputBox.inputElement;
                _this.inputElement.setAttribute('role', 'combobox');
                _this.inputElement.setAttribute('aria-haspopup', 'false');
                _this.inputElement.setAttribute('aria-autocomplete', 'list');
                addDisposableListener(_this.inputBox.inputElement, EventType.KEY_DOWN, function (e) {
                    var keyboardEvent = new StandardKeyboardEvent(e);
                    var shouldOpenInBackground = _this.shouldOpenInBackground(keyboardEvent);
                    // Do not handle Tab: It is used to navigate between elements without mouse
                    if (keyboardEvent.keyCode === 2 /* Tab */) {
                        return;
                    }
                    // Pass tree navigation keys to the tree but leave focus in input field
                    else if (keyboardEvent.keyCode === 18 /* DownArrow */ || keyboardEvent.keyCode === 16 /* UpArrow */ || keyboardEvent.keyCode === 12 /* PageDown */ || keyboardEvent.keyCode === 11 /* PageUp */) {
                        EventHelper.stop(e, true);
                        _this.navigateInTree(keyboardEvent.keyCode, keyboardEvent.shiftKey);
                        // Position cursor at the end of input to allow right arrow (open in background)
                        // to function immediately unless the user has made a selection
                        if (_this.inputBox.inputElement.selectionStart === _this.inputBox.inputElement.selectionEnd) {
                            _this.inputBox.inputElement.selectionStart = _this.inputBox.value.length;
                        }
                    }
                    // Select element on Enter or on Arrow-Right if we are at the end of the input
                    else if (keyboardEvent.keyCode === 3 /* Enter */ || shouldOpenInBackground) {
                        EventHelper.stop(e, true);
                        var focus_1 = _this.tree.getFocus();
                        if (focus_1) {
                            _this.elementSelected(focus_1, e, shouldOpenInBackground ? Mode.OPEN_IN_BACKGROUND : Mode.OPEN);
                        }
                    }
                });
                addDisposableListener(_this.inputBox.inputElement, EventType.INPUT, function (e) {
                    _this.onType();
                });
            });
            // Tree
            _this.treeContainer = div.div({
                'class': 'quick-open-tree'
            }, function (div) {
                var createTree = _this.options.treeCreator || (function (container, config, opts) { return new Tree(container, config, opts); });
                _this.tree = createTree(div.getHTMLElement(), {
                    dataSource: new DataSource$1(_this),
                    controller: new QuickOpenController({ clickBehavior: ClickBehavior.ON_MOUSE_UP, keyboardSupport: _this.options.keyboardSupport }),
                    renderer: (_this.renderer = new Renderer$4(_this, _this.styles)),
                    filter: new Filter(_this),
                    accessibilityProvider: new AccessibilityProvider(_this)
                }, {
                    twistiePixels: 11,
                    indentPixels: 0,
                    alwaysFocused: true,
                    verticalScrollMode: ScrollbarVisibility.Visible,
                    horizontalScrollMode: ScrollbarVisibility.Hidden,
                    ariaLabel: localize('treeAriaLabel', "Quick Picker"),
                    keyboardSupport: _this.options.keyboardSupport,
                    preventRootFocus: true
                });
                _this.treeElement = _this.tree.getHTMLElement();
                // Handle Focus and Selection event
                _this.toUnbind.push(_this.tree.onDidChangeFocus(function (event) {
                    _this.elementFocused(event.focus, event);
                }));
                _this.toUnbind.push(_this.tree.onDidChangeSelection(function (event) {
                    if (event.selection && event.selection.length > 0) {
                        var mouseEvent = event.payload && event.payload.originalEvent instanceof StandardMouseEvent ? event.payload.originalEvent : void 0;
                        var shouldOpenInBackground = mouseEvent ? _this.shouldOpenInBackground(mouseEvent) : false;
                        _this.elementSelected(event.selection[0], event, shouldOpenInBackground ? Mode.OPEN_IN_BACKGROUND : Mode.OPEN);
                    }
                }));
            }).
                on(EventType.KEY_DOWN, function (e) {
                var keyboardEvent = new StandardKeyboardEvent(e);
                // Only handle when in quick navigation mode
                if (!_this.quickNavigateConfiguration) {
                    return;
                }
                // Support keyboard navigation in quick navigation mode
                if (keyboardEvent.keyCode === 18 /* DownArrow */ || keyboardEvent.keyCode === 16 /* UpArrow */ || keyboardEvent.keyCode === 12 /* PageDown */ || keyboardEvent.keyCode === 11 /* PageUp */) {
                    EventHelper.stop(e, true);
                    _this.navigateInTree(keyboardEvent.keyCode);
                }
            }).
                on(EventType.KEY_UP, function (e) {
                var keyboardEvent = new StandardKeyboardEvent(e);
                var keyCode = keyboardEvent.keyCode;
                // Only handle when in quick navigation mode
                if (!_this.quickNavigateConfiguration) {
                    return;
                }
                // Select element when keys are pressed that signal it
                var quickNavKeys = _this.quickNavigateConfiguration.keybindings;
                var wasTriggerKeyPressed = keyCode === 3 /* Enter */ || quickNavKeys.some(function (k) {
                    var _a = k.getParts(), firstPart = _a[0], chordPart = _a[1];
                    if (chordPart) {
                        return false;
                    }
                    if (firstPart.shiftKey && keyCode === 4 /* Shift */) {
                        if (keyboardEvent.ctrlKey || keyboardEvent.altKey || keyboardEvent.metaKey) {
                            return false; // this is an optimistic check for the shift key being used to navigate back in quick open
                        }
                        return true;
                    }
                    if (firstPart.altKey && keyCode === 6 /* Alt */) {
                        return true;
                    }
                    if (firstPart.ctrlKey && keyCode === 5 /* Ctrl */) {
                        return true;
                    }
                    if (firstPart.metaKey && keyCode === 57 /* Meta */) {
                        return true;
                    }
                    return false;
                });
                if (wasTriggerKeyPressed) {
                    var focus_2 = _this.tree.getFocus();
                    if (focus_2) {
                        _this.elementSelected(focus_2, e);
                    }
                }
            }).
                clone();
        })
            // Widget Attributes
            .addClass('monaco-quick-open-widget')
            .build(this.container);
        // Support layout
        if (this.layoutDimensions) {
            this.layout(this.layoutDimensions);
        }
        this.applyStyles();
        // Allows focus to switch to next/previous entry after tab into an actionbar item
        addDisposableListener(this.treeContainer.getHTMLElement(), EventType.KEY_DOWN, function (e) {
            var keyboardEvent = new StandardKeyboardEvent(e);
            // Only handle when not in quick navigation mode
            if (_this.quickNavigateConfiguration) {
                return;
            }
            if (keyboardEvent.keyCode === 18 /* DownArrow */ || keyboardEvent.keyCode === 16 /* UpArrow */ || keyboardEvent.keyCode === 12 /* PageDown */ || keyboardEvent.keyCode === 11 /* PageUp */) {
                EventHelper.stop(e, true);
                _this.navigateInTree(keyboardEvent.keyCode, keyboardEvent.shiftKey);
                _this.inputBox.inputElement.focus();
            }
        });
        return this.builder.getHTMLElement();
    };
    QuickOpenWidget.prototype.style = function (styles) {
        this.styles = styles;
        this.applyStyles();
    };
    QuickOpenWidget.prototype.applyStyles = function () {
        if (this.builder) {
            var foreground$$1 = this.styles.foreground ? this.styles.foreground.toString() : null;
            var background = this.styles.background ? this.styles.background.toString() : null;
            var borderColor = this.styles.borderColor ? this.styles.borderColor.toString() : null;
            var widgetShadow$$1 = this.styles.widgetShadow ? this.styles.widgetShadow.toString() : null;
            this.builder.style('color', foreground$$1);
            this.builder.style('background-color', background);
            this.builder.style('border-color', borderColor);
            this.builder.style('border-width', borderColor ? '1px' : null);
            this.builder.style('border-style', borderColor ? 'solid' : null);
            this.builder.style('box-shadow', widgetShadow$$1 ? "0 5px 8px " + widgetShadow$$1 : null);
        }
        if (this.progressBar) {
            this.progressBar.style({
                progressBarBackground: this.styles.progressBarBackground
            });
        }
        if (this.inputBox) {
            this.inputBox.style({
                inputBackground: this.styles.inputBackground,
                inputForeground: this.styles.inputForeground,
                inputBorder: this.styles.inputBorder,
                inputValidationInfoBackground: this.styles.inputValidationInfoBackground,
                inputValidationInfoBorder: this.styles.inputValidationInfoBorder,
                inputValidationWarningBackground: this.styles.inputValidationWarningBackground,
                inputValidationWarningBorder: this.styles.inputValidationWarningBorder,
                inputValidationErrorBackground: this.styles.inputValidationErrorBackground,
                inputValidationErrorBorder: this.styles.inputValidationErrorBorder
            });
        }
        if (this.tree && !this.options.treeCreator) {
            this.tree.style(this.styles);
        }
        if (this.renderer) {
            this.renderer.updateStyles(this.styles);
        }
    };
    QuickOpenWidget.prototype.shouldOpenInBackground = function (e) {
        // Keyboard
        if (e instanceof StandardKeyboardEvent) {
            if (e.keyCode !== 17 /* RightArrow */) {
                return false; // only for right arrow
            }
            if (e.metaKey || e.ctrlKey || e.shiftKey || e.altKey) {
                return false; // no modifiers allowed
            }
            // validate the cursor is at the end of the input and there is no selection,
            // and if not prevent opening in the background such as the selection can be changed
            var element = this.inputBox.inputElement;
            return element.selectionEnd === this.inputBox.value.length && element.selectionStart === element.selectionEnd;
        }
        // Mouse
        return e.middleButton;
    };
    QuickOpenWidget.prototype.onType = function () {
        var value = this.inputBox.value;
        // Adjust help text as needed if present
        if (this.helpText) {
            if (value) {
                this.helpText.hide();
            }
            else {
                this.helpText.show();
            }
        }
        // Send to callbacks
        this.callbacks.onType(value);
    };
    QuickOpenWidget.prototype.navigate = function (next, quickNavigate) {
        if (this.isVisible()) {
            // Transition into quick navigate mode if not yet done
            if (!this.quickNavigateConfiguration && quickNavigate) {
                this.quickNavigateConfiguration = quickNavigate;
                this.tree.domFocus();
            }
            // Navigate
            this.navigateInTree(next ? 18 /* DownArrow */ : 16 /* UpArrow */);
        }
    };
    QuickOpenWidget.prototype.navigateInTree = function (keyCode, isShift) {
        var model = this.tree.getInput();
        var entries = model ? model.entries : [];
        var oldFocus = this.tree.getFocus();
        // Normal Navigation
        switch (keyCode) {
            case 18 /* DownArrow */:
                this.tree.focusNext();
                break;
            case 16 /* UpArrow */:
                this.tree.focusPrevious();
                break;
            case 12 /* PageDown */:
                this.tree.focusNextPage();
                break;
            case 11 /* PageUp */:
                this.tree.focusPreviousPage();
                break;
            case 2 /* Tab */:
                if (isShift) {
                    this.tree.focusPrevious();
                }
                else {
                    this.tree.focusNext();
                }
                break;
        }
        var newFocus = this.tree.getFocus();
        // Support cycle-through navigation if focus did not change
        if (entries.length > 1 && oldFocus === newFocus) {
            // Up from no entry or first entry goes down to last
            if (keyCode === 16 /* UpArrow */ || (keyCode === 2 /* Tab */ && isShift)) {
                this.tree.focusLast();
            }
            // Down from last entry goes to up to first
            else if (keyCode === 18 /* DownArrow */ || keyCode === 2 /* Tab */ && !isShift) {
                this.tree.focusFirst();
            }
        }
        // Reveal
        newFocus = this.tree.getFocus();
        if (newFocus) {
            this.tree.reveal(newFocus).done(null, onUnexpectedError);
        }
    };
    QuickOpenWidget.prototype.elementFocused = function (value, event) {
        if (!value || !this.isVisible()) {
            return;
        }
        // ARIA
        this.inputElement.setAttribute('aria-activedescendant', this.treeElement.getAttribute('aria-activedescendant'));
        var context = { event: event, keymods: this.extractKeyMods(event), quickNavigateConfiguration: this.quickNavigateConfiguration };
        this.model.runner.run(value, Mode.PREVIEW, context);
    };
    QuickOpenWidget.prototype.elementSelected = function (value, event, preferredMode) {
        var hide$$1 = true;
        // Trigger open of element on selection
        if (this.isVisible()) {
            var mode = preferredMode || Mode.OPEN;
            var context = { event: event, keymods: this.extractKeyMods(event), quickNavigateConfiguration: this.quickNavigateConfiguration };
            hide$$1 = this.model.runner.run(value, mode, context);
        }
        // Hide if command was run successfully
        if (hide$$1) {
            this.hide(HideReason.ELEMENT_SELECTED);
        }
    };
    QuickOpenWidget.prototype.extractKeyMods = function (event) {
        return {
            ctrlCmd: event && (event.ctrlKey || event.metaKey || (event.payload && event.payload.originalEvent && (event.payload.originalEvent.ctrlKey || event.payload.originalEvent.metaKey))),
            alt: event && (event.altKey || (event.payload && event.payload.originalEvent && event.payload.originalEvent.altKey))
        };
    };
    QuickOpenWidget.prototype.show = function (param, options) {
        this.visible = true;
        this.isLoosingFocus = false;
        this.quickNavigateConfiguration = options ? options.quickNavigateConfiguration : void 0;
        // Adjust UI for quick navigate mode
        if (this.quickNavigateConfiguration) {
            this.inputContainer.hide();
            this.builder.show();
            this.tree.domFocus();
        }
        // Otherwise use normal UI
        else {
            this.inputContainer.show();
            this.builder.show();
            this.inputBox.focus();
        }
        // Adjust Help text for IE
        if (this.helpText) {
            if (this.quickNavigateConfiguration || isString(param)) {
                this.helpText.hide();
            }
            else {
                this.helpText.show();
            }
        }
        // Show based on param
        if (isString(param)) {
            this.doShowWithPrefix(param);
        }
        else {
            this.doShowWithInput(param, options && options.autoFocus ? options.autoFocus : {});
        }
        // Respect selectAll option
        if (options && options.inputSelection && !this.quickNavigateConfiguration) {
            this.inputBox.select(options.inputSelection);
        }
        if (this.callbacks.onShow) {
            this.callbacks.onShow();
        }
    };
    QuickOpenWidget.prototype.doShowWithPrefix = function (prefix) {
        this.inputBox.value = prefix;
        this.callbacks.onType(prefix);
    };
    QuickOpenWidget.prototype.doShowWithInput = function (input, autoFocus) {
        this.setInput(input, autoFocus);
    };
    QuickOpenWidget.prototype.setInputAndLayout = function (input, autoFocus) {
        var _this = this;
        this.treeContainer.style({ height: this.getHeight(input) + "px" });
        this.tree.setInput(null).then(function () {
            _this.model = input;
            // ARIA
            _this.inputElement.setAttribute('aria-haspopup', String(input && input.entries && input.entries.length > 0));
            return _this.tree.setInput(input);
        }).done(function () {
            // Indicate entries to tree
            _this.tree.layout();
            // Handle auto focus
            if (input && input.entries.some(function (e) { return _this.isElementVisible(input, e); })) {
                _this.autoFocus(input, autoFocus);
            }
        }, onUnexpectedError);
    };
    QuickOpenWidget.prototype.isElementVisible = function (input, e) {
        if (!input.filter) {
            return true;
        }
        return input.filter.isVisible(e);
    };
    QuickOpenWidget.prototype.autoFocus = function (input, autoFocus) {
        var _this = this;
        if (autoFocus === void 0) { autoFocus = {}; }
        var entries = input.entries.filter(function (e) { return _this.isElementVisible(input, e); });
        // First check for auto focus of prefix matches
        if (autoFocus.autoFocusPrefixMatch) {
            var caseSensitiveMatch = void 0;
            var caseInsensitiveMatch = void 0;
            var prefix = autoFocus.autoFocusPrefixMatch;
            var lowerCasePrefix = prefix.toLowerCase();
            for (var i = 0; i < entries.length; i++) {
                var entry = entries[i];
                var label = input.dataSource.getLabel(entry);
                if (!caseSensitiveMatch && label.indexOf(prefix) === 0) {
                    caseSensitiveMatch = entry;
                }
                else if (!caseInsensitiveMatch && label.toLowerCase().indexOf(lowerCasePrefix) === 0) {
                    caseInsensitiveMatch = entry;
                }
                if (caseSensitiveMatch && caseInsensitiveMatch) {
                    break;
                }
            }
            var entryToFocus = caseSensitiveMatch || caseInsensitiveMatch;
            if (entryToFocus) {
                this.tree.setFocus(entryToFocus);
                this.tree.reveal(entryToFocus, 0.5).done(null, onUnexpectedError);
                return;
            }
        }
        // Second check for auto focus of first entry
        if (autoFocus.autoFocusFirstEntry) {
            this.tree.focusFirst();
            this.tree.reveal(this.tree.getFocus()).done(null, onUnexpectedError);
        }
        // Third check for specific index option
        else if (typeof autoFocus.autoFocusIndex === 'number') {
            if (entries.length > autoFocus.autoFocusIndex) {
                this.tree.focusNth(autoFocus.autoFocusIndex);
                this.tree.reveal(this.tree.getFocus()).done(null, onUnexpectedError);
            }
        }
        // Check for auto focus of second entry
        else if (autoFocus.autoFocusSecondEntry) {
            if (entries.length > 1) {
                this.tree.focusNth(1);
            }
        }
        // Finally check for auto focus of last entry
        else if (autoFocus.autoFocusLastEntry) {
            if (entries.length > 1) {
                this.tree.focusLast();
            }
        }
    };
    QuickOpenWidget.prototype.refresh = function (input, autoFocus) {
        var _this = this;
        if (!this.isVisible()) {
            return;
        }
        if (!input) {
            input = this.tree.getInput();
        }
        if (!input) {
            return;
        }
        // Apply height & Refresh
        this.treeContainer.style({ height: this.getHeight(input) + "px" });
        this.tree.refresh().done(function () {
            // Indicate entries to tree
            _this.tree.layout();
            // Handle auto focus
            if (autoFocus) {
                var doAutoFocus = autoFocus && input && input.entries.some(function (e) { return _this.isElementVisible(input, e); });
                if (doAutoFocus) {
                    _this.autoFocus(input, autoFocus);
                }
            }
        }, onUnexpectedError);
    };
    QuickOpenWidget.prototype.getHeight = function (input) {
        var _this = this;
        var renderer = input.renderer;
        if (!input) {
            var itemHeight = renderer.getHeight(null);
            return this.options.minItemsToShow ? this.options.minItemsToShow * itemHeight : 0;
        }
        var height = 0;
        var preferredItemsHeight;
        if (this.layoutDimensions && this.layoutDimensions.height) {
            preferredItemsHeight = (this.layoutDimensions.height - 50 /* subtract height of input field (30px) and some spacing (drop shadow) to fit */) * 0.40 /* max 40% of screen */;
        }
        if (!preferredItemsHeight || preferredItemsHeight > QuickOpenWidget.MAX_ITEMS_HEIGHT) {
            preferredItemsHeight = QuickOpenWidget.MAX_ITEMS_HEIGHT;
        }
        var entries = input.entries.filter(function (e) { return _this.isElementVisible(input, e); });
        var maxEntries = this.options.maxItemsToShow || entries.length;
        for (var i = 0; i < maxEntries && i < entries.length; i++) {
            var entryHeight = renderer.getHeight(entries[i]);
            if (height + entryHeight <= preferredItemsHeight) {
                height += entryHeight;
            }
            else {
                break;
            }
        }
        return height;
    };
    QuickOpenWidget.prototype.hide = function (reason) {
        if (!this.isVisible()) {
            return;
        }
        this.visible = false;
        this.builder.hide();
        this.builder.domBlur();
        // Clear input field and clear tree
        this.inputBox.value = '';
        this.tree.setInput(null);
        // ARIA
        this.inputElement.setAttribute('aria-haspopup', 'false');
        // Reset Tree Height
        this.treeContainer.style({ height: (this.options.minItemsToShow ? this.options.minItemsToShow * 22 : 0) + 'px' });
        // Clear any running Progress
        this.progressBar.stop().hide();
        // Clear Focus
        if (this.tree.isDOMFocused()) {
            this.tree.domBlur();
        }
        else if (this.inputBox.hasFocus()) {
            this.inputBox.blur();
        }
        // Callbacks
        if (reason === HideReason.ELEMENT_SELECTED) {
            this.callbacks.onOk();
        }
        else {
            this.callbacks.onCancel();
        }
        if (this.callbacks.onHide) {
            this.callbacks.onHide(reason);
        }
    };
    QuickOpenWidget.prototype.getQuickNavigateConfiguration = function () {
        return this.quickNavigateConfiguration;
    };
    QuickOpenWidget.prototype.setPlaceHolder = function (placeHolder) {
        if (this.inputBox) {
            this.inputBox.setPlaceHolder(placeHolder);
        }
    };
    QuickOpenWidget.prototype.setValue = function (value, selectionOrStableHint) {
        if (this.inputBox) {
            this.inputBox.value = value;
            if (selectionOrStableHint === null) ;
            else if (Array.isArray(selectionOrStableHint)) {
                var start = selectionOrStableHint[0], end = selectionOrStableHint[1];
                this.inputBox.select({ start: start, end: end });
            }
            else {
                this.inputBox.select();
            }
        }
    };
    QuickOpenWidget.prototype.setPassword = function (isPassword) {
        if (this.inputBox) {
            this.inputBox.inputElement.type = isPassword ? 'password' : 'text';
        }
    };
    QuickOpenWidget.prototype.setInput = function (input, autoFocus, ariaLabel) {
        if (!this.isVisible()) {
            return;
        }
        // If the input changes, indicate this to the tree
        if (!!this.getInput()) {
            this.onInputChanging();
        }
        // Adapt tree height to entries and apply input
        this.setInputAndLayout(input, autoFocus);
        // Apply ARIA
        if (this.inputBox) {
            this.inputBox.setAriaLabel(ariaLabel || DEFAULT_INPUT_ARIA_LABEL);
        }
    };
    QuickOpenWidget.prototype.onInputChanging = function () {
        var _this = this;
        if (this.inputChangingTimeoutHandle) {
            clearTimeout(this.inputChangingTimeoutHandle);
            this.inputChangingTimeoutHandle = null;
        }
        // when the input is changing in quick open, we indicate this as CSS class to the widget
        // for a certain timeout. this helps reducing some hectic UI updates when input changes quickly
        this.builder.addClass('content-changing');
        this.inputChangingTimeoutHandle = setTimeout(function () {
            _this.builder.removeClass('content-changing');
        }, 500);
    };
    QuickOpenWidget.prototype.getInput = function () {
        return this.tree.getInput();
    };
    QuickOpenWidget.prototype.showInputDecoration = function (decoration) {
        if (this.inputBox) {
            this.inputBox.showMessage({ type: decoration === Severity.Info ? MessageType.INFO : decoration === Severity.Warning ? MessageType.WARNING : MessageType.ERROR, content: '' });
        }
    };
    QuickOpenWidget.prototype.clearInputDecoration = function () {
        if (this.inputBox) {
            this.inputBox.hideMessage();
        }
    };
    QuickOpenWidget.prototype.focus = function () {
        if (this.isVisible() && this.inputBox) {
            this.inputBox.focus();
        }
    };
    QuickOpenWidget.prototype.accept = function () {
        if (this.isVisible()) {
            var focus_3 = this.tree.getFocus();
            if (focus_3) {
                this.elementSelected(focus_3);
            }
        }
    };
    QuickOpenWidget.prototype.getProgressBar = function () {
        return this.progressBar;
    };
    QuickOpenWidget.prototype.getInputBox = function () {
        return this.inputBox;
    };
    QuickOpenWidget.prototype.setExtraClass = function (clazz) {
        var previousClass = this.builder.getProperty('extra-class');
        if (previousClass) {
            this.builder.removeClass(previousClass);
        }
        if (clazz) {
            this.builder.addClass(clazz);
            this.builder.setProperty('extra-class', clazz);
        }
        else if (previousClass) {
            this.builder.removeProperty('extra-class');
        }
    };
    QuickOpenWidget.prototype.isVisible = function () {
        return this.visible;
    };
    QuickOpenWidget.prototype.layout = function (dimension) {
        this.layoutDimensions = dimension;
        // Apply to quick open width (height is dynamic by number of items to show)
        var quickOpenWidth = Math.min(this.layoutDimensions.width * 0.62 /* golden cut */, QuickOpenWidget.MAX_WIDTH);
        if (this.builder) {
            // quick open
            this.builder.style({
                width: quickOpenWidth + 'px',
                marginLeft: '-' + (quickOpenWidth / 2) + 'px'
            });
            // input field
            this.inputContainer.style({
                width: (quickOpenWidth - 12) + 'px'
            });
        }
    };
    QuickOpenWidget.prototype.gainingFocus = function () {
        this.isLoosingFocus = false;
    };
    QuickOpenWidget.prototype.loosingFocus = function (e) {
        var _this = this;
        if (!this.isVisible()) {
            return;
        }
        var relatedTarget = e.relatedTarget;
        if (!this.quickNavigateConfiguration && isAncestor(relatedTarget, this.builder.getHTMLElement())) {
            return; // user clicked somewhere into quick open widget, do not close thereby
        }
        this.isLoosingFocus = true;
        TPromise.timeout(0).then(function () {
            if (!_this.isLoosingFocus) {
                return;
            }
            if (_this.isDisposed) {
                return;
            }
            var veto = _this.callbacks.onFocusLost && _this.callbacks.onFocusLost();
            if (!veto) {
                _this.hide(HideReason.FOCUS_LOST);
            }
        });
    };
    QuickOpenWidget.prototype.dispose = function () {
        this.isDisposed = true;
        this.toUnbind = dispose(this.toUnbind);
        this.progressBar.dispose();
        this.inputBox.dispose();
        this.tree.dispose();
    };
    QuickOpenWidget.MAX_WIDTH = 600; // Max total width of quick open widget
    QuickOpenWidget.MAX_ITEMS_HEIGHT = 20 * 22; // Max height of item list below input field
    return QuickOpenWidget;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var QuickOpenEditorWidget = /** @class */ (function () {
    function QuickOpenEditorWidget(codeEditor, onOk, onCancel, onType, configuration, themeService) {
        this.codeEditor = codeEditor;
        this.themeService = themeService;
        this.create(onOk, onCancel, onType, configuration);
    }
    QuickOpenEditorWidget.prototype.create = function (onOk, onCancel, onType, configuration) {
        this.domNode = document.createElement('div');
        this.quickOpenWidget = new QuickOpenWidget(this.domNode, {
            onOk: onOk,
            onCancel: onCancel,
            onType: onType
        }, {
            inputPlaceHolder: null,
            inputAriaLabel: configuration.inputAriaLabel,
            keyboardSupport: true
        });
        this.styler = attachQuickOpenStyler(this.quickOpenWidget, this.themeService, {
            pickerGroupForeground: foreground
        });
        this.quickOpenWidget.create();
        this.codeEditor.addOverlayWidget(this);
    };
    QuickOpenEditorWidget.prototype.setInput = function (model, focus) {
        this.quickOpenWidget.setInput(model, focus);
    };
    QuickOpenEditorWidget.prototype.getId = function () {
        return QuickOpenEditorWidget.ID;
    };
    QuickOpenEditorWidget.prototype.getDomNode = function () {
        return this.domNode;
    };
    QuickOpenEditorWidget.prototype.destroy = function () {
        this.codeEditor.removeOverlayWidget(this);
        this.quickOpenWidget.dispose();
        this.styler.dispose();
    };
    QuickOpenEditorWidget.prototype.isVisible = function () {
        return this.visible;
    };
    QuickOpenEditorWidget.prototype.show = function (value) {
        this.visible = true;
        var editorLayout = this.codeEditor.getLayoutInfo();
        if (editorLayout) {
            this.quickOpenWidget.layout(new Dimension(editorLayout.width, editorLayout.height));
        }
        this.quickOpenWidget.show(value);
        this.codeEditor.layoutOverlayWidget(this);
    };
    QuickOpenEditorWidget.prototype.hide = function () {
        this.visible = false;
        this.quickOpenWidget.hide();
        this.codeEditor.layoutOverlayWidget(this);
    };
    QuickOpenEditorWidget.prototype.getPosition = function () {
        if (this.visible) {
            return {
                preference: OverlayWidgetPositionPreference.TOP_CENTER
            };
        }
        return null;
    };
    QuickOpenEditorWidget.ID = 'editor.contrib.quickOpenEditorWidget';
    return QuickOpenEditorWidget;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$Q = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate$u = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$u = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var QuickOpenController$1 = /** @class */ (function () {
    function QuickOpenController(editor, themeService) {
        this.themeService = themeService;
        this.editor = editor;
    }
    QuickOpenController.get = function (editor) {
        return editor.getContribution(QuickOpenController.ID);
    };
    QuickOpenController.prototype.getId = function () {
        return QuickOpenController.ID;
    };
    QuickOpenController.prototype.dispose = function () {
        // Dispose widget
        if (this.widget) {
            this.widget.destroy();
            this.widget = null;
        }
    };
    QuickOpenController.prototype.run = function (opts) {
        var _this = this;
        if (this.widget) {
            this.widget.destroy();
            this.widget = null;
        }
        // Create goto line widget
        var onClose = function (canceled$$1) {
            // Clear Highlight Decorations if present
            _this.clearDecorations();
            // Restore selection if canceled
            if (canceled$$1 && _this.lastKnownEditorSelection) {
                _this.editor.setSelection(_this.lastKnownEditorSelection);
                _this.editor.revealRangeInCenterIfOutsideViewport(_this.lastKnownEditorSelection, 0 /* Smooth */);
            }
            _this.lastKnownEditorSelection = null;
            _this.editor.focus();
        };
        this.widget = new QuickOpenEditorWidget(this.editor, function () { return onClose(false); }, function () { return onClose(true); }, function (value) {
            _this.widget.setInput(opts.getModel(value), opts.getAutoFocus(value));
        }, {
            inputAriaLabel: opts.inputAriaLabel
        }, this.themeService);
        // Remember selection to be able to restore on cancel
        if (!this.lastKnownEditorSelection) {
            this.lastKnownEditorSelection = this.editor.getSelection();
        }
        // Show
        this.widget.show('');
    };
    QuickOpenController.prototype.decorateLine = function (range$$1, editor) {
        var oldDecorations = [];
        if (this.rangeHighlightDecorationId) {
            oldDecorations.push(this.rangeHighlightDecorationId);
            this.rangeHighlightDecorationId = null;
        }
        var newDecorations = [
            {
                range: range$$1,
                options: QuickOpenController._RANGE_HIGHLIGHT_DECORATION
            }
        ];
        var decorations = editor.deltaDecorations(oldDecorations, newDecorations);
        this.rangeHighlightDecorationId = decorations[0];
    };
    QuickOpenController.prototype.clearDecorations = function () {
        if (this.rangeHighlightDecorationId) {
            this.editor.deltaDecorations([this.rangeHighlightDecorationId], []);
            this.rangeHighlightDecorationId = null;
        }
    };
    QuickOpenController.ID = 'editor.controller.quickOpenController';
    QuickOpenController._RANGE_HIGHLIGHT_DECORATION = ModelDecorationOptions.register({
        className: 'rangeHighlight',
        isWholeLine: true
    });
    QuickOpenController = __decorate$u([
        __param$u(1, IThemeService)
    ], QuickOpenController);
    return QuickOpenController;
}());
/**
 * Base class for providing quick open in the editor.
 */
var BaseEditorQuickOpenAction = /** @class */ (function (_super) {
    __extends$Q(BaseEditorQuickOpenAction, _super);
    function BaseEditorQuickOpenAction(inputAriaLabel, opts) {
        var _this = _super.call(this, opts) || this;
        _this._inputAriaLabel = inputAriaLabel;
        return _this;
    }
    BaseEditorQuickOpenAction.prototype.getController = function (editor) {
        return QuickOpenController$1.get(editor);
    };
    BaseEditorQuickOpenAction.prototype._show = function (controller, opts) {
        controller.run({
            inputAriaLabel: this._inputAriaLabel,
            getModel: function (value) { return opts.getModel(value); },
            getAutoFocus: function (searchValue) { return opts.getAutoFocus(searchValue); }
        });
    };
    return BaseEditorQuickOpenAction;
}(EditorAction));
registerEditorContribution(QuickOpenController$1);

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
function getDocumentSymbols(model) {
    var entries = [];
    var promises = DocumentSymbolProviderRegistry.all(model).map(function (support) {
        return asWinJsPromise(function (token) {
            return support.provideDocumentSymbols(model, token);
        }).then(function (result) {
            if (Array.isArray(result)) {
                entries.push.apply(entries, result);
            }
        }, function (err) {
            onUnexpectedExternalError(err);
        });
    });
    return TPromise.join(promises).then(function () {
        var flatEntries = [];
        flatten$1(flatEntries, entries, '');
        flatEntries.sort(compareEntriesUsingStart);
        return {
            entries: flatEntries,
        };
    });
}
function compareEntriesUsingStart(a, b) {
    return Range.compareRangesUsingStarts(Range.lift(a.location.range), Range.lift(b.location.range));
}
function flatten$1(bucket, entries, overrideContainerLabel) {
    for (var _i = 0, entries_1 = entries; _i < entries_1.length; _i++) {
        var entry = entries_1[_i];
        bucket.push({
            kind: entry.kind,
            location: entry.location,
            name: entry.name,
            containerName: entry.containerName || overrideContainerLabel
        });
    }
}
registerLanguageCommand('_executeDocumentSymbolProvider', function (accessor, args) {
    var resource = args.resource;
    if (!(resource instanceof URI)) {
        throw illegalArgument('resource');
    }
    var model = accessor.get(IModelService).getModel(resource);
    if (!model) {
        throw illegalArgument('resource');
    }
    return getDocumentSymbols(model);
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$R = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var SCOPE_PREFIX = ':';
var SymbolEntry = /** @class */ (function (_super) {
    __extends$R(SymbolEntry, _super);
    function SymbolEntry(name, type, description, range$$1, highlights, editor, decorator) {
        var _this = _super.call(this) || this;
        _this.name = name;
        _this.type = type;
        _this.description = description;
        _this.range = range$$1;
        _this.setHighlights(highlights);
        _this.editor = editor;
        _this.decorator = decorator;
        return _this;
    }
    SymbolEntry.prototype.getLabel = function () {
        return this.name;
    };
    SymbolEntry.prototype.getAriaLabel = function () {
        return localize('entryAriaLabel', "{0}, symbols", this.name);
    };
    SymbolEntry.prototype.getIcon = function () {
        return this.type;
    };
    SymbolEntry.prototype.getDescription = function () {
        return this.description;
    };
    SymbolEntry.prototype.getType = function () {
        return this.type;
    };
    SymbolEntry.prototype.getRange = function () {
        return this.range;
    };
    SymbolEntry.prototype.run = function (mode, context) {
        if (mode === Mode.OPEN) {
            return this.runOpen(context);
        }
        return this.runPreview();
    };
    SymbolEntry.prototype.runOpen = function (context) {
        // Apply selection and focus
        var range$$1 = this.toSelection();
        this.editor.setSelection(range$$1);
        this.editor.revealRangeInCenter(range$$1, 0 /* Smooth */);
        this.editor.focus();
        return true;
    };
    SymbolEntry.prototype.runPreview = function () {
        // Select Outline Position
        var range$$1 = this.toSelection();
        this.editor.revealRangeInCenter(range$$1, 0 /* Smooth */);
        // Decorate if possible
        this.decorator.decorateLine(this.range, this.editor);
        return false;
    };
    SymbolEntry.prototype.toSelection = function () {
        return new Range(this.range.startLineNumber, this.range.startColumn || 1, this.range.startLineNumber, this.range.startColumn || 1);
    };
    return SymbolEntry;
}(QuickOpenEntryGroup));
var QuickOutlineAction = /** @class */ (function (_super) {
    __extends$R(QuickOutlineAction, _super);
    function QuickOutlineAction() {
        return _super.call(this, localize('quickOutlineActionInput', "Type the name of an identifier you wish to navigate to"), {
            id: 'editor.action.quickOutline',
            label: localize('QuickOutlineAction.label', "Go to Symbol..."),
            alias: 'Go to Symbol...',
            precondition: EditorContextKeys.hasDocumentSymbolProvider,
            kbOpts: {
                kbExpr: EditorContextKeys.focus,
                primary: 2048 /* CtrlCmd */ | 1024 /* Shift */ | 45 /* KEY_O */
            },
            menuOpts: {
                group: 'navigation',
                order: 3
            }
        }) || this;
    }
    QuickOutlineAction.prototype.run = function (accessor, editor) {
        var _this = this;
        var model = editor.getModel();
        if (!DocumentSymbolProviderRegistry.has(model)) {
            return null;
        }
        // Resolve outline
        return getDocumentSymbols(model).then(function (result) {
            if (result.entries.length === 0) {
                return;
            }
            _this._run(editor, result.entries);
        });
    };
    QuickOutlineAction.prototype._run = function (editor, result) {
        var _this = this;
        this._show(this.getController(editor), {
            getModel: function (value) {
                return new QuickOpenModel(_this.toQuickOpenEntries(editor, result, value));
            },
            getAutoFocus: function (searchValue) {
                // Remove any type pattern (:) from search value as needed
                if (searchValue.indexOf(SCOPE_PREFIX) === 0) {
                    searchValue = searchValue.substr(SCOPE_PREFIX.length);
                }
                return {
                    autoFocusPrefixMatch: searchValue,
                    autoFocusFirstEntry: !!searchValue
                };
            }
        });
    };
    QuickOutlineAction.prototype.symbolEntry = function (name, type, description, location, highlights, editor, decorator) {
        return new SymbolEntry(name, type, description, Range.lift(location.range), highlights, editor, decorator);
    };
    QuickOutlineAction.prototype.toQuickOpenEntries = function (editor, flattened, searchValue) {
        var controller = this.getController(editor);
        var results = [];
        // Convert to Entries
        var normalizedSearchValue = searchValue;
        if (searchValue.indexOf(SCOPE_PREFIX) === 0) {
            normalizedSearchValue = normalizedSearchValue.substr(SCOPE_PREFIX.length);
        }
        for (var i = 0; i < flattened.length; i++) {
            var element = flattened[i];
            var label = trim(element.name);
            // Check for meatch
            var highlights = matchesFuzzy(normalizedSearchValue, label);
            if (highlights) {
                // Show parent scope as description
                var description = null;
                if (element.containerName) {
                    description = element.containerName;
                }
                // Add
                results.push(this.symbolEntry(label, symbolKindToCssClass(element.kind), description, element.location, highlights, editor, controller));
            }
        }
        // Sort properly if actually searching
        if (searchValue) {
            if (searchValue.indexOf(SCOPE_PREFIX) === 0) {
                results = results.sort(this.sortScoped.bind(this, searchValue.toLowerCase()));
            }
            else {
                results = results.sort(this.sortNormal.bind(this, searchValue.toLowerCase()));
            }
        }
        // Mark all type groups
        if (results.length > 0 && searchValue.indexOf(SCOPE_PREFIX) === 0) {
            var currentType = null;
            var currentResult = null;
            var typeCounter = 0;
            for (var i = 0; i < results.length; i++) {
                var result = results[i];
                // Found new type
                if (currentType !== result.getType()) {
                    // Update previous result with count
                    if (currentResult) {
                        currentResult.setGroupLabel(this.typeToLabel(currentType, typeCounter));
                    }
                    currentType = result.getType();
                    currentResult = result;
                    typeCounter = 1;
                    result.setShowBorder(i > 0);
                }
                // Existing type, keep counting
                else {
                    typeCounter++;
                }
            }
            // Update previous result with count
            if (currentResult) {
                currentResult.setGroupLabel(this.typeToLabel(currentType, typeCounter));
            }
        }
        // Mark first entry as outline
        else if (results.length > 0) {
            results[0].setGroupLabel(localize('symbols', "symbols ({0})", results.length));
        }
        return results;
    };
    QuickOutlineAction.prototype.typeToLabel = function (type, count) {
        switch (type) {
            case 'module': return localize('modules', "modules ({0})", count);
            case 'class': return localize('class', "classes ({0})", count);
            case 'interface': return localize('interface', "interfaces ({0})", count);
            case 'method': return localize('method', "methods ({0})", count);
            case 'function': return localize('function', "functions ({0})", count);
            case 'property': return localize('property', "properties ({0})", count);
            case 'variable': return localize('variable', "variables ({0})", count);
            case 'var': return localize('variable2', "variables ({0})", count);
            case 'constructor': return localize('_constructor', "constructors ({0})", count);
            case 'call': return localize('call', "calls ({0})", count);
        }
        return type;
    };
    QuickOutlineAction.prototype.sortNormal = function (searchValue, elementA, elementB) {
        var elementAName = elementA.getLabel().toLowerCase();
        var elementBName = elementB.getLabel().toLowerCase();
        // Compare by name
        var r = elementAName.localeCompare(elementBName);
        if (r !== 0) {
            return r;
        }
        // If name identical sort by range instead
        var elementARange = elementA.getRange();
        var elementBRange = elementB.getRange();
        return elementARange.startLineNumber - elementBRange.startLineNumber;
    };
    QuickOutlineAction.prototype.sortScoped = function (searchValue, elementA, elementB) {
        // Remove scope char
        searchValue = searchValue.substr(SCOPE_PREFIX.length);
        // Sort by type first if scoped search
        var elementAType = elementA.getType();
        var elementBType = elementB.getType();
        var r = elementAType.localeCompare(elementBType);
        if (r !== 0) {
            return r;
        }
        // Special sort when searching in scoped mode
        if (searchValue) {
            var elementAName = elementA.getLabel().toLowerCase();
            var elementBName = elementB.getLabel().toLowerCase();
            // Compare by name
            var r_1 = elementAName.localeCompare(elementBName);
            if (r_1 !== 0) {
                return r_1;
            }
        }
        // Default to sort by range
        var elementARange = elementA.getRange();
        var elementBRange = elementB.getRange();
        return elementARange.startLineNumber - elementBRange.startLineNumber;
    };
    return QuickOutlineAction;
}(BaseEditorQuickOpenAction));
registerEditorAction(QuickOutlineAction);

const css$w = "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n.monaco-quick-open-widget {\n\tfont-size: 13px;\n}";
  const element$w = ((css, src) => {
if (typeof document !== 'object')
console.info(`Skipped loading "${src}"`);
try {
const id = src
  .replace(/\.css.*$/, '')
  .replace(/[\\:]/g, '/')
  .replace(/[^\w\/]+/g, '');
return (
  document.querySelector(`style[id="${id}"]`) ||
  document.head.appendChild(
    Object.assign(document.createElement('style'), {
      id,
      textContent: `${css}\n\n /* sourceURL=${src} */`,
    }),
  )
);
} catch (exception) {
console.warn(`Failed load "${src}"`, exception);
}
})(css$w, "…monaco-editor/esm/vs/editor/standalone/browser/quickOpen/gotoLine.css");
  //@ sourceURL=/Users/daflair/Projects/packages/monaco-es/node_modules/monaco-editor/esm/vs/editor/standalone/browser/quickOpen/gotoLine.css

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$S = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var GotoLineEntry = /** @class */ (function (_super) {
    __extends$S(GotoLineEntry, _super);
    function GotoLineEntry(line, editor, decorator) {
        var _this = _super.call(this) || this;
        _this.editor = editor;
        _this.decorator = decorator;
        _this._parseResult = _this._parseInput(line);
        return _this;
    }
    GotoLineEntry.prototype._parseInput = function (line) {
        var numbers = line.split(',').map(function (part) { return parseInt(part, 10); }).filter(function (part) { return !isNaN(part); }), position;
        if (numbers.length === 0) {
            position = new Position(-1, -1);
        }
        else if (numbers.length === 1) {
            position = new Position(numbers[0], 1);
        }
        else {
            position = new Position(numbers[0], numbers[1]);
        }
        var model;
        if (isCodeEditor(this.editor)) {
            model = this.editor.getModel();
        }
        else {
            model = this.editor.getModel().modified;
        }
        var isValid = model.validatePosition(position).equals(position), label;
        if (isValid) {
            if (position.column && position.column > 1) {
                label = localize('gotoLineLabelValidLineAndColumn', "Go to line {0} and character {1}", position.lineNumber, position.column);
            }
            else {
                label = localize('gotoLineLabelValidLine', "Go to line {0}", position.lineNumber, position.column);
            }
        }
        else if (position.lineNumber < 1 || position.lineNumber > model.getLineCount()) {
            label = localize('gotoLineLabelEmptyWithLineLimit', "Type a line number between 1 and {0} to navigate to", model.getLineCount());
        }
        else {
            label = localize('gotoLineLabelEmptyWithLineAndColumnLimit', "Type a character between 1 and {0} to navigate to", model.getLineMaxColumn(position.lineNumber));
        }
        return {
            position: position,
            isValid: isValid,
            label: label
        };
    };
    GotoLineEntry.prototype.getLabel = function () {
        return this._parseResult.label;
    };
    GotoLineEntry.prototype.getAriaLabel = function () {
        return localize('gotoLineAriaLabel', "Go to line {0}", this._parseResult.label);
    };
    GotoLineEntry.prototype.run = function (mode, context) {
        if (mode === Mode.OPEN) {
            return this.runOpen();
        }
        return this.runPreview();
    };
    GotoLineEntry.prototype.runOpen = function () {
        // No-op if range is not valid
        if (!this._parseResult.isValid) {
            return false;
        }
        // Apply selection and focus
        var range$$1 = this.toSelection();
        this.editor.setSelection(range$$1);
        this.editor.revealRangeInCenter(range$$1, 0 /* Smooth */);
        this.editor.focus();
        return true;
    };
    GotoLineEntry.prototype.runPreview = function () {
        // No-op if range is not valid
        if (!this._parseResult.isValid) {
            this.decorator.clearDecorations();
            return false;
        }
        // Select Line Position
        var range$$1 = this.toSelection();
        this.editor.revealRangeInCenter(range$$1, 0 /* Smooth */);
        // Decorate if possible
        this.decorator.decorateLine(range$$1, this.editor);
        return false;
    };
    GotoLineEntry.prototype.toSelection = function () {
        return new Range(this._parseResult.position.lineNumber, this._parseResult.position.column, this._parseResult.position.lineNumber, this._parseResult.position.column);
    };
    return GotoLineEntry;
}(QuickOpenEntry));
var GotoLineAction = /** @class */ (function (_super) {
    __extends$S(GotoLineAction, _super);
    function GotoLineAction() {
        return _super.call(this, localize('gotoLineActionInput', "Type a line number, followed by an optional colon and a character number to navigate to"), {
            id: 'editor.action.gotoLine',
            label: localize('GotoLineAction.label', "Go to Line..."),
            alias: 'Go to Line...',
            precondition: null,
            kbOpts: {
                kbExpr: EditorContextKeys.focus,
                primary: 2048 /* CtrlCmd */ | 37 /* KEY_G */,
                mac: { primary: 256 /* WinCtrl */ | 37 /* KEY_G */ }
            }
        }) || this;
    }
    GotoLineAction.prototype.run = function (accessor, editor) {
        var _this = this;
        this._show(this.getController(editor), {
            getModel: function (value) {
                return new QuickOpenModel([new GotoLineEntry(value, editor, _this.getController(editor))]);
            },
            getAutoFocus: function (searchValue) {
                return {
                    autoFocusFirstEntry: searchValue.length > 0
                };
            }
        });
    };
    return GotoLineAction;
}(BaseEditorQuickOpenAction));
registerEditorAction(GotoLineAction);

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$T = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var EditorActionCommandEntry = /** @class */ (function (_super) {
    __extends$T(EditorActionCommandEntry, _super);
    function EditorActionCommandEntry(key, highlights, action, editor) {
        var _this = _super.call(this) || this;
        _this.key = key;
        _this.setHighlights(highlights);
        _this.action = action;
        _this.editor = editor;
        return _this;
    }
    EditorActionCommandEntry.prototype.getLabel = function () {
        return this.action.label;
    };
    EditorActionCommandEntry.prototype.getAriaLabel = function () {
        return localize('ariaLabelEntry', "{0}, commands", this.getLabel());
    };
    EditorActionCommandEntry.prototype.getGroupLabel = function () {
        return this.key;
    };
    EditorActionCommandEntry.prototype.run = function (mode, context) {
        var _this = this;
        if (mode === Mode.OPEN) {
            // Use a timeout to give the quick open widget a chance to close itself first
            TPromise.timeout(50).done(function () {
                // Some actions are enabled only when editor has focus
                _this.editor.focus();
                try {
                    var promise = _this.action.run() || TPromise.as(null);
                    promise.done(null, onUnexpectedError);
                }
                catch (error) {
                    onUnexpectedError(error);
                }
            }, onUnexpectedError);
            return true;
        }
        return false;
    };
    return EditorActionCommandEntry;
}(QuickOpenEntryGroup));
var QuickCommandAction = /** @class */ (function (_super) {
    __extends$T(QuickCommandAction, _super);
    function QuickCommandAction() {
        return _super.call(this, localize('quickCommandActionInput', "Type the name of an action you want to execute"), {
            id: 'editor.action.quickCommand',
            label: localize('QuickCommandAction.label', "Command Palette"),
            alias: 'Command Palette',
            precondition: null,
            kbOpts: {
                kbExpr: EditorContextKeys.focus,
                primary: (isIE ? 512 /* Alt */ | 59 /* F1 */ : 59 /* F1 */)
            },
            menuOpts: {}
        }) || this;
    }
    QuickCommandAction.prototype.run = function (accessor, editor) {
        var _this = this;
        var keybindingService = accessor.get(IKeybindingService);
        this._show(this.getController(editor), {
            getModel: function (value) {
                return new QuickOpenModel(_this._editorActionsToEntries(keybindingService, editor, value));
            },
            getAutoFocus: function (searchValue) {
                return {
                    autoFocusFirstEntry: true,
                    autoFocusPrefixMatch: searchValue
                };
            }
        });
    };
    QuickCommandAction.prototype._sort = function (elementA, elementB) {
        var elementAName = elementA.getLabel().toLowerCase();
        var elementBName = elementB.getLabel().toLowerCase();
        return elementAName.localeCompare(elementBName);
    };
    QuickCommandAction.prototype._editorActionsToEntries = function (keybindingService, editor, searchValue) {
        var actions = editor.getSupportedActions();
        var entries = [];
        for (var i = 0; i < actions.length; i++) {
            var action = actions[i];
            var keybind = keybindingService.lookupKeybinding(action.id);
            if (action.label) {
                var highlights = matchesFuzzy(searchValue, action.label);
                if (highlights) {
                    entries.push(new EditorActionCommandEntry(keybind ? keybind.getLabel() : '', highlights, action, editor));
                }
            }
        }
        // Sort by name
        entries = entries.sort(this._sort);
        return entries;
    };
    return QuickCommandAction;
}(BaseEditorQuickOpenAction));
registerEditorAction(QuickCommandAction);

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$U = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var ToggleHighContrast = /** @class */ (function (_super) {
    __extends$U(ToggleHighContrast, _super);
    function ToggleHighContrast() {
        var _this = _super.call(this, {
            id: 'editor.action.toggleHighContrast',
            label: localize('toggleHighContrast', "Toggle High Contrast Theme"),
            alias: 'Toggle High Contrast Theme',
            precondition: null
        }) || this;
        _this._originalThemeName = null;
        return _this;
    }
    ToggleHighContrast.prototype.run = function (accessor, editor) {
        var standaloneThemeService = accessor.get(IStandaloneThemeService);
        if (this._originalThemeName) {
            // We must toggle back to the integrator's theme
            standaloneThemeService.setTheme(this._originalThemeName);
            this._originalThemeName = null;
        }
        else {
            this._originalThemeName = standaloneThemeService.getTheme().themeName;
            standaloneThemeService.setTheme('hc-black');
        }
    };
    return ToggleHighContrast;
}(EditorAction));
registerEditorAction(ToggleHighContrast);

/**
 * (1) Features
 *
 * By default all the features are included
 * but you can comment out the ones you don't
 * need if you want to limit the size.
 *
 * NOTE: Changing requires rebuilding.
 *
 */

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var CodeActionKind = /** @class */ (function () {
    function CodeActionKind(value) {
        this.value = value;
    }
    CodeActionKind.prototype.contains = function (other) {
        return this.value === other || startsWith(other, this.value + CodeActionKind.sep);
    };
    CodeActionKind.sep = '.';
    CodeActionKind.Empty = new CodeActionKind('');
    CodeActionKind.Refactor = new CodeActionKind('refactor');
    CodeActionKind.Source = new CodeActionKind('source');
    CodeActionKind.SourceOrganizeImports = new CodeActionKind('source.organizeImports');
    return CodeActionKind;
}());
var CodeActionAutoApply;
(function (CodeActionAutoApply) {
    CodeActionAutoApply[CodeActionAutoApply["IfSingle"] = 1] = "IfSingle";
    CodeActionAutoApply[CodeActionAutoApply["First"] = 2] = "First";
    CodeActionAutoApply[CodeActionAutoApply["Never"] = 3] = "Never";
})(CodeActionAutoApply || (CodeActionAutoApply = {}));

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
function getCodeActions(model, range$$1, filter) {
    var codeActionContext = { only: filter && filter.kind ? filter.kind.value : undefined };
    var promises = CodeActionProviderRegistry.all(model).map(function (support) {
        return asWinJsPromise(function (token) { return support.provideCodeActions(model, range$$1, codeActionContext, token); }).then(function (providedCodeActions) {
            if (!Array.isArray(providedCodeActions)) {
                return [];
            }
            return providedCodeActions.filter(function (action) { return isValidAction(filter, action); });
        }, function (err) {
            onUnexpectedExternalError(err);
            return [];
        });
    });
    return TPromise.join(promises)
        .then(flatten)
        .then(function (allCodeActions) { return mergeSort(allCodeActions, codeActionsComparator); });
}
function isValidAction(filter, action) {
    if (!action) {
        return false;
    }
    // Filter out actions by kind
    if (filter && filter.kind && (!action.kind || !filter.kind.contains(action.kind))) {
        return false;
    }
    // Don't return source actions unless they are explicitly requested
    if (action.kind && CodeActionKind.Source.contains(action.kind) && (!filter || !filter.includeSourceActions)) {
        return false;
    }
    return true;
}
function codeActionsComparator(a, b) {
    var aHasDiags = !isFalsyOrEmpty(a.diagnostics);
    var bHasDiags = !isFalsyOrEmpty(b.diagnostics);
    if (aHasDiags) {
        if (bHasDiags) {
            return a.diagnostics[0].message.localeCompare(b.diagnostics[0].message);
        }
        else {
            return -1;
        }
    }
    else if (bHasDiags) {
        return 1;
    }
    else {
        return 0; // both have no diagnostics
    }
}
registerLanguageCommand('_executeCodeActionProvider', function (accessor, args) {
    var resource = args.resource, range$$1 = args.range;
    if (!(resource instanceof URI) || !Range.isIRange(range$$1)) {
        throw illegalArgument();
    }
    var model = accessor.get(IModelService).getModel(resource);
    if (!model) {
        throw illegalArgument();
    }
    return getCodeActions(model, model.validateRange(range$$1));
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var SUPPORTED_CODE_ACTIONS = new RawContextKey('supportedCodeAction', '');
var CodeActionOracle = /** @class */ (function () {
    function CodeActionOracle(_editor, _markerService, _signalChange, delay) {
        if (delay === void 0) { delay = 250; }
        var _this = this;
        this._editor = _editor;
        this._markerService = _markerService;
        this._signalChange = _signalChange;
        this._disposables = [];
        this._disposables.push(debounceEvent(this._markerService.onMarkerChanged, function (last, cur) { return last ? last.concat(cur) : cur; }, delay / 2)(function (e) { return _this._onMarkerChanges(e); }), debounceEvent(this._editor.onDidChangeCursorPosition, function (last, cur) { return cur; }, delay)(function (e) { return _this._onCursorChange(); }));
    }
    CodeActionOracle.prototype.dispose = function () {
        this._disposables = dispose(this._disposables);
    };
    CodeActionOracle.prototype.trigger = function (trigger) {
        var rangeOrSelection = this._getRangeOfMarker() || this._getRangeOfSelectionUnlessWhitespaceEnclosed();
        if (!rangeOrSelection && trigger.type === 'manual') {
            rangeOrSelection = this._editor.getSelection();
        }
        return this._createEventAndSignalChange(trigger, rangeOrSelection);
    };
    CodeActionOracle.prototype._onMarkerChanges = function (resources) {
        var uri = this._editor.getModel().uri;
        for (var _i = 0, resources_1 = resources; _i < resources_1.length; _i++) {
            var resource = resources_1[_i];
            if (resource.toString() === uri.toString()) {
                this.trigger({ type: 'auto' });
                return;
            }
        }
    };
    CodeActionOracle.prototype._onCursorChange = function () {
        this.trigger({ type: 'auto' });
    };
    CodeActionOracle.prototype._getRangeOfMarker = function () {
        var selection = this._editor.getSelection();
        var model = this._editor.getModel();
        for (var _i = 0, _a = this._markerService.read({ resource: model.uri }); _i < _a.length; _i++) {
            var marker = _a[_i];
            if (Range.intersectRanges(marker, selection)) {
                return Range.lift(marker);
            }
        }
        return undefined;
    };
    CodeActionOracle.prototype._getRangeOfSelectionUnlessWhitespaceEnclosed = function () {
        var model = this._editor.getModel();
        var selection = this._editor.getSelection();
        if (selection.isEmpty()) {
            var _a = selection.getPosition(), lineNumber = _a.lineNumber, column = _a.column;
            var line = model.getLineContent(lineNumber);
            if (line.length === 0) {
                // empty line
                return undefined;
            }
            else if (column === 1) {
                // look only right
                if (/\s/.test(line[0])) {
                    return undefined;
                }
            }
            else if (column === model.getLineMaxColumn(lineNumber)) {
                // look only left
                if (/\s/.test(line[line.length - 1])) {
                    return undefined;
                }
            }
            else {
                // look left and right
                if (/\s/.test(line[column - 2]) && /\s/.test(line[column - 1])) {
                    return undefined;
                }
            }
        }
        return selection;
    };
    CodeActionOracle.prototype._createEventAndSignalChange = function (trigger, rangeOrSelection) {
        if (!rangeOrSelection) {
            // cancel
            this._signalChange({
                trigger: trigger,
                range: undefined,
                position: undefined,
                actions: undefined,
            });
            return TPromise.as(undefined);
        }
        else {
            // actual
            var model = this._editor.getModel();
            var range$$1 = model.validateRange(rangeOrSelection);
            var position = rangeOrSelection instanceof Selection ? rangeOrSelection.getPosition() : rangeOrSelection.getStartPosition();
            var actions = getCodeActions(model, range$$1, trigger && trigger.filter);
            this._signalChange({
                trigger: trigger,
                range: range$$1,
                position: position,
                actions: actions
            });
            return actions;
        }
    };
    return CodeActionOracle;
}());
var CodeActionModel = /** @class */ (function () {
    function CodeActionModel(editor, markerService, contextKeyService) {
        var _this = this;
        this._onDidChangeFixes = new Emitter();
        this._disposables = [];
        this._editor = editor;
        this._markerService = markerService;
        this._supportedCodeActions = SUPPORTED_CODE_ACTIONS.bindTo(contextKeyService);
        this._disposables.push(this._editor.onDidChangeModel(function () { return _this._update(); }));
        this._disposables.push(this._editor.onDidChangeModelLanguage(function () { return _this._update(); }));
        this._disposables.push(CodeActionProviderRegistry.onDidChange(this._update, this));
        this._update();
    }
    CodeActionModel.prototype.dispose = function () {
        this._disposables = dispose(this._disposables);
        dispose(this._codeActionOracle);
    };
    Object.defineProperty(CodeActionModel.prototype, "onDidChangeFixes", {
        get: function () {
            return this._onDidChangeFixes.event;
        },
        enumerable: true,
        configurable: true
    });
    CodeActionModel.prototype._update = function () {
        var _this = this;
        if (this._codeActionOracle) {
            this._codeActionOracle.dispose();
            this._codeActionOracle = undefined;
            this._onDidChangeFixes.fire(undefined);
        }
        if (this._editor.getModel()
            && CodeActionProviderRegistry.has(this._editor.getModel())
            && !this._editor.getConfiguration().readOnly) {
            var supportedActions = [];
            for (var _i = 0, _a = CodeActionProviderRegistry.all(this._editor.getModel()); _i < _a.length; _i++) {
                var provider = _a[_i];
                if (Array.isArray(provider.providedCodeActionKinds)) {
                    supportedActions.push.apply(supportedActions, provider.providedCodeActionKinds);
                }
            }
            this._supportedCodeActions.set(supportedActions.join(' '));
            this._codeActionOracle = new CodeActionOracle(this._editor, this._markerService, function (p) { return _this._onDidChangeFixes.fire(p); });
            this._codeActionOracle.trigger({ type: 'auto' });
        }
        else {
            this._supportedCodeActions.reset();
        }
    };
    CodeActionModel.prototype.trigger = function (trigger) {
        if (this._codeActionOracle) {
            return this._codeActionOracle.trigger(trigger);
        }
        return TPromise.as(undefined);
    };
    return CodeActionModel;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var CodeActionContextMenu = /** @class */ (function () {
    function CodeActionContextMenu(_editor, _contextMenuService, _onApplyCodeAction) {
        this._editor = _editor;
        this._contextMenuService = _contextMenuService;
        this._onApplyCodeAction = _onApplyCodeAction;
        this._onDidExecuteCodeAction = new Emitter();
        this.onDidExecuteCodeAction = this._onDidExecuteCodeAction.event;
    }
    CodeActionContextMenu.prototype.show = function (fixes, at) {
        var _this = this;
        var actions = fixes.then(function (value) {
            return value.map(function (action) {
                return new Action(action.command ? action.command.id : action.title, action.title, undefined, true, function () {
                    return always(_this._onApplyCodeAction(action), function () { return _this._onDidExecuteCodeAction.fire(undefined); });
                });
            });
        }).then(function (actions) {
            if (!_this._editor.getDomNode()) {
                // cancel when editor went off-dom
                return TPromise.wrapError(canceled());
            }
            return actions;
        });
        this._contextMenuService.showContextMenu({
            getAnchor: function () {
                if (Position.isIPosition(at)) {
                    at = _this._toCoords(at);
                }
                return at;
            },
            getActions: function () { return actions; },
            onHide: function () { _this._visible = false; },
            autoSelectFirstItem: true
        });
    };
    Object.defineProperty(CodeActionContextMenu.prototype, "isVisible", {
        get: function () {
            return this._visible;
        },
        enumerable: true,
        configurable: true
    });
    CodeActionContextMenu.prototype._toCoords = function (position) {
        this._editor.revealPosition(position, 1 /* Immediate */);
        this._editor.render();
        // Translate to absolute editor position
        var cursorCoords = this._editor.getScrolledVisiblePosition(this._editor.getPosition());
        var editorCoords = getDomNodePagePosition(this._editor.getDomNode());
        var x = editorCoords.left + cursorCoords.left;
        var y = editorCoords.top + cursorCoords.top + cursorCoords.height;
        return { x: x, y: y };
    };
    return CodeActionContextMenu;
}());

const css$x = "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n.monaco-editor .lightbulb-glyph {\n\tdisplay: flex;\n\talign-items: center;\n\tjustify-content: center;\n\theight: 16px;\n\twidth: 20px;\n\tpadding-left: 2px;\n}\n\n.monaco-editor .lightbulb-glyph:hover {\n\tcursor: pointer;\n\t/* transform: scale(1.3, 1.3); */\n}\n\n.monaco-editor.vs .lightbulb-glyph {\n\tbackground: url(\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNiAxNiIgZW5hYmxlLWJhY2tncm91bmQ9Im5ldyAwIDAgMTYgMTYiIGhlaWdodD0iMTYiIHdpZHRoPSIxNiI+PHBhdGggZmlsbD0iI0Y2RjZGNiIgZD0iTTEzLjUgNC4yQzEzLjEgMi4xIDEwLjggMCA5LjMgMEg2LjdjLS40IDAtLjYuMi0uNi4yQzQgLjggMi41IDIuNyAyLjUgNC45YzAgLjUtLjEgMi4zIDEuNyAzLjguNS41IDEuMiAyIDEuMyAyLjR2My4zTDcuMSAxNmgybDEuNS0xLjZWMTFjLjEtLjQuOC0xLjkgMS4zLTIuMyAxLjEtLjkgMS41LTEuOSAxLjYtMi43VjQuMnoiLz48Zz48ZyBmaWxsPSIjODQ4NDg0Ij48cGF0aCBkPSJNNi41IDEyaDN2MWgtM3pNNy41IDE1aDEuMWwuOS0xaC0zeiIvPjwvZz48cGF0aCBmaWxsPSIjZmMwIiBkPSJNMTIuNiA1YzAtMi4zLTEuOC00LjEtNC4xLTQuMS0uMSAwLTEuNC4xLTEuNC4xLTIuMS4zLTMuNyAyLTMuNyA0IDAgLjEtLjIgMS42IDEuNCAzIC43LjcgMS41IDIuNCAxLjYgMi45bC4xLjFoM2wuMS0uMmMuMS0uNS45LTIuMiAxLjYtMi45IDEuNi0xLjMgMS40LTIuOCAxLjQtMi45em0tMyAxbC0uNSAzaC0uNlY2YzEuMSAwIC45LTEgLjktMUg2LjV2LjFjMCAuMi4xLjkgMSAuOXYzSDdsLS4yLS43TDYuNSA2Yy0uNyAwLS45LS40LTEtLjd2LS40YzAtLjguOS0uOS45LS45aDMuMXMxIC4xIDEgMWMwIDAgLjEgMS0uOSAxeiIvPjwvZz48cGF0aCBmaWxsPSIjRjBFRkYxIiBkPSJNMTAuNSA1YzAtLjktMS0xLTEtMUg2LjRzLS45LjEtLjkuOXYuNGMwIC4zLjMuNy45LjdsLjQgMi4zLjIuN2guNVY2Yy0xIDAtMS0uNy0xLS45VjVoM3MuMSAxLS45IDF2M2guNmwuNS0zYy45IDAgLjgtMSAuOC0xeiIvPjwvc3ZnPg==\") center center no-repeat;\n}\n\n.monaco-editor.vs-dark .lightbulb-glyph,\n.monaco-editor.hc-black .lightbulb-glyph {\n\tbackground: url(\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNiAxNiIgZW5hYmxlLWJhY2tncm91bmQ9Im5ldyAwIDAgMTYgMTYiIGhlaWdodD0iMTYiIHdpZHRoPSIxNiI+PHBhdGggZmlsbD0iIzFFMUUxRSIgZD0iTTEzLjUgNC4yQzEzLjEgMi4xIDEwLjggMCA5LjMgMEg2LjdjLS40IDAtLjYuMi0uNi4yQzQgLjggMi41IDIuNyAyLjUgNC45YzAgLjUtLjEgMi4zIDEuNyAzLjguNS41IDEuMiAyIDEuMyAyLjR2My4zTDcuMSAxNmgybDEuNS0xLjZWMTFjLjEtLjQuOC0xLjkgMS4zLTIuMyAxLjEtLjkgMS41LTEuOSAxLjYtMi43VjQuMnoiLz48Zz48ZyBmaWxsPSIjQzVDNUM1Ij48cGF0aCBkPSJNNi41IDEyaDN2MWgtM3pNNy41IDE1aDEuMWwuOS0xaC0zeiIvPjwvZz48cGF0aCBmaWxsPSIjRERCMjA0IiBkPSJNMTIuNiA1YzAtMi4zLTEuOC00LjEtNC4xLTQuMS0uMSAwLTEuNC4xLTEuNC4xLTIuMS4zLTMuNyAyLTMuNyA0IDAgLjEtLjIgMS42IDEuNCAzIC43LjcgMS41IDIuNCAxLjYgMi45bC4xLjFoM2wuMS0uMmMuMS0uNS45LTIuMiAxLjYtMi45IDEuNi0xLjMgMS40LTIuOCAxLjQtMi45em0tMyAxbC0uNSAzaC0uNlY2YzEuMSAwIC45LTEgLjktMUg2LjV2LjFjMCAuMi4xLjkgMSAuOXYzSDdsLS4yLS43TDYuNSA2Yy0uNyAwLS45LS40LTEtLjd2LS40YzAtLjguOS0uOS45LS45aDMuMXMxIC4xIDEgMWMwIDAgLjEgMS0uOSAxeiIvPjwvZz48cGF0aCBmaWxsPSIjMjUyNTI2IiBkPSJNMTAuNSA1YzAtLjktMS0xLTEtMUg2LjRzLS45LjEtLjkuOXYuNGMwIC4zLjMuNy45LjdsLjQgMi4zLjIuN2guNVY2Yy0xIDAtMS0uNy0xLS45VjVoM3MuMSAxLS45IDF2M2guNmwuNS0zYy45IDAgLjgtMSAuOC0xeiIvPjwvc3ZnPg==\") center center no-repeat;\n}\n";
  const element$x = ((css, src) => {
if (typeof document !== 'object')
console.info(`Skipped loading "${src}"`);
try {
const id = src
  .replace(/\.css.*$/, '')
  .replace(/[\\:]/g, '/')
  .replace(/[^\w\/]+/g, '');
return (
  document.querySelector(`style[id="${id}"]`) ||
  document.head.appendChild(
    Object.assign(document.createElement('style'), {
      id,
      textContent: `${css}\n\n /* sourceURL=${src} */`,
    }),
  )
);
} catch (exception) {
console.warn(`Failed load "${src}"`, exception);
}
})(css$x, "…monaco-editor/esm/vs/editor/contrib/codeAction/lightBulbWidget.css");
  //@ sourceURL=/Users/daflair/Projects/packages/monaco-es/node_modules/monaco-editor/esm/vs/editor/contrib/codeAction/lightBulbWidget.css

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var LightBulbWidget = /** @class */ (function () {
    function LightBulbWidget(editor) {
        var _this = this;
        this._disposables = [];
        this._onClick = new Emitter();
        this.onClick = this._onClick.event;
        this._futureFixes = new CancellationTokenSource();
        this._domNode = document.createElement('div');
        this._domNode.className = 'lightbulb-glyph';
        this._editor = editor;
        this._editor.addContentWidget(this);
        this._disposables.push(this._editor.onDidChangeModel(function (_) { return _this._futureFixes.cancel(); }));
        this._disposables.push(this._editor.onDidChangeModelLanguage(function (_) { return _this._futureFixes.cancel(); }));
        this._disposables.push(this._editor.onDidChangeModelContent(function (_) {
            // cancel when the line in question has been removed
            if (_this._model && _this.model.position.lineNumber >= _this._editor.getModel().getLineCount()) {
                _this._futureFixes.cancel();
            }
        }));
        this._disposables.push(addStandardDisposableListener(this._domNode, 'click', function (e) {
            // Make sure that focus / cursor location is not lost when clicking widget icon
            _this._editor.focus();
            // a bit of extra work to make sure the menu
            // doesn't cover the line-text
            var _a = getDomNodePagePosition(_this._domNode), top = _a.top, height = _a.height;
            var lineHeight = _this._editor.getConfiguration().lineHeight;
            var pad$$1 = Math.floor(lineHeight / 3);
            if (_this._position.position.lineNumber < _this._model.position.lineNumber) {
                pad$$1 += lineHeight;
            }
            _this._onClick.fire({
                x: e.posx,
                y: top + height + pad$$1
            });
        }));
        this._disposables.push(addDisposableListener(this._domNode, 'mouseenter', function (e) {
            if ((e.buttons & 1) !== 1) {
                return;
            }
            // mouse enters lightbulb while the primary/left button
            // is being pressed -> hide the lightbulb and block future
            // showings until mouse is released
            _this.hide();
            var monitor = new GlobalMouseMoveMonitor();
            monitor.startMonitoring(standardMouseMoveMerger, function () { }, function () {
                monitor.dispose();
            });
        }));
        this._disposables.push(this._editor.onDidChangeConfiguration(function (e) {
            // hide when told to do so
            if (e.contribInfo && !_this._editor.getConfiguration().contribInfo.lightbulbEnabled) {
                _this.hide();
            }
        }));
    }
    LightBulbWidget.prototype.dispose = function () {
        dispose(this._disposables);
        this._editor.removeContentWidget(this);
    };
    LightBulbWidget.prototype.getId = function () {
        return 'LightBulbWidget';
    };
    LightBulbWidget.prototype.getDomNode = function () {
        return this._domNode;
    };
    LightBulbWidget.prototype.getPosition = function () {
        return this._position;
    };
    Object.defineProperty(LightBulbWidget.prototype, "model", {
        get: function () {
            return this._model;
        },
        set: function (value) {
            var _this = this;
            if (this._position && (!value.position || this._position.position.lineNumber !== value.position.lineNumber)) {
                // hide when getting a 'hide'-request or when currently
                // showing on another line
                this.hide();
            }
            else if (this._futureFixes) {
                // cancel pending show request in any case
                this._futureFixes.cancel();
            }
            this._futureFixes = new CancellationTokenSource();
            var token = this._futureFixes.token;
            this._model = value;
            this._model.actions.done(function (fixes) {
                if (!token.isCancellationRequested && fixes && fixes.length > 0) {
                    _this._show();
                }
                else {
                    _this.hide();
                }
            }, function (err) {
                _this.hide();
            });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LightBulbWidget.prototype, "title", {
        get: function () {
            return this._domNode.title;
        },
        set: function (value) {
            this._domNode.title = value;
        },
        enumerable: true,
        configurable: true
    });
    LightBulbWidget.prototype._show = function () {
        var config = this._editor.getConfiguration();
        if (!config.contribInfo.lightbulbEnabled) {
            return;
        }
        var lineNumber = this._model.position.lineNumber;
        var model = this._editor.getModel();
        var tabSize = model.getOptions().tabSize;
        var lineContent = model.getLineContent(lineNumber);
        var indent = TextModel.computeIndentLevel(lineContent, tabSize);
        var lineHasSpace = config.fontInfo.spaceWidth * indent > 22;
        var effectiveLineNumber = lineNumber;
        if (!lineHasSpace) {
            if (lineNumber > 1) {
                effectiveLineNumber -= 1;
            }
            else {
                effectiveLineNumber += 1;
            }
        }
        this._position = {
            position: { lineNumber: effectiveLineNumber, column: 1 },
            preference: LightBulbWidget._posPref
        };
        this._editor.layoutContentWidget(this);
    };
    LightBulbWidget.prototype.hide = function () {
        this._position = null;
        this._model = null;
        this._futureFixes.cancel();
        this._editor.layoutContentWidget(this);
    };
    LightBulbWidget._posPref = [ContentWidgetPositionPreference.EXACT];
    return LightBulbWidget;
}());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends$V = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate$v = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$v = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var __awaiter$4 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator$4 = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
function contextKeyForSupportedActions(kind) {
    return ContextKeyExpr.regex(SUPPORTED_CODE_ACTIONS.keys()[0], new RegExp('(\\s|^)' + escapeRegExpCharacters(kind.value) + '\\b'));
}
var QuickFixController = /** @class */ (function () {
    function QuickFixController(editor, markerService, contextKeyService, _commandService, contextMenuService, _keybindingService, _textModelService, _fileService) {
        var _this = this;
        this._commandService = _commandService;
        this._keybindingService = _keybindingService;
        this._textModelService = _textModelService;
        this._fileService = _fileService;
        this._disposables = [];
        this._editor = editor;
        this._model = new CodeActionModel(this._editor, markerService, contextKeyService);
        this._codeActionContextMenu = new CodeActionContextMenu(editor, contextMenuService, function (action) { return _this._onApplyCodeAction(action); });
        this._lightBulbWidget = new LightBulbWidget(editor);
        this._updateLightBulbTitle();
        this._disposables.push(this._codeActionContextMenu.onDidExecuteCodeAction(function (_) { return _this._model.trigger({ type: 'auto', filter: {} }); }), this._lightBulbWidget.onClick(this._handleLightBulbSelect, this), this._model.onDidChangeFixes(function (e) { return _this._onCodeActionsEvent(e); }), this._keybindingService.onDidUpdateKeybindings(this._updateLightBulbTitle, this));
    }
    QuickFixController.get = function (editor) {
        return editor.getContribution(QuickFixController.ID);
    };
    QuickFixController.prototype.dispose = function () {
        this._model.dispose();
        dispose(this._disposables);
    };
    QuickFixController.prototype._onCodeActionsEvent = function (e) {
        var _this = this;
        if (e && e.trigger.filter && e.trigger.filter.kind) {
            // Triggered for specific scope
            // Apply if we only have one action or requested autoApply, otherwise show menu
            e.actions.then(function (fixes) {
                if (e.trigger.autoApply === CodeActionAutoApply.First || (e.trigger.autoApply === CodeActionAutoApply.IfSingle && fixes.length === 1)) {
                    _this._onApplyCodeAction(fixes[0]);
                }
                else {
                    _this._codeActionContextMenu.show(e.actions, e.position);
                }
            });
            return;
        }
        if (e && e.trigger.type === 'manual') {
            this._codeActionContextMenu.show(e.actions, e.position);
        }
        else if (e && e.actions) {
            // auto magically triggered
            // * update an existing list of code actions
            // * manage light bulb
            if (this._codeActionContextMenu.isVisible) {
                this._codeActionContextMenu.show(e.actions, e.position);
            }
            else {
                this._lightBulbWidget.model = e;
            }
        }
        else {
            this._lightBulbWidget.hide();
        }
    };
    QuickFixController.prototype.getId = function () {
        return QuickFixController.ID;
    };
    QuickFixController.prototype._handleLightBulbSelect = function (coords) {
        this._codeActionContextMenu.show(this._lightBulbWidget.model.actions, coords);
    };
    QuickFixController.prototype.triggerFromEditorSelection = function (filter, autoApply) {
        return this._model.trigger({ type: 'manual', filter: filter, autoApply: autoApply });
    };
    QuickFixController.prototype._updateLightBulbTitle = function () {
        var kb = this._keybindingService.lookupKeybinding(QuickFixAction.Id);
        var title;
        if (kb) {
            title = localize('quickFixWithKb', "Show Fixes ({0})", kb.getLabel());
        }
        else {
            title = localize('quickFix', "Show Fixes");
        }
        this._lightBulbWidget.title = title;
    };
    QuickFixController.prototype._onApplyCodeAction = function (action) {
        return __awaiter$4(this, void 0, TPromise, function () {
            return __generator$4(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, applyCodeAction(action, this._textModelService, this._fileService, this._commandService, this._editor)];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    QuickFixController.ID = 'editor.contrib.quickFixController';
    QuickFixController = __decorate$v([
        __param$v(1, IMarkerService),
        __param$v(2, IContextKeyService),
        __param$v(3, ICommandService),
        __param$v(4, IContextMenuService),
        __param$v(5, IKeybindingService),
        __param$v(6, ITextModelService),
        __param$v(7, optional(IFileService))
    ], QuickFixController);
    return QuickFixController;
}());
function applyCodeAction(action, textModelService, fileService, commandService, editor) {
    return __awaiter$4(this, void 0, void 0, function () {
        return __generator$4(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (!action.edit) return [3 /*break*/, 2];
                    return [4 /*yield*/, BulkEdit.perform(action.edit.edits, textModelService, fileService, editor)];
                case 1:
                    _a.sent();
                    _a.label = 2;
                case 2:
                    if (!action.command) return [3 /*break*/, 4];
                    return [4 /*yield*/, commandService.executeCommand.apply(commandService, [action.command.id].concat(action.command.arguments))];
                case 3:
                    _a.sent();
                    _a.label = 4;
                case 4: return [2 /*return*/];
            }
        });
    });
}
function showCodeActionsForEditorSelection(editor, notAvailableMessage, filter, autoApply) {
    var controller = QuickFixController.get(editor);
    if (!controller) {
        return;
    }
    var pos = editor.getPosition();
    controller.triggerFromEditorSelection(filter, autoApply).then(function (codeActions) {
        if (!codeActions || !codeActions.length) {
            MessageController.get(editor).showMessage(notAvailableMessage, pos);
        }
    });
}
var QuickFixAction = /** @class */ (function (_super) {
    __extends$V(QuickFixAction, _super);
    function QuickFixAction() {
        return _super.call(this, {
            id: QuickFixAction.Id,
            label: localize('quickfix.trigger.label', "Quick Fix..."),
            alias: 'Quick Fix',
            precondition: ContextKeyExpr.and(EditorContextKeys.writable, EditorContextKeys.hasCodeActionsProvider),
            kbOpts: {
                kbExpr: EditorContextKeys.editorTextFocus,
                primary: 2048 /* CtrlCmd */ | 84 /* US_DOT */
            }
        }) || this;
    }
    QuickFixAction.prototype.run = function (accessor, editor) {
        return showCodeActionsForEditorSelection(editor, localize('editor.action.quickFix.noneMessage', "No code actions available"));
    };
    QuickFixAction.Id = 'editor.action.quickFix';
    return QuickFixAction;
}(EditorAction));
var CodeActionCommandArgs = /** @class */ (function () {
    function CodeActionCommandArgs(kind, apply) {
        this.kind = kind;
        this.apply = apply;
    }
    CodeActionCommandArgs.fromUser = function (arg) {
        if (!arg || typeof arg !== 'object') {
            return new CodeActionCommandArgs(CodeActionKind.Empty, CodeActionAutoApply.IfSingle);
        }
        return new CodeActionCommandArgs(CodeActionCommandArgs.getKindFromUser(arg), CodeActionCommandArgs.getApplyFromUser(arg));
    };
    CodeActionCommandArgs.getApplyFromUser = function (arg) {
        switch (typeof arg.apply === 'string' ? arg.apply.toLowerCase() : '') {
            case 'first':
                return CodeActionAutoApply.First;
            case 'never':
                return CodeActionAutoApply.Never;
            case 'ifsingle':
            default:
                return CodeActionAutoApply.IfSingle;
        }
    };
    CodeActionCommandArgs.getKindFromUser = function (arg) {
        return typeof arg.kind === 'string'
            ? new CodeActionKind(arg.kind)
            : CodeActionKind.Empty;
    };
    return CodeActionCommandArgs;
}());
var CodeActionCommand = /** @class */ (function (_super) {
    __extends$V(CodeActionCommand, _super);
    function CodeActionCommand() {
        return _super.call(this, {
            id: CodeActionCommand.Id,
            precondition: ContextKeyExpr.and(EditorContextKeys.writable, EditorContextKeys.hasCodeActionsProvider)
        }) || this;
    }
    CodeActionCommand.prototype.runEditorCommand = function (accessor, editor, userArg) {
        var args = CodeActionCommandArgs.fromUser(userArg);
        return showCodeActionsForEditorSelection(editor, localize('editor.action.quickFix.noneMessage', "No code actions available"), { kind: args.kind, includeSourceActions: true }, args.apply);
    };
    CodeActionCommand.Id = 'editor.action.codeAction';
    return CodeActionCommand;
}(EditorCommand));
var RefactorAction = /** @class */ (function (_super) {
    __extends$V(RefactorAction, _super);
    function RefactorAction() {
        return _super.call(this, {
            id: RefactorAction.Id,
            label: localize('refactor.label', "Refactor..."),
            alias: 'Refactor',
            precondition: ContextKeyExpr.and(EditorContextKeys.writable, EditorContextKeys.hasCodeActionsProvider),
            kbOpts: {
                kbExpr: EditorContextKeys.editorTextFocus,
                primary: 256 /* WinCtrl */ | 1024 /* Shift */ | 48 /* KEY_R */
            },
            menuOpts: {
                group: '1_modification',
                order: 2,
                when: ContextKeyExpr.and(EditorContextKeys.writable, contextKeyForSupportedActions(CodeActionKind.Refactor)),
            }
        }) || this;
    }
    RefactorAction.prototype.run = function (accessor, editor) {
        return showCodeActionsForEditorSelection(editor, localize('editor.action.refactor.noneMessage', "No refactorings available"), { kind: CodeActionKind.Refactor }, CodeActionAutoApply.Never);
    };
    RefactorAction.Id = 'editor.action.refactor';
    return RefactorAction;
}(EditorAction));
var SourceAction = /** @class */ (function (_super) {
    __extends$V(SourceAction, _super);
    function SourceAction() {
        return _super.call(this, {
            id: SourceAction.Id,
            label: localize('source.label', "Source Action..."),
            alias: 'Source Action',
            precondition: ContextKeyExpr.and(EditorContextKeys.writable, EditorContextKeys.hasCodeActionsProvider),
            menuOpts: {
                group: '1_modification',
                order: 2.1,
                when: ContextKeyExpr.and(EditorContextKeys.writable, contextKeyForSupportedActions(CodeActionKind.Source)),
            }
        }) || this;
    }
    SourceAction.prototype.run = function (accessor, editor) {
        return showCodeActionsForEditorSelection(editor, localize('editor.action.source.noneMessage', "No source actions available"), { kind: CodeActionKind.Source, includeSourceActions: true }, CodeActionAutoApply.Never);
    };
    SourceAction.Id = 'editor.action.sourceAction';
    return SourceAction;
}(EditorAction));
var OrganizeImportsAction = /** @class */ (function (_super) {
    __extends$V(OrganizeImportsAction, _super);
    function OrganizeImportsAction() {
        return _super.call(this, {
            id: OrganizeImportsAction.Id,
            label: localize('organizeImports.label', "Organize Imports"),
            alias: 'Organize Imports',
            precondition: ContextKeyExpr.and(EditorContextKeys.writable, contextKeyForSupportedActions(CodeActionKind.SourceOrganizeImports)),
            kbOpts: {
                kbExpr: EditorContextKeys.editorTextFocus,
                primary: 1024 /* Shift */ | 512 /* Alt */ | 45 /* KEY_O */
            }
        }) || this;
    }
    OrganizeImportsAction.prototype.run = function (accessor, editor) {
        return showCodeActionsForEditorSelection(editor, localize('editor.action.organize.noneMessage', "No organize imports action available"), { kind: CodeActionKind.SourceOrganizeImports, includeSourceActions: true }, CodeActionAutoApply.IfSingle);
    };
    OrganizeImportsAction.Id = 'editor.action.organizeImports';
    return OrganizeImportsAction;
}(EditorAction));

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
registerEditorContribution(QuickFixController);
registerEditorAction(QuickFixAction);
registerEditorAction(RefactorAction);
registerEditorAction(SourceAction);
registerEditorAction(OrganizeImportsAction);
registerEditorCommand(new CodeActionCommand());

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
//# sourceMappingURL=monaco.js.map
